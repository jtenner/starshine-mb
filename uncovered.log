Total: 10980 uncovered line(s) in 96 file(s)

374 uncovered line(s) in src/binary/decode.mbt:

     | pub impl Decode for CompType with decode(bytes, i) {
     |   match bytes.get(i) {
     |     None => Err("Index out of bounds")
     |     Some(0x5E) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((ft, i)) => Ok((CompType::array(ft), i))
 115 |         Err(err) => Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x5F) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((fts, i)) => Ok((CompType::struct_(fts), i))
 120 |         Err(err) => Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x60) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((props, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((rets, i)) => Ok((CompType::func(props, rets), i))
 127 |             Err(err) => Err(err)
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 129 |         Err(err) => Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(_) => Err("Invalid Comp Type")
     |   }
     | }
     …

     | pub impl Decode for PackType with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x77) => Ok((PackType::i16(), i + 1))
     |     Some(0x78) => Ok((PackType::i8(), i + 1))
     |     Some(_) => Err("Invalid Packed Type")
 166 |     None => Err("Index out of bounds")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for SubType with decode(buf, i) {
     |   match buf.get(i) {
     |     // Final
     |     Some(0x4F) =>
     |       match Decode::decode(buf, i + 1) {
     |         Ok((idxs, i)) =>
     |           match Decode::decode(buf, i) {
     |             Ok((ct, i)) => Ok((SubType::new(true, idxs, ct), i))
 196 |             Err(err) => Err(err)
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Err(err) => Err(err)
     |       }
     |     // Subtypes
     |     Some(0x50) =>
     |       match Decode::decode(buf, i + 1) {
     |         Ok((idxs, i)) =>
     |           match Decode::decode(buf, i) {
     |             Ok((ct, i)) => Ok((SubType::new(false, idxs, ct), i))
 206 |             Err(err) => Err(err)
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 208 |         Err(err) => Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     // CompType, defer to comp type decoder
     |     Some(_) =>
     |       match Decode::decode(buf, i) {
     |         Ok((ct, i)) => Ok((SubType::comp_type(ct), i))
     |         Err(err) => Err(err)
     |       }
     |     None => Err("Index out of bounds")
     |   }
     | }
     …

     | fn decode_unsigned(
     |   bytes : Bytes,
     |   index : Int,
     |   nbits : Int,
     | ) -> Result[(UInt64, Int), String] {
     |   if nbits <= 0 || nbits > 64 {
     |     return Err("invalid nbits for uleb")
     |   }
     |   let max_bytes = max_leb_bytes(nbits)
     |   let mut i = index
     |   let mut shift = 0
     |   let mut acc : UInt64 = 0UL
     |   let mut count = 0
     |   while true {
     |     if i >= bytes.length() {
     |       return Err("unexpected EOF in uleb")
     |     }
     |     if count >= max_bytes {
     |       return Err("uleb too many bytes")
     |     }
     |     let byte_u : UInt64 = bytes[i].to_uint64()
     |     i += 1
     |     count += 1
     |     let payload : UInt64 = byte_u & 0x7fUL
     |     acc = acc | (payload << shift)
     |     let cont = (byte_u & 0x80UL) != 0UL
     |     shift = shift + 7
     |     if !cont {
     |       // range check
     |       if nbits < 64 {
     |         let max_val = (1UL << nbits) - 1UL
     |         if acc > max_val {
     |           return Err("uleb out of range for bit width")
     |         }
     |       }
     | 
     |       // terminal unused bits constraint - ONLY at max bytes
     |       if count == max_bytes {
     |         let rem = nbits % 7
     |         if rem != 0 {
     |           let limit = 1UL << rem
     |           if payload >= limit {
 263 |             return Err("uleb terminal byte has non-zero unused bits")
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |       return Ok((acc, i))
     |     }
     |   }
     |   Err("unreachable")
     | }
     …

     | fn decode_signed(
     |   bytes : Bytes,
     |   index : Int,
     |   nbits : Int,
     | ) -> Result[(Int64, Int), String] {
     |   if nbits <= 0 || nbits > 64 {
     |     return Err("invalid nbits for sleb")
     |   }
     |   let max_bytes = max_leb_bytes(nbits)
     |   let mut i = index
     |   let mut shift = 0
     |   let mut acc : Int64 = 0
     |   let mut count = 0
     |   let mut last_byte : UInt64 = 0
     |   while true {
     |     if i >= bytes.length() {
     |       return Err("unexpected EOF in sleb")
     |     }
     |     if count >= max_bytes {
     |       return Err("sleb too many bytes")
     |     }
     |     let byte_u = bytes[i].to_uint64()
     |     last_byte = byte_u
     |     i += 1
     |     count += 1
     |     let payload = (byte_u & 0x7f).reinterpret_as_int64()
     |     acc = acc | (payload << shift)
     |     let cont = (byte_u & 0x80) != 0
     |     shift += 7
     |     if !cont {
     |       break
     |     }
     |   }
     | 
     |   // sign extend to full int64 based on last byte's sign bit (0x40)
     |   if (last_byte & 0x40) != 0 && shift < 64 {
     |     acc = acc | ((-1 : Int64) << shift)
     |   }
     | 
     |   // range check for N bits signed
     |   if nbits < 64 {
     |     let min = (-1 : Int64) << (nbits - 1)
     |     let max = ((1 : Int64) << (nbits - 1)) - 1
     |     if acc < min || acc > max {
 318 |       return Err("sleb out of range for bit width")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   // terminal-byte unused bits constraint - ONLY at max bytes
     |   if count == max_bytes && nbits != 64 {
     |     let rem = nbits % 7
     |     if rem != 0 {
     |       let payload_u = last_byte & 0x7f
     |       let used_mask = (1UL << rem) - 1UL
     |       let inv_used = UInt64::lnot(used_mask) & 0x7fUL
     |       let unused = payload_u & inv_used
     |       if acc >= 0 {
     |         if unused != 0 {
 332 |           return Err("sleb terminal byte has non-zero unused bits for positive")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
     |         let want = inv_used
     |         if unused != want {
 337 |           return Err("sleb terminal byte has wrong sign-extension bits")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   }
     |   Ok((acc, i))
     | }
     …

     | pub impl Decode for S33 with decode(bytes, i) {
     |   match decode_signed(bytes, i, 33) {
     |     Err(err) => Err(err)
     |     Ok((val, i)) if val >= 0 && val < 4294967295 =>
     |       Ok((S33(val.to_int().reinterpret_as_uint()), i))
 351 |     Ok(_) => Err("Invalid S33 Range")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for I32 with decode(bytes, i) {
     |   match decode_signed(bytes, i, 32) {
 358 |     Err(err) => Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((val, i)) => Ok((I32(val.to_int()), i))
     |   }
     | }
     …

     | pub impl Decode for I64 with decode(bytes, i) {
     |   match decode_signed(bytes, i, 64) {
 374 |     Err(err) => Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((val, i)) => Ok((I64(val), i))
     |   }
     | }
     …

     | pub impl Decode for @lib.U64 with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 64) {
 382 |     Err(err) => Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((val, i)) => Ok((U64(val), i))
     |   }
     | }
     …

     | pub impl Decode for F32 with decode(bytes, i) {
     |   if bytes.length() >= i + 4 {
     |     let value : Int = (bytes.unsafe_get(i + 3).to_int() << 24) |
     |       (bytes.unsafe_get(i + 2).to_int() << 16) |
     |       (bytes.unsafe_get(i + 1).to_int() << 8) |
     |       bytes.unsafe_get(i).to_int()
     |     Ok((F32(Float::reinterpret_from_int(value)), i + 4))
     |   } else {
 396 |     Err("Index out of bounds")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for F64 with decode(bytes, i) {
     |   if bytes.length() >= i + 8 {
     |     let value : Int64 = (bytes.unsafe_get(i + 7).to_int64() << 56) |
     |       (bytes.unsafe_get(i + 6).to_int64() << 48) |
     |       (bytes.unsafe_get(i + 5).to_int64() << 40) |
     |       (bytes.unsafe_get(i + 4).to_int64() << 32) |
     |       (bytes.unsafe_get(i + 3).to_int64() << 24) |
     |       (bytes.unsafe_get(i + 2).to_int64() << 16) |
     |       (bytes.unsafe_get(i + 1).to_int64() << 8) |
     |       bytes.unsafe_get(i).to_int64()
     |     Ok((F64(value.reinterpret_as_double()), i + 8))
     |   } else {
 413 |     Err("Index out of bounds")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl[T : Decode] Decode for T? with decode(bytes, i) {
 429 |   match T::decode(bytes, i) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(_) => Ok((None, i))
     |     Ok((val, i)) => Ok((Some(val), i))
     |   }
     | }
     …

     | pub impl Decode for TypeIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 438 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((TypeIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for FuncIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 446 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((FuncIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for TableIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 454 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((TableIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for MemIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 462 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((MemIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for GlobalIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 470 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((GlobalIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for TagIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 478 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((TagIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for ElemIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 486 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((ElemIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for DataIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 494 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((DataIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for LocalIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 502 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((LocalIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for LabelIdx with decode(bytes, i) {
     |   match decode_unsigned(bytes, i, 32) {
 519 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((n, i)) => Ok((LabelIdx::new(n.to_uint()), i))
     |   }
     | }
     …

     | pub impl Decode for Name with decode(bytes, i) {
     |   let (@lib.U32(len_u), j) = match Decode::decode(bytes, i) {
 527 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(t) => t
     |   }
     |   let len = len_u.reinterpret_as_int()
     |   if len < 0 {
 532 |     return Err("negative name length")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let end = j + len
     |   if end > bytes.length() {
 536 |     return Err("Index out of bounds")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let name = @utf8.decode_lossy(bytes[j:end]).to_string_view()
     |   Ok((Name::new(name), end))
     | }
     …

     | fn[T : Decode] decode_section_vector_payload(
     |   bytes : Bytes,
     |   i : Int,
     |   section_id : Byte,
     | ) -> Result[(Array[T], Int), String] {
     |   if bytes.get(i) != Some(section_id) {
     |     return Err("Invalid section header")
     |   }
     |   let (@lib.U32(len_u), payload_start) = match Decode::decode(bytes, i + 1) {
     |     Ok(t) => t
 553 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let len = len_u.reinterpret_as_int()
     |   let payload_end = payload_start + len
     |   if payload_end > bytes.length() {
     |     return Err("Section payload length out of range")
     |   }
     |   let payload = bytes[payload_start:payload_end].to_bytes()
     |   let (content, consumed) = match Decode::decode(payload, 0) {
     |     Ok(t) => t
     |     Err(t) => return Err(t)
     |   }
     |   if consumed == len {
     |     Ok((content, payload_end))
     |   } else {
     |     Err("Invalid section - didn't consume all bytes")
     |   }
     | }
     …

     | pub impl Decode for Module with decode(bytes, i) {
     |   let mut i = i
     |   let custom = Array::new()
     |   let mut mod = Module::new()
     |   for b in [0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00] {
     |     if bytes.get(i) != Some(b.to_byte()) {
     |       return Err("Invalid magic header")
     |     }
     |     i = i + 1
     |   }
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
     |     Err(t) => return Err(t)
     |   }
     |   let (type_sec, next) = match decode_optional_section(bytes, i, 1) {
     |     Ok(t) => t
     |     Err(t) => return Err(t)
     |   }
     |   i = next
     |   if type_sec is Some(sec) {
     |     mod = mod.with_type_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 632 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (import_sec, next) = match decode_optional_section(bytes, i, 2) {
     |     Ok(t) => t
 636 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if import_sec is Some(sec) {
     |     mod = mod.with_import_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 645 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (func_sec, next) = match decode_optional_section(bytes, i, 3) {
     |     Ok(t) => t
 649 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if func_sec is Some(sec) {
     |     mod = mod.with_func_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 658 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (table_sec, next) = match decode_optional_section(bytes, i, 4) {
     |     Ok(t) => t
 662 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if table_sec is Some(sec) {
     |     mod = mod.with_table_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 671 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (mem_sec, next) = match decode_optional_section(bytes, i, 5) {
     |     Ok(t) => t
 675 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if mem_sec is Some(sec) {
     |     mod = mod.with_mem_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 684 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (tag_sec, next) = match decode_optional_section(bytes, i, 13) {
     |     Ok(t) => t
 688 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if tag_sec is Some(sec) {
     |     mod = mod.with_tag_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 697 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (global_sec, next) = match decode_optional_section(bytes, i, 6) {
     |     Ok(t) => t
 701 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if global_sec is Some(sec) {
     |     mod = mod.with_global_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 710 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (export_sec, next) = match decode_optional_section(bytes, i, 7) {
     |     Ok(t) => t
 714 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if export_sec is Some(sec) {
     |     mod = mod.with_export_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 723 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (start_sec, next) = match decode_optional_section(bytes, i, 8) {
     |     Ok(t) => t
 727 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if start_sec is Some(sec) {
     |     mod = mod.with_start_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 736 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (elem_sec, next) = match decode_optional_section(bytes, i, 9) {
     |     Ok(t) => t
 740 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if elem_sec is Some(sec) {
     |     mod = mod.with_elem_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 749 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (data_cnt_sec, next) = match decode_optional_section(bytes, i, 12) {
     |     Ok(t) => t
 753 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if data_cnt_sec is Some(sec) {
     |     mod = mod.with_data_cnt_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 762 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (code_sec, next) = match decode_optional_section(bytes, i, 10) {
     |     Ok(t) => t
 766 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if code_sec is Some(sec) {
     |     mod = mod.with_code_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 775 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (data_sec, next) = match decode_optional_section(bytes, i, 11) {
     |     Ok(t) => t
 779 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   i = next
     |   if data_sec is Some(sec) {
     |     mod = mod.with_data_sec(sec)
     |   }
     | 
     |   i = match decode_custom_sections(bytes, i, custom) {
     |     Ok(next) => next
 788 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   mod = mod.with_custom_secs(custom)
     |   if i == bytes.length() {
     |     Ok((mod, i))
     |   } else {
     |     Err("Invalid module")
     |   }
     | }
     …

     | pub impl Decode for Elem with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((expr, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((fidxs, i)) =>
     |               Ok(
     |                 (
     |                   Elem::new(
     |                     ElemMode::active(TableIdx::new(0), expr),
     |                     ElemKind::funcs(fidxs),
     |                   ),
     |                   i,
     |                 ),
     |               )
 816 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 818 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x01) =>
     |       match bytes.get(i + 1) {
     |         Some(0x00) =>
     |           match Decode::decode(bytes, i + 2) {
     |             Ok((fidxs, i)) =>
     |               Ok((Elem::new(ElemMode::passive(), ElemKind::funcs(fidxs)), i))
 826 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 828 |         _ => Err("Invalid elem header")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x02) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.TableIdx(idx), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((expr, i)) =>
     |               match bytes.get(i) {
     |                 Some(0x00) =>
     |                   match Decode::decode(bytes, i + 1) {
     |                     Ok((fidxs, i)) =>
     |                       Ok(
     |                         (
     |                           Elem::new(
     |                             ElemMode::active(TableIdx::new(idx), expr),
     |                             ElemKind::funcs(fidxs),
     |                           ),
     |                           i,
     |                         ),
     |                       )
 848 |                     Err(t) => Err(t)
     |                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
 850 |                 _ => Err("Invalid elem header")
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 852 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 854 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x03) =>
     |       match bytes.get(i + 1) {
     |         Some(0x00) =>
     |           match Decode::decode(bytes, i + 2) {
     |             Ok((fidxs, i)) =>
     |               Ok(
     |                 (Elem::new(ElemMode::declarative(), ElemKind::funcs(fidxs)), i),
     |               )
 864 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 866 |         _ => Err("Invalid elem header")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x04) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((expr, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((exprs, i)) =>
     |               Ok(
     |                 (
     |                   Elem::new(
     |                     ElemMode::active(TableIdx::new(0), expr),
     |                     ElemKind::func_exprs(exprs),
     |                   ),
     |                   i,
     |                 ),
     |               )
 882 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 884 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x05) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((rt, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((exprs, i)) =>
     |               Ok(
     |                 (
     |                   Elem::new(
     |                     ElemMode::passive(),
     |                     ElemKind::typed_exprs(rt, exprs),
     |                   ),
     |                   i,
     |                 ),
     |               )
 900 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 902 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x06) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((expr, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((exprs, i)) =>
     |                   Ok(
     |                     (
     |                       Elem::new(
     |                         ElemMode::active(idx, expr),
     |                         ElemKind::func_exprs(exprs),
     |                       ),
     |                       i,
     |                     ),
     |                   )
 920 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 922 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 924 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x07) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((rt, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((exprs, i)) =>
     |               Ok(
     |                 (
     |                   Elem::new(
     |                     ElemMode::declarative(),
     |                     ElemKind::typed_exprs(rt, exprs),
     |                   ),
     |                   i,
     |                 ),
     |               )
 940 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 942 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 944 |     Some(_) => Err("Invalid elem header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => Err("Index out of bounds")
     |   }
     | }
     …

     | pub impl Decode for ElemSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 9) {
     |     Ok((content, next)) => Ok((ElemSec::new(content), next))
 953 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for DataCntSec with decode(bytes, i) {
     |   if bytes.get(i) != Some(12) {
 960 |     return Err("Invalid section header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match Decode::decode(bytes, i + 1) {
     |     Ok((@lib.U32(count), i)) => Ok((DataCntSec::new(count), i))
 964 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for Locals with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((@lib.U32(count), i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((vt, i)) => Ok((Locals::new(count, vt), i))
 974 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 976 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for Func with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((@lib.U32(_size), i)) => // Read the length prefix first
     |       match Decode::decode(bytes, i) {
     |         Ok((locals, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((expr, i)) => Ok((Func::new(locals, expr), i))
 988 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 990 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 992 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for CodeSec with decode(bytes, i) {
     |   if bytes.get(i) != Some(10) {
 999 |     return Err("Invalid section header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match Decode::decode(bytes, i + 1) {
     |     Ok((funcs, i)) => Ok((CodeSec::new(funcs), i))
1003 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for Data with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((expr, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((bytes, i)) =>
     |               Ok((Data::new(DataMode::active(MemIdx::new(0), expr), bytes), i))
1016 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1018 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x01) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((bytes, i)) => Ok((Data::new(DataMode::passive(), bytes), i))
1023 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x02) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((expr, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((bytes, i)) =>
     |                   Ok((Data::new(DataMode::active(idx, expr), bytes), i))
1033 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1035 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1037 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1039 |     Some(_) => Err("Invalid data header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => Err("Index out of bounds")
     |   }
     | }
     …

     | pub impl Decode for DataSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 11) {
     |     Ok((content, next)) => Ok((DataSec::new(content), next))
1048 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for CustomSec with decode(bytes, i) {
     |   if bytes.get(i) != Some(0) {
1055 |     return Err("Invalid section header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (@lib.U32(len), i1) = match Decode::decode(bytes, i + 1) {
     |     Ok(t) => t
1059 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let len = len.reinterpret_as_int()
     |   let end = i1 + len
     |   if end > bytes.length() {
     |     return Err("Custom section payload length out of range")
     |   }
     |   let view = bytes[i1:end].to_bytes()
     |   let (name, j) = match Decode::decode(view, 0) {
     |     Ok(t) => t
1069 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let bytes = view[j:].to_bytes()
     |   Ok((CustomSec::new(name, bytes), end))
     | }
     …

     | pub impl Decode for Import with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((nm1, i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((nm2, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((et, i)) => Ok((Import::new(nm1, nm2, et), i))
1091 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1093 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1095 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for Limits with decode(bytes, i) {
     |   match bytes.get(i) {
1102 |     None => Err("Index out of bounds")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(0x00) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U64(n), i)) => Ok((Limits::i32(n.to_uint(), None), i))
1106 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x01) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U64(n), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((@lib.U64(m), i)) =>
     |               Ok((Limits::i32(n.to_uint(), Some(m.to_uint())), i))
1114 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1116 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x04) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U64(n), i)) => Ok((Limits::i64(n, None), i))
1121 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x05) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U64(n), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((@lib.U64(m), i)) => Ok((Limits::i64(n, Some(m)), i))
1128 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1130 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1132 |     Some(_) => Err("Invalid Limits")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for TableType with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((rt, i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((l, i)) => Ok((TableType::new(rt, l), i))
1142 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1144 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for MemType with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((l, i)) => Ok((MemType::new(l), i))
1152 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for GlobalType with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((vt, i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((m, i)) => Ok((GlobalType::new(vt, m), i))
1162 |         Err(_) => Ok((GlobalType::new(vt, false), i))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1164 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for TagType with decode(bytes, i) {
     |   if bytes.get(i) != Some(0x00) {
1171 |     return Err("Invalid TagType")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match Decode::decode(bytes, i + 1) {
     |     Ok((idx, i)) => Ok((TagType::new(idx), i))
1175 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for ExternType with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((ExternType::func(idx), i))
1185 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x01) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tt, i)) => Ok((ExternType::table(tt), i))
1190 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x02) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((mt, i)) => Ok((ExternType::mem(mt), i))
1195 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x03) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((gt, i)) => Ok((ExternType::global(gt), i))
1200 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x04) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tt, i)) => Ok((ExternType::tag(tt), i))
1205 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1207 |     Some(_) => Err("Invalid ExternType Header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => Err("Index out of bounds")
     |   }
     | }
     …

     | pub impl Decode for ImportSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 2) {
     |     Ok((content, next)) => Ok((ImportSec::new(content), next))
1218 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for FuncSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 3) {
     |     Ok((content, next)) => Ok((FuncSec::new(content), next))
1226 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for Expr with decode(bytes, i) {
     |   let a = Array::new()
     |   let i = loop i {
     |     i =>
     |       match Decode::decode(bytes, i) {
     |         Ok((inst, i)) => {
     |           a.push(inst)
     |           continue i
     |         }
     |         Err(_) if bytes.get(i) == Some(0x0B) => break i + 1
1255 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     |   Ok((Expr::new(a), i))
     | }
     …

     | pub impl Decode for Table with decode(bytes, i) {
     |   match (bytes.get(i), bytes.get(i + 1)) {
     |     (Some(0x40), Some(0x00)) =>
     |       match Decode::decode(bytes, i + 2) {
     |         Ok((tt, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((e, i)) => Ok((Table::new(tt, Some(e)), i))
1269 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1271 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ =>
     |       match Decode::decode(bytes, i) {
     |         Ok((tt, i)) => Ok((Table::new(tt, None), i))
1276 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | pub impl Decode for Global with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((gt, i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((expr, i)) => Ok((Global::new(gt, expr), i))
1287 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1289 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for ExternIdx with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((ExternIdx::func(idx), i))
1299 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x01) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((ExternIdx::table(idx), i))
1304 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x02) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((ExternIdx::mem(idx), i))
1309 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x03) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((ExternIdx::global(idx), i))
1314 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x04) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((ExternIdx::tag(idx), i))
1319 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1321 |     Some(_) => Err("Invalid extern index")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => Err("Index out of bounds")
     |   }
     | }
     …

     | pub impl Decode for Export with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((n, i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((idx, i)) => Ok((Export::new(n, idx), i))
1332 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1334 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for TableSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 4) {
     |     Ok((content, next)) => Ok((TableSec::new(content), next))
1342 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for MemSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 5) {
     |     Ok((content, next)) => Ok((MemSec::new(content), next))
1350 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for TagSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 13) {
     |     Ok((content, next)) => Ok((TagSec::new(content), next))
1358 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for GlobalSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 6) {
     |     Ok((content, next)) => Ok((GlobalSec::new(content), next))
1366 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for ExportSec with decode(bytes, i) {
     |   match decode_section_vector_payload(bytes, i, 7) {
     |     Ok((content, next)) => Ok((ExportSec::new(content), next))
1374 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for StartSec with decode(bytes, i) {
     |   if bytes.get(i) != Some(8) {
1381 |     return Err("Invalid section header")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match Decode::decode(bytes, i + 1) {
1384 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((idx, i)) => Ok((StartSec::new(idx), i))
     |   }
     | }
     …

     | pub impl Decode for Bytes with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
1392 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((@lib.U32(len), i)) if len + i.reinterpret_as_uint() <=
     |       bytes.length().reinterpret_as_uint() => {
     |       let next = i + len.reinterpret_as_int()
     |       let val = bytes[i:next].to_bytes()
     |       Ok((val, next))
     |     }
1399 |     Ok(_) => Err("Invalid offset.")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for Catch with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tidx, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((lidx, i)) => Ok((Catch::new(tidx, lidx), i))
1411 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1413 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x01) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tidx, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((lidx, i)) => Ok((Catch::ref_(tidx, lidx), i))
1420 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1422 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x02) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Catch::all(idx), i))
1427 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x03) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Catch::all_ref(idx), i))
1432 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1434 |     _ => Err("Invalid catch")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for CastOp with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) => Ok((CastOp::new(false, false), i + 1))
     |     Some(0x01) => Ok((CastOp::new(true, false), i + 1))
     |     Some(0x02) => Ok((CastOp::new(false, true), i + 1))
     |     Some(0x03) => Ok((CastOp::new(true, true), i + 1))
1445 |     _ => Err("Invalid castop")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Decode for MemArg with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
     |     Ok((@lib.U32(n), i)) if n >= 64 && n < 128 =>
     |       match Decode::decode(bytes, i) {
     |         Ok((x, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((@lib.U64(m), i)) => Ok((MemArg::new(n - 64, Some(x), m), i))
1457 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1459 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Ok((@lib.U32(n), i)) if n < 64 =>
     |       match Decode::decode(bytes, i) {
     |         Ok((@lib.U64(m), i)) => Ok((MemArg::new(n, None, m), i))
1464 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1466 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => Err("Invalid memarg")
     |   }
     | }
     …

     | pub impl Decode for Instruction with decode(bytes, i) {
     |   match bytes.get(i) {
     |     Some(0x00) => Ok((Instruction::unreachable_(), i + 1))
     |     Some(0x01) => Ok((Instruction::nop(), i + 1))
     |     Some(0x1A) => Ok((Instruction::drop(), i + 1))
     |     Some(0x1B) => Ok((Instruction::select(types=None), i + 1))
     |     Some(0x1C) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((vts, i)) => Ok((Instruction::select(types=Some(vts)), i))
1481 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x02) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((bt, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((expr, i)) => Ok((Instruction::block(bt, expr), i))
1488 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1490 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x03) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((bt, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((expr, i)) => Ok((Instruction::loop_(bt, expr), i))
1497 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1499 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x04) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((bt, i)) => {
     |           let (if_inst, i) = loop (i, [], None) {
     |             (i, if_insts, Some(else_insts)) =>
     |               match bytes.get(i) {
     |                 Some(0x0B) =>
     |                   break (
     |                     Instruction::if_(bt, if_insts, Some(else_insts)),
     |                     i + 1,
     |                   )
     |                 _ =>
     |                   match Decode::decode(bytes, i) {
     |                     Ok((inst, i)) => {
     |                       else_insts.push(inst)
     |                       continue (i, if_insts, Some(else_insts))
     |                     }
1518 |                     Err(t) => return Err(t)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |               }
     |             (i, if_insts, None) =>
     |               match bytes.get(i) {
     |                 Some(0x05) => continue (i + 1, if_insts, Some([]))
     |                 Some(0x0B) =>
     |                   break (Instruction::if_(bt, if_insts, None), i + 1)
     |                 _ =>
     |                   match Decode::decode(bytes, i) {
     |                     Ok((inst, i)) => {
     |                       if_insts.push(inst)
     |                       continue (i, if_insts, None)
     |                     }
1532 |                     Err(t) => return Err(t)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |               }
     |           }
     |           Ok((if_inst, i))
     |         }
1538 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x08) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tag, i)) => Ok((Instruction::throw_(tag), i))
1543 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x0A) => Ok((Instruction::throw_ref(), i + 1))
     |     Some(0x0C) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((lbl, i)) => Ok((Instruction::br(lbl), i))
1549 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x0D) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((lbl, i)) => Ok((Instruction::br_if(lbl), i))
1554 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x0E) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((lbls, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((lbl, i)) => Ok((Instruction::br_table(lbls, lbl), i))
1561 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1563 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x0F) => Ok((Instruction::return_(), i + 1))
     |     Some(0x10) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::call(idx), i))
1569 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x11) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tidx, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((tblidx, i)) => Ok((Instruction::call_indirect(tidx, tblidx), i))
1576 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1578 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x12) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::return_call(idx), i))
1583 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x13) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tidx, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((tblidx, i)) =>
     |               Ok((Instruction::return_call_indirect(tidx, tblidx), i))
1591 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1593 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x14) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tidx, i)) => Ok((Instruction::call_ref(tidx), i))
1598 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x15) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((tidx, i)) => Ok((Instruction::return_call_ref(tidx), i))
1603 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x1F) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((bt, i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((c, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((e, i)) => Ok((Instruction::try_table(bt, c, e), i))
1612 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1614 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1616 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0xD5) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::br_on_null(idx), i))
1621 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0xD6) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::br_on_non_null(idx), i))
1626 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x20) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::local_get(idx), i))
1631 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x21) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::local_set(idx), i))
1636 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x22) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::local_tee(idx), i))
1641 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x23) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::global_get(idx), i))
1646 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x24) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::global_set(idx), i))
1651 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x25) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::table_get(idx), i))
1656 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x26) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((idx, i)) => Ok((Instruction::table_set(idx), i))
1661 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x28) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_load(m), i))
1666 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x29) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load(m), i))
1671 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x2A) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::f32_load(m), i))
1676 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x2B) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::f64_load(m), i))
1681 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x2C) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_load8s(m), i))
1686 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x2D) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_load8u(m), i))
1691 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x2E) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_load16s(m), i))
1696 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x2F) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_load16u(m), i))
1701 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x30) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load8s(m), i))
1706 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x31) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load8u(m), i))
1711 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x32) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load16s(m), i))
1716 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x33) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load16u(m), i))
1721 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x34) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load32s(m), i))
1726 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x35) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_load32u(m), i))
1731 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x36) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_store(m), i))
1736 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x37) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_store(m), i))
1741 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x38) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::f32_store(m), i))
1746 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x39) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::f64_store(m), i))
1751 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x3A) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_store8(m), i))
1756 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x3B) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i32_store16(m), i))
1761 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x3C) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_store8(m), i))
1766 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x3D) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_store16(m), i))
1771 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x3E) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((m, i)) => Ok((Instruction::i64_store32(m), i))
1776 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x3F) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((x, i)) => Ok((Instruction::memory_size(x), i))
1781 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x40) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((x, i)) => Ok((Instruction::memory_grow(x), i))
1786 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0xD0) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((ht, i)) => Ok((Instruction::ref_null(ht), i))
1791 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0xD1) => Ok((Instruction::ref_is_null(), i + 1))
     |     Some(0xD2) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((x, i)) => Ok((Instruction::ref_func(x), i))
1797 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0xD3) => Ok((Instruction::ref_eq(), i + 1))
     |     Some(0xD4) => Ok((Instruction::ref_as_non_null(), i + 1))
     |     Some(0x45) => Ok((Instruction::i32_eqz(), i + 1))
     |     Some(0x46) => Ok((Instruction::i32_eq(), i + 1))
     |     Some(0x47) => Ok((Instruction::i32_ne(), i + 1))
     |     Some(0x48) => Ok((Instruction::i32_lt_s(), i + 1))
     |     Some(0x49) => Ok((Instruction::i32_lt_u(), i + 1))
     |     Some(0x4A) => Ok((Instruction::i32_gt_s(), i + 1))
     |     Some(0x4B) => Ok((Instruction::i32_gt_u(), i + 1))
     |     Some(0x4C) => Ok((Instruction::i32_le_s(), i + 1))
     |     Some(0x4D) => Ok((Instruction::i32_le_u(), i + 1))
     |     Some(0x4E) => Ok((Instruction::i32_ge_s(), i + 1))
     |     Some(0x4F) => Ok((Instruction::i32_ge_u(), i + 1))
     |     Some(0x50) => Ok((Instruction::i64_eqz(), i + 1))
     |     Some(0x51) => Ok((Instruction::i64_eq(), i + 1))
     |     Some(0x52) => Ok((Instruction::i64_ne(), i + 1))
     |     Some(0x53) => Ok((Instruction::i64_lt_s(), i + 1))
     |     Some(0x54) => Ok((Instruction::i64_lt_u(), i + 1))
     |     Some(0x55) => Ok((Instruction::i64_gt_s(), i + 1))
     |     Some(0x56) => Ok((Instruction::i64_gt_u(), i + 1))
     |     Some(0x57) => Ok((Instruction::i64_le_s(), i + 1))
     |     Some(0x58) => Ok((Instruction::i64_le_u(), i + 1))
     |     Some(0x59) => Ok((Instruction::i64_ge_s(), i + 1))
     |     Some(0x5A) => Ok((Instruction::i64_ge_u(), i + 1))
     |     Some(0x5B) => Ok((Instruction::f32_eq(), i + 1))
     |     Some(0x5C) => Ok((Instruction::f32_ne(), i + 1))
     |     Some(0x5D) => Ok((Instruction::f32_lt(), i + 1))
     |     Some(0x5E) => Ok((Instruction::f32_gt(), i + 1))
     |     Some(0x5F) => Ok((Instruction::f32_le(), i + 1))
     |     Some(0x60) => Ok((Instruction::f32_ge(), i + 1))
     |     Some(0x61) => Ok((Instruction::f64_eq(), i + 1))
     |     Some(0x62) => Ok((Instruction::f64_ne(), i + 1))
     |     Some(0x63) => Ok((Instruction::f64_lt(), i + 1))
     |     Some(0x64) => Ok((Instruction::f64_gt(), i + 1))
     |     Some(0x65) => Ok((Instruction::f64_le(), i + 1))
     |     Some(0x66) => Ok((Instruction::f64_ge(), i + 1))
     |     Some(0x67) => Ok((Instruction::i32_clz(), i + 1))
     |     Some(0x68) => Ok((Instruction::i32_ctz(), i + 1))
     |     Some(0x69) => Ok((Instruction::i32_popcnt(), i + 1))
     |     Some(0x6A) => Ok((Instruction::i32_add(), i + 1))
     |     Some(0x6B) => Ok((Instruction::i32_sub(), i + 1))
     |     Some(0x6C) => Ok((Instruction::i32_mul(), i + 1))
     |     Some(0x6D) => Ok((Instruction::i32_div_s(), i + 1))
     |     Some(0x6E) => Ok((Instruction::i32_div_u(), i + 1))
     |     Some(0x6F) => Ok((Instruction::i32_rem_s(), i + 1))
     |     Some(0x70) => Ok((Instruction::i32_rem_u(), i + 1))
     |     Some(0x71) => Ok((Instruction::i32_and(), i + 1))
     |     Some(0x72) => Ok((Instruction::i32_or(), i + 1))
     |     Some(0x73) => Ok((Instruction::i32_xor(), i + 1))
     |     Some(0x74) => Ok((Instruction::i32_shl(), i + 1))
     |     Some(0x75) => Ok((Instruction::i32_shr_s(), i + 1))
     |     Some(0x76) => Ok((Instruction::i32_shr_u(), i + 1))
     |     Some(0x77) => Ok((Instruction::i32_rotl(), i + 1))
     |     Some(0x78) => Ok((Instruction::i32_rotr(), i + 1))
     |     Some(0x79) => Ok((Instruction::i64_clz(), i + 1))
     |     Some(0x7A) => Ok((Instruction::i64_ctz(), i + 1))
     |     Some(0x7B) => Ok((Instruction::i64_popcnt(), i + 1))
     |     Some(0x7C) => Ok((Instruction::i64_add(), i + 1))
     |     Some(0x7D) => Ok((Instruction::i64_sub(), i + 1))
     |     Some(0x7E) => Ok((Instruction::i64_mul(), i + 1))
     |     Some(0x7F) => Ok((Instruction::i64_div_s(), i + 1))
     |     Some(0x80) => Ok((Instruction::i64_div_u(), i + 1))
     |     Some(0x81) => Ok((Instruction::i64_rem_s(), i + 1))
     |     Some(0x82) => Ok((Instruction::i64_rem_u(), i + 1))
     |     Some(0x83) => Ok((Instruction::i64_and(), i + 1))
     |     Some(0x84) => Ok((Instruction::i64_or(), i + 1))
     |     Some(0x85) => Ok((Instruction::i64_xor(), i + 1))
     |     Some(0x86) => Ok((Instruction::i64_shl(), i + 1))
     |     Some(0x87) => Ok((Instruction::i64_shr_s(), i + 1))
     |     Some(0x88) => Ok((Instruction::i64_shr_u(), i + 1))
     |     Some(0x89) => Ok((Instruction::i64_rotl(), i + 1))
     |     Some(0x8A) => Ok((Instruction::i64_rotr(), i + 1))
     |     Some(0x8B) => Ok((Instruction::f32_abs(), i + 1))
     |     Some(0x8C) => Ok((Instruction::f32_neg(), i + 1))
     |     Some(0x8D) => Ok((Instruction::f32_ceil(), i + 1))
     |     Some(0x8E) => Ok((Instruction::f32_floor(), i + 1))
     |     Some(0x8F) => Ok((Instruction::f32_trunc(), i + 1))
     |     Some(0x90) => Ok((Instruction::f32_nearest(), i + 1))
     |     Some(0x91) => Ok((Instruction::f32_sqrt(), i + 1))
     |     Some(0x92) => Ok((Instruction::f32_add(), i + 1))
     |     Some(0x93) => Ok((Instruction::f32_sub(), i + 1))
     |     Some(0x94) => Ok((Instruction::f32_mul(), i + 1))
     |     Some(0x95) => Ok((Instruction::f32_div(), i + 1))
     |     Some(0x96) => Ok((Instruction::f32_min(), i + 1))
     |     Some(0x97) => Ok((Instruction::f32_max(), i + 1))
     |     Some(0x98) => Ok((Instruction::f32_copysign(), i + 1))
     |     Some(0x99) => Ok((Instruction::f64_abs(), i + 1))
     |     Some(0x9A) => Ok((Instruction::f64_neg(), i + 1))
     |     Some(0x9B) => Ok((Instruction::f64_ceil(), i + 1))
     |     Some(0x9C) => Ok((Instruction::f64_floor(), i + 1))
     |     Some(0x9D) => Ok((Instruction::f64_trunc(), i + 1))
     |     Some(0x9E) => Ok((Instruction::f64_nearest(), i + 1))
     |     Some(0x9F) => Ok((Instruction::f64_sqrt(), i + 1))
     |     Some(0xA0) => Ok((Instruction::f64_add(), i + 1))
     |     Some(0xA1) => Ok((Instruction::f64_sub(), i + 1))
     |     Some(0xA2) => Ok((Instruction::f64_mul(), i + 1))
     |     Some(0xA3) => Ok((Instruction::f64_div(), i + 1))
     |     Some(0xA4) => Ok((Instruction::f64_min(), i + 1))
     |     Some(0xA5) => Ok((Instruction::f64_max(), i + 1))
     |     Some(0xA6) => Ok((Instruction::f64_copysign(), i + 1))
     |     Some(0xA7) => Ok((Instruction::i32_wrap_i64(), i + 1))
     |     Some(0xA8) => Ok((Instruction::i32_trunc_f32s(), i + 1))
     |     Some(0xA9) => Ok((Instruction::i32_trunc_f32u(), i + 1))
     |     Some(0xAA) => Ok((Instruction::i32_trunc_f64s(), i + 1))
     |     Some(0xAB) => Ok((Instruction::i32_trunc_f64u(), i + 1))
     |     Some(0xAC) => Ok((Instruction::i64_extend_i32s(), i + 1))
     |     Some(0xAD) => Ok((Instruction::i64_extend_i32u(), i + 1))
     |     Some(0xAE) => Ok((Instruction::i64_trunc_f32s(), i + 1))
     |     Some(0xAF) => Ok((Instruction::i64_trunc_f32u(), i + 1))
     |     Some(0xB0) => Ok((Instruction::i64_trunc_f64s(), i + 1))
     |     Some(0xB1) => Ok((Instruction::i64_trunc_f64u(), i + 1))
     |     Some(0xB2) => Ok((Instruction::f32_convert_i32s(), i + 1))
     |     Some(0xB3) => Ok((Instruction::f32_convert_i32u(), i + 1))
     |     Some(0xB4) => Ok((Instruction::f32_convert_i64s(), i + 1))
     |     Some(0xB5) => Ok((Instruction::f32_convert_i64u(), i + 1))
     |     Some(0xB6) => Ok((Instruction::f32_demote_f64(), i + 1))
     |     Some(0xB7) => Ok((Instruction::f64_convert_i32s(), i + 1))
     |     Some(0xB8) => Ok((Instruction::f64_convert_i32u(), i + 1))
     |     Some(0xB9) => Ok((Instruction::f64_convert_i64s(), i + 1))
     |     Some(0xBA) => Ok((Instruction::f64_convert_i64u(), i + 1))
     |     Some(0xBB) => Ok((Instruction::f64_promote_f32(), i + 1))
     |     Some(0xBC) => Ok((Instruction::i32_reinterpret_f32(), i + 1))
     |     Some(0xBD) => Ok((Instruction::i64_reinterpret_f64(), i + 1))
     |     Some(0xBE) => Ok((Instruction::f32_reinterpret_i32(), i + 1))
     |     Some(0xBF) => Ok((Instruction::f64_reinterpret_i64(), i + 1))
     |     Some(0xC0) => Ok((Instruction::i32_extend8s(), i + 1))
     |     Some(0xC1) => Ok((Instruction::i32_extend16s(), i + 1))
     |     Some(0xC2) => Ok((Instruction::i64_extend8s(), i + 1))
     |     Some(0xC3) => Ok((Instruction::i64_extend16s(), i + 1))
     |     Some(0xC4) => Ok((Instruction::i64_extend32s(), i + 1))
     |     Some(0x41) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((n, i)) => Ok((Instruction::i32_const(n), i))
1932 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x42) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((n, i)) => Ok((Instruction::i64_const(n), i))
1937 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x43) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((n, i)) => Ok((Instruction::f32_const(n), i))
1942 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Some(0x44) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((n, i)) => Ok((Instruction::f64_const(n), i))
1947 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |     // Section: Control Flow/Aggregate 0xFB
     |     Some(0xFB) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U32(0), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::struct_new(x), i))
1956 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(1), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::struct_new_default(x), i))
1961 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(2), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::struct_get(x, n), i))
1968 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1970 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(3), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::struct_get_s(x, n), i))
1977 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1979 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(4), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::struct_get_u(x, n), i))
1986 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1988 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(5), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::struct_set(x, n), i))
1995 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1997 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(6), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_new(x), i))
2002 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(7), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_new_default(x), i))
2007 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(8), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::array_new_fixed(x, n), i))
2014 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2016 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(9), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::array_new_data(x, n), i))
2023 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2025 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(10), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((n, i)) => Ok((Instruction::array_new_elem(x, n), i))
2032 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2034 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(11), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_get(x), i))
2039 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(12), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_get_s(x), i))
2044 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(13), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_get_u(x), i))
2049 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(14), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_set(x), i))
2054 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(15), i)) => Ok((Instruction::array_len(), i))
     |         Ok((@lib.U32(16), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::array_fill(x), i))
2060 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(17), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x1, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((x2, i)) => Ok((Instruction::array_copy(x1, x2), i))
2067 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2069 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(18), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x1, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((x2, i)) => Ok((Instruction::array_init_data(x1, x2), i))
2076 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2078 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(19), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x1, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((x2, i)) => Ok((Instruction::array_init_elem(x1, x2), i))
2085 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2087 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(20), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_test(false, ht), i))
2092 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(21), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_test(true, ht), i))
2097 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(22), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_cast(false, ht), i))
2102 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(23), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_cast(true, ht), i))
2107 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(24), i)) => {
     |           let castop : Result[(CastOp, Int), String] = Decode::decode(bytes, i)
     |           match castop {
     |             Ok((c, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) =>
     |                   match Decode::decode(bytes, i) {
     |                     Ok((ht1, i)) =>
     |                       match Decode::decode(bytes, i) {
     |                         Ok((ht2, i)) =>
     |                           Ok(
     |                             (Instruction::br_on_cast(l, c.0, ht1, c.1, ht2), i),
     |                           )
2122 |                         Err(t) => Err(t)
     |                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
2124 |                     Err(t) => Err(t)
     |                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
2126 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2128 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         Ok((U32(25), i)) => {
     |           let castop : Result[(CastOp, Int), String] = Decode::decode(bytes, i)
     |           match castop {
     |             Ok((c, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) =>
     |                   match Decode::decode(bytes, i) {
     |                     Ok((ht1, i)) =>
     |                       match Decode::decode(bytes, i) {
     |                         Ok((ht2, i)) =>
     |                           Ok(
     |                             (
     |                               Instruction::br_on_cast_fail(
     |                                 l,
     |                                 c.0,
     |                                 ht1,
     |                                 c.1,
     |                                 ht2,
     |                               ),
     |                               i,
     |                             ),
     |                           )
2153 |                         Err(t) => Err(t)
     |                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
2155 |                     Err(t) => Err(t)
     |                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
2157 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2159 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         Ok((U32(26), i)) => Ok((Instruction::any_convert_extern(), i))
     |         Ok((U32(27), i)) => Ok((Instruction::extern_convert_any(), i))
     |         Ok((U32(28), i)) => Ok((Instruction::ref_i31(), i))
     |         Ok((U32(29), i)) => Ok((Instruction::i31_get_s(), i))
     |         Ok((U32(30), i)) => Ok((Instruction::i31_get_u(), i))
     |         Ok((U32(31), i)) => Ok((Instruction::ref_get_desc(), i))
     |         Ok((@lib.U32(32), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_test_desc(false, ht), i))
2171 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(33), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_test_desc(true, ht), i))
2176 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(34), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_cast_desc_eq(false, ht), i))
2181 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(35), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((ht, i)) => Ok((Instruction::ref_cast_desc_eq(true, ht), i))
2186 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
2188 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => Err("Invalid instruction")
     |       }
     | 
     |     // Section: Memory/Table/Elem
     |     Some(0xFC) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U32(0), i)) => Ok((Instruction::i32_trunc_sat_f32s(), i))
     |         Ok((U32(1), i)) => Ok((Instruction::i32_trunc_sat_f32u(), i))
     |         Ok((U32(2), i)) => Ok((Instruction::i32_trunc_sat_f64s(), i))
     |         Ok((U32(3), i)) => Ok((Instruction::i32_trunc_sat_f64u(), i))
     |         Ok((U32(4), i)) => Ok((Instruction::i64_trunc_sat_f32s(), i))
     |         Ok((U32(5), i)) => Ok((Instruction::i64_trunc_sat_f32u(), i))
     |         Ok((U32(6), i)) => Ok((Instruction::i64_trunc_sat_f64s(), i))
     |         Ok((U32(7), i)) => Ok((Instruction::i64_trunc_sat_f64u(), i))
     |         Ok((U32(8), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((y, i)) => Ok((Instruction::memory_init(x, y), i))
2208 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2210 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(9), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::data_drop(x), i))
2215 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(10), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((y, i)) => Ok((Instruction::memory_copy(x, y), i))
2222 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2224 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(11), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) => Ok((Instruction::memory_fill(x), i))
2229 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(12), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((y, i)) => Ok((Instruction::table_init(x, y), i))
2236 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2238 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(13), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((y, i)) => Ok((Instruction::elem_drop(y), i))
2243 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(14), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((x, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((y, i)) => Ok((Instruction::table_copy(x, y), i))
2250 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2252 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(15), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((y, i)) => Ok((Instruction::table_grow(y), i))
2257 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(16), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((y, i)) => Ok((Instruction::table_size(y), i))
2262 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(17), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((y, i)) => Ok((Instruction::table_fill(y), i))
2267 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
2269 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => Err("Invalid Instruction")
     |       }
     | 
     |     // Section: Threads atomics
     |     Some(0xFE) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U32(0), i)) =>
2277 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::memory_atomic_notify(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(1), i)) =>
2282 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::memory_atomic_wait32(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(2), i)) =>
2287 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::memory_atomic_wait64(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(3), i)) =>
     |           match bytes.get(i) {
2293 |             Some(0x00) => Ok((Instruction::atomic_fence(), i + 1))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ => Err("Invalid atomic.fence immediate")
     |           }
     |         Ok((@lib.U32(16), i)) =>
2297 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i32_atomic_load(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(17), i)) =>
2302 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_load(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(18), i)) =>
2307 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i32_atomic_load8_u(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(19), i)) =>
2312 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i32_atomic_load16_u(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(20), i)) =>
2317 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_load8_u(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(21), i)) =>
2322 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_load16_u(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(22), i)) =>
2327 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_load32_u(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(23), i)) =>
2332 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i32_atomic_store(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(24), i)) =>
2337 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_store(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(25), i)) =>
2342 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i32_atomic_store8(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(26), i)) =>
2347 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i32_atomic_store16(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(27), i)) =>
2352 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_store8(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(28), i)) =>
2357 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_store16(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(29), i)) =>
2362 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => Ok((Instruction::i64_atomic_store32(m), i))
     |             Err(t) => Err(t)
     |           }
     |         Ok((@lib.U32(id), i)) if id >= 30 && id <= 71 =>
2367 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => {
     |               let op : AtomicRmwOp = match id {
     |                 30 => AtomicRmwOp::i32_add()
     |                 31 => AtomicRmwOp::i64_add()
     |                 32 => AtomicRmwOp::i32_8_add_u()
     |                 33 => AtomicRmwOp::i32_16_add_u()
     |                 34 => AtomicRmwOp::i64_8_add_u()
     |                 35 => AtomicRmwOp::i64_16_add_u()
     |                 36 => AtomicRmwOp::i64_32_add_u()
     |                 37 => AtomicRmwOp::i32_sub()
     |                 38 => AtomicRmwOp::i64_sub()
     |                 39 => AtomicRmwOp::i32_8_sub_u()
     |                 40 => AtomicRmwOp::i32_16_sub_u()
     |                 41 => AtomicRmwOp::i64_8_sub_u()
     |                 42 => AtomicRmwOp::i64_16_sub_u()
     |                 43 => AtomicRmwOp::i64_32_sub_u()
     |                 44 => AtomicRmwOp::i32_and()
     |                 45 => AtomicRmwOp::i64_and()
     |                 46 => AtomicRmwOp::i32_8_and_u()
     |                 47 => AtomicRmwOp::i32_16_and_u()
     |                 48 => AtomicRmwOp::i64_8_and_u()
     |                 49 => AtomicRmwOp::i64_16_and_u()
     |                 50 => AtomicRmwOp::i64_32_and_u()
     |                 51 => AtomicRmwOp::i32_or()
     |                 52 => AtomicRmwOp::i64_or()
     |                 53 => AtomicRmwOp::i32_8_or_u()
     |                 54 => AtomicRmwOp::i32_16_or_u()
     |                 55 => AtomicRmwOp::i64_8_or_u()
     |                 56 => AtomicRmwOp::i64_16_or_u()
     |                 57 => AtomicRmwOp::i64_32_or_u()
     |                 58 => AtomicRmwOp::i32_xor()
     |                 59 => AtomicRmwOp::i64_xor()
     |                 60 => AtomicRmwOp::i32_8_xor_u()
     |                 61 => AtomicRmwOp::i32_16_xor_u()
     |                 62 => AtomicRmwOp::i64_8_xor_u()
     |                 63 => AtomicRmwOp::i64_16_xor_u()
     |                 64 => AtomicRmwOp::i64_32_xor_u()
     |                 65 => AtomicRmwOp::i32_xchg()
     |                 66 => AtomicRmwOp::i64_xchg()
     |                 67 => AtomicRmwOp::i32_8_xchg_u()
     |                 68 => AtomicRmwOp::i32_16_xchg_u()
     |                 69 => AtomicRmwOp::i64_8_xchg_u()
     |                 70 => AtomicRmwOp::i64_16_xchg_u()
     |                 _ => AtomicRmwOp::i64_32_xchg_u()
     |               }
2413 |               Ok((Instruction::atomic_rmw(op, m), i))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
2415 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(id), i)) if id >= 72 && id <= 78 =>
2418 |           match Decode::decode(bytes, i) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok((m, i)) => {
     |               let op : AtomicCmpxchgOp = match id {
     |                 72 => AtomicCmpxchgOp::i32()
     |                 73 => AtomicCmpxchgOp::i64()
     |                 74 => AtomicCmpxchgOp::i32_8_u()
     |                 75 => AtomicCmpxchgOp::i32_16_u()
     |                 76 => AtomicCmpxchgOp::i64_8_u()
     |                 77 => AtomicCmpxchgOp::i64_16_u()
     |                 _ => AtomicCmpxchgOp::i64_32_u()
     |               }
2429 |               Ok((Instruction::atomic_cmpxchg(op, m), i))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
2431 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
2433 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => Err("Invalid atomic instruction")
     |       }
     | 
     |     // Section: Vector
     |     Some(0xFD) =>
     |       match Decode::decode(bytes, i + 1) {
     |         Ok((@lib.U32(0), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load(m), i))
2443 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(1), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load8x8s(m), i))
2448 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(2), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load8x8u(m), i))
2453 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(3), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load16x4s(m), i))
2458 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(4), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load16x4u(m), i))
2463 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(5), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load32x2s(m), i))
2468 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(6), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load32x2u(m), i))
2473 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(7), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load8_splat(m), i))
2478 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(8), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load16_splat(m), i))
2483 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(9), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load32_splat(m), i))
2488 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(10), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load64_splat(m), i))
2493 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(11), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_store(m), i))
2498 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(12), i)) =>
     |           // 16 bytes const
     |           if bytes.length() >= i + 16 {
     |             Ok(
     |               (
     |                 Instruction::v128_const(
     |                   bytes.unsafe_get(i),
     |                   bytes.unsafe_get(i + 1),
     |                   bytes.unsafe_get(i + 2),
     |                   bytes.unsafe_get(i + 3),
     |                   bytes.unsafe_get(i + 4),
     |                   bytes.unsafe_get(i + 5),
     |                   bytes.unsafe_get(i + 6),
     |                   bytes.unsafe_get(i + 7),
     |                   bytes.unsafe_get(i + 8),
     |                   bytes.unsafe_get(i + 9),
     |                   bytes.unsafe_get(i + 10),
     |                   bytes.unsafe_get(i + 11),
     |                   bytes.unsafe_get(i + 12),
     |                   bytes.unsafe_get(i + 13),
     |                   bytes.unsafe_get(i + 14),
     |                   bytes.unsafe_get(i + 15),
     |                 ),
     |                 i + 16,
     |               ),
     |             )
     |           } else {
2527 |             Err("Invalid Instruction")
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(13), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l0, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l1, i)) =>
     |                   match Decode::decode(bytes, i) {
     |                     Ok((l2, i)) =>
     |                       match Decode::decode(bytes, i) {
     |                         Ok((l3, i)) =>
     |                           match Decode::decode(bytes, i) {
     |                             Ok((l4, i)) =>
     |                               match Decode::decode(bytes, i) {
     |                                 Ok((l5, i)) =>
     |                                   match Decode::decode(bytes, i) {
     |                                     Ok((l6, i)) =>
     |                                       match Decode::decode(bytes, i) {
     |                                         Ok((l7, i)) =>
     |                                           match Decode::decode(bytes, i) {
     |                                             Ok((l8, i)) =>
     |                                               match Decode::decode(bytes, i) {
     |                                                 Ok((l9, i)) =>
     |                                                   match
     |                                                     Decode::decode(bytes, i) {
     |                                                     Ok((l10, i)) =>
     |                                                       match
     |                                                         Decode::decode(bytes, i) {
     |                                                         Ok((l11, i)) =>
     |                                                           match
     |                                                             Decode::decode(
     |                                                               bytes, i,
     |                                                             ) {
     |                                                             Ok((l12, i)) =>
     |                                                               match
     |                                                                 Decode::decode(
     |                                                                   bytes, i,
     |                                                                 ) {
     |                                                                 Ok((l13, i)) =>
     |                                                                   match
     |                                                                     Decode::decode(
     |                                                                       bytes, i,
     |                                                                     ) {
     |                                                                     Ok((l14, i)) =>
     |                                                                       match
     |                                                                         Decode::decode(
     |                                                                           bytes,
     |                                                                           i,
     |                                                                         ) {
     |                                                                         Ok(
     |                                                                           (
     |                                                                             l15,
     |                                                                             i,
     |                                                                           )
     |                                                                         ) =>
     |                                                                           Ok(
     |                                                                             (
     |                                                                               Instruction::i8x16_shuffle(
     |                                                                                 l0,
     |                                                                                 l1,
     |                                                                                 l2,
     |                                                                                 l3,
     |                                                                                 l4,
     |                                                                                 l5,
     |                                                                                 l6,
     |                                                                                 l7,
     |                                                                                 l8,
     |                                                                                 l9,
     |                                                                                 l10,
     |                                                                                 l11,
     |                                                                                 l12,
     |                                                                                 l13,
     |                                                                                 l14,
     |                                                                                 l15,
     |                                                                               ),
     |                                                                               i,
     |                                                                             ),
     |                                                                           )
     |                                                                         Err(t) =>
2606 |                                                                           Err(t)
     |                                                                           ^^^^^^ 	<-- UNCOVERED
     |                                                                       }
     |                                                                     Err(t) =>
2609 |                                                                       Err(t)
     |                                                                       ^^^^^^ 	<-- UNCOVERED
     |                                                                   }
2611 |                                                                 Err(t) => Err(t)
     |                                                                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                                               }
2613 |                                                             Err(t) => Err(t)
     |                                                             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                                           }
2615 |                                                         Err(t) => Err(t)
     |                                                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                                       }
2617 |                                                     Err(t) => Err(t)
     |                                                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                                   }
2619 |                                                 Err(t) => Err(t)
     |                                                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                               }
2621 |                                             Err(t) => Err(t)
     |                                             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                           }
2623 |                                         Err(t) => Err(t)
     |                                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                       }
2625 |                                     Err(t) => Err(t)
     |                                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                                   }
2627 |                                 Err(t) => Err(t)
     |                                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                               }
2629 |                             Err(t) => Err(t)
     |                             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           }
2631 |                         Err(t) => Err(t)
     |                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
2633 |                     Err(t) => Err(t)
     |                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
2635 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2637 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((@lib.U32(14), i)) => Ok((Instruction::i8x16_swizzle(), i))
     |         Ok((@lib.U32(15), i)) => Ok((Instruction::i8x16_splat(), i))
     |         Ok((@lib.U32(16), i)) => Ok((Instruction::i16x8_splat(), i))
     |         Ok((@lib.U32(17), i)) => Ok((Instruction::i32x4_splat(), i))
     |         Ok((@lib.U32(18), i)) => Ok((Instruction::i64x2_splat(), i))
     |         Ok((@lib.U32(19), i)) => Ok((Instruction::f32x4_splat(), i))
     |         Ok((@lib.U32(20), i)) => Ok((Instruction::f64x2_splat(), i))
     |         Ok((@lib.U32(35), i)) => Ok((Instruction::i8x16_eq(), i))
     |         Ok((@lib.U32(36), i)) => Ok((Instruction::i8x16_ne(), i))
     |         Ok((@lib.U32(37), i)) => Ok((Instruction::i8x16_lt_s(), i))
     |         Ok((@lib.U32(38), i)) => Ok((Instruction::i8x16_lt_u(), i))
     |         Ok((@lib.U32(39), i)) => Ok((Instruction::i8x16_gt_s(), i))
     |         Ok((@lib.U32(40), i)) => Ok((Instruction::i8x16_gt_u(), i))
     |         Ok((@lib.U32(41), i)) => Ok((Instruction::i8x16_le_s(), i))
     |         Ok((@lib.U32(42), i)) => Ok((Instruction::i8x16_le_u(), i))
     |         Ok((@lib.U32(43), i)) => Ok((Instruction::i8x16_ge_s(), i))
     |         Ok((@lib.U32(44), i)) => Ok((Instruction::i8x16_ge_u(), i))
     |         Ok((@lib.U32(45), i)) => Ok((Instruction::i16x8_eq(), i))
     |         Ok((@lib.U32(46), i)) => Ok((Instruction::i16x8_ne(), i))
     |         Ok((@lib.U32(47), i)) => Ok((Instruction::i16x8_lt_s(), i))
     |         Ok((@lib.U32(48), i)) => Ok((Instruction::i16x8_lt_u(), i))
     |         Ok((@lib.U32(49), i)) => Ok((Instruction::i16x8_gt_s(), i))
     |         Ok((@lib.U32(50), i)) => Ok((Instruction::i16x8_gt_u(), i))
     |         Ok((@lib.U32(51), i)) => Ok((Instruction::i16x8_le_s(), i))
     |         Ok((@lib.U32(52), i)) => Ok((Instruction::i16x8_le_u(), i))
     |         Ok((@lib.U32(53), i)) => Ok((Instruction::i16x8_ge_s(), i))
     |         Ok((@lib.U32(54), i)) => Ok((Instruction::i16x8_ge_u(), i))
     |         Ok((@lib.U32(55), i)) => Ok((Instruction::i32x4_eq(), i))
     |         Ok((@lib.U32(56), i)) => Ok((Instruction::i32x4_ne(), i))
     |         Ok((@lib.U32(57), i)) => Ok((Instruction::i32x4_lt_s(), i))
     |         Ok((@lib.U32(58), i)) => Ok((Instruction::i32x4_lt_u(), i))
     |         Ok((@lib.U32(59), i)) => Ok((Instruction::i32x4_gt_s(), i))
     |         Ok((@lib.U32(60), i)) => Ok((Instruction::i32x4_gt_u(), i))
     |         Ok((@lib.U32(61), i)) => Ok((Instruction::i32x4_le_s(), i))
     |         Ok((@lib.U32(62), i)) => Ok((Instruction::i32x4_le_u(), i))
     |         Ok((@lib.U32(63), i)) => Ok((Instruction::i32x4_ge_s(), i))
     |         Ok((@lib.U32(64), i)) => Ok((Instruction::i32x4_ge_u(), i))
     |         Ok((@lib.U32(65), i)) => Ok((Instruction::f32x4_eq(), i))
     |         Ok((@lib.U32(66), i)) => Ok((Instruction::f32x4_ne(), i))
     |         Ok((@lib.U32(67), i)) => Ok((Instruction::f32x4_lt(), i))
     |         Ok((@lib.U32(68), i)) => Ok((Instruction::f32x4_gt(), i))
     |         Ok((@lib.U32(69), i)) => Ok((Instruction::f32x4_le(), i))
     |         Ok((@lib.U32(70), i)) => Ok((Instruction::f32x4_ge(), i))
     |         Ok((@lib.U32(71), i)) => Ok((Instruction::f64x2_eq(), i))
     |         Ok((@lib.U32(72), i)) => Ok((Instruction::f64x2_ne(), i))
     |         Ok((@lib.U32(73), i)) => Ok((Instruction::f64x2_lt(), i))
     |         Ok((@lib.U32(74), i)) => Ok((Instruction::f64x2_gt(), i))
     |         Ok((@lib.U32(75), i)) => Ok((Instruction::f64x2_le(), i))
     |         Ok((@lib.U32(76), i)) => Ok((Instruction::f64x2_ge(), i))
     |         Ok((@lib.U32(77), i)) => Ok((Instruction::v128_not(), i))
     |         Ok((@lib.U32(78), i)) => Ok((Instruction::v128_and(), i))
     |         Ok((@lib.U32(79), i)) => Ok((Instruction::v128_andnot(), i))
     |         Ok((@lib.U32(80), i)) => Ok((Instruction::v128_or(), i))
     |         Ok((@lib.U32(81), i)) => Ok((Instruction::v128_xor(), i))
     |         Ok((@lib.U32(82), i)) => Ok((Instruction::v128_bitselect(), i))
     |         Ok((@lib.U32(83), i)) => Ok((Instruction::v128_any_true(), i))
     |         Ok((@lib.U32(94), i)) => Ok((Instruction::f32x4_demote_f64x2_zero(), i))
     |         Ok((@lib.U32(95), i)) => Ok((Instruction::f64x2_promote_low_f32x4(), i))
     |         Ok((@lib.U32(96), i)) => Ok((Instruction::i8x16_abs(), i))
     |         Ok((@lib.U32(97), i)) => Ok((Instruction::i8x16_neg(), i))
     |         Ok((@lib.U32(98), i)) => Ok((Instruction::i8x16_popcnt(), i))
     |         Ok((@lib.U32(99), i)) => Ok((Instruction::i8x16_all_true(), i))
     |         Ok((@lib.U32(100), i)) => Ok((Instruction::i8x16_bitmask(), i))
     |         Ok((@lib.U32(101), i)) => Ok((Instruction::i8x16_narrow_i16x8s(), i))
     |         Ok((@lib.U32(102), i)) => Ok((Instruction::i8x16_narrow_i16x8u(), i))
     |         Ok((@lib.U32(103), i)) => Ok((Instruction::f32x4_ceil(), i))
     |         Ok((@lib.U32(104), i)) => Ok((Instruction::f32x4_floor(), i))
     |         Ok((@lib.U32(105), i)) => Ok((Instruction::f32x4_trunc(), i))
     |         Ok((@lib.U32(106), i)) => Ok((Instruction::f32x4_nearest(), i))
     |         Ok((@lib.U32(107), i)) => Ok((Instruction::i8x16_shl(), i))
     |         Ok((@lib.U32(108), i)) => Ok((Instruction::i8x16_shr_s(), i))
     |         Ok((@lib.U32(109), i)) => Ok((Instruction::i8x16_shr_u(), i))
     |         Ok((@lib.U32(110), i)) => Ok((Instruction::i8x16_add(), i))
     |         Ok((@lib.U32(111), i)) => Ok((Instruction::i8x16_add_sat_s(), i))
     |         Ok((@lib.U32(112), i)) => Ok((Instruction::i8x16_add_sat_u(), i))
     |         Ok((@lib.U32(113), i)) => Ok((Instruction::i8x16_sub(), i))
     |         Ok((@lib.U32(114), i)) => Ok((Instruction::i8x16_sub_sat_s(), i))
     |         Ok((@lib.U32(115), i)) => Ok((Instruction::i8x16_sub_sat_u(), i))
     |         Ok((@lib.U32(116), i)) => Ok((Instruction::f64x2_ceil(), i))
     |         Ok((@lib.U32(117), i)) => Ok((Instruction::f64x2_floor(), i))
     |         Ok((@lib.U32(118), i)) => Ok((Instruction::i8x16_min_s(), i))
     |         Ok((@lib.U32(119), i)) => Ok((Instruction::i8x16_min_u(), i))
     |         Ok((@lib.U32(120), i)) => Ok((Instruction::i8x16_max_s(), i))
     |         Ok((@lib.U32(121), i)) => Ok((Instruction::i8x16_max_u(), i))
     |         Ok((@lib.U32(122), i)) => Ok((Instruction::f64x2_trunc(), i))
     |         Ok((@lib.U32(123), i)) => Ok((Instruction::i8x16_avgr_u(), i))
     |         Ok((@lib.U32(124), i)) =>
     |           Ok((Instruction::i16x8_extadd_pairwise_i8x16s(), i))
     |         Ok((@lib.U32(125), i)) =>
     |           Ok((Instruction::i16x8_extadd_pairwise_i8x16u(), i))
     |         Ok((@lib.U32(126), i)) =>
     |           Ok((Instruction::i32x4_extadd_pairwise_i16x8s(), i))
     |         Ok((@lib.U32(127), i)) =>
     |           Ok((Instruction::i32x4_extadd_pairwise_i16x8u(), i))
     |         Ok((@lib.U32(128), i)) => Ok((Instruction::i16x8_abs(), i))
     |         Ok((@lib.U32(129), i)) => Ok((Instruction::i16x8_neg(), i))
     |         Ok((@lib.U32(130), i)) => Ok((Instruction::i16x8q15mulr_sat_s(), i))
     |         Ok((@lib.U32(131), i)) => Ok((Instruction::i16x8_all_true(), i))
     |         Ok((@lib.U32(132), i)) => Ok((Instruction::i16x8_bitmask(), i))
     |         Ok((@lib.U32(133), i)) => Ok((Instruction::i16x8_narrow_i32x4s(), i))
     |         Ok((@lib.U32(134), i)) => Ok((Instruction::i16x8_narrow_i32x4u(), i))
     |         Ok((@lib.U32(135), i)) =>
     |           Ok((Instruction::i16x8_extend_low_i8x16s(), i))
     |         Ok((@lib.U32(136), i)) =>
     |           Ok((Instruction::i16x8_extend_high_i8x16s(), i))
     |         Ok((@lib.U32(137), i)) =>
     |           Ok((Instruction::i16x8_extend_low_i8x16u(), i))
     |         Ok((@lib.U32(138), i)) =>
     |           Ok((Instruction::i16x8_extend_high_i8x16u(), i))
     |         Ok((@lib.U32(139), i)) => Ok((Instruction::i16x8_shl(), i))
     |         Ok((@lib.U32(140), i)) => Ok((Instruction::i16x8_shr_s(), i))
     |         Ok((@lib.U32(141), i)) => Ok((Instruction::i16x8_shr_u(), i))
     |         Ok((@lib.U32(142), i)) => Ok((Instruction::i16x8_add(), i))
     |         Ok((@lib.U32(143), i)) => Ok((Instruction::i16x8_add_sat_s(), i))
     |         Ok((@lib.U32(144), i)) => Ok((Instruction::i16x8_add_sat_u(), i))
     |         Ok((@lib.U32(145), i)) => Ok((Instruction::i16x8_sub(), i))
     |         Ok((@lib.U32(146), i)) => Ok((Instruction::i16x8_sub_sat_s(), i))
     |         Ok((@lib.U32(147), i)) => Ok((Instruction::i16x8_sub_sat_u(), i))
     |         Ok((@lib.U32(148), i)) => Ok((Instruction::f64x2_nearest(), i))
     |         Ok((@lib.U32(149), i)) => Ok((Instruction::i16x8_mul(), i))
     |         Ok((@lib.U32(150), i)) => Ok((Instruction::i16x8_min_s(), i))
     |         Ok((@lib.U32(151), i)) => Ok((Instruction::i16x8_min_u(), i))
     |         Ok((@lib.U32(152), i)) => Ok((Instruction::i16x8_max_s(), i))
     |         Ok((@lib.U32(153), i)) => Ok((Instruction::i16x8_max_u(), i))
     |         Ok((@lib.U32(155), i)) => Ok((Instruction::i16x8_avgr_u(), i))
     |         Ok((@lib.U32(156), i)) =>
     |           Ok((Instruction::i16x8_extmul_low_i8x16s(), i))
     |         Ok((@lib.U32(157), i)) =>
     |           Ok((Instruction::i16x8_extmul_high_i8x16s(), i))
     |         Ok((@lib.U32(158), i)) =>
     |           Ok((Instruction::i16x8_extmul_low_i8x16u(), i))
     |         Ok((@lib.U32(159), i)) =>
     |           Ok((Instruction::i16x8_extmul_high_i8x16u(), i))
     |         Ok((@lib.U32(160), i)) => Ok((Instruction::i32x4_abs(), i))
     |         Ok((@lib.U32(161), i)) => Ok((Instruction::i32x4_neg(), i))
     |         Ok((@lib.U32(163), i)) => Ok((Instruction::i32x4_all_true(), i))
     |         Ok((@lib.U32(164), i)) => Ok((Instruction::i32x4_bitmask(), i))
     |         Ok((@lib.U32(167), i)) =>
     |           Ok((Instruction::i32x4_extend_low_i16x8s(), i))
     |         Ok((@lib.U32(168), i)) =>
     |           Ok((Instruction::i32x4_extend_high_i16x8s(), i))
     |         Ok((@lib.U32(169), i)) =>
     |           Ok((Instruction::i32x4_extend_low_i16x8u(), i))
     |         Ok((@lib.U32(170), i)) =>
     |           Ok((Instruction::i32x4_extend_high_i16x8u(), i))
     |         Ok((@lib.U32(171), i)) => Ok((Instruction::i32x4_shl(), i))
     |         Ok((@lib.U32(172), i)) => Ok((Instruction::i32x4_shr_s(), i))
     |         Ok((@lib.U32(173), i)) => Ok((Instruction::i32x4_shr_u(), i))
     |         Ok((@lib.U32(174), i)) => Ok((Instruction::i32x4_add(), i))
     |         Ok((@lib.U32(177), i)) => Ok((Instruction::i32x4_sub(), i))
     |         Ok((@lib.U32(181), i)) => Ok((Instruction::i32x4_mul(), i))
     |         Ok((@lib.U32(182), i)) => Ok((Instruction::i32x4_min_s(), i))
     |         Ok((@lib.U32(183), i)) => Ok((Instruction::i32x4_min_u(), i))
     |         Ok((@lib.U32(184), i)) => Ok((Instruction::i32x4_max_s(), i))
     |         Ok((@lib.U32(185), i)) => Ok((Instruction::i32x4_max_u(), i))
     |         Ok((@lib.U32(186), i)) => Ok((Instruction::i32x4_dot_i16x8s(), i))
     |         Ok((@lib.U32(188), i)) =>
     |           Ok((Instruction::i32x4_extmul_low_i16x8s(), i))
     |         Ok((@lib.U32(189), i)) =>
     |           Ok((Instruction::i32x4_extmul_high_i16x8s(), i))
     |         Ok((@lib.U32(190), i)) =>
     |           Ok((Instruction::i32x4_extmul_low_i16x8u(), i))
     |         Ok((@lib.U32(191), i)) =>
     |           Ok((Instruction::i32x4_extmul_high_i16x8u(), i))
     |         Ok((@lib.U32(192), i)) => Ok((Instruction::i64x2_abs(), i))
     |         Ok((@lib.U32(193), i)) => Ok((Instruction::i64x2_neg(), i))
     |         Ok((@lib.U32(195), i)) => Ok((Instruction::i64x2_all_true(), i))
     |         Ok((@lib.U32(196), i)) => Ok((Instruction::i64x2_bitmask(), i))
     |         Ok((@lib.U32(199), i)) =>
     |           Ok((Instruction::i64x2_extend_low_i32x4s(), i))
     |         Ok((@lib.U32(200), i)) =>
     |           Ok((Instruction::i64x2_extend_high_i32x4s(), i))
     |         Ok((@lib.U32(201), i)) =>
     |           Ok((Instruction::i64x2_extend_low_i32x4u(), i))
     |         Ok((@lib.U32(202), i)) =>
     |           Ok((Instruction::i64x2_extend_high_i32x4u(), i))
     |         Ok((@lib.U32(203), i)) => Ok((Instruction::i64x2_shl(), i))
     |         Ok((@lib.U32(204), i)) => Ok((Instruction::i64x2_shr_s(), i))
     |         Ok((@lib.U32(205), i)) => Ok((Instruction::i64x2_shr_u(), i))
     |         Ok((@lib.U32(206), i)) => Ok((Instruction::i64x2_add(), i))
     |         Ok((@lib.U32(209), i)) => Ok((Instruction::i64x2_sub(), i))
     |         Ok((@lib.U32(213), i)) => Ok((Instruction::i64x2_mul(), i))
     |         Ok((@lib.U32(214), i)) => Ok((Instruction::i64x2_eq(), i))
     |         Ok((@lib.U32(215), i)) => Ok((Instruction::i64x2_ne(), i))
     |         Ok((@lib.U32(216), i)) => Ok((Instruction::i64x2_lt_s(), i))
     |         Ok((@lib.U32(217), i)) => Ok((Instruction::i64x2_gt_s(), i))
     |         Ok((@lib.U32(218), i)) => Ok((Instruction::i64x2_le_s(), i))
     |         Ok((@lib.U32(219), i)) => Ok((Instruction::i64x2_ge_s(), i))
     |         Ok((@lib.U32(220), i)) =>
     |           Ok((Instruction::i64x2_extmul_low_i32x4s(), i))
     |         Ok((@lib.U32(221), i)) =>
     |           Ok((Instruction::i64x2_extmul_high_i32x4s(), i))
     |         Ok((@lib.U32(222), i)) =>
     |           Ok((Instruction::i64x2_extmul_low_i32x4u(), i))
     |         Ok((@lib.U32(223), i)) =>
     |           Ok((Instruction::i64x2_extmul_high_i32x4u(), i))
     |         Ok((@lib.U32(224), i)) => Ok((Instruction::f32x4_abs(), i))
     |         Ok((@lib.U32(225), i)) => Ok((Instruction::f32x4_neg(), i))
     |         Ok((@lib.U32(227), i)) => Ok((Instruction::f32x4_sqrt(), i))
     |         Ok((@lib.U32(228), i)) => Ok((Instruction::f32x4_add(), i))
     |         Ok((@lib.U32(229), i)) => Ok((Instruction::f32x4_sub(), i))
     |         Ok((@lib.U32(230), i)) => Ok((Instruction::f32x4_mul(), i))
     |         Ok((@lib.U32(231), i)) => Ok((Instruction::f32x4_div(), i))
     |         Ok((@lib.U32(232), i)) => Ok((Instruction::f32x4_min(), i))
     |         Ok((@lib.U32(233), i)) => Ok((Instruction::f32x4_max(), i))
     |         Ok((@lib.U32(234), i)) => Ok((Instruction::f32x4_pmin(), i))
     |         Ok((@lib.U32(235), i)) => Ok((Instruction::f32x4_pmax(), i))
     |         Ok((@lib.U32(236), i)) => Ok((Instruction::f64x2_abs(), i))
     |         Ok((@lib.U32(237), i)) => Ok((Instruction::f64x2_neg(), i))
     |         Ok((@lib.U32(239), i)) => Ok((Instruction::f64x2_sqrt(), i))
     |         Ok((@lib.U32(240), i)) => Ok((Instruction::f64x2_add(), i))
     |         Ok((@lib.U32(241), i)) => Ok((Instruction::f64x2_sub(), i))
     |         Ok((@lib.U32(242), i)) => Ok((Instruction::f64x2_mul(), i))
     |         Ok((@lib.U32(243), i)) => Ok((Instruction::f64x2_div(), i))
     |         Ok((@lib.U32(244), i)) => Ok((Instruction::f64x2_min(), i))
     |         Ok((@lib.U32(245), i)) => Ok((Instruction::f64x2_max(), i))
     |         Ok((@lib.U32(246), i)) => Ok((Instruction::f64x2_pmin(), i))
     |         Ok((@lib.U32(247), i)) => Ok((Instruction::f64x2_pmax(), i))
     |         Ok((@lib.U32(248), i)) => Ok((Instruction::i32x4_trunc_sat_f32x4s(), i))
     |         Ok((@lib.U32(249), i)) => Ok((Instruction::i32x4_trunc_sat_f32x4u(), i))
     |         Ok((@lib.U32(250), i)) => Ok((Instruction::f32x4_convert_i32x4s(), i))
     |         Ok((@lib.U32(251), i)) => Ok((Instruction::f32x4_convert_i32x4u(), i))
     |         Ok((@lib.U32(252), i)) =>
     |           Ok((Instruction::i32x4_trunc_sat_f64x2s_zero(), i))
     |         Ok((@lib.U32(253), i)) =>
     |           Ok((Instruction::i32x4_trunc_sat_f64x2u_zero(), i))
     |         Ok((@lib.U32(254), i)) =>
     |           Ok((Instruction::f64x2_convert_low_i32x4s(), i))
     |         Ok((@lib.U32(255), i)) =>
     |           Ok((Instruction::f64x2_convert_low_i32x4u(), i))
     |         Ok((@lib.U32(256), i)) => Ok((Instruction::i8x16_relaxed_swizzle(), i))
     |         Ok((@lib.U32(257), i)) =>
     |           Ok((Instruction::i32x4_relaxed_trunc_f32x4s(), i))
     |         Ok((@lib.U32(258), i)) =>
     |           Ok((Instruction::i32x4_relaxed_trunc_f32x4u(), i))
     |         Ok((@lib.U32(259), i)) =>
     |           Ok((Instruction::i32x4_relaxed_trunc_zero_f64x2s(), i))
     |         Ok((@lib.U32(260), i)) =>
     |           Ok((Instruction::i32x4_relaxed_trunc_zero_f64x2u(), i))
     |         Ok((@lib.U32(261), i)) => Ok((Instruction::f32x4_relaxed_madd(), i))
     |         Ok((@lib.U32(262), i)) => Ok((Instruction::f32x4_relaxed_nmadd(), i))
     |         Ok((@lib.U32(263), i)) => Ok((Instruction::f64x2_relaxed_madd(), i))
     |         Ok((@lib.U32(264), i)) => Ok((Instruction::f64x2_relaxed_nmadd(), i))
     |         Ok((@lib.U32(265), i)) =>
     |           Ok((Instruction::i8x16_relaxed_laneselect(), i))
     |         Ok((@lib.U32(266), i)) =>
     |           Ok((Instruction::i16x8_relaxed_laneselect(), i))
     |         Ok((@lib.U32(267), i)) =>
     |           Ok((Instruction::i32x4_relaxed_laneselect(), i))
     |         Ok((@lib.U32(268), i)) =>
     |           Ok((Instruction::i64x2_relaxed_laneselect(), i))
     |         Ok((@lib.U32(269), i)) => Ok((Instruction::f32x4_relaxed_min(), i))
     |         Ok((@lib.U32(270), i)) => Ok((Instruction::f32x4_relaxed_max(), i))
     |         Ok((@lib.U32(271), i)) => Ok((Instruction::f64x2_relaxed_min(), i))
     |         Ok((@lib.U32(272), i)) => Ok((Instruction::f64x2_relaxed_max(), i))
     |         Ok((@lib.U32(273), i)) =>
     |           Ok((Instruction::i16x8_relaxed_q15mulr_s(), i))
     |         Ok((@lib.U32(274), i)) =>
     |           Ok((Instruction::i16x8_relaxed_dot_i8x16i7x16s(), i))
     |         Ok((@lib.U32(275), i)) =>
     |           Ok((Instruction::i32x4_relaxed_dot_i8x16i7x16_add_s(), i))
     |         Ok((@lib.U32(21), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i8x16_extract_lane_s(l), i))
2903 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(22), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i8x16_extract_lane_u(l), i))
2908 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(23), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i8x16_replace_lane(l), i))
2913 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(24), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i16x8_extract_lane_s(l), i))
2918 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(25), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i16x8_extract_lane_u(l), i))
2923 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(26), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i16x8_replace_lane(l), i))
2928 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(27), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i32x4_extract_lane(l), i))
2933 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(28), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i32x4_replace_lane(l), i))
2938 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(29), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i64x2_extract_lane(l), i))
2943 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(30), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::i64x2_replace_lane(l), i))
2948 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(31), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::f32x4_extract_lane(l), i))
2953 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(32), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::f32x4_replace_lane(l), i))
2958 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(33), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::f64x2_extract_lane(l), i))
2963 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(34), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((l, i)) => Ok((Instruction::f64x2_replace_lane(l), i))
2968 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(84), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_load8_lane(m, l), i))
2975 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2977 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(85), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_load16_lane(m, l), i))
2984 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2986 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(86), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_load32_lane(m, l), i))
2993 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2995 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(87), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_load64_lane(m, l), i))
3002 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
3004 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(88), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_store8_lane(m, l), i))
3011 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
3013 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(89), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_store16_lane(m, l), i))
3020 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
3022 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(90), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_store32_lane(m, l), i))
3029 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
3031 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(91), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) =>
     |               match Decode::decode(bytes, i) {
     |                 Ok((l, i)) => Ok((Instruction::v128_store64_lane(m, l), i))
3038 |                 Err(t) => Err(t)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
3040 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(92), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load32_zero(m), i))
3045 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok((U32(93), i)) =>
     |           match Decode::decode(bytes, i) {
     |             Ok((m, i)) => Ok((Instruction::v128_load64_zero(m), i))
3050 |             Err(t) => Err(t)
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
3052 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => Err("Invalid Instruction")
     |       }
     |     _ => Err("Invalid Instruction")
     |   }
     | }
     …

     | pub impl Decode for FieldType with decode(bytes, i) {
     |   match Decode::decode(bytes, i) {
3062 |     Err(err) => Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((st, i)) =>
     |       match Decode::decode(bytes, i) {
     |         Ok((m, i)) => Ok((FieldType::new(st, m), i))
3066 |         Err(err) => Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

423 uncovered line(s) in src/binary/encode.mbt:

     | pub impl Encode for HeapType with encode(val, buf) {
     |   match val {
     |     AbsHeapTypeHeapType(ht) => Encode::encode(ht, buf)
     |     HeapType(TypeIdx(i)) => Encode::encode(@lib.S33(i), buf)
     |     HeapType(RecIdx(_)) => Err("Cannot encode recursive indexes")
  23 |     DefTypeHeapType(_) => Err("Cannot encode deftypes")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl[T : Encode] Encode for @list.List[T] with encode(val, buf) {
     |   if Encode::encode(@lib.U32(val.length().reinterpret_as_uint()), buf) is Err(t) {
  77 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   loop val {
  80 |     Empty => Ok(())
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     More(val, tail~) => {
     |       if Encode::encode(val, buf) is Err(t) {
     |         break Err(t)
     |       }
     |       continue tail
     |     }
     |   }
     | }
     …

     | pub impl Encode for FieldType with encode(val, buf) {
     |   let FieldType(st, m) = val
     |   if Encode::encode(st, buf) is Err(t) {
 115 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(m, buf) is Err(t) {
 118 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(())
     | }
     …

     | pub impl Encode for SubType with encode(val, buf) {
     |   match val {
     |     SubType(f, indexes, ct) => {
     |       match f {
     |         true => buf.write_byte(0x4F)
     |         false => buf.write_byte(0x50)
     |       }
     |       if Encode::encode(indexes, buf) is Err(t) {
 174 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(ct, buf)
     |     }
     |     CompTypeSubType(ct) => Encode::encode(ct, buf)
     |   }
     | }
     …

     | pub fn size_unsigned(val : UInt64, nbits : Int) -> Result[Int, String] {
     |   if nbits <= 0 || nbits > 64 {
     |     return Err("invalid nbits for uleb")
     |   }
     |   if nbits < 64 {
     |     let max = (1UL << nbits) - 1UL
     |     if val > max {
     |       return Err("uleb value out of range")
     |     }
     |   }
     |   let mut x = val
     |   let mut count = 0
     |   while true {
 222 |     x = x >> 7
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |     count += 1
     |     if x == 0 {
 225 |       break
     |       ^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(count)
     | }
     …

     | pub fn size_signed(val : Int64, nbits : Int) -> Result[Int, String] {
     |   if nbits <= 0 || nbits > 64 {
     |     return Err("invalid nbits for sleb")
     |   }
     |   if nbits < 64 {
     |     let min = -1L << (nbits - 1)
     |     let max = (1L << (nbits - 1)) - 1
     |     if val < min || val > max {
     |       return Err("sleb value out of range")
     |     }
     |   }
     |   let rem = nbits % 7
     |   let used_mask = if rem == 0 { 0UL } else { (1UL << rem) - 1UL }
     |   let inv_used7 = UInt64::lnot(used_mask) & 0x7fUL
     |   let mut x = val
     |   let mut count = 0
     |   while true {
     |     let payload_u = (x & 0x7f).reinterpret_as_uint64()
     |     let sign_bit = (payload_u & 0x40UL) != 0UL
     |     x = x >> 7
     |     let done_std = (x == 0 && !sign_bit) || (x == -1 && sign_bit)
     |     let done_bits_ok = if nbits == 64 || rem == 0 {
 254 |       true
     |       ^^^^ 	<-- UNCOVERED
     |     } else if val >= 0 {
     |       (payload_u & inv_used7) == 0UL
     |     } else {
 258 |       (payload_u & inv_used7) == inv_used7
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let done = done_std && done_bits_ok
     |     count += 1
     |     if done {
     |       break
     |     }
     |   }
     |   Ok(count)
     | }
     …

     | fn encode_unsigned(
     |   val : UInt64,
     |   buf : @buffer.Buffer,
     |   nbits : Int,
     | ) -> Result[Unit, String] {
     |   if nbits <= 0 || nbits > 64 {
     |     return Err("invalid nbits for uleb")
     |   }
     |   if nbits < 64 {
     |     let max = (1UL << nbits) - 1UL
     |     if val > max {
     |       return Err("uleb value out of range")
     |     }
     |   }
     |   let max_bytes = max_leb_bytes(nbits)
     |   let mut x = val
     |   let mut count = 0
     |   while true {
     |     if count >= max_bytes {
 289 |       return Err("uleb encode exceeds max bytes")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let payload = x & 0x7fUL
     |     x = x >> 7
     |     let out = if x == 0UL { payload } else { payload | 0x80UL }
     |     buf.write_byte(out.to_byte())
     |     count += 1
     |     if x == 0UL {
     |       break
     |     }
     |   }
     |   Ok(())
     | }
     …

     | fn encode_signed(
     |   val : Int64,
     |   buf : @buffer.Buffer,
     |   nbits : Int,
     | ) -> Result[Unit, String] {
     |   if nbits <= 0 || nbits > 64 {
     |     return Err("invalid nbits for sleb")
     |   }
     |   if nbits < 64 {
     |     let min = -1L << (nbits - 1)
     |     let max = (1L << (nbits - 1)) - 1
     |     if val < min || val > max {
     |       return Err("sleb value out of range")
     |     }
     |   }
     |   let max_bytes = max_leb_bytes(nbits)
     |   let rem = nbits % 7
     |   let used_mask = if rem == 0 { 0UL } else { (1UL << rem) - 1UL }
     |   let inv_used7 = UInt64::lnot(used_mask) & 0x7fUL
     |   let mut x = val
     |   let mut count = 0
     |   while true {
     |     if count >= max_bytes {
 327 |       return Err("sleb encode exceeds max bytes")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let payload_u = (x & 0x7f).reinterpret_as_uint64()
     |     let sign_bit = (payload_u & 0x40UL) != 0UL
     |     x = x >> 7
     |     let done_std = (x == 0 && !sign_bit) || (x == -1 && sign_bit)
     |     let done_bits_ok = if nbits == 64 || rem == 0 {
     |       true
     |     } else if val >= 0 {
     |       (payload_u & inv_used7) == 0UL
     |     } else {
     |       (payload_u & inv_used7) == inv_used7
     |     }
     |     let done = done_std && done_bits_ok
     |     let out = if done { payload_u } else { payload_u | 0x80UL }
     |     buf.write_byte(out.to_byte())
     |     count += 1
     |     if done {
     |       break
     |     }
     |   }
     |   Ok(())
     | }
     …

     | pub impl Encode for Name with encode(val, buf) {
     |   let Name(name) = val
     |   let bytes = @utf8.encode(name)
     |   let len = bytes.length()
     |   match Encode::encode(@lib.U32(len.reinterpret_as_uint()), buf) {
 497 |     Err(err) => Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => {
     |       buf.write_bytes(bytes)
     |       Ok(())
     |     }
     |   }
     | }
     …

     | pub impl Encode for CustomSec with encode(val, buf) {
     |   let CustomSec(name, bytes) = val
     |   buf.write_byte(0)
     |   let payload_buff = @buffer.new()
     |   if Encode::encode(name, payload_buff) is Err(t) {
 511 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   payload_buff.write_bytes(bytes)
     |   let payload_bytes = payload_buff.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 517 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for TypeSec with encode(val, buf) {
     |   buf.write_byte(1)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
     |     return Err(t)
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 533 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for ImportSec with encode(val, buf) {
     |   buf.write_byte(2)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
     |     return Err(t)
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 549 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Import with encode(val, buf) {
     |   let Import(ns, name, et) = val
     |   match Encode::encode(ns, buf) {
 559 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   match Encode::encode(name, buf) {
 563 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   Encode::encode(et, buf)
     | }
     …

     | pub impl Encode for TableType with encode(val, buf) {
     |   let TableType(rt, l) = val
     |   match Encode::encode(rt, buf) {
 599 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   Encode::encode(l, buf)
     | }
     …

     | pub impl Encode for Limits with encode(val, buf) {
     |   match val {
     |     I32Limits(min, None) => {
     |       buf.write_byte(0x00)
     |       Encode::encode(@lib.U64(min.to_uint64()), buf)
     |     }
     |     I32Limits(min, Some(max)) => {
     |       buf.write_byte(0x01)
     |       match Encode::encode(@lib.U64(min.to_uint64()), buf) {
 615 |         Err(err) => return Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       Encode::encode(@lib.U64(max.to_uint64()), buf)
     |     }
     |     I64Limits(min, None) => {
     |       buf.write_byte(0x04)
     |       Encode::encode(@lib.U64(min), buf)
     |     }
     |     I64Limits(min, Some(max)) => {
     |       buf.write_byte(0x05)
     |       match Encode::encode(@lib.U64(min), buf) {
 627 |         Err(err) => return Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       Encode::encode(@lib.U64(max), buf)
     |     }
     |   }
     | }
     …

     | pub impl Encode for GlobalType with encode(val, buf) {
     |   let GlobalType(vt, m) = val
     |   match Encode::encode(vt, buf) {
 644 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   Encode::encode(m, buf)
     | }
     …

     | pub impl Encode for FuncSec with encode(val, buf) {
     |   buf.write_byte(3)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 661 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 666 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for TableSec with encode(val, buf) {
     |   buf.write_byte(4)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 677 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 682 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Table with encode(val, buf) {
     |   match val {
     |     Table(tt, None) => Encode::encode(tt, buf)
     |     Table(tt, Some(e)) => {
     |       buf.write_bytes(b"\x40\x00")
     |       match Encode::encode(tt, buf) {
 695 |         Err(err) => return Err(err)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(_) => Encode::encode(e, buf)
     |       }
     |     }
     |   }
     | }
     …

     | pub impl Encode for MemSec with encode(val, buf) {
     |   buf.write_byte(5)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 707 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 712 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for GlobalSec with encode(val, buf) {
     |   buf.write_byte(6)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 723 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 728 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Global with encode(val, buf) {
     |   let Global(gt, e) = val
     |   match Encode::encode(gt, buf) {
 738 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   Encode::encode(e, buf)
     | }
     …

     | pub impl Encode for ExportSec with encode(val, buf) {
     |   buf.write_byte(7)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 749 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 754 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Export with encode(val, buf) {
     |   let Export(n, eidx) = val
     |   match Encode::encode(n, buf) {
 764 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   Encode::encode(eidx, buf)
     | }
     …

     | pub impl Encode for ElemSec with encode(val, buf) {
     |   buf.write_byte(9)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 781 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 786 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Elem with encode(val, buf) {
     |   match val {
     |     Elem(Active(TableIdx(0), e), FuncsElemKind(y)) => {
     |       buf.write_byte(0x00)
     |       if Encode::encode(e, buf) is Err(t) {
 798 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(y, buf)
     |     }
     |     Elem(Passive, FuncsElemKind(y)) => {
     |       buf.write_bytes(b"\x01\x00")
     |       Encode::encode(y, buf)
     |     }
     |     Elem(Active(ti, e), FuncsElemKind(y)) => {
     |       buf.write_byte(0x02)
     |       if Encode::encode(ti, buf) is Err(t) {
 809 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(e, buf) is Err(t) {
 812 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       buf.write_byte(0x00)
     |       Encode::encode(y, buf)
     |     }
     |     Elem(Declarative, FuncsElemKind(y)) => {
     |       buf.write_bytes(b"\x03\x00")
     |       Encode::encode(y, buf)
     |     }
     |     Elem(Active(TableIdx(0), e), FuncExprsElemKind(es)) => {
     |       buf.write_byte(0x04)
     |       if Encode::encode(e, buf) is Err(t) {
 824 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(es, buf)
     |     }
     |     // Encoder fixes - add funcref reftype
 829 |     Elem(Passive, FuncExprsElemKind(es)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       buf.write_byte(0x05)
     |       let rt = RefType::new(true, HeapType::abs(AbsHeapType::func()))
     |       if Encode::encode(rt, buf) is Err(t) {
 833 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 835 |       Encode::encode(es, buf)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     Elem(Active(ti, e), FuncExprsElemKind(es)) => {
     |       buf.write_byte(0x06)
     |       if Encode::encode(ti, buf) is Err(t) {
 840 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(e, buf) is Err(t) {
 843 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       // DON'T encode reftype - format 6 has implicit (ref null func)
     |       Encode::encode(es, buf)
     |     }
 848 |     Elem(Declarative, FuncExprsElemKind(es)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rt = RefType::new(true, HeapType::abs(AbsHeapType::func()))
     |       buf.write_byte(0x07)
     |       if Encode::encode(rt, buf) is Err(t) {
 852 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 854 |       Encode::encode(es, buf)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     Elem(Passive, TypedExprsElemKind(rt, es)) => {
     |       buf.write_byte(0x05)
     |       if Encode::encode(rt, buf) is Err(t) {
 859 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(es, buf)
     |     }
     |     Elem(Declarative, TypedExprsElemKind(rt, es)) => {
     |       buf.write_byte(0x07)
     |       if Encode::encode(rt, buf) is Err(t) {
 866 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(es, buf)
     |     }
     |     Elem(Active(_), TypedExprsElemKind(_)) =>
 871 |       Err(
     |       ^^^^ 	<-- UNCOVERED
     |         "Invalid Active Sequence. Active Sequences must be func refs or indicies.",
     |       )
     |   }
     | }
     …

     | pub impl Encode for Func with encode(val, buf) {
     |   let fn_body = @buffer.new()
     |   let (locals, expr) = match val {
     |     Func(locals, expr) => (locals, expr)
 889 |     TFunc(tlocals, texpr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let locals = tlocals_to_locals(tlocals)
     |       let expr = texpr.to_expr()
     |       (locals, expr)
     |     }
     |   }
     |   if Encode::encode(locals, fn_body) is Err(t) {
 896 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(expr, fn_body) is Err(t) {
     |     return Err(t)
     |   }
     |   let fn_bytes = fn_body.to_bytes()
     |   if Encode::encode(@lib.U32(fn_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 904 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(fn_bytes) // Don't use Encode::encode here - just write raw bytes
     |   Ok(())
     | }
     …

     | pub impl Encode for DataSec with encode(val, buf) {
     |   buf.write_byte(11)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 915 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 920 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Data with encode(val, buf) {
     |   match val {
     |     Data(Active(MemIdx(0), e), bytes) => {
     |       buf.write_byte(0x00)
     |       if Encode::encode(e, buf) is Err(t) {
 932 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(bytes, buf)
     |     }
     |     Data(Passive, bytes) => {
     |       buf.write_byte(0x01)
     |       Encode::encode(bytes, buf)
     |     }
     |     Data(Active(idx, e), bytes) => {
     |       buf.write_byte(0x02)
     |       if Encode::encode(idx, buf) is Err(t) {
 943 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(e, buf) is Err(t) {
 946 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Encode::encode(bytes, buf)
     |     }
     |   }
     | }
     …

     | pub impl Encode for Locals with encode(val, buf) {
     |   let Locals(count, vt) = val
     |   match Encode::encode(@lib.U32(count), buf) {
 957 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   Encode::encode(vt, buf)
     | }
     …

     | pub impl Encode for DataCntSec with encode(val, buf) {
     |   let DataCntSec(count) = val
     |   buf.write_byte(12)
     |   if Encode::encode(count, buf) is Err(t) {
 968 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(())
     | }
     …

     | pub impl Encode for TagSec with encode(val, buf) {
     |   buf.write_byte(13)
     |   let payload = @buffer.new()
     |   if Encode::encode(val.0, payload) is Err(t) {
 978 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let payload_bytes = payload.to_bytes()
     |   if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)
     |     is Err(t) {
 983 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   buf.write_bytes(payload_bytes)
     |   Ok(())
     | }
     …

     | pub impl Encode for Module with encode(val, buf) {
     |   buf.write_bytes(b"\x00\x61\x73\x6D\x01\x00\x00\x00")
     |   // custom sections
     |   for sec in val.custom_secs {
     |     if Encode::encode(sec, buf) is Err(t) {
1006 |       return Err(t)
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if Encode::encode(val.type_sec, buf) is Err(t) {
     |     return Err(t)
     |   }
     |   if Encode::encode(val.import_sec, buf) is Err(t) {
1013 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.func_sec, buf) is Err(t) {
1016 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.table_sec, buf) is Err(t) {
1019 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.mem_sec, buf) is Err(t) {
1022 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.tag_sec, buf) is Err(t) {
1025 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.global_sec, buf) is Err(t) {
1028 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.export_sec, buf) is Err(t) {
1031 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.start_sec, buf) is Err(t) {
1034 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.elem_sec, buf) is Err(t) {
1037 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.data_cnt_sec, buf) is Err(t) {
1040 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.code_sec, buf) is Err(t) {
1043 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if Encode::encode(val.data_sec, buf) is Err(t) {
1046 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(())
     | }
     …

     | pub impl Encode for Bytes with encode(val, buf) {
     |   match Encode::encode(@lib.U32(val.length().reinterpret_as_uint()), buf) {
1054 |     Err(err) => return Err(err)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |   }
     |   buf.write_bytes(val)
     |   Ok(())
     | }
     …

     | pub impl Encode for Catch with encode(val, buf) {
     |   match val {
     |     Catch(t, l) => {
     |       buf.write_byte(0x00)
     |       if Encode::encode(t, buf) is Err(t) {
1091 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
1094 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     CatchRef(t, l) => {
     |       buf.write_byte(0x01)
     |       if Encode::encode(t, buf) is Err(t) {
1100 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
1103 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     CatchAll(l) => {
     |       buf.write_byte(0x02)
     |       if Encode::encode(l, buf) is Err(t) {
1109 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     CatchAllRef(l) => {
     |       buf.write_byte(0x03)
     |       if Encode::encode(l, buf) is Err(t) {
1115 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   Ok(())
     | }
     …

     | pub impl Encode for MemArg with encode(val, buf) {
     |   match val {
     |     MemArg(U32(n), Some(i), m) if n < 64 => {
     |       if Encode::encode(@lib.U32(n + 64), buf) is Err(t) {
1127 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1130 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1133 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     MemArg(U32(n), None, m) if n < 64 => {
     |       if Encode::encode(@lib.U32(n), buf) is Err(t) {
1138 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1141 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1144 |     _ => return Err("Invalid Memarg")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(())
     | }
     …

     | fn simd_inst(id : UInt, buf : @buffer.Buffer) -> Result[Unit, String] {
     |   buf.write_byte(0xFD)
     |   if Encode::encode(@lib.U32(id), buf) is Err(t) {
1153 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(())
     | }
     …

     | fn atomic_inst(id : UInt, buf : @buffer.Buffer) -> Result[Unit, String] {
1160 |   buf.write_byte(0xFE)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if Encode::encode(@lib.U32(id), buf) is Err(t) {
1162 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(())
     | }
     …

     | fn atomic_rmw_op_id(op : AtomicRmwOp) -> UInt {
1169 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AtomicRmwAddOp => 30
     |     I64AtomicRmwAddOp => 31
     |     I32AtomicRmw8AddUOp => 32
     |     I32AtomicRmw16AddUOp => 33
     |     I64AtomicRmw8AddUOp => 34
     |     I64AtomicRmw16AddUOp => 35
     |     I64AtomicRmw32AddUOp => 36
     |     I32AtomicRmwSubOp => 37
     |     I64AtomicRmwSubOp => 38
     |     I32AtomicRmw8SubUOp => 39
     |     I32AtomicRmw16SubUOp => 40
     |     I64AtomicRmw8SubUOp => 41
     |     I64AtomicRmw16SubUOp => 42
     |     I64AtomicRmw32SubUOp => 43
     |     I32AtomicRmwAndOp => 44
     |     I64AtomicRmwAndOp => 45
     |     I32AtomicRmw8AndUOp => 46
     |     I32AtomicRmw16AndUOp => 47
     |     I64AtomicRmw8AndUOp => 48
     |     I64AtomicRmw16AndUOp => 49
     |     I64AtomicRmw32AndUOp => 50
     |     I32AtomicRmwOrOp => 51
     |     I64AtomicRmwOrOp => 52
     |     I32AtomicRmw8OrUOp => 53
     |     I32AtomicRmw16OrUOp => 54
     |     I64AtomicRmw8OrUOp => 55
     |     I64AtomicRmw16OrUOp => 56
     |     I64AtomicRmw32OrUOp => 57
     |     I32AtomicRmwXorOp => 58
     |     I64AtomicRmwXorOp => 59
     |     I32AtomicRmw8XorUOp => 60
     |     I32AtomicRmw16XorUOp => 61
     |     I64AtomicRmw8XorUOp => 62
     |     I64AtomicRmw16XorUOp => 63
     |     I64AtomicRmw32XorUOp => 64
     |     I32AtomicRmwXchgOp => 65
     |     I64AtomicRmwXchgOp => 66
     |     I32AtomicRmw8XchgUOp => 67
     |     I32AtomicRmw16XchgUOp => 68
     |     I64AtomicRmw8XchgUOp => 69
     |     I64AtomicRmw16XchgUOp => 70
     |     I64AtomicRmw32XchgUOp => 71
     |   }
     | }
     …

     | fn atomic_cmpxchg_op_id(op : AtomicCmpxchgOp) -> UInt {
1217 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AtomicRmwCmpxchgOp => 72
     |     I64AtomicRmwCmpxchgOp => 73
     |     I32AtomicRmw8CmpxchgUOp => 74
     |     I32AtomicRmw16CmpxchgUOp => 75
     |     I64AtomicRmw8CmpxchgUOp => 76
     |     I64AtomicRmw16CmpxchgUOp => 77
     |     I64AtomicRmw32CmpxchgUOp => 78
     |   }
     | }
     …

     | pub impl Encode for Instruction with encode(val, buf) {
     |   match val {
     |     Unreachable => buf.write_byte(0x00)
     |     Nop => buf.write_byte(0x01)
     |     Block(bt, i) => {
     |       buf.write_byte(0x02)
     |       if Encode::encode(bt, buf) is Err(t) {
     |         return Err(t)
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1239 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     Loop(bt, i) => {
     |       buf.write_byte(0x03)
     |       if Encode::encode(bt, buf) is Err(t) {
1245 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1248 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     If(bt, if_block, else_block) => {
     |       buf.write_byte(0x04)
     |       if Encode::encode(bt, buf) is Err(t) {
1254 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for i in if_block.iter() {
     |         if Encode::encode(i, buf) is Err(t) {
1258 |           return Err(t)
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       if else_block is Some(else_block) {
     |         buf.write_byte(0x05)
     |         for i in else_block.iter() {
     |           if Encode::encode(i, buf) is Err(t) {
1265 |             return Err(t)
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |       buf.write_byte(0x0B)
     |     }
     |     Throw(t) => {
     |       buf.write_byte(0x08)
     |       if Encode::encode(t, buf) is Err(t) {
1274 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ThrowRef => buf.write_byte(0x0A)
     |     Br(i) => {
     |       buf.write_byte(0x0C)
     |       if Encode::encode(i, buf) is Err(t) {
1281 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     BrIf(i) => {
     |       buf.write_byte(0x0D)
     |       if Encode::encode(i, buf) is Err(t) {
1287 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     BrTable(ls, i) => {
     |       buf.write_byte(0x0E)
     |       if Encode::encode(ls, buf) is Err(t) {
1293 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1296 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     Return => buf.write_byte(0x0F)
     |     Call(i) => {
     |       buf.write_byte(0x10)
     |       if Encode::encode(i, buf) is Err(t) {
1303 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     CallIndirect(ty, ta) => {
     |       buf.write_byte(0x11)
     |       if Encode::encode(ty, buf) is Err(t) {
1309 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ta, buf) is Err(t) {
1312 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ReturnCall(f) => {
     |       buf.write_byte(0x12)
     |       if Encode::encode(f, buf) is Err(t) {
1318 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ReturnCallIndirect(ty, ta) => {
     |       buf.write_byte(0x13)
     |       if Encode::encode(ty, buf) is Err(t) {
1324 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ta, buf) is Err(t) {
1327 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     CallRef(t) => {
     |       buf.write_byte(0x14)
     |       if Encode::encode(t, buf) is Err(t) {
1333 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ReturnCallRef(t) => {
     |       buf.write_byte(0x15)
     |       if Encode::encode(t, buf) is Err(t) {
1339 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     Drop => buf.write_byte(0x1A)
     |     Select(None) => buf.write_byte(0x1b)
     |     Select(Some(vts)) => {
     |       buf.write_byte(0x1C)
     |       if Encode::encode(vts, buf) is Err(t) {
1347 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TryTable(bt, c, e) => {
     |       buf.write_byte(0x1F)
     |       if Encode::encode(bt, buf) is Err(t) {
1353 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(c, buf) is Err(t) {
1356 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(e, buf) is Err(t) {
1359 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     LocalGet(l) => {
     |       buf.write_byte(0x20)
     |       if Encode::encode(l, buf) is Err(t) {
1365 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     LocalSet(l) => {
     |       buf.write_byte(0x21)
     |       if Encode::encode(l, buf) is Err(t) {
1371 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     LocalTee(l) => {
     |       buf.write_byte(0x22)
     |       if Encode::encode(l, buf) is Err(t) {
1377 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     GlobalGet(g) => {
     |       buf.write_byte(0x23)
     |       if Encode::encode(g, buf) is Err(t) {
1383 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     GlobalSet(g) => {
     |       buf.write_byte(0x24)
     |       if Encode::encode(g, buf) is Err(t) {
1389 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableGet(i) => {
     |       buf.write_byte(0x25)
     |       if Encode::encode(i, buf) is Err(t) {
1395 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableSet(i) => {
     |       buf.write_byte(0x26)
     |       if Encode::encode(i, buf) is Err(t) {
1401 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Load(m) => {
     |       buf.write_byte(0x28)
     |       if Encode::encode(m, buf) is Err(t) {
1407 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load(m) => {
     |       buf.write_byte(0x29)
     |       if Encode::encode(m, buf) is Err(t) {
1413 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F32Load(m) => {
     |       buf.write_byte(0x2A)
     |       if Encode::encode(m, buf) is Err(t) {
1419 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F64Load(m) => {
     |       buf.write_byte(0x2B)
     |       if Encode::encode(m, buf) is Err(t) {
1425 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Load8S(m) => {
     |       buf.write_byte(0x2C)
     |       if Encode::encode(m, buf) is Err(t) {
1431 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Load8U(m) => {
     |       buf.write_byte(0x2D)
     |       if Encode::encode(m, buf) is Err(t) {
1437 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Load16S(m) => {
     |       buf.write_byte(0x2E)
     |       if Encode::encode(m, buf) is Err(t) {
1443 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Load16U(m) => {
     |       buf.write_byte(0x2F)
     |       if Encode::encode(m, buf) is Err(t) {
1449 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load8S(m) => {
     |       buf.write_byte(0x30)
     |       if Encode::encode(m, buf) is Err(t) {
1455 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load8U(m) => {
     |       buf.write_byte(0x31)
     |       if Encode::encode(m, buf) is Err(t) {
1461 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load16S(m) => {
     |       buf.write_byte(0x32)
     |       if Encode::encode(m, buf) is Err(t) {
1467 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load16U(m) => {
     |       buf.write_byte(0x33)
     |       if Encode::encode(m, buf) is Err(t) {
1473 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load32S(m) => {
     |       buf.write_byte(0x34)
     |       if Encode::encode(m, buf) is Err(t) {
1479 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Load32U(m) => {
     |       buf.write_byte(0x35)
     |       if Encode::encode(m, buf) is Err(t) {
1485 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Store(m) => {
     |       buf.write_byte(0x36)
     |       if Encode::encode(m, buf) is Err(t) {
1491 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Store(m) => {
     |       buf.write_byte(0x37)
     |       if Encode::encode(m, buf) is Err(t) {
1497 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F32Store(m) => {
     |       buf.write_byte(0x38)
     |       if Encode::encode(m, buf) is Err(t) {
1503 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F64Store(m) => {
     |       buf.write_byte(0x39)
     |       if Encode::encode(m, buf) is Err(t) {
1509 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Store8(m) => {
     |       buf.write_byte(0x3A)
     |       if Encode::encode(m, buf) is Err(t) {
1515 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Store16(m) => {
     |       buf.write_byte(0x3B)
     |       if Encode::encode(m, buf) is Err(t) {
1521 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Store8(m) => {
     |       buf.write_byte(0x3C)
     |       if Encode::encode(m, buf) is Err(t) {
1527 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Store16(m) => {
     |       buf.write_byte(0x3D)
     |       if Encode::encode(m, buf) is Err(t) {
1533 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Store32(m) => {
     |       buf.write_byte(0x3E)
     |       if Encode::encode(m, buf) is Err(t) {
1539 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     MemorySize(m) => {
     |       buf.write_byte(0x3F)
     |       if Encode::encode(m, buf) is Err(t) {
1545 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     MemoryGrow(m) => {
     |       buf.write_byte(0x40)
     |       if Encode::encode(m, buf) is Err(t) {
1551 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1554 |     MemoryAtomicNotify(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(0, buf) is Err(t) {
1556 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1559 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1562 |     MemoryAtomicWait32(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(1, buf) is Err(t) {
1564 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1567 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1570 |     MemoryAtomicWait64(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(2, buf) is Err(t) {
1572 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1575 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1578 |     AtomicFence => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(3, buf) is Err(t) {
1580 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1582 |       buf.write_byte(0x00)
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1584 |     I32AtomicLoad(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(16, buf) is Err(t) {
1586 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1589 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1592 |     I64AtomicLoad(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(17, buf) is Err(t) {
1594 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1597 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1600 |     I32AtomicLoad8U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(18, buf) is Err(t) {
1602 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1605 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1608 |     I32AtomicLoad16U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(19, buf) is Err(t) {
1610 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1613 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1616 |     I64AtomicLoad8U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(20, buf) is Err(t) {
1618 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1621 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1624 |     I64AtomicLoad16U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(21, buf) is Err(t) {
1626 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1629 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1632 |     I64AtomicLoad32U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(22, buf) is Err(t) {
1634 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1637 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1640 |     I32AtomicStore(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(23, buf) is Err(t) {
1642 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1645 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1648 |     I64AtomicStore(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(24, buf) is Err(t) {
1650 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1653 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1656 |     I32AtomicStore8(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(25, buf) is Err(t) {
1658 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1661 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1664 |     I32AtomicStore16(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(26, buf) is Err(t) {
1666 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1669 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1672 |     I64AtomicStore8(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(27, buf) is Err(t) {
1674 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1677 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1680 |     I64AtomicStore16(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(28, buf) is Err(t) {
1682 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1685 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1688 |     I64AtomicStore32(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(29, buf) is Err(t) {
1690 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1693 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1696 |     AtomicRmw(op, m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(atomic_rmw_op_id(op), buf) is Err(t) {
1698 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1701 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1704 |     AtomicCmpxchg(op, m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if atomic_inst(atomic_cmpxchg_op_id(op), buf) is Err(t) {
1706 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
1709 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Const(c) => {
     |       buf.write_byte(0x41)
     |       if Encode::encode(c, buf) is Err(t) {
1715 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64Const(c) => {
     |       buf.write_byte(0x42)
     |       if Encode::encode(c, buf) is Err(t) {
1721 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F32Const(c) => {
     |       buf.write_byte(0x43)
     |       if Encode::encode(c, buf) is Err(t) {
1727 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F64Const(c) => {
     |       buf.write_byte(0x44)
     |       if Encode::encode(c, buf) is Err(t) {
1733 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32Eqz => buf.write_byte(0x45)
     |     I32Eq => buf.write_byte(0x46)
     |     I32Ne => buf.write_byte(0x47)
     |     I32LtS => buf.write_byte(0x48)
     |     I32LtU => buf.write_byte(0x49)
     |     I32GtS => buf.write_byte(0x4A)
     |     I32GtU => buf.write_byte(0x4B)
     |     I32LeS => buf.write_byte(0x4C)
     |     I32LeU => buf.write_byte(0x4D)
     |     I32GeS => buf.write_byte(0x4E)
     |     I32GeU => buf.write_byte(0x4F)
     |     I64Eqz => buf.write_byte(0x50)
     |     I64Eq => buf.write_byte(0x51)
     |     I64Ne => buf.write_byte(0x52)
     |     I64LtS => buf.write_byte(0x53)
     |     I64LtU => buf.write_byte(0x54)
     |     I64GtS => buf.write_byte(0x55)
     |     I64GtU => buf.write_byte(0x56)
     |     I64LeS => buf.write_byte(0x57)
     |     I64LeU => buf.write_byte(0x58)
     |     I64GeS => buf.write_byte(0x59)
     |     I64GeU => buf.write_byte(0x5A)
     |     F32Eq => buf.write_byte(0x5B)
     |     F32Ne => buf.write_byte(0x5C)
     |     F32Lt => buf.write_byte(0x5D)
     |     F32Gt => buf.write_byte(0x5E)
     |     F32Le => buf.write_byte(0x5F)
     |     F32Ge => buf.write_byte(0x60)
     |     F64Eq => buf.write_byte(0x61)
     |     F64Ne => buf.write_byte(0x62)
     |     F64Lt => buf.write_byte(0x63)
     |     F64Gt => buf.write_byte(0x64)
     |     F64Le => buf.write_byte(0x65)
     |     F64Ge => buf.write_byte(0x66)
     |     I32Clz => buf.write_byte(0x67)
     |     I32Ctz => buf.write_byte(0x68)
     |     I32Popcnt => buf.write_byte(0x69)
     |     I32Add => buf.write_byte(0x6A)
     |     I32Sub => buf.write_byte(0x6B)
     |     I32Mul => buf.write_byte(0x6C)
     |     I32DivS => buf.write_byte(0x6D)
     |     I32DivU => buf.write_byte(0x6E)
     |     I32RemS => buf.write_byte(0x6F)
     |     I32RemU => buf.write_byte(0x70)
     |     I32And => buf.write_byte(0x71)
     |     I32Or => buf.write_byte(0x72)
     |     I32Xor => buf.write_byte(0x73)
     |     I32Shl => buf.write_byte(0x74)
     |     I32ShrS => buf.write_byte(0x75)
     |     I32ShrU => buf.write_byte(0x76)
     |     I32Rotl => buf.write_byte(0x77)
     |     I32Rotr => buf.write_byte(0x78)
     |     I64Clz => buf.write_byte(0x79)
     |     I64Ctz => buf.write_byte(0x7A)
     |     I64Popcnt => buf.write_byte(0x7B)
     |     I64Add => buf.write_byte(0x7C)
     |     I64Sub => buf.write_byte(0x7D)
     |     I64Mul => buf.write_byte(0x7E)
     |     I64DivS => buf.write_byte(0x7F)
     |     I64DivU => buf.write_byte(0x80)
     |     I64RemS => buf.write_byte(0x81)
     |     I64RemU => buf.write_byte(0x82)
     |     I64And => buf.write_byte(0x83)
     |     I64Or => buf.write_byte(0x84)
     |     I64Xor => buf.write_byte(0x85)
     |     I64Shl => buf.write_byte(0x86)
     |     I64ShrS => buf.write_byte(0x87)
     |     I64ShrU => buf.write_byte(0x88)
     |     I64Rotl => buf.write_byte(0x89)
     |     I64Rotr => buf.write_byte(0x8A)
     |     F32Abs => buf.write_byte(0x8B)
     |     F32Neg => buf.write_byte(0x8C)
     |     F32Ceil => buf.write_byte(0x8D)
     |     F32Floor => buf.write_byte(0x8E)
     |     F32Trunc => buf.write_byte(0x8F)
     |     F32Nearest => buf.write_byte(0x90)
     |     F32Sqrt => buf.write_byte(0x91)
     |     F32Add => buf.write_byte(0x92)
     |     F32Sub => buf.write_byte(0x93)
     |     F32Mul => buf.write_byte(0x94)
     |     F32Div => buf.write_byte(0x95)
     |     F32Min => buf.write_byte(0x96)
     |     F32Max => buf.write_byte(0x97)
     |     F32Copysign => buf.write_byte(0x98)
     |     F64Abs => buf.write_byte(0x99)
     |     F64Neg => buf.write_byte(0x9A)
     |     F64Ceil => buf.write_byte(0x9B)
     |     F64Floor => buf.write_byte(0x9C)
     |     F64Trunc => buf.write_byte(0x9D)
     |     F64Nearest => buf.write_byte(0x9E)
     |     F64Sqrt => buf.write_byte(0x9F)
     |     F64Add => buf.write_byte(0xA0)
     |     F64Sub => buf.write_byte(0xA1)
     |     F64Mul => buf.write_byte(0xA2)
     |     F64Div => buf.write_byte(0xA3)
     |     F64Min => buf.write_byte(0xA4)
     |     F64Max => buf.write_byte(0xA5)
     |     F64Copysign => buf.write_byte(0xA6)
     |     I32WrapI64 => buf.write_byte(0xA7)
     |     I32TruncF32S => buf.write_byte(0xA8)
     |     I32TruncF32U => buf.write_byte(0xA9)
     |     I32TruncF64S => buf.write_byte(0xAA)
     |     I32TruncF64U => buf.write_byte(0xAB)
     |     I64ExtendI32S => buf.write_byte(0xAC)
     |     I64ExtendI32U => buf.write_byte(0xAD)
     |     I64TruncF32S => buf.write_byte(0xAE)
     |     I64TruncF32U => buf.write_byte(0xAF)
     |     I64TruncF64S => buf.write_byte(0xB0)
     |     I64TruncF64U => buf.write_byte(0xB1)
     |     F32ConvertI32S => buf.write_byte(0xB2)
     |     F32ConvertI32U => buf.write_byte(0xB3)
     |     F32ConvertI64S => buf.write_byte(0xB4)
     |     F32ConvertI64U => buf.write_byte(0xB5)
     |     F32DemoteF64 => buf.write_byte(0xB6)
     |     F64ConvertI32S => buf.write_byte(0xB7)
     |     F64ConvertI32U => buf.write_byte(0xB8)
     |     F64ConvertI64S => buf.write_byte(0xB9)
     |     F64ConvertI64U => buf.write_byte(0xBA)
     |     F64PromoteF32 => buf.write_byte(0xBB)
     |     I32ReinterpretF32 => buf.write_byte(0xBC)
     |     I64ReinterpretF64 => buf.write_byte(0xBD)
     |     F32ReinterpretI32 => buf.write_byte(0xBE)
     |     F64ReinterpretI64 => buf.write_byte(0xBF)
     |     I32Extend8S => buf.write_byte(0xC0)
     |     I32Extend16S => buf.write_byte(0xC1)
     |     I64Extend8S => buf.write_byte(0xC2)
     |     I64Extend16S => buf.write_byte(0xC3)
     |     I64Extend32S => buf.write_byte(0xC4)
     |     RefNull(ht) => {
     |       buf.write_byte(0xD0)
     |       if Encode::encode(ht, buf) is Err(t) {
1867 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefIsNull => buf.write_byte(0xD1)
     |     RefFunc(i) => {
     |       buf.write_byte(0xD2)
     |       if Encode::encode(i, buf) is Err(t) {
1874 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefEq => buf.write_byte(0xD3)
     |     RefAsNonNull => buf.write_byte(0xD4)
     |     BrOnNull(i) => {
     |       buf.write_byte(0xD5)
     |       if Encode::encode(i, buf) is Err(t) {
1882 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     BrOnNonNull(i) => {
     |       buf.write_byte(0xD6)
     |       if Encode::encode(i, buf) is Err(t) {
1888 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructNew(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(0), buf) is Err(t) {
1894 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1897 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructNewDefault(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(1), buf) is Err(t) {
1903 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1906 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructGet(i, idx) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(2), buf) is Err(t) {
1912 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1915 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(idx, buf) is Err(t) {
1918 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructGetS(i, idx) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(3), buf) is Err(t) {
1924 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1927 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(idx, buf) is Err(t) {
1930 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructGetU(i, idx) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(4), buf) is Err(t) {
1936 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1939 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(idx, buf) is Err(t) {
1942 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructSet(i, idx) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(5), buf) is Err(t) {
1948 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1951 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(idx, buf) is Err(t) {
1954 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayNew(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(6), buf) is Err(t) {
1960 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1963 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayNewDefault(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(7), buf) is Err(t) {
1969 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1972 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayNewFixed(i, n) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(8), buf) is Err(t) {
1978 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1981 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(n, buf) is Err(t) {
1984 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayNewData(i, idx) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(9), buf) is Err(t) {
1990 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
1993 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(idx, buf) is Err(t) {
1996 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayNewElem(i, idx) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(10), buf) is Err(t) {
2002 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
2005 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(idx, buf) is Err(t) {
2008 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayGet(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(11), buf) is Err(t) {
2014 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
2017 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayGetS(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(12), buf) is Err(t) {
2023 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
2026 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayGetU(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(13), buf) is Err(t) {
2032 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
2035 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArraySet(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(14), buf) is Err(t) {
2041 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
2044 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayLen => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(15), buf) is Err(t) {
2050 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayFill(i) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(16), buf) is Err(t) {
2056 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(i, buf) is Err(t) {
2059 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayCopy(x0, x1) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(17), buf) is Err(t) {
2065 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(x0, buf) is Err(t) {
2068 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(x1, buf) is Err(t) {
2071 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayInitData(x, y) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(18), buf) is Err(t) {
2077 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(x, buf) is Err(t) {
2080 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(y, buf) is Err(t) {
2083 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ArrayInitElem(x, y) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(19), buf) is Err(t) {
2089 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(x, buf) is Err(t) {
2092 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(y, buf) is Err(t) {
2095 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefTest(false, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(20), buf) is Err(t) {
2101 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2104 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefTest(true, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(21), buf) is Err(t) {
2110 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2113 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefCast(false, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(22), buf) is Err(t) {
2119 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2122 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefCast(true, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(23), buf) is Err(t) {
2128 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2131 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefGetDesc => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(31), buf) is Err(t) {
2137 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefTestDesc(false, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(32), buf) is Err(t) {
2143 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2146 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefTestDesc(true, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(33), buf) is Err(t) {
2152 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2155 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefCastDescEq(false, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(34), buf) is Err(t) {
2161 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2164 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefCastDescEq(true, ht) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(35), buf) is Err(t) {
2170 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht, buf) is Err(t) {
2173 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     BrOnCast(l, castop, ht0, ht1) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(24), buf) is Err(t) {
2179 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(castop, buf) is Err(t) {
2182 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2185 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht0, buf) is Err(t) {
2188 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht1, buf) is Err(t) {
2191 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     BrOnCastFail(l, castop, ht0, ht1) => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(25), buf) is Err(t) {
2197 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(castop, buf) is Err(t) {
2200 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2203 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht0, buf) is Err(t) {
2206 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ht1, buf) is Err(t) {
2209 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     AnyConvertExtern => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(26), buf) is Err(t) {
2215 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ExternConvertAny => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(27), buf) is Err(t) {
2221 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RefI31 => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(28), buf) is Err(t) {
2227 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I31GetS => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(29), buf) is Err(t) {
2233 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I31GetU => {
     |       buf.write_byte(0xFB)
     |       if Encode::encode(@lib.U32(30), buf) is Err(t) {
2239 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32TruncSatF32S => buf.write_bytes(b"\xFC\x00")
     |     I32TruncSatF32U => buf.write_bytes(b"\xFC\x01")
     |     I32TruncSatF64S => buf.write_bytes(b"\xFC\x02")
     |     I32TruncSatF64U => buf.write_bytes(b"\xFC\x03")
     |     I64TruncSatF32S => buf.write_bytes(b"\xFC\x04")
     |     I64TruncSatF32U => buf.write_bytes(b"\xFC\x05")
     |     I64TruncSatF64S => buf.write_bytes(b"\xFC\x06")
     |     I64TruncSatF64U => buf.write_bytes(b"\xFC\x07")
     |     MemoryInit(di, mi) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(8), buf) is Err(t) {
2253 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(di, buf) is Err(t) {
2256 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(mi, buf) is Err(t) {
2259 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     DataDrop(di) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(9), buf) is Err(t) {
2265 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(di, buf) is Err(t) {
2268 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     MemoryCopy(mi0, mi1) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(10), buf) is Err(t) {
2274 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(mi0, buf) is Err(t) {
2277 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(mi1, buf) is Err(t) {
2280 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     MemoryFill(mi) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(11), buf) is Err(t) {
2286 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(mi, buf) is Err(t) {
2289 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableInit(ei, ti) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(12), buf) is Err(t) {
2295 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ei, buf) is Err(t) {
2298 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ti, buf) is Err(t) {
2301 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ElemDrop(ei) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(13), buf) is Err(t) {
2307 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ei, buf) is Err(t) {
2310 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableCopy(ti0, ti1) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(14), buf) is Err(t) {
2316 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ti0, buf) is Err(t) {
2319 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ti1, buf) is Err(t) {
2322 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableGrow(ti) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(15), buf) is Err(t) {
2328 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ti, buf) is Err(t) {
2331 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableSize(ti) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(16), buf) is Err(t) {
2337 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ti, buf) is Err(t) {
2340 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TableFill(ti) => {
     |       buf.write_byte(0xFC)
     |       if Encode::encode(@lib.U32(17), buf) is Err(t) {
2346 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(ti, buf) is Err(t) {
2349 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(0), buf) is Err(t) {
2355 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2358 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load8x8S(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(1), buf) is Err(t) {
2364 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2367 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load8x8U(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(2), buf) is Err(t) {
2373 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2376 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load16x4S(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(3), buf) is Err(t) {
2382 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2385 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load16x4U(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(4), buf) is Err(t) {
2391 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2394 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load32x2S(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(5), buf) is Err(t) {
2400 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2403 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load32x2U(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(6), buf) is Err(t) {
2409 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2412 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load8Splat(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(7), buf) is Err(t) {
2418 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2421 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load16Splat(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(8), buf) is Err(t) {
2427 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2430 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load32Splat(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(9), buf) is Err(t) {
2436 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2439 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load64Splat(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(10), buf) is Err(t) {
2445 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2448 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Store(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(11), buf) is Err(t) {
2454 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2457 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Const(
     |       b0,
     |       b1,
     |       b2,
     |       b3,
     |       b4,
     |       b5,
     |       b6,
     |       b7,
     |       b8,
     |       b9,
     |       b10,
     |       b11,
     |       b12,
     |       b13,
     |       b14,
     |       b15
     |     ) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(12), buf) is Err(t) {
2480 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       buf.write_byte(b0)
     |       buf.write_byte(b1)
     |       buf.write_byte(b2)
     |       buf.write_byte(b3)
     |       buf.write_byte(b4)
     |       buf.write_byte(b5)
     |       buf.write_byte(b6)
     |       buf.write_byte(b7)
     |       buf.write_byte(b8)
     |       buf.write_byte(b9)
     |       buf.write_byte(b10)
     |       buf.write_byte(b11)
     |       buf.write_byte(b12)
     |       buf.write_byte(b13)
     |       buf.write_byte(b14)
     |       buf.write_byte(b15)
     |     }
     |     I8x16Shuffle(
     |       b0,
     |       b1,
     |       b2,
     |       b3,
     |       b4,
     |       b5,
     |       b6,
     |       b7,
     |       b8,
     |       b9,
     |       b10,
     |       b11,
     |       b12,
     |       b13,
     |       b14,
     |       b15
     |     ) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(13), buf) is Err(t) {
2519 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b0, buf) is Err(t) {
2522 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b1, buf) is Err(t) {
2525 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b2, buf) is Err(t) {
2528 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b3, buf) is Err(t) {
2531 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b4, buf) is Err(t) {
2534 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b5, buf) is Err(t) {
2537 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b6, buf) is Err(t) {
2540 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b7, buf) is Err(t) {
2543 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b8, buf) is Err(t) {
2546 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b9, buf) is Err(t) {
2549 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b10, buf) is Err(t) {
2552 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b11, buf) is Err(t) {
2555 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b12, buf) is Err(t) {
2558 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b13, buf) is Err(t) {
2561 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b14, buf) is Err(t) {
2564 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(b15, buf) is Err(t) {
2567 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I8x16Swizzle => return simd_inst(14, buf)
     |     I8x16Splat => return simd_inst(15, buf)
     |     I16x8Splat => return simd_inst(16, buf)
     |     I32x4Splat => return simd_inst(17, buf)
     |     I64x2Splat => return simd_inst(18, buf)
     |     F32x4Splat => return simd_inst(19, buf)
     |     F64x2Splat => return simd_inst(20, buf)
     |     I8x16ExtractLaneS(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(21), buf) is Err(t) {
2580 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2583 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I8x16ExtractLaneU(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(22), buf) is Err(t) {
2589 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2592 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I8x16ReplaceLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(23), buf) is Err(t) {
2598 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2601 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I16x8ExtractLaneS(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(24), buf) is Err(t) {
2607 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2610 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I16x8ExtractLaneU(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(25), buf) is Err(t) {
2616 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2619 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I16x8ReplaceLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(26), buf) is Err(t) {
2625 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2628 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32x4ExtractLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(27), buf) is Err(t) {
2634 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2637 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I32x4ReplaceLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(28), buf) is Err(t) {
2643 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2646 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64x2ExtractLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(29), buf) is Err(t) {
2652 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2655 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I64x2ReplaceLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(30), buf) is Err(t) {
2661 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2664 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F32x4ExtractLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(31), buf) is Err(t) {
2670 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2673 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F32x4ReplaceLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(32), buf) is Err(t) {
2679 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2682 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F64x2ExtractLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(33), buf) is Err(t) {
2688 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2691 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F64x2ReplaceLane(l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(34), buf) is Err(t) {
2697 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2700 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     I8x16Eq => return simd_inst(35, buf)
     |     I8x16Ne => return simd_inst(36, buf)
     |     I8x16LtS => return simd_inst(37, buf)
     |     I8x16LtU => return simd_inst(38, buf)
     |     I8x16GtS => return simd_inst(39, buf)
     |     I8x16GtU => return simd_inst(40, buf)
     |     I8x16LeS => return simd_inst(41, buf)
     |     I8x16LeU => return simd_inst(42, buf)
     |     I8x16GeS => return simd_inst(43, buf)
     |     I8x16GeU => return simd_inst(44, buf)
     |     I16x8Eq => return simd_inst(45, buf)
     |     I16x8Ne => return simd_inst(46, buf)
     |     I16x8LtS => return simd_inst(47, buf)
     |     I16x8LtU => return simd_inst(48, buf)
     |     I16x8GtS => return simd_inst(49, buf)
     |     I16x8GtU => return simd_inst(50, buf)
     |     I16x8LeS => return simd_inst(51, buf)
     |     I16x8LeU => return simd_inst(52, buf)
     |     I16x8GeS => return simd_inst(53, buf)
     |     I16x8GeU => return simd_inst(54, buf)
     |     I32x4Eq => return simd_inst(55, buf)
     |     I32x4Ne => return simd_inst(56, buf)
     |     I32x4LtS => return simd_inst(57, buf)
     |     I32x4LtU => return simd_inst(58, buf)
     |     I32x4GtS => return simd_inst(59, buf)
     |     I32x4GtU => return simd_inst(60, buf)
     |     I32x4LeS => return simd_inst(61, buf)
     |     I32x4LeU => return simd_inst(62, buf)
     |     I32x4GeS => return simd_inst(63, buf)
     |     I32x4GeU => return simd_inst(64, buf)
     |     F32x4Eq => return simd_inst(65, buf)
     |     F32x4Ne => return simd_inst(66, buf)
     |     F32x4Lt => return simd_inst(67, buf)
     |     F32x4Gt => return simd_inst(68, buf)
     |     F32x4Le => return simd_inst(69, buf)
     |     F32x4Ge => return simd_inst(70, buf)
     |     F64x2Eq => return simd_inst(71, buf)
     |     F64x2Ne => return simd_inst(72, buf)
     |     F64x2Lt => return simd_inst(73, buf)
     |     F64x2Gt => return simd_inst(74, buf)
     |     F64x2Le => return simd_inst(75, buf)
     |     F64x2Ge => return simd_inst(76, buf)
     |     V128Not => return simd_inst(77, buf)
     |     V128And => return simd_inst(78, buf)
     |     V128Andnot => return simd_inst(79, buf)
     |     V128Or => return simd_inst(80, buf)
     |     V128Xor => return simd_inst(81, buf)
     |     V128Bitselect => return simd_inst(82, buf)
     |     V128AnyTrue => return simd_inst(83, buf)
     |     V128Load8Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(84), buf) is Err(t) {
2755 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2758 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2761 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load16Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(85), buf) is Err(t) {
2767 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2770 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2773 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load32Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(86), buf) is Err(t) {
2779 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2782 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2785 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load64Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(87), buf) is Err(t) {
2791 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2794 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2797 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Store8Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(88), buf) is Err(t) {
2803 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2806 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2809 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Store16Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(89), buf) is Err(t) {
2815 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2818 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2821 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Store32Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(90), buf) is Err(t) {
2827 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2830 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2833 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Store64Lane(m, l) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(91), buf) is Err(t) {
2839 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2842 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(l, buf) is Err(t) {
2845 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load32Zero(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(92), buf) is Err(t) {
2851 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2854 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     V128Load64Zero(m) => {
     |       buf.write_byte(0xFD)
     |       if Encode::encode(@lib.U32(93), buf) is Err(t) {
2860 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if Encode::encode(m, buf) is Err(t) {
2863 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     F32x4DemoteF64x2Zero => return simd_inst(94, buf)
     |     F64x2PromoteLowF32x4 => return simd_inst(95, buf)
     |     I8x16Abs => return simd_inst(96, buf)
     |     I8x16Neg => return simd_inst(97, buf)
     |     I8x16Popcnt => return simd_inst(98, buf)
     |     I8x16AllTrue => return simd_inst(99, buf)
     |     I8x16Bitmask => return simd_inst(100, buf)
     |     I8x16NarrowI16x8S => return simd_inst(101, buf)
     |     I8x16NarrowI16x8U => return simd_inst(102, buf)
     |     F32x4Ceil => return simd_inst(103, buf)
     |     F32x4Floor => return simd_inst(104, buf)
     |     F32x4Trunc => return simd_inst(105, buf)
     |     F32x4Nearest => return simd_inst(106, buf)
     |     I8x16Shl => return simd_inst(107, buf)
     |     I8x16ShrS => return simd_inst(108, buf)
     |     I8x16ShrU => return simd_inst(109, buf)
     |     I8x16Add => return simd_inst(110, buf)
     |     I8x16AddSatS => return simd_inst(111, buf)
     |     I8x16AddSatU => return simd_inst(112, buf)
     |     I8x16Sub => return simd_inst(113, buf)
     |     I8x16SubSatS => return simd_inst(114, buf)
     |     I8x16SubSatU => return simd_inst(115, buf)
     |     F64x2Ceil => return simd_inst(116, buf)
     |     F64x2Floor => return simd_inst(117, buf)
     |     I8x16MinS => return simd_inst(118, buf)
     |     I8x16MinU => return simd_inst(119, buf)
     |     I8x16MaxS => return simd_inst(120, buf)
     |     I8x16MaxU => return simd_inst(121, buf)
     |     F64x2Trunc => return simd_inst(122, buf)
     |     I8x16AvgrU => return simd_inst(123, buf)
     |     I16x8ExtaddPairwiseI8x16S => return simd_inst(124, buf)
     |     I16x8ExtaddPairwiseI8x16U => return simd_inst(125, buf)
     |     I32x4ExtaddPairwiseI16x8S => return simd_inst(126, buf)
     |     I32x4ExtaddPairwiseI16x8U => return simd_inst(127, buf)
     |     I16x8Abs => return simd_inst(128, buf)
     |     I16x8Neg => return simd_inst(129, buf)
     |     I16x8Q15mulrSatS => return simd_inst(130, buf)
     |     I16x8AllTrue => return simd_inst(131, buf)
     |     I16x8Bitmask => return simd_inst(132, buf)
     |     I16x8NarrowI32x4S => return simd_inst(133, buf)
     |     I16x8NarrowI32x4U => return simd_inst(134, buf)
     |     I16x8ExtendLowI8x16S => return simd_inst(135, buf)
     |     I16x8ExtendHighI8x16S => return simd_inst(136, buf)
     |     I16x8ExtendLowI8x16U => return simd_inst(137, buf)
     |     I16x8ExtendHighI8x16U => return simd_inst(138, buf)
     |     I16x8Shl => return simd_inst(139, buf)
     |     I16x8ShrS => return simd_inst(140, buf)
     |     I16x8ShrU => return simd_inst(141, buf)
     |     I16x8Add => return simd_inst(142, buf)
     |     I16x8AddSatS => return simd_inst(143, buf)
     |     I16x8AddSatU => return simd_inst(144, buf)
     |     I16x8Sub => return simd_inst(145, buf)
     |     I16x8SubSatS => return simd_inst(146, buf)
     |     I16x8SubSatU => return simd_inst(147, buf)
     |     F64x2Nearest => return simd_inst(148, buf)
     |     I16x8Mul => return simd_inst(149, buf)
     |     I16x8MinS => return simd_inst(150, buf)
     |     I16x8MinU => return simd_inst(151, buf)
     |     I16x8MaxS => return simd_inst(152, buf)
     |     I16x8MaxU => return simd_inst(153, buf)
     |     I16x8AvgrU => return simd_inst(155, buf)
     |     I16x8ExtmulLowI8x16S => return simd_inst(156, buf)
     |     I16x8ExtmulHighI8x16S => return simd_inst(157, buf)
     |     I16x8ExtmulLowI8x16U => return simd_inst(158, buf)
     |     I16x8ExtmulHighI8x16U => return simd_inst(159, buf)
     |     I32x4Abs => return simd_inst(160, buf)
     |     I32x4Neg => return simd_inst(161, buf)
     |     I32x4AllTrue => return simd_inst(163, buf)
     |     I32x4Bitmask => return simd_inst(164, buf)
     |     I32x4ExtendLowI16x8S => return simd_inst(167, buf)
     |     I32x4ExtendHighI16x8S => return simd_inst(168, buf)
     |     I32x4ExtendLowI16x8U => return simd_inst(169, buf)
     |     I32x4ExtendHighI16x8U => return simd_inst(170, buf)
     |     I32x4Shl => return simd_inst(171, buf)
     |     I32x4ShrS => return simd_inst(172, buf)
     |     I32x4ShrU => return simd_inst(173, buf)
     |     I32x4Add => return simd_inst(174, buf)
     |     I32x4Sub => return simd_inst(177, buf)
     |     I32x4Mul => return simd_inst(181, buf)
     |     I32x4MinS => return simd_inst(182, buf)
     |     I32x4MinU => return simd_inst(183, buf)
     |     I32x4MaxS => return simd_inst(184, buf)
     |     I32x4MaxU => return simd_inst(185, buf)
     |     I32x4DotI16x8S => return simd_inst(186, buf)
     |     I32x4ExtmulLowI16x8S => return simd_inst(188, buf)
     |     I32x4ExtmulHighI16x8S => return simd_inst(189, buf)
     |     I32x4ExtmulLowI16x8U => return simd_inst(190, buf)
     |     I32x4ExtmulHighI16x8U => return simd_inst(191, buf)
     |     I64x2Abs => return simd_inst(192, buf)
     |     I64x2Neg => return simd_inst(193, buf)
     |     I64x2AllTrue => return simd_inst(195, buf)
     |     I64x2Bitmask => return simd_inst(196, buf)
     |     I64x2ExtendLowI32x4S => return simd_inst(199, buf)
     |     I64x2ExtendHighI32x4S => return simd_inst(200, buf)
     |     I64x2ExtendLowI32x4U => return simd_inst(201, buf)
     |     I64x2ExtendHighI32x4U => return simd_inst(202, buf)
     |     I64x2Shl => return simd_inst(203, buf)
     |     I64x2ShrS => return simd_inst(204, buf)
     |     I64x2ShrU => return simd_inst(205, buf)
     |     I64x2Add => return simd_inst(206, buf)
     |     I64x2Sub => return simd_inst(209, buf)
     |     I64x2Mul => return simd_inst(213, buf)
     |     I64x2Eq => return simd_inst(214, buf)
     |     I64x2Ne => return simd_inst(215, buf)
     |     I64x2LtS => return simd_inst(216, buf)
     |     I64x2GtS => return simd_inst(217, buf)
     |     I64x2LeS => return simd_inst(218, buf)
     |     I64x2GeS => return simd_inst(219, buf)
     |     I64x2ExtmulLowI32x4S => return simd_inst(220, buf)
     |     I64x2ExtmulHighI32x4S => return simd_inst(221, buf)
     |     I64x2ExtmulLowI32x4U => return simd_inst(222, buf)
     |     I64x2ExtmulHighI32x4U => return simd_inst(223, buf)
     |     F32x4Abs => return simd_inst(224, buf)
     |     F32x4Neg => return simd_inst(225, buf)
     |     F32x4Sqrt => return simd_inst(227, buf)
     |     F32x4Add => return simd_inst(228, buf)
     |     F32x4Sub => return simd_inst(229, buf)
     |     F32x4Mul => return simd_inst(230, buf)
     |     F32x4Div => return simd_inst(231, buf)
     |     F32x4Min => return simd_inst(232, buf)
     |     F32x4Max => return simd_inst(233, buf)
     |     F32x4Pmin => return simd_inst(234, buf)
     |     F32x4Pmax => return simd_inst(235, buf)
     |     F64x2Abs => return simd_inst(236, buf)
     |     F64x2Neg => return simd_inst(237, buf)
     |     F64x2Sqrt => return simd_inst(239, buf)
     |     F64x2Add => return simd_inst(240, buf)
     |     F64x2Sub => return simd_inst(241, buf)
     |     F64x2Mul => return simd_inst(242, buf)
     |     F64x2Div => return simd_inst(243, buf)
     |     F64x2Min => return simd_inst(244, buf)
     |     F64x2Max => return simd_inst(245, buf)
     |     F64x2Pmin => return simd_inst(246, buf)
     |     F64x2Pmax => return simd_inst(247, buf)
     |     I32x4TruncSatF32x4S => return simd_inst(248, buf)
     |     I32x4TruncSatF32x4U => return simd_inst(249, buf)
     |     F32x4ConvertI32x4S => return simd_inst(250, buf)
     |     F32x4ConvertI32x4U => return simd_inst(251, buf)
     |     I32x4TruncSatF64x2SZero => return simd_inst(252, buf)
     |     I32x4TruncSatF64x2UZero => return simd_inst(253, buf)
     |     F64x2ConvertLowI32x4S => return simd_inst(254, buf)
     |     F64x2ConvertLowI32x4U => return simd_inst(255, buf)
     |     I8x16RelaxedSwizzle => return simd_inst(256, buf)
     |     I32x4RelaxedTruncF32x4S => return simd_inst(257, buf)
     |     I32x4RelaxedTruncF32x4U => return simd_inst(258, buf)
     |     I32x4RelaxedTruncZeroF64x2S => return simd_inst(259, buf)
     |     I32x4RelaxedTruncZeroF64x2U => return simd_inst(260, buf)
     |     F32x4RelaxedMadd => return simd_inst(261, buf)
     |     F32x4RelaxedNmadd => return simd_inst(262, buf)
     |     F64x2RelaxedMadd => return simd_inst(263, buf)
     |     F64x2RelaxedNmadd => return simd_inst(264, buf)
     |     I8x16RelaxedLaneselect => return simd_inst(265, buf)
     |     I16x8RelaxedLaneselect => return simd_inst(266, buf)
     |     I32x4RelaxedLaneselect => return simd_inst(267, buf)
     |     I64x2RelaxedLaneselect => return simd_inst(268, buf)
     |     F32x4RelaxedMin => return simd_inst(269, buf)
     |     F32x4RelaxedMax => return simd_inst(270, buf)
     |     F64x2RelaxedMin => return simd_inst(271, buf)
     |     F64x2RelaxedMax => return simd_inst(272, buf)
     |     I16x8RelaxedQ15mulrS => return simd_inst(273, buf)
     |     I16x8RelaxedDotI8x16I7x16S => return simd_inst(274, buf)
     |     I32x4RelaxedDotI8x16I7x16AddS => return simd_inst(275, buf)
     |   }
     |   Ok(())
     | }
     …

     | pub impl[T : Encode] Encode for Array[T] with encode(val, buf) {
     |   if Encode::encode(@lib.U32(val.length().reinterpret_as_uint()), buf) is Err(t) {
3035 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for v in val {
     |     if Encode::encode(v, buf) is Err(t) {
     |       return Err(t)
     |     }
     |   }
     |   Ok(())
     | }
     …

8 uncovered line(s) in src/binary/tests.mbt:

    | fn[T : Encode + Decode + Eq + Show] roundtrip(x : T) -> Unit raise {
    |   let buf = @buffer.new()
    |   match Encode::encode(x, buf) {
    |     Ok(_) => ()
 16 |     Err(t) => raise EncodingFailed(t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let bytes = buf.to_bytes()
    |   let (y, i2) = match Decode::decode(bytes, 0) {
    |     Ok(t) => t
 21 |     Err(t) => raise DecodingFailed(t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if bytes.length() != i2 {
 24 |     println(("Failed: Byte Length Mismatch", bytes.length(), i2))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if y != x {
 27 |     println(("Failed", x))
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     println(("Byte Representation", bytes.to_array()))
    |     let compare = @buffer.new()
    |     match Encode::encode(y, compare) {
    |       Ok(_) =>
 32 |         println(("Decoded byte representation", compare.to_bytes().to_array()))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(t) => println("Could not re-encode actual value \{t}")
    |     }
 35 |     println(("Decoded", y))
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   assert_eq(i2, bytes.length())
    |   assert_eq(y, x)
    | }
    …

    | fn[T] assert_decode_err_contains(
    |   result : Result[(T, Int), String],
    |   needle : String,
    | ) -> Unit raise {
    |   match result {
 64 |     Ok(_) => fail("expected decode failure containing \{needle}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(msg) => assert_true(msg.contains(needle))
    |   }
    | }
    …

    | fn assert_encode_err_contains(
    |   result : Result[Unit, String],
    |   needle : String,
    | ) -> Unit raise {
    |   match result {
 75 |     Ok(_) => fail("expected encode failure containing \{needle}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(msg) => assert_true(msg.contains(needle))
    |   }
    | }
    …

6 uncovered line(s) in src/ir/cfg.mbt:

    | fn lower_if(
    |   cond : TInstr,
    |   then_expr : TExpr,
    |   else_expr : TExpr?,
    |   ctx : BlockContext,
    |   builder : CFGBuilder,
    | ) -> BlockContext {
    |   let then_block = builder.block()
    |   let else_block = builder.block()
    |   let merge_block = builder.block()
    | 
    |   // Close current block
    |   builder.emit_block(
    |     ctx.id,
    |     ctx.instrs,
    |     Terminator::BrIf(cond, then_block, else_block),
    |   )
    | 
    |   // THEN branch
    |   let then_ctx = lower_expr(
    |     then_expr,
    |     BlockContext::{ id: then_block, instrs: [] },
    |     builder,
    |   )
    |   builder.emit_block(then_ctx.id, then_ctx.instrs, Terminator::Br(merge_block))
    | 
    |   // ELSE branch
    |   if else_expr is Some(e) {
    |     let else_ctx = lower_expr(
    |       e,
    |       BlockContext::{ id: else_block, instrs: [] },
    |       builder,
    |     )
    |     builder.emit_block(
    |       else_ctx.id,
    |       else_ctx.instrs,
    |       Terminator::Br(merge_block),
    |     )
    |   } else {
 98 |     builder.emit_block(else_block, [], Terminator::Br(merge_block))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // New current block
    |   BlockContext::{ id: merge_block, instrs: [] }
    | }
    …

    | pub fn CFG::dominators(self : CFG) -> Map[BlockId, BlockId] {
    |   // 1. Compute traversal order
    |   let rpo = compute_rpo(self)
    | 
    |   // 2. Initialize idoms
    |   let idom = Map::new()
    |   for b in self.blocks.keys() {
    |     idom[b] = None
    |   }
    |   idom[self.entry()] = Some(self.entry())
    | 
    |   // 3. Iteratively compute idoms
    |   let mut changed = true
    |   while changed {
    |     changed = false
    |     for b in rpo {
    |       if b == self.entry() {
    |         continue
    |       }
    |       let preds = self.predecessors(b).filter(p => idom[p] is Some(_))
    |       if preds.is_empty() {
243 |         continue
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let mut new_idom = preds[0]
    |       for p in preds.op_as_view(start=1, end=preds.length()) {
    |         new_idom = intersect(idom, p, new_idom)
    |       }
    |       if idom[b] != Some(new_idom) {
    |         idom[b] = Some(new_idom)
    |         changed = true
    |       }
    |     }
    |   }
    | 
    |   // 4. Finalize result (unwrap)
    |   let result = Map::new()
    |   for b in idom {
    |     let (b, d) = b
    |     if d is Some(x) {
    |       result[b] = x
    |     }
    |   }
    |   result
    | }
    …

    | pub fn CFG::strict_dominates(self : CFG, a : BlockId, b : BlockId) -> Bool {
285 |   a != b && self.dominates(a, b)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CFG::validate(self : CFG) -> Result[Unit, String] {
    |   for b in self.blocks {
    |     let (id, _) = b
    |     // Entry has no predecessors
    |     if id == self.entry && self.predecessors(id).length() != 0 {
294 |       return Err("entry block has predecessors")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    | 
    |     // Terminator successors must exist
    |     for succ in self.successors(id) {
    |       if !self.blocks.contains(succ) {
300 |         return Err("block has invalid successor")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    |   Ok(())
    | }
    …

    | pub fn CFG::dominance_frontier(self : CFG) -> Map[BlockId, Set[BlockId]] {
    |   let idom = self.dominators()
    |   let dom_tree = build_dom_tree(idom)
    | 
    |   // Initialize DF sets
    |   let df = Map::new()
    |   for b in self.blocks {
    |     let (b, _) = b
    |     df[b] = Set::new()
    |   }
    | 
    |   // Step 1: local DF
    |   for b in self.blocks {
    |     let (b, _) = b
    |     for s in self.successors(b) {
    |       if idom[s] != b {
    |         df[b].add(s)
    |       }
    |     }
    |   }
    | 
    |   // Step 2: up the dominator tree
    |   fn dfs(
    |     b : BlockId,
    |     cfg : CFG,
    |     dom_tree : Map[BlockId, Array[BlockId]],
    |     idom : Map[BlockId, BlockId],
    |     df : Map[BlockId, Set[BlockId]],
    |   ) -> Unit {
    |     for c in dom_tree.get(b).unwrap_or([]) {
    |       dfs(c, cfg, dom_tree, idom, df)
    |       for w in df[c] {
    |         if idom[w] != b {
341 |           df[b].add(w)
    |           ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     }
    |   }
    | 
    |   dfs(self.entry(), self, dom_tree, idom, df)
    |   df
    | }
    …

69 uncovered line(s) in src/ir/gvn.mbt:

    | fn op_to_gvn_key(op : SSAOp, state : GVNState) -> GVNKey? {
    |   match op {
    |     SSAOp::I32Const(c) => Some(GVNKey::Const32(c.0))
 37 |     SSAOp::I64Const(c) => Some(GVNKey::Const64(c.0))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::F32Const(c) => Some(GVNKey::ConstF32(c.0))
    |     SSAOp::F64Const(c) => Some(GVNKey::ConstF64(c.0))
    |     SSAOp::RefNull(ht) => Some(GVNKey::RefNull(ht))
    |     SSAOp::RefFunc(idx) => Some(GVNKey::RefFunc(idx))
    |     SSAOp::Unary(op, v) => Some(GVNKey::Unary(op, state.resolve(v)))
    |     SSAOp::Binary(op, a, b) => {
    |       let ra = state.resolve(a)
    |       let rb = state.resolve(b)
    |       // Canonicalize commutative operations
    |       let (a_canon, b_canon) = if is_commutative(op) && ra.0 > rb.0 {
    |         (rb, ra)
    |       } else {
    |         (ra, rb)
    |       }
    |       Some(GVNKey::Binary(op, a_canon, b_canon))
    |     }
    |     // Note: Loads are tricky - only safe if we track memory state
    |     // For now, skip loads to be conservative
    |     SSAOp::StructGet(ty, field, v) =>
 57 |       Some(GVNKey::StructGet(ty, field, state.resolve(v)))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayGet(ty, arr, idx) =>
 59 |       Some(GVNKey::ArrayGet(ty, state.resolve(arr), state.resolve(idx)))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Skip operations with side effects or that depend on mutable state
    |     _ => None
    |   }
    | }
    …

    | fn is_commutative(op : BinaryOp) -> Bool {
    |   match op {
    |     I32AddOp
    |     | I32MulOp
    |     | I32AndOp
    |     | I32OrOp
    |     | I32XorOp
    |     | I32EqOp
    |     | I32NeOp
    |     | I64AddOp
    |     | I64MulOp
    |     | I64AndOp
    |     | I64OrOp
    |     | I64XorOp
    |     | I64EqOp
    |     | I64NeOp
    |     | F32AddOp
    |     | F32MulOp
    |     | F32EqOp
    |     | F32NeOp
    |     | F64AddOp
    |     | F64MulOp
    |     | F64EqOp
    |     | F64NeOp => true
 90 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn apply_gvn_to_op(op : SSAOp, state : GVNState) -> SSAOp {
    |   fn r(v : SSAValue) -> SSAValue {
    |     state.resolve(v)
    |   }
    | 
    |   fn r_args(args : Array[SSAValue]) -> Array[SSAValue] {
102 |     args.map(fn(v) { r(v) })
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   match op {
    |     SSAOp::Copy(v) => SSAOp::Copy(r(v))
    |     SSAOp::I32Const(_)
    |     | SSAOp::I64Const(_)
    |     | SSAOp::F32Const(_)
    |     | SSAOp::F64Const(_)
    |     | SSAOp::V128Const(_)
    |     | SSAOp::RefNull(_)
    |     | SSAOp::RefFunc(_)
    |     | SSAOp::GlobalGet(_)
    |     | SSAOp::MemorySize(_)
    |     | SSAOp::AtomicFence
    |     | SSAOp::TableSize(_)
    |     | SSAOp::DataDrop(_)
    |     | SSAOp::ElemDrop(_)
    |     | SSAOp::StructNewDefault(_) => op
121 |     SSAOp::Unary(unop, v) => SSAOp::Unary(unop, r(v))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Binary(binop, a, b) => SSAOp::Binary(binop, r(a), r(b))
123 |     SSAOp::Select(tys, a, b, c) => SSAOp::Select(tys, r(a), r(b), r(c))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::GlobalSet(idx, v) => SSAOp::GlobalSet(idx, r(v))
125 |     SSAOp::Load(lop, memarg, addr) => SSAOp::Load(lop, memarg, r(addr))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Store(sop, memarg, addr, val) =>
127 |       SSAOp::Store(sop, memarg, r(addr), r(val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryGrow(idx, v) => SSAOp::MemoryGrow(idx, r(v))
    |     SSAOp::MemoryAtomicNotify(memarg, addr, count) =>
130 |       SSAOp::MemoryAtomicNotify(memarg, r(addr), r(count))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryAtomicWait32(memarg, addr, expected, timeout) =>
132 |       SSAOp::MemoryAtomicWait32(memarg, r(addr), r(expected), r(timeout))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryAtomicWait64(memarg, addr, expected, timeout) =>
134 |       SSAOp::MemoryAtomicWait64(memarg, r(addr), r(expected), r(timeout))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::AtomicRmw(op, memarg, addr, val) =>
136 |       SSAOp::AtomicRmw(op, memarg, r(addr), r(val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::AtomicCmpxchg(op, memarg, addr, expected, replacement) =>
138 |       SSAOp::AtomicCmpxchg(op, memarg, r(addr), r(expected), r(replacement))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryFill(idx, d, v, l) => SSAOp::MemoryFill(idx, r(d), r(v), r(l))
    |     SSAOp::MemoryCopy(di, si, d, s, l) =>
141 |       SSAOp::MemoryCopy(di, si, r(d), r(s), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryInit(data, mem, d, s, l) =>
143 |       SSAOp::MemoryInit(data, mem, r(d), r(s), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::TableGet(idx, i) => SSAOp::TableGet(idx, r(i))
    |     SSAOp::TableSet(idx, i, v) => SSAOp::TableSet(idx, r(i), r(v))
    |     SSAOp::TableGrow(idx, v, n) => SSAOp::TableGrow(idx, r(v), r(n))
    |     SSAOp::TableFill(idx, i, v, n) => SSAOp::TableFill(idx, r(i), r(v), r(n))
    |     SSAOp::TableCopy(di, si, d, s, n) =>
149 |       SSAOp::TableCopy(di, si, r(d), r(s), r(n))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::TableInit(elem, table, d, s, n) =>
151 |       SSAOp::TableInit(elem, table, r(d), r(s), r(n))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Call(func, args) => SSAOp::Call(func, r_args(args))
    |     SSAOp::CallIndirect(ty, table, args, idx) =>
154 |       SSAOp::CallIndirect(ty, table, r_args(args), r(idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::CallRef(ty, args, func) => SSAOp::CallRef(ty, r_args(args), r(func))
    |     SSAOp::RefIsNull(v) => SSAOp::RefIsNull(r(v))
    |     SSAOp::RefEq(a, b) => SSAOp::RefEq(r(a), r(b))
    |     SSAOp::RefAsNonNull(v) => SSAOp::RefAsNonNull(r(v))
    |     SSAOp::RefI31(v) => SSAOp::RefI31(r(v))
    |     SSAOp::I31GetS(v) => SSAOp::I31GetS(r(v))
    |     SSAOp::I31GetU(v) => SSAOp::I31GetU(r(v))
    |     SSAOp::RefTest(nullable, ht, v) => SSAOp::RefTest(nullable, ht, r(v))
    |     SSAOp::RefCast(nullable, ht, v) => SSAOp::RefCast(nullable, ht, r(v))
    |     SSAOp::AnyConvertExtern(v) => SSAOp::AnyConvertExtern(r(v))
    |     SSAOp::ExternConvertAny(v) => SSAOp::ExternConvertAny(r(v))
    |     SSAOp::StructNew(ty, args) => SSAOp::StructNew(ty, r_args(args))
    |     SSAOp::StructGet(ty, field, v) => SSAOp::StructGet(ty, field, r(v))
    |     SSAOp::StructGetS(ty, field, v) => SSAOp::StructGetS(ty, field, r(v))
    |     SSAOp::StructGetU(ty, field, v) => SSAOp::StructGetU(ty, field, r(v))
    |     SSAOp::StructSet(ty, field, o, v) => SSAOp::StructSet(ty, field, r(o), r(v))
    |     SSAOp::ArrayNew(ty, v, l) => SSAOp::ArrayNew(ty, r(v), r(l))
    |     SSAOp::ArrayNewDefault(ty, l) => SSAOp::ArrayNewDefault(ty, r(l))
    |     SSAOp::ArrayNewFixed(ty, args) => SSAOp::ArrayNewFixed(ty, r_args(args))
    |     SSAOp::ArrayNewData(ty, data, o, l) =>
175 |       SSAOp::ArrayNewData(ty, data, r(o), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewElem(ty, elem, o, l) =>
177 |       SSAOp::ArrayNewElem(ty, elem, r(o), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayGet(ty, arr, idx) => SSAOp::ArrayGet(ty, r(arr), r(idx))
    |     SSAOp::ArrayGetS(ty, arr, idx) => SSAOp::ArrayGetS(ty, r(arr), r(idx))
    |     SSAOp::ArrayGetU(ty, arr, idx) => SSAOp::ArrayGetU(ty, r(arr), r(idx))
    |     SSAOp::ArraySet(ty, arr, idx, v) =>
182 |       SSAOp::ArraySet(ty, r(arr), r(idx), r(v))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayLen(v) => SSAOp::ArrayLen(r(v))
    |     SSAOp::ArrayFill(ty, arr, o, v, l) =>
185 |       SSAOp::ArrayFill(ty, r(arr), r(o), r(v), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayCopy(dty, sty, d, doff, s, soff, l) =>
187 |       SSAOp::ArrayCopy(dty, sty, r(d), r(doff), r(s), r(soff), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayInitData(ty, data, arr, ao, do_, l) =>
189 |       SSAOp::ArrayInitData(ty, data, r(arr), r(ao), r(do_), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayInitElem(ty, elem, arr, ao, eo, l) =>
191 |       SSAOp::ArrayInitElem(ty, elem, r(arr), r(ao), r(eo), r(l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Splat(sop, v) => SSAOp::Splat(sop, r(v))
    |     SSAOp::ExtractLane(eop, lane, v) => SSAOp::ExtractLane(eop, lane, r(v))
    |     SSAOp::ReplaceLane(rop, lane, vec, val) =>
195 |       SSAOp::ReplaceLane(rop, lane, r(vec), r(val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Shuffle(lanes, a, b) => SSAOp::Shuffle(lanes, r(a), r(b))
    |     SSAOp::Swizzle(a, b) => SSAOp::Swizzle(r(a), r(b))
    |     SSAOp::V128Shift(sop, v, s) => SSAOp::V128Shift(sop, r(v), r(s))
    |     SSAOp::V128Ternary(top, a, b, c) =>
200 |       SSAOp::V128Ternary(top, r(a), r(b), r(c))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::V128LoadLane(lop, memarg, lane, addr, vec) =>
202 |       SSAOp::V128LoadLane(lop, memarg, lane, r(addr), r(vec))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::V128StoreLane(sop, memarg, lane, addr, vec) =>
204 |       SSAOp::V128StoreLane(sop, memarg, lane, r(addr), r(vec))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Throw(tag, args) => SSAOp::Throw(tag, r_args(args))
    |   }
    | }
    …

    | fn apply_gvn_to_terminator(
    |   term : SSATerminator,
    |   state : GVNState,
    | ) -> SSATerminator {
    |   fn r(v : SSAValue) -> SSAValue {
    |     state.resolve(v)
    |   }
    | 
    |   fn r_args(args : Array[SSAValue]) -> Array[SSAValue] {
    |     args.map(fn(v) { r(v) })
    |   }
    | 
    |   match term {
224 |     SSATerminator::Br(_) | SSATerminator::Unreachable => term
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrIf(cond, t, f) => SSATerminator::BrIf(r(cond), t, f)
    |     SSATerminator::BrTable(cond, targets, def) =>
227 |       SSATerminator::BrTable(r(cond), targets, def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrOnNull(v, null_t, nonnull_t) =>
229 |       SSATerminator::BrOnNull(r(v), null_t, nonnull_t)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrOnNonNull(v, nonnull_t, null_t) =>
231 |       SSATerminator::BrOnNonNull(r(v), nonnull_t, null_t)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrOnCast(cop, ht1, ht2, v, succ, fail) =>
233 |       SSATerminator::BrOnCast(cop, ht1, ht2, r(v), succ, fail)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrOnCastFail(cop, ht1, ht2, v, succ, fail) =>
235 |       SSATerminator::BrOnCastFail(cop, ht1, ht2, r(v), succ, fail)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::Return(vals) => SSATerminator::Return(r_args(vals))
    |     SSATerminator::ReturnCall(func, args) =>
238 |       SSATerminator::ReturnCall(func, r_args(args))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::ReturnCallIndirect(ty, table, args, idx) =>
240 |       SSATerminator::ReturnCallIndirect(ty, table, r_args(args), r(idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::ReturnCallRef(ty, args, func) =>
242 |       SSATerminator::ReturnCallRef(ty, r_args(args), r(func))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::ThrowRef(v) => SSATerminator::ThrowRef(r(v))
    |   }
    | }
    …

    | fn apply_gvn_to_phi(phi : PhiNode, state : GVNState) -> PhiNode {
250 |   let new_args : Map[BlockId, SSAValue] = Map::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for entry in phi.args {
252 |     let (pred, val) = entry
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     new_args[pred] = state.resolve(val)
    |   }
    |   PhiNode::{ local_idx: phi.local_idx, result: phi.result, args: new_args }
    | }
    …

    | fn has_side_effects(op : SSAOp) -> Bool {
    |   match op {
    |     // Pure operations - no side effects
    |     SSAOp::I32Const(_)
    |     | SSAOp::I64Const(_)
    |     | SSAOp::F32Const(_)
    |     | SSAOp::F64Const(_)
    |     | SSAOp::V128Const(_)
    |     | SSAOp::RefNull(_)
    |     | SSAOp::RefFunc(_)
    |     | SSAOp::Copy(_)
    |     | SSAOp::Unary(_, _)
    |     | SSAOp::Binary(_, _, _)
    |     | SSAOp::Select(_, _, _, _)
    |     | SSAOp::RefIsNull(_)
    |     | SSAOp::RefEq(_, _)
    |     | SSAOp::RefI31(_)
    |     | SSAOp::I31GetS(_)
    |     | SSAOp::I31GetU(_)
    |     | SSAOp::RefTest(_, _, _)
    |     | SSAOp::AnyConvertExtern(_)
    |     | SSAOp::ExternConvertAny(_)
    |     | SSAOp::Splat(_, _)
    |     | SSAOp::ExtractLane(_, _, _)
    |     | SSAOp::ReplaceLane(_, _, _, _)
    |     | SSAOp::Shuffle(_, _, _)
    |     | SSAOp::Swizzle(_, _)
    |     | SSAOp::V128Shift(_, _, _)
    |     | SSAOp::V128Ternary(_, _, _, _) => false
    | 
    |     // Reads from global state - pure but depend on mutable state
    |     SSAOp::GlobalGet(_) | SSAOp::MemorySize(_) | SSAOp::TableSize(_) => false
    | 
    |     // These can trap, so conservatively treat as having effects
294 |     SSAOp::RefAsNonNull(_) | SSAOp::RefCast(_, _, _) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |     // Memory/table reads can trap on out-of-bounds
    |     SSAOp::Load(_, _, _)
    |     | SSAOp::TableGet(_, _)
    |     | SSAOp::StructGet(_, _, _)
    |     | SSAOp::StructGetS(_, _, _)
    |     | SSAOp::StructGetU(_, _, _)
    |     | SSAOp::ArrayGet(_, _, _)
    |     | SSAOp::ArrayGetS(_, _, _)
    |     | SSAOp::ArrayGetU(_, _, _)
    |     | SSAOp::ArrayLen(_)
    |     | SSAOp::V128LoadLane(_, _, _, _, _) => true
    | 
    |     // All writes have side effects
    |     SSAOp::AtomicFence
    |     | SSAOp::GlobalSet(_, _)
    |     | SSAOp::Store(_, _, _, _)
    |     | SSAOp::MemoryAtomicNotify(_, _, _)
    |     | SSAOp::MemoryAtomicWait32(_, _, _, _)
    |     | SSAOp::MemoryAtomicWait64(_, _, _, _)
    |     | SSAOp::AtomicRmw(_, _, _, _)
    |     | SSAOp::AtomicCmpxchg(_, _, _, _, _)
    |     | SSAOp::MemoryGrow(_, _)
    |     | SSAOp::MemoryFill(_, _, _, _)
    |     | SSAOp::MemoryCopy(_, _, _, _, _)
    |     | SSAOp::MemoryInit(_, _, _, _, _)
    |     | SSAOp::DataDrop(_)
    |     | SSAOp::TableSet(_, _, _)
    |     | SSAOp::TableGrow(_, _, _)
    |     | SSAOp::TableFill(_, _, _, _)
    |     | SSAOp::TableCopy(_, _, _, _, _)
    |     | SSAOp::TableInit(_, _, _, _, _)
    |     | SSAOp::ElemDrop(_)
    |     | SSAOp::StructSet(_, _, _, _)
    |     | SSAOp::ArraySet(_, _, _, _)
    |     | SSAOp::ArrayFill(_, _, _, _, _)
    |     | SSAOp::ArrayCopy(_, _, _, _, _, _, _)
    |     | SSAOp::ArrayInitData(_, _, _, _, _, _)
    |     | SSAOp::ArrayInitElem(_, _, _, _, _, _)
    |     | SSAOp::V128StoreLane(_, _, _, _, _) => true
    | 
    |     // Calls always have potential side effects
    |     SSAOp::Call(_, _)
    |     | SSAOp::CallIndirect(_, _, _, _)
    |     | SSAOp::CallRef(_, _, _) => true
    | 
    |     // Allocations have effects (even if pure from a value perspective)
    |     SSAOp::StructNew(_, _)
    |     | SSAOp::StructNewDefault(_)
    |     | SSAOp::ArrayNew(_, _, _)
    |     | SSAOp::ArrayNewDefault(_, _)
    |     | SSAOp::ArrayNewFixed(_, _)
    |     | SSAOp::ArrayNewData(_, _, _, _)
348 |     | SSAOp::ArrayNewElem(_, _, _, _) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |     // Exceptions
351 |     SSAOp::Throw(_, _) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn invalidate_for_side_effects(op : SSAOp, state : GVNState) -> Unit {
    |   match op {
    |     // Memory writes invalidate all loads
    |     SSAOp::Store(_, _, _, _)
    |     | SSAOp::AtomicFence
    |     | SSAOp::MemoryAtomicNotify(_, _, _)
    |     | SSAOp::MemoryAtomicWait32(_, _, _, _)
    |     | SSAOp::MemoryAtomicWait64(_, _, _, _)
    |     | SSAOp::AtomicRmw(_, _, _, _)
    |     | SSAOp::AtomicCmpxchg(_, _, _, _, _)
    |     | SSAOp::MemoryFill(_, _, _, _)
    |     | SSAOp::MemoryCopy(_, _, _, _, _)
369 |     | SSAOp::MemoryInit(_, _, _, _, _) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       // Remove all Load keys from value_map
    |       let keys_to_remove : Array[GVNKey] = []
    |       for entry in state.value_map {
373 |         let (key, _) = entry
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         if key is GVNKey::Load(_, _, _) {
375 |           keys_to_remove.push(key)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       for key in keys_to_remove {
379 |         state.value_map.remove(key)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    | 
    |     // Struct writes invalidate struct reads of same type/field
384 |     SSAOp::StructSet(ty, field, _, _) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let keys_to_remove : Array[GVNKey] = []
    |       for entry in state.value_map {
387 |         let (key, _) = entry
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         if key is GVNKey::StructGet(t, f, _) && t == ty && f == field {
389 |           keys_to_remove.push(key)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       for key in keys_to_remove {
393 |         state.value_map.remove(key)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    | 
    |     // Array writes invalidate array reads of same type
    |     SSAOp::ArraySet(ty, _, _, _)
    |     | SSAOp::ArrayFill(ty, _, _, _, _)
    |     | SSAOp::ArrayCopy(ty, _, _, _, _, _, _)
    |     | SSAOp::ArrayInitData(ty, _, _, _, _, _)
402 |     | SSAOp::ArrayInitElem(ty, _, _, _, _, _) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let keys_to_remove : Array[GVNKey] = []
    |       for entry in state.value_map {
405 |         let (key, _) = entry
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         if key is GVNKey::ArrayGet(t, _, _) && t == ty {
407 |           keys_to_remove.push(key)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       for key in keys_to_remove {
411 |         state.value_map.remove(key)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    | 
    |     // Global writes invalidate that global's reads
    |     SSAOp::GlobalSet(idx, _) => state.value_map.remove(GVNKey::GlobalGet(idx))
    | 
    |     // Calls can do anything - be conservative
    |     SSAOp::Call(_, _)
    |     | SSAOp::CallIndirect(_, _, _, _)
421 |     | SSAOp::CallRef(_, _, _) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       // Invalidate all non-constant entries
    |       let keys_to_remove : Array[GVNKey] = []
    |       for entry in state.value_map {
425 |         let (key, _) = entry
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match key {
    |           GVNKey::Const32(_)
    |           | GVNKey::Const64(_)
    |           | GVNKey::ConstF32(_)
    |           | GVNKey::ConstF64(_)
    |           | GVNKey::RefNull(_)
432 |           | GVNKey::RefFunc(_) => ()
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           _ => keys_to_remove.push(key)
    |         }
    |       }
    |       for key in keys_to_remove {
437 |         state.value_map.remove(key)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
440 |     _ => ()
    |     ^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn gvn_block(block : SSABlock, state : GVNState) -> SSABlock {
    |   let new_instrs : Array[SSAInstr] = []
    |   for instr in block.instrs {
    |     match instr {
    |       SSAInstr::Assign(result, op) => {
    |         // First apply existing replacements to the op
    |         let resolved_op = apply_gvn_to_op(op, state)
    | 
    |         // Try to find an existing value number for this expression
    |         match op_to_gvn_key(resolved_op, state) {
    |           Some(key) => {
    |             // Look up or add to value numbering
    |             let canonical = state.lookup_or_add(key, result)
    |             if canonical == result {
    |               // This is a new expression, emit it
    |               new_instrs.push(SSAInstr::Assign(result, resolved_op))
    |             }
    |             // If canonical != result, we found a duplicate - don't emit,
    |             // future uses of result will be replaced with canonical
    |           }
    |           None => {
    |             // Not a pure expression we can value-number
    |             // Check for side effects that invalidate cached values
    |             if has_side_effects(resolved_op) {
470 |               invalidate_for_side_effects(resolved_op, state)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |             new_instrs.push(SSAInstr::Assign(result, resolved_op))
    |           }
    |         }
    |       }
    |       SSAInstr::Effect(op) => {
    |         let resolved_op = apply_gvn_to_op(op, state)
    |         if has_side_effects(resolved_op) {
    |           invalidate_for_side_effects(resolved_op, state)
    |         }
    |         new_instrs.push(SSAInstr::Effect(resolved_op))
    |       }
    |     }
    |   }
    | 
    |   // Apply replacements to phis
    |   let new_phis = block.phis.map(fn(phi) { apply_gvn_to_phi(phi, state) })
    | 
    |   // Apply replacements to terminator
    |   let new_term = apply_gvn_to_terminator(block.terminator, state)
    |   SSABlock::{
    |     id: block.id,
    |     phis: new_phis,
    |     instrs: new_instrs,
    |     terminator: new_term,
    |   }
    | }
    …

    | fn build_dom_children(
    |   cfg : SSACFG,
    |   idom : Map[BlockId, BlockId],
    | ) -> Map[BlockId, Array[BlockId]] {
    |   let children : Map[BlockId, Array[BlockId]] = Map::new()
    | 
    |   // Initialize empty arrays for all blocks
    |   for entry in cfg.blocks {
    |     let (id, _) = entry
    |     children[id] = []
    |   }
    | 
    |   // Build parent -> children mapping
    |   for entry in idom {
    |     let (child, parent) = entry
    |     if child != parent { // Skip self-loops (entry block)
517 |       children.get_or_init(parent, fn() { [] }).push(child)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   children
    | }
    …

    | pub fn run_gvn(cfg : SSACFG, idom : Map[BlockId, BlockId]) -> SSACFG {
    |   let dom_children = build_dom_children(cfg, idom)
    |   let state = GVNState::new()
    |   let new_blocks : Map[BlockId, SSABlock] = Map::new()
    | 
    |   // Process blocks in dominator tree order (DFS)
    |   fn process_block(
    |     block_id : BlockId,
    |     cfg : SSACFG,
    |     dom_children : Map[BlockId, Array[BlockId]],
    |     state : GVNState,
    |     new_blocks : Map[BlockId, SSABlock],
    |   ) -> Unit {
    |     match cfg.blocks.get(block_id) {
    |       Some(block) => {
    |         // Save state before processing this subtree
    |         let saved_map : Map[GVNKey, SSAValue] = Map::new()
    |         for entry in state.value_map {
543 |           let (k, v) = entry
    |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           saved_map[k] = v
    |         }
    |         let saved_replacements : Map[SSAValue, SSAValue] = Map::new()
    |         for entry in state.replacements {
548 |           let (k, v) = entry
    |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           saved_replacements[k] = v
    |         }
    | 
    |         // Process this block
    |         let new_block = gvn_block(block, state)
    |         new_blocks[block_id] = new_block
    | 
    |         // Process dominated children
    |         match dom_children.get(block_id) {
    |           Some(children) =>
    |             for child in children {
560 |               process_block(child, cfg, dom_children, state, new_blocks)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
562 |           None => ()
    |           ^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    | 
    |         // Restore state (values added by this block shouldn't be visible to siblings)
    |         state.value_map.clear()
    |         for entry in saved_map {
568 |           let (k, v) = entry
    |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           state.value_map[k] = v
    |         }
    |         // Keep replacements - they're global
    |       }
573 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   process_block(cfg.entry, cfg, dom_children, state, new_blocks)
    |   SSACFG::{
    |     entry: cfg.entry,
    |     blocks: new_blocks,
    |     preds: cfg.preds,
    |     param_values: cfg.param_values,
    |     next_value: cfg.next_value,
    |   }
    | }
    …

84 uncovered line(s) in src/ir/ir_context.mbt:

    | pub fn IRContext::get_mod(self : Self) -> Module? {
 20 |   self.mod_
    |   ^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IRContext::get_cfg(self : Self) -> CFG {
    |   match self.cfg {
 53 |     Some(val) => val
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => {
    |       let cfg = CFG::build(self.body)
    |       self.cfg = Some(cfg)
    |       cfg
    |     }
    |   }
    | }
    …

    | pub fn IRContext::get_usedef(self : Self) -> UseDefInfo {
 80 |   match self.usedef {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => val
    |     None => {
    |       let ssa = self.get_ssa()
    |       let ud = ssa.build_use_def()
    |       self.usedef = Some(ud)
    |       ud
    |     }
    |   }
    | }
    …

    | pub fn IRContext::get_liveness(self : Self) -> LivenessInfo {
 93 |   match self.liveness {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => val
    |     None => {
    |       let ssa = self.get_ssa()
    |       let li = ssa.compute_liveness()
    |       self.liveness = Some(li)
    |       li
    |     }
    |   }
    | }
    …

    | pub fn IRContext::get_types(self : Self) -> SSATypeInfo? {
106 |   match self.types {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => Some(val)
    |     None => {
    |       let ssa = self.get_ssa()
    |       let type_ctx = match self.type_ctx {
    |         Some(ctx) => ctx
    |         None => return None
    |       }
114 |       let ti = infer_ssa_types(ssa, type_ctx)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       self.types = Some(ti)
    |       Some(ti)
    |     }
    |   }
    | }
    …

    | pub fn IRContext::get_gvn(self : Self) -> SSACFG {
123 |   match self.gvn {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => val
    |     None => {
    |       let ssa = self.get_ssa()
    |       let cfg = self.get_cfg()
    |       let doms = cfg.dominators()
    |       let optimized = run_gvn(ssa, doms)
    |       self.gvn = Some(optimized)
    |       optimized
    |     }
    |   }
    | }
    …

    | pub fn IRContext::lower_to_cfg(self : Self) -> CFG {
186 |   let ssa = self.get_gvn()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ssa.to_cfg(self.locals.length())
    | }
    …

    | pub fn IRContext::apply_gvn(self : Self) -> Unit {
194 |   let optimized = self.get_gvn()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.ssa = Some(optimized)
    |   self.gvn = None
    |   // Downstream analyses were computed against the old SSA
    |   self.usedef = None
    |   self.liveness = None
    |   self.types = None
    | }
    …

    | fn terminator_successors(term : Terminator) -> Array[BlockId] {
    |   match term {
218 |     Br(t) => [t]
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     BrIf(_, t, f)
    |     | BrOnNull(_, t, f)
    |     | BrOnNonNull(_, t, f)
    |     | BrOnCast(_, _, _, _, t, f)
223 |     | BrOnCastFail(_, _, _, _, t, f) => [t, f]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     BrTable(_, targets, d) => {
    |       let out = targets.copy()
    |       out.push(d)
    |       out
    |     }
    |     Return(_)
    |     | ReturnCall(_, _)
    |     | ReturnCallIndirect(_, _, _, _)
    |     | ReturnCallRef(_, _, _)
    |     | ThrowRef(_)
    |     | Unreachable => []
    |   }
    | }
    …

    | fn collect_reachable(
    |   cfg : CFG,
    |   start : BlockId,
    |   stop : BlockId?,
    |   max_steps : Int,
    | ) -> Set[BlockId] {
    |   let seen : Set[BlockId] = Set::new()
    |   let work : Array[BlockId] = [start]
    |   let mut steps = 0
    |   while work.length() > 0 && steps < max_steps {
    |     steps = steps + 1
    |     let cur = work.pop().unwrap()
    |     if seen.contains(cur) {
252 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     seen.add(cur)
    |     if stop is Some(s) && cur == s {
256 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     match cfg.blocks.get(cur) {
    |       Some(block) =>
    |         for succ in terminator_successors(block.terminator) {
261 |           work.push(succ)
    |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
263 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   seen
    | }
    …

    | fn find_merge_block(
    |   cfg : CFG,
    |   then_block : BlockId,
    |   else_block : BlockId,
    |   stop : BlockId?,
    |   max_steps : Int,
    | ) -> BlockId? {
    |   let then_reachable = collect_reachable(cfg, then_block, stop, max_steps)
    |   let else_reachable = collect_reachable(cfg, else_block, stop, max_steps)
    |   if stop is Some(s) && then_reachable.contains(s) && else_reachable.contains(s) {
280 |     return Some(s)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let mut best : BlockId? = None
    |   for b in then_reachable {
    |     if else_reachable.contains(b) {
285 |       match best {
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         None => best = Some(b)
    |         Some(cur) if b.0 < cur.0 => best = Some(b)
    |         _ => ()
    |       }
    |     }
    |   }
    |   best
    | }
    …

    | fn find_merge_block_many(
    |   cfg : CFG,
    |   succs : Array[BlockId],
    |   stop : BlockId?,
    |   max_steps : Int,
    | ) -> BlockId? {
    |   if succs.length() == 0 {
303 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if succs.length() == 1 {
306 |     return Some(succs[0])
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let mut reachable_intersection : Set[BlockId]? = None
    |   for succ in succs {
    |     let reachable = collect_reachable(cfg, succ, stop, max_steps)
    |     match reachable_intersection {
    |       None => reachable_intersection = Some(reachable)
    |       Some(acc) => {
    |         let next_acc : Set[BlockId] = Set::new()
    |         for b in acc {
    |           if reachable.contains(b) {
317 |             next_acc.add(b)
    |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |         reachable_intersection = Some(next_acc)
    |       }
    |     }
    |   }
    |   match reachable_intersection {
325 |     None => None
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(intersection) => {
    |       if stop is Some(s) && intersection.contains(s) {
328 |         return Some(s)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let mut best : BlockId? = None
    |       for b in intersection {
332 |         match best {
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |           None => best = Some(b)
    |           Some(cur) if b.0 < cur.0 => best = Some(b)
    |           _ => ()
    |         }
    |       }
    |       best
    |     }
    |   }
    | }
    …

    | fn lower_conditional_branch(
    |   cfg : CFG,
    |   instrs : Array[TInstr],
    |   cond : TInstr,
    |   then_block : BlockId,
    |   else_block : BlockId,
    |   stop : BlockId?,
    |   depth : Int,
    |   max_depth : Int,
    | ) -> TExpr? {
    |   match find_merge_block(cfg, then_block, else_block, stop, max_depth * 2) {
    |     Some(merge) =>
363 |       match
    |       ^^^^^ 	<-- UNCOVERED
    |         (
    |           cfg_region_to_texpr(
    |             cfg,
    |             then_block,
    |             Some(merge),
    |             depth + 1,
    |             max_depth,
    |           ),
372 |           cfg_region_to_texpr(
    |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             cfg,
    |             else_block,
    |             Some(merge),
    |             depth + 1,
    |             max_depth,
    |           ),
    |         ) {
380 |         (Some(then_expr), Some(else_expr)) => {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let else_opt = if else_expr.0.length() == 0 {
382 |             None
    |             ^^^^ 	<-- UNCOVERED
    |           } else {
384 |             Some(else_expr)
    |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
386 |           instrs.push(
    |           ^^^^^^^^^^^^ 	<-- UNCOVERED
    |             TInstr::if_(BlockType::void_(), cond, then_expr, else_opt),
    |           )
    |           if stop is Some(s) && merge == s {
390 |             return Some(TExpr::new(instrs))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
392 |           match cfg_region_to_texpr(cfg, merge, stop, depth + 1, max_depth) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(tail) => {
    |               append_texpr(instrs, tail)
    |               Some(TExpr::new(instrs))
    |             }
397 |             None => None
    |             ^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
400 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     None =>
    |       match
    |         (
    |           cfg_region_to_texpr(cfg, then_block, stop, depth + 1, max_depth),
    |           cfg_region_to_texpr(cfg, else_block, stop, depth + 1, max_depth),
    |         ) {
    |         (Some(then_expr), Some(else_expr)) => {
    |           let else_opt = if else_expr.0.length() == 0 {
410 |             None
    |             ^^^^ 	<-- UNCOVERED
    |           } else {
    |             Some(else_expr)
    |           }
    |           instrs.push(
    |             TInstr::if_(BlockType::void_(), cond, then_expr, else_opt),
    |           )
    |           Some(TExpr::new(instrs))
    |         }
419 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |   }
    | }
    …

    | fn lower_br_table(
    |   cfg : CFG,
    |   instrs : Array[TInstr],
    |   idx : TInstr,
    |   targets : Array[BlockId],
    |   default : BlockId,
    |   stop : BlockId?,
    |   depth : Int,
    |   max_depth : Int,
    | ) -> TExpr? {
    |   let succs = targets.copy()
    |   succs.push(default)
    |   let merge_opt = find_merge_block_many(cfg, succs, stop, max_depth * 2)
    |   let mut dispatch = match
    |     cfg_region_to_texpr(cfg, default, merge_opt, depth + 1, max_depth) {
    |     Some(expr) => expr
441 |     None => return None
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   for i = targets.length() - 1; i >= 0; i = i - 1 {
    |     let then_expr = match
    |       cfg_region_to_texpr(cfg, targets[i], merge_opt, depth + 1, max_depth) {
    |       Some(expr) => expr
447 |       None => return None
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let cond = TInstr::binary(
    |       BinaryOp::i32_eq(),
    |       idx,
    |       TInstr::i32_const(I32(i)),
    |     )
    |     dispatch = TExpr::new([
    |       TInstr::if_(BlockType::void_(), cond, then_expr, Some(dispatch)),
    |     ])
    |   }
    |   append_texpr(instrs, dispatch)
    |   match merge_opt {
460 |     Some(merge) => {
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       if stop is Some(s) && merge == s {
462 |         return Some(TExpr::new(instrs))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
464 |       match cfg_region_to_texpr(cfg, merge, stop, depth + 1, max_depth) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(tail) => {
    |           append_texpr(instrs, tail)
    |           Some(TExpr::new(instrs))
    |         }
469 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     None => Some(TExpr::new(instrs))
    |   }
    | }
    …

    | fn cfg_region_to_texpr(
    |   cfg : CFG,
    |   block_id : BlockId,
    |   stop : BlockId?,
    |   depth : Int,
    |   max_depth : Int,
    | ) -> TExpr? {
    |   if depth > max_depth {
485 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stop is Some(s) && block_id == s {
488 |     return Some(TExpr::new([]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let block = match cfg.blocks.get(block_id) {
    |     Some(b) => b
492 |     None => return None
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let instrs = block.instrs.copy()
    |   match block.terminator {
    |     Br(target) => {
    |       if stop is Some(s) && target == s {
498 |         return Some(TExpr::new(instrs))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       match cfg_region_to_texpr(cfg, target, stop, depth + 1, max_depth) {
    |         Some(tail) => {
    |           append_texpr(instrs, tail)
    |           Some(TExpr::new(instrs))
    |         }
505 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     BrIf(cond, then_block, else_block) =>
509 |       lower_conditional_branch(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         cfg, instrs, cond, then_block, else_block, stop, depth, max_depth,
    |       )
    |     BrOnNull(v, null_block, nonnull_block) =>
513 |       lower_conditional_branch(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         cfg,
    |         instrs,
516 |         TInstr::ref_is_null(v),
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         null_block,
    |         nonnull_block,
    |         stop,
    |         depth,
    |         max_depth,
    |       )
    |     BrOnNonNull(v, nonnull_block, null_block) =>
    |       lower_conditional_branch(
    |         cfg,
    |         instrs,
    |         TInstr::ref_is_null(v),
    |         null_block,
    |         nonnull_block,
    |         stop,
    |         depth,
    |         max_depth,
    |       )
534 |     BrOnCast(op, _src_ht, dst_ht, v, success, fail) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let cond = TInstr::ref_test(op.1, dst_ht, v)
    |       lower_conditional_branch(
    |         cfg, instrs, cond, success, fail, stop, depth, max_depth,
    |       )
    |     }
    |     BrOnCastFail(op, _src_ht, dst_ht, v, fail, success) => {
    |       let test_ok = TInstr::ref_test(op.1, dst_ht, v)
    |       let cond_fail = TInstr::unary(UnaryOp::i32_eqz(), test_ok)
    |       lower_conditional_branch(
    |         cfg, instrs, cond_fail, fail, success, stop, depth, max_depth,
    |       )
    |     }
    |     BrTable(idx, targets, default) =>
    |       lower_br_table(cfg, instrs, idx, targets, default, stop, depth, max_depth)
    |     Return(vals) => {
    |       instrs.push(TInstr::return_(vals))
    |       Some(TExpr::new(instrs))
    |     }
553 |     ReturnCall(func, args) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       instrs.push(TInstr::return_call(func, args))
    |       Some(TExpr::new(instrs))
    |     }
557 |     ReturnCallIndirect(ty, table, args, idx) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       instrs.push(TInstr::return_call_indirect(ty, table, args, idx))
    |       Some(TExpr::new(instrs))
    |     }
561 |     ReturnCallRef(ty, args, func) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       instrs.push(TInstr::return_call_ref(ty, args, func))
    |       Some(TExpr::new(instrs))
    |     }
565 |     ThrowRef(v) => {
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       instrs.push(TInstr::throw_ref(v))
    |       Some(TExpr::new(instrs))
    |     }
    |     Unreachable => {
    |       instrs.push(TInstr::unreachable_())
    |       Some(TExpr::new(instrs))
    |     }
    |   }
    | }
    …

    | pub fn IRContext::validate(self : Self) -> Result[Unit, String] {
595 |   self.get_cfg().validate()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn extract_comp_type(sub_type : SubType) -> CompType {
606 |   match sub_type {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SubType(_, _, comp) => comp
    |     CompTypeSubType(comp) => comp
    |   }
    | }
    …

    | fn resolve_func_type(comp_types : Array[CompType], idx : TypeIdx) -> FuncType {
614 |   let i = match idx {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TypeIdx(n) => n
    |     RecIdx(n) => n
    |   }
618 |   match comp_types[i.reinterpret_as_int()] {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     FuncCompType(params, results) => FuncType::new(params, results)
    |     _ => abort("Expected func type at type index")
    |   }
    | }
    …

    | pub fn TypeContext::from_module(
    |   mod_ : Module,
    |   locals : Array[ValType],
    | ) -> TypeContext {
    |   // 1. Flatten type section into CompTypes indexed by type index
630 |   let comp_types : Array[CompType] = []
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match mod_.type_sec {
    |     Some(TypeSec(rec_types)) =>
633 |       for rec_type in rec_types {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match rec_type {
    |           SingleRecType(sub_type) =>
636 |             comp_types.push(extract_comp_type(sub_type))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           GroupRecType(sub_types) =>
638 |             for sub_type in sub_types {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               comp_types.push(extract_comp_type(sub_type))
    |             }
    |         }
    |       }
643 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // 2. Collect from imports first (imports precede locals in index space)
    |   let func_types : Array[FuncType] = []
    |   let global_types : Array[GlobalType] = []
    |   let table_types : Array[TableType] = []
    |   let tag_types : Array[TagType] = []
651 |   match mod_.import_sec {
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ImportSec(imports)) =>
653 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, extern_type) = import_
    |         match extern_type {
    |           FuncExternType(type_idx) =>
657 |             func_types.push(resolve_func_type(comp_types, type_idx))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           TableExternType(tt) => table_types.push(tt)
    |           GlobalExternType(gt) => global_types.push(gt)
    |           TagExternType(tt) => tag_types.push(tt)
    |           MemExternType(_) => ()
    |         }
    |       }
664 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // 3. Local function types (func_sec maps func index -> type index)
668 |   match mod_.func_sec {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(FuncSec(type_idxs)) =>
670 |       for type_idx in type_idxs {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         func_types.push(resolve_func_type(comp_types, type_idx))
    |       }
673 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // 4. Local globals
677 |   match mod_.global_sec {
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(GlobalSec(globals)) =>
679 |       for global in globals {
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Global(gt, _) = global
    |         global_types.push(gt)
    |       }
683 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // 5. Local tables
687 |   match mod_.table_sec {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(TableSec(tables)) =>
689 |       for table in tables {
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Table(tt, _) = table
    |         table_types.push(tt)
    |       }
693 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // 6. Local tags
697 |   match mod_.tag_sec {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(TagSec(tags)) =>
699 |       for tag in tags {
    |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         tag_types.push(tag)
    |       }
702 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   // 7. Extract struct and array types from the flattened type section
    |   let struct_types : Array[Array[FieldType]] = []
    |   let array_types : Array[FieldType] = []
    |   for comp_type in comp_types {
709 |     match comp_type {
    |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       StructCompType(fields) => struct_types.push(fields)
    |       ArrayCompType(field) => array_types.push(field)
    |       FuncCompType(_, _) => ()
    |     }
    |   }
    |   {
    |     func_types,
    |     global_types,
    |     table_types,
    |     struct_types,
    |     array_types,
    |     tag_types,
    |     local_types: locals,
    |   }
    | }
    …

    | pub fn IRContext::get_type_ctx(self : Self) -> Result[TypeContext, String] {
728 |   match self.type_ctx {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ctx) => Ok(ctx)
    |     None => {
    |       let mod_ = match self.get_mod() {
    |         None => return Err("No module set")
    |         Some(m) => m
    |       }
735 |       let ctx = TypeContext::from_module(mod_, self.locals)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       self.type_ctx = Some(ctx)
    |       Ok(ctx)
    |     }
    |   }
    | }
    …

    | fn extract_return_i32(expr : TExpr) -> Int? {
    |   for instr in expr.0 {
    |     match instr {
    |       TReturn([TI32Const(I32(v))]) => return Some(v)
765 |       _ => ()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   None
    | }
    …

    | fn collect_return_i32s(expr : TExpr, out : Set[Int]) -> Unit {
    |   for instr in expr.0 {
    |     match instr {
    |       TIf(_, _, then_e, else_e) => {
    |         collect_return_i32s(then_e, out)
    |         if else_e is Some(e) {
    |           collect_return_i32s(e, out)
    |         }
    |       }
    |       TReturn([TI32Const(I32(v))]) => out.add(v)
782 |       _ => ()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | }
    …

67 uncovered line(s) in src/ir/liveness.mbt:

    | fn collect_op_values(op : SSAOp, out : Set[SSAValue]) -> Unit {
    |   match op {
    |     SSAOp::Copy(v) => out.add(v)
  6 |     SSAOp::Unary(_, v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Binary(_, a, b) => {
    |       out.add(a)
    |       out.add(b)
    |     }
 11 |     SSAOp::Select(_, a, b, c) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(a)
    |       out.add(b)
    |       out.add(c)
    |     }
 16 |     SSAOp::GlobalSet(_, v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Load(_, _, addr) => out.add(addr)
    |     SSAOp::Store(_, _, addr, val) => {
    |       out.add(addr)
    |       out.add(val)
    |     }
 22 |     SSAOp::MemoryGrow(_, v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryAtomicNotify(_, addr, count) => {
    |       out.add(addr)
    |       out.add(count)
    |     }
    |     SSAOp::MemoryAtomicWait32(_, addr, expected, timeout)
 28 |     | SSAOp::MemoryAtomicWait64(_, addr, expected, timeout) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(addr)
    |       out.add(expected)
    |       out.add(timeout)
    |     }
 33 |     SSAOp::AtomicRmw(_, _, addr, val) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(addr)
    |       out.add(val)
    |     }
 37 |     SSAOp::AtomicCmpxchg(_, _, addr, expected, replacement) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(addr)
    |       out.add(expected)
    |       out.add(replacement)
    |     }
 42 |     SSAOp::MemoryFill(_, d, v, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(d)
    |       out.add(v)
    |       out.add(l)
    |     }
 47 |     SSAOp::MemoryCopy(_, _, d, s, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(d)
    |       out.add(s)
    |       out.add(l)
    |     }
 52 |     SSAOp::MemoryInit(_, _, d, s, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(d)
    |       out.add(s)
    |       out.add(l)
    |     }
 57 |     SSAOp::TableGet(_, i) => out.add(i)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::TableSet(_, i, v) => {
    |       out.add(i)
    |       out.add(v)
    |     }
 62 |     SSAOp::TableGrow(_, v, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(v)
    |       out.add(n)
    |     }
 66 |     SSAOp::TableFill(_, i, v, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(i)
    |       out.add(v)
    |       out.add(n)
    |     }
 71 |     SSAOp::TableCopy(_, _, d, s, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(d)
    |       out.add(s)
    |       out.add(n)
    |     }
 76 |     SSAOp::TableInit(_, _, d, s, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(d)
    |       out.add(s)
    |       out.add(n)
    |     }
    |     SSAOp::Call(_, args) =>
 82 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.add(a)
    |       }
 85 |     SSAOp::CallIndirect(_, _, args, idx) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for a in args {
 87 |         out.add(a)
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 89 |       out.add(idx)
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
 91 |     SSAOp::CallRef(_, args, func) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for a in args {
 93 |         out.add(a)
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 95 |       out.add(func)
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     SSAOp::RefIsNull(v)
    |     | SSAOp::RefAsNonNull(v)
    |     | SSAOp::RefI31(v)
    |     | SSAOp::I31GetS(v)
    |     | SSAOp::I31GetU(v)
    |     | SSAOp::RefTest(_, _, v)
    |     | SSAOp::RefCast(_, _, v)
    |     | SSAOp::AnyConvertExtern(v)
105 |     | SSAOp::ExternConvertAny(v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::RefEq(a, b) => {
    |       out.add(a)
    |       out.add(b)
    |     }
    |     SSAOp::StructNew(_, args) =>
111 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.add(a)
    |       }
    |     SSAOp::StructGet(_, _, v)
    |     | SSAOp::StructGetS(_, _, v)
116 |     | SSAOp::StructGetU(_, _, v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::StructSet(_, _, o, v) => {
    |       out.add(o)
    |       out.add(v)
    |     }
121 |     SSAOp::ArrayNew(_, v, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(v)
    |       out.add(l)
    |     }
125 |     SSAOp::ArrayNewDefault(_, l) => out.add(l)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewFixed(_, args) =>
127 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.add(a)
    |       }
130 |     SSAOp::ArrayNewData(_, _, o, l) | SSAOp::ArrayNewElem(_, _, o, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(o)
    |       out.add(l)
    |     }
    |     SSAOp::ArrayGet(_, a, i)
    |     | SSAOp::ArrayGetS(_, a, i)
136 |     | SSAOp::ArrayGetU(_, a, i) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(a)
    |       out.add(i)
    |     }
140 |     SSAOp::ArraySet(_, a, i, v) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(a)
    |       out.add(i)
    |       out.add(v)
    |     }
145 |     SSAOp::ArrayLen(v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayFill(_, a, o, v, l) => {
    |       out.add(a)
    |       out.add(o)
    |       out.add(v)
    |       out.add(l)
    |     }
152 |     SSAOp::ArrayCopy(_, _, d, doff, s, soff, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(d)
    |       out.add(doff)
    |       out.add(s)
    |       out.add(soff)
    |       out.add(l)
    |     }
    |     SSAOp::ArrayInitData(_, _, a, ao, do_, l)
160 |     | SSAOp::ArrayInitElem(_, _, a, ao, do_, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(a)
    |       out.add(ao)
    |       out.add(do_)
    |       out.add(l)
    |     }
166 |     SSAOp::Splat(_, v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ExtractLane(_, _, v) => out.add(v)
    |     SSAOp::ReplaceLane(_, _, vec, val) => {
    |       out.add(vec)
    |       out.add(val)
    |     }
172 |     SSAOp::Shuffle(_, a, b) | SSAOp::Swizzle(a, b) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(a)
    |       out.add(b)
    |     }
176 |     SSAOp::V128Shift(_, v, s) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(v)
    |       out.add(s)
    |     }
180 |     SSAOp::V128Ternary(_, a, b, c) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(a)
    |       out.add(b)
    |       out.add(c)
    |     }
    |     SSAOp::V128LoadLane(_, _, _, addr, vec)
186 |     | SSAOp::V128StoreLane(_, _, _, addr, vec) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.add(addr)
    |       out.add(vec)
    |     }
    |     SSAOp::Throw(_, args) =>
191 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.add(a)
    |       }
    |     // No uses
    |     SSAOp::I32Const(_)
    |     | SSAOp::I64Const(_)
    |     | SSAOp::F32Const(_)
    |     | SSAOp::F64Const(_)
    |     | SSAOp::V128Const(_)
    |     | SSAOp::RefNull(_)
    |     | SSAOp::RefFunc(_)
    |     | SSAOp::GlobalGet(_)
    |     | SSAOp::MemorySize(_)
    |     | SSAOp::AtomicFence
    |     | SSAOp::TableSize(_)
    |     | SSAOp::DataDrop(_)
    |     | SSAOp::ElemDrop(_)
    |     | SSAOp::StructNewDefault(_) => ()
    |   }
    | }
    …

    | fn collect_terminator_values(term : SSATerminator, out : Set[SSAValue]) -> Unit {
    |   match term {
    |     SSATerminator::Br(_) | SSATerminator::Unreachable => ()
217 |     SSATerminator::BrIf(cond, _, _) => out.add(cond)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrTable(cond, _, _) => out.add(cond)
    |     SSATerminator::BrOnNull(v, _, _) | SSATerminator::BrOnNonNull(v, _, _) =>
220 |       out.add(v)
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrOnCast(_, _, _, v, _, _)
222 |     | SSATerminator::BrOnCastFail(_, _, _, v, _, _) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::Return(vals) =>
    |       for v in vals {
    |         out.add(v)
    |       }
    |     SSATerminator::ReturnCall(_, args) =>
228 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.add(a)
    |       }
231 |     SSATerminator::ReturnCallIndirect(_, _, args, idx) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for a in args {
233 |         out.add(a)
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
235 |       out.add(idx)
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
237 |     SSATerminator::ReturnCallRef(_, args, func) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for a in args {
239 |         out.add(a)
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
241 |       out.add(func)
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
243 |     SSATerminator::ThrowRef(v) => out.add(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn compute_block_use_def(block : SSABlock) -> (Set[SSAValue], Set[SSAValue]) {
    |   let uses : Set[SSAValue] = Set::new()
    |   let defs : Set[SSAValue] = Set::new()
    | 
    |   // Phi definitions
    |   for phi in block.phis {
    |     defs.add(phi.result)
    |   }
    | 
    |   // Instructions (process in order to get upward-exposed uses)
    |   for instr in block.instrs {
    |     match instr {
    |       SSAInstr::Assign(result, op) => {
    |         // Collect uses that aren't already defined in this block
    |         let op_uses : Set[SSAValue] = Set::new()
    |         collect_op_values(op, op_uses)
    |         for v in op_uses {
    |           if !defs.contains(v) {
267 |             uses.add(v)
    |             ^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |         defs.add(result)
    |       }
272 |       SSAInstr::Effect(op) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let op_uses : Set[SSAValue] = Set::new()
    |         collect_op_values(op, op_uses)
    |         for v in op_uses {
276 |           if !defs.contains(v) {
    |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             uses.add(v)
    |           }
    |         }
    |       }
    |     }
    |   }
    | 
    |   // Terminator uses
    |   let term_uses : Set[SSAValue] = Set::new()
    |   collect_terminator_values(block.terminator, term_uses)
    |   for v in term_uses {
    |     if !defs.contains(v) {
289 |       uses.add(v)
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   (uses, defs)
    | }
    …

    | fn get_block_successors(term : SSATerminator) -> Array[BlockId] {
    |   match term {
    |     SSATerminator::Br(t) => [t]
300 |     SSATerminator::BrIf(_, t, f) => [t, f]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::BrTable(_, targets, def) => {
    |       let result = targets.copy()
    |       result.push(def)
    |       result
    |     }
    |     SSATerminator::BrOnNull(_, t, f)
    |     | SSATerminator::BrOnNonNull(_, t, f)
    |     | SSATerminator::BrOnCast(_, _, _, _, t, f)
309 |     | SSATerminator::BrOnCastFail(_, _, _, _, t, f) => [t, f]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSATerminator::Return(_)
    |     | SSATerminator::ReturnCall(_, _)
    |     | SSATerminator::ReturnCallIndirect(_, _, _, _)
    |     | SSATerminator::ReturnCallRef(_, _, _)
    |     | SSATerminator::ThrowRef(_)
    |     | SSATerminator::Unreachable => []
    |   }
    | }
    …

    | pub fn SSACFG::compute_liveness(self : SSACFG) -> LivenessInfo {
    |   let live_in : Map[BlockId, Set[SSAValue]] = Map::new()
    |   let live_out : Map[BlockId, Set[SSAValue]] = Map::new()
    | 
    |   // Precompute use/def sets for each block
    |   let block_uses : Map[BlockId, Set[SSAValue]] = Map::new()
    |   let block_defs : Map[BlockId, Set[SSAValue]] = Map::new()
    |   for entry in self.blocks {
    |     let (id, block) = entry
    |     let (uses, defs) = compute_block_use_def(block)
    |     block_uses[id] = uses
    |     block_defs[id] = defs
    |     live_in[id] = Set::new()
    |     live_out[id] = Set::new()
    |   }
    | 
    |   // Add phi uses to predecessor's live_out
    |   // (handled specially - phi args are live at end of corresponding predecessor)
    |   let phi_uses : Map[BlockId, Map[BlockId, Set[SSAValue]]] = Map::new()
    |   for entry in self.blocks {
    |     let (id, block) = entry
    |     for phi in block.phis {
    |       for arg_entry in phi.args {
    |         let (pred, val) = arg_entry
    |         phi_uses
    |         .get_or_init(id, fn() { Map::new() })
    |         .get_or_init(pred, fn() { Set::new() })
    |         .add(val)
    |       }
    |     }
    |   }
    | 
    |   // Iterative dataflow
    |   let mut changed = true
    |   while changed {
    |     changed = false
    | 
    |     // Process all blocks (could use reverse postorder for efficiency)
    |     for entry in self.blocks {
    |       let (id, block) = entry
    | 
    |       // live_out[B] = union of live_in[S] for all successors S
    |       //             + phi uses from B in successors
    |       let new_out : Set[SSAValue] = Set::new()
    |       let succs = get_block_successors(block.terminator)
    |       for succ in succs {
    |         // Add successor's live_in
    |         match live_in.get(succ) {
    |           Some(succ_in) =>
    |             for v in succ_in {
371 |               new_out.add(v)
    |               ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
373 |           None => ()
    |           ^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    | 
    |         // Add phi arguments that come from this block
    |         match phi_uses.get(succ) {
    |           Some(pred_map) =>
    |             match pred_map.get(id) {
    |               Some(vals) =>
    |                 for v in vals {
    |                   new_out.add(v)
    |                 }
384 |               None => ()
    |               ^^^^^^^^^^ 	<-- UNCOVERED
    |             }
386 |           None => ()
    |           ^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    | 
    |       // Check if live_out changed
    |       let old_out = live_out[id]
    |       if new_out.length() != old_out.length() {
    |         live_out[id] = new_out
    |         changed = true
    |       } else {
    |         for v in new_out {
    |           if !old_out.contains(v) {
398 |             live_out[id] = new_out
    |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             changed = true
    |             break
    |           }
    |         }
    |       }
    | 
    |       // live_in[B] = use[B] + (live_out[B] - def[B])
    |       let new_in : Set[SSAValue] = Set::new()
    | 
    |       // Add uses
    |       match block_uses.get(id) {
    |         Some(uses) =>
    |           for v in uses {
412 |             new_in.add(v)
    |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
414 |         None => ()
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    | 
    |       // Add live_out - def
    |       let defs = block_defs.get(id).unwrap_or(Set::new())
    |       for v in live_out[id] {
    |         if !defs.contains(v) {
421 |           new_in.add(v)
    |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    | 
    |       // Check if live_in changed
    |       let old_in = live_in[id]
    |       if new_in.length() != old_in.length() {
428 |         live_in[id] = new_in
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         changed = true
    |       } else {
    |         for v in new_in {
432 |           if !old_in.contains(v) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             live_in[id] = new_in
    |             changed = true
    |             break
    |           }
    |         }
    |       }
    |     }
    |   }
    |   LivenessInfo::{ live_in, live_out }
    | }
    …

10 uncovered line(s) in src/ir/local_graph.mbt:

    | fn compute_get_sets_cfg(
    |   blocks : Array[Block],
    |   instrs : Array[TInstr],
    | ) -> Map[Int, Set[LocalSet]] {
    |   let block_map = Map::new()
    |   for b in blocks {
    |     block_map[b.id] = b
    |   }
    |   let infos = extract_all_block_infos(blocks, instrs)
    |   let result = Map::new()
    |   let mut get_index = 0
    |   for block in blocks {
    |     let info = infos.get(block.id).unwrap()
    | 
    |     // collect gets in this block
    |     for action in info.actions {
    |       match action {
    |         Action::Get(idx, get_action_index) => {
    |           // scan backward inside block
    |           let mut found = false
    |           let mut i = get_action_index - 1
    |           while i >= 0 {
    |             match info.actions[i] {
    |               Action::Set(sidx, set_id) if sidx == idx => {
    |                 let s = Set::new()
    |                 s.add(LocalSet::Set(idx, instrs[set_id]))
    |                 result[get_index] = s
    |                 found = true
    |                 break
    |               }
    |               _ => ()
    |             }
    |             i = i - 1
    |           }
    |           if !found {
    |             let sets = Set::new()
    |             if block.preds.is_empty() {
    |               sets.add(LocalSet::InitValue)
    |             } else {
155 |               for pred in block.preds {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 let pred_sets = flow_back_from_block(
    |                   pred,
    |                   idx,
    |                   block_map,
    |                   infos,
    |                   instrs,
162 |                   Set::new(),
    |                   ^^^^^^^^^^^ 	<-- UNCOVERED
    |                 )
    |                 for s in pred_sets {
165 |                   sets.add(s)
    |                   ^^^^^^^^^^^ 	<-- UNCOVERED
    |                 }
    |               }
    |             }
    |             result[get_index] = sets
    |           }
    |           get_index = get_index + 1 // ✅ ADD THIS
    |         }
    |         _ => ()
    |       }
    |     }
    |   }
    |   result
    | }
    …

    | fn flow_back_from_block(
    |   block_id : Int,
    |   local_idx : LocalIdx,
    |   blocks : Map[Int, Block],
    |   infos : Map[Int, BlockInfo],
    |   instrs : Array[TInstr],
    |   visited : Set[Int],
    | ) -> Set[LocalSet] {
    | 
    |   // avoid infinite loops
191 |   if visited.contains(block_id) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return Set::new()
    |   }
194 |   let visited = visited.copy()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   visited.add(block_id)
    |   let info = infos.get(block_id).unwrap()
    |   let block = blocks.get(block_id).unwrap()
    | 
    |   // If this block has a set for the local, use it and stop.
    |   if info.last_sets.get(local_idx) is Some(set_id) {
201 |     let instr = instrs[set_id]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let result = Set::new()
    |     result.add(LocalSet::Set(local_idx, instr))
    |     return result
    |   }
    | 
    |   // Otherwise, flow to predecessors
208 |   let result = Set::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if block.preds.is_empty() {
    |     // Entry block: implicit init value
211 |     result.add(LocalSet::InitValue)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return result
    |   }
    |   for pred in block.preds {
215 |     let pred_sets = flow_back_from_block(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       pred, local_idx, blocks, infos, instrs, visited,
    |     )
    |     for s in pred_sets {
219 |       result.add(s)
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   result
    | }
    …

267 uncovered line(s) in src/ir/ssa.mbt:

     | fn SSABuilder::current_value(self : SSABuilder, l : LocalIdx) -> SSAValue? {
     |   match self.stacks.get(l) {
     |     Some(stack) if stack.length() > 0 => Some(stack[stack.length() - 1])
  27 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn collect_instr_locals(instr : TInstr, locals : Set[LocalIdx]) -> Unit {
     |   match instr {
     |     TLocalGet(l) => locals.add(l)
     |     TLocalSet(l, inner) => {
     |       locals.add(l)
     |       collect_instr_locals(inner, locals)
     |     }
  69 |     TLocalTee(l, inner) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       locals.add(l)
     |       collect_instr_locals(inner, locals)
     |     }
     | 
     |     // Recurse into all nested instructions
  75 |     TUnary(_, a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBinary(_, a, b) => {
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
  80 |     TDrop(a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TGlobalSet(_, a) => collect_instr_locals(a, locals)
     |     TRefIsNull(a) => collect_instr_locals(a, locals)
     |     TRefAsNonNull(a) => collect_instr_locals(a, locals)
     |     TRefEq(a, b) => {
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
  88 |     TI31GetS(a) | TI31GetU(a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefI31(a) => collect_instr_locals(a, locals)
     |     TArrayLen(a) => collect_instr_locals(a, locals)
     |     TAnyConvertExtern(a) | TExternConvertAny(a) =>
  92 |       collect_instr_locals(a, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TThrowRef(a) => collect_instr_locals(a, locals)
     |     TStore(_, _, addr, val) => {
     |       collect_instr_locals(addr, locals)
     |       collect_instr_locals(val, locals)
     |     }
  98 |     TLoad(_, _, addr) => collect_instr_locals(addr, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryGrow(_, a) => collect_instr_locals(a, locals)
     |     TMemoryAtomicNotify(_, addr, count) => {
     |       collect_instr_locals(addr, locals)
     |       collect_instr_locals(count, locals)
     |     }
 104 |     TMemoryAtomicWait32(_, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(addr, locals)
     |       collect_instr_locals(expected, locals)
     |       collect_instr_locals(timeout, locals)
     |     }
 109 |     TMemoryAtomicWait64(_, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(addr, locals)
     |       collect_instr_locals(expected, locals)
     |       collect_instr_locals(timeout, locals)
     |     }
 114 |     TAtomicRmw(_, _, addr, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(addr, locals)
     |       collect_instr_locals(value, locals)
     |     }
 118 |     TAtomicCmpxchg(_, _, addr, expected, replacement) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(addr, locals)
     |       collect_instr_locals(expected, locals)
     |       collect_instr_locals(replacement, locals)
     |     }
 123 |     TMemoryFill(_, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 128 |     TMemoryCopy(_, _, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 133 |     TMemoryInit(_, _, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 138 |     TTableGet(_, a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableSet(_, a, b) => {
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 143 |     TTableGrow(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 147 |     TTableFill(_, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 152 |     TTableCopy(_, _, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 157 |     TTableInit(_, _, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
     |     TCall(_, args) =>
 163 |       for a in args {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(a, locals)
     |       }
 166 |     TCallIndirect(_, _, args, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for a in args {
 168 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 170 |       collect_instr_locals(idx, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 172 |     TCallRef(_, args, func) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for a in args {
 174 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 176 |       collect_instr_locals(func, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TReturnCall(_, args) =>
 179 |       for a in args {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(a, locals)
     |       }
 182 |     TReturnCallIndirect(_, _, args, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for a in args {
 184 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 186 |       collect_instr_locals(idx, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 188 |     TReturnCallRef(_, args, func) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for a in args {
 190 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 192 |       collect_instr_locals(func, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TStructNew(_, args) =>
 195 |       for a in args {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(a, locals)
     |       }
     |     TStructGet(_, _, a) | TStructGetS(_, _, a) | TStructGetU(_, _, a) =>
 199 |       collect_instr_locals(a, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructSet(_, _, a, b) => {
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 204 |     TArrayNew(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 208 |     TArrayNewDefault(_, a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNewFixed(_, args) =>
 210 |       for a in args {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(a, locals)
     |       }
 213 |     TArrayNewData(_, _, a, b) | TArrayNewElem(_, _, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 217 |     TArrayGet(_, a, b) | TArrayGetS(_, a, b) | TArrayGetU(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 221 |     TArraySet(_, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 226 |     TArrayFill(_, a, b, c, d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |       collect_instr_locals(d, locals)
     |     }
 232 |     TArrayCopy(_, _, a, b, c, d, e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |       collect_instr_locals(d, locals)
     |       collect_instr_locals(e, locals)
     |     }
 239 |     TArrayInitData(_, _, a, b, c, d) | TArrayInitElem(_, _, a, b, c, d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |       collect_instr_locals(d, locals)
     |     }
     |     TRefGetDesc(a)
     |     | TRefTest(_, _, a)
     |     | TRefCast(_, _, a)
     |     | TRefTestDesc(_, _, a)
 249 |     | TRefCastDescEq(_, _, a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(_, a, b, c) => {
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
     |     TThrow(_, args) =>
 256 |       for a in args {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(a, locals)
     |       }
     |     TBlock(_, expr) | TLoop(_, expr) =>
 260 |       for i in expr.0 {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(i, locals)
     |       }
 263 |     TIf(_, cond, then_e, else_e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(cond, locals)
     |       for i in then_e.0 {
 266 |         collect_instr_locals(i, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if else_e is Some(e) {
 269 |         for i in e.0 {
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           collect_instr_locals(i, locals)
     |         }
     |       }
     |     }
     |     TTryTable(_, _, expr) =>
 275 |       for i in expr.0 {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(i, locals)
     |       }
     |     TBr(_, args) =>
     |       for a in args {
 280 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 282 |     TBrIf(_, cond, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(cond, locals)
     |       for a in args {
 285 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 288 |     TBrTable(_, _, cond, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(cond, locals)
     |       for a in args {
 291 |         collect_instr_locals(a, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 294 |     TBrOnNull(_, a, args) | TBrOnNonNull(_, a, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       for arg in args {
 297 |         collect_instr_locals(arg, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 300 |     TBrOnCast(_, _, _, _, a, args) | TBrOnCastFail(_, _, _, _, a, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       for arg in args {
 303 |         collect_instr_locals(arg, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TReturn(args) =>
 307 |       for a in args {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(a, locals)
     |       }
     |     TI8x16Splat(a)
     |     | TI16x8Splat(a)
     |     | TI32x4Splat(a)
     |     | TI64x2Splat(a)
     |     | TF32x4Splat(a)
 315 |     | TF64x2Splat(a) => collect_instr_locals(a, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TExtractLane(_, _, a) => collect_instr_locals(a, locals)
     |     TReplaceLane(_, _, a, b) => {
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 321 |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 325 |     TI8x16Swizzle(a, b) | TI8x16RelaxedSwizzle(a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 329 |     TV128Shift(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
 333 |     TV128Ternary(_, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |       collect_instr_locals(c, locals)
     |     }
 338 |     TV128LoadLane(_, _, _, a, b) | TV128StoreLane(_, _, _, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_instr_locals(a, locals)
     |       collect_instr_locals(b, locals)
     |     }
     | 
     |     // Instructions with no nested locals
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TUnreachable
     |     | TNop
     |     | TGlobalGet(_)
     |     | TMemorySize(_)
     |     | TAtomicFence
     |     | TTableSize(_)
     |     | TDataDrop(_)
     |     | TElemDrop(_)
     |     | TStructNewDefault(_) => ()
     |   }
     | }
     …

     | fn collect_terminator_locals(term : Terminator, locals : Set[LocalIdx]) -> Unit {
     |   match term {
     |     Br(_) | Unreachable => ()
     |     BrIf(cond, _, _) => collect_instr_locals(cond, locals)
 368 |     BrTable(cond, _, _) => collect_instr_locals(cond, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Return(values) =>
     |       for v in values {
     |         collect_instr_locals(v, locals)
     |       }
 373 |     ReturnCallRef(_, values, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for v in values {
 375 |         collect_instr_locals(v, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 377 |       collect_instr_locals(value, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 379 |     ReturnCallIndirect(_, _, values, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for v in values {
 381 |         collect_instr_locals(v, locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 383 |       collect_instr_locals(value, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     ReturnCall(_, values) =>
 386 |       for v in values {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_instr_locals(v, locals)
     |       }
 389 |     BrOnCastFail(_, _, _, value, _, _) => collect_instr_locals(value, locals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BrOnCast(_, _, _, value, BlockId(_), BlockId(_)) =>
 391 |       collect_instr_locals(value, locals)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BrOnNonNull(value, _, _) => collect_instr_locals(value, locals)
     |     BrOnNull(value, _, _) => collect_instr_locals(value, locals)
     |     ThrowRef(value) => collect_instr_locals(value, locals)
     |   }
     | }
     …

     | fn instr_defines_local(instr : TInstr, target : LocalIdx) -> Bool {
     |   match instr {
     |     TLocalSet(l, _) | TLocalTee(l, _) if l == target => true
     |     TLocalSet(_, inner) | TLocalTee(_, inner) =>
     |       instr_defines_local(inner, target)
     | 
     |     // Recurse
 423 |     TUnary(_, a) => instr_defines_local(a, target)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBinary(_, a, b) =>
     |       instr_defines_local(a, target) || instr_defines_local(b, target)
 426 |     TDrop(a) => instr_defines_local(a, target)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(_, a, b, c) =>
 428 |       instr_defines_local(a, target) ||
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instr_defines_local(b, target) ||
     |       instr_defines_local(c, target)
     |     // ... extend for other cases as needed
     |     _ => false
     |   }
     | }
     …

     | fn place_phi_nodes(
     |   cfg : CFG,
     |   df : Map[BlockId, Set[BlockId]],
     | ) -> Map[BlockId, Set[LocalIdx]] {
     |   let phi_placements : Map[BlockId, Set[LocalIdx]] = Map::new()
     | 
     |   // Initialize empty sets
     |   for entry in cfg.blocks {
     |     let (id, _) = entry
     |     phi_placements[id] = Set::new()
     |   }
     |   let all_locals = collect_all_locals(cfg)
     |   for l in all_locals {
     |     let def_blocks = collect_def_blocks(cfg, l)
     | 
     |     // Worklist algorithm
     |     let worklist : Array[BlockId] = []
     |     for b in def_blocks {
     |       worklist.push(b)
     |     }
     |     let has_phi : Set[BlockId] = Set::new()
     |     let processed : Set[BlockId] = Set::new()
     |     while worklist.length() > 0 {
     |       let b = worklist.pop().unwrap()
     |       if processed.contains(b) {
 466 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       processed.add(b)
     | 
     |       // Add phi at each block in dominance frontier
     |       match df.get(b) {
     |         Some(frontier) =>
     |           for d in frontier {
     |             if !has_phi.contains(d) {
     |               phi_placements[d].add(l)
     |               has_phi.add(d)
     |               worklist.push(d)
     |             }
     |           }
 480 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   phi_placements
     | }
     …

     | fn rename_instr(
     |   instr : TInstr,
     |   builder : SSABuilder,
     |   out : Array[SSAInstr],
     | ) -> SSAValue? {
     |   match instr {
     |     // Local access
     |     TLocalGet(l) => builder.current_value(l)
     |     TLocalSet(l, inner) => {
     |       match rename_instr(inner, builder, out) {
     |         Some(v) => {
     |           let new_val = builder.fresh()
     |           out.push(SSAInstr::Assign(new_val, SSAOp::Copy(v)))
     |           builder.push_def(l, new_val)
     |         }
 508 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       None
     |     }
     |     TLocalTee(l, inner) =>
 513 |       match rename_instr(inner, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(v) => {
     |           let new_val = builder.fresh()
     |           out.push(SSAInstr::Assign(new_val, SSAOp::Copy(v)))
     |           builder.push_def(l, new_val)
     |           Some(new_val)
     |         }
 520 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |     // Constants
     |     TI32Const(c) => {
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::I32Const(c)))
     |       Some(v)
     |     }
 529 |     TI64Const(c) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::I64Const(c)))
     |       Some(v)
     |     }
 534 |     TF32Const(c) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::F32Const(c)))
     |       Some(v)
     |     }
 539 |     TF64Const(c) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::F64Const(c)))
     |       Some(v)
     |     }
 544 |     TRefNull(ht) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::RefNull(ht)))
     |       Some(v)
     |     }
 549 |     TRefFunc(idx) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::RefFunc(idx)))
     |       Some(v)
     |     }
     |     TV128Const(
     |       b0,
     |       b1,
     |       b2,
     |       b3,
     |       b4,
     |       b5,
     |       b6,
     |       b7,
     |       b8,
     |       b9,
     |       b10,
     |       b11,
     |       b12,
     |       b13,
     |       b14,
     |       b15
 571 |     ) => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       let bytes = Bytes::from_array([
     |         b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,
     |       ])
 576 |       out.push(SSAInstr::Assign(v, SSAOp::V128Const(bytes)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(v)
     |     }
     | 
     |     // Unary/Binary
     |     TUnary(op, a) =>
 582 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Unary(op, av)))
     |           Some(v)
     |         }
 588 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TBinary(op, a, b) => {
     |       let av = rename_instr(a, builder, out)
     |       let bv = rename_instr(b, builder, out)
     |       match (av, bv) {
     |         (Some(a), Some(b)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Binary(op, a, b)))
     |           Some(v)
     |         }
 599 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     // Drop
 604 |     TDrop(a) => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = rename_instr(a, builder, out)
     |       None
     |     }
     | 
     |     // Globals
 610 |     TGlobalGet(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::GlobalGet(idx)))
     |       Some(v)
     |     }
 615 |     TGlobalSet(idx, a) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match rename_instr(a, builder, out) {
     |         Some(av) => out.push(SSAInstr::Effect(SSAOp::GlobalSet(idx, av)))
     |         None => ()
     |       }
     |       None
     |     }
     | 
     |     // Memory
 624 |     TMemorySize(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::MemorySize(idx)))
     |       Some(v)
     |     }
     |     TMemoryGrow(idx, a) =>
 630 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::MemoryGrow(idx, av)))
     |           Some(v)
     |         }
 636 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 638 |     TMemoryAtomicNotify(memarg, addr, count) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr_v = rename_instr(addr, builder, out)
     |       let count_v = rename_instr(count, builder, out)
     |       match (addr_v, count_v) {
     |         (Some(a), Some(c)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::MemoryAtomicNotify(memarg, a, c)))
     |           Some(v)
     |         }
 647 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 650 |     TMemoryAtomicWait32(memarg, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr_v = rename_instr(addr, builder, out)
     |       let expected_v = rename_instr(expected, builder, out)
     |       let timeout_v = rename_instr(timeout, builder, out)
     |       match (addr_v, expected_v, timeout_v) {
     |         (Some(a), Some(e), Some(t)) => {
     |           let v = builder.fresh()
     |           out.push(
     |             SSAInstr::Assign(v, SSAOp::MemoryAtomicWait32(memarg, a, e, t)),
     |           )
     |           Some(v)
     |         }
 662 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 665 |     TMemoryAtomicWait64(memarg, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr_v = rename_instr(addr, builder, out)
     |       let expected_v = rename_instr(expected, builder, out)
     |       let timeout_v = rename_instr(timeout, builder, out)
     |       match (addr_v, expected_v, timeout_v) {
     |         (Some(a), Some(e), Some(t)) => {
     |           let v = builder.fresh()
     |           out.push(
     |             SSAInstr::Assign(v, SSAOp::MemoryAtomicWait64(memarg, a, e, t)),
     |           )
     |           Some(v)
     |         }
 677 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 680 |     TAtomicFence => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       out.push(SSAInstr::Effect(SSAOp::AtomicFence))
     |       None
     |     }
 684 |     TAtomicRmw(op, memarg, addr, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr_v = rename_instr(addr, builder, out)
     |       let value_v = rename_instr(value, builder, out)
     |       match (addr_v, value_v) {
     |         (Some(a), Some(vv)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::AtomicRmw(op, memarg, a, vv)))
     |           Some(v)
     |         }
 693 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 696 |     TAtomicCmpxchg(op, memarg, addr, expected, replacement) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr_v = rename_instr(addr, builder, out)
     |       let expected_v = rename_instr(expected, builder, out)
     |       let replacement_v = rename_instr(replacement, builder, out)
     |       match (addr_v, expected_v, replacement_v) {
     |         (Some(a), Some(e), Some(r)) => {
     |           let v = builder.fresh()
     |           out.push(
     |             SSAInstr::Assign(v, SSAOp::AtomicCmpxchg(op, memarg, a, e, r)),
     |           )
     |           Some(v)
     |         }
 708 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TLoad(op, memarg, addr) =>
 712 |       match rename_instr(addr, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Load(op, memarg, av)))
     |           Some(v)
     |         }
 718 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 720 |     TStore(op, memarg, addr, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr_v = rename_instr(addr, builder, out)
     |       let val_v = rename_instr(val, builder, out)
     |       match (addr_v, val_v) {
     |         (Some(a), Some(v)) =>
 725 |           out.push(SSAInstr::Effect(SSAOp::Store(op, memarg, a, v)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 730 |     TMemoryFill(idx, dest, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let dest_v = rename_instr(dest, builder, out)
     |       let val_v = rename_instr(val, builder, out)
     |       let len_v = rename_instr(len, builder, out)
     |       match (dest_v, val_v, len_v) {
     |         (Some(d), Some(v), Some(l)) =>
 736 |           out.push(SSAInstr::Effect(SSAOp::MemoryFill(idx, d, v, l)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 741 |     TMemoryCopy(dst_idx, src_idx, dest, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let dest_v = rename_instr(dest, builder, out)
     |       let src_v = rename_instr(src, builder, out)
     |       let len_v = rename_instr(len, builder, out)
     |       match (dest_v, src_v, len_v) {
     |         (Some(d), Some(s), Some(l)) =>
 747 |           out.push(
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             SSAInstr::Effect(SSAOp::MemoryCopy(dst_idx, src_idx, d, s, l)),
     |           )
 750 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       None
     |     }
 754 |     TMemoryInit(data, mem, dest, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let dest_v = rename_instr(dest, builder, out)
     |       let src_v = rename_instr(src, builder, out)
     |       let len_v = rename_instr(len, builder, out)
     |       match (dest_v, src_v, len_v) {
     |         (Some(d), Some(s), Some(l)) =>
 760 |           out.push(SSAInstr::Effect(SSAOp::MemoryInit(data, mem, d, s, l)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 765 |     TDataDrop(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       out.push(SSAInstr::Effect(SSAOp::DataDrop(idx)))
     |       None
     |     }
     | 
     |     // Tables
 771 |     TTableSize(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::TableSize(idx)))
     |       Some(v)
     |     }
     |     TTableGet(idx, i) =>
 777 |       match rename_instr(i, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(iv) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::TableGet(idx, iv)))
     |           Some(v)
     |         }
 783 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 785 |     TTableSet(idx, i, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let iv = rename_instr(i, builder, out)
     |       let vv = rename_instr(val, builder, out)
     |       match (iv, vv) {
     |         (Some(i), Some(v)) =>
 790 |           out.push(SSAInstr::Effect(SSAOp::TableSet(idx, i, v)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 795 |     TTableGrow(idx, val, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vv = rename_instr(val, builder, out)
     |       let nv = rename_instr(n, builder, out)
     |       match (vv, nv) {
     |         (Some(v), Some(n)) => {
     |           let r = builder.fresh()
     |           out.push(SSAInstr::Assign(r, SSAOp::TableGrow(idx, v, n)))
     |           Some(r)
     |         }
 804 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 807 |     TTableFill(idx, i, val, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let iv = rename_instr(i, builder, out)
     |       let vv = rename_instr(val, builder, out)
     |       let nv = rename_instr(n, builder, out)
     |       match (iv, vv, nv) {
     |         (Some(i), Some(v), Some(n)) =>
 813 |           out.push(SSAInstr::Effect(SSAOp::TableFill(idx, i, v, n)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 818 |     TTableCopy(dst, src, d, s, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let dv = rename_instr(d, builder, out)
     |       let sv = rename_instr(s, builder, out)
     |       let nv = rename_instr(n, builder, out)
     |       match (dv, sv, nv) {
     |         (Some(d), Some(s), Some(n)) =>
 824 |           out.push(SSAInstr::Effect(SSAOp::TableCopy(dst, src, d, s, n)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 829 |     TTableInit(elem, table, d, s, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let dv = rename_instr(d, builder, out)
     |       let sv = rename_instr(s, builder, out)
     |       let nv = rename_instr(n, builder, out)
     |       match (dv, sv, nv) {
     |         (Some(d), Some(s), Some(n)) =>
 835 |           out.push(SSAInstr::Effect(SSAOp::TableInit(elem, table, d, s, n)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
 840 |     TElemDrop(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       out.push(SSAInstr::Effect(SSAOp::ElemDrop(idx)))
     |       None
     |     }
     | 
     |     // Calls
 846 |     TCall(func, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::Call(func, ssa_args)))
     |       Some(v)
     |     }
 852 |     TCallIndirect(ty, table, args, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       match rename_instr(idx, builder, out) {
     |         Some(iv) => {
     |           let v = builder.fresh()
     |           out.push(
     |             SSAInstr::Assign(v, SSAOp::CallIndirect(ty, table, ssa_args, iv)),
     |           )
     |           Some(v)
     |         }
 862 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 865 |     TCallRef(ty, args, func) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       match rename_instr(func, builder, out) {
     |         Some(fv) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::CallRef(ty, ssa_args, fv)))
     |           Some(v)
     |         }
 873 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     // References
     |     TRefIsNull(a) =>
 879 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::RefIsNull(av)))
     |           Some(v)
     |         }
 885 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 887 |     TRefEq(a, b) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(a, builder, out)
     |       let bv = rename_instr(b, builder, out)
     |       match (av, bv) {
     |         (Some(a), Some(b)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::RefEq(a, b)))
     |           Some(v)
     |         }
 896 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TRefAsNonNull(a) =>
 900 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::RefAsNonNull(av)))
     |           Some(v)
     |         }
 906 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefI31(a) =>
 909 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::RefI31(av)))
     |           Some(v)
     |         }
 915 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TI31GetS(a) =>
 918 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::I31GetS(av)))
     |           Some(v)
     |         }
 924 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TI31GetU(a) =>
 927 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::I31GetU(av)))
     |           Some(v)
     |         }
 933 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefTest(nullable, ht, a) =>
 936 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::RefTest(nullable, ht, av)))
     |           Some(v)
     |         }
 942 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefCast(nullable, ht, a) =>
 945 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::RefCast(nullable, ht, av)))
     |           Some(v)
     |         }
 951 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefGetDesc(a) =>
 954 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(_) => None
     |         None => None
     |       }
     |     TRefTestDesc(_, _, a) =>
 959 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(_) => None
     |         None => None
     |       }
     |     TRefCastDescEq(_, _, a) =>
 964 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(_) => None
     |         None => None
     |       }
     |     TAnyConvertExtern(a) =>
 969 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::AnyConvertExtern(av)))
     |           Some(v)
     |         }
 975 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TExternConvertAny(a) =>
 978 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ExternConvertAny(av)))
     |           Some(v)
     |         }
 984 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |     // Structs
 988 |     TStructNew(ty, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::StructNew(ty, ssa_args)))
     |       Some(v)
     |     }
 994 |     TStructNewDefault(ty) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::StructNewDefault(ty)))
     |       Some(v)
     |     }
     |     TStructGet(ty, field, a) =>
1000 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::StructGet(ty, field, av)))
     |           Some(v)
     |         }
1006 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TStructGetS(ty, field, a) =>
1009 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::StructGetS(ty, field, av)))
     |           Some(v)
     |         }
1015 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TStructGetU(ty, field, a) =>
1018 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::StructGetU(ty, field, av)))
     |           Some(v)
     |         }
1024 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1026 |     TStructSet(ty, field, obj, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ov = rename_instr(obj, builder, out)
     |       let vv = rename_instr(val, builder, out)
     |       match (ov, vv) {
     |         (Some(o), Some(v)) =>
1031 |           out.push(SSAInstr::Effect(SSAOp::StructSet(ty, field, o, v)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
     | 
     |     // Arrays
1038 |     TArrayNew(ty, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vv = rename_instr(val, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (vv, lv) {
     |         (Some(v), Some(l)) => {
     |           let r = builder.fresh()
     |           out.push(SSAInstr::Assign(r, SSAOp::ArrayNew(ty, v, l)))
     |           Some(r)
     |         }
1047 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TArrayNewDefault(ty, len) =>
1051 |       match rename_instr(len, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(lv) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayNewDefault(ty, lv)))
     |           Some(v)
     |         }
1057 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1059 |     TArrayNewFixed(ty, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       let v = builder.fresh()
     |       out.push(SSAInstr::Assign(v, SSAOp::ArrayNewFixed(ty, ssa_args)))
     |       Some(v)
     |     }
1065 |     TArrayNewData(ty, data, offset, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ov = rename_instr(offset, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (ov, lv) {
     |         (Some(o), Some(l)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayNewData(ty, data, o, l)))
     |           Some(v)
     |         }
1074 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1077 |     TArrayNewElem(ty, elem, offset, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ov = rename_instr(offset, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (ov, lv) {
     |         (Some(o), Some(l)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayNewElem(ty, elem, o, l)))
     |           Some(v)
     |         }
1086 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1089 |     TArrayGet(ty, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let iv = rename_instr(idx, builder, out)
     |       match (av, iv) {
     |         (Some(a), Some(i)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayGet(ty, a, i)))
     |           Some(v)
     |         }
1098 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1101 |     TArrayGetS(ty, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let iv = rename_instr(idx, builder, out)
     |       match (av, iv) {
     |         (Some(a), Some(i)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayGetS(ty, a, i)))
     |           Some(v)
     |         }
1110 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1113 |     TArrayGetU(ty, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let iv = rename_instr(idx, builder, out)
     |       match (av, iv) {
     |         (Some(a), Some(i)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayGetU(ty, a, i)))
     |           Some(v)
     |         }
1122 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1125 |     TArraySet(ty, arr, idx, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let iv = rename_instr(idx, builder, out)
     |       let vv = rename_instr(val, builder, out)
     |       match (av, iv, vv) {
     |         (Some(a), Some(i), Some(v)) =>
1131 |           out.push(SSAInstr::Effect(SSAOp::ArraySet(ty, a, i, v)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
     |     TArrayLen(arr) =>
1137 |       match rename_instr(arr, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ArrayLen(av)))
     |           Some(v)
     |         }
1143 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1145 |     TArrayFill(ty, arr, offset, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let ov = rename_instr(offset, builder, out)
     |       let vv = rename_instr(val, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (av, ov, vv, lv) {
     |         (Some(a), Some(o), Some(v), Some(l)) =>
1152 |           out.push(SSAInstr::Effect(SSAOp::ArrayFill(ty, a, o, v, l)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |       None
     |     }
1157 |     TArrayCopy(dst_ty, src_ty, dst, dst_off, src, src_off, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let dv = rename_instr(dst, builder, out)
     |       let dov = rename_instr(dst_off, builder, out)
     |       let sv = rename_instr(src, builder, out)
     |       let sov = rename_instr(src_off, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (dv, dov, sv, sov, lv) {
     |         (Some(d), Some(d_off), Some(s), Some(s_off), Some(l)) =>
1165 |           out.push(
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             SSAInstr::Effect(
     |               SSAOp::ArrayCopy(dst_ty, src_ty, d, d_off, s, s_off, l),
     |             ),
     |           )
1170 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       None
     |     }
1174 |     TArrayInitData(ty, data, arr, arr_off, data_off, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let aov = rename_instr(arr_off, builder, out)
     |       let dov = rename_instr(data_off, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (av, aov, dov, lv) {
     |         (Some(a), Some(ao), Some(d_off), Some(l)) =>
1181 |           out.push(
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             SSAInstr::Effect(SSAOp::ArrayInitData(ty, data, a, ao, d_off, l)),
     |           )
1184 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       None
     |     }
1188 |     TArrayInitElem(ty, elem, arr, arr_off, elem_off, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(arr, builder, out)
     |       let aov = rename_instr(arr_off, builder, out)
     |       let eov = rename_instr(elem_off, builder, out)
     |       let lv = rename_instr(len, builder, out)
     |       match (av, aov, eov, lv) {
     |         (Some(a), Some(ao), Some(e_off), Some(l)) =>
1195 |           out.push(
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             SSAInstr::Effect(SSAOp::ArrayInitElem(ty, elem, a, ao, e_off, l)),
     |           )
1198 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       None
     |     }
     | 
     |     // Select
1204 |     TSelect(types, a, b, cond) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(a, builder, out)
     |       let bv = rename_instr(b, builder, out)
     |       let cv = rename_instr(cond, builder, out)
     |       match (av, bv, cv) {
     |         (Some(a), Some(b), Some(c)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Select(types, a, b, c)))
     |           Some(v)
     |         }
1214 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     // SIMD Splats
     |     TI8x16Splat(a) =>
1220 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Splat(SplatOp::I8x16Splat, av)))
     |           Some(v)
     |         }
1226 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TI16x8Splat(a) =>
1229 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Splat(SplatOp::I16x8Splat, av)))
     |           Some(v)
     |         }
1235 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TI32x4Splat(a) =>
1238 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Splat(SplatOp::I32x4Splat, av)))
     |           Some(v)
     |         }
1244 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TI64x2Splat(a) =>
1247 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Splat(SplatOp::I64x2Splat, av)))
     |           Some(v)
     |         }
1253 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TF32x4Splat(a) =>
1256 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Splat(SplatOp::F32x4Splat, av)))
     |           Some(v)
     |         }
1262 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TF64x2Splat(a) =>
1265 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Splat(SplatOp::F64x2Splat, av)))
     |           Some(v)
     |         }
1271 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TExtractLane(op, lane, a) =>
1274 |       match rename_instr(a, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(av) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::ExtractLane(op, lane, av)))
     |           Some(v)
     |         }
1280 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1282 |     TReplaceLane(op, lane, vec, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vv = rename_instr(vec, builder, out)
     |       let valv = rename_instr(val, builder, out)
     |       match (vv, valv) {
     |         (Some(v), Some(val)) => {
     |           let r = builder.fresh()
     |           out.push(SSAInstr::Assign(r, SSAOp::ReplaceLane(op, lane, v, val)))
     |           Some(r)
     |         }
1291 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TI8x16Shuffle(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15,
     |       a,
     |       b
1313 |     ) => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(a, builder, out)
     |       let bv = rename_instr(b, builder, out)
     |       match (av, bv) {
     |         (Some(a), Some(b)) => {
     |           let v = builder.fresh()
     |           let lanes = [
     |             l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15,
     |           ]
1322 |           out.push(SSAInstr::Assign(v, SSAOp::Shuffle(lanes, a, b)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(v)
     |         }
1325 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1328 |     TI8x16Swizzle(a, b) | TI8x16RelaxedSwizzle(a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(a, builder, out)
     |       let bv = rename_instr(b, builder, out)
     |       match (av, bv) {
     |         (Some(a), Some(b)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::Swizzle(a, b)))
     |           Some(v)
     |         }
1337 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1340 |     TV128Shift(op, vec, shift) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vv = rename_instr(vec, builder, out)
     |       let sv = rename_instr(shift, builder, out)
     |       match (vv, sv) {
     |         (Some(v), Some(s)) => {
     |           let r = builder.fresh()
     |           out.push(SSAInstr::Assign(r, SSAOp::V128Shift(op, v, s)))
     |           Some(r)
     |         }
1349 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1352 |     TV128Ternary(op, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(a, builder, out)
     |       let bv = rename_instr(b, builder, out)
     |       let cv = rename_instr(c, builder, out)
     |       match (av, bv, cv) {
     |         (Some(a), Some(b), Some(c)) => {
     |           let v = builder.fresh()
     |           out.push(SSAInstr::Assign(v, SSAOp::V128Ternary(op, a, b, c)))
     |           Some(v)
     |         }
1362 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1365 |     TV128LoadLane(op, memarg, lane, addr, vec) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(addr, builder, out)
     |       let vv = rename_instr(vec, builder, out)
     |       match (av, vv) {
     |         (Some(a), Some(v)) => {
     |           let r = builder.fresh()
     |           out.push(
     |             SSAInstr::Assign(r, SSAOp::V128LoadLane(op, memarg, lane, a, v)),
     |           )
     |           Some(r)
     |         }
1376 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1379 |     TV128StoreLane(op, memarg, lane, addr, vec) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let av = rename_instr(addr, builder, out)
     |       let vv = rename_instr(vec, builder, out)
     |       match (av, vv) {
     |         (Some(a), Some(v)) =>
1384 |           out.push(
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             SSAInstr::Effect(SSAOp::V128StoreLane(op, memarg, lane, a, v)),
     |           )
1387 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       None
     |     }
     | 
     |     // Exceptions
1393 |     TThrow(tag, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       out.push(SSAInstr::Effect(SSAOp::Throw(tag, ssa_args)))
     |       None
     |     }
1398 |     TThrowRef(_) => None // Handled at terminator level
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Simple instructions
1401 |     TUnreachable => None
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TNop => None
     | 
     |     // Control flow - these shouldn't appear in basic block instructions
     |     // as they should have been converted to terminators
1406 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => None
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBr(_, _) | TBrIf(_, _, _) | TBrTable(_, _, _, _) => None
1408 |     TBrOnNull(_, _, _) | TBrOnNonNull(_, _, _) => None
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBrOnCast(_, _, _, _, _, _) | TBrOnCastFail(_, _, _, _, _, _) => None
     |     TReturn(_) => None
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
1413 |     | TReturnCallRef(_, _, _) => None
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rename_args(
     |   args : Array[TInstr],
     |   builder : SSABuilder,
     |   out : Array[SSAInstr],
     | ) -> Array[SSAValue] {
     |   let result : Array[SSAValue] = []
     |   for arg in args {
     |     match rename_instr(arg, builder, out) {
     |       Some(v) => result.push(v)
1427 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   result
     | }
     …

     | fn rename_terminator(
     |   term : Terminator,
     |   builder : SSABuilder,
     |   out : Array[SSAInstr],
     | ) -> SSATerminator {
     |   match term {
     |     Br(target) => SSATerminator::Br(target)
     |     Unreachable => SSATerminator::Unreachable
     |     BrIf(cond, t, f) =>
     |       match rename_instr(cond, builder, out) {
     |         Some(cv) => SSATerminator::BrIf(cv, t, f)
1445 |         None => SSATerminator::Unreachable
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     BrTable(cond, targets, default) =>
1448 |       match rename_instr(cond, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(cv) => SSATerminator::BrTable(cv, targets, default)
     |         None => SSATerminator::Unreachable
     |       }
     |     BrOnNull(val, t, f) =>
1453 |       match rename_instr(val, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(v) => SSATerminator::BrOnNull(v, t, f)
     |         None => SSATerminator::Unreachable
     |       }
     |     BrOnNonNull(val, t, f) =>
1458 |       match rename_instr(val, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(v) => SSATerminator::BrOnNonNull(v, t, f)
     |         None => SSATerminator::Unreachable
     |       }
     |     BrOnCast(op, ht1, ht2, val, t, f) =>
1463 |       match rename_instr(val, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(v) => SSATerminator::BrOnCast(op, ht1, ht2, v, t, f)
     |         None => SSATerminator::Unreachable
     |       }
     |     BrOnCastFail(op, ht1, ht2, val, t, f) =>
1468 |       match rename_instr(val, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(v) => SSATerminator::BrOnCastFail(op, ht1, ht2, v, t, f)
     |         None => SSATerminator::Unreachable
     |       }
     |     Return(values) => {
     |       let ssa_values = rename_args(values, builder, out)
     |       SSATerminator::Return(ssa_values)
     |     }
1476 |     ReturnCall(func, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       SSATerminator::ReturnCall(func, ssa_args)
     |     }
1480 |     ReturnCallIndirect(ty, table, args, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       match rename_instr(idx, builder, out) {
     |         Some(i) => SSATerminator::ReturnCallIndirect(ty, table, ssa_args, i)
     |         None => SSATerminator::Unreachable
     |       }
     |     }
1487 |     ReturnCallRef(ty, args, func) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ssa_args = rename_args(args, builder, out)
     |       match rename_instr(func, builder, out) {
     |         Some(f) => SSATerminator::ReturnCallRef(ty, ssa_args, f)
     |         None => SSATerminator::Unreachable
     |       }
     |     }
     |     ThrowRef(val) =>
1495 |       match rename_instr(val, builder, out) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(v) => SSATerminator::ThrowRef(v)
     |         None => SSATerminator::Unreachable
     |       }
     |   }
     | }
     …

     | fn rename_block(
     |   cfg : CFG,
     |   block_id : BlockId,
     |   builder : SSABuilder,
     |   phi_placements : Map[BlockId, Set[LocalIdx]],
     |   dom_children : Map[BlockId, Array[BlockId]],
     |   ssa_blocks : Map[BlockId, SSABlock],
     |   pending_phi_args : Map[BlockId, Map[(LocalIdx, BlockId), SSAValue]],
     | ) -> Unit {
     |   let checkpoint = builder.save_checkpoint()
     |   let block = cfg.blocks[block_id]
     | 
     |   // Create phi nodes for this block
     |   let phis : Array[PhiNode] = []
     |   match phi_placements.get(block_id) {
     |     Some(locals) =>
     |       for l in locals {
     |         let result = builder.fresh()
     |         let phi = PhiNode::{ local_idx: l, result, args: Map::new() }
     |         phis.push(phi)
     |         builder.push_def(l, result)
     |       }
1529 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Rename instructions
     |   let instrs : Array[SSAInstr] = []
     |   for instr in block.instrs {
     |     let _ = rename_instr(instr, builder, instrs)
     |   }
     | 
     |   // Rename terminator
     |   let terminator = rename_terminator(block.terminator, builder, instrs)
     | 
     |   // Create SSA block
     |   let ssa_block = SSABlock::{ id: block_id, phis, instrs, terminator }
     | 
     |   // Apply pending phi args recorded by previously processed predecessors.
     |   match pending_phi_args.get(block_id) {
     |     Some(pending) =>
     |       for entry in pending {
     |         let ((local_idx, pred_id), val) = entry
     |         for phi in ssa_block.phis {
     |           if phi.local_idx == local_idx && !phi.args.contains(pred_id) {
     |             phi.args[pred_id] = val
     |           }
     |         }
     |       }
     |     None => ()
     |   }
     |   pending_phi_args.remove(block_id)
     |   ssa_blocks[block_id] = ssa_block
     | 
     |   // Fill in phi arguments for successors
     |   let successors = get_successors(block.terminator)
     |   for succ in successors {
     |     match phi_placements.get(succ) {
     |       Some(locals) =>
     |         for l in locals {
     |           match builder.current_value(l) {
     |             Some(val) =>
     |               // Find the phi node in successor and add argument
     |               match ssa_blocks.get(succ) {
     |                 Some(succ_block) =>
1571 |                   for phi in succ_block.phis {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     if phi.local_idx == l {
     |                       phi.args[block_id] = val
     |                     }
     |                   }
     |                 None =>
     |                   pending_phi_args.get_or_init(succ, fn() { Map::new() })[(
     |                     l, block_id,
     |                   )] = val
     |               }
1581 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
1584 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   // Recurse to dominator tree children
     |   match dom_children.get(block_id) {
     |     Some(children) =>
     |       for child in children {
     |         rename_block(
     |           cfg, child, builder, phi_placements, dom_children, ssa_blocks, pending_phi_args,
     |         )
     |       }
1596 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Restore builder state
     |   builder.restore_checkpoint(checkpoint)
     | }
     …

     | fn get_successors(term : Terminator) -> Array[BlockId] {
     |   match term {
     |     Br(target) => [target]
     |     BrIf(_, t, f)
     |     | BrOnNull(_, t, f)
     |     | BrOnNonNull(_, t, f)
     |     | BrOnCast(_, _, _, _, t, f)
     |     | BrOnCastFail(_, _, _, _, t, f) => [t, f]
1612 |     BrTable(_, targets, default) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let result = targets.copy()
     |       result.push(default)
     |       result
     |     }
     |     Return(_)
     |     | ReturnCall(_, _)
     |     | ReturnCallIndirect(_, _, _, _)
     |     | ReturnCallRef(_, _, _)
     |     | ThrowRef(_)
     |     | Unreachable => []
     |   }
     | }
     …

     | fn fill_phi_args(
     |   cfg : CFG,
     |   ssa_blocks : Map[BlockId, SSABlock],
     |   phi_placements : Map[BlockId, Set[LocalIdx]],
     |   builder : SSABuilder,
     |   dom_children : Map[BlockId, Array[BlockId]],
     |   block_id : BlockId,
     | ) -> Unit {
     |   let checkpoint = builder.save_checkpoint()
     | 
     |   // Re-establish definitions for this block
     |   match ssa_blocks.get(block_id) {
     |     Some(ssa_block) =>
     |       // Push phi results
     |       for phi in ssa_block.phis {
     |         builder.push_def(phi.local_idx, phi.result)
     |       }
     | 
     |     // Walk through instructions to rebuild local state
     |     // (SSA values from Assign instructions that came from local.set/tee)
     |     // This is a simplified approach - in practice you'd track this during rename
1652 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Fill phi args for successors
     |   let block = cfg.blocks[block_id]
     |   let successors = get_successors(block.terminator)
     |   for succ in successors {
     |     match ssa_blocks.get(succ) {
     |       Some(succ_block) =>
     |         for phi in succ_block.phis {
     |           if !phi.args.contains(block_id) {
1663 |             match builder.current_value(phi.local_idx) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(val) => phi.args[block_id] = val
     |               None => ()
     |             }
     |           }
     |         }
1669 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   // Recurse
     |   match dom_children.get(block_id) {
     |     Some(children) =>
     |       for child in children {
     |         fill_phi_args(
     |           cfg, ssa_blocks, phi_placements, builder, dom_children, child,
     |         )
     |       }
1681 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   builder.restore_checkpoint(checkpoint)
     | }
     …

     | pub fn CFG::to_ssa(
     |   self : CFG,
     |   dom : Map[BlockId, BlockId],
     |   df : Map[BlockId, Set[BlockId]],
     |   param_count : Int,
     | ) -> SSACFG {
     |   let builder = SSABuilder::new()
     | 
     |   // Initialize SSA values for function parameters
     |   let param_values : Map[LocalIdx, SSAValue] = Map::new()
     |   for i = 0; i < param_count; i = i + 1 {
     |     let l = LocalIdx::new(i.reinterpret_as_uint())
     |     let val = builder.fresh()
     |     param_values[l] = val
     |     builder.push_def(l, val)
     |   }
     | 
     |   // Place phi nodes
     |   let phi_placements = place_phi_nodes(self, df)
     | 
     |   // Build dominator tree (children map)
     |   let dom_children : Map[BlockId, Array[BlockId]] = Map::new()
     |   for entry in self.blocks {
     |     let (id, _) = entry
     |     dom_children[id] = []
     |   }
     |   for entry in dom {
     |     let (child, parent) = entry
     |     if child != parent { // Skip entry block
     |       match dom_children.get(parent) {
     |         Some(children) => children.push(child)
1722 |         None => dom_children[parent] = [child]
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | 
     |   // Rename variables via DFS
     |   let ssa_blocks : Map[BlockId, SSABlock] = Map::new()
     |   let pending_phi_args : Map[BlockId, Map[(LocalIdx, BlockId), SSAValue]] = Map::new()
     |   rename_block(
     |     self,
     |     self.entry,
     |     builder,
     |     phi_placements,
     |     dom_children,
     |     ssa_blocks,
     |     pending_phi_args,
     |   )
     | 
     |   // Second pass to fill any remaining phi arguments
     |   let builder2 = SSABuilder::new()
     |   for i = 0; i < param_count; i = i + 1 {
     |     let l = LocalIdx::new(i.reinterpret_as_uint())
     |     match param_values.get(l) {
     |       Some(val) => builder2.push_def(l, val)
1746 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   fill_phi_args(
     |     self,
     |     ssa_blocks,
     |     phi_placements,
     |     builder2,
     |     dom_children,
     |     self.entry,
     |   )
     |   SSACFG::{
     |     entry: self.entry,
     |     blocks: ssa_blocks,
     |     preds: self.preds,
     |     param_values,
     |     next_value: builder.next_value,
     |   }
     | }
     …

66 uncovered line(s) in src/ir/ssa_destruction.mbt:

    | fn get_ssa_successors(term : SSATerminator) -> Array[BlockId] {
    |   match term {
    |     Br(t) => [t]
    |     BrOnCast(CastOp(_, _), _, _, SSAValue(_), t, f)
    |     | BrOnNonNull(SSAValue(_), t, f)
    |     | BrOnNull(SSAValue(_), t, f)
    |     | BrOnCastFail(CastOp(_, _), _, _, SSAValue(_), t, f)
    |     | BrIf(_, t, f) => [t, f]
 39 |     BrTable(_, targets, d) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let result = targets.copy()
    |       result.push(d)
    |       result
    |     }
    |     _ => []
    |   }
    | }
    …

    | pub fn SSACFG::split_critical_edges(self : SSACFG) -> SSACFG {
    |   let new_blocks : Map[BlockId, SSABlock] = Map::new()
    |   let new_preds : Map[BlockId, Array[BlockId]] = Map::new()
    |   let mut next_id = 0
    | 
    |   // Find max block id
    |   for entry in self.blocks {
    |     let (BlockId(id), _) = entry
    |     if id >= next_id {
    |       next_id = id + 1
    |     }
    |   }
    | 
    |   // Maps (pred, succ) -> new intermediate block
    |   let split_blocks : Map[(BlockId, BlockId), BlockId] = Map::new()
    | 
    |   // First pass: identify critical edges
    |   for entry in self.blocks {
    |     let (block_id, block) = entry
    |     let succs = get_ssa_successors(block.terminator)
    |     for succ in succs {
    |       if is_critical_edge(self, block_id, succ) {
    |         let new_id = BlockId(next_id)
    |         next_id = next_id + 1
    |         split_blocks[(block_id, succ)] = new_id
    |       }
    |     }
    |   }
    | 
    |   // Second pass: create new blocks and update terminators
    |   for entry in self.blocks {
    |     let (block_id, block) = entry
    | 
    |     // Update terminator to point to split blocks
    |     let new_term = match block.terminator {
    |       SSATerminator::Br(t) =>
    |         match split_blocks.get((block_id, t)) {
 87 |           Some(new_id) => SSATerminator::Br(new_id)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           None => SSATerminator::Br(t)
    |         }
    |       SSATerminator::BrIf(cond, t, f) => {
    |         let new_t = split_blocks.get((block_id, t)).unwrap_or(t)
    |         let new_f = split_blocks.get((block_id, f)).unwrap_or(f)
    |         SSATerminator::BrIf(cond, new_t, new_f)
    |       }
    |       SSATerminator::BrOnNull(val, t, f) => {
    |         let new_t = split_blocks.get((block_id, t)).unwrap_or(t)
    |         let new_f = split_blocks.get((block_id, f)).unwrap_or(f)
    |         SSATerminator::BrOnNull(val, new_t, new_f)
    |       }
100 |       SSATerminator::BrOnNonNull(val, t, f) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let new_t = split_blocks.get((block_id, t)).unwrap_or(t)
    |         let new_f = split_blocks.get((block_id, f)).unwrap_or(f)
    |         SSATerminator::BrOnNonNull(val, new_t, new_f)
    |       }
105 |       SSATerminator::BrOnCast(cop, ht1, ht2, val, t, f) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let new_t = split_blocks.get((block_id, t)).unwrap_or(t)
    |         let new_f = split_blocks.get((block_id, f)).unwrap_or(f)
    |         SSATerminator::BrOnCast(cop, ht1, ht2, val, new_t, new_f)
    |       }
110 |       SSATerminator::BrOnCastFail(cop, ht1, ht2, val, t, f) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let new_t = split_blocks.get((block_id, t)).unwrap_or(t)
    |         let new_f = split_blocks.get((block_id, f)).unwrap_or(f)
    |         SSATerminator::BrOnCastFail(cop, ht1, ht2, val, new_t, new_f)
    |       }
115 |       SSATerminator::BrTable(cond, targets, d) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let new_targets = targets.map(fn(t) {
    |           split_blocks.get((block_id, t)).unwrap_or(t)
    |         })
119 |         let new_d = split_blocks.get((block_id, d)).unwrap_or(d)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         SSATerminator::BrTable(cond, new_targets, new_d)
    |       }
    |       other => other
    |     }
    | 
    |     // Update phi args to come from split blocks
    |     let new_phis = block.phis.map(fn(phi) {
    |       let new_args : Map[BlockId, SSAValue] = Map::new()
    |       for arg_entry in phi.args {
    |         let (pred, val) = arg_entry
    |         match split_blocks.get((pred, block_id)) {
    |           Some(split_id) => new_args[split_id] = val
    |           None => new_args[pred] = val
    |         }
    |       }
    |       PhiNode::{ local_idx: phi.local_idx, result: phi.result, args: new_args }
    |     })
    |     new_blocks[block_id] = SSABlock::{
    |       id: block_id,
    |       phis: new_phis,
    |       instrs: block.instrs,
    |       terminator: new_term,
    |     }
    |   }
    | 
    |   // Create the split blocks (empty, just jump to original target)
    |   for entry in split_blocks {
    |     let ((_, succ), new_id) = entry
    |     new_blocks[new_id] = SSABlock::{
    |       id: new_id,
    |       phis: [],
    |       instrs: [],
    |       terminator: SSATerminator::Br(succ),
    |     }
    |   }
    | 
    |   // Recompute predecessors
    |   for entry in new_blocks {
    |     let (_, block) = entry
    |     for succ in get_ssa_successors(block.terminator) {
    |       new_preds.get_or_init(succ, fn() { [] }).push(block.id)
    |     }
    |   }
    |   SSACFG::{
    |     entry: self.entry,
    |     blocks: new_blocks,
    |     preds: new_preds,
    |     param_values: self.param_values,
    |     next_value: self.next_value,
    |   }
    | }
    …

    | pub fn SSACFG::to_cfg(self : SSACFG, param_count : Int) -> CFG {
    |   let destructor = SSADestructor::new(param_count)
    |   let blocks : Map[BlockId, BasicBlock] = Map::new()
    | 
    |   // First pass: assign locals to all SSA values
    |   for entry in self.param_values {
    |     let (local_idx, val) = entry
    |     destructor.value_to_local[val] = local_idx
    |   }
    | 
    |   // Assign locals to all defined values
    |   for entry in self.blocks {
    |     let (_, block) = entry
    |     for phi in block.phis {
    |       let _ = destructor.get_local(phi.result)
    |     }
    |     for instr in block.instrs {
    |       if instr is SSAInstr::Assign(result, _) {
    |         ignore(destructor.get_local(result))
    |       }
    |     }
    |   }
    | 
    |   // Second pass: convert blocks
    |   for entry in self.blocks {
    |     let (block_id, block) = entry
    |     let instrs : Array[TInstr] = []
    | 
    |     // Phi nodes become copies at the START of the block
    |     // (Actually, copies need to go at END of predecessors - handle below)
    | 
    |     // Convert instructions
    |     for instr in block.instrs {
    |       match instr {
    |         SSAInstr::Assign(result, op) => {
    |           let l = destructor.get_local(result)
    |           let tinstr = convert_ssa_op_to_tinstr(op, destructor)
    |           instrs.push(TInstr::local_set(l, tinstr))
    |         }
213 |         SSAInstr::Effect(op) => {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let tinstr = convert_ssa_op_to_tinstr(op, destructor)
    |           instrs.push(tinstr)
    |         }
    |       }
    |     }
    | 
    |     // Convert terminator
    |     let terminator = convert_ssa_terminator(block.terminator, destructor)
    |     blocks[block_id] = BasicBlock::{ id: block_id, instrs, terminator }
    |   }
    | 
    |   // Third pass: insert phi copies at end of predecessor blocks
    |   for entry in self.blocks {
    |     let (_, block) = entry
    |     for phi in block.phis {
    |       let dest_local = destructor.get_local(phi.result)
    |       for arg_entry in phi.args {
    |         let (pred_id, val) = arg_entry
    |         let src_local = destructor.get_local(val)
    |         let copy_instr = TInstr::local_set(
    |           dest_local,
    |           TInstr::local_get(src_local),
    |         )
    |         // Insert before terminator
    |         blocks[pred_id].instrs.push(copy_instr)
    |       }
    |     }
    |   }
    |   let preds = compute_predecessors(blocks)
    |   CFG::{ entry: self.entry, blocks, preds }
    | }
    …

    | fn convert_ssa_op_to_tinstr(op : SSAOp, d : SSADestructor) -> TInstr {
    |   fn get(d : SSADestructor, v : SSAValue) -> TInstr {
    |     TInstr::local_get(d.get_local(v))
    |   }
    | 
    |   fn get_args(d : SSADestructor, args : Array[SSAValue]) -> Array[TInstr] {
253 |     args.map(fn(v) { get(d, v) })
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   match op {
    |     SSAOp::Copy(v) => get(d, v)
    |     SSAOp::I32Const(c) => TInstr::i32_const(c)
259 |     SSAOp::I64Const(c) => TInstr::i64_const(c)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::F32Const(c) => TInstr::f32_const(c)
    |     SSAOp::F64Const(c) => TInstr::f64_const(c)
    |     SSAOp::V128Const(bytes) =>
263 |       TInstr::v128_const(
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         bytes.unsafe_get(0),
    |         bytes.unsafe_get(1),
    |         bytes.unsafe_get(2),
    |         bytes.unsafe_get(3),
    |         bytes.unsafe_get(4),
    |         bytes.unsafe_get(5),
    |         bytes.unsafe_get(6),
    |         bytes.unsafe_get(7),
    |         bytes.unsafe_get(8),
    |         bytes.unsafe_get(9),
    |         bytes.unsafe_get(10),
    |         bytes.unsafe_get(11),
    |         bytes.unsafe_get(12),
    |         bytes.unsafe_get(13),
    |         bytes.unsafe_get(14),
    |         bytes.unsafe_get(15),
    |       )
281 |     SSAOp::RefNull(ht) => TInstr::ref_null(ht)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::RefFunc(idx) => TInstr::ref_func(idx)
    |     SSAOp::Unary(op, a) => TInstr::unary(op, get(d, a))
    |     SSAOp::Binary(op, a, b) => TInstr::binary(op, get(d, a), get(d, b))
    |     SSAOp::Select(tys, a, b, c) =>
286 |       TInstr::select(tys, get(d, a), get(d, b), get(d, c))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::GlobalGet(idx) => TInstr::global_get(idx)
    |     SSAOp::GlobalSet(idx, v) => TInstr::global_set(idx, get(d, v))
    |     SSAOp::Load(op, memarg, addr) => TInstr::load(op, memarg, get(d, addr))
    |     SSAOp::Store(op, memarg, addr, val) =>
291 |       TInstr::store(op, memarg, get(d, addr), get(d, val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemorySize(idx) => TInstr::memory_size(idx)
    |     SSAOp::MemoryGrow(idx, v) => TInstr::memory_grow(idx, get(d, v))
    |     SSAOp::MemoryAtomicNotify(memarg, addr, count) =>
295 |       TInstr::memory_atomic_notify(memarg, get(d, addr), get(d, count))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryAtomicWait32(memarg, addr, expected, timeout) =>
297 |       TInstr::memory_atomic_wait32(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         memarg,
299 |         get(d, addr),
    |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, expected),
    |         get(d, timeout),
    |       )
    |     SSAOp::MemoryAtomicWait64(memarg, addr, expected, timeout) =>
304 |       TInstr::memory_atomic_wait64(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         memarg,
306 |         get(d, addr),
    |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, expected),
    |         get(d, timeout),
    |       )
310 |     SSAOp::AtomicFence => TInstr::atomic_fence()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::AtomicRmw(op, memarg, addr, val) =>
312 |       TInstr::atomic_rmw(op, memarg, get(d, addr), get(d, val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::AtomicCmpxchg(op, memarg, addr, expected, replacement) =>
314 |       TInstr::atomic_cmpxchg(
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         op,
    |         memarg,
317 |         get(d, addr),
    |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, expected),
    |         get(d, replacement),
    |       )
    |     SSAOp::MemoryFill(idx, dest, val, len) =>
322 |       TInstr::memory_fill(idx, get(d, dest), get(d, val), get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryCopy(dst, src, d_, s, l) =>
324 |       TInstr::memory_copy(dst, src, get(d, d_), get(d, s), get(d, l))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryInit(data, mem, dest, src, len) =>
326 |       TInstr::memory_init(data, mem, get(d, dest), get(d, src), get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::DataDrop(idx) => TInstr::data_drop(idx)
    |     SSAOp::TableSize(idx) => TInstr::table_size(idx)
    |     SSAOp::TableGet(idx, i) => TInstr::table_get(idx, get(d, i))
    |     SSAOp::TableSet(idx, i, v) => TInstr::table_set(idx, get(d, i), get(d, v))
    |     SSAOp::TableGrow(idx, v, n) => TInstr::table_grow(idx, get(d, v), get(d, n))
    |     SSAOp::TableFill(idx, i, v, n) =>
333 |       TInstr::table_fill(idx, get(d, i), get(d, v), get(d, n))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::TableCopy(dst, src, d_, s, n) =>
335 |       TInstr::table_copy(dst, src, get(d, d_), get(d, s), get(d, n))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::TableInit(elem, table, dest, src, n) =>
337 |       TInstr::table_init(elem, table, get(d, dest), get(d, src), get(d, n))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ElemDrop(idx) => TInstr::elem_drop(idx)
    |     SSAOp::Call(func, args) => TInstr::call(func, get_args(d, args))
    |     SSAOp::CallIndirect(ty, table, args, idx) =>
341 |       TInstr::call_indirect(ty, table, get_args(d, args), get(d, idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::CallRef(ty, args, func) =>
343 |       TInstr::call_ref(ty, get_args(d, args), get(d, func))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::RefIsNull(v) => TInstr::ref_is_null(get(d, v))
    |     SSAOp::RefEq(a, b) => TInstr::ref_eq(get(d, a), get(d, b))
    |     SSAOp::RefAsNonNull(v) => TInstr::ref_as_non_null(get(d, v))
    |     SSAOp::RefI31(v) => TInstr::ref_i31(get(d, v))
    |     SSAOp::I31GetS(v) => TInstr::i31_get_s(get(d, v))
    |     SSAOp::I31GetU(v) => TInstr::i31_get_u(get(d, v))
    |     SSAOp::RefTest(nullable, ht, v) => TInstr::ref_test(nullable, ht, get(d, v))
    |     SSAOp::RefCast(nullable, ht, v) => TInstr::ref_cast(nullable, ht, get(d, v))
    |     SSAOp::AnyConvertExtern(v) => TInstr::any_convert_extern(get(d, v))
    |     SSAOp::ExternConvertAny(v) => TInstr::extern_convert_any(get(d, v))
    |     SSAOp::StructNew(ty, args) => TInstr::struct_new(ty, get_args(d, args))
    |     SSAOp::StructNewDefault(ty) => TInstr::struct_new_default(ty)
    |     SSAOp::StructGet(ty, field, v) => TInstr::struct_get(ty, field, get(d, v))
    |     SSAOp::StructGetS(ty, field, v) =>
358 |       TInstr::struct_get_s(ty, field, get(d, v))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::StructGetU(ty, field, v) =>
360 |       TInstr::struct_get_u(ty, field, get(d, v))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::StructSet(ty, field, obj, val) =>
362 |       TInstr::struct_set(ty, field, get(d, obj), get(d, val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNew(ty, val, len) =>
364 |       TInstr::array_new(ty, get(d, val), get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewDefault(ty, len) =>
366 |       TInstr::array_new_default(ty, get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewFixed(ty, args) =>
368 |       TInstr::array_new_fixed(ty, get_args(d, args))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewData(ty, data, off, len) =>
370 |       TInstr::array_new_data(ty, data, get(d, off), get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewElem(ty, elem, off, len) =>
372 |       TInstr::array_new_elem(ty, elem, get(d, off), get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayGet(ty, arr, idx) =>
374 |       TInstr::array_get(ty, get(d, arr), get(d, idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayGetS(ty, arr, idx) =>
376 |       TInstr::array_get_s(ty, get(d, arr), get(d, idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayGetU(ty, arr, idx) =>
378 |       TInstr::array_get_u(ty, get(d, arr), get(d, idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArraySet(ty, arr, idx, val) =>
380 |       TInstr::array_set(ty, get(d, arr), get(d, idx), get(d, val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayLen(v) => TInstr::array_len(get(d, v))
    |     SSAOp::ArrayFill(ty, arr, off, val, len) =>
383 |       TInstr::array_fill(ty, get(d, arr), get(d, off), get(d, val), get(d, len))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayCopy(dst_ty, src_ty, dst, d_off, src, s_off, len) =>
385 |       TInstr::array_copy(
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         dst_ty,
    |         src_ty,
388 |         get(d, dst),
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, d_off),
    |         get(d, src),
    |         get(d, s_off),
    |         get(d, len),
    |       )
    |     SSAOp::ArrayInitData(ty, data, arr, a_off, d_off, len) =>
395 |       TInstr::array_init_data(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ty,
    |         data,
398 |         get(d, arr),
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, a_off),
    |         get(d, d_off),
    |         get(d, len),
    |       )
    |     SSAOp::ArrayInitElem(ty, elem, arr, a_off, e_off, len) =>
404 |       TInstr::array_init_elem(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ty,
    |         elem,
407 |         get(d, arr),
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, a_off),
    |         get(d, e_off),
    |         get(d, len),
    |       )
412 |     SSAOp::Throw(tag, args) => TInstr::throw_(tag, get_args(d, args))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Splat(splat_op, v) =>
414 |       match splat_op {
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         SplatOp::I8x16Splat => TInstr::i8x16_splat(get(d, v))
    |         SplatOp::I16x8Splat => TInstr::i16x8_splat(get(d, v))
    |         SplatOp::I32x4Splat => TInstr::i32x4_splat(get(d, v))
    |         SplatOp::I64x2Splat => TInstr::i64x2_splat(get(d, v))
    |         SplatOp::F32x4Splat => TInstr::f32x4_splat(get(d, v))
    |         SplatOp::F64x2Splat => TInstr::f64x2_splat(get(d, v))
    |       }
422 |     SSAOp::ExtractLane(op, lane, v) => TInstr::extract_lane(op, lane, get(d, v))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ReplaceLane(op, lane, vec, val) =>
424 |       TInstr::replace_lane(op, lane, get(d, vec), get(d, val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Shuffle(lanes, a, b) =>
426 |       TInstr::i8x16_shuffle(
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         lanes[0],
    |         lanes[1],
    |         lanes[2],
    |         lanes[3],
    |         lanes[4],
    |         lanes[5],
    |         lanes[6],
    |         lanes[7],
    |         lanes[8],
    |         lanes[9],
    |         lanes[10],
    |         lanes[11],
    |         lanes[12],
    |         lanes[13],
    |         lanes[14],
    |         lanes[15],
443 |         get(d, a),
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |         get(d, b),
    |       )
446 |     SSAOp::Swizzle(a, b) => TInstr::i8x16_swizzle(get(d, a), get(d, b))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::V128Shift(op, v, s) => TInstr::v128_shift(op, get(d, v), get(d, s))
    |     SSAOp::V128Ternary(op, a, b, c) =>
449 |       TInstr::v128_ternary(op, get(d, a), get(d, b), get(d, c))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::V128LoadLane(op, memarg, lane, addr, vec) =>
451 |       TInstr::v128_load_lane(op, memarg, lane, get(d, addr), get(d, vec))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::V128StoreLane(op, memarg, lane, addr, vec) =>
453 |       TInstr::v128_store_lane(op, memarg, lane, get(d, addr), get(d, vec))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn convert_ssa_terminator(
    |   term : SSATerminator,
    |   d : SSADestructor,
    | ) -> Terminator {
    |   fn get(v : SSAValue) -> TInstr {
    |     TInstr::local_get(d.get_local(v))
    |   }
    | 
    |   fn get_all(vals : Array[SSAValue]) -> Array[TInstr] {
    |     vals.map(fn(v) { get(v) })
    |   }
    | 
    |   match term {
    |     Br(target) => Terminator::Br(target)
    |     Unreachable => Terminator::Unreachable
    |     BrIf(cond, t, f) => Terminator::BrIf(get(cond), t, f)
474 |     BrTable(cond, targets, def) => Terminator::BrTable(get(cond), targets, def)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     BrOnNull(val, t, f) => Terminator::BrOnNull(get(val), t, f)
    |     BrOnNonNull(val, t, f) => Terminator::BrOnNonNull(get(val), t, f)
    |     BrOnCast(op, ht1, ht2, val, t, f) =>
478 |       Terminator::BrOnCast(op, ht1, ht2, get(val), t, f)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     BrOnCastFail(op, ht1, ht2, val, t, f) =>
480 |       Terminator::BrOnCastFail(op, ht1, ht2, get(val), t, f)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Return(vals) => Terminator::Return(get_all(vals))
482 |     ReturnCall(func, args) => Terminator::ReturnCall(func, get_all(args))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ReturnCallIndirect(ty, table, args, idx) =>
484 |       Terminator::ReturnCallIndirect(ty, table, get_all(args), get(idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ReturnCallRef(ty, args, func) =>
486 |       Terminator::ReturnCallRef(ty, get_all(args), get(func))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ThrowRef(val) => Terminator::ThrowRef(get(val))
    |   }
    | }
    …

3 uncovered line(s) in src/ir/ssa_destruction_tests.mbt:

    | fn ssa_term_successors(term : SSATerminator) -> Array[BlockId] {
    |   match term {
    |     Br(t) => [t]
    |     BrIf(_, t, f)
    |     | BrOnNull(_, t, f)
    |     | BrOnNonNull(_, t, f)
    |     | BrOnCast(_, _, _, _, t, f)
    |     | BrOnCastFail(_, _, _, _, t, f) => [t, f]
 10 |     BrTable(_, targets, d) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = targets.copy()
    |       out.push(d)
    |       out
    |     }
    |     Return(_)
    |     | ReturnCall(_, _)
    |     | ReturnCallIndirect(_, _, _, _)
    |     | ReturnCallRef(_, _, _)
    |     | ThrowRef(_)
    |     | Unreachable => []
    |   }
    | }
    …

    | fn ends_with_local_copy(instrs : Array[TInstr]) -> Bool {
    |   if instrs.is_empty() {
 43 |     return false
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match instrs[instrs.length() - 1] {
    |     TLocalSet(_, TLocalGet(_)) => true
 47 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

216 uncovered line(s) in src/ir/ssa_optimize.mbt:

     | fn round_half_to_even_f32(x : Float) -> Float {
  29 |   let d = x.to_double()
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let r = round_half_to_even_f64(d)
     |   Float::from_double(r)
     | }
     …

     | fn eval_ssa_unary(op : UnaryOp, lit : SSALiteral) -> SSALiteral? {
     |   match (op, lit) {
     |     // i32 operations
     |     (I32EqzOp, LitI32(x)) => Some(LitI32(if x == 0 { 1 } else { 0 }))
     |     (I32ClzOp, LitI32(x)) => Some(LitI32(x.clz()))
     |     (I32CtzOp, LitI32(x)) => Some(LitI32(x.ctz()))
     |     (I32PopcntOp, LitI32(x)) => Some(LitI32(x.popcnt()))
     |     // i64 operations
     |     (I64EqzOp, LitI64(x)) => Some(LitI32(if x == 0L { 1 } else { 0 }))
     |     (I64ClzOp, LitI64(x)) => Some(LitI64(x.clz().to_int64()))
     |     (I64CtzOp, LitI64(x)) => Some(LitI64(x.ctz().to_int64()))
     |     (I64PopcntOp, LitI64(x)) => Some(LitI64(x.popcnt().to_int64()))
     |     // Conversions
 248 |     (I32Extend8SOp, LitI32(x)) => Some(LitI64(x.to_int64()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32Extend16SOp, LitI32(x)) =>
 250 |       Some(LitI64(x.reinterpret_as_uint().to_uint64().reinterpret_as_int64()))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32WrapI64Op, LitI64(x)) => Some(LitI32(x.to_int()))
     |     // f32 operations
     |     (F32NegOp, LitF32(x)) => Some(LitF32(-x))
     |     (F32AbsOp, LitF32(x)) => Some(LitF32(x.abs()))
     |     (F32SqrtOp, LitF32(x)) => Some(LitF32(x.sqrt()))
     |     (F32CeilOp, LitF32(x)) =>
 257 |       Some(LitF32(Float::from_double(x.to_double().ceil())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32FloorOp, LitF32(x)) =>
 259 |       Some(LitF32(Float::from_double(x.to_double().floor())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32TruncOp, LitF32(x)) =>
 261 |       Some(LitF32(Float::from_double(x.to_double().trunc())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32NearestOp, LitF32(x)) => Some(LitF32(round_half_to_even_f32(x)))
     |     // f64 operations
     |     (F64NegOp, LitF64(x)) => Some(LitF64(-x))
     |     (F64AbsOp, LitF64(x)) => Some(LitF64(x.abs()))
     |     (F64SqrtOp, LitF64(x)) => Some(LitF64(x.sqrt()))
     |     (F64CeilOp, LitF64(x)) => Some(LitF64(x.ceil()))
     |     (F64FloorOp, LitF64(x)) => Some(LitF64(x.floor()))
     |     (F64TruncOp, LitF64(x)) => Some(LitF64(x.trunc()))
     |     (F64NearestOp, LitF64(x)) => Some(LitF64(round_half_to_even_f64(x)))
     |     // Float to int conversions
     |     (I32TruncF32SOp, LitF32(x)) =>
     |       match trunc_f64_to_i32_s(x.to_double()) {
 274 |         Some(v) => Some(LitI32(v))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => None
     |       }
     |     (I32TruncF32UOp, LitF32(x)) =>
     |       match trunc_f64_to_i32_u(x.to_double()) {
 279 |         Some(v) => Some(LitI32(v))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => None
     |       }
     |     (I32TruncF64SOp, LitF64(x)) =>
     |       match trunc_f64_to_i32_s(x) {
     |         Some(v) => Some(LitI32(v))
     |         None => None
     |       }
     |     (I32TruncF64UOp, LitF64(x)) =>
     |       match trunc_f64_to_i32_u(x) {
     |         Some(v) => Some(LitI32(v))
     |         None => None
     |       }
     |     (I64ExtendI32SOp, LitI32(x)) => Some(LitI64(x.to_int64()))
     |     (I64ExtendI32UOp, LitI32(x)) =>
     |       Some(LitI64(x.reinterpret_as_uint().to_uint64().reinterpret_as_int64()))
     |     (I64TruncF32SOp, LitF32(x)) =>
     |       match trunc_f64_to_i64_s(x.to_double()) {
     |         Some(v) => Some(LitI64(v))
     |         None => None
     |       }
     |     (I64TruncF32UOp, LitF32(x)) =>
     |       match trunc_f64_to_i64_u(x.to_double()) {
     |         Some(v) => Some(LitI64(v))
     |         None => None
     |       }
     |     (I64TruncF64SOp, LitF64(x)) =>
     |       match trunc_f64_to_i64_s(x) {
     |         Some(v) => Some(LitI64(v))
     |         None => None
     |       }
     |     (I64TruncF64UOp, LitF64(x)) =>
     |       match trunc_f64_to_i64_u(x) {
     |         Some(v) => Some(LitI64(v))
     |         None => None
     |       }
     |     // Int to float conversions
     |     (F32ConvertI32SOp, LitI32(x)) =>
 317 |       Some(LitF32(Float::from_double(x.to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32ConvertI32UOp, LitI32(x)) =>
 319 |       Some(LitF32(Float::from_double(x.reinterpret_as_uint().to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32ConvertI64SOp, LitI64(x)) =>
 321 |       Some(LitF32(Float::from_double(x.to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32ConvertI64UOp, LitI64(x)) =>
 323 |       Some(LitF32(Float::from_double(x.reinterpret_as_uint64().to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64ConvertI32SOp, LitI32(x)) => Some(LitF64(x.to_double()))
     |     (F64ConvertI32UOp, LitI32(x)) =>
     |       Some(LitF64(x.reinterpret_as_uint().to_double()))
     |     (F64ConvertI64SOp, LitI64(x)) => Some(LitF64(x.to_double()))
     |     (F64ConvertI64UOp, LitI64(x)) =>
 329 |       Some(LitF64(x.reinterpret_as_uint64().to_double()))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     // Float promotions/demotions
     |     (F64PromoteF32Op, LitF32(x)) => Some(LitF64(x.to_double()))
     |     (F32DemoteF64Op, LitF64(x)) => Some(LitF32(Float::from_double(x)))
     |     // Reinterpret
 334 |     (F32ReinterpretI32Op, LitF32(x)) => Some(LitI32(x.reinterpret_as_int()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64ReinterpretI64Op, LitF64(x)) => Some(LitI64(x.reinterpret_as_int64()))
     |     (I32ReinterpretF32Op, LitI32(x)) =>
 337 |       Some(LitF32(Float::reinterpret_from_int(x)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64ReinterpretF64Op, LitI64(x)) => Some(LitF64(x.reinterpret_as_double()))
     |     _ => None
     |   }
     | }
     …

     | fn eval_ssa_binary(
     |   op : @lib.BinaryOp,
     |   a : SSALiteral,
     |   b : SSALiteral,
     | ) -> SSALiteral? {
     |   match (op, a, b) {
     |     // i32 arithmetic
     |     (I32AddOp, LitI32(x), LitI32(y)) => Some(LitI32(x + y))
     |     (I32SubOp, LitI32(x), LitI32(y)) => Some(LitI32(x - y))
     |     (I32MulOp, LitI32(x), LitI32(y)) => Some(LitI32(x * y))
     |     (I32DivSOp, LitI32(x), LitI32(y)) if y != 0 => Some(LitI32(x / y))
     |     (I32DivUOp, LitI32(x), LitI32(y)) if y != 0 => {
     |       let xu = x.reinterpret_as_uint()
     |       let yu = y.reinterpret_as_uint()
     |       Some(LitI32((xu / yu).reinterpret_as_int()))
     |     }
     |     (I32RemSOp, LitI32(x), LitI32(y)) if y != 0 => Some(LitI32(x % y))
     |     (I32RemUOp, LitI32(x), LitI32(y)) if y != 0 => {
     |       let xu = x.reinterpret_as_uint()
     |       let yu = y.reinterpret_as_uint()
     |       Some(LitI32((xu % yu).reinterpret_as_int()))
     |     }
     |     // i32 bitwise
     |     (I32AndOp, LitI32(x), LitI32(y)) => Some(LitI32(x & y))
     |     (I32OrOp, LitI32(x), LitI32(y)) => Some(LitI32(x | y))
     |     (I32XorOp, LitI32(x), LitI32(y)) => Some(LitI32(x ^ y))
     |     (I32ShlOp, LitI32(x), LitI32(y)) => Some(LitI32(x << (y & 31)))
     |     (I32ShrSOp, LitI32(x), LitI32(y)) => Some(LitI32(x >> (y & 31)))
     |     (I32ShrUOp, LitI32(x), LitI32(y)) =>
     |       Some(LitI32((x.reinterpret_as_uint() >> (y & 31)).reinterpret_as_int()))
     |     (I32RotlOp, LitI32(x), LitI32(y)) => {
     |       let k = y & 31
     |       if k == 0 {
     |         return Some(LitI32(x))
     |       }
     |       let xu = x.reinterpret_as_uint()
     |       Some(LitI32(((xu << k) | (xu >> (32 - k))).reinterpret_as_int()))
     |     }
     |     (I32RotrOp, LitI32(x), LitI32(y)) => {
     |       let k = y & 31
     |       if k == 0 {
     |         return Some(LitI32(x))
     |       }
 391 |       let xu = x.reinterpret_as_uint()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(LitI32(((xu >> k) | (xu << (32 - k))).reinterpret_as_int()))
     |     }
     |     // i32 comparisons
     |     (I32EqOp, LitI32(x), LitI32(y)) => Some(LitI32(if x == y { 1 } else { 0 }))
     |     (I32NeOp, LitI32(x), LitI32(y)) => Some(LitI32(if x != y { 1 } else { 0 }))
     |     (I32LtSOp, LitI32(x), LitI32(y)) => Some(LitI32(if x < y { 1 } else { 0 }))
     |     (I32LtUOp, LitI32(x), LitI32(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint() < y.reinterpret_as_uint() {
     |             1
     |           } else {
     |             0
     |           },
     |         ),
     |       )
     |     (I32LeSOp, LitI32(x), LitI32(y)) => Some(LitI32(if x <= y { 1 } else { 0 }))
     |     (I32LeUOp, LitI32(x), LitI32(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint() <= y.reinterpret_as_uint() {
     |             1
     |           } else {
 415 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (I32GtSOp, LitI32(x), LitI32(y)) => Some(LitI32(if x > y { 1 } else { 0 }))
     |     (I32GtUOp, LitI32(x), LitI32(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint() > y.reinterpret_as_uint() {
     |             1
     |           } else {
 426 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (I32GeSOp, LitI32(x), LitI32(y)) => Some(LitI32(if x >= y { 1 } else { 0 }))
     |     (I32GeUOp, LitI32(x), LitI32(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint() >= y.reinterpret_as_uint() {
     |             1
     |           } else {
 437 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     // i64 arithmetic
     |     (I64AddOp, LitI64(x), LitI64(y)) => Some(LitI64(x + y))
     |     (I64SubOp, LitI64(x), LitI64(y)) => Some(LitI64(x - y))
     |     (I64MulOp, LitI64(x), LitI64(y)) => Some(LitI64(x * y))
     |     (I64DivSOp, LitI64(x), LitI64(y)) if y != 0L => Some(LitI64(x / y))
     |     (I64DivUOp, LitI64(x), LitI64(y)) if y != 0L => {
     |       let xu = x.reinterpret_as_uint64()
     |       let yu = y.reinterpret_as_uint64()
     |       Some(LitI64((xu / yu).reinterpret_as_int64()))
     |     }
     |     (I64RemSOp, LitI64(x), LitI64(y)) if y != 0L => Some(LitI64(x % y))
     |     (I64RemUOp, LitI64(x), LitI64(y)) if y != 0L => {
     |       let xu = x.reinterpret_as_uint64()
     |       let yu = y.reinterpret_as_uint64()
     |       Some(LitI64((xu % yu).reinterpret_as_int64()))
     |     }
     |     // i64 bitwise
     |     (I64AndOp, LitI64(x), LitI64(y)) => Some(LitI64(x & y))
     |     (I64OrOp, LitI64(x), LitI64(y)) => Some(LitI64(x | y))
     |     (I64XorOp, LitI64(x), LitI64(y)) => Some(LitI64(x ^ y))
     |     (I64ShlOp, LitI64(x), LitI64(y)) => Some(LitI64(x << y.land(63L).to_int()))
     |     (I64ShrSOp, LitI64(x), LitI64(y)) => Some(LitI64(x >> y.land(63L).to_int()))
     |     (I64ShrUOp, LitI64(x), LitI64(y)) =>
     |       Some(
     |         LitI64(
     |           (x.reinterpret_as_uint64() >> y.land(63L).to_int()).reinterpret_as_int64(),
     |         ),
     |       )
     |     (I64RotlOp, LitI64(x), LitI64(y)) => {
     |       let k = y.land(63L).to_int()
     |       if k == 0 {
     |         return Some(LitI64(x))
     |       }
 474 |       let xu = x.reinterpret_as_uint64()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(LitI64(((xu << k) | (xu >> (64 - k))).reinterpret_as_int64()))
     |     }
     |     (I64RotrOp, LitI64(x), LitI64(y)) => {
     |       let k = y.land(63L).to_int()
     |       if k == 0 {
     |         return Some(LitI64(x))
     |       }
 482 |       let xu = x.reinterpret_as_uint64()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(LitI64(((xu >> k) | (xu << (64 - k))).reinterpret_as_int64()))
     |     }
     |     // i64 comparisons
     |     (I64EqOp, LitI64(x), LitI64(y)) => Some(LitI32(if x == y { 1 } else { 0 }))
     |     (I64NeOp, LitI64(x), LitI64(y)) => Some(LitI32(if x != y { 1 } else { 0 }))
     |     (I64LtSOp, LitI64(x), LitI64(y)) => Some(LitI32(if x < y { 1 } else { 0 }))
     |     (I64LtUOp, LitI64(x), LitI64(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint64() < y.reinterpret_as_uint64() {
     |             1
     |           } else {
 495 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (I64LeSOp, LitI64(x), LitI64(y)) => Some(LitI32(if x <= y { 1 } else { 0 }))
     |     (I64LeUOp, LitI64(x), LitI64(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint64() <= y.reinterpret_as_uint64() {
     |             1
     |           } else {
 506 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (I64GtSOp, LitI64(x), LitI64(y)) => Some(LitI32(if x > y { 1 } else { 0 }))
     |     (I64GtUOp, LitI64(x), LitI64(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint64() > y.reinterpret_as_uint64() {
     |             1
     |           } else {
 517 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (I64GeSOp, LitI64(x), LitI64(y)) => Some(LitI32(if x >= y { 1 } else { 0 }))
     |     (I64GeUOp, LitI64(x), LitI64(y)) =>
     |       Some(
     |         LitI32(
     |           if x.reinterpret_as_uint64() >= y.reinterpret_as_uint64() {
     |             1
     |           } else {
 528 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     // f32 arithmetic
     |     (F32AddOp, LitF32(x), LitF32(y)) => Some(LitF32(x + y))
     |     (F32SubOp, LitF32(x), LitF32(y)) => Some(LitF32(x - y))
     |     (F32MulOp, LitF32(x), LitF32(y)) => Some(LitF32(x * y))
     |     (F32DivOp, LitF32(x), LitF32(y)) => Some(LitF32(x / y))
     |     (F32MinOp, LitF32(x), LitF32(y)) =>
     |       Some(
     |         LitF32(
     |           if x.is_nan() || y.is_nan() {
 541 |             @float.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x < y {
     |             x
     |           } else {
 545 |             y
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (F32MaxOp, LitF32(x), LitF32(y)) =>
     |       Some(
     |         LitF32(
     |           if x.is_nan() || y.is_nan() {
 553 |             @float.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x > y {
 555 |             x
     |             ^ 	<-- UNCOVERED
     |           } else {
     |             y
     |           },
     |         ),
     |       )
     |     (F32CopysignOp, LitF32(x), LitF32(y)) => {
     |       let x_abs = x.abs()
     |       let result = if y.reinterpret_as_int() < 0 { -x_abs } else { x_abs }
     |       Some(LitF32(result))
     |     }
     |     // f32 comparisons
     |     (F32EqOp, LitF32(x), LitF32(y)) => Some(LitI32(if x == y { 1 } else { 0 }))
     |     (F32NeOp, LitF32(x), LitF32(y)) => Some(LitI32(if x != y { 1 } else { 0 }))
     |     (F32LtOp, LitF32(x), LitF32(y)) => Some(LitI32(if x < y { 1 } else { 0 }))
     |     (F32LeOp, LitF32(x), LitF32(y)) => Some(LitI32(if x <= y { 1 } else { 0 }))
     |     (F32GtOp, LitF32(x), LitF32(y)) => Some(LitI32(if x > y { 1 } else { 0 }))
     |     (F32GeOp, LitF32(x), LitF32(y)) => Some(LitI32(if x >= y { 1 } else { 0 }))
     |     // f64 arithmetic
     |     (F64AddOp, LitF64(x), LitF64(y)) => Some(LitF64(x + y))
     |     (F64SubOp, LitF64(x), LitF64(y)) => Some(LitF64(x - y))
     |     (F64MulOp, LitF64(x), LitF64(y)) => Some(LitF64(x * y))
     |     (F64DivOp, LitF64(x), LitF64(y)) => Some(LitF64(x / y))
     |     (F64MinOp, LitF64(x), LitF64(y)) =>
     |       Some(
     |         LitF64(
     |           if x.is_nan() || y.is_nan() {
     |             @double.not_a_number
     |           } else if x < y {
     |             x
     |           } else {
 586 |             y
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (F64MaxOp, LitF64(x), LitF64(y)) =>
     |       Some(
     |         LitF64(
     |           if x.is_nan() || y.is_nan() {
 594 |             @double.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x > y {
 596 |             x
     |             ^ 	<-- UNCOVERED
     |           } else {
     |             y
     |           },
     |         ),
     |       )
     |     (F64CopysignOp, LitF64(x), LitF64(y)) => {
     |       let x_abs = x.abs()
     |       let result = if y.reinterpret_as_int64() < 0L { -x_abs } else { x_abs }
     |       Some(LitF64(result))
     |     }
     |     // f64 comparisons
     |     (F64EqOp, LitF64(x), LitF64(y)) => Some(LitI32(if x == y { 1 } else { 0 }))
     |     (F64NeOp, LitF64(x), LitF64(y)) => Some(LitI32(if x != y { 1 } else { 0 }))
     |     (F64LtOp, LitF64(x), LitF64(y)) => Some(LitI32(if x < y { 1 } else { 0 }))
     |     (F64LeOp, LitF64(x), LitF64(y)) => Some(LitI32(if x <= y { 1 } else { 0 }))
     |     (F64GtOp, LitF64(x), LitF64(y)) => Some(LitI32(if x > y { 1 } else { 0 }))
     |     (F64GeOp, LitF64(x), LitF64(y)) => Some(LitI32(if x >= y { 1 } else { 0 }))
     |     _ => None
     |   }
     | }
     …

     | fn try_strength_reduce_ssa(
     |   ctx : SSAOptCtx,
     |   result : SSAValue,
     |   op : BinaryOp,
     |   left : SSAValue,
     |   right : SSAValue,
     | ) -> Bool {
     |   match op {
     |     I32MulOp => {
     |       // x * (2^k) → x << k
     |       match ctx.get_const(right) {
     |         Some(LitI32(c)) if is_power_of_2_i32(c) => {
     |           let shift = log2_i32(c)
     |           let shift_v = ctx.make_const(LitI32(shift))
     |           ctx.def_map[result] = SSAOp::Binary(
     |             BinaryOp::i32_shl(),
     |             left, // ✅ use the non-const operand
     |             shift_v,
     |           )
     |           ctx.changed = true
     |           return true
     |         }
     |         _ => ()
     |       }
     | 
     |       // (2^k) * x → x << k
     |       match ctx.get_const(left) {
 670 |         Some(LitI32(c)) if is_power_of_2_i32(c) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let shift = log2_i32(c)
     |           let shift_v = ctx.make_const(LitI32(shift))
     |           ctx.def_map[result] = SSAOp::Binary(
 674 |             BinaryOp::i32_shl(),
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             right, // ✅ use the non-const operand
     |             shift_v,
     |           )
     |           ctx.changed = true
     |           return true
     |         }
     |         _ => ()
     |       }
     |       false
     |     }
 685 |     I64MulOp => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // x * (2^k) → x << k
 687 |       match ctx.get_const(right) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(c)) if is_power_of_2_i64(c) => {
     |           let shift = log2_i64(c)
     |           let shift_v = ctx.make_const(LitI64(shift))
     |           ctx.def_map[result] = SSAOp::Binary(
 692 |             BinaryOp::i64_shl(),
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             left, // ✅ shift the non-const operand
     |             shift_v,
     |           )
     |           ctx.changed = true
     |           return true
     |         }
 699 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       // (2^k) * x → x << k
 703 |       match ctx.get_const(left) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(c)) if is_power_of_2_i64(c) => {
     |           let shift = log2_i64(c)
     |           let shift_v = ctx.make_const(LitI64(shift))
     |           ctx.def_map[result] = SSAOp::Binary(
 708 |             BinaryOp::i64_shl(),
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             right, // ✅ shift the non-const operand
     |             shift_v,
     |           )
     |           ctx.changed = true
     |           return true
     |         }
 715 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       false
     |     }
     |     I32DivUOp =>
     |       match ctx.get_const(right) {
     |         Some(LitI32(c)) if is_power_of_2_i32(c) => {
     |           if c == 1 {
 723 |             ctx.replace(result, left)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ctx.changed = true
     |             return true
     |           }
     |           let shift = log2_i32(c)
     |           let shift_v = ctx.make_const(LitI32(shift))
     |           ctx.def_map[result] = SSAOp::Binary(
     |             BinaryOp::i32_shr_u(),
     |             left,
     |             shift_v,
     |           )
     |           ctx.changed = true
     |           true
     |         }
 737 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I64DivUOp =>
 740 |       match ctx.get_const(right) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(c)) if is_power_of_2_i64(c) => {
     |           if c == 1L {
 743 |             ctx.replace(result, left)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ctx.changed = true
     |             return true
     |           }
 747 |           let shift = log2_i64(c)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let shift_v = ctx.make_const(LitI64(shift))
     |           ctx.def_map[result] = SSAOp::Binary(
 750 |             BinaryOp::i64_shr_u(),
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             left,
     |             shift_v,
     |           )
     |           ctx.changed = true
     |           true
     |         }
 757 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I32RemUOp =>
     |       match ctx.get_const(right) {
     |         Some(LitI32(c)) if is_power_of_2_i32(c) => {
     |           let mask_v = ctx.make_const(LitI32(c - 1))
     |           ctx.def_map[result] = SSAOp::Binary(BinaryOp::i32_and(), left, mask_v)
     |           ctx.changed = true
     |           true
     |         }
 767 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I64RemUOp =>
 770 |       match ctx.get_const(right) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(c)) if is_power_of_2_i64(c) => {
     |           let mask_v = ctx.make_const(LitI64(c - 1L))
     |           ctx.def_map[result] = SSAOp::Binary(BinaryOp::i64_and(), left, mask_v)
     |           ctx.changed = true
     |           true
     |         }
 777 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => false
     |   }
     | }
     …

     | fn try_algebraic_simplify(
     |   ctx : SSAOptCtx,
     |   result : SSAValue,
     |   op : BinaryOp,
     |   left : SSAValue,
     |   right : SSAValue,
     | ) -> Bool {
     |   let left_r = ctx.resolve(left)
     |   let right_r = ctx.resolve(right)
     |   let left_c = ctx.get_const(left)
     |   let right_c = ctx.get_const(right)
     |   match op {
     |     // x + 0 = 0 + x = x
     |     I32AddOp => {
     |       match right_c {
     |         Some(LitI32(0)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       match left_c {
 810 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, right_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       false
     |     }
 818 |     I64AddOp => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
 824 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
 826 |       match left_c {
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, right_r)
     |           return true
     |         }
 831 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       false
     |     }
     |     // x - 0 = x; x - x = 0
     |     I32SubOp => {
     |       match right_c {
 838 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, left_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       if left_r == right_r {
     |         let z = ctx.make_const(LitI32(0))
     |         ctx.replace(result, z)
     |         return true
     |       }
     |       false
     |     }
 851 |     I64SubOp => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
 857 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if left_r == right_r {
 860 |         let z = ctx.make_const(LitI64(0L))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx.replace(result, z)
     |         return true
     |       }
     |       false
     |     }
     |     // x * 0 = 0; x * 1 = x
     |     I32MulOp => {
     |       match right_c {
     |         Some(LitI32(0)) => {
     |           let z = ctx.make_const(LitI32(0))
     |           ctx.replace(result, z)
     |           return true
     |         }
 874 |         Some(LitI32(1)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, left_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       match left_c {
 881 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI32(0))
     |           ctx.replace(result, z)
     |           return true
     |         }
 886 |         Some(LitI32(1)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, right_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       false
     |     }
 894 |     I64MulOp => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI64(0L)) => {
     |           let z = ctx.make_const(LitI64(0L))
     |           ctx.replace(result, z)
     |           return true
     |         }
 901 |         Some(LitI64(1L)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, left_r)
     |           return true
     |         }
 905 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
 907 |       match left_c {
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(0L)) => {
     |           let z = ctx.make_const(LitI64(0L))
     |           ctx.replace(result, z)
     |           return true
     |         }
 913 |         Some(LitI64(1L)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, right_r)
     |           return true
     |         }
 917 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       false
     |     }
     |     // x & 0 = 0; x & -1 = x; x & x = x
     |     I32AndOp => {
     |       match right_c {
 924 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI32(0))
     |           ctx.replace(result, z)
     |           return true
     |         }
     |         Some(LitI32(-1)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       match left_c {
 936 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI32(0))
     |           ctx.replace(result, z)
     |           return true
     |         }
 941 |         Some(LitI32(-1)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, right_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       if left_r == right_r {
 948 |         ctx.replace(result, left_r)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return true
     |       }
     |       false
     |     }
 953 |     I64AndOp => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI64(0L)) => {
     |           let z = ctx.make_const(LitI64(0L))
     |           ctx.replace(result, z)
     |           return true
     |         }
 960 |         Some(LitI64(-1L)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, left_r)
     |           return true
     |         }
 964 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
 966 |       match left_c {
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(0L)) => {
     |           let z = ctx.make_const(LitI64(0L))
     |           ctx.replace(result, z)
     |           return true
     |         }
 972 |         Some(LitI64(-1L)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, right_r)
     |           return true
     |         }
 976 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if left_r == right_r {
 979 |         ctx.replace(result, left_r)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return true
     |       }
     |       false
     |     }
     |     // x | 0 = x; x | -1 = -1; x | x = x
 985 |     I32OrOp => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI32(0)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
 991 |         Some(LitI32(-1)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI32(-1))
     |           ctx.replace(result, z)
     |           return true
     |         }
 996 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
 998 |       match left_c {
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI32(0)) => {
     |           ctx.replace(result, right_r)
     |           return true
     |         }
1003 |         Some(LitI32(-1)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI32(-1))
     |           ctx.replace(result, z)
     |           return true
     |         }
1008 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if left_r == right_r {
1011 |         ctx.replace(result, left_r)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return true
     |       }
     |       false
     |     }
1016 |     I64OrOp => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
1022 |         Some(LitI64(-1L)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI64(-1L))
     |           ctx.replace(result, z)
     |           return true
     |         }
1027 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
1029 |       match left_c {
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, right_r)
     |           return true
     |         }
1034 |         Some(LitI64(-1L)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let z = ctx.make_const(LitI64(-1L))
     |           ctx.replace(result, z)
     |           return true
     |         }
1039 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if left_r == right_r {
1042 |         ctx.replace(result, left_r)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return true
     |       }
     |       false
     |     }
     |     // x ^ 0 = x; x ^ x = 0
     |     I32XorOp => {
     |       match right_c {
1050 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, left_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       match left_c {
1057 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, right_r)
     |           return true
     |         }
     |         _ => ()
     |       }
     |       if left_r == right_r {
     |         let z = ctx.make_const(LitI32(0))
     |         ctx.replace(result, z)
     |         return true
     |       }
     |       false
     |     }
1070 |     I64XorOp => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match right_c {
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, left_r)
     |           return true
     |         }
1076 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
1078 |       match left_c {
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, right_r)
     |           return true
     |         }
1083 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if left_r == right_r {
1086 |         let z = ctx.make_const(LitI64(0L))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx.replace(result, z)
     |         return true
     |       }
     |       false
     |     }
     |     // x << 0 = x; x >> 0 = x
     |     I32ShlOp | I32ShrSOp | I32ShrUOp | I32RotlOp | I32RotrOp =>
     |       match right_c {
1095 |         Some(LitI32(0)) => {
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.replace(result, left_r)
     |           true
     |         }
     |         _ => false
     |       }
     |     I64ShlOp | I64ShrSOp | I64ShrUOp | I64RotlOp | I64RotrOp =>
1102 |       match right_c {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(0L)) => {
     |           ctx.replace(result, left_r)
     |           true
     |         }
1107 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     // x /s 1 = x
     |     I32DivSOp =>
1111 |       match right_c {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI32(1)) => {
     |           ctx.replace(result, left_r)
     |           true
     |         }
1116 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I64DivSOp =>
1119 |       match right_c {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(1L)) => {
     |           ctx.replace(result, left_r)
     |           true
     |         }
1124 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I32DivUOp =>
1127 |       match right_c {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI32(1)) => {
     |           ctx.replace(result, left_r)
     |           true
     |         }
1132 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I64DivUOp =>
1135 |       match right_c {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(LitI64(1L)) => {
     |           ctx.replace(result, left_r)
     |           true
     |         }
1140 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     // Self-comparison: x == x => 1, x != x => 0,
     |     // x <= x => 1, x >= x => 1, x < x => 0, x > x => 0
     |     I32EqOp | I64EqOp if left_r == right_r => {
     |       let z = ctx.make_const(LitI32(1))
     |       ctx.replace(result, z)
     |       true
     |     }
1149 |     I32NeOp | I64NeOp if left_r == right_r => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let z = ctx.make_const(LitI32(0))
     |       ctx.replace(result, z)
     |       true
     |     }
     |     I32LeSOp
     |     | I32LeUOp
     |     | I32GeSOp
     |     | I32GeUOp
     |     | I64LeSOp
     |     | I64LeUOp
     |     | I64GeSOp
1161 |     | I64GeUOp if left_r == right_r => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let z = ctx.make_const(LitI32(1))
     |       ctx.replace(result, z)
     |       true
     |     }
     |     I32LtSOp
     |     | I32LtUOp
     |     | I32GtSOp
     |     | I32GtUOp
     |     | I64LtSOp
     |     | I64LtUOp
     |     | I64GtSOp
     |     | I64GtUOp if left_r == right_r => {
     |       let z = ctx.make_const(LitI32(0))
     |       ctx.replace(result, z)
     |       true
     |     }
1178 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn SSAOptCtx::rewrite_op(self : SSAOptCtx, op : SSAOp) -> SSAOp {
     |   match op {
     |     I32Const(_)
     |     | I64Const(_)
     |     | F32Const(_)
     |     | F64Const(_)
     |     | RefNull(_)
     |     | RefFunc(_)
     |     | V128Const(_)
     |     | MemorySize(_)
     |     | AtomicFence
     |     | DataDrop(_)
     |     | GlobalGet(_)
     |     | TableSize(_)
     |     | ElemDrop(_)
     |     | StructNewDefault(_) => op
1216 |     Copy(v) => Copy(self.rewrite_value(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Binary(bop, a, b) =>
     |       Binary(bop, self.rewrite_value(a), self.rewrite_value(b))
1219 |     Unary(uop, a) => Unary(uop, self.rewrite_value(a))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Load(lop, ma, a) => Load(lop, ma, self.rewrite_value(a))
     |     Store(sop, ma, a, b) =>
1222 |       Store(sop, ma, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     MemoryGrow(idx, a) => MemoryGrow(idx, self.rewrite_value(a))
     |     MemoryAtomicNotify(ma, addr, count) =>
1225 |       MemoryAtomicNotify(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ma,
1227 |         self.rewrite_value(addr),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(count),
     |       )
     |     MemoryAtomicWait32(ma, addr, expected, timeout) =>
1231 |       MemoryAtomicWait32(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ma,
1233 |         self.rewrite_value(addr),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(expected),
     |         self.rewrite_value(timeout),
     |       )
     |     MemoryAtomicWait64(ma, addr, expected, timeout) =>
1238 |       MemoryAtomicWait64(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ma,
1240 |         self.rewrite_value(addr),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(expected),
     |         self.rewrite_value(timeout),
     |       )
     |     AtomicRmw(op, ma, addr, val) =>
1245 |       AtomicRmw(op, ma, self.rewrite_value(addr), self.rewrite_value(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AtomicCmpxchg(op, ma, addr, expected, replacement) =>
1247 |       AtomicCmpxchg(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         op,
     |         ma,
1250 |         self.rewrite_value(addr),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(expected),
     |         self.rewrite_value(replacement),
     |       )
     |     MemoryFill(idx, a, b, c) =>
1255 |       MemoryFill(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         idx,
1257 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     MemoryCopy(i1, i2, a, b, c) =>
1262 |       MemoryCopy(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         i1,
     |         i2,
1265 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     MemoryInit(di, mi, a, b, c) =>
1270 |       MemoryInit(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         di,
     |         mi,
1273 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     GlobalSet(idx, a) => GlobalSet(idx, self.rewrite_value(a))
1278 |     TableGet(idx, a) => TableGet(idx, self.rewrite_value(a))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TableSet(idx, a, b) =>
1280 |       TableSet(idx, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TableGrow(idx, a, b) =>
1282 |       TableGrow(idx, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TableFill(idx, a, b, c) =>
1284 |       TableFill(
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         idx,
1286 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     TableCopy(i1, i2, a, b, c) =>
1291 |       TableCopy(
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         i1,
     |         i2,
1294 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     TableInit(ei, ti, a, b, c) =>
1299 |       TableInit(
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         ei,
     |         ti,
1302 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     Call(fi, vs) => Call(fi, self.rewrite_values(vs))
     |     CallIndirect(ti, tbi, vs, v) =>
1308 |       CallIndirect(ti, tbi, self.rewrite_values(vs), self.rewrite_value(v))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CallRef(ti, vs, v) =>
1310 |       CallRef(ti, self.rewrite_values(vs), self.rewrite_value(v))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefIsNull(a) => RefIsNull(self.rewrite_value(a))
     |     RefEq(a, b) => RefEq(self.rewrite_value(a), self.rewrite_value(b))
     |     RefAsNonNull(a) => RefAsNonNull(self.rewrite_value(a))
     |     RefI31(a) => RefI31(self.rewrite_value(a))
     |     I31GetS(a) => I31GetS(self.rewrite_value(a))
     |     I31GetU(a) => I31GetU(self.rewrite_value(a))
     |     RefTest(b, ht, a) => RefTest(b, ht, self.rewrite_value(a))
     |     RefCast(b, ht, a) => RefCast(b, ht, self.rewrite_value(a))
     |     AnyConvertExtern(a) => AnyConvertExtern(self.rewrite_value(a))
     |     ExternConvertAny(a) => ExternConvertAny(self.rewrite_value(a))
     |     StructNew(ti, vs) => StructNew(ti, self.rewrite_values(vs))
     |     StructGet(ti, fi, a) => StructGet(ti, fi, self.rewrite_value(a))
     |     StructGetS(ti, fi, a) => StructGetS(ti, fi, self.rewrite_value(a))
     |     StructGetU(ti, fi, a) => StructGetU(ti, fi, self.rewrite_value(a))
     |     StructSet(ti, fi, a, b) =>
1326 |       StructSet(ti, fi, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayNew(ti, a, b) =>
1328 |       ArrayNew(ti, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayNewDefault(ti, a) => ArrayNewDefault(ti, self.rewrite_value(a))
     |     ArrayNewFixed(ti, vs) => ArrayNewFixed(ti, self.rewrite_values(vs))
     |     ArrayNewData(ti, di, a, b) =>
1332 |       ArrayNewData(ti, di, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayNewElem(ti, ei, a, b) =>
1334 |       ArrayNewElem(ti, ei, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayGet(ti, a, b) =>
1336 |       ArrayGet(ti, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayGetS(ti, a, b) =>
1338 |       ArrayGetS(ti, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayGetU(ti, a, b) =>
1340 |       ArrayGetU(ti, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArraySet(ti, a, b, c) =>
1342 |       ArraySet(
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |         ti,
1344 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
1348 |     ArrayLen(a) => ArrayLen(self.rewrite_value(a))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayFill(ti, a, b, c, d) =>
1350 |       ArrayFill(
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         ti,
1352 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |         self.rewrite_value(d),
     |       )
     |     ArrayCopy(t1, t2, a, b, c, d, e) =>
1358 |       ArrayCopy(
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         t1,
     |         t2,
1361 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |         self.rewrite_value(d),
     |         self.rewrite_value(e),
     |       )
     |     ArrayInitData(ti, di, a, b, c, d) =>
1368 |       ArrayInitData(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ti,
     |         di,
1371 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |         self.rewrite_value(d),
     |       )
     |     ArrayInitElem(ti, ei, a, b, c, d) =>
1377 |       ArrayInitElem(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ti,
     |         ei,
1380 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |         self.rewrite_value(d),
     |       )
1385 |     Splat(sop, a) => Splat(sop, self.rewrite_value(a))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ExtractLane(eop, li, a) => ExtractLane(eop, li, self.rewrite_value(a))
     |     ReplaceLane(rop, li, a, b) =>
1388 |       ReplaceLane(rop, li, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Shuffle(lanes, a, b) =>
1390 |       Shuffle(lanes, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Swizzle(a, b) => Swizzle(self.rewrite_value(a), self.rewrite_value(b))
     |     V128Shift(sop, a, b) =>
1393 |       V128Shift(sop, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Ternary(top, a, b, c) =>
1395 |       V128Ternary(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         top,
1397 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
     |     V128LoadLane(lop, ma, li, a, b) =>
1402 |       V128LoadLane(lop, ma, li, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128StoreLane(sop, ma, li, a, b) =>
1404 |       V128StoreLane(sop, ma, li, self.rewrite_value(a), self.rewrite_value(b))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Select(tys, a, b, c) =>
1406 |       Select(
     |       ^^^^^^^ 	<-- UNCOVERED
     |         tys,
1408 |         self.rewrite_value(a),
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(b),
     |         self.rewrite_value(c),
     |       )
1412 |     Throw(ti, vs) => Throw(ti, self.rewrite_values(vs))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn SSAOptCtx::rewrite_terminator(
     |   self : SSAOptCtx,
     |   term : SSATerminator,
     | ) -> SSATerminator {
     |   match term {
     |     Br(_) => term
     |     BrIf(v, t, f) => BrIf(self.rewrite_value(v), t, f)
     |     BrTable(v, targets, default) =>
1425 |       BrTable(self.rewrite_value(v), targets, default)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BrOnNull(v, t, f) => BrOnNull(self.rewrite_value(v), t, f)
     |     BrOnNonNull(v, t, f) => BrOnNonNull(self.rewrite_value(v), t, f)
     |     BrOnCast(cop, h1, h2, v, t, f) =>
1429 |       BrOnCast(cop, h1, h2, self.rewrite_value(v), t, f)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BrOnCastFail(cop, h1, h2, v, t, f) =>
1431 |       BrOnCastFail(cop, h1, h2, self.rewrite_value(v), t, f)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Return(vs) => Return(self.rewrite_values(vs))
1433 |     ReturnCall(fi, vs) => ReturnCall(fi, self.rewrite_values(vs))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ReturnCallIndirect(ti, tbi, vs, v) =>
1435 |       ReturnCallIndirect(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ti,
     |         tbi,
1438 |         self.rewrite_values(vs),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.rewrite_value(v),
     |       )
     |     ReturnCallRef(ti, vs, v) =>
1442 |       ReturnCallRef(ti, self.rewrite_values(vs), self.rewrite_value(v))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ThrowRef(v) => ThrowRef(self.rewrite_value(v))
     |     Unreachable => Unreachable
     |   }
     | }
     …

     | fn SSAOptCtx::mark_op_uses(self : SSAOptCtx, op : SSAOp) -> Unit {
     |   match op {
     |     I32Const(_)
     |     | I64Const(_)
     |     | F32Const(_)
     |     | F64Const(_)
     |     | RefNull(_)
     |     | RefFunc(_)
     |     | V128Const(_)
     |     | MemorySize(_)
     |     | AtomicFence
     |     | DataDrop(_)
     |     | GlobalGet(_)
     |     | TableSize(_)
     |     | ElemDrop(_)
     |     | StructNewDefault(_) => ()
1483 |     Copy(v) => self.mark_value_used(v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Binary(_, a, b) => {
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |     }
1488 |     Unary(_, a) => self.mark_value_used(a)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Load(_, _, a) => self.mark_value_used(a)
     |     Store(_, _, a, b) => {
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |     }
1494 |     MemoryGrow(_, a) => self.mark_value_used(a)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     MemoryAtomicNotify(_, addr, count) => {
     |       self.mark_value_used(addr)
     |       self.mark_value_used(count)
     |     }
     |     MemoryAtomicWait32(_, addr, expected, timeout)
1500 |     | MemoryAtomicWait64(_, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(addr)
     |       self.mark_value_used(expected)
     |       self.mark_value_used(timeout)
     |     }
1505 |     AtomicRmw(_, _, addr, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(addr)
     |       self.mark_value_used(val)
     |     }
1509 |     AtomicCmpxchg(_, _, addr, expected, replacement) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(addr)
     |       self.mark_value_used(expected)
     |       self.mark_value_used(replacement)
     |     }
     |     MemoryFill(_, a, b, c)
     |     | MemoryCopy(_, _, a, b, c)
     |     | MemoryInit(_, _, a, b, c)
     |     | TableFill(_, a, b, c)
     |     | TableCopy(_, _, a, b, c)
1519 |     | TableInit(_, _, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |       self.mark_value_used(c)
     |     }
     |     GlobalSet(_, a)
     |     | TableGet(_, a)
     |     | RefIsNull(a)
     |     | RefAsNonNull(a)
     |     | RefI31(a)
     |     | I31GetS(a)
     |     | I31GetU(a)
     |     | AnyConvertExtern(a)
     |     | ExternConvertAny(a)
     |     | ArrayLen(a)
     |     | ArrayNewDefault(_, a) => self.mark_value_used(a)
     |     TableSet(_, a, b)
     |     | TableGrow(_, a, b)
     |     | RefEq(a, b)
     |     | ArrayNew(_, a, b)
     |     | ArrayNewData(_, _, a, b)
1540 |     | ArrayNewElem(_, _, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |     }
     |     RefTest(_, _, a)
     |     | RefCast(_, _, a)
     |     | StructGet(_, _, a)
     |     | StructGetS(_, _, a)
     |     | StructGetU(_, _, a)
     |     | Splat(_, a)
1550 |     | ExtractLane(_, _, a) => self.mark_value_used(a)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     StructSet(_, _, a, b)
     |     | ReplaceLane(_, _, a, b)
     |     | Shuffle(_, a, b)
     |     | Swizzle(a, b)
1555 |     | V128Shift(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |     }
1559 |     ArrayGet(_, a, b) | ArrayGetS(_, a, b) | ArrayGetU(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |     }
1563 |     ArraySet(_, a, b, c) | V128Ternary(_, a, b, c) | Select(_, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |       self.mark_value_used(c)
     |     }
     |     ArrayFill(_, a, b, c, d)
     |     | ArrayInitData(_, _, a, b, c, d)
1570 |     | ArrayInitElem(_, _, a, b, c, d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |       self.mark_value_used(c)
     |       self.mark_value_used(d)
     |     }
1576 |     ArrayCopy(_, _, a, b, c, d, e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |       self.mark_value_used(c)
     |       self.mark_value_used(d)
     |       self.mark_value_used(e)
     |     }
     |     Call(_, vs) | StructNew(_, vs) | ArrayNewFixed(_, vs) | Throw(_, vs) =>
     |       for v in vs {
     |         self.mark_value_used(v)
     |       }
1587 |     CallIndirect(_, _, vs, v) | CallRef(_, vs, v) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for vi in vs {
1589 |         self.mark_value_used(vi)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1591 |       self.mark_value_used(v)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1593 |     V128LoadLane(_, _, _, a, b) | V128StoreLane(_, _, _, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.mark_value_used(a)
     |       self.mark_value_used(b)
     |     }
     |   }
     | }
     …

     | fn SSAOptCtx::mark_terminator_uses(
     |   self : SSAOptCtx,
     |   term : SSATerminator,
     | ) -> Unit {
     |   match term {
     |     Br(_) | Unreachable => ()
     |     BrIf(v, _, _)
     |     | BrTable(v, _, _)
     |     | BrOnNull(v, _, _)
     |     | BrOnNonNull(v, _, _)
     |     | ThrowRef(v) => self.mark_value_used(v)
     |     BrOnCast(_, _, _, v, _, _) | BrOnCastFail(_, _, _, v, _, _) =>
1613 |       self.mark_value_used(v)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Return(vs) | ReturnCall(_, vs) =>
     |       for v in vs {
     |         self.mark_value_used(v)
     |       }
1618 |     ReturnCallIndirect(_, _, vs, v) | ReturnCallRef(_, vs, v) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for vi in vs {
1620 |         self.mark_value_used(vi)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1622 |       self.mark_value_used(v)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn optimize_assign(ctx : SSAOptCtx, result : SSAValue, op : SSAOp) -> Unit {
     |   match op {
     |     // Copy propagation
     |     Copy(v) => {
     |       ctx.replace(result, ctx.resolve(v))
     |       return
     |     }
     |     // Constant folding: unary
     |     Unary(uop, a) =>
     |       match ctx.get_const(a) {
     |         Some(lit) =>
     |           match eval_ssa_unary(uop, lit) {
     |             Some(result_lit) => {
     |               let cv = ctx.make_const(result_lit)
     |               ctx.replace(result, cv)
     |               return
     |             }
1656 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1658 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     // Constant folding: binary
     |     Binary(bop, a, b) => {
     |       match (ctx.get_const(a), ctx.get_const(b)) {
     |         (Some(la), Some(lb)) =>
     |           match eval_ssa_binary(bop, la, lb) {
     |             Some(result_lit) => {
     |               let cv = ctx.make_const(result_lit)
     |               ctx.replace(result, cv)
     |               return
     |             }
1670 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         _ => ()
     |       }
     |       // Strength reduction
     |       if try_strength_reduce_ssa(ctx, result, bop, a, b) {
     |         return
     |       }
     |       // Algebraic simplification
     |       if try_algebraic_simplify(ctx, result, bop, a, b) {
     |         return
     |       }
     |     }
     |     // Select with constant condition
     |     Select(_, cond, t, f) =>
     |       match ctx.get_const(cond) {
     |         Some(LitI32(0)) => {
     |           ctx.replace(result, ctx.resolve(f))
     |           return
     |         }
     |         Some(LitI32(_)) => {
     |           ctx.replace(result, ctx.resolve(t))
     |           return
     |         }
1694 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn optimize_terminator(ctx : SSAOptCtx, term : SSATerminator) -> SSATerminator {
     |   match term {
     |     // BrIf with constant condition
     |     BrIf(v, then_blk, else_blk) =>
     |       match ctx.get_const(v) {
     |         Some(LitI32(0)) => {
     |           ctx.changed = true
     |           SSATerminator::Br(else_blk)
     |         }
     |         Some(LitI32(_)) => {
     |           ctx.changed = true
     |           SSATerminator::Br(then_blk)
     |         }
     |         _ => term
     |       }
     |     // BrOnNull with known null
     |     BrOnNull(v, null_blk, nonnull_blk) =>
1722 |       match ctx.get_op(v) {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(RefNull(_)) => {
     |           ctx.changed = true
     |           SSATerminator::Br(null_blk)
     |         }
1727 |         Some(RefFunc(_)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.changed = true
     |           SSATerminator::Br(nonnull_blk)
     |         }
1731 |         _ => term
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     BrOnNonNull(v, nonnull_blk, null_blk) =>
1734 |       match ctx.get_op(v) {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(RefNull(_)) => {
     |           ctx.changed = true
     |           SSATerminator::Br(null_blk)
     |         }
1739 |         Some(RefFunc(_)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.changed = true
     |           SSATerminator::Br(nonnull_blk)
     |         }
1743 |         _ => term
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     // BrTable with constant index
     |     BrTable(v, targets, default) =>
     |       match ctx.get_const(v) {
     |         Some(LitI32(idx)) => {
     |           ctx.changed = true
     |           if idx >= 0 && idx < targets.length() {
     |             SSATerminator::Br(targets[idx])
     |           } else {
     |             SSATerminator::Br(default)
     |           }
     |         }
1756 |         _ => term
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => term
     |   }
     | }
     …

     | pub fn SSACFG::optimize(self : SSACFG) -> SSACFG {
     |   let mut current = self
     | 
     |   // Limit iterations to avoid pathological cases
     |   for _iter = 0; _iter < 10; _iter = _iter + 1 {
     |     let ctx = SSAOptCtx::new(current)
     | 
     |     // ----------------------------------------------------------
     |     // Phase 1: Local instruction-level optimization
     |     // ----------------------------------------------------------
     | 
     |     // Store optimized terminators from Phase 1
     |     let optimized_terminators : Map[BlockId, SSATerminator] = {}
     | 
     |     // ----------------------------------------------------------
     |     // Phase 1: Local instruction-level optimization
     |     // ----------------------------------------------------------
     |     for b in current.blocks {
     |       let (bid, block) = b
     | 
     |       // Phis and instructions...
     |       for phi in block.phis {
     |         optimize_phi(ctx, phi)
     |       }
     |       for instr in block.instrs {
     |         match instr {
     |           Assign(v, op) => optimize_assign(ctx, v, op)
     |           Effect(_) => ()
     |         }
     |       }
     | 
     |       // Terminators - store the result!
     |       let opt_term = optimize_terminator(ctx, block.terminator)
     |       let new_term = ctx.rewrite_terminator(opt_term)
     |       ctx.mark_terminator_uses(new_term)
     |       optimized_terminators[bid] = new_term
     |     }
     |     let mut iteration_changed = ctx.changed
     | 
     |     // ----------------------------------------------------------
     |     // Phase 2: Rewrite SSA using replacement map
     |     // ----------------------------------------------------------
     | 
     |     let new_blocks : Map[BlockId, SSABlock] = {}
     | 
     |     // First pass: rewrite + mark uses
     |     for b in current.blocks {
     |       let (bid, block) = b
     |       // Rewrite phis
     |       let new_phis : Array[PhiNode] = []
     |       for phi in block.phis {
     |         if ctx.replacements.contains(phi.result) {
     |           continue
     |         }
     |         let rp = ctx.rewrite_phi(phi)
     |         ctx.mark_phi_uses(rp)
     |         new_phis.push(rp)
     |       }
     | 
     |       // Rewrite terminator
     |       let new_term = optimized_terminators[bid]
     |       ctx.mark_terminator_uses(new_term)
     | 
     |       // Rewrite instructions (keep all for now)
     |       let rewritten : Array[SSAInstr] = []
     |       for instr in block.instrs {
     |         match instr {
     |           Assign(v, op) =>
     |             if ctx.replacements.contains(v) {
     |               () // Eliminated by replacement
     |             } else {
     |               let effective_op = match ctx.def_map.get(v) {
     |                 Some(new_op) => new_op
1864 |                 None => op
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               let new_op = ctx.rewrite_op(effective_op)
     |               rewritten.push(Assign(v, new_op))
     |             }
     |           Effect(op) => {
     |             let new_op = ctx.rewrite_op(op)
     |             ctx.mark_op_uses(new_op)
     |             rewritten.push(Effect(new_op))
     |           }
     |         }
     |       }
     | 
     |       // ------------------------------------------------------
     |       // Phase 3: Dead code elimination (pure instructions)
     |       // ------------------------------------------------------
     | 
     |       let final_instrs : Array[SSAInstr] = []
     |       for i = rewritten.length() - 1; i >= 0; i = i - 1 {
     |         match rewritten[i] {
     |           Assign(v, op) =>
     |             if has_side_effects(op) || ctx.used.contains(v) {
     |               ctx.mark_op_uses(op)
     |               final_instrs.push(rewritten[i])
     |             }
     |           Effect(op) => {
     |             ctx.mark_op_uses(op)
     |             final_instrs.push(rewritten[i])
     |           }
     |         }
     |       }
     |       if final_instrs.length() != rewritten.length() {
     |         iteration_changed = true
     |       }
     |       // Reverse back to original order
     |       final_instrs.rev_in_place()
     |       new_blocks[bid] = {
     |         id: bid,
     |         phis: new_phis,
     |         instrs: final_instrs,
     |         terminator: new_term,
     |       }
     |     }
     | 
     |     // ----------------------------------------------------------
     |     // Phase 4: Emit newly created constants (entry block)
     |     // ----------------------------------------------------------
     | 
     |     let entry = current.entry
     |     match new_blocks.get(entry) {
     |       Some(entry_block) => {
     |         let new_instrs = entry_block.instrs
     |         for b in ctx.def_map {
     |           let (v, op) = b
     |           let predicate = fn(i : SSAInstr) -> Bool {
     |             match i {
     |               Assign(av, _) => av == v
1921 |               _ => false
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           if is_const_op(op) &&
     |             ctx.used.contains(v) &&
     |             not(entry_block.instrs.any(predicate)) {
     |             new_instrs.insert(0, Assign(v, op))
     |             iteration_changed = true
     |           }
     |         }
     |         new_blocks[entry] = {
     |           id: entry_block.id,
     |           phis: entry_block.phis,
     |           instrs: new_instrs,
     |           terminator: entry_block.terminator,
     |         }
     |       }
1938 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // ----------------------------------------------------------
     |     // Commit iteration
     |     // ----------------------------------------------------------
     | 
     |     current = { ..current, blocks: new_blocks, next_value: ctx.next_value }
     |     if not(iteration_changed) {
     |       break
     |     }
     |   }
     |   current
     | }
     …

3 uncovered line(s) in src/ir/ssa_optimize_tests.mbt:

     | fn find_assign(ssa : SSACFG, block_id : Int, value_id : Int) -> SSAOp? {
     |   match ssa.blocks.get(BlockId(block_id)) {
     |     Some(block) =>
     |       for instr in block.instrs {
     |         match instr {
     |           Assign(SSAValue(v), op) if v == value_id => return Some(op)
     |           _ => continue
     |         }
     |       }
  53 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   None
     | }
     …

     | fn count_instrs(ssa : SSACFG, block_id : Int) -> Int {
     |   match ssa.blocks.get(BlockId(block_id)) {
     |     Some(block) => block.instrs.length()
  62 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn get_terminator(ssa : SSACFG, block_id : Int) -> SSATerminator? {
     |   match ssa.blocks.get(BlockId(block_id)) {
     |     Some(block) => Some(block.terminator)
  70 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

59 uncovered line(s) in src/ir/type_tracking.mbt:

    | pub fn TypeContext::empty() -> Self {
 19 |   {
    |   ^ 	<-- UNCOVERED
    |     func_types: [],
    |     global_types: [],
    |     table_types: [],
    |     struct_types: [],
    |     array_types: [],
    |     tag_types: [],
    |     local_types: [],
    |   }
    | }
    …

    | pub fn infer_ssa_types(cfg : SSACFG, ctx : TypeContext) -> SSATypeInfo {
    |   let types : Map[SSAValue, ValType] = Map::new()
    | 
    |   // Type parameters
    |   for entry in cfg.param_values {
    |     let (local_idx, val) = entry
    |     let i = local_idx.0.reinterpret_as_int()
    |     if i >= 0 && i < ctx.local_types.length() {
    |       types[val] = ctx.local_types[i]
    |     }
    |   }
    | 
    |   // Walk blocks and type each instruction
    |   for entry in cfg.blocks {
    |     let (_, block) = entry
    | 
    |     // Type phi nodes (assume first arg type)
    |     for phi in block.phis {
 49 |       let local_idx = phi.local_idx.0.reinterpret_as_int()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       if local_idx < ctx.local_types.length() {
 51 |         types[phi.result] = ctx.local_types[local_idx]
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    | 
    |     // Type instructions
    |     for instr in block.instrs {
    |       if instr is SSAInstr::Assign(result, op) {
    |         match infer_op_type(op, types, ctx) {
    |           Some(ty) => types[result] = ty
    |           None => ()
    |         }
    |       }
    |     }
    |   }
    |   SSATypeInfo::{ value_types: types }
    | }
    …

    | fn infer_op_type(
    |   op : SSAOp,
    |   types : Map[SSAValue, ValType],
    |   ctx : TypeContext,
    | ) -> ValType? {
    |   match op {
    |     SSAOp::Copy(v) => types.get(v)
    |     SSAOp::I32Const(_) => Some(ValType::i32())
 77 |     SSAOp::I64Const(_) => Some(ValType::i64())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::F32Const(_) => Some(ValType::f32())
    |     SSAOp::F64Const(_) => Some(ValType::f64())
    |     SSAOp::V128Const(_) => Some(ValType::v128())
    |     SSAOp::RefNull(ht) => Some(ValType::ref_null(ht))
    |     SSAOp::RefFunc(_) =>
 83 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         ValType::ref_type(
    |           RefType::new(false, HeapType::abs(AbsHeapType::func())),
    |         ),
    |       )
 88 |     SSAOp::Unary(op, _) => Some(unary_result_type(op))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Binary(op, _, _) => Some(binary_result_type(op))
    |     SSAOp::Select(tys, _, _, _) =>
    |       match tys {
 92 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(tys) => if tys.is_empty() { None } else { Some(tys[0]) }
    |       }
 95 |     SSAOp::GlobalGet(idx) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let i = idx.0.reinterpret_as_int()
    |       if i < ctx.global_types.length() {
 98 |         Some(ctx.global_types[i].0)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
100 |         None
    |         ^^^^ 	<-- UNCOVERED
    |       }
    |     }
103 |     SSAOp::Load(op, _, _) => Some(load_result_type(op))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemorySize(_) => Some(ValType::i32())
    |     SSAOp::MemoryGrow(_, _) => Some(ValType::i32())
    |     SSAOp::MemoryAtomicNotify(_, _, _) => Some(ValType::i32())
    |     SSAOp::MemoryAtomicWait32(_, _, _, _) => Some(ValType::i32())
    |     SSAOp::MemoryAtomicWait64(_, _, _, _) => Some(ValType::i32())
    |     SSAOp::AtomicRmw(op, _, _, _) => Some(atomic_rmw_result_type(op))
    |     SSAOp::AtomicCmpxchg(op, _, _, _, _) => Some(atomic_cmpxchg_result_type(op))
    |     SSAOp::TableSize(_) => Some(ValType::i32())
    |     SSAOp::TableGet(idx, _) => {
    |       let i = idx.0.reinterpret_as_int()
    |       if i < ctx.table_types.length() {
115 |         Some(ValType::ref_type(ctx.table_types[i].0))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
117 |         None
    |         ^^^^ 	<-- UNCOVERED
    |       }
    |     }
120 |     SSAOp::TableGrow(_, _, _) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Call(func_idx, _) => {
    |       let i = func_idx.0.reinterpret_as_int()
    |       if i < ctx.func_types.length() {
124 |         let ft = ctx.func_types[i]
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         if ft.1.length() == 1 {
126 |           Some(ft.1[0])
    |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         } else {
128 |           None // Multi-value not directly supported
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       } else {
131 |         None
    |         ^^^^ 	<-- UNCOVERED
    |       }
    |     }
134 |     SSAOp::RefIsNull(_) | SSAOp::RefEq(_, _) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::RefAsNonNull(v) =>
    |       match types.get(v) {
    |         Some(ValType::RefTypeValType(rt)) =>
    |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
139 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     SSAOp::RefI31(_) =>
142 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         ValType::ref_type(
    |           RefType::new(false, HeapType::abs(AbsHeapType::i31())),
    |         ),
    |       )
147 |     SSAOp::I31GetS(_) | SSAOp::I31GetU(_) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::RefTest(_, _, _) => Some(ValType::i32())
    |     SSAOp::RefCast(nullable, ht, _) =>
150 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::AnyConvertExtern(_) =>
152 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         ValType::ref_type(
    |           RefType::new(false, HeapType::abs(AbsHeapType::any())),
    |         ),
    |       )
    |     SSAOp::ExternConvertAny(_) =>
158 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         ValType::ref_type(
    |           RefType::new(false, HeapType::abs(AbsHeapType::extern_())),
    |         ),
    |       )
    |     SSAOp::StructNew(ty, _) | SSAOp::StructNewDefault(ty) =>
164 |       Some(ValType::ref_type(RefType::new(false, HeapType::new(ty))))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::StructGet(ty, field, _)
    |     | SSAOp::StructGetS(ty, field, _)
167 |     | SSAOp::StructGetU(ty, field, _) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let i = match ty {
    |         TypeIdx(i) => i.reinterpret_as_int()
    |         RecIdx(_) => return None
    |       }
172 |       let f = field.0.reinterpret_as_int()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       if i < ctx.struct_types.length() && f < ctx.struct_types[i].length() {
174 |         Some(ctx.struct_types[i][f].unpack())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
176 |         None
    |         ^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     SSAOp::ArrayNew(ty, _, _)
    |     | SSAOp::ArrayNewDefault(ty, _)
    |     | SSAOp::ArrayNewFixed(ty, _)
    |     | SSAOp::ArrayNewData(ty, _, _, _)
    |     | SSAOp::ArrayNewElem(ty, _, _, _) =>
184 |       Some(ValType::ref_type(RefType::new(false, HeapType::new(ty))))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayGet(ty, _, _)
    |     | SSAOp::ArrayGetS(ty, _, _)
187 |     | SSAOp::ArrayGetU(ty, _, _) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let i = match ty {
    |         TypeIdx(i) => i.reinterpret_as_int()
    |         RecIdx(_) => return None
    |       }
    |       if i < ctx.array_types.length() {
193 |         Some(ctx.array_types[i].unpack())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
195 |         None
    |         ^^^^ 	<-- UNCOVERED
    |       }
    |     }
198 |     SSAOp::ArrayLen(_) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Splat(_, _) => Some(ValType::v128())
    |     SSAOp::ExtractLane(op, _, _) => Some(extract_lane_result_type(op))
    |     SSAOp::ReplaceLane(_, _, _, _) => Some(ValType::v128())
    |     SSAOp::Shuffle(_, _, _) | SSAOp::Swizzle(_, _) => Some(ValType::v128())
    |     SSAOp::V128Shift(_, _, _) | SSAOp::V128Ternary(_, _, _, _) =>
204 |       Some(ValType::v128())
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::V128LoadLane(_, _, _, _, _) => Some(ValType::v128())
    | 
    |     // Effects - no result type
    |     SSAOp::GlobalSet(_, _)
    |     | SSAOp::Store(_, _, _, _)
    |     | SSAOp::AtomicFence
    |     | SSAOp::MemoryFill(_, _, _, _)
    |     | SSAOp::MemoryCopy(_, _, _, _, _)
    |     | SSAOp::MemoryInit(_, _, _, _, _)
    |     | SSAOp::DataDrop(_)
    |     | SSAOp::TableSet(_, _, _)
    |     | SSAOp::TableFill(_, _, _, _)
    |     | SSAOp::TableCopy(_, _, _, _, _)
    |     | SSAOp::TableInit(_, _, _, _, _)
    |     | SSAOp::ElemDrop(_)
    |     | SSAOp::StructSet(_, _, _, _)
    |     | SSAOp::ArraySet(_, _, _, _)
    |     | SSAOp::ArrayFill(_, _, _, _, _)
    |     | SSAOp::ArrayCopy(_, _, _, _, _, _, _)
    |     | SSAOp::ArrayInitData(_, _, _, _, _, _)
    |     | SSAOp::ArrayInitElem(_, _, _, _, _, _)
    |     | SSAOp::V128StoreLane(_, _, _, _, _)
227 |     | SSAOp::Throw(_, _) => None
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     _ => None
    |   }
    | }
    …

    | fn unary_result_type(op : UnaryOp) -> ValType {
234 |   match op {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     I32ClzOp
    |     | I32CtzOp
    |     | I32PopcntOp
    |     | I32EqzOp
    |     | I32Extend8SOp
    |     | I32Extend16SOp
    |     | I32WrapI64Op
    |     | I32TruncF32SOp
    |     | I32TruncF32UOp
    |     | I32TruncF64SOp
    |     | I32TruncF64UOp
    |     | I32TruncSatF32SOp
    |     | I32TruncSatF32UOp
    |     | I32TruncSatF64SOp
    |     | I32TruncSatF64UOp
250 |     | I32ReinterpretF32Op => ValType::i32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I64ClzOp
    |     | I64CtzOp
    |     | I64PopcntOp
    |     | I64EqzOp
    |     | I64Extend8SOp
    |     | I64Extend16SOp
    |     | I64Extend32SOp
    |     | I64ExtendI32SOp
    |     | I64ExtendI32UOp
    |     | I64TruncF32SOp
    |     | I64TruncF32UOp
    |     | I64TruncF64SOp
    |     | I64TruncF64UOp
    |     | I64TruncSatF32SOp
    |     | I64TruncSatF32UOp
    |     | I64TruncSatF64SOp
    |     | I64TruncSatF64UOp
268 |     | I64ReinterpretF64Op => ValType::i64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F32AbsOp
    |     | F32NegOp
    |     | F32CeilOp
    |     | F32FloorOp
    |     | F32TruncOp
    |     | F32NearestOp
    |     | F32SqrtOp
    |     | F32ConvertI32SOp
    |     | F32ConvertI32UOp
    |     | F32ConvertI64SOp
    |     | F32ConvertI64UOp
    |     | F32DemoteF64Op
281 |     | F32ReinterpretI32Op => ValType::f32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F64AbsOp
    |     | F64NegOp
    |     | F64CeilOp
    |     | F64FloorOp
    |     | F64TruncOp
    |     | F64NearestOp
    |     | F64SqrtOp
    |     | F64ConvertI32SOp
    |     | F64ConvertI32UOp
    |     | F64ConvertI64SOp
    |     | F64ConvertI64UOp
    |     | F64PromoteF32Op
294 |     | F64ReinterpretI64Op => ValType::f64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     _ => ValType::i32() // Default fallback
    |   }
    | }
    …

    | fn binary_result_type(op : BinaryOp) -> ValType {
301 |   match op {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     I32AddOp
    |     | I32SubOp
    |     | I32MulOp
    |     | I32DivSOp
    |     | I32DivUOp
    |     | I32RemSOp
    |     | I32RemUOp
    |     | I32AndOp
    |     | I32OrOp
    |     | I32XorOp
    |     | I32ShlOp
    |     | I32ShrSOp
    |     | I32ShrUOp
    |     | I32RotlOp
    |     | I32RotrOp
    |     | I32EqOp
    |     | I32NeOp
    |     | I32LtSOp
    |     | I32LtUOp
    |     | I32GtSOp
    |     | I32GtUOp
    |     | I32LeSOp
    |     | I32LeUOp
    |     | I32GeSOp
    |     | I32GeUOp
    |     | I64EqOp
    |     | I64NeOp
    |     | I64LtSOp
    |     | I64LtUOp
    |     | I64GtSOp
    |     | I64GtUOp
    |     | I64LeSOp
    |     | I64LeUOp
    |     | I64GeSOp
    |     | I64GeUOp
    |     | F32EqOp
    |     | F32NeOp
    |     | F32LtOp
    |     | F32GtOp
    |     | F32LeOp
    |     | F32GeOp
    |     | F64EqOp
    |     | F64NeOp
    |     | F64LtOp
    |     | F64GtOp
    |     | F64LeOp
348 |     | F64GeOp => ValType::i32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I64AddOp
    |     | I64SubOp
    |     | I64MulOp
    |     | I64DivSOp
    |     | I64DivUOp
    |     | I64RemSOp
    |     | I64RemUOp
    |     | I64AndOp
    |     | I64OrOp
    |     | I64XorOp
    |     | I64ShlOp
    |     | I64ShrSOp
    |     | I64ShrUOp
    |     | I64RotlOp
363 |     | I64RotrOp => ValType::i64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F32AddOp
    |     | F32SubOp
    |     | F32MulOp
    |     | F32DivOp
    |     | F32MinOp
    |     | F32MaxOp
370 |     | F32CopysignOp => ValType::f32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F64AddOp
    |     | F64SubOp
    |     | F64MulOp
    |     | F64DivOp
    |     | F64MinOp
    |     | F64MaxOp
377 |     | F64CopysignOp => ValType::f64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     _ => ValType::i32() // Default fallback
    |   }
    | }
    …

    | fn load_result_type(op : LoadOp) -> ValType {
384 |   match op {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     I32LoadOp
    |     | I32Load8SOp
    |     | I32Load8UOp
    |     | I32Load16SOp
    |     | I32Load16UOp
    |     | I32AtomicLoadOp
    |     | I32AtomicLoad8UOp
392 |     | I32AtomicLoad16UOp => ValType::i32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I64LoadOp
    |     | I64Load8SOp
    |     | I64Load8UOp
    |     | I64Load16SOp
    |     | I64Load16UOp
    |     | I64Load32SOp
    |     | I64Load32UOp
    |     | I64AtomicLoadOp
    |     | I64AtomicLoad8UOp
    |     | I64AtomicLoad16UOp
403 |     | I64AtomicLoad32UOp => ValType::i64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F32LoadOp => ValType::f32()
    |     F64LoadOp => ValType::f64()
    |     V128LoadOp
    |     | V128Load8x8SOp
    |     | V128Load8x8UOp
    |     | V128Load16x4SOp
    |     | V128Load16x4UOp
    |     | V128Load32ZeroOp
    |     | V128Load64SplatOp
    |     | V128Load32SplatOp
    |     | V128Load16SplatOp
    |     | V128Load8SplatOp
    |     | V128Load32x2UOp
    |     | V128Load32x2SOp
418 |     | V128Load64ZeroOp => ValType::v128()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn atomic_rmw_result_type(op : AtomicRmwOp) -> ValType {
424 |   match op {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     I32AtomicRmwAddOp
    |     | I32AtomicRmw8AddUOp
    |     | I32AtomicRmw16AddUOp
    |     | I32AtomicRmwSubOp
    |     | I32AtomicRmw8SubUOp
    |     | I32AtomicRmw16SubUOp
    |     | I32AtomicRmwAndOp
    |     | I32AtomicRmw8AndUOp
    |     | I32AtomicRmw16AndUOp
    |     | I32AtomicRmwOrOp
    |     | I32AtomicRmw8OrUOp
    |     | I32AtomicRmw16OrUOp
    |     | I32AtomicRmwXorOp
    |     | I32AtomicRmw8XorUOp
    |     | I32AtomicRmw16XorUOp
    |     | I32AtomicRmwXchgOp
    |     | I32AtomicRmw8XchgUOp
442 |     | I32AtomicRmw16XchgUOp => ValType::i32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I64AtomicRmwAddOp
    |     | I64AtomicRmw8AddUOp
    |     | I64AtomicRmw16AddUOp
    |     | I64AtomicRmw32AddUOp
    |     | I64AtomicRmwSubOp
    |     | I64AtomicRmw8SubUOp
    |     | I64AtomicRmw16SubUOp
    |     | I64AtomicRmw32SubUOp
    |     | I64AtomicRmwAndOp
    |     | I64AtomicRmw8AndUOp
    |     | I64AtomicRmw16AndUOp
    |     | I64AtomicRmw32AndUOp
    |     | I64AtomicRmwOrOp
    |     | I64AtomicRmw8OrUOp
    |     | I64AtomicRmw16OrUOp
    |     | I64AtomicRmw32OrUOp
    |     | I64AtomicRmwXorOp
    |     | I64AtomicRmw8XorUOp
    |     | I64AtomicRmw16XorUOp
    |     | I64AtomicRmw32XorUOp
    |     | I64AtomicRmwXchgOp
    |     | I64AtomicRmw8XchgUOp
    |     | I64AtomicRmw16XchgUOp
466 |     | I64AtomicRmw32XchgUOp => ValType::i64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn atomic_cmpxchg_result_type(op : AtomicCmpxchgOp) -> ValType {
472 |   match op {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     I32AtomicRmwCmpxchgOp
    |     | I32AtomicRmw8CmpxchgUOp
475 |     | I32AtomicRmw16CmpxchgUOp => ValType::i32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I64AtomicRmwCmpxchgOp
    |     | I64AtomicRmw8CmpxchgUOp
    |     | I64AtomicRmw16CmpxchgUOp
479 |     | I64AtomicRmw32CmpxchgUOp => ValType::i64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn extract_lane_result_type(op : ExtractLaneOp) -> ValType {
485 |   match op {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     ExtractLaneOp::I8x16ExtractLaneSOp
    |     | ExtractLaneOp::I8x16ExtractLaneUOp
    |     | ExtractLaneOp::I16x8ExtractLaneSOp
    |     | ExtractLaneOp::I16x8ExtractLaneUOp
490 |     | ExtractLaneOp::I32x4ExtractLaneOp => ValType::i32()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ExtractLaneOp::I64x2ExtractLaneOp => ValType::i64()
    |     ExtractLaneOp::F32x4ExtractLaneOp => ValType::f32()
    |     ExtractLaneOp::F64x2ExtractLaneOp => ValType::f64()
    |   }
    | }
    …

51 uncovered line(s) in src/ir/usedef.mbt:

    | pub fn SSACFG::build_use_def(cfg : SSACFG) -> UseDefInfo {
    |   let defs : Map[SSAValue, (BlockId, SSADef)] = Map::new()
    |   let uses : Map[SSAValue, Array[SSAUse]] = Map::new()
    | 
    |   // Helper to record a use
    |   fn record_use(
    |     uses : Map[SSAValue, Array[SSAUse]],
    |     val : SSAValue,
    |     use_ : SSAUse,
    |   ) {
    |     uses.get_or_init(val, fn() { [] }).push(use_)
    |   }
    | 
    |   // Record parameter definitions
    |   for entry in cfg.param_values {
    |     let (local_idx, val) = entry
    |     defs[val] = (cfg.entry, SSADef::Param(local_idx))
    |     ignore(uses.get_or_init(val, fn() { [] }))
    |   }
    | 
    |   // Walk all blocks
    |   for entry in cfg.blocks {
    |     let (block_id, block) = entry
    | 
    |     // Record phi definitions and uses
    |     for phi in block.phis {
    |       defs[phi.result] = (block_id, SSADef::Phi(phi.local_idx))
    |       ignore(uses.get_or_init(phi.result, fn() { [] }))
    |       for arg_entry in phi.args {
    |         let (pred_id, val) = arg_entry
    |         record_use(uses, val, SSAUse::InPhi(block_id, phi.local_idx, pred_id))
    |       }
    |     }
    | 
    |     // Record instruction definitions and uses
    |     for i, instr in block.instrs {
    |       match instr {
    |         SSAInstr::Assign(result, op) => {
    |           defs[result] = (block_id, SSADef::Instr(i))
    |           ignore(uses.get_or_init(result, fn() { [] }))
    |           collect_op_uses(op, block_id, i, uses)
    |         }
 44 |         SSAInstr::Effect(op) => collect_op_uses(op, block_id, i, uses)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    | 
    |     // Record terminator uses
    |     collect_terminator_uses(block.terminator, block_id, uses)
    |   }
    |   UseDefInfo::{ defs, uses }
    | }
    …

    | fn collect_op_uses(
    |   op : SSAOp,
    |   block_id : BlockId,
    |   instr_idx : Int,
    |   uses : Map[SSAValue, Array[SSAUse]],
    | ) -> Unit {
    |   let use_ = SSAUse::InInstr(block_id, instr_idx)
    |   fn record(
    |     uses : Map[SSAValue, Array[SSAUse]],
    |     val : SSAValue,
    |     use_ : SSAUse,
    |   ) {
    |     uses.get_or_init(val, fn() { [] }).push(use_)
    |   }
    | 
    |   match op {
    |     SSAOp::Copy(v) => record(uses, v, use_)
 72 |     SSAOp::Unary(_, v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Binary(_, a, b) => {
    |       record(uses, a, use_)
    |       record(uses, b, use_)
    |     }
 77 |     SSAOp::Select(_, a, b, c) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, a, use_)
    |       record(uses, b, use_)
    |       record(uses, c, use_)
    |     }
    |     SSAOp::Call(_, args) =>
 83 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         record(uses, a, use_)
    |       }
 86 |     SSAOp::CallIndirect(_, _, args, idx) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for a in args {
 88 |         record(uses, a, use_)
    |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 90 |       record(uses, idx, use_)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
 92 |     SSAOp::CallRef(_, args, func) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for a in args {
 94 |         record(uses, a, use_)
    |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 96 |       record(uses, func, use_)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
 98 |     SSAOp::GlobalSet(_, v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::Load(_, _, addr) => record(uses, addr, use_)
    |     SSAOp::Store(_, _, addr, val) => {
    |       record(uses, addr, use_)
    |       record(uses, val, use_)
    |     }
104 |     SSAOp::MemoryGrow(_, v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::MemoryAtomicNotify(_, addr, count) => {
    |       record(uses, addr, use_)
    |       record(uses, count, use_)
    |     }
    |     SSAOp::MemoryAtomicWait32(_, addr, expected, timeout)
110 |     | SSAOp::MemoryAtomicWait64(_, addr, expected, timeout) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, addr, use_)
    |       record(uses, expected, use_)
    |       record(uses, timeout, use_)
    |     }
115 |     SSAOp::AtomicRmw(_, _, addr, val) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, addr, use_)
    |       record(uses, val, use_)
    |     }
119 |     SSAOp::AtomicCmpxchg(_, _, addr, expected, replacement) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, addr, use_)
    |       record(uses, expected, use_)
    |       record(uses, replacement, use_)
    |     }
124 |     SSAOp::MemoryFill(_, d, v, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, d, use_)
    |       record(uses, v, use_)
    |       record(uses, l, use_)
    |     }
129 |     SSAOp::MemoryCopy(_, _, d, s, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, d, use_)
    |       record(uses, s, use_)
    |       record(uses, l, use_)
    |     }
134 |     SSAOp::MemoryInit(_, _, d, s, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, d, use_)
    |       record(uses, s, use_)
    |       record(uses, l, use_)
    |     }
139 |     SSAOp::TableGet(_, i) => record(uses, i, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::TableSet(_, i, v) => {
    |       record(uses, i, use_)
    |       record(uses, v, use_)
    |     }
144 |     SSAOp::TableGrow(_, v, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, v, use_)
    |       record(uses, n, use_)
    |     }
148 |     SSAOp::TableFill(_, i, v, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, i, use_)
    |       record(uses, v, use_)
    |       record(uses, n, use_)
    |     }
153 |     SSAOp::TableCopy(_, _, d, s, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, d, use_)
    |       record(uses, s, use_)
    |       record(uses, n, use_)
    |     }
158 |     SSAOp::TableInit(_, _, d, s, n) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, d, use_)
    |       record(uses, s, use_)
    |       record(uses, n, use_)
    |     }
    |     SSAOp::RefIsNull(v)
    |     | SSAOp::RefAsNonNull(v)
    |     | SSAOp::RefI31(v)
    |     | SSAOp::I31GetS(v)
    |     | SSAOp::I31GetU(v)
    |     | SSAOp::RefTest(_, _, v)
    |     | SSAOp::RefCast(_, _, v)
    |     | SSAOp::AnyConvertExtern(v)
171 |     | SSAOp::ExternConvertAny(v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::RefEq(a, b) => {
    |       record(uses, a, use_)
    |       record(uses, b, use_)
    |     }
    |     SSAOp::StructNew(_, args) =>
177 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         record(uses, a, use_)
    |       }
    |     SSAOp::StructGet(_, _, v)
    |     | SSAOp::StructGetS(_, _, v)
182 |     | SSAOp::StructGetU(_, _, v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::StructSet(_, _, o, v) => {
    |       record(uses, o, use_)
    |       record(uses, v, use_)
    |     }
187 |     SSAOp::ArrayNew(_, v, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, v, use_)
    |       record(uses, l, use_)
    |     }
191 |     SSAOp::ArrayNewDefault(_, l) => record(uses, l, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayNewFixed(_, args) =>
193 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         record(uses, a, use_)
    |       }
196 |     SSAOp::ArrayNewData(_, _, o, l) | SSAOp::ArrayNewElem(_, _, o, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, o, use_)
    |       record(uses, l, use_)
    |     }
    |     SSAOp::ArrayGet(_, a, i)
    |     | SSAOp::ArrayGetS(_, a, i)
202 |     | SSAOp::ArrayGetU(_, a, i) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, a, use_)
    |       record(uses, i, use_)
    |     }
206 |     SSAOp::ArraySet(_, a, i, v) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, a, use_)
    |       record(uses, i, use_)
    |       record(uses, v, use_)
    |     }
211 |     SSAOp::ArrayLen(v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ArrayFill(_, a, o, v, l) => {
    |       record(uses, a, use_)
    |       record(uses, o, use_)
    |       record(uses, v, use_)
    |       record(uses, l, use_)
    |     }
218 |     SSAOp::ArrayCopy(_, _, d, d_off, s, s_off, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, d, use_)
    |       record(uses, d_off, use_)
    |       record(uses, s, use_)
    |       record(uses, s_off, use_)
    |       record(uses, l, use_)
    |     }
    |     SSAOp::ArrayInitData(_, _, a, ao, d_off, l)
226 |     | SSAOp::ArrayInitElem(_, _, a, ao, d_off, l) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, a, use_)
    |       record(uses, ao, use_)
    |       record(uses, d_off, use_)
    |       record(uses, l, use_)
    |     }
232 |     SSAOp::Splat(_, v) => record(uses, v, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     SSAOp::ExtractLane(_, _, v) => record(uses, v, use_)
    |     SSAOp::ReplaceLane(_, _, vec, val) => {
    |       record(uses, vec, use_)
    |       record(uses, val, use_)
    |     }
238 |     SSAOp::Shuffle(_, a, b) | SSAOp::Swizzle(a, b) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, a, use_)
    |       record(uses, b, use_)
    |     }
242 |     SSAOp::V128Shift(_, v, s) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, v, use_)
    |       record(uses, s, use_)
    |     }
246 |     SSAOp::V128Ternary(_, a, b, c) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, a, use_)
    |       record(uses, b, use_)
    |       record(uses, c, use_)
    |     }
251 |     SSAOp::V128LoadLane(_, _, _, addr, vec) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, addr, use_)
    |       record(uses, vec, use_)
    |     }
255 |     SSAOp::V128StoreLane(_, _, _, addr, vec) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       record(uses, addr, use_)
    |       record(uses, vec, use_)
    |     }
    |     SSAOp::Throw(_, args) =>
260 |       for a in args {
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         record(uses, a, use_)
    |       }
    |     // No uses
    |     SSAOp::I32Const(_)
    |     | SSAOp::I64Const(_)
    |     | SSAOp::F32Const(_)
    |     | SSAOp::F64Const(_)
    |     | SSAOp::V128Const(_)
    |     | SSAOp::RefNull(_)
    |     | SSAOp::RefFunc(_)
    |     | SSAOp::GlobalGet(_)
    |     | SSAOp::MemorySize(_)
    |     | SSAOp::AtomicFence
    |     | SSAOp::TableSize(_)
    |     | SSAOp::DataDrop(_)
    |     | SSAOp::ElemDrop(_)
    |     | SSAOp::StructNewDefault(_) => ()
    |   }
    | }
    …

    | fn collect_terminator_uses(
    |   term : SSATerminator,
    |   block_id : BlockId,
    |   uses : Map[SSAValue, Array[SSAUse]],
    | ) -> Unit {
    |   let use_ = SSAUse::InTerminator(block_id)
    |   fn record(
    |     uses : Map[SSAValue, Array[SSAUse]],
    |     val : SSAValue,
    |     use_ : SSAUse,
    |   ) {
    |     uses.get_or_init(val, fn() { [] }).push(use_)
    |   }
    | 
    |   match term {
    |     Br(_) | Unreachable => ()
298 |     BrIf(cond, _, _) | BrTable(cond, _, _) => record(uses, cond, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     BrOnNull(val, _, _) | BrOnNonNull(val, _, _) => record(uses, val, use_)
    |     BrOnCast(_, _, _, val, _, _) | BrOnCastFail(_, _, _, val, _, _) =>
301 |       record(uses, val, use_)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Return(vals) | ReturnCall(_, vals) =>
    |       for v in vals {
    |         record(uses, v, use_)
    |       }
306 |     ReturnCallIndirect(_, _, args, idx) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for v in args {
308 |         record(uses, v, use_)
    |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
310 |       record(uses, idx, use_)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
312 |     ReturnCallRef(_, args, func) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for v in args {
314 |         record(uses, v, use_)
    |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
316 |       record(uses, func, use_)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
318 |     ThrowRef(val) => record(uses, val, use_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

3 uncovered line(s) in src/lib/arbitrary.mbt:

     | pub impl @quickcheck.Arbitrary for ValType with arbitrary(size, st) {
     |   match st.next_uint() % 3 {
     |     0 => NumTypeValType(@quickcheck.Arbitrary::arbitrary(size, st))
     |     1 => VecTypeValType
     |     2 => RefTypeValType(@quickcheck.Arbitrary::arbitrary(size, st))
  39 |     _ => VecTypeValType
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl @quickcheck.Arbitrary for DefType with arbitrary(t, state) {
  70 |   let s = @quickcheck.Arbitrary::arbitrary(t, state)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match s {
     |     SingleRecType(_) => DefType(s, 0)
     |     GroupRecType(g) => {
     |       let idx = state.next_uint() % g.length().reinterpret_as_uint()
     |       DefType(s, idx)
     |     }
     |   }
     | }
     …

     | pub impl @quickcheck.Arbitrary for Instruction with arbitrary(t, state) {
     |   match state.next_uint() % 494 {
     |     0 => Unreachable
     |     1 => Nop
     |     2 =>
     |       Block(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     3 =>
     |       Loop(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     4 =>
     |       If(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         array_of_arbitrary(5, t, state),
     |         if (state.next_uint() & 1) == 1 {
     |           Some(array_of_arbitrary(5, t, state))
     |         } else {
     |           None
     |         },
     |       )
     |     5 => Throw(@quickcheck.Arbitrary::arbitrary(t, state))
     |     6 => ThrowRef
     |     7 => Br(@quickcheck.Arbitrary::arbitrary(t, state))
     |     8 => BrIf(@quickcheck.Arbitrary::arbitrary(t, state))
     |     9 =>
     |       BrTable(
     |         array_of_arbitrary(3, t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     10 => Return
     |     11 => Call(@quickcheck.Arbitrary::arbitrary(t, state))
     |     12 =>
     |       CallIndirect(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     13 => ReturnCall(@quickcheck.Arbitrary::arbitrary(t, state))
     |     14 =>
     |       ReturnCallIndirect(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     15 => CallRef(@quickcheck.Arbitrary::arbitrary(t, state))
     |     16 => ReturnCallRef(@quickcheck.Arbitrary::arbitrary(t, state))
     |     17 => Drop
     |     18 =>
     |       TryTable(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         array_of_arbitrary(4, t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     19 =>
     |       Select(
     |         if @quickcheck.Arbitrary::arbitrary(t, state) {
     |           Some(array_of_arbitrary(4, t, state))
     |         } else {
     |           None
     |         },
     |       )
     |     20 => LocalGet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     21 => LocalSet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     22 => LocalTee(@quickcheck.Arbitrary::arbitrary(t, state))
     |     23 => GlobalGet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     24 => GlobalSet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     25 => TableGet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     26 => TableSet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     27 => I32Load(@quickcheck.Arbitrary::arbitrary(t, state))
     |     28 => I64Load(@quickcheck.Arbitrary::arbitrary(t, state))
     |     29 => F32Load(@quickcheck.Arbitrary::arbitrary(t, state))
     |     30 => F64Load(@quickcheck.Arbitrary::arbitrary(t, state))
     |     31 => I32Load8S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     32 => I32Load8U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     33 => I32Load16S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     34 => I32Load16U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     35 => I64Load8S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     36 => I64Load8U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     37 => I64Load16S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     38 => I64Load16U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     39 => I64Load32S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     40 => I64Load32U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     41 => I32Store(@quickcheck.Arbitrary::arbitrary(t, state))
     |     42 => I64Store(@quickcheck.Arbitrary::arbitrary(t, state))
     |     43 => F32Store(@quickcheck.Arbitrary::arbitrary(t, state))
     |     44 => F64Store(@quickcheck.Arbitrary::arbitrary(t, state))
     |     45 => I32Store8(@quickcheck.Arbitrary::arbitrary(t, state))
     |     46 => I32Store16(@quickcheck.Arbitrary::arbitrary(t, state))
     |     47 => I64Store8(@quickcheck.Arbitrary::arbitrary(t, state))
     |     48 => I64Store16(@quickcheck.Arbitrary::arbitrary(t, state))
     |     49 => I64Store32(@quickcheck.Arbitrary::arbitrary(t, state))
     |     50 => MemorySize(@quickcheck.Arbitrary::arbitrary(t, state))
     |     51 => MemoryGrow(@quickcheck.Arbitrary::arbitrary(t, state))
     |     52 => I32Const(@quickcheck.Arbitrary::arbitrary(t, state))
     |     53 => I64Const(@quickcheck.Arbitrary::arbitrary(t, state))
     |     54 => F32Const(@quickcheck.Arbitrary::arbitrary(t, state))
     |     55 => F64Const(@quickcheck.Arbitrary::arbitrary(t, state))
     |     56 => I32Eqz
     |     57 => I32Eq
     |     58 => I32Ne
     |     59 => I32LtS
     |     60 => I32LtU
     |     61 => I32GtS
     |     62 => I32GtU
     |     63 => I32LeS
     |     64 => I32LeU
     |     65 => I32GeS
     |     66 => I32GeU
     |     67 => I64Eqz
     |     68 => I64Eq
     |     69 => I64Ne
     |     70 => I64LtS
     |     71 => I64LtU
     |     72 => I64GtS
     |     73 => I64GtU
     |     74 => I64LeS
     |     75 => I64LeU
     |     76 => I64GeS
     |     77 => I64GeU
     |     78 => F32Eq
     |     79 => F32Ne
     |     80 => F32Lt
     |     81 => F32Gt
     |     82 => F32Le
     |     83 => F32Ge
     |     84 => F64Eq
     |     85 => F64Ne
     |     86 => F64Lt
     |     87 => F64Gt
     |     88 => F64Le
     |     89 => F64Ge
     |     90 => I32Clz
     |     91 => I32Ctz
     |     92 => I32Popcnt
     |     93 => I32Add
     |     94 => I32Sub
     |     95 => I32Mul
     |     96 => I32DivS
     |     97 => I32DivU
     |     98 => I32RemS
     |     99 => I32RemU
     |     100 => I32And
     |     101 => I32Or
     |     102 => I32Xor
     |     103 => I32Shl
     |     104 => I32ShrS
     |     105 => I32ShrU
     |     106 => I32Rotl
     |     107 => I32Rotr
     |     108 => I64Clz
     |     109 => I64Ctz
     |     110 => I64Popcnt
     |     111 => I64Add
     |     112 => I64Sub
     |     113 => I64Mul
     |     114 => I64DivS
     |     115 => I64DivU
     |     116 => I64RemS
     |     117 => I64RemU
     |     118 => I64And
     |     119 => I64Or
     |     120 => I64Xor
     |     121 => I64Shl
     |     122 => I64ShrS
     |     123 => I64ShrU
     |     124 => I64Rotl
     |     125 => I64Rotr
     |     126 => F32Abs
     |     127 => F32Neg
     |     128 => F32Ceil
     |     129 => F32Floor
     |     130 => F32Trunc
     |     131 => F32Nearest
     |     132 => F32Sqrt
     |     133 => F32Add
     |     134 => F32Sub
     |     135 => F32Mul
     |     136 => F32Div
     |     137 => F32Min
     |     138 => F32Max
     |     139 => F32Copysign
     |     140 => F64Abs
     |     141 => F64Neg
     |     142 => F64Ceil
     |     143 => F64Floor
     |     144 => F64Trunc
     |     145 => F64Nearest
     |     146 => F64Sqrt
     |     147 => F64Add
     |     148 => F64Sub
     |     149 => F64Mul
     |     150 => F64Div
     |     151 => F64Min
     |     152 => F64Max
     |     153 => F64Copysign
     |     154 => I32WrapI64
     |     155 => I32TruncF32S
     |     156 => I32TruncF32U
     |     157 => I32TruncF64S
     |     158 => I32TruncF64U
     |     159 => I64ExtendI32S
     |     160 => I64ExtendI32U
     |     161 => I64TruncF32S
     |     162 => I64TruncF32U
     |     163 => I64TruncF64S
     |     164 => I64TruncF64U
     |     165 => F32ConvertI32S
     |     166 => F32ConvertI32U
     |     167 => F32ConvertI64S
     |     168 => F32ConvertI64U
     |     169 => F32DemoteF64
     |     170 => F64ConvertI32S
     |     171 => F64ConvertI32U
     |     172 => F64ConvertI64S
     |     173 => F64ConvertI64U
     |     174 => F64PromoteF32
     |     175 => I32ReinterpretF32
     |     176 => I64ReinterpretF64
     |     177 => F32ReinterpretI32
     |     178 => F64ReinterpretI64
     |     179 => I32Extend8S
     |     180 => I32Extend16S
     |     181 => I64Extend8S
     |     182 => I64Extend16S
     |     183 => I64Extend32S
     |     184 => RefNull(@quickcheck.Arbitrary::arbitrary(t, state))
     |     185 => RefIsNull
     |     186 => RefFunc(@quickcheck.Arbitrary::arbitrary(t, state))
     |     187 => RefEq
     |     188 => RefAsNonNull
     |     189 => BrOnNull(@quickcheck.Arbitrary::arbitrary(t, state))
     |     190 => BrOnNonNull(@quickcheck.Arbitrary::arbitrary(t, state))
     |     191 => StructNew(@quickcheck.Arbitrary::arbitrary(t, state))
     |     192 => StructNewDefault(@quickcheck.Arbitrary::arbitrary(t, state))
     |     193 =>
     |       StructGet(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     194 =>
     |       StructGetS(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     195 =>
     |       StructGetU(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     196 =>
     |       StructSet(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     197 => ArrayNew(@quickcheck.Arbitrary::arbitrary(t, state))
     |     198 => ArrayNewDefault(@quickcheck.Arbitrary::arbitrary(t, state))
     |     199 =>
     |       ArrayNewFixed(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     200 =>
     |       ArrayNewData(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     201 =>
     |       ArrayNewElem(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     202 => ArrayGet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     203 => ArrayGetS(@quickcheck.Arbitrary::arbitrary(t, state))
     |     204 => ArrayGetU(@quickcheck.Arbitrary::arbitrary(t, state))
     |     205 => ArraySet(@quickcheck.Arbitrary::arbitrary(t, state))
     |     206 => ArrayLen
     |     207 => ArrayFill(@quickcheck.Arbitrary::arbitrary(t, state))
     |     208 =>
     |       ArrayCopy(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     209 =>
     |       ArrayInitData(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     210 =>
     |       ArrayInitElem(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     211 =>
     |       RefTest(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     212 =>
     |       RefCast(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     213 =>
     |       BrOnCast(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     214 =>
     |       BrOnCastFail(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     215 => AnyConvertExtern
     |     216 => ExternConvertAny
     |     217 => RefI31
     |     218 => I31GetS
     |     219 => I31GetU
     |     220 => I32TruncSatF32S
     |     221 => I32TruncSatF32U
     |     222 => I32TruncSatF64S
     |     223 => I32TruncSatF64U
     |     224 => I64TruncSatF32S
     |     225 => I64TruncSatF32U
     |     226 => I64TruncSatF64S
     |     227 => I64TruncSatF64U
     |     228 =>
     |       MemoryInit(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     229 => DataDrop(@quickcheck.Arbitrary::arbitrary(t, state))
     |     230 =>
     |       MemoryCopy(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     231 => MemoryFill(@quickcheck.Arbitrary::arbitrary(t, state))
     |     232 =>
     |       TableInit(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     233 => ElemDrop(@quickcheck.Arbitrary::arbitrary(t, state))
     |     234 =>
     |       TableCopy(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     235 => TableGrow(@quickcheck.Arbitrary::arbitrary(t, state))
     |     236 => TableSize(@quickcheck.Arbitrary::arbitrary(t, state))
     |     237 => TableFill(@quickcheck.Arbitrary::arbitrary(t, state))
     |     238 => V128Load(@quickcheck.Arbitrary::arbitrary(t, state))
     |     239 => V128Load8x8S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     240 => V128Load8x8U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     241 => V128Load16x4S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     242 => V128Load16x4U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     243 => V128Load32x2S(@quickcheck.Arbitrary::arbitrary(t, state))
     |     244 => V128Load32x2U(@quickcheck.Arbitrary::arbitrary(t, state))
     |     245 => V128Load8Splat(@quickcheck.Arbitrary::arbitrary(t, state))
     |     246 => V128Load16Splat(@quickcheck.Arbitrary::arbitrary(t, state))
     |     247 => V128Load32Splat(@quickcheck.Arbitrary::arbitrary(t, state))
     |     248 => V128Load64Splat(@quickcheck.Arbitrary::arbitrary(t, state))
     |     249 => V128Store(@quickcheck.Arbitrary::arbitrary(t, state))
     |     250 =>
     |       V128Const(
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |         (state.next_uint() % 256).to_byte(),
     |       )
     |     251 =>
     |       I8x16Shuffle(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     252 => I8x16Swizzle
     |     253 => I8x16Splat
     |     254 => I16x8Splat
     |     255 => I32x4Splat
     |     256 => I64x2Splat
     |     257 => F32x4Splat
     |     258 => F64x2Splat
     |     259 => I8x16ExtractLaneS(@quickcheck.Arbitrary::arbitrary(t, state))
     |     260 => I8x16ExtractLaneU(@quickcheck.Arbitrary::arbitrary(t, state))
     |     261 => I8x16ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     262 => I16x8ExtractLaneS(@quickcheck.Arbitrary::arbitrary(t, state))
     |     263 => I16x8ExtractLaneU(@quickcheck.Arbitrary::arbitrary(t, state))
     |     264 => I16x8ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     265 => I32x4ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     266 => I32x4ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     267 => I64x2ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     268 => I64x2ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     269 => F32x4ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     270 => F32x4ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     271 => F64x2ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     272 => F64x2ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))
     |     273 => I8x16Eq
     |     274 => I8x16Ne
     |     275 => I8x16LtS
     |     276 => I8x16LtU
     |     277 => I8x16GtS
     |     278 => I8x16GtU
     |     279 => I8x16LeS
     |     280 => I8x16LeU
     |     281 => I8x16GeS
     |     282 => I8x16GeU
     |     283 => I16x8Eq
     |     284 => I16x8Ne
     |     285 => I16x8LtS
     |     286 => I16x8LtU
     |     287 => I16x8GtS
     |     288 => I16x8GtU
     |     289 => I16x8LeS
     |     290 => I16x8LeU
     |     291 => I16x8GeS
     |     292 => I16x8GeU
     |     293 => I32x4Eq
     |     294 => I32x4Ne
     |     295 => I32x4LtS
     |     296 => I32x4LtU
     |     297 => I32x4GtS
     |     298 => I32x4GtU
     |     299 => I32x4LeS
     |     300 => I32x4LeU
     |     301 => I32x4GeS
     |     302 => I32x4GeU
     |     303 => F32x4Eq
     |     304 => F32x4Ne
     |     305 => F32x4Lt
     |     306 => F32x4Gt
     |     307 => F32x4Le
     |     308 => F32x4Ge
     |     309 => F64x2Eq
     |     310 => F64x2Ne
     |     311 => F64x2Lt
     |     312 => F64x2Gt
     |     313 => F64x2Le
     |     314 => F64x2Ge
     |     315 => V128Not
     |     316 => V128And
     |     317 => V128Andnot
     |     318 => V128Or
     |     319 => V128Xor
     |     320 => V128Bitselect
     |     321 => V128AnyTrue
     |     322 =>
     |       V128Load8Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     323 =>
     |       V128Load16Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     324 =>
     |       V128Load32Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     325 =>
     |       V128Load64Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     326 =>
     |       V128Store8Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     327 =>
     |       V128Store16Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     328 =>
     |       V128Store32Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     329 =>
     |       V128Store64Lane(
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |         @quickcheck.Arbitrary::arbitrary(t, state),
     |       )
     |     330 => V128Load32Zero(@quickcheck.Arbitrary::arbitrary(t, state))
     |     331 => V128Load64Zero(@quickcheck.Arbitrary::arbitrary(t, state))
     |     332 => F32x4DemoteF64x2Zero
     |     333 => F64x2PromoteLowF32x4
     |     334 => I8x16Abs
     |     335 => I8x16Neg
     |     336 => I8x16Popcnt
     |     337 => I8x16AllTrue
     |     338 => I8x16Bitmask
     |     339 => I8x16NarrowI16x8S
     |     340 => I8x16NarrowI16x8U
     |     341 => F32x4Ceil
     |     342 => F32x4Floor
     |     343 => F32x4Trunc
     |     344 => F32x4Nearest
     |     345 => I8x16Shl
     |     346 => I8x16ShrS
     |     347 => I8x16ShrU
     |     348 => I8x16Add
     |     349 => I8x16AddSatS
     |     350 => I8x16AddSatU
     |     351 => I8x16Sub
     |     352 => I8x16SubSatS
     |     353 => I8x16SubSatU
     |     354 => F64x2Ceil
     |     355 => F64x2Floor
     |     356 => I8x16MinS
     |     357 => I8x16MinU
     |     358 => I8x16MaxS
     |     359 => I8x16MaxU
     |     360 => F64x2Trunc
     |     361 => I8x16AvgrU
     |     362 => I16x8ExtaddPairwiseI8x16S
     |     363 => I16x8ExtaddPairwiseI8x16U
     |     364 => I32x4ExtaddPairwiseI16x8S
     |     365 => I32x4ExtaddPairwiseI16x8U
     |     366 => I16x8Abs
     |     367 => I16x8Neg
     |     368 => I16x8Q15mulrSatS
     |     369 => I16x8AllTrue
     |     370 => I16x8Bitmask
     |     371 => I16x8NarrowI32x4S
     |     372 => I16x8NarrowI32x4U
     |     373 => I16x8ExtendLowI8x16S
     |     374 => I16x8ExtendHighI8x16S
     |     375 => I16x8ExtendLowI8x16U
     |     376 => I16x8ExtendHighI8x16U
     |     377 => I16x8Shl
     |     378 => I16x8ShrS
     |     379 => I16x8ShrU
     |     380 => I16x8Add
     |     381 => I16x8AddSatS
     |     382 => I16x8AddSatU
     |     383 => I16x8Sub
     |     384 => I16x8SubSatS
     |     385 => I16x8SubSatU
     |     386 => F64x2Nearest
     |     387 => I16x8Mul
     |     388 => I16x8MinS
     |     389 => I16x8MinU
     |     390 => I16x8MaxS
     |     391 => I16x8MaxU
     |     392 => I16x8AvgrU
     |     393 => I16x8ExtmulLowI8x16S
     |     394 => I16x8ExtmulHighI8x16S
     |     395 => I16x8ExtmulLowI8x16U
     |     396 => I16x8ExtmulHighI8x16U
     |     397 => I32x4Abs
     |     398 => I32x4Neg
     |     399 => I32x4AllTrue
     |     400 => I32x4Bitmask
     |     401 => I32x4ExtendLowI16x8S
     |     402 => I32x4ExtendHighI16x8S
     |     403 => I32x4ExtendLowI16x8U
     |     404 => I32x4ExtendHighI16x8U
     |     405 => I32x4Shl
     |     406 => I32x4ShrS
     |     407 => I32x4ShrU
     |     408 => I32x4Add
     |     409 => I32x4Sub
     |     410 => I32x4Mul
     |     411 => I32x4MinS
     |     412 => I32x4MinU
     |     413 => I32x4MaxS
     |     414 => I32x4MaxU
     |     415 => I32x4DotI16x8S
     |     416 => I32x4ExtmulLowI16x8S
     |     417 => I32x4ExtmulHighI16x8S
     |     418 => I32x4ExtmulLowI16x8U
     |     419 => I32x4ExtmulHighI16x8U
     |     420 => I64x2Abs
     |     421 => I64x2Neg
     |     422 => I64x2AllTrue
     |     423 => I64x2Bitmask
     |     424 => I64x2ExtendLowI32x4S
     |     425 => I64x2ExtendHighI32x4S
     |     426 => I64x2ExtendLowI32x4U
     |     427 => I64x2ExtendHighI32x4U
     |     428 => I64x2Shl
     |     429 => I64x2ShrS
     |     430 => I64x2ShrU
     |     431 => I64x2Add
     |     432 => I64x2Sub
     |     433 => I64x2Mul
     |     434 => I64x2Eq
     |     435 => I64x2Ne
     |     436 => I64x2LtS
     |     437 => I64x2GtS
     |     438 => I64x2LeS
     |     439 => I64x2GeS
     |     440 => I64x2ExtmulLowI32x4S
     |     441 => I64x2ExtmulHighI32x4S
     |     442 => I64x2ExtmulLowI32x4U
     |     443 => I64x2ExtmulHighI32x4U
     |     444 => F32x4Abs
     |     445 => F32x4Neg
     |     446 => F32x4Sqrt
     |     447 => F32x4Add
     |     448 => F32x4Sub
     |     449 => F32x4Mul
     |     450 => F32x4Div
     |     451 => F32x4Min
     |     452 => F32x4Max
     |     453 => F32x4Pmin
     |     454 => F32x4Pmax
     |     455 => F64x2Abs
     |     456 => F64x2Neg
     |     457 => F64x2Sqrt
     |     458 => F64x2Add
     |     459 => F64x2Sub
     |     460 => F64x2Mul
     |     461 => F64x2Div
     |     462 => F64x2Min
     |     463 => F64x2Max
     |     464 => F64x2Pmin
     |     465 => F64x2Pmax
     |     466 => I32x4TruncSatF32x4S
     |     467 => I32x4TruncSatF32x4U
     |     468 => F32x4ConvertI32x4S
     |     469 => F32x4ConvertI32x4U
     |     470 => I32x4TruncSatF64x2SZero
     |     471 => I32x4TruncSatF64x2UZero
     |     472 => F64x2ConvertLowI32x4S
     |     473 => F64x2ConvertLowI32x4U
     |     474 => I8x16RelaxedSwizzle
     |     475 => I32x4RelaxedTruncF32x4S
     |     476 => I32x4RelaxedTruncF32x4U
     |     477 => I32x4RelaxedTruncZeroF64x2S
     |     478 => I32x4RelaxedTruncZeroF64x2U
     |     479 => F32x4RelaxedMadd
     |     480 => F32x4RelaxedNmadd
     |     481 => F64x2RelaxedMadd
     |     482 => F64x2RelaxedNmadd
     |     483 => I8x16RelaxedLaneselect
     |     484 => I16x8RelaxedLaneselect
     |     485 => I32x4RelaxedLaneselect
     |     486 => I64x2RelaxedLaneselect
     |     487 => F32x4RelaxedMin
     |     488 => F32x4RelaxedMax
     |     489 => F64x2RelaxedMin
     |     490 => F64x2RelaxedMax
     |     491 => I16x8RelaxedQ15mulrS
     |     492 => I16x8RelaxedDotI8x16I7x16S
     |     493 => I32x4RelaxedDotI8x16I7x16AddS
1643 |     _ => Nop
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

3 uncovered line(s) in src/lib/eq.mbt:

    | pub impl Eq for Module with equal(l, r) {
    |   let l_custom = l.custom_secs
    |   let r_custom = r.custom_secs
    |   if l_custom.length() != r_custom.length() {
  6 |     return false
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   for lc in l_custom {
    |     if !r_custom.contains(lc) {
 10 |       return false
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   for rc in r_custom {
    |     if !l_custom.contains(rc) {
 15 |       return false
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   l.type_sec == r.type_sec &&
    |   l.import_sec == r.import_sec &&
    |   l.func_sec == r.func_sec &&
    |   l.table_sec == r.table_sec &&
    |   l.mem_sec == r.mem_sec &&
    |   l.tag_sec == r.tag_sec &&
    |   l.global_sec == r.global_sec &&
    |   l.export_sec == r.export_sec &&
    |   l.start_sec == r.start_sec &&
    |   l.elem_sec == r.elem_sec &&
    |   l.data_cnt_sec == r.data_cnt_sec &&
    |   l.code_sec == r.code_sec &&
    |   l.data_sec == r.data_sec
    | }
    …

7 uncovered line(s) in src/lib/pretty_print.mbt:

    | pub fn TabsOrSpaces::spaces() -> TabsOrSpaces {
 14 |   Spaces
    |   ^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn wrap_line(line : String, ctx : PrettyPrintContext) -> String {
    |   let max_width = ctx.max_line_width.reinterpret_as_int()
    |   if max_width == 0 || line.length() <= max_width {
    |     return line
    |   }
    | 
    |   let mut leading = 0
    |   while leading < line.length() {
    |     let c = line[leading]
    |     if c == ' ' || c == '\t' {
 80 |       leading += 1
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       break
    |     }
    |   }
    |   let prefix = line.sub(end=leading).to_string() catch { _ => "" }
    |   let body = line.sub(start=leading).to_string() catch { _ => line }
    |   if body.length() == 0 {
 88 |     return line
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   let words = body.split(" ")
    |   let out = StringBuilder::new()
    |   let continuation_prefix = prefix + ctx.indent(ctx.continuation_indent)
    |   let mut current_prefix = prefix
    |   out.write_string(current_prefix)
    |   let mut current_width = current_prefix.length()
    |   let mut has_word = false
    | 
    |   for word_view in words {
    |     let word = word_view.to_string()
    |     if word.length() == 0 {
102 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let word_width = word.length()
    |     let needs_space = has_word
    |     let mut next_width = current_width + word_width
    |     if needs_space {
    |       next_width += 1
    |     }
    |     if needs_space && next_width > max_width {
    |       out.write_char('\n')
    |       current_prefix = continuation_prefix
    |       out.write_string(current_prefix)
    |       current_width = current_prefix.length()
    |       has_word = false
    |     }
    |     if has_word {
118 |       out.write_char(' ')
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       current_width += 1
    |     }
    |     out.write_string(word)
    |     current_width += word_width
    |     has_word = true
    |   }
    | 
    |   out.to_string()
    | }
    …

    | fn normalize_indent(line : String, ctx : PrettyPrintContext) -> String {
    |   let mut leading = 0
    |   let mut spaces = 0
    |   let mut tabs = 0
    |   while leading < line.length() {
    |     let c = line[leading]
    |     if c == ' ' {
    |       spaces += 1
    |       leading += 1
    |     } else if c == '\t' {
140 |       tabs += 1
    |       ^^^^^^^^^ 	<-- UNCOVERED
    |       leading += 1
    |     } else {
    |       break
    |     }
    |   }
    |   if leading == 0 {
    |     return line
    |   }
    |   let source_unit = if ctx.source_indent_width == 0U {
150 |     1
    |     ^ 	<-- UNCOVERED
    |   } else {
    |     ctx.source_indent_width.reinterpret_as_int()
    |   }
    |   let levels = tabs + spaces / source_unit
    |   let content = line.sub(start=leading).to_string() catch { _ => line }
    |   ctx.indent(levels.reinterpret_as_uint()) + content
    | }
    …

82 uncovered line(s) in src/lib/pretty_print_impls.mbt:

    | pub impl PrettyPrint for AbsHeapType with pretty_print(self, ctx) {
  8 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for BinaryOp with pretty_print(self, ctx) {
 13 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for BlockType with pretty_print(self, ctx) {
 18 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for CastOp with pretty_print(self, ctx) {
 23 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Catch with pretty_print(self, ctx) {
 28 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for CodeSec with pretty_print(self, ctx) {
 33 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for CompType with pretty_print(self, ctx) {
 38 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for CustomSec with pretty_print(self, ctx) {
 43 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Data with pretty_print(self, ctx) {
 48 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for DataCntSec with pretty_print(self, ctx) {
 53 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for DataIdx with pretty_print(self, ctx) {
 58 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for DataMode with pretty_print(self, ctx) {
 63 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for DataSec with pretty_print(self, ctx) {
 68 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for DefType with pretty_print(self, ctx) {
 73 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Elem with pretty_print(self, ctx) {
 78 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ElemIdx with pretty_print(self, ctx) {
 83 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ElemKind with pretty_print(self, ctx) {
 88 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ElemMode with pretty_print(self, ctx) {
 93 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ElemSec with pretty_print(self, ctx) {
 98 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Export with pretty_print(self, ctx) {
103 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ExportSec with pretty_print(self, ctx) {
108 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ExternIdx with pretty_print(self, ctx) {
118 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ExternType with pretty_print(self, ctx) {
123 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ExtractLaneOp with pretty_print(self, ctx) {
128 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for F32 with pretty_print(self, ctx) {
133 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for F64 with pretty_print(self, ctx) {
138 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for FieldType with pretty_print(self, ctx) {
143 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Func with pretty_print(self, ctx) {
148 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for FuncIdx with pretty_print(self, ctx) {
153 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for FuncSec with pretty_print(self, ctx) {
158 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for FuncType with pretty_print(self, ctx) {
163 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Global with pretty_print(self, ctx) {
168 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for GlobalIdx with pretty_print(self, ctx) {
173 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for GlobalSec with pretty_print(self, ctx) {
178 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for GlobalType with pretty_print(self, ctx) {
183 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for HeapType with pretty_print(self, ctx) {
188 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for I32 with pretty_print(self, ctx) {
193 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for I64 with pretty_print(self, ctx) {
198 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Import with pretty_print(self, ctx) {
203 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ImportSec with pretty_print(self, ctx) {
208 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Instruction with pretty_print(self, ctx) {
213 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for LabelIdx with pretty_print(self, ctx) {
218 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for LaneIdx with pretty_print(self, ctx) {
223 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Limits with pretty_print(self, ctx) {
228 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for LoadOp with pretty_print(self, ctx) {
233 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for LocalIdx with pretty_print(self, ctx) {
238 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Locals with pretty_print(self, ctx) {
243 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for MemArg with pretty_print(self, ctx) {
248 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for MemIdx with pretty_print(self, ctx) {
253 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for MemSec with pretty_print(self, ctx) {
258 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for MemType with pretty_print(self, ctx) {
263 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Module with pretty_print(self, ctx) {
268 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Mut with pretty_print(self, ctx) {
273 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Name with pretty_print(self, ctx) {
278 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for PackType with pretty_print(self, ctx) {
288 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for RecType with pretty_print(self, ctx) {
293 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for RefType with pretty_print(self, ctx) {
298 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ReplaceLaneOp with pretty_print(self, ctx) {
303 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for S33 with pretty_print(self, ctx) {
308 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for StartSec with pretty_print(self, ctx) {
313 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for StorageType with pretty_print(self, ctx) {
318 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for StoreOp with pretty_print(self, ctx) {
323 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for SubType with pretty_print(self, ctx) {
328 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TExpr with pretty_print(self, ctx) {
333 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TInstr with pretty_print(self, ctx) {
338 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Table with pretty_print(self, ctx) {
343 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TableIdx with pretty_print(self, ctx) {
348 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TableSec with pretty_print(self, ctx) {
353 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TableType with pretty_print(self, ctx) {
358 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TagIdx with pretty_print(self, ctx) {
363 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TagSec with pretty_print(self, ctx) {
368 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TagType with pretty_print(self, ctx) {
373 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TypeIdx with pretty_print(self, ctx) {
378 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TypeSec with pretty_print(self, ctx) {
383 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for U32 with pretty_print(self, ctx) {
388 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for U64 with pretty_print(self, ctx) {
393 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for UnaryOp with pretty_print(self, ctx) {
398 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for V128LoadLaneOp with pretty_print(self, ctx) {
403 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for V128ShiftOp with pretty_print(self, ctx) {
408 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for V128StoreLaneOp with pretty_print(self, ctx) {
413 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for V128TernaryOp with pretty_print(self, ctx) {
418 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ValType with pretty_print(self, ctx) {
423 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

277 uncovered line(s) in src/lib/show.mbt:

     | pub impl Show for S33 with output(self, logger) {
   3 |   let S33(t) = self
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("S33(")
     |   t.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for I64 with output(self, logger) {
  19 |   let I64(t) = self
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("I64(")
     |   t.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for AbsHeapType with output(self, logger) {
  69 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ExnAbsHeapType => logger.write_string("(AbsHeapType Exn)")
     |     ArrayAbsHeapType => logger.write_string("(AbsHeapType Array)")
     |     StructAbsHeapType => logger.write_string("(AbsHeapType Struct)")
     |     I31AbsHeapType => logger.write_string("(AbsHeapType I31)")
     |     EqAbsHeapType => logger.write_string("(AbsHeapType Eq)")
     |     AnyAbsHeapType => logger.write_string("(AbsHeapType Any)")
     |     ExternAbsHeapType => logger.write_string("(AbsHeapType Extern)")
     |     FuncAbsHeapType => logger.write_string("(AbsHeapType Func)")
     |     NoneAbsHeapType => logger.write_string("(AbsHeapType None)")
     |     NoExternAbsHeapType => logger.write_string("(AbsHeapType NoExtern)")
     |     NoFuncAbsHeapType => logger.write_string("(AbsHeapType NoFunc)")
     |     NoExnAbsHeapType => logger.write_string("(AbsHeapType NoExn)")
     |   }
     | }
     …

     | pub impl Show for HeapType with output(self, logger) {
  87 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AbsHeapTypeHeapType(ht) => {
     |       logger.write_string("(HeapType ")
     |       ht.output(logger)
     |       logger.write_char(')')
     |     }
  93 |     HeapType(TypeIdx(t)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(HeapType Idx ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
  98 |     HeapType(RecIdx(t)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(HeapType Rec ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
 103 |     DefTypeHeapType(d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(HeapType ")
     |       d.output(logger)
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for DefType with output(self, logger) {
 113 |   logger.write_string("(DefType ")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   self.0.output(logger)
     |   logger.write_char(' ')
     |   self.1.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for RefType with output(self, logger) {
 122 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     HeapTypeRefType(n, ht) => {
     |       logger.write_string("(RefType ")
     |       if !n {
 126 |         logger.write_string("Not ")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 128 |       logger.write_string("Null ")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ht.output(logger)
     |       logger.write_char(')')
     |     }
 132 |     AbsHeapTypeRefType(aht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(RefType Null ")
     |       aht.output(logger)
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for ValType with output(self, logger) {
     |   match self {
 143 |     VecTypeValType => logger.write_string("(V128)")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     NumTypeValType(nt) => nt.output(logger)
 145 |     RefTypeValType(rt) => rt.output(logger)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BotValType => logger.write_string("(Bot)")
     |   }
     | }
     …

     | pub impl Show for PackType with output(self, logger) {
 152 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16PackType => logger.write_string("(I16)")
     |     I8PackType => logger.write_string("(I8)")
     |   }
     | }
     …

     | pub impl Show for StorageType with output(self, logger) {
 160 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ValTypeStorageType(vt) => vt.output(logger)
     |     PackTypeStorageType(pt) => pt.output(logger)
     |   }
     | }
     …

     | pub impl Show for FieldType with output(self, logger) {
 168 |   let FieldType(st, m) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Field ")
     |   m.output(logger)
     |   logger.write_char(' ')
     |   st.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for Mut with output(self, logger) {
     |   match self {
 179 |     Var => logger.write_string("Mut")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Const => logger.write_string("Const")
     |   }
     | }
     …

     | pub impl Show for TypeIdx with output(self, logger) {
     |   match self {
     |     TypeIdx(val) => {
     |       logger.write_string("(Type ")
     |       val.output(logger)
     |       logger.write_char(')')
     |     }
 192 |     RecIdx(i) => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Rec ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for MemIdx with output(self, logger) {
 218 |   let MemIdx(val) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Mem ")
     |   val.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for TagIdx with output(self, logger) {
 234 |   let TagIdx(val) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Tag ")
     |   val.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for ElemIdx with output(self, logger) {
 242 |   let ElemIdx(val) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Elem ")
     |   val.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for DataIdx with output(self, logger) {
 250 |   let DataIdx(val) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Data ")
     |   val.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for LaneIdx with output(self, logger) {
 274 |   let LaneIdx(val) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Lane ")
     |   val.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for CompType with output(self, logger) {
     |   match self {
 283 |     StructCompType(st) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Struct ")
     |       for f in st {
 286 |         f.output(logger)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
 289 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 291 |     ArrayCompType(at) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Array ")
     |       at.output(logger)
     |       logger.write_char(')')
     |     }
     |     FuncCompType(p, r) => {
     |       logger.write_string("(Func (Props ")
     |       match p {
     |         [] => logger.write_string("(Void)")
     |         _ =>
     |           for pm in p {
     |             pm.output(logger)
     |             logger.write_char(' ')
     |           }
     |       }
     |       logger.write_string(") (Ret ")
     |       match r {
     |         [] => logger.write_string("(Void)")
     |         _ =>
     |           for pm in r {
     |             pm.output(logger)
     |             logger.write_char(' ')
     |           }
     |       }
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for SubType with output(self, logger) {
     |   match self {
 323 |     SubType(f, sts, ct) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Sub ")
     |       if f {
 326 |         logger.write_string("Final ")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for st in sts {
 329 |         st.output(logger)
     |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
 332 |       ct.output(logger)
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_char(')')
     |     }
     |     CompTypeSubType(ct) => {
     |       logger.write_string("(Sub Final ")
     |       ct.output(logger)
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for RecType with output(self, logger) {
     |   match self {
     |     SingleRecType(st) => {
     |       logger.write_string("(Rec ")
     |       st.output(logger)
     |       logger.write_char(')')
     |     }
 351 |     GroupRecType(sts) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Rec ")
     |       for st in sts {
 354 |         st.output(logger)
     |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
 357 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | pub impl Show for Limits with output(self, logger) {
     |   match self {
     |     I32Limits(min, max) => {
     |       logger.write_string("(Lim I32 ")
     |       min.output(logger)
     |       if max is Some(max) {
 369 |         logger.write_char(' ')
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         max.output(logger)
     |       }
     |       logger.write_char(')')
     |     }
 374 |     I64Limits(min, max) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Lim I64 ")
     |       min.output(logger)
     |       if max is Some(max) {
 378 |         logger.write_char(' ')
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         max.output(logger)
     |       }
 381 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | pub impl Show for TagType with output(self, logger) {
 388 |   let TagType(t) = self
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   t.output(logger)
     | }
     …

     | pub impl Show for TableType with output(self, logger) {
 411 |   let TableType(rt, l) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(TableType ")
     |   rt.output(logger)
     |   logger.write_char(' ')
     |   l.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for ExternType with output(self, logger) {
 421 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     GlobalExternType(gt) => gt.output(logger)
     |     MemExternType(mt) => mt.output(logger)
     |     TableExternType(tt) => tt.output(logger)
     |     FuncExternType(t) => t.output(logger)
     |     TagExternType(t) => t.output(logger)
     |   }
     | }
     …

     | pub impl Show for ExternIdx with output(self, logger) {
 432 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     GlobalExternIdx(g) => g.output(logger)
     |     MemExternIdx(m) => m.output(logger)
     |     TableExternIdx(t) => t.output(logger)
     |     FuncExternIdx(f) => f.output(logger)
     |     TagExternIdx(t) => t.output(logger)
     |   }
     | }
     …

     | pub impl Show for ElemMode with output(self, logger) {
 443 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Active(t, e) => {
     |       logger.write_string("(Active ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       e.output(logger)
     |       logger.write_char(')')
     |     }
 451 |     Passive => logger.write_string("Passive")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Declarative => logger.write_string("Declarative")
     |   }
     | }
     …

     | pub impl Show for ElemKind with output(self, logger) {
 458 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     FuncExprsElemKind(exprs) => {
     |       logger.write_string("(Funcs ")
     |       for expr in exprs {
 462 |         expr.output(logger)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
 465 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 467 |     FuncsElemKind(idxs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Funcs Indexes ")
     |       for idx in idxs {
 470 |         idx.output(logger)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
 473 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 475 |     TypedExprsElemKind(rt, exprs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Exprs ")
     |       rt.output(logger)
     |       logger.write_char(' ')
     |       for expr in exprs {
 480 |         expr.output(logger)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 482 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | pub impl Show for Elem with output(self, logger) {
 489 |   let Elem(m, k) = self
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Elem ")
     |   m.output(logger)
     |   logger.write_char(' ')
     |   k.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for Import with output(self, logger) {
 508 |   let Import(ns, n, et) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_char('(')
     |   ns.output(logger)
     |   logger.write_char(' ')
     |   n.output(logger)
     |   logger.write_char(' ')
     |   et.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for Table with output(self, logger) {
 520 |   let Table(tt, e) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Table ")
     |   tt.output(logger)
     |   if e is Some(e) {
 524 |     logger.write_char(' ')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     e.output(logger)
     |   }
 527 |   logger.write_char(')')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for Export with output(self, logger) {
 542 |   let Export(n, idx) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Export ")
     |   n.output(logger)
     |   logger.write_char(' ')
     |   idx.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for Locals with output(self, logger) {
 552 |   let Locals(i, vt) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   loop i {
     |     0 => break
     |     n => {
     |       vt.output(logger)
     |       logger.write_char(' ')
     |       continue n - 1
     |     }
     |   }
     | }
     …

     | pub impl Show for Func with output(self, logger) {
     |   match self {
 566 |     Func(ls, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(Func ")
     |       ls.output(logger)
     |       logger.write_char(' ')
     |       expr.output(logger)
     |       logger.write_char(')')
     |     }
     |     TFunc(ls, texpr) => {
     |       logger.write_string("(Func ")
     |       ls.output(logger)
     |       logger.write_char(' ')
     |       texpr.output(logger)
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for DataMode with output(self, logger) {
 585 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Active(m, e) => {
     |       logger.write_string("(Active ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       e.output(logger)
     |       logger.write_char(')')
     |     }
 593 |     Passive => logger.write_string("Passive")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Show for Data with output(self, logger) {
 599 |   let Data(dm, b) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("(Data ")
     |   dm.output(logger)
     |   logger.write_char(' ')
     |   b.output(logger)
     |   logger.write_char(')')
     | }
     …

     | pub impl Show for Name with output(self, logger) {
 609 |   let Name(sv) = self
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_char('"')
     |   sv.to_string().output(logger)
     |   logger.write_char('"')
     | }
     …

     | pub impl Show for BlockType with output(self, logger) {
     |   match self {
     |     ValTypeBlockType(vt) => vt.output(logger)
     |     VoidBlockType => logger.write_string("(Void)")
 620 |     TypeIdxBlockType(t) => t.output(logger)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Show for Catch with output(self, logger) {
 626 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CatchAll(l) => {
     |       logger.write_string("(catch_all ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 632 |     CatchRef(t, l) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(catch_ref ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 639 |     Catch(t, l) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(catch ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 646 |     CatchAllRef(l) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(catch_all_ref ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
     |   }
     | }
     …

     | pub impl Show for MemArg with output(self, logger) {
     |   let MemArg(a, m, o) = self
     |   logger.write_string("align=")
     |   a.output(logger)
     |   if m is Some(m) {
 660 |     logger.write_string(" mem=")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     m.output(logger)
     |   }
     |   logger.write_string(" offset=")
     |   o.output(logger)
     | }
     …

     | pub impl Show for Instruction with output(self, logger) {
     |   match self {
 670 |     Unreachable => logger.write_string("unreachable")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Nop => logger.write_string("nop")
     |     Block(bt, expr) => {
     |       logger.write_string("(block ")
     |       bt.output(logger)
     |       logger.write_char(' ')
     |       expr.output(logger)
     |       logger.write_char(')')
     |     }
 679 |     Loop(bt, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(loop ")
     |       bt.output(logger)
     |       logger.write_char(' ')
     |       expr.output(logger)
     |       logger.write_char(')')
     |     }
 686 |     If(bt, i, e) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(if ")
     |       bt.output(logger)
     |       logger.write_char(' ')
     |       for n in i {
 691 |         n.output(logger)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
     |       if e is Some(e) {
 695 |         logger.write_string("else ")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for n in e {
 697 |           n.output(logger)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           logger.write_char(' ')
     |         }
 700 |         logger.write_char(')')
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 703 |     Throw(t) => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(throw ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
 708 |     ThrowRef => logger.write_string("throw_ref")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Br(l) => {
     |       logger.write_string("(br ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 714 |     BrIf(l) => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(br_if ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 719 |     BrTable(ls, l) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(br_table ")
     |       for n in ls {
 722 |         n.output(logger)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         logger.write_char(' ')
     |       }
 725 |       l.output(logger)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_char(')')
     |     }
 728 |     Return => logger.write_string("return")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Call(f) => {
     |       logger.write_string("(call ")
     |       f.output(logger)
     |       logger.write_char(')')
     |     }
 734 |     CallIndirect(ty, tbl) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(call_indirect ")
     |       ty.output(logger)
     |       logger.write_char(' ')
     |       tbl.output(logger)
     |       logger.write_char(')')
     |     }
 741 |     ReturnCall(f) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(return_call ")
     |       f.output(logger)
     |       logger.write_char(')')
     |     }
 746 |     ReturnCallIndirect(ty, tbl) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(return_call_indirect ")
     |       ty.output(logger)
     |       logger.write_char(' ')
     |       tbl.output(logger)
     |       logger.write_char(')')
     |     }
 753 |     CallRef(t) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(call_ref ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
 758 |     ReturnCallRef(t) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(return_call_ref ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
     |     Drop => logger.write_string("drop")
 764 |     Select(None) => logger.write_string("select")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Select(Some(vts)) => {
     |       logger.write_string("(select")
     |       for vt in vts {
 768 |         logger.write_char(' ')
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         vt.output(logger)
     |       }
 771 |       logger.write_char(')')
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 773 |     TryTable(bt, c, e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(try_table ")
     |       bt.output(logger)
     |       logger.write_char(' ')
     |       c.output(logger)
     |       logger.write_char(' ')
     |       e.output(logger)
     |       logger.write_char(')')
     |     }
 782 |     LocalGet(l) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(local.get ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 787 |     LocalSet(l) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(local.set ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 792 |     LocalTee(l) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(local.tee ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
 797 |     GlobalGet(g) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(global.get ")
     |       g.output(logger)
     |       logger.write_char(')')
     |     }
 802 |     GlobalSet(g) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(global.set ")
     |       g.output(logger)
     |       logger.write_char(')')
     |     }
 807 |     TableGet(t) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.get ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
 812 |     TableSet(t) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.set ")
     |       t.output(logger)
     |       logger.write_char(')')
     |     }
 817 |     I32Load(m) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 822 |     I64Load(m) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 827 |     F32Load(m) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f32.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 832 |     F64Load(m) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f64.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 837 |     I32Load8S(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.load8s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 842 |     I32Load8U(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.load8u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 847 |     I32Load16S(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.load16s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 852 |     I32Load16U(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.load16u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 857 |     I64Load8S(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load8s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 862 |     I64Load8U(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load8u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 867 |     I64Load16S(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load16s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 872 |     I64Load16U(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load16u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 877 |     I64Load32S(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load32s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 882 |     I64Load32U(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.load32u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 887 |     I32Store(m) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 892 |     I64Store(m) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 897 |     F32Store(m) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f32.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 902 |     F64Store(m) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f64.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 907 |     I32Store8(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.store8 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 912 |     I32Store16(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.store16 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 917 |     I64Store8(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.store8 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 922 |     I64Store16(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.store16 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 927 |     I64Store32(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.store32 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 932 |     MemorySize(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.size ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 937 |     MemoryGrow(m) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.grow ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 942 |     MemoryAtomicNotify(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.atomic.notify ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 947 |     MemoryAtomicWait32(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.atomic.wait32 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 952 |     MemoryAtomicWait64(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.atomic.wait64 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 957 |     AtomicFence => logger.write_string("atomic.fence")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AtomicLoad(m) => {
     |       logger.write_string("(i32.atomic.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 963 |     I64AtomicLoad(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 968 |     I32AtomicLoad8U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.atomic.load8_u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 973 |     I32AtomicLoad16U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.atomic.load16_u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 978 |     I64AtomicLoad8U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.load8_u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 983 |     I64AtomicLoad16U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.load16_u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 988 |     I64AtomicLoad32U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.load32_u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 993 |     I32AtomicStore(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.atomic.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
 998 |     I64AtomicStore(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1003 |     I32AtomicStore8(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.atomic.store8 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1008 |     I32AtomicStore16(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32.atomic.store16 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1013 |     I64AtomicStore8(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.store8 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1018 |     I64AtomicStore16(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.store16 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1023 |     I64AtomicStore32(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.atomic.store32 ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1028 |     AtomicRmw(op, m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(atomic.rmw ")
     |       op.output(logger)
     |       logger.write_char(' ')
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1035 |     AtomicCmpxchg(op, m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(atomic.cmpxchg ")
     |       op.output(logger)
     |       logger.write_char(' ')
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
     |     I32Const(c) => {
     |       logger.write_string("(i32.const ")
     |       c.output(logger)
     |       logger.write_char(')')
     |     }
1047 |     I64Const(c) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64.const ")
     |       c.output(logger)
     |       logger.write_char(')')
     |     }
1052 |     F32Const(c) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f32.const ")
     |       c.output(logger)
     |       logger.write_char(')')
     |     }
1057 |     F64Const(c) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f64.const ")
     |       c.output(logger)
     |       logger.write_char(')')
     |     }
1062 |     I32Eqz => logger.write_string("i32.eqz")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Eq => logger.write_string("i32.eq")
     |     I32Ne => logger.write_string("i32.ne")
     |     I32LtS => logger.write_string("i32.lt_s")
     |     I32LtU => logger.write_string("i32.lt_u")
     |     I32GtS => logger.write_string("i32.gt_s")
     |     I32GtU => logger.write_string("i32.gt_u")
     |     I32LeS => logger.write_string("i32.le_s")
     |     I32LeU => logger.write_string("i32.le_u")
     |     I32GeS => logger.write_string("i32.ge_s")
     |     I32GeU => logger.write_string("i32.ge_u")
     |     I64Eqz => logger.write_string("i64.eqz")
     |     I64Eq => logger.write_string("i64.eq")
     |     I64Ne => logger.write_string("i64.ne")
     |     I64LtS => logger.write_string("i64.lt_s")
     |     I64LtU => logger.write_string("i64.lt_u")
     |     I64GtS => logger.write_string("i64.gt_s")
     |     I64GtU => logger.write_string("i64.gt_u")
     |     I64LeS => logger.write_string("i64.le_s")
     |     I64LeU => logger.write_string("i64.le_u")
     |     I64GeS => logger.write_string("i64.ge_s")
     |     I64GeU => logger.write_string("i64.ge_u")
     |     F32Eq => logger.write_string("f32.eq")
     |     F32Ne => logger.write_string("f32.ne")
     |     F32Lt => logger.write_string("f32.lt")
     |     F32Gt => logger.write_string("f32.gt")
     |     F32Le => logger.write_string("f32.le")
     |     F32Ge => logger.write_string("f32.ge")
     |     F64Eq => logger.write_string("f64.eq")
     |     F64Ne => logger.write_string("f64.ne")
     |     F64Lt => logger.write_string("f64.lt")
     |     F64Gt => logger.write_string("f64.gt")
     |     F64Le => logger.write_string("f64.le")
     |     F64Ge => logger.write_string("f64.ge")
     |     I32Clz => logger.write_string("i32.clz")
     |     I32Ctz => logger.write_string("i32.ctz")
     |     I32Popcnt => logger.write_string("i32.popcnt")
     |     I32Add => logger.write_string("i32.add")
1100 |     I32Sub => logger.write_string("i32.sub")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Mul => logger.write_string("i32.mul")
     |     I32DivS => logger.write_string("i32.div_s")
     |     I32DivU => logger.write_string("i32.div_u")
     |     I32RemS => logger.write_string("i32.rem_s")
     |     I32RemU => logger.write_string("i32.rem_u")
     |     I32And => logger.write_string("i32.and")
     |     I32Or => logger.write_string("i32.or")
     |     I32Xor => logger.write_string("i32.xor")
     |     I32Shl => logger.write_string("i32.shl")
     |     I32ShrS => logger.write_string("i32.shr_s")
     |     I32ShrU => logger.write_string("i32.shr_u")
     |     I32Rotl => logger.write_string("i32.rotl")
     |     I32Rotr => logger.write_string("i32.rotr")
     |     I64Clz => logger.write_string("i64.clz")
     |     I64Ctz => logger.write_string("i64.ctz")
     |     I64Popcnt => logger.write_string("i64.popcnt")
     |     I64Add => logger.write_string("i64.add")
     |     I64Sub => logger.write_string("i64.sub")
     |     I64Mul => logger.write_string("i64.mul")
     |     I64DivS => logger.write_string("i64.div_s")
     |     I64DivU => logger.write_string("i64.div_u")
     |     I64RemS => logger.write_string("i64.rem_s")
     |     I64RemU => logger.write_string("i64.rem_u")
     |     I64And => logger.write_string("i64.and")
     |     I64Or => logger.write_string("i64.or")
     |     I64Xor => logger.write_string("i64.xor")
     |     I64Shl => logger.write_string("i64.shl")
     |     I64ShrS => logger.write_string("i64.shr_s")
     |     I64ShrU => logger.write_string("i64.shr_u")
     |     I64Rotl => logger.write_string("i64.rotl")
     |     I64Rotr => logger.write_string("i64.rotr")
     |     F32Abs => logger.write_string("f32.abs")
     |     F32Neg => logger.write_string("f32.neg")
     |     F32Ceil => logger.write_string("f32.ceil")
     |     F32Floor => logger.write_string("f32.floor")
     |     F32Trunc => logger.write_string("f32.trunc")
     |     F32Nearest => logger.write_string("f32.nearest")
     |     F32Sqrt => logger.write_string("f32.sqrt")
     |     F32Add => logger.write_string("f32.add")
     |     F32Sub => logger.write_string("f32.sub")
     |     F32Mul => logger.write_string("f32.mul")
     |     F32Div => logger.write_string("f32.div")
     |     F32Min => logger.write_string("f32.min")
     |     F32Max => logger.write_string("f32.max")
     |     F32Copysign => logger.write_string("f32.copysign")
     |     F64Abs => logger.write_string("f64.abs")
     |     F64Neg => logger.write_string("f64.neg")
     |     F64Ceil => logger.write_string("f64.ceil")
     |     F64Floor => logger.write_string("f64.floor")
     |     F64Trunc => logger.write_string("f64.trunc")
     |     F64Nearest => logger.write_string("f64.nearest")
     |     F64Sqrt => logger.write_string("f64.sqrt")
     |     F64Add => logger.write_string("f64.add")
     |     F64Sub => logger.write_string("f64.sub")
     |     F64Mul => logger.write_string("f64.mul")
     |     F64Div => logger.write_string("f64.div")
     |     F64Min => logger.write_string("f64.min")
     |     F64Max => logger.write_string("f64.max")
     |     F64Copysign => logger.write_string("f64.copysign")
     |     I32WrapI64 => logger.write_string("i32.wrap_i64")
     |     I32TruncF32S => logger.write_string("i32.trunc_f32s")
     |     I32TruncF32U => logger.write_string("i32.trunc_f32u")
     |     I32TruncF64S => logger.write_string("i32.trunc_f64s")
     |     I32TruncF64U => logger.write_string("i32.trunc_f64u")
     |     I64ExtendI32S => logger.write_string("i64.extend_i32s")
     |     I64ExtendI32U => logger.write_string("i64.extend_i32u")
     |     I64TruncF32S => logger.write_string("i64.trunc_f32s")
     |     I64TruncF32U => logger.write_string("i64.trunc_f32u")
     |     I64TruncF64S => logger.write_string("i64.trunc_f64s")
     |     I64TruncF64U => logger.write_string("i64.trunc_f64u")
     |     F32ConvertI32S => logger.write_string("f32.convert_i32s")
     |     F32ConvertI32U => logger.write_string("f32.convert_i32u")
     |     F32ConvertI64S => logger.write_string("f32.convert_i64s")
     |     F32ConvertI64U => logger.write_string("f32.convert_i64u")
     |     F32DemoteF64 => logger.write_string("f32.demote_f64")
     |     F64ConvertI32S => logger.write_string("f64.convert_i32s")
     |     F64ConvertI32U => logger.write_string("f64.convert_i32u")
     |     F64ConvertI64S => logger.write_string("f64.convert_i64s")
     |     F64ConvertI64U => logger.write_string("f64.convert_i64u")
     |     F64PromoteF32 => logger.write_string("f64.promote_f32")
     |     I32ReinterpretF32 => logger.write_string("i32.reinterpret_f32")
     |     I64ReinterpretF64 => logger.write_string("i64.reinterpret_f64")
     |     F32ReinterpretI32 => logger.write_string("f32.reinterpret_i32")
     |     F64ReinterpretI64 => logger.write_string("f64.reinterpret_i64")
     |     I32Extend8S => logger.write_string("i32.extend8s")
     |     I32Extend16S => logger.write_string("i32.extend16s")
     |     I64Extend8S => logger.write_string("i64.extend8s")
     |     I64Extend16S => logger.write_string("i64.extend16s")
     |     I64Extend32S => logger.write_string("i64.extend32s")
     |     RefNull(ht) => {
     |       logger.write_string("(ref.null ")
     |       ht.output(logger)
     |       logger.write_char(')')
     |     }
1195 |     RefIsNull => logger.write_string("ref.null")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefFunc(i) => {
     |       logger.write_string("(ref.func ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1201 |     RefEq => logger.write_string("ref.eq")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefAsNonNull => logger.write_string("ref.as_non_null")
     |     BrOnNull(l) => {
     |       logger.write_string("(br_on_null ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
1208 |     BrOnNonNull(l) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(br_on_non_null ")
     |       l.output(logger)
     |       logger.write_char(')')
     |     }
1213 |     StructNew(i) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(struct.new ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1218 |     StructNewDefault(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(struct.new_default ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1223 |     StructGet(t, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(struct.get ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1230 |     StructGetS(t, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(struct.get_s ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1237 |     StructGetU(t, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(struct.get_u ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1244 |     StructSet(t, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(struct.set ")
     |       t.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1251 |     ArrayNew(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.new ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1256 |     ArrayNewDefault(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.new_default ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1261 |     ArrayNewFixed(i, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.new_fixed ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       n.output(logger)
     |       logger.write_char(')')
     |     }
1268 |     ArrayNewData(i, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.new_data ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       n.output(logger)
     |       logger.write_char(')')
     |     }
1275 |     ArrayNewElem(i, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.new_elem ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       n.output(logger)
     |       logger.write_char(')')
     |     }
1282 |     ArrayGet(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.get ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1287 |     ArrayGetS(i) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.get_s ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1292 |     ArrayGetU(i) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.get_u ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1297 |     ArraySet(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.set ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1302 |     ArrayLen => logger.write_string("array.len")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayFill(i) => {
     |       logger.write_string("(array.fill ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1308 |     ArrayCopy(i, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.copy ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       n.output(logger)
     |       logger.write_char(')')
     |     }
1315 |     ArrayInitData(i, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.init_data ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       n.output(logger)
     |       logger.write_char(')')
     |     }
1322 |     ArrayInitElem(i, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(array.init_elem ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       n.output(logger)
     |       logger.write_char(')')
     |     }
1329 |     RefGetDesc => logger.write_string("ref.get_desc")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTest(n, ht) => {
     |       logger.write_string("(ref.test ")
     |       HeapTypeRefType(n, ht).output(logger)
     |       logger.write_char(')')
     |     }
1335 |     RefCast(n, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(ref.cast ")
     |       HeapTypeRefType(n, ht).output(logger)
     |       logger.write_char(')')
     |     }
1340 |     RefTestDesc(n, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(ref.test_desc ")
     |       HeapTypeRefType(n, ht).output(logger)
     |       logger.write_char(')')
     |     }
1345 |     RefCastDescEq(n, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(ref.cast_desc_eq ")
     |       HeapTypeRefType(n, ht).output(logger)
     |       logger.write_char(')')
     |     }
1350 |     BrOnCast(i, CastOp(l, r), lht, rht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(br_on_cast ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       HeapTypeRefType(l, lht).output(logger)
     |       logger.write_char(' ')
     |       HeapTypeRefType(r, rht).output(logger)
     |       logger.write_char(')')
     |     }
1359 |     BrOnCastFail(i, CastOp(l, r), lht, rht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(br_on_cast_fail ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       HeapTypeRefType(l, lht).output(logger)
     |       logger.write_char(' ')
     |       HeapTypeRefType(r, rht).output(logger)
     |       logger.write_char(')')
     |     }
1368 |     AnyConvertExtern => logger.write_string("any.convert_extern")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ExternConvertAny => logger.write_string("extern.convert_any")
     |     RefI31 => logger.write_string("ref.i31")
     |     I31GetS => logger.write_string("i31.get_s")
     |     I31GetU => logger.write_string("i31.get_u")
     |     I32TruncSatF32S => logger.write_string("i32.trunc_sat_f32s")
     |     I32TruncSatF32U => logger.write_string("i32.trunc_sat_f32u")
     |     I32TruncSatF64S => logger.write_string("i32.trunc_sat_f64s")
     |     I32TruncSatF64U => logger.write_string("i32.trunc_sat_f64u")
     |     I64TruncSatF32S => logger.write_string("i64.trunc_sat_f32s")
     |     I64TruncSatF32U => logger.write_string("i64.trunc_sat_f32u")
     |     I64TruncSatF64S => logger.write_string("i64.trunc_sat_f64s")
     |     I64TruncSatF64U => logger.write_string("i64.trunc_sat_f64u")
     |     MemoryInit(i, m) => {
     |       logger.write_string("(memory.init ")
     |       i.output(logger)
     |       logger.write_char(' ')
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1388 |     DataDrop(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(data.drop ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1393 |     MemoryCopy(i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.copy ")
     |       i0.output(logger)
     |       logger.write_char(' ')
     |       i1.output(logger)
     |       logger.write_char(')')
     |     }
1400 |     MemoryFill(i) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(memory.fill ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1405 |     TableInit(i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.init ")
     |       i0.output(logger)
     |       logger.write_char(' ')
     |       i1.output(logger)
     |       logger.write_char(')')
     |     }
1412 |     ElemDrop(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(elem.drop ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1417 |     TableCopy(i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.copy ")
     |       i0.output(logger)
     |       logger.write_char(' ')
     |       i1.output(logger)
     |       logger.write_char(')')
     |     }
1424 |     TableGrow(i) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.grow ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1429 |     TableSize(i) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.size ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1434 |     TableFill(i) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(table.fill ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1439 |     V128Load(m) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1444 |     V128Load8x8S(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load8x8s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1449 |     V128Load8x8U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load8x8u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1454 |     V128Load16x4S(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load16x4s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1459 |     V128Load16x4U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load16x4u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1464 |     V128Load32x2S(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load32x2s ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1469 |     V128Load32x2U(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load32x2u ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1474 |     V128Load8Splat(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load8_splat ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1479 |     V128Load16Splat(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load16_splat ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1484 |     V128Load32Splat(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load32_splat ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1489 |     V128Load64Splat(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load64_splat ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1494 |     V128Store(m) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.store ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
     |     V128Const(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15
1516 |     ) => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.const ")
     |       l0.to_hex().pad_start(2, '0').output(logger)
     |       l1.to_hex().pad_start(2, '0').output(logger)
     |       l2.to_hex().pad_start(2, '0').output(logger)
     |       l3.to_hex().pad_start(2, '0').output(logger)
     |       l4.to_hex().pad_start(2, '0').output(logger)
     |       l5.to_hex().pad_start(2, '0').output(logger)
     |       l6.to_hex().pad_start(2, '0').output(logger)
     |       l7.to_hex().pad_start(2, '0').output(logger)
     |       l8.to_hex().pad_start(2, '0').output(logger)
     |       l9.to_hex().pad_start(2, '0').output(logger)
     |       l10.to_hex().pad_start(2, '0').output(logger)
     |       l11.to_hex().pad_start(2, '0').output(logger)
     |       l12.to_hex().pad_start(2, '0').output(logger)
     |       l13.to_hex().pad_start(2, '0').output(logger)
     |       l14.to_hex().pad_start(2, '0').output(logger)
     |       l15.to_hex().pad_start(2, '0').output(logger)
     |       logger.write_char(')')
     |     }
     |     I8x16Shuffle(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15
1553 |     ) => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i8x16.shuffle ")
     |       l0.output(logger)
     |       logger.write_char(' ')
     |       l1.output(logger)
     |       logger.write_char(' ')
     |       l2.output(logger)
     |       logger.write_char(' ')
     |       l3.output(logger)
     |       logger.write_char(' ')
     |       l4.output(logger)
     |       logger.write_char(' ')
     |       l5.output(logger)
     |       logger.write_char(' ')
     |       l6.output(logger)
     |       logger.write_char(' ')
     |       l7.output(logger)
     |       logger.write_char(' ')
     |       l8.output(logger)
     |       logger.write_char(' ')
     |       l9.output(logger)
     |       logger.write_char(' ')
     |       l10.output(logger)
     |       logger.write_char(' ')
     |       l11.output(logger)
     |       logger.write_char(' ')
     |       l12.output(logger)
     |       logger.write_char(' ')
     |       l13.output(logger)
     |       logger.write_char(' ')
     |       l14.output(logger)
     |       logger.write_char(' ')
     |       l15.output(logger)
     |       logger.write_char(')')
     |     }
1588 |     I8x16Swizzle => logger.write_string("i8x16.swizzle")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16Splat => logger.write_string("i8x16.splat")
     |     I16x8Splat => logger.write_string("i16x8.splat")
     |     I32x4Splat => logger.write_string("i32x4.splat")
     |     I64x2Splat => logger.write_string("i64x2.splat")
     |     F32x4Splat => logger.write_string("f32x4.splat")
     |     F64x2Splat => logger.write_string("f64x2.splat")
     |     I8x16ExtractLaneS(i) => {
     |       logger.write_string("(i8x16.extract_lane_s ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1600 |     I8x16ExtractLaneU(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i8x16.extract_lane_u ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1605 |     I8x16ReplaceLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i8x16.replace_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1610 |     I16x8ExtractLaneS(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i16x8.extract_lane_s ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1615 |     I16x8ExtractLaneU(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i16x8.extract_lane_u ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1620 |     I16x8ReplaceLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i16x8.replace_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1625 |     I32x4ExtractLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32x4.extract_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1630 |     I32x4ReplaceLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i32x4.replace_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1635 |     I64x2ExtractLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64x2.extract_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1640 |     I64x2ReplaceLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(i64x2.replace_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1645 |     F32x4ExtractLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f32x4.extract_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1650 |     F32x4ReplaceLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f32x4.replace_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1655 |     F64x2ExtractLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f64x2.extract_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1660 |     F64x2ReplaceLane(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(f64x2.replace_lane ")
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1665 |     I8x16Eq => logger.write_string("i8x16.eq")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16Ne => logger.write_string("i8x16.ne")
     |     I8x16LtS => logger.write_string("i8x16.lt_s")
     |     I8x16LtU => logger.write_string("i8x16.lt_u")
     |     I8x16GtS => logger.write_string("i8x16.gt_s")
     |     I8x16GtU => logger.write_string("i8x16.gt_u")
     |     I8x16LeS => logger.write_string("i8x16.le_s")
     |     I8x16LeU => logger.write_string("i8x16.le_u")
     |     I8x16GeS => logger.write_string("i8x16.ge_s")
     |     I8x16GeU => logger.write_string("i8x16.ge_u")
     |     I16x8Eq => logger.write_string("i16x8.eq")
     |     I16x8Ne => logger.write_string("i16x8.ne")
     |     I16x8LtS => logger.write_string("i16x8.lt_s")
     |     I16x8LtU => logger.write_string("i16x8.lt_u")
     |     I16x8GtS => logger.write_string("i16x8.gt_s")
     |     I16x8GtU => logger.write_string("i16x8.gt_u")
     |     I16x8LeS => logger.write_string("i16x8.le_s")
     |     I16x8LeU => logger.write_string("i16x8.le_u")
     |     I16x8GeS => logger.write_string("i16x8.ge_s")
     |     I16x8GeU => logger.write_string("i16x8.ge_u")
     |     I32x4Eq => logger.write_string("i32x4.eq")
     |     I32x4Ne => logger.write_string("i32x4.ne")
     |     I32x4LtS => logger.write_string("i32x4.lt_s")
     |     I32x4LtU => logger.write_string("i32x4.lt_u")
     |     I32x4GtS => logger.write_string("i32x4.gt_s")
     |     I32x4GtU => logger.write_string("i32x4.gt_u")
     |     I32x4LeS => logger.write_string("i32x4.le_s")
     |     I32x4LeU => logger.write_string("i32x4.le_u")
     |     I32x4GeS => logger.write_string("i32x4.ge_s")
     |     I32x4GeU => logger.write_string("i32x4.ge_u")
     |     F32x4Eq => logger.write_string("f32x4.eq")
     |     F32x4Ne => logger.write_string("f32x4.ne")
     |     F32x4Lt => logger.write_string("f32x4.lt")
     |     F32x4Gt => logger.write_string("f32x4.gt")
     |     F32x4Le => logger.write_string("f32x4.le")
     |     F32x4Ge => logger.write_string("f32x4.ge")
     |     F64x2Eq => logger.write_string("f64x2.eq")
     |     F64x2Ne => logger.write_string("f64x2.ne")
     |     F64x2Lt => logger.write_string("f64x2.lt")
     |     F64x2Gt => logger.write_string("f64x2.gt")
     |     F64x2Le => logger.write_string("f64x2.le")
     |     F64x2Ge => logger.write_string("f64x2.ge")
     |     V128Not => logger.write_string("v128.not")
     |     V128And => logger.write_string("v128.and")
     |     V128Andnot => logger.write_string("v128.andnot")
     |     V128Or => logger.write_string("v128.or")
     |     V128Xor => logger.write_string("v128.xor")
     |     V128Bitselect => logger.write_string("v128.bitselect")
     |     V128AnyTrue => logger.write_string("v128.any_true")
     |     V128Load8Lane(m, i) => {
     |       logger.write_string("(v128.load8_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1721 |     V128Load16Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load16_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1728 |     V128Load32Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load32_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1735 |     V128Load64Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.load64_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1742 |     V128Store8Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.store8_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1749 |     V128Store16Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.store16_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1756 |     V128Store32Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.store32_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1763 |     V128Store64Lane(m, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128.store64_lane ")
     |       m.output(logger)
     |       logger.write_char(' ')
     |       i.output(logger)
     |       logger.write_char(')')
     |     }
1770 |     V128Load32Zero(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128_load32_zero ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1775 |     V128Load64Zero(m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       logger.write_string("(v128_load64_zero ")
     |       m.output(logger)
     |       logger.write_char(')')
     |     }
1780 |     F32x4DemoteF64x2Zero => logger.write_string("f32x4.demote_f64x2_zero")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64x2PromoteLowF32x4 => logger.write_string("f64x2.promote_low_f32x4")
     |     I8x16Abs => logger.write_string("i8x16.abs")
     |     I8x16Neg => logger.write_string("i8x16.neg")
     |     I8x16Popcnt => logger.write_string("i8x16.popcnt")
     |     I8x16AllTrue => logger.write_string("i8x16.all_true")
     |     I8x16Bitmask => logger.write_string("i8x16.bitmask")
     |     I8x16NarrowI16x8S => logger.write_string("i8x16.narrow_i16x8s")
     |     I8x16NarrowI16x8U => logger.write_string("i8x16.narrow_i16x8u")
     |     F32x4Ceil => logger.write_string("f32x4.ceil")
     |     F32x4Floor => logger.write_string("f32x4.floor")
     |     F32x4Trunc => logger.write_string("f32x4.trunc")
     |     F32x4Nearest => logger.write_string("f32x4.nearest")
     |     I8x16Shl => logger.write_string("i8x16.shl")
     |     I8x16ShrS => logger.write_string("i8x16.shr_s")
     |     I8x16ShrU => logger.write_string("i8x16.shr_u")
     |     I8x16Add => logger.write_string("i8x16.add")
     |     I8x16AddSatS => logger.write_string("i8x16.add_sat_s")
     |     I8x16AddSatU => logger.write_string("i8x16.add_sat_u")
     |     I8x16Sub => logger.write_string("i8x16.sub")
     |     I8x16SubSatS => logger.write_string("i8x16.sub_sat_s")
     |     I8x16SubSatU => logger.write_string("i8x16.sub_sat_u")
     |     F64x2Ceil => logger.write_string("f64x2.ceil")
     |     F64x2Floor => logger.write_string("f64x2.floor")
     |     I8x16MinS => logger.write_string("i8x16.min_s")
     |     I8x16MinU => logger.write_string("i8x16.min_u")
     |     I8x16MaxS => logger.write_string("i8x16.max_s")
     |     I8x16MaxU => logger.write_string("i8x16.max_u")
     |     F64x2Trunc => logger.write_string("f64x2.trunc")
     |     I8x16AvgrU => logger.write_string("i8x16.avgr_u")
     |     I16x8ExtaddPairwiseI8x16S =>
1811 |       logger.write_string("i16x8.extadd_pairwise_i8x16s")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8ExtaddPairwiseI8x16U =>
1813 |       logger.write_string("i16x8.extadd_pairwise_i8x16u")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4ExtaddPairwiseI16x8S =>
1815 |       logger.write_string("i32x4.extadd_pairwise_i16x8s")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4ExtaddPairwiseI16x8U =>
1817 |       logger.write_string("i32x4.extadd_pairwise_i16x8u")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8Abs => logger.write_string("i16x8.abs")
     |     I16x8Neg => logger.write_string("i16x8.neg")
     |     I16x8Q15mulrSatS => logger.write_string("i16x8.15mulr_sat_s")
     |     I16x8AllTrue => logger.write_string("i16x8.all_true")
     |     I16x8Bitmask => logger.write_string("i16x8.bitmask")
     |     I16x8NarrowI32x4S => logger.write_string("i16x8.narrow_i32x4s")
     |     I16x8NarrowI32x4U => logger.write_string("i16x8.narrow_i32x4u")
     |     I16x8ExtendLowI8x16S => logger.write_string("i16x8.extend_low_i8x16s")
     |     I16x8ExtendHighI8x16S => logger.write_string("i16x8.extend_high_i8x16s")
     |     I16x8ExtendLowI8x16U => logger.write_string("i16x8.extend_low_i8x16u")
     |     I16x8ExtendHighI8x16U => logger.write_string("i16x8.extend_high_i8x16u")
     |     I16x8Shl => logger.write_string("i16x8.shl")
     |     I16x8ShrS => logger.write_string("i16x8.shr_s")
     |     I16x8ShrU => logger.write_string("i16x8.shr_u")
     |     I16x8Add => logger.write_string("i16x8.add")
     |     I16x8AddSatS => logger.write_string("i16x8.add_sat_s")
     |     I16x8AddSatU => logger.write_string("i16x8.add_sat_u")
     |     I16x8Sub => logger.write_string("i16x8.sub")
     |     I16x8SubSatS => logger.write_string("i16x8.sub_sat_s")
     |     I16x8SubSatU => logger.write_string("i16x8.sub_sat_u")
     |     F64x2Nearest => logger.write_string("f64x2.nearest")
     |     I16x8Mul => logger.write_string("i16x8.mul")
     |     I16x8MinS => logger.write_string("i16x8.min_s")
     |     I16x8MinU => logger.write_string("i16x8.min_u")
     |     I16x8MaxS => logger.write_string("i16x8.max_s")
     |     I16x8MaxU => logger.write_string("i16x8.max_u")
     |     I16x8AvgrU => logger.write_string("i16x8.avgr_u")
     |     I16x8ExtmulLowI8x16S => logger.write_string("i16x8.extmul_low_i8x16s")
     |     I16x8ExtmulHighI8x16S => logger.write_string("i16x8.extmul_high_i8x16s")
     |     I16x8ExtmulLowI8x16U => logger.write_string("i16x8.extmul_low_i8x16u")
     |     I16x8ExtmulHighI8x16U => logger.write_string("i16x8.extmul_high_i8x16u")
     |     I32x4Abs => logger.write_string("i32x4.abs")
     |     I32x4Neg => logger.write_string("i32x4.neg")
     |     I32x4AllTrue => logger.write_string("i32x4.all_true")
     |     I32x4Bitmask => logger.write_string("i32x4.bitmask")
     |     I32x4ExtendLowI16x8S => logger.write_string("i32x4.extend_low_i16x8s")
     |     I32x4ExtendHighI16x8S => logger.write_string("i32x4.extend_high_i16x8s")
     |     I32x4ExtendLowI16x8U => logger.write_string("i32x4.extend_low_i16x8u")
     |     I32x4ExtendHighI16x8U => logger.write_string("i32x4.extend_high_i16x8u")
     |     I32x4Shl => logger.write_string("i32x4.shl")
     |     I32x4ShrS => logger.write_string("i32x4.shr_s")
     |     I32x4ShrU => logger.write_string("i32x4.shr_u")
     |     I32x4Add => logger.write_string("i32x4.add")
     |     I32x4Sub => logger.write_string("i32x4.sub")
     |     I32x4Mul => logger.write_string("i32x4.mul")
     |     I32x4MinS => logger.write_string("i32x4.min_s")
     |     I32x4MinU => logger.write_string("i32x4.min_u")
     |     I32x4MaxS => logger.write_string("i32x4.max_s")
     |     I32x4MaxU => logger.write_string("i32x4.max_u")
     |     I32x4DotI16x8S => logger.write_string("i32x4.dot_i16x8s")
     |     I32x4ExtmulLowI16x8S => logger.write_string("i32x4.extmul_low_i16x8s")
     |     I32x4ExtmulHighI16x8S => logger.write_string("i32x4.extmul_high_i16x8s")
     |     I32x4ExtmulLowI16x8U => logger.write_string("i32x4.extmul_low_i16x8u")
     |     I32x4ExtmulHighI16x8U => logger.write_string("i32x4.extmul_high_i16x8u")
     |     I64x2Abs => logger.write_string("i64x2.abs")
     |     I64x2Neg => logger.write_string("i64x2.neg")
     |     I64x2AllTrue => logger.write_string("i64x2.all_true")
     |     I64x2Bitmask => logger.write_string("i64x2.bitmask")
     |     I64x2ExtendLowI32x4S => logger.write_string("i64x2.extend_low_i32x4s")
     |     I64x2ExtendHighI32x4S => logger.write_string("i64x2.extend_high_i32x4s")
     |     I64x2ExtendLowI32x4U => logger.write_string("i64x2.extend_low_i32x4u")
     |     I64x2ExtendHighI32x4U => logger.write_string("i64x2.extend_high_i32x4u")
     |     I64x2Shl => logger.write_string("i64x2.shl")
     |     I64x2ShrS => logger.write_string("i64x2.shr_s")
     |     I64x2ShrU => logger.write_string("i64x2.shr_u")
     |     I64x2Add => logger.write_string("i64x2.add")
     |     I64x2Sub => logger.write_string("i64x2.sub")
     |     I64x2Mul => logger.write_string("i64x2.mul")
     |     I64x2Eq => logger.write_string("i64x2.eq")
     |     I64x2Ne => logger.write_string("i64x2.ne")
     |     I64x2LtS => logger.write_string("i64x2.lt_s")
     |     I64x2GtS => logger.write_string("i64x2.gt_s")
     |     I64x2LeS => logger.write_string("i64x2.le_s")
     |     I64x2GeS => logger.write_string("i64x2.ge_s")
     |     I64x2ExtmulLowI32x4S => logger.write_string("i64x2.extmul_low_i32x4s")
     |     I64x2ExtmulHighI32x4S => logger.write_string("i64x2.extmul_high_i32x4s")
     |     I64x2ExtmulLowI32x4U => logger.write_string("i64x2.extmul_low_i32x4u")
     |     I64x2ExtmulHighI32x4U => logger.write_string("i64x2.extmul_high_i32x4u")
     |     F32x4Abs => logger.write_string("f32x4.abs")
     |     F32x4Neg => logger.write_string("f32x4.neg")
     |     F32x4Sqrt => logger.write_string("f32x4.sqrt")
     |     F32x4Add => logger.write_string("f32x4.add")
     |     F32x4Sub => logger.write_string("f32x4.sub")
     |     F32x4Mul => logger.write_string("f32x4.mul")
     |     F32x4Div => logger.write_string("f32x4.div")
     |     F32x4Min => logger.write_string("f32x4.min")
     |     F32x4Max => logger.write_string("f32x4.max")
     |     F32x4Pmin => logger.write_string("f32x4.pmin")
     |     F32x4Pmax => logger.write_string("f32x4.pmax")
     |     F64x2Abs => logger.write_string("f64x2.abs")
     |     F64x2Neg => logger.write_string("f64x2.neg")
     |     F64x2Sqrt => logger.write_string("f64x2.sqrt")
     |     F64x2Add => logger.write_string("f64x2.add")
     |     F64x2Sub => logger.write_string("f64x2.sub")
     |     F64x2Mul => logger.write_string("f64x2.mul")
     |     F64x2Div => logger.write_string("f64x2.div")
     |     F64x2Min => logger.write_string("f64x2.min")
     |     F64x2Max => logger.write_string("f64x2.max")
     |     F64x2Pmin => logger.write_string("f64x2.pmin")
     |     F64x2Pmax => logger.write_string("f64x2.pmax")
     |     I32x4TruncSatF32x4S => logger.write_string("i32x4.trunc_sat_f32x4s")
     |     I32x4TruncSatF32x4U => logger.write_string("i32x4.trunc_sat_f32x4u")
     |     F32x4ConvertI32x4S => logger.write_string("f32x4.convert_i32x4s")
     |     F32x4ConvertI32x4U => logger.write_string("f32x4.convert_i32x4u")
     |     I32x4TruncSatF64x2SZero =>
1923 |       logger.write_string("i32x4.trunc_sat_f64x2s_zero")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4TruncSatF64x2UZero =>
1925 |       logger.write_string("i32x4.trunc_sat_f64x2u_zero")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64x2ConvertLowI32x4S => logger.write_string("f64x2.convert_low_i32x4s")
     |     F64x2ConvertLowI32x4U => logger.write_string("f64x2.convert_low_i32x4u")
     |     I8x16RelaxedSwizzle => logger.write_string("i8x16.relaxed_swizzle")
     |     I32x4RelaxedTruncF32x4S => logger.write_string("i32x4.relaxed_trunc_f32x4s")
     |     I32x4RelaxedTruncF32x4U => logger.write_string("i32x4.relaxed_trunc_f32x4u")
     |     I32x4RelaxedTruncZeroF64x2S =>
1932 |       logger.write_string("i32x4.relaxed_trunc_zero_f64x2s")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4RelaxedTruncZeroF64x2U =>
1934 |       logger.write_string("i32x4.relaxed_trunc_zero_f64x2u")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32x4RelaxedMadd => logger.write_string("f32x4.relaxed_madd")
     |     F32x4RelaxedNmadd => logger.write_string("f32x4.relaxed_nmadd")
     |     F64x2RelaxedMadd => logger.write_string("f64x2.relaxed_madd")
     |     F64x2RelaxedNmadd => logger.write_string("f64x2.relaxed_nmadd")
     |     I8x16RelaxedLaneselect => logger.write_string("i8x16.relaxed_laneselect")
     |     I16x8RelaxedLaneselect => logger.write_string("i16x8.relaxed_laneselect")
     |     I32x4RelaxedLaneselect => logger.write_string("i32x4.relaxed_laneselect")
     |     I64x2RelaxedLaneselect => logger.write_string("i64x2.relaxed_laneselect")
     |     F32x4RelaxedMin => logger.write_string("f32x4.relaxed_min")
     |     F32x4RelaxedMax => logger.write_string("f32x4.relaxed_max")
     |     F64x2RelaxedMin => logger.write_string("f64x2.relaxed_min")
     |     F64x2RelaxedMax => logger.write_string("f64x2.relaxed_max")
     |     I16x8RelaxedQ15mulrS => logger.write_string("i16x8.relaxed_q15mulr_s")
     |     I16x8RelaxedDotI8x16I7x16S =>
1949 |       logger.write_string("i16x8.relaxed_dot_i8x16i7x16s")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4RelaxedDotI8x16I7x16AddS =>
1951 |       logger.write_string("i32x4.relaxed_dot_i8x16i7x16_add_s")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Show for CustomSec with output(self, logger) {
1957 |   let CustomSec(name, _) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Custom: ")
     |   name.output(logger)
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for TypeSec with output(self, logger) {
     |   let TypeSec(tys) = self
     |   logger.write_string("[Types")
     |   if tys.length() == 0 {
1968 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     |   logger.write_string(":\n")
     |   for ty in tys {
     |     logger.write_string("  - ")
     |     ty.output(logger)
     |     logger.write_char('\n')
     |   }
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for ImportSec with output(self, logger) {
1982 |   let ImportSec(imports) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Imports")
     |   if imports.length() == 0 {
1985 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
1988 |   logger.write_string(": \n")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in imports {
1990 |     logger.write_string("  - ")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
1994 |   logger.write_char(']')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for FuncSec with output(self, logger) {
     |   let FuncSec(fns) = self
     |   logger.write_string("[Funcs")
     |   if fns.length() == 0 {
2002 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     |   logger.write_string(": \n")
     |   for i in fns {
     |     logger.write_string("  - ")
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for TableSec with output(self, logger) {
2016 |   let TableSec(tbls) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Tables")
     |   if tbls.length() == 0 {
2019 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
2022 |   logger.write_string(": \n")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in tbls {
2024 |     logger.write_string("  - ")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
2028 |   logger.write_char(']')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for MemSec with output(self, logger) {
     |   let MemSec(mems) = self
     |   logger.write_string("[Memory")
     |   if mems.length() == 0 {
2036 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     |   logger.write_string(": \n")
     |   for i in mems {
     |     logger.write_string("  - ")
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for TagSec with output(self, logger) {
2050 |   let TagSec(mems) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Tags")
     |   if mems.length() == 0 {
2053 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
2056 |   logger.write_string(": \n")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in mems {
2058 |     logger.write_string("  - ")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
2062 |   logger.write_char(']')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for GlobalSec with output(self, logger) {
     |   let GlobalSec(globals) = self
     |   logger.write_string("[Globals")
     |   if globals.length() == 0 {
2070 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     |   logger.write_string(": \n")
     |   for i in globals {
     |     logger.write_string("  - ")
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for ExportSec with output(self, logger) {
2084 |   let ExportSec(exports) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Globals")
     |   if exports.length() == 0 {
2087 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
2090 |   logger.write_string(": \n")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in exports {
2092 |     logger.write_string("  - ")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
2096 |   logger.write_char(']')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for StartSec with output(self, logger) {
2101 |   let StartSec(start) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Start ")
     |   start.output(logger)
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for ElemSec with output(self, logger) {
2109 |   let ElemSec(elems) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Elems")
     |   if elems.length() == 0 {
2112 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
2115 |   logger.write_string(": \n")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in elems {
2117 |     logger.write_string("  - ")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
2121 |   logger.write_char(']')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for DataCntSec with output(self, logger) {
2126 |   let DataCntSec(start) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[DataCount ")
     |   start.output(logger)
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for CodeSec with output(self, logger) {
     |   let CodeSec(codes) = self
     |   logger.write_string("[Code")
     |   if codes.length() == 0 {
2137 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     |   logger.write_string(": \n")
     |   for i in codes {
     |     logger.write_string("  - ")
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
     |   logger.write_char(']')
     | }
     …

     | pub impl Show for DataSec with output(self, logger) {
2151 |   let DataSec(datas) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("[Elems")
     |   if datas.length() == 0 {
2154 |     logger.write_char(']')
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
2157 |   logger.write_string(": \n")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in datas {
2159 |     logger.write_string("  - ")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i.output(logger)
     |     logger.write_char('\n')
     |   }
2163 |   logger.write_char(']')
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub impl Show for FuncType with output(self, logger) {
2231 |   let FuncType(props, results) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   logger.write_string("FuncType {\n  props : ")
     |   props.output(logger)
     |   logger.write_string("\n  results : ")
     |   results.output(logger)
     |   logger.write_string("\n}")
     | }
     …

163 uncovered line(s) in src/lib/texpr.mbt:

     | fn tinstr_to_instr(tinstr : TInstr, instrs : Array[Instruction]) -> Unit {
     |   match tinstr {
     |     // === Constants ===
     |     TI32Const(v) => instrs.push(I32Const(v))
     |     TI64Const(v) => instrs.push(I64Const(v))
  21 |     TF32Const(v) => instrs.push(F32Const(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF64Const(v) => instrs.push(F64Const(v))
     |     TRefNull(ht) => instrs.push(RefNull(ht))
  24 |     TRefFunc(idx) => instrs.push(RefFunc(idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Const(
     |       b0,
     |       b1,
     |       b2,
     |       b3,
     |       b4,
     |       b5,
     |       b6,
     |       b7,
     |       b8,
     |       b9,
     |       b10,
     |       b11,
     |       b12,
     |       b13,
     |       b14,
     |       b15
     |     ) =>
  43 |       instrs.push(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         V128Const(
     |           b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,
     |         ),
     |       )
     | 
     |     // === Nullary ===
  50 |     TUnreachable => instrs.push(Unreachable)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TNop => instrs.push(Nop)
     |     TLocalGet(idx) => instrs.push(LocalGet(idx))
  53 |     TGlobalGet(idx) => instrs.push(GlobalGet(idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemorySize(idx) => instrs.push(MemorySize(idx))
     |     TTableSize(idx) => instrs.push(TableSize(idx))
     | 
     |     // === Unary ===
  58 |     TUnary(op, child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(unary_op_to_instr(op))
     |     }
     |     TDrop(child) => {
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(Drop)
     |     }
     |     TLocalSet(idx, child) => {
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(LocalSet(idx))
     |     }
  70 |     TLocalTee(idx, child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(LocalTee(idx))
     |     }
  74 |     TGlobalSet(idx, child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(GlobalSet(idx))
     |     }
  78 |     TRefIsNull(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(RefIsNull)
     |     }
     |     TRefAsNonNull(child) => {
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(RefAsNonNull)
     |     }
  86 |     TI31GetS(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(I31GetS)
     |     }
  90 |     TI31GetU(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(I31GetU)
     |     }
  94 |     TRefI31(child) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(RefI31)
     |     }
  98 |     TArrayLen(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(ArrayLen)
     |     }
 102 |     TAnyConvertExtern(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(AnyConvertExtern)
     |     }
 106 |     TExternConvertAny(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(ExternConvertAny)
     |     }
 110 |     TThrowRef(child) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(child, instrs)
     |       instrs.push(ThrowRef)
     |     }
     | 
     |     // === Binary ===
 116 |     TBinary(op, lhs, rhs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(lhs, instrs)
     |       tinstr_to_instr(rhs, instrs)
     |       instrs.push(binary_op_to_instr(op))
     |     }
 121 |     TRefEq(lhs, rhs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(lhs, instrs)
     |       tinstr_to_instr(rhs, instrs)
     |       instrs.push(RefEq)
     |     }
 126 |     TStore(op, memarg, addr, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(value, instrs)
     |       instrs.push(store_op_to_instr(op, memarg))
     |     }
     | 
     |     // === Load ===
 133 |     TLoad(op, memarg, addr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       instrs.push(load_op_to_instr(op, memarg))
     |     }
     | 
     |     // === Memory operations ===
 139 |     TMemoryGrow(idx, pages) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(pages, instrs)
     |       instrs.push(MemoryGrow(idx))
     |     }
 143 |     TMemoryFill(idx, dest, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(dest, instrs)
     |       tinstr_to_instr(val, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(MemoryFill(idx))
     |     }
 149 |     TMemoryCopy(dst, src, dst_addr, src_addr, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(dst_addr, instrs)
     |       tinstr_to_instr(src_addr, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(MemoryCopy(dst, src))
     |     }
 155 |     TMemoryInit(data_idx, mem_idx, dst, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(dst, instrs)
     |       tinstr_to_instr(src, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(MemoryInit(data_idx, mem_idx))
     |     }
 161 |     TDataDrop(idx) => instrs.push(DataDrop(idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryAtomicNotify(memarg, addr, count) => {
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(count, instrs)
     |       instrs.push(MemoryAtomicNotify(memarg))
     |     }
 167 |     TMemoryAtomicWait32(memarg, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(expected, instrs)
     |       tinstr_to_instr(timeout, instrs)
     |       instrs.push(MemoryAtomicWait32(memarg))
     |     }
 173 |     TMemoryAtomicWait64(memarg, addr, expected, timeout) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(expected, instrs)
     |       tinstr_to_instr(timeout, instrs)
     |       instrs.push(MemoryAtomicWait64(memarg))
     |     }
 179 |     TAtomicFence => instrs.push(AtomicFence)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TAtomicRmw(op, memarg, addr, value) => {
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(value, instrs)
     |       instrs.push(AtomicRmw(op, memarg))
     |     }
 185 |     TAtomicCmpxchg(op, memarg, addr, expected, replacement) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(expected, instrs)
     |       tinstr_to_instr(replacement, instrs)
     |       instrs.push(AtomicCmpxchg(op, memarg))
     |     }
     | 
     |     // === Table operations ===
 193 |     TTableGet(idx, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(i, instrs)
     |       instrs.push(TableGet(idx))
     |     }
 197 |     TTableSet(idx, i, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(i, instrs)
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(TableSet(idx))
     |     }
 202 |     TTableGrow(idx, val, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       tinstr_to_instr(n, instrs)
     |       instrs.push(TableGrow(idx))
     |     }
 207 |     TTableFill(idx, i, val, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(i, instrs)
     |       tinstr_to_instr(val, instrs)
     |       tinstr_to_instr(n, instrs)
     |       instrs.push(TableFill(idx))
     |     }
 213 |     TTableCopy(dst, src, d, s, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(d, instrs)
     |       tinstr_to_instr(s, instrs)
     |       tinstr_to_instr(n, instrs)
     |       instrs.push(TableCopy(dst, src))
     |     }
 219 |     TTableInit(elem_idx, table_idx, d, s, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(d, instrs)
     |       tinstr_to_instr(s, instrs)
     |       tinstr_to_instr(n, instrs)
     |       instrs.push(TableInit(elem_idx, table_idx))
     |     }
 225 |     TElemDrop(idx) => instrs.push(ElemDrop(idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // === Calls ===
 228 |     TCall(func_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 230 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 232 |       instrs.push(Call(func_idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 234 |     TCallIndirect(type_idx, table_idx, args, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 236 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 238 |       tinstr_to_instr(idx, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(CallIndirect(type_idx, table_idx))
     |     }
 241 |     TCallRef(type_idx, args, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 243 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 245 |       tinstr_to_instr(ref_, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(CallRef(type_idx))
     |     }
 248 |     TReturnCall(func_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 250 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 252 |       instrs.push(ReturnCall(func_idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 254 |     TReturnCallIndirect(type_idx, table_idx, args, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 256 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 258 |       tinstr_to_instr(idx, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(ReturnCallIndirect(type_idx, table_idx))
     |     }
 261 |     TReturnCallRef(type_idx, args, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 263 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 265 |       tinstr_to_instr(ref_, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(ReturnCallRef(type_idx))
     |     }
     | 
     |     // === Control flow ===
 270 |     TBlock(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let body_instrs : Array[Instruction] = []
     |       for value in body.0 {
 273 |         tinstr_to_instr(value, body_instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 275 |       instrs.push(Block(bt, Expr(body_instrs)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 277 |     TLoop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let body_instrs : Array[Instruction] = []
     |       for value in body.0 {
 280 |         tinstr_to_instr(value, body_instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 282 |       instrs.push(Loop(bt, Expr(body_instrs)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TIf(bt, cond, then_branch, else_branch) => {
     |       tinstr_to_instr(cond, instrs)
     |       let then_instrs : Array[Instruction] = []
     |       for value in then_branch.0 {
     |         tinstr_to_instr(value, then_instrs)
     |       }
     |       let else_instrs : Array[Instruction]? = match else_branch {
     |         Some(else_body) => {
     |           let els : Array[Instruction] = []
     |           for value in else_body.0 {
     |             tinstr_to_instr(value, els)
     |           }
     |           Some(els)
     |         }
 298 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       instrs.push(If(bt, then_instrs, else_instrs))
     |     }
 302 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let body_instrs : Array[Instruction] = []
     |       for value in body.0 {
 305 |         tinstr_to_instr(value, body_instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 307 |       instrs.push(TryTable(bt, catches, Expr(body_instrs)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 309 |     TThrow(tag_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 311 |         tinstr_to_instr(arg, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 313 |       instrs.push(Throw(tag_idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Branches ===
 317 |     TBr(label, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 319 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 321 |       instrs.push(Br(label))
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 323 |     TBrIf(label, cond, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 325 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 327 |       tinstr_to_instr(cond, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(BrIf(label))
     |     }
 330 |     TBrTable(labels, default, idx, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 332 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 334 |       tinstr_to_instr(idx, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(BrTable(labels, default))
     |     }
 337 |     TBrOnNull(label, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 339 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 341 |       tinstr_to_instr(ref_, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(BrOnNull(label))
     |     }
 344 |     TBrOnNonNull(label, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 346 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 348 |       tinstr_to_instr(ref_, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(BrOnNonNull(label))
     |     }
 351 |     TBrOnCast(label, castop, ht1, ht2, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 353 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 355 |       tinstr_to_instr(ref_, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(BrOnCast(label, castop, ht1, ht2))
     |     }
 358 |     TBrOnCastFail(label, castop, ht1, ht2, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 360 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 362 |       tinstr_to_instr(ref_, instrs)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(BrOnCastFail(label, castop, ht1, ht2))
     |     }
 365 |     TReturn(values) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
 367 |         tinstr_to_instr(value, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 369 |       instrs.push(Return)
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     // === Select ===
 372 |     TSelect(types, cond, val1, val2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val1, instrs)
     |       tinstr_to_instr(val2, instrs)
     |       tinstr_to_instr(cond, instrs)
     |       instrs.push(Select(types))
     |     }
     | 
     |     // === GC: Structs ===
     |     TStructNew(type_idx, fields) => {
     |       for field in fields {
 382 |         tinstr_to_instr(field, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       instrs.push(StructNew(type_idx))
     |     }
 386 |     TStructNewDefault(type_idx) => instrs.push(StructNewDefault(type_idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(type_idx, field_idx, struct_ref) => {
     |       tinstr_to_instr(struct_ref, instrs)
     |       instrs.push(StructGet(type_idx, field_idx))
     |     }
 391 |     TStructGetS(type_idx, field_idx, struct_ref) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(struct_ref, instrs)
     |       instrs.push(StructGetS(type_idx, field_idx))
     |     }
 395 |     TStructGetU(type_idx, field_idx, struct_ref) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(struct_ref, instrs)
     |       instrs.push(StructGetU(type_idx, field_idx))
     |     }
 399 |     TStructSet(type_idx, field_idx, struct_ref, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(struct_ref, instrs)
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(StructSet(type_idx, field_idx))
     |     }
     | 
     |     // === GC: Arrays ===
 406 |     TArrayNew(type_idx, init, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(init, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayNew(type_idx))
     |     }
 411 |     TArrayNewDefault(type_idx, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayNewDefault(type_idx))
     |     }
 415 |     TArrayNewFixed(type_idx, elems) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for elem in elems {
 417 |         tinstr_to_instr(elem, instrs)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 419 |       instrs.push(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ArrayNewFixed(type_idx, U32(elems.length().reinterpret_as_uint())),
     |       )
     |     }
 423 |     TArrayNewData(type_idx, data_idx, offset, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(offset, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayNewData(type_idx, data_idx))
     |     }
 428 |     TArrayNewElem(type_idx, elem_idx, offset, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(offset, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayNewElem(type_idx, elem_idx))
     |     }
 433 |     TArrayGet(type_idx, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(idx, instrs)
     |       instrs.push(ArrayGet(type_idx))
     |     }
 438 |     TArrayGetS(type_idx, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(idx, instrs)
     |       instrs.push(ArrayGetS(type_idx))
     |     }
 443 |     TArrayGetU(type_idx, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(idx, instrs)
     |       instrs.push(ArrayGetU(type_idx))
     |     }
 448 |     TArraySet(type_idx, arr, idx, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(idx, instrs)
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(ArraySet(type_idx))
     |     }
 454 |     TArrayFill(type_idx, arr, offset, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(offset, instrs)
     |       tinstr_to_instr(val, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayFill(type_idx))
     |     }
 461 |     TArrayCopy(dst_type, src_type, dst, dst_offset, src, src_offset, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(dst, instrs)
     |       tinstr_to_instr(dst_offset, instrs)
     |       tinstr_to_instr(src, instrs)
     |       tinstr_to_instr(src_offset, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayCopy(dst_type, src_type))
     |     }
 469 |     TArrayInitData(type_idx, data_idx, arr, dst, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(dst, instrs)
     |       tinstr_to_instr(src, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayInitData(type_idx, data_idx))
     |     }
 476 |     TArrayInitElem(type_idx, elem_idx, arr, dst, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(arr, instrs)
     |       tinstr_to_instr(dst, instrs)
     |       tinstr_to_instr(src, instrs)
     |       tinstr_to_instr(len, instrs)
     |       instrs.push(ArrayInitElem(type_idx, elem_idx))
     |     }
     | 
     |     // === GC: Casts ===
 485 |     TRefGetDesc(ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(ref_, instrs)
     |       instrs.push(RefGetDesc)
     |     }
 489 |     TRefTest(nullable, ht, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(ref_, instrs)
     |       instrs.push(RefTest(nullable, ht))
     |     }
 493 |     TRefCast(nullable, ht, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(ref_, instrs)
     |       instrs.push(RefCast(nullable, ht))
     |     }
 497 |     TRefTestDesc(nullable, ht, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(ref_, instrs)
     |       instrs.push(RefTestDesc(nullable, ht))
     |     }
 501 |     TRefCastDescEq(nullable, ht, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(ref_, instrs)
     |       instrs.push(RefCastDescEq(nullable, ht))
     |     }
     | 
     |     // === SIMD: Splat ===
 507 |     TI8x16Splat(val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(I8x16Splat)
     |     }
 511 |     TI16x8Splat(val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(I16x8Splat)
     |     }
 515 |     TI32x4Splat(val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(I32x4Splat)
     |     }
 519 |     TI64x2Splat(val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(I64x2Splat)
     |     }
 523 |     TF32x4Splat(val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(F32x4Splat)
     |     }
 527 |     TF64x2Splat(val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(F64x2Splat)
     |     }
     | 
     |     // === SIMD: Extract lane ===
 533 |     TExtractLane(op, lane, vec) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(vec, instrs)
     |       instrs.push(extract_lane_op_to_instr(op, lane))
     |     }
     | 
     |     // === SIMD: Replace lane ===
 539 |     TReplaceLane(op, lane, vec, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(vec, instrs)
     |       tinstr_to_instr(val, instrs)
     |       instrs.push(replace_lane_op_to_instr(op, lane))
     |     }
     | 
     |     // === SIMD: Shuffle ===
     |     TI8x16Shuffle(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15,
     |       v1,
     |       v2
 565 |     ) => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(v1, instrs)
     |       tinstr_to_instr(v2, instrs)
     |       instrs.push(
     |         I8x16Shuffle(
     |           l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15,
     |         ),
     |       )
     |     }
     | 
     |     // === SIMD: Swizzle ===
 576 |     TI8x16Swizzle(vec, indices) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(vec, instrs)
     |       tinstr_to_instr(indices, instrs)
     |       instrs.push(I8x16Swizzle)
     |     }
 581 |     TI8x16RelaxedSwizzle(vec, indices) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(vec, instrs)
     |       tinstr_to_instr(indices, instrs)
     |       instrs.push(I8x16RelaxedSwizzle)
     |     }
     | 
     |     // === SIMD: Shift ===
 588 |     TV128Shift(op, vec, shift) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(vec, instrs)
     |       tinstr_to_instr(shift, instrs)
     |       instrs.push(v128_shift_op_to_instr(op))
     |     }
     | 
     |     // === SIMD: Ternary ===
 595 |     TV128Ternary(op, v1, v2, v3) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(v1, instrs)
     |       tinstr_to_instr(v2, instrs)
     |       tinstr_to_instr(v3, instrs)
     |       instrs.push(v128_ternary_op_to_instr(op))
     |     }
     | 
     |     // === SIMD: Lane load ===
 603 |     TV128LoadLane(op, memarg, lane, addr, vec) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(vec, instrs)
     |       instrs.push(v128_load_lane_op_to_instr(op, memarg, lane))
     |     }
     | 
     |     // === SIMD: Lane store ===
 610 |     TV128StoreLane(op, memarg, lane, addr, vec) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       tinstr_to_instr(addr, instrs)
     |       tinstr_to_instr(vec, instrs)
     |       instrs.push(v128_store_lane_op_to_instr(op, memarg, lane))
     |     }
     |   }
     | }
     …

     | fn unary_op_to_instr(op : UnaryOp) -> Instruction {
 624 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32EqzOp => I32Eqz
     |     I64EqzOp => I64Eqz
     |     I32ClzOp => I32Clz
     |     I32CtzOp => I32Ctz
     |     I32PopcntOp => I32Popcnt
     |     I64ClzOp => I64Clz
     |     I64CtzOp => I64Ctz
     |     I64PopcntOp => I64Popcnt
     |     F32AbsOp => F32Abs
     |     F32NegOp => F32Neg
     |     F32CeilOp => F32Ceil
     |     F32FloorOp => F32Floor
     |     F32TruncOp => F32Trunc
     |     F32NearestOp => F32Nearest
     |     F32SqrtOp => F32Sqrt
     |     F64AbsOp => F64Abs
     |     F64NegOp => F64Neg
     |     F64CeilOp => F64Ceil
     |     F64FloorOp => F64Floor
     |     F64TruncOp => F64Trunc
     |     F64NearestOp => F64Nearest
     |     F64SqrtOp => F64Sqrt
     |     I32WrapI64Op => I32WrapI64
     |     I32TruncF32SOp => I32TruncF32S
     |     I32TruncF32UOp => I32TruncF32U
     |     I32TruncF64SOp => I32TruncF64S
     |     I32TruncF64UOp => I32TruncF64U
     |     I64ExtendI32SOp => I64ExtendI32S
     |     I64ExtendI32UOp => I64ExtendI32U
     |     I64TruncF32SOp => I64TruncF32S
     |     I64TruncF32UOp => I64TruncF32U
     |     I64TruncF64SOp => I64TruncF64S
     |     I64TruncF64UOp => I64TruncF64U
     |     F32ConvertI32SOp => F32ConvertI32S
     |     F32ConvertI32UOp => F32ConvertI32U
     |     F32ConvertI64SOp => F32ConvertI64S
     |     F32ConvertI64UOp => F32ConvertI64U
     |     F32DemoteF64Op => F32DemoteF64
     |     F64ConvertI32SOp => F64ConvertI32S
     |     F64ConvertI32UOp => F64ConvertI32U
     |     F64ConvertI64SOp => F64ConvertI64S
     |     F64ConvertI64UOp => F64ConvertI64U
     |     F64PromoteF32Op => F64PromoteF32
     |     I32ReinterpretF32Op => I32ReinterpretF32
     |     I64ReinterpretF64Op => I64ReinterpretF64
     |     F32ReinterpretI32Op => F32ReinterpretI32
     |     F64ReinterpretI64Op => F64ReinterpretI64
     |     I32Extend8SOp => I32Extend8S
     |     I32Extend16SOp => I32Extend16S
     |     I64Extend8SOp => I64Extend8S
     |     I64Extend16SOp => I64Extend16S
     |     I64Extend32SOp => I64Extend32S
     |     I32TruncSatF32SOp => I32TruncSatF32S
     |     I32TruncSatF32UOp => I32TruncSatF32U
     |     I32TruncSatF64SOp => I32TruncSatF64S
     |     I32TruncSatF64UOp => I32TruncSatF64U
     |     I64TruncSatF32SOp => I64TruncSatF32S
     |     I64TruncSatF32UOp => I64TruncSatF32U
     |     I64TruncSatF64SOp => I64TruncSatF64S
     |     I64TruncSatF64UOp => I64TruncSatF64U
     |     // SIMD v128 -> v128
 686 |     V128NotOp => V128Not
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16AbsOp => I8x16Abs
     |     I8x16NegOp => I8x16Neg
     |     I8x16PopcntOp => I8x16Popcnt
     |     I16x8AbsOp => I16x8Abs
     |     I16x8NegOp => I16x8Neg
     |     I32x4AbsOp => I32x4Abs
     |     I32x4NegOp => I32x4Neg
     |     I64x2AbsOp => I64x2Abs
     |     I64x2NegOp => I64x2Neg
     |     F32x4AbsOp => F32x4Abs
     |     F32x4NegOp => F32x4Neg
     |     F32x4SqrtOp => F32x4Sqrt
     |     F32x4CeilOp => F32x4Ceil
     |     F32x4FloorOp => F32x4Floor
     |     F32x4TruncOp => F32x4Trunc
     |     F32x4NearestOp => F32x4Nearest
     |     F64x2AbsOp => F64x2Abs
     |     F64x2NegOp => F64x2Neg
     |     F64x2SqrtOp => F64x2Sqrt
     |     F64x2CeilOp => F64x2Ceil
     |     F64x2FloorOp => F64x2Floor
     |     F64x2TruncOp => F64x2Trunc
     |     F64x2NearestOp => F64x2Nearest
     |     // SIMD v128 -> i32
 711 |     V128AnyTrueOp => V128AnyTrue
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16AllTrueOp => I8x16AllTrue
     |     I8x16BitmaskOp => I8x16Bitmask
     |     I16x8AllTrueOp => I16x8AllTrue
     |     I16x8BitmaskOp => I16x8Bitmask
     |     I32x4AllTrueOp => I32x4AllTrue
     |     I32x4BitmaskOp => I32x4Bitmask
     |     I64x2AllTrueOp => I64x2AllTrue
     |     I64x2BitmaskOp => I64x2Bitmask
     |     // SIMD extend
 721 |     I16x8ExtendLowI8x16SOp => I16x8ExtendLowI8x16S
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8ExtendHighI8x16SOp => I16x8ExtendHighI8x16S
     |     I16x8ExtendLowI8x16UOp => I16x8ExtendLowI8x16U
     |     I16x8ExtendHighI8x16UOp => I16x8ExtendHighI8x16U
     |     I32x4ExtendLowI16x8SOp => I32x4ExtendLowI16x8S
     |     I32x4ExtendHighI16x8SOp => I32x4ExtendHighI16x8S
     |     I32x4ExtendLowI16x8UOp => I32x4ExtendLowI16x8U
     |     I32x4ExtendHighI16x8UOp => I32x4ExtendHighI16x8U
     |     I64x2ExtendLowI32x4SOp => I64x2ExtendLowI32x4S
     |     I64x2ExtendHighI32x4SOp => I64x2ExtendHighI32x4S
     |     I64x2ExtendLowI32x4UOp => I64x2ExtendLowI32x4U
     |     I64x2ExtendHighI32x4UOp => I64x2ExtendHighI32x4U
     |     // SIMD pairwise add
 734 |     I16x8ExtaddPairwiseI8x16SOp => I16x8ExtaddPairwiseI8x16S
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8ExtaddPairwiseI8x16UOp => I16x8ExtaddPairwiseI8x16U
     |     I32x4ExtaddPairwiseI16x8SOp => I32x4ExtaddPairwiseI16x8S
     |     I32x4ExtaddPairwiseI16x8UOp => I32x4ExtaddPairwiseI16x8U
     |     // SIMD conversion
 739 |     F32x4DemoteF64x2ZeroOp => F32x4DemoteF64x2Zero
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64x2PromoteLowF32x4Op => F64x2PromoteLowF32x4
     |     I32x4TruncSatF32x4SOp => I32x4TruncSatF32x4S
     |     I32x4TruncSatF32x4UOp => I32x4TruncSatF32x4U
     |     F32x4ConvertI32x4SOp => F32x4ConvertI32x4S
     |     F32x4ConvertI32x4UOp => F32x4ConvertI32x4U
     |     I32x4TruncSatF64x2SZeroOp => I32x4TruncSatF64x2SZero
     |     I32x4TruncSatF64x2UZeroOp => I32x4TruncSatF64x2UZero
     |     F64x2ConvertLowI32x4SOp => F64x2ConvertLowI32x4S
     |     F64x2ConvertLowI32x4UOp => F64x2ConvertLowI32x4U
     |     // SIMD relaxed truncation
 750 |     I32x4RelaxedTruncF32x4SOp => I32x4RelaxedTruncF32x4S
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4RelaxedTruncF32x4UOp => I32x4RelaxedTruncF32x4U
     |     I32x4RelaxedTruncZeroF64x2SOp => I32x4RelaxedTruncZeroF64x2S
     |     I32x4RelaxedTruncZeroF64x2UOp => I32x4RelaxedTruncZeroF64x2U
     |   }
     | }
     …

     | fn binary_op_to_instr(op : BinaryOp) -> Instruction {
 759 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32EqOp => I32Eq
     |     I32NeOp => I32Ne
     |     I32LtSOp => I32LtS
     |     I32LtUOp => I32LtU
     |     I32GtSOp => I32GtS
     |     I32GtUOp => I32GtU
     |     I32LeSOp => I32LeS
     |     I32LeUOp => I32LeU
     |     I32GeSOp => I32GeS
     |     I32GeUOp => I32GeU
     |     I64EqOp => I64Eq
     |     I64NeOp => I64Ne
     |     I64LtSOp => I64LtS
     |     I64LtUOp => I64LtU
     |     I64GtSOp => I64GtS
     |     I64GtUOp => I64GtU
     |     I64LeSOp => I64LeS
     |     I64LeUOp => I64LeU
     |     I64GeSOp => I64GeS
     |     I64GeUOp => I64GeU
     |     F32EqOp => F32Eq
     |     F32NeOp => F32Ne
     |     F32LtOp => F32Lt
     |     F32GtOp => F32Gt
     |     F32LeOp => F32Le
     |     F32GeOp => F32Ge
     |     F64EqOp => F64Eq
     |     F64NeOp => F64Ne
     |     F64LtOp => F64Lt
     |     F64GtOp => F64Gt
     |     F64LeOp => F64Le
     |     F64GeOp => F64Ge
     |     I32AddOp => I32Add
     |     I32SubOp => I32Sub
     |     I32MulOp => I32Mul
     |     I32DivSOp => I32DivS
     |     I32DivUOp => I32DivU
     |     I32RemSOp => I32RemS
     |     I32RemUOp => I32RemU
     |     I32AndOp => I32And
     |     I32OrOp => I32Or
     |     I32XorOp => I32Xor
     |     I32ShlOp => I32Shl
     |     I32ShrSOp => I32ShrS
     |     I32ShrUOp => I32ShrU
     |     I32RotlOp => I32Rotl
     |     I32RotrOp => I32Rotr
     |     I64AddOp => I64Add
     |     I64SubOp => I64Sub
     |     I64MulOp => I64Mul
     |     I64DivSOp => I64DivS
     |     I64DivUOp => I64DivU
     |     I64RemSOp => I64RemS
     |     I64RemUOp => I64RemU
     |     I64AndOp => I64And
     |     I64OrOp => I64Or
     |     I64XorOp => I64Xor
     |     I64ShlOp => I64Shl
     |     I64ShrSOp => I64ShrS
     |     I64ShrUOp => I64ShrU
     |     I64RotlOp => I64Rotl
     |     I64RotrOp => I64Rotr
     |     F32AddOp => F32Add
     |     F32SubOp => F32Sub
     |     F32MulOp => F32Mul
     |     F32DivOp => F32Div
     |     F32MinOp => F32Min
     |     F32MaxOp => F32Max
     |     F32CopysignOp => F32Copysign
     |     F64AddOp => F64Add
     |     F64SubOp => F64Sub
     |     F64MulOp => F64Mul
     |     F64DivOp => F64Div
     |     F64MinOp => F64Min
     |     F64MaxOp => F64Max
     |     F64CopysignOp => F64Copysign
     |     // SIMD bitwise
 837 |     V128AndOp => V128And
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128AndnotOp => V128Andnot
     |     V128OrOp => V128Or
     |     V128XorOp => V128Xor
     |     // SIMD i8x16 comparisons
 842 |     I8x16EqOp => I8x16Eq
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16NeOp => I8x16Ne
     |     I8x16LtSOp => I8x16LtS
     |     I8x16LtUOp => I8x16LtU
     |     I8x16GtSOp => I8x16GtS
     |     I8x16GtUOp => I8x16GtU
     |     I8x16LeSOp => I8x16LeS
     |     I8x16LeUOp => I8x16LeU
     |     I8x16GeSOp => I8x16GeS
     |     I8x16GeUOp => I8x16GeU
     |     // SIMD i16x8 comparisons
 853 |     I16x8EqOp => I16x8Eq
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8NeOp => I16x8Ne
     |     I16x8LtSOp => I16x8LtS
     |     I16x8LtUOp => I16x8LtU
     |     I16x8GtSOp => I16x8GtS
     |     I16x8GtUOp => I16x8GtU
     |     I16x8LeSOp => I16x8LeS
     |     I16x8LeUOp => I16x8LeU
     |     I16x8GeSOp => I16x8GeS
     |     I16x8GeUOp => I16x8GeU
     |     // SIMD i32x4 comparisons
 864 |     I32x4EqOp => I32x4Eq
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4NeOp => I32x4Ne
     |     I32x4LtSOp => I32x4LtS
     |     I32x4LtUOp => I32x4LtU
     |     I32x4GtSOp => I32x4GtS
     |     I32x4GtUOp => I32x4GtU
     |     I32x4LeSOp => I32x4LeS
     |     I32x4LeUOp => I32x4LeU
     |     I32x4GeSOp => I32x4GeS
     |     I32x4GeUOp => I32x4GeU
     |     // SIMD i64x2 comparisons
 875 |     I64x2EqOp => I64x2Eq
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64x2NeOp => I64x2Ne
     |     I64x2LtSOp => I64x2LtS
     |     I64x2GtSOp => I64x2GtS
     |     I64x2LeSOp => I64x2LeS
     |     I64x2GeSOp => I64x2GeS
     |     // SIMD f32x4 comparisons
 882 |     F32x4EqOp => F32x4Eq
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32x4NeOp => F32x4Ne
     |     F32x4LtOp => F32x4Lt
     |     F32x4GtOp => F32x4Gt
     |     F32x4LeOp => F32x4Le
     |     F32x4GeOp => F32x4Ge
     |     // SIMD f64x2 comparisons
 889 |     F64x2EqOp => F64x2Eq
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64x2NeOp => F64x2Ne
     |     F64x2LtOp => F64x2Lt
     |     F64x2GtOp => F64x2Gt
     |     F64x2LeOp => F64x2Le
     |     F64x2GeOp => F64x2Ge
     |     // SIMD i8x16 arithmetic
 896 |     I8x16AddOp => I8x16Add
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16AddSatSOp => I8x16AddSatS
     |     I8x16AddSatUOp => I8x16AddSatU
     |     I8x16SubOp => I8x16Sub
     |     I8x16SubSatSOp => I8x16SubSatS
     |     I8x16SubSatUOp => I8x16SubSatU
     |     I8x16MinSOp => I8x16MinS
     |     I8x16MinUOp => I8x16MinU
     |     I8x16MaxSOp => I8x16MaxS
     |     I8x16MaxUOp => I8x16MaxU
     |     I8x16AvgrUOp => I8x16AvgrU
     |     I8x16NarrowI16x8SOp => I8x16NarrowI16x8S
     |     I8x16NarrowI16x8UOp => I8x16NarrowI16x8U
     |     // SIMD i16x8 arithmetic
 910 |     I16x8AddOp => I16x8Add
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8AddSatSOp => I16x8AddSatS
     |     I16x8AddSatUOp => I16x8AddSatU
     |     I16x8SubOp => I16x8Sub
     |     I16x8SubSatSOp => I16x8SubSatS
     |     I16x8SubSatUOp => I16x8SubSatU
     |     I16x8MulOp => I16x8Mul
     |     I16x8MinSOp => I16x8MinS
     |     I16x8MinUOp => I16x8MinU
     |     I16x8MaxSOp => I16x8MaxS
     |     I16x8MaxUOp => I16x8MaxU
     |     I16x8AvgrUOp => I16x8AvgrU
     |     I16x8Q15mulrSatSOp => I16x8Q15mulrSatS
     |     I16x8NarrowI32x4SOp => I16x8NarrowI32x4S
     |     I16x8NarrowI32x4UOp => I16x8NarrowI32x4U
     |     I16x8ExtmulLowI8x16SOp => I16x8ExtmulLowI8x16S
     |     I16x8ExtmulHighI8x16SOp => I16x8ExtmulHighI8x16S
     |     I16x8ExtmulLowI8x16UOp => I16x8ExtmulLowI8x16U
     |     I16x8ExtmulHighI8x16UOp => I16x8ExtmulHighI8x16U
     |     // SIMD i32x4 arithmetic
 930 |     I32x4AddOp => I32x4Add
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32x4SubOp => I32x4Sub
     |     I32x4MulOp => I32x4Mul
     |     I32x4MinSOp => I32x4MinS
     |     I32x4MinUOp => I32x4MinU
     |     I32x4MaxSOp => I32x4MaxS
     |     I32x4MaxUOp => I32x4MaxU
     |     I32x4DotI16x8SOp => I32x4DotI16x8S
     |     I32x4ExtmulLowI16x8SOp => I32x4ExtmulLowI16x8S
     |     I32x4ExtmulHighI16x8SOp => I32x4ExtmulHighI16x8S
     |     I32x4ExtmulLowI16x8UOp => I32x4ExtmulLowI16x8U
     |     I32x4ExtmulHighI16x8UOp => I32x4ExtmulHighI16x8U
     |     // SIMD i64x2 arithmetic
 943 |     I64x2AddOp => I64x2Add
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64x2SubOp => I64x2Sub
     |     I64x2MulOp => I64x2Mul
     |     I64x2ExtmulLowI32x4SOp => I64x2ExtmulLowI32x4S
     |     I64x2ExtmulHighI32x4SOp => I64x2ExtmulHighI32x4S
     |     I64x2ExtmulLowI32x4UOp => I64x2ExtmulLowI32x4U
     |     I64x2ExtmulHighI32x4UOp => I64x2ExtmulHighI32x4U
     |     // SIMD f32x4 arithmetic
 951 |     F32x4AddOp => F32x4Add
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32x4SubOp => F32x4Sub
     |     F32x4MulOp => F32x4Mul
     |     F32x4DivOp => F32x4Div
     |     F32x4MinOp => F32x4Min
     |     F32x4MaxOp => F32x4Max
     |     F32x4PminOp => F32x4Pmin
     |     F32x4PmaxOp => F32x4Pmax
     |     // SIMD f64x2 arithmetic
 960 |     F64x2AddOp => F64x2Add
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64x2SubOp => F64x2Sub
     |     F64x2MulOp => F64x2Mul
     |     F64x2DivOp => F64x2Div
     |     F64x2MinOp => F64x2Min
     |     F64x2MaxOp => F64x2Max
     |     F64x2PminOp => F64x2Pmin
     |     F64x2PmaxOp => F64x2Pmax
     |     // SIMD relaxed
 969 |     F32x4RelaxedMinOp => F32x4RelaxedMin
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32x4RelaxedMaxOp => F32x4RelaxedMax
     |     F64x2RelaxedMinOp => F64x2RelaxedMin
     |     F64x2RelaxedMaxOp => F64x2RelaxedMax
     |     I16x8RelaxedQ15mulrSOp => I16x8RelaxedQ15mulrS
     |     I16x8RelaxedDotI8x16I7x16SOp => I16x8RelaxedDotI8x16I7x16S
     |   }
     | }
     …

     | fn load_op_to_instr(op : LoadOp, memarg : MemArg) -> Instruction {
 980 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32LoadOp => I32Load(memarg)
     |     I64LoadOp => I64Load(memarg)
     |     F32LoadOp => F32Load(memarg)
     |     F64LoadOp => F64Load(memarg)
     |     I32Load8SOp => I32Load8S(memarg)
     |     I32Load8UOp => I32Load8U(memarg)
     |     I32Load16SOp => I32Load16S(memarg)
     |     I32Load16UOp => I32Load16U(memarg)
     |     I64Load8SOp => I64Load8S(memarg)
     |     I64Load8UOp => I64Load8U(memarg)
     |     I64Load16SOp => I64Load16S(memarg)
     |     I64Load16UOp => I64Load16U(memarg)
     |     I64Load32SOp => I64Load32S(memarg)
     |     I64Load32UOp => I64Load32U(memarg)
     |     I32AtomicLoadOp => I32AtomicLoad(memarg)
     |     I64AtomicLoadOp => I64AtomicLoad(memarg)
     |     I32AtomicLoad8UOp => I32AtomicLoad8U(memarg)
     |     I32AtomicLoad16UOp => I32AtomicLoad16U(memarg)
     |     I64AtomicLoad8UOp => I64AtomicLoad8U(memarg)
     |     I64AtomicLoad16UOp => I64AtomicLoad16U(memarg)
     |     I64AtomicLoad32UOp => I64AtomicLoad32U(memarg)
     |     V128LoadOp => V128Load(memarg)
     |     V128Load8x8SOp => V128Load8x8S(memarg)
     |     V128Load8x8UOp => V128Load8x8U(memarg)
     |     V128Load16x4SOp => V128Load16x4S(memarg)
     |     V128Load16x4UOp => V128Load16x4U(memarg)
     |     V128Load32x2SOp => V128Load32x2S(memarg)
     |     V128Load32x2UOp => V128Load32x2U(memarg)
     |     V128Load8SplatOp => V128Load8Splat(memarg)
     |     V128Load16SplatOp => V128Load16Splat(memarg)
     |     V128Load32SplatOp => V128Load32Splat(memarg)
     |     V128Load64SplatOp => V128Load64Splat(memarg)
     |     V128Load32ZeroOp => V128Load32Zero(memarg)
     |     V128Load64ZeroOp => V128Load64Zero(memarg)
     |   }
     | }
     …

     | fn store_op_to_instr(op : StoreOp, memarg : MemArg) -> Instruction {
1020 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32StoreOp => I32Store(memarg)
     |     I64StoreOp => I64Store(memarg)
     |     F32StoreOp => F32Store(memarg)
     |     F64StoreOp => F64Store(memarg)
     |     I32Store8Op => I32Store8(memarg)
     |     I32Store16Op => I32Store16(memarg)
     |     I64Store8Op => I64Store8(memarg)
     |     I64Store16Op => I64Store16(memarg)
     |     I64Store32Op => I64Store32(memarg)
     |     I32AtomicStoreOp => I32AtomicStore(memarg)
     |     I64AtomicStoreOp => I64AtomicStore(memarg)
     |     I32AtomicStore8Op => I32AtomicStore8(memarg)
     |     I32AtomicStore16Op => I32AtomicStore16(memarg)
     |     I64AtomicStore8Op => I64AtomicStore8(memarg)
     |     I64AtomicStore16Op => I64AtomicStore16(memarg)
     |     I64AtomicStore32Op => I64AtomicStore32(memarg)
     |     V128StoreOp => V128Store(memarg)
     |   }
     | }
     …

     | fn extract_lane_op_to_instr(op : ExtractLaneOp, lane : LaneIdx) -> Instruction {
1043 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16ExtractLaneSOp => I8x16ExtractLaneS(lane)
     |     I8x16ExtractLaneUOp => I8x16ExtractLaneU(lane)
     |     I16x8ExtractLaneSOp => I16x8ExtractLaneS(lane)
     |     I16x8ExtractLaneUOp => I16x8ExtractLaneU(lane)
     |     I32x4ExtractLaneOp => I32x4ExtractLane(lane)
     |     I64x2ExtractLaneOp => I64x2ExtractLane(lane)
     |     F32x4ExtractLaneOp => F32x4ExtractLane(lane)
     |     F64x2ExtractLaneOp => F64x2ExtractLane(lane)
     |   }
     | }
     …

     | fn replace_lane_op_to_instr(op : ReplaceLaneOp, lane : LaneIdx) -> Instruction {
1057 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16ReplaceLaneOp => I8x16ReplaceLane(lane)
     |     I16x8ReplaceLaneOp => I16x8ReplaceLane(lane)
     |     I32x4ReplaceLaneOp => I32x4ReplaceLane(lane)
     |     I64x2ReplaceLaneOp => I64x2ReplaceLane(lane)
     |     F32x4ReplaceLaneOp => F32x4ReplaceLane(lane)
     |     F64x2ReplaceLaneOp => F64x2ReplaceLane(lane)
     |   }
     | }
     …

     | fn v128_shift_op_to_instr(op : V128ShiftOp) -> Instruction {
1069 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16ShlOp => I8x16Shl
     |     I8x16ShrSOp => I8x16ShrS
     |     I8x16ShrUOp => I8x16ShrU
     |     I16x8ShlOp => I16x8Shl
     |     I16x8ShrSOp => I16x8ShrS
     |     I16x8ShrUOp => I16x8ShrU
     |     I32x4ShlOp => I32x4Shl
     |     I32x4ShrSOp => I32x4ShrS
     |     I32x4ShrUOp => I32x4ShrU
     |     I64x2ShlOp => I64x2Shl
     |     I64x2ShrSOp => I64x2ShrS
     |     I64x2ShrUOp => I64x2ShrU
     |   }
     | }
     …

     | fn v128_ternary_op_to_instr(op : V128TernaryOp) -> Instruction {
1087 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     V128BitselectOp => V128Bitselect
     |     I8x16RelaxedLaneselectOp => I8x16RelaxedLaneselect
     |     I16x8RelaxedLaneselectOp => I16x8RelaxedLaneselect
     |     I32x4RelaxedLaneselectOp => I32x4RelaxedLaneselect
     |     I64x2RelaxedLaneselectOp => I64x2RelaxedLaneselect
     |     F32x4RelaxedMaddOp => F32x4RelaxedMadd
     |     F32x4RelaxedNmaddOp => F32x4RelaxedNmadd
     |     F64x2RelaxedMaddOp => F64x2RelaxedMadd
     |     F64x2RelaxedNmaddOp => F64x2RelaxedNmadd
     |     I32x4RelaxedDotI8x16I7x16AddSOp => I32x4RelaxedDotI8x16I7x16AddS
     |   }
     | }
     …

     | fn v128_load_lane_op_to_instr(
     |   op : V128LoadLaneOp,
     |   memarg : MemArg,
     |   lane : LaneIdx,
     | ) -> Instruction {
1107 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load8LaneOp => V128Load8Lane(memarg, lane)
     |     V128Load16LaneOp => V128Load16Lane(memarg, lane)
     |     V128Load32LaneOp => V128Load32Lane(memarg, lane)
     |     V128Load64LaneOp => V128Load64Lane(memarg, lane)
     |   }
     | }
     …

     | fn v128_store_lane_op_to_instr(
     |   op : V128StoreLaneOp,
     |   memarg : MemArg,
     |   lane : LaneIdx,
     | ) -> Instruction {
1121 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Store8LaneOp => V128Store8Lane(memarg, lane)
     |     V128Store16LaneOp => V128Store16Lane(memarg, lane)
     |     V128Store32LaneOp => V128Store32Lane(memarg, lane)
     |     V128Store64LaneOp => V128Store64Lane(memarg, lane)
     |   }
     | }
     …

     | pub fn tlocals_to_locals(tlocals : Array[ValType]) -> Array[Locals] {
     |   if tlocals.length() == 0 {
1132 |     return []
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let end = tlocals.length()
     |   let mut current = tlocals[0]
     |   let mut count = 1U
     |   let acc = []
     |   loop 1 {
     |     n if n == end => {
     |       acc.push(Locals(count, current))
     |       break acc
     |     }
     |     n => {
     |       let next = tlocals[n]
     |       if current == next {
     |         count = count + 1
     |       } else {
     |         acc.push(Locals(count, current))
     |         count = 1
     |         current = next
     |       }
     |       continue n + 1
     |     }
     |   }
     | }
     …

353 uncovered line(s) in src/lib/types.mbt:

     | pub fn Limits::mem_addr_bits(lim : Limits) -> Int {
     |   match lim {
     |     I32Limits(_, _) => 32
 916 |     I64Limits(_, _) => 64
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn RefType::make_nullable(rt : RefType) -> RefType {
     |   match rt {
 944 |     AbsHeapTypeRefType(ahs) => AbsHeapTypeRefType(ahs)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     HeapTypeRefType(_, ht) => HeapTypeRefType(true, ht)
     |   }
     | }
     …

     | pub fn RefType::is_defaultable(rt : RefType) -> Bool {
 951 |   rt.is_nullable()
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn RecType::get_subtype(self : RecType, idx : UInt) -> SubType? {
     |   match (self, idx) {
 973 |     (SingleRecType(st), 0) => Some(st)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (GroupRecType(sts), i) => sts.get(i.reinterpret_as_int())
 975 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn DefType::project(self : DefType) -> SubType? {
     |   let DefType(rt, n) = self
     |   match rt {
     |     SingleRecType(st) => if n == 0 { Some(st) } else { None }
 984 |     GroupRecType(sts) => sts.get(n.reinterpret_as_int())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T : Eq] equals(a : Array[T], b : Array[T]) -> Bool {
     |   if a.length() != b.length() {
1051 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for i in 0..<a.length() {
     |     if a[i] != b[i] {
     |       return false
     |     }
     |   }
     |   true
     | }
     …

     | pub fn min_addr(a : Limits, b : Limits) -> Limits {
     |   match (a, b) {
     |     (I32Limits(_), _) => a
1073 |     (_, I32Limits(_)) => b
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => a
     |   }
     | }
     …

     | pub fn Elem::reftype(self : Elem) -> RefType {
     |   match self {
     |     Elem(_, kind) =>
     |       match kind {
     |         FuncsElemKind(_) => AbsHeapTypeRefType(FuncAbsHeapType) // funcref
1084 |         FuncExprsElemKind(_) => AbsHeapTypeRefType(FuncAbsHeapType) // funcref
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TypedExprsElemKind(rt, _) => rt
     |       }
     |   }
     | }
     …

     | pub fn has_default(vt : ValType) -> Bool {
     |   match vt {
     |     NumTypeValType(_) => true
1120 |     VecTypeValType => true
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) => rt.is_nullable() // default is ref.null
1122 |     BotValType => true
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn get_struct_field(
     |   fields : Array[FieldType],
     |   i : U32,
     | ) -> Result[FieldType, String] {
     |   let U32(idx) = i
     |   match fields.get(idx.reinterpret_as_int()) {
1133 |     None => Err("struct field index out of range")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(ft) => Ok(ft)
     |   }
     | }
     …

     | pub fn min_addr_valtype(l1 : Limits, l2 : Limits) -> ValType {
     |   match (l1, l2) {
1160 |     (I64Limits(_, _), I64Limits(_, _)) => NumTypeValType(I64NumType)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => NumTypeValType(I32NumType)
     |   }
     | }
     …

     | pub fn Mut::const_() -> Mut {
2092 |   Const
     |   ^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn rec_idx(idx : UInt) -> TypeIdx {
2122 |   RecIdx(idx)
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn sub_type(f : Bool, supers : Array[TypeIdx], ct : CompType) -> SubType {
2142 |   SubType(f, supers, ct)
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn group_rec_type(sts : Array[SubType]) -> RecType {
2157 |   GroupRecType(sts)
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn func_extern_type(idx : TypeIdx) -> ExternType {
2172 |   FuncExternType(idx)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn table_extern_type(tt : TableType) -> ExternType {
2177 |   TableExternType(tt)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn mem_type(l : Limits) -> MemType {
2182 |   MemType(l)
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn mem_extern_type(mt : MemType) -> ExternType {
2187 |   MemExternType(mt)
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn global_type(vt : ValType, nullable : Bool) -> GlobalType {
2192 |   GlobalType(vt, nullable)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn global_extern_type(gt : GlobalType) -> ExternType {
2197 |   GlobalExternType(gt)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn tag_type(idx : TypeIdx) -> TagType {
2202 |   TagType(idx)
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn tag_extern_type(tt : TagType) -> ExternType {
2207 |   TagExternType(tt)
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn func_extern_idx(fi : FuncIdx) -> ExternIdx {
2217 |   FuncExternIdx(fi)
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn table_extern_idx(ti : TableIdx) -> ExternIdx {
2227 |   TableExternIdx(ti)
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn mem_extern_idx(mi : MemIdx) -> ExternIdx {
2232 |   MemExternIdx(mi)
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn global_idx(idx : UInt) -> GlobalIdx {
2237 |   GlobalIdx(idx)
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn global_extern_idx(gi : GlobalIdx) -> ExternIdx {
2242 |   GlobalExternIdx(gi)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn tag_extern_idx(ti : TagIdx) -> ExternIdx {
2247 |   TagExternIdx(ti)
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_load(ma : MemArg) -> Instruction {
2599 |   I64AtomicLoad(ma)
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i32_atomic_load8_u(ma : MemArg) -> Instruction {
2604 |   I32AtomicLoad8U(ma)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i32_atomic_load16_u(ma : MemArg) -> Instruction {
2609 |   I32AtomicLoad16U(ma)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_load8_u(ma : MemArg) -> Instruction {
2614 |   I64AtomicLoad8U(ma)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_load16_u(ma : MemArg) -> Instruction {
2619 |   I64AtomicLoad16U(ma)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_load32_u(ma : MemArg) -> Instruction {
2624 |   I64AtomicLoad32U(ma)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_store(ma : MemArg) -> Instruction {
2634 |   I64AtomicStore(ma)
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i32_atomic_store8(ma : MemArg) -> Instruction {
2639 |   I32AtomicStore8(ma)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i32_atomic_store16(ma : MemArg) -> Instruction {
2644 |   I32AtomicStore16(ma)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_store8(ma : MemArg) -> Instruction {
2649 |   I64AtomicStore8(ma)
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_store16(ma : MemArg) -> Instruction {
2654 |   I64AtomicStore16(ma)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Instruction::i64_atomic_store32(ma : MemArg) -> Instruction {
2659 |   I64AtomicStore32(ma)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::i31_get_s(i : TInstr) -> TInstr {
5078 |   TI31GetS(i)
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::i31_get_u(i : TInstr) -> TInstr {
5083 |   TI31GetU(i)
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::ref_i31(i : TInstr) -> TInstr {
5088 |   TRefI31(i)
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::any_convert_extern(i : TInstr) -> TInstr {
5098 |   TAnyConvertExtern(i)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::extern_convert_any(i : TInstr) -> TInstr {
5103 |   TExternConvertAny(i)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::br_on_null(
     |   li : LabelIdx,
     |   i0 : TInstr,
     |   i : Array[TInstr],
     | ) -> TInstr {
5389 |   TBrOnNull(li, i0, i)
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::br_on_non_null(
     |   li : LabelIdx,
     |   i0 : TInstr,
     |   i : Array[TInstr],
     | ) -> TInstr {
5398 |   TBrOnNonNull(li, i0, i)
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::array_init_data(
     |   ti : TypeIdx,
     |   di : DataIdx,
     |   i0 : TInstr,
     |   i1 : TInstr,
     |   i2 : TInstr,
     |   i3 : TInstr,
     | ) -> TInstr {
5570 |   TArrayInitData(ti, di, i0, i1, i2, i3)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::i8x16_splat(i : TInstr) -> TInstr {
5622 |   TI8x16Splat(i)
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::i16x8_splat(i : TInstr) -> TInstr {
5627 |   TI16x8Splat(i)
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::f32x4_splat(i : TInstr) -> TInstr {
5642 |   TF32x4Splat(i)
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::f64x2_splat(i : TInstr) -> TInstr {
5647 |   TF64x2Splat(i)
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::extract_lane(
     |   op : ExtractLaneOp,
     |   li : LaneIdx,
     |   i : TInstr,
     | ) -> TInstr {
5656 |   TExtractLane(op, li, i)
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::i8x16_swizzle(i0 : TInstr, i1 : TInstr) -> TInstr {
5698 |   TI8x16Swizzle(i0, i1)
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::i8x16_relaxed_swizzle(i0 : TInstr, i1 : TInstr) -> TInstr {
5703 |   TI8x16RelaxedSwizzle(i0, i1)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::v128_shift(op : V128ShiftOp, i0 : TInstr, i1 : TInstr) -> TInstr {
5708 |   TV128Shift(op, i0, i1)
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn TInstr::v128_ternary(
     |   op : V128TernaryOp,
     |   i0 : TInstr,
     |   i1 : TInstr,
     |   i2 : TInstr,
     | ) -> TInstr {
5718 |   TV128Ternary(op, i0, i1, i2)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32_convert_i64s() -> UnaryOp {
5920 |   F32ConvertI64SOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64_convert_i64u() -> UnaryOp {
5950 |   F64ConvertI64UOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64_extend8s() -> UnaryOp {
5990 |   I64Extend8SOp
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64_extend16s() -> UnaryOp {
5995 |   I64Extend16SOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32_trunc_sat_f32s() -> UnaryOp {
6005 |   I32TruncSatF32SOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32_trunc_sat_f64s() -> UnaryOp {
6015 |   I32TruncSatF64SOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64_trunc_sat_f32u() -> UnaryOp {
6030 |   I64TruncSatF32UOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64_trunc_sat_f64s() -> UnaryOp {
6035 |   I64TruncSatF64SOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::v128_not() -> UnaryOp {
6045 |   V128NotOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i8x16_abs() -> UnaryOp {
6050 |   I8x16AbsOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i8x16_neg() -> UnaryOp {
6055 |   I8x16NegOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i8x16_popcnt() -> UnaryOp {
6060 |   I8x16PopcntOp
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_abs() -> UnaryOp {
6065 |   I16x8AbsOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_neg() -> UnaryOp {
6070 |   I16x8NegOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_abs() -> UnaryOp {
6075 |   I32x4AbsOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_neg() -> UnaryOp {
6080 |   I32x4NegOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64x2_abs() -> UnaryOp {
6085 |   I64x2AbsOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64x2_neg() -> UnaryOp {
6090 |   I64x2NegOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_abs() -> UnaryOp {
6095 |   F32x4AbsOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_neg() -> UnaryOp {
6100 |   F32x4NegOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_sqrt() -> UnaryOp {
6105 |   F32x4SqrtOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_ceil() -> UnaryOp {
6110 |   F32x4CeilOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_floor() -> UnaryOp {
6115 |   F32x4FloorOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_trunc() -> UnaryOp {
6120 |   F32x4TruncOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_nearest() -> UnaryOp {
6125 |   F32x4NearestOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_abs() -> UnaryOp {
6130 |   F64x2AbsOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_neg() -> UnaryOp {
6135 |   F64x2NegOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_sqrt() -> UnaryOp {
6140 |   F64x2SqrtOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_ceil() -> UnaryOp {
6145 |   F64x2CeilOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_floor() -> UnaryOp {
6150 |   F64x2FloorOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_trunc() -> UnaryOp {
6155 |   F64x2TruncOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_nearest() -> UnaryOp {
6160 |   F64x2NearestOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::v128_any_true() -> UnaryOp {
6165 |   V128AnyTrueOp
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i8x16_all_true() -> UnaryOp {
6170 |   I8x16AllTrueOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i8x16_bitmask() -> UnaryOp {
6175 |   I8x16BitmaskOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_all_true() -> UnaryOp {
6180 |   I16x8AllTrueOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_bitmask() -> UnaryOp {
6185 |   I16x8BitmaskOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_all_true() -> UnaryOp {
6190 |   I32x4AllTrueOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_bitmask() -> UnaryOp {
6195 |   I32x4BitmaskOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64x2_all_true() -> UnaryOp {
6200 |   I64x2AllTrueOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64x2_bitmask() -> UnaryOp {
6205 |   I64x2BitmaskOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_extend_high_i8x16s() -> UnaryOp {
6215 |   I16x8ExtendHighI8x16SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_extend_high_i8x16u() -> UnaryOp {
6225 |   I16x8ExtendHighI8x16UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_extend_high_i16x8s() -> UnaryOp {
6235 |   I32x4ExtendHighI16x8SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_extend_high_i16x8u() -> UnaryOp {
6245 |   I32x4ExtendHighI16x8UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64x2_extend_high_i32x4s() -> UnaryOp {
6255 |   I64x2ExtendHighI32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i64x2_extend_high_i32x4u() -> UnaryOp {
6265 |   I64x2ExtendHighI32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_extadd_pairwise_i8x16s() -> UnaryOp {
6270 |   I16x8ExtaddPairwiseI8x16SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i16x8_extadd_pairwise_i8x16u() -> UnaryOp {
6275 |   I16x8ExtaddPairwiseI8x16UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_extadd_pairwise_i16x8s() -> UnaryOp {
6280 |   I32x4ExtaddPairwiseI16x8SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_extadd_pairwise_i16x8u() -> UnaryOp {
6285 |   I32x4ExtaddPairwiseI16x8UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_demote_f64x2_zero() -> UnaryOp {
6290 |   F32x4DemoteF64x2ZeroOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_promote_low_f32x4() -> UnaryOp {
6295 |   F64x2PromoteLowF32x4Op
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_trunc_sat_f32x4s() -> UnaryOp {
6300 |   I32x4TruncSatF32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_trunc_sat_f32x4u() -> UnaryOp {
6305 |   I32x4TruncSatF32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_convert_i32x4s() -> UnaryOp {
6310 |   F32x4ConvertI32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f32x4_convert_i32x4u() -> UnaryOp {
6315 |   F32x4ConvertI32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_trunc_sat_f64x2s_zero() -> UnaryOp {
6320 |   I32x4TruncSatF64x2SZeroOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_trunc_sat_f64x2u_zero() -> UnaryOp {
6325 |   I32x4TruncSatF64x2UZeroOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_convert_low_i32x4s() -> UnaryOp {
6330 |   F64x2ConvertLowI32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::f64x2_convert_low_i32x4u() -> UnaryOp {
6335 |   F64x2ConvertLowI32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_relaxed_trunc_f32x4s() -> UnaryOp {
6340 |   I32x4RelaxedTruncF32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_relaxed_trunc_f32x4u() -> UnaryOp {
6345 |   I32x4RelaxedTruncF32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_relaxed_trunc_zero_f64x2s() -> UnaryOp {
6350 |   I32x4RelaxedTruncZeroF64x2SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn UnaryOp::i32x4_relaxed_trunc_zero_f64x2u() -> UnaryOp {
6355 |   I32x4RelaxedTruncZeroF64x2UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::v128_and() -> BinaryOp {
6740 |   V128AndOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::v128_andnot() -> BinaryOp {
6745 |   V128AndnotOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::v128_or() -> BinaryOp {
6750 |   V128OrOp
     |   ^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::v128_xor() -> BinaryOp {
6755 |   V128XorOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_eq() -> BinaryOp {
6760 |   I8x16EqOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_ne() -> BinaryOp {
6765 |   I8x16NeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_lt_s() -> BinaryOp {
6770 |   I8x16LtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_lt_u() -> BinaryOp {
6775 |   I8x16LtUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_gt_s() -> BinaryOp {
6780 |   I8x16GtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_gt_u() -> BinaryOp {
6785 |   I8x16GtUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_le_s() -> BinaryOp {
6790 |   I8x16LeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_le_u() -> BinaryOp {
6795 |   I8x16LeUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_ge_s() -> BinaryOp {
6800 |   I8x16GeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_ge_u() -> BinaryOp {
6805 |   I8x16GeUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_eq() -> BinaryOp {
6810 |   I16x8EqOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_ne() -> BinaryOp {
6815 |   I16x8NeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_lt_s() -> BinaryOp {
6820 |   I16x8LtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_lt_u() -> BinaryOp {
6825 |   I16x8LtUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_gt_s() -> BinaryOp {
6830 |   I16x8GtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_gt_u() -> BinaryOp {
6835 |   I16x8GtUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_le_s() -> BinaryOp {
6840 |   I16x8LeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_le_u() -> BinaryOp {
6845 |   I16x8LeUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_ge_s() -> BinaryOp {
6850 |   I16x8GeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_ge_u() -> BinaryOp {
6855 |   I16x8GeUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_eq() -> BinaryOp {
6860 |   I32x4EqOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_ne() -> BinaryOp {
6865 |   I32x4NeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_lt_s() -> BinaryOp {
6870 |   I32x4LtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_lt_u() -> BinaryOp {
6875 |   I32x4LtUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_gt_s() -> BinaryOp {
6880 |   I32x4GtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_gt_u() -> BinaryOp {
6885 |   I32x4GtUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_le_s() -> BinaryOp {
6890 |   I32x4LeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_le_u() -> BinaryOp {
6895 |   I32x4LeUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_ge_s() -> BinaryOp {
6900 |   I32x4GeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_ge_u() -> BinaryOp {
6905 |   I32x4GeUOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_eq() -> BinaryOp {
6910 |   I64x2EqOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_ne() -> BinaryOp {
6915 |   I64x2NeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_lt_s() -> BinaryOp {
6920 |   I64x2LtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_gt_s() -> BinaryOp {
6925 |   I64x2GtSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_le_s() -> BinaryOp {
6930 |   I64x2LeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_ge_s() -> BinaryOp {
6935 |   I64x2GeSOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_eq() -> BinaryOp {
6940 |   F32x4EqOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_ne() -> BinaryOp {
6945 |   F32x4NeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_lt() -> BinaryOp {
6950 |   F32x4LtOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_gt() -> BinaryOp {
6955 |   F32x4GtOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_le() -> BinaryOp {
6960 |   F32x4LeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_ge() -> BinaryOp {
6965 |   F32x4GeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_eq() -> BinaryOp {
6970 |   F64x2EqOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_ne() -> BinaryOp {
6975 |   F64x2NeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_lt() -> BinaryOp {
6980 |   F64x2LtOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_gt() -> BinaryOp {
6985 |   F64x2GtOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_le() -> BinaryOp {
6990 |   F64x2LeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_ge() -> BinaryOp {
6995 |   F64x2GeOp
     |   ^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_add() -> BinaryOp {
7000 |   I8x16AddOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_add_sat_s() -> BinaryOp {
7005 |   I8x16AddSatSOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_add_sat_u() -> BinaryOp {
7010 |   I8x16AddSatUOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_sub() -> BinaryOp {
7015 |   I8x16SubOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_sub_sat_s() -> BinaryOp {
7020 |   I8x16SubSatSOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_sub_sat_u() -> BinaryOp {
7025 |   I8x16SubSatUOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_min_s() -> BinaryOp {
7030 |   I8x16MinSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_min_u() -> BinaryOp {
7035 |   I8x16MinUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_max_s() -> BinaryOp {
7040 |   I8x16MaxSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_max_u() -> BinaryOp {
7045 |   I8x16MaxUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_avgr_u() -> BinaryOp {
7050 |   I8x16AvgrUOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_narrow_i16x8s() -> BinaryOp {
7055 |   I8x16NarrowI16x8SOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i8x16_narrow_i16x8u() -> BinaryOp {
7060 |   I8x16NarrowI16x8UOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_add() -> BinaryOp {
7065 |   I16x8AddOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_add_sat_s() -> BinaryOp {
7070 |   I16x8AddSatSOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_add_sat_u() -> BinaryOp {
7075 |   I16x8AddSatUOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_sub() -> BinaryOp {
7080 |   I16x8SubOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_sub_sat_s() -> BinaryOp {
7085 |   I16x8SubSatSOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_sub_sat_u() -> BinaryOp {
7090 |   I16x8SubSatUOp
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_mul() -> BinaryOp {
7095 |   I16x8MulOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_min_s() -> BinaryOp {
7100 |   I16x8MinSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_min_u() -> BinaryOp {
7105 |   I16x8MinUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_max_s() -> BinaryOp {
7110 |   I16x8MaxSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_max_u() -> BinaryOp {
7115 |   I16x8MaxUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_avgr_u() -> BinaryOp {
7120 |   I16x8AvgrUOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8q15mulr_sat_s() -> BinaryOp {
7125 |   I16x8Q15mulrSatSOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_narrow_i32x4s() -> BinaryOp {
7130 |   I16x8NarrowI32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_narrow_i32x4u() -> BinaryOp {
7135 |   I16x8NarrowI32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_extmul_low_i8x16s() -> BinaryOp {
7140 |   I16x8ExtmulLowI8x16SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_extmul_high_i8x16s() -> BinaryOp {
7145 |   I16x8ExtmulHighI8x16SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_extmul_low_i8x16u() -> BinaryOp {
7150 |   I16x8ExtmulLowI8x16UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_extmul_high_i8x16u() -> BinaryOp {
7155 |   I16x8ExtmulHighI8x16UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_add() -> BinaryOp {
7160 |   I32x4AddOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_sub() -> BinaryOp {
7165 |   I32x4SubOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_mul() -> BinaryOp {
7170 |   I32x4MulOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_min_s() -> BinaryOp {
7175 |   I32x4MinSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_min_u() -> BinaryOp {
7180 |   I32x4MinUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_max_s() -> BinaryOp {
7185 |   I32x4MaxSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_max_u() -> BinaryOp {
7190 |   I32x4MaxUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_dot_i16x8s() -> BinaryOp {
7195 |   I32x4DotI16x8SOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_extmul_low_i16x8s() -> BinaryOp {
7200 |   I32x4ExtmulLowI16x8SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_extmul_high_i16x8s() -> BinaryOp {
7205 |   I32x4ExtmulHighI16x8SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_extmul_low_i16x8u() -> BinaryOp {
7210 |   I32x4ExtmulLowI16x8UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i32x4_extmul_high_i16x8u() -> BinaryOp {
7215 |   I32x4ExtmulHighI16x8UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_add() -> BinaryOp {
7220 |   I64x2AddOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_sub() -> BinaryOp {
7225 |   I64x2SubOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_mul() -> BinaryOp {
7230 |   I64x2MulOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_extmul_low_i32x4s() -> BinaryOp {
7235 |   I64x2ExtmulLowI32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_extmul_high_i32x4s() -> BinaryOp {
7240 |   I64x2ExtmulHighI32x4SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_extmul_low_i32x4u() -> BinaryOp {
7245 |   I64x2ExtmulLowI32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i64x2_extmul_high_i32x4u() -> BinaryOp {
7250 |   I64x2ExtmulHighI32x4UOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_add() -> BinaryOp {
7255 |   F32x4AddOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_sub() -> BinaryOp {
7260 |   F32x4SubOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_mul() -> BinaryOp {
7265 |   F32x4MulOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_div() -> BinaryOp {
7270 |   F32x4DivOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_min() -> BinaryOp {
7275 |   F32x4MinOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_max() -> BinaryOp {
7280 |   F32x4MaxOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_pmin() -> BinaryOp {
7285 |   F32x4PminOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_pmax() -> BinaryOp {
7290 |   F32x4PmaxOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_add() -> BinaryOp {
7295 |   F64x2AddOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_sub() -> BinaryOp {
7300 |   F64x2SubOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_mul() -> BinaryOp {
7305 |   F64x2MulOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_div() -> BinaryOp {
7310 |   F64x2DivOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_min() -> BinaryOp {
7315 |   F64x2MinOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_max() -> BinaryOp {
7320 |   F64x2MaxOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_pmin() -> BinaryOp {
7325 |   F64x2PminOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_pmax() -> BinaryOp {
7330 |   F64x2PmaxOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_relaxed_min() -> BinaryOp {
7335 |   F32x4RelaxedMinOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f32x4_relaxed_max() -> BinaryOp {
7340 |   F32x4RelaxedMaxOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_relaxed_min() -> BinaryOp {
7345 |   F64x2RelaxedMinOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::f64x2_relaxed_max() -> BinaryOp {
7350 |   F64x2RelaxedMaxOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_relaxed_q15mulr_s() -> BinaryOp {
7355 |   I16x8RelaxedQ15mulrSOp
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BinaryOp::i16x8_relaxed_dot_i8x16i7x16s() -> BinaryOp {
7360 |   I16x8RelaxedDotI8x16I7x16SOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i64_load8s() -> LoadOp {
7405 |   I64Load8SOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i64_load16s() -> LoadOp {
7415 |   I64Load16SOp
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i64_atomic_load() -> LoadOp {
7440 |   I64AtomicLoadOp
     |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i32_atomic_load8_u() -> LoadOp {
7445 |   I32AtomicLoad8UOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i32_atomic_load16_u() -> LoadOp {
7450 |   I32AtomicLoad16UOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i64_atomic_load8_u() -> LoadOp {
7455 |   I64AtomicLoad8UOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i64_atomic_load16_u() -> LoadOp {
7460 |   I64AtomicLoad16UOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::i64_atomic_load32_u() -> LoadOp {
7465 |   I64AtomicLoad32UOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::v128_load8_splat() -> LoadOp {
7505 |   V128Load8SplatOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn LoadOp::v128_load16_splat() -> LoadOp {
7510 |   V128Load16SplatOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn StoreOp::i64_atomic_store() -> StoreOp {
7585 |   I64AtomicStoreOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn StoreOp::i32_atomic_store8() -> StoreOp {
7590 |   I32AtomicStore8Op
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn StoreOp::i32_atomic_store16() -> StoreOp {
7595 |   I32AtomicStore16Op
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn StoreOp::i64_atomic_store8() -> StoreOp {
7600 |   I64AtomicStore8Op
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn StoreOp::i64_atomic_store16() -> StoreOp {
7605 |   I64AtomicStore16Op
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn StoreOp::i64_atomic_store32() -> StoreOp {
7610 |   I64AtomicStore32Op
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_add() -> AtomicRmwOp {
7625 |   I64AtomicRmwAddOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_8_add_u() -> AtomicRmwOp {
7630 |   I32AtomicRmw8AddUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_16_add_u() -> AtomicRmwOp {
7635 |   I32AtomicRmw16AddUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_8_add_u() -> AtomicRmwOp {
7640 |   I64AtomicRmw8AddUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_16_add_u() -> AtomicRmwOp {
7645 |   I64AtomicRmw16AddUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_32_add_u() -> AtomicRmwOp {
7650 |   I64AtomicRmw32AddUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_sub() -> AtomicRmwOp {
7655 |   I32AtomicRmwSubOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_sub() -> AtomicRmwOp {
7660 |   I64AtomicRmwSubOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_8_sub_u() -> AtomicRmwOp {
7665 |   I32AtomicRmw8SubUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_16_sub_u() -> AtomicRmwOp {
7670 |   I32AtomicRmw16SubUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_8_sub_u() -> AtomicRmwOp {
7675 |   I64AtomicRmw8SubUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_16_sub_u() -> AtomicRmwOp {
7680 |   I64AtomicRmw16SubUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_32_sub_u() -> AtomicRmwOp {
7685 |   I64AtomicRmw32SubUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_and() -> AtomicRmwOp {
7690 |   I32AtomicRmwAndOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_and() -> AtomicRmwOp {
7695 |   I64AtomicRmwAndOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_8_and_u() -> AtomicRmwOp {
7700 |   I32AtomicRmw8AndUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_16_and_u() -> AtomicRmwOp {
7705 |   I32AtomicRmw16AndUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_8_and_u() -> AtomicRmwOp {
7710 |   I64AtomicRmw8AndUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_16_and_u() -> AtomicRmwOp {
7715 |   I64AtomicRmw16AndUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_32_and_u() -> AtomicRmwOp {
7720 |   I64AtomicRmw32AndUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_or() -> AtomicRmwOp {
7725 |   I32AtomicRmwOrOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_or() -> AtomicRmwOp {
7730 |   I64AtomicRmwOrOp
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_8_or_u() -> AtomicRmwOp {
7735 |   I32AtomicRmw8OrUOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_16_or_u() -> AtomicRmwOp {
7740 |   I32AtomicRmw16OrUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_8_or_u() -> AtomicRmwOp {
7745 |   I64AtomicRmw8OrUOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_16_or_u() -> AtomicRmwOp {
7750 |   I64AtomicRmw16OrUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_32_or_u() -> AtomicRmwOp {
7755 |   I64AtomicRmw32OrUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_xor() -> AtomicRmwOp {
7760 |   I32AtomicRmwXorOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_xor() -> AtomicRmwOp {
7765 |   I64AtomicRmwXorOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_8_xor_u() -> AtomicRmwOp {
7770 |   I32AtomicRmw8XorUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_16_xor_u() -> AtomicRmwOp {
7775 |   I32AtomicRmw16XorUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_8_xor_u() -> AtomicRmwOp {
7780 |   I64AtomicRmw8XorUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_16_xor_u() -> AtomicRmwOp {
7785 |   I64AtomicRmw16XorUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_32_xor_u() -> AtomicRmwOp {
7790 |   I64AtomicRmw32XorUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_xchg() -> AtomicRmwOp {
7795 |   I32AtomicRmwXchgOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_xchg() -> AtomicRmwOp {
7800 |   I64AtomicRmwXchgOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_8_xchg_u() -> AtomicRmwOp {
7805 |   I32AtomicRmw8XchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i32_16_xchg_u() -> AtomicRmwOp {
7810 |   I32AtomicRmw16XchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_8_xchg_u() -> AtomicRmwOp {
7815 |   I64AtomicRmw8XchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_16_xchg_u() -> AtomicRmwOp {
7820 |   I64AtomicRmw16XchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicRmwOp::i64_32_xchg_u() -> AtomicRmwOp {
7825 |   I64AtomicRmw32XchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicCmpxchgOp::i32_8_u() -> AtomicCmpxchgOp {
7840 |   I32AtomicRmw8CmpxchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicCmpxchgOp::i32_16_u() -> AtomicCmpxchgOp {
7845 |   I32AtomicRmw16CmpxchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicCmpxchgOp::i64_8_u() -> AtomicCmpxchgOp {
7850 |   I64AtomicRmw8CmpxchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicCmpxchgOp::i64_16_u() -> AtomicCmpxchgOp {
7855 |   I64AtomicRmw16CmpxchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn AtomicCmpxchgOp::i64_32_u() -> AtomicCmpxchgOp {
7860 |   I64AtomicRmw32CmpxchgUOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::i8x16_extract_lane_u() -> ExtractLaneOp {
7870 |   I8x16ExtractLaneUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::i16x8_extract_lane_s() -> ExtractLaneOp {
7875 |   I16x8ExtractLaneSOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::i16x8_extract_lane_u() -> ExtractLaneOp {
7880 |   I16x8ExtractLaneUOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::i32x4_extract_lane() -> ExtractLaneOp {
7885 |   I32x4ExtractLaneOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::i64x2_extract_lane() -> ExtractLaneOp {
7890 |   I64x2ExtractLaneOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::f32x4_extract_lane() -> ExtractLaneOp {
7895 |   F32x4ExtractLaneOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ExtractLaneOp::f64x2_extract_lane() -> ExtractLaneOp {
7900 |   F64x2ExtractLaneOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ReplaceLaneOp::f32x4_replace_lane() -> ReplaceLaneOp {
7925 |   F32x4ReplaceLaneOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn ReplaceLaneOp::f64x2_replace_lane() -> ReplaceLaneOp {
7930 |   F64x2ReplaceLaneOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i8x16_shr_s() -> V128ShiftOp {
7940 |   I8x16ShrSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i8x16_shr_u() -> V128ShiftOp {
7945 |   I8x16ShrUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i16x8_shl() -> V128ShiftOp {
7950 |   I16x8ShlOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i16x8_shr_s() -> V128ShiftOp {
7955 |   I16x8ShrSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i16x8_shr_u() -> V128ShiftOp {
7960 |   I16x8ShrUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i32x4_shl() -> V128ShiftOp {
7965 |   I32x4ShlOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i32x4_shr_s() -> V128ShiftOp {
7970 |   I32x4ShrSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i32x4_shr_u() -> V128ShiftOp {
7975 |   I32x4ShrUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i64x2_shl() -> V128ShiftOp {
7980 |   I64x2ShlOp
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i64x2_shr_s() -> V128ShiftOp {
7985 |   I64x2ShrSOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128ShiftOp::i64x2_shr_u() -> V128ShiftOp {
7990 |   I64x2ShrUOp
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::i8x16_relaxed_laneselect() -> V128TernaryOp {
8000 |   I8x16RelaxedLaneselectOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::i16x8_relaxed_laneselect() -> V128TernaryOp {
8005 |   I16x8RelaxedLaneselectOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::i32x4_relaxed_laneselect() -> V128TernaryOp {
8010 |   I32x4RelaxedLaneselectOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::i64x2_relaxed_laneselect() -> V128TernaryOp {
8015 |   I64x2RelaxedLaneselectOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::f32x4_relaxed_madd() -> V128TernaryOp {
8020 |   F32x4RelaxedMaddOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::f32x4_relaxed_nmadd() -> V128TernaryOp {
8025 |   F32x4RelaxedNmaddOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::f64x2_relaxed_madd() -> V128TernaryOp {
8030 |   F64x2RelaxedMaddOp
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::f64x2_relaxed_nmadd() -> V128TernaryOp {
8035 |   F64x2RelaxedNmaddOp
     |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128TernaryOp::i32x4_relaxed_dot_i8x16i7x16_add_s() -> V128TernaryOp {
8040 |   I32x4RelaxedDotI8x16I7x16AddSOp
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128StoreLaneOp::v128_store16_lane() -> V128StoreLaneOp {
8070 |   V128Store16LaneOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128StoreLaneOp::v128_store32_lane() -> V128StoreLaneOp {
8075 |   V128Store32LaneOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn V128StoreLaneOp::v128_store64_lane() -> V128StoreLaneOp {
8080 |   V128Store64LaneOp
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn HeapType::is_struct(self : Self) -> Bool {
8090 |   match self {
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     DefTypeHeapType(def) =>
8092 |       match def.project() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(st) =>
8094 |           match st.get_comptype() {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             StructCompType(_) => true
     |             _ => false
     |           }
8098 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
8100 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn HeapType::is_array(self : Self) -> Bool {
     |   match self {
     |     DefTypeHeapType(def) =>
8108 |       match def.project() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(st) =>
8110 |           match st.get_comptype() {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ArrayCompType(_) => true
     |             _ => false
     |           }
8114 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => false
     |   }
     | }
     …

     | pub fn HeapType::is_gc_aggregate(self : Self) -> Bool {
8122 |   self.is_struct() || self.is_array()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

1 uncovered line(s) in src/lib/util.mbt:

   | pub fn expand_locals(decls : Array[Locals]) -> Result[Array[ValType], String] {
   |   let out : Array[ValType] = []
   |   for d in decls {
   |     let Locals(n, vt) = d
   |     let count = n.reinterpret_as_int()
   |     if count < 0 {
 8 |       return Err("locals: negative count")
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     }
   |     for _ in 0..<count {
   |       out.push(vt)
   |     }
   |   }
   |   Ok(out)
   | }
   …

16 uncovered line(s) in src/passes/abstract_type_refining.mbt:

    | fn build_subtypes(mod : Module) -> SubTypes {
    |   let types = Array::new()
    |   let immediate = Map::new()
    |   let mut current_type_idx = 0
    |   if mod.type_sec is Some(type_sec) {
    |     for rec in type_sec.0 {
    |       match rec {
    |         SingleRecType(st) => {
    |           let ht = HeapType::new(
    |             TypeIdx::new(current_type_idx.reinterpret_as_uint()),
    |           )
    |           types.push(ht)
    |           immediate[ht] = st.super_types().map(HeapType::new)
    |           current_type_idx = current_type_idx + 1
    |         }
    |         GroupRecType(sts) =>
 49 |           for st in sts {
    |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             let ht = HeapType::new(
    |               TypeIdx::new(current_type_idx.reinterpret_as_uint()),
    |             )
 53 |             types.push(ht)
    |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             immediate[ht] = st.super_types().map(HeapType::new)
    |             current_type_idx = current_type_idx + 1
    |           }
    |       }
    |     }
    |   }
    |   SubTypes::{ types, immediate_sub: immediate }
    | }
    …

    | fn collect_created_types(mod : Module) -> HeapTypeSet {
    |   let set = Set::new()
    |   let transformer = ModuleTransformer::new().on_tinstruction_evt(fn(
    |     _,
    |     _,
    |     instr,
    |   ) {
    |     match instr {
    |       // ---- structs ----
 73 |       TStructNew(type_idx, _) => set.add(HeapType::new(type_idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |       // ---- arrays ----
    |       TArrayNew(type_idx, _, _)
    |       | TArrayNewDefault(type_idx, _)
    |       | TArrayNewFixed(type_idx, _)
    |       | TArrayNewData(type_idx, _, _, _)
 80 |       | TArrayNewElem(type_idx, _, _, _) => set.add(HeapType::new(type_idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => ()
    |     }
    |     unchanged()
    |   })
    |   ignore(transformer.walk_module((), mod))
    |   set
    | }
    …

    | fn compute_created_or_sub(
    |   created : HeapTypeSet,
    |   subtypes : SubTypes,
    | ) -> HeapTypeSet {
    |   let result = created.copy()
    | 
    |   // bottom‑up traversal
    |   for t in subtypes.types {
    |     let subs = subtypes.immediate_sub.get(t).unwrap_or([])
    |     for s in subs {
100 |       if result.contains(s) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         result.add(t)
    |         break
    |       }
    |     }
    |   }
    |   result
    | }
    …

    | fn compute_refinable(
    |   created : HeapTypeSet,
    |   created_or_sub : HeapTypeSet,
    |   subtypes : SubTypes,
    | ) -> HeapTypeMap {
    |   let refinable = Map::new()
    |   for t in subtypes.types {
    |     if created.contains(t) {
118 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let subs = subtypes.immediate_sub.get(t).unwrap_or([])
    |     let mut candidate : HeapType? = None
    |     for s in subs {
123 |       if created_or_sub.contains(s) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match candidate {
    |           None => candidate = Some(s)
    |           Some(_) => {
    |             candidate = None
    |             break
    |           }
    |         }
    |       }
    |     }
    |     if candidate is Some(c) {
134 |       refinable[t] = refinable.get(c).unwrap_or(c)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   refinable
    | }
    …

    | fn build_mapping(state : ATRState) -> HeapTypeMap {
    |   let mapping = Map::new()
    |   for t in state.subtypes.types {
    |     if state.traps_never_happen && !state.created_or_sub.contains(t) {
    |       mapping[t] = HeapType::bottom()
    |       continue
    |     }
    |     if state.refinable.get(t) is Some(r) {
149 |       mapping[t] = r
    |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   mapping
    | }
    …

    | fn rewrite_cast(instr : TInstr, mapping : HeapTypeMap) -> TInstr {
    |   match instr {
    |     TRefCast(nullable, ht, v) => {
    |       let new_ht = rewrite_heaptype(ht, mapping)
    |       if new_ht == ht {
    |         instr
    |       } else {
    |         TInstr::ref_cast(nullable, new_ht, v)
    |       }
    |     }
171 |     TBrOnCast(l, op, ht1, ht2, v, args) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let n1 = rewrite_heaptype(ht1, mapping)
    |       let n2 = rewrite_heaptype(ht2, mapping)
    |       TInstr::br_on_cast(l, op.0, n1, op.1, n2, v, args)
    |     }
    |     _ => instr
    |   }
    | }
    …

    | fn rewrite_descriptor_exact_ref_cast(
    |   instr : TInstr,
    |   mapping : HeapTypeMap,
    |   traps_never_happen : Bool,
    | ) -> TInstr {
    |   match instr {
    |     TRefCast(_, ht, value) =>
    |       // Exact casts must not gain success.
    |       // After normalization, this is impossible iff:
    |       //   - the type is bottom, or
    |       //   - the type was refined to something else.
    |       if traps_never_happen &&
    |         (ht == HeapType::bottom() || is_refined(ht, mapping)) {
    |         drop_then_unreachable(value)
    |       } else {
    |         instr
    |       }
232 |     _ => instr
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rewrite_descriptor_exact_br_on_cast(
    |   instr : TInstr,
    |   mapping : HeapTypeMap,
    |   traps_never_happen : Bool,
    | ) -> TInstr {
    |   match instr {
    |     TBrOnCast(label, op, src_ht, dst_ht, value, args) =>
    |       if traps_never_happen && op.1 && is_refined(dst_ht, mapping) {
    |         TInstr::br_on_cast(
    |           label,
    |           op.0,
    |           src_ht,
    |           false,
    |           HeapType::bottom(),
    |           value,
    |           args,
    |         )
    |       } else {
    |         instr
    |       }
    |     TBrOnCastFail(label, op, src_ht, dst_ht, value, args) =>
258 |       if traps_never_happen && op.1 && is_refined(dst_ht, mapping) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         TInstr::br_on_cast_fail(
    |           label,
    |           op.0,
    |           src_ht,
    |           false,
264 |           HeapType::bottom(),
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           value,
    |           args,
    |         )
    |       } else {
269 |         instr
    |         ^^^^^ 	<-- UNCOVERED
    |       }
    |     _ => instr
    |   }
    | }
    …

    | fn run_abstract_type_refining_pass(
    |   mod : Module,
    |   props : AbstractTypeRefiningPassProps,
    | ) -> Result[Module, String] {
    |   let ctx = IRContext::new()
    |   let mut mod = mod
    |   ctx.set_mod(mod)
    |   let pass = abstract_type_refining(mod, props.traps_never_happen)
    |   match pass.walk_module(ctx, mod) {
    |     Ok(Some((_, final_mod))) => mod = final_mod
286 |     Ok(None) => ()
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => return Err(e)
    |   }
    |   Ok(mod)
    | }
    …

    | fn abstract_type_refining(
    |   mod : Module,
    |   traps_never_happen : Bool,
    | ) -> ModuleTransformer[IRContext] {
    |   let state = compute_atr_state(mod, traps_never_happen)
    |   ModuleTransformer::new()
    |   .on_tinstruction_evt(fn(_, ctx : IRContext, instr) {
    |     let instr = rewrite_cast(instr, state.mapping)
    |     let instr = rewrite_descriptor_exact_ref_cast(
    |       instr,
    |       state.mapping,
    |       state.traps_never_happen,
    |     )
    |     let instr = rewrite_descriptor_exact_br_on_cast(
    |       instr,
    |       state.mapping,
    |       state.traps_never_happen,
    |     )
    |     change(ctx, instr)
    |   })
    |   .on_heaptype_evt(fn(_, ctx, ht) {
314 |     change(ctx, rewrite_heaptype(ht, state.mapping))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | }
    …

54 uncovered line(s) in src/passes/alignment_lowering.mbt:

     | fn store_op_stack_size(op : StoreOp) -> StackSize {
     |   match op {
     |     I64StoreOp => StackSize64
  29 |     I64AtomicStoreOp => StackSize64
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Store32Op => StackSize64
     |     I64AtomicStore32Op => StackSize64
     |     I64Store16Op => StackSize64
     |     I64AtomicStore16Op => StackSize64
     |     I64Store8Op => StackSize64
  35 |     I64AtomicStore8Op => StackSize64
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64StoreOp => StackSize64
     |     _ => StackSize32
     |   }
     | }
     …

     | fn load_op_with_chunk_size(
     |   stack_size : StackSize,
     |   chunk_size : ChunkSize,
     | ) -> Result[LoadOp, String] {
     |   match (stack_size, chunk_size) {
     |     (StackSize32, ChunkSize8) => Ok(LoadOp::i32_load8u())
     |     (StackSize32, ChunkSize16) => Ok(LoadOp::i32_load16u())
     |     (StackSize64, ChunkSize8) => Ok(LoadOp::i64_load8u())
     |     (StackSize64, ChunkSize16) => Ok(LoadOp::i64_load16u())
     |     (StackSize64, ChunkSize32) => Ok(LoadOp::i64_load32u())
     |     // Impossible!
  53 |     _ => Err("Invalid chunk size for value")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn store_op_with_chunk_size(
     |   stack_size : StackSize,
     |   chunk_size : ChunkSize,
     | ) -> Result[StoreOp, String] {
     |   match (stack_size, chunk_size) {
     |     (StackSize32, ChunkSize8) => Ok(StoreOp::i32_store8())
     |     (StackSize32, ChunkSize16) => Ok(StoreOp::i32_store16())
     |     (StackSize64, ChunkSize8) => Ok(StoreOp::i64_store8())
  66 |     (StackSize64, ChunkSize16) => Ok(StoreOp::i64_store16())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (StackSize64, ChunkSize32) => Ok(StoreOp::i64_store32())
     |     _ => Err("Invalid chunk size for store")
     |   }
     | }
     …

     | fn load_op_stack_size(op : LoadOp) -> StackSize {
     |   match op {
     |     V128Load64SplatOp => StackSize64
     |     I64Load32UOp => StackSize64
  94 |     I64AtomicLoad32UOp => StackSize64
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load32SOp => StackSize64
  96 |     I64Load16UOp => StackSize64
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64AtomicLoad16UOp => StackSize64
     |     I64Load16SOp => StackSize64
     |     I64Load8UOp => StackSize64
 100 |     I64AtomicLoad8UOp => StackSize64
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load8SOp => StackSize64
     |     F64LoadOp => StackSize64
     |     I64LoadOp => StackSize64
 104 |     I64AtomicLoadOp => StackSize64
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load64ZeroOp => StackSize64
     |     V128Load8x8SOp => StackSize64
     |     V128Load8x8UOp => StackSize64
     |     V128Load16x4SOp => StackSize64
     |     V128Load16x4UOp => StackSize64
     |     V128Load32x2SOp => StackSize64
     |     V128Load32x2UOp => StackSize64
     |     _ => StackSize32
     |   }
     | }
     …

     | fn size_of_load_op(t : LoadOp) -> UInt {
     |   match t {
     |     V128Load32ZeroOp => 4
     |     V128Load64SplatOp => 8
     |     V128Load32SplatOp => 4
 141 |     V128Load16SplatOp => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load8SplatOp => 1
     |     V128Load32x2UOp => 8
     |     V128Load32x2SOp => 8
     |     V128Load16x4UOp => 8
     |     V128Load16x4SOp => 8
     |     V128Load8x8UOp => 8
     |     V128Load8x8SOp => 8
     |     V128LoadOp => 16
     |     I64Load32UOp => 4
 151 |     I64AtomicLoad32UOp => 4
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load32SOp => 4
     |     I64Load16UOp => 2
 154 |     I64AtomicLoad16UOp => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load16SOp => 2
     |     I64Load8UOp => 1
 157 |     I64AtomicLoad8UOp => 1
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load8SOp => 1
     |     I32Load16UOp => 2
 160 |     I32AtomicLoad16UOp => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Load16SOp => 2
     |     I32Load8UOp => 1
 163 |     I32AtomicLoad8UOp => 1
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Load8SOp => 1
     |     F64LoadOp => 8
     |     F32LoadOp => 4
     |     I64LoadOp => 8
 168 |     I64AtomicLoadOp => 8
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32LoadOp => 4
 170 |     I32AtomicLoadOp => 4
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load64ZeroOp => 8
     |   }
     | }
     …

     | fn size_of_store_op(t : StoreOp) -> UInt {
     |   match t {
     |     I64Store32Op => 4
 179 |     I64AtomicStore32Op => 4
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Store16Op => 2
 181 |     I64AtomicStore16Op => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Store8Op => 1
 183 |     I64AtomicStore8Op => 1
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Store16Op => 2
 185 |     I32AtomicStore16Op => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Store8Op => 1
 187 |     I32AtomicStore8Op => 1
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64StoreOp => 8
     |     F32StoreOp => 4
     |     I64StoreOp => 8
 191 |     I64AtomicStoreOp => 8
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32StoreOp => 4
 193 |     I32AtomicStoreOp => 4
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128StoreOp => 16
     |   }
     | }
     …

     | fn finalize_v128_extending_load(op : LoadOp, i : TInstr) -> TInstr {
     |   let low64_in_v128 = TInstr::replace_lane(
     |     ReplaceLaneOp::i64x2_replace_lane(),
     |     LaneIdx::new(0),
     |     TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
     |     i,
     |   )
     |   match op {
     |     V128Load8x8SOp =>
     |       TInstr::unary(UnaryOp::i16x8_extend_low_i8x16s(), low64_in_v128)
     |     V128Load8x8UOp =>
     |       TInstr::unary(UnaryOp::i16x8_extend_low_i8x16u(), low64_in_v128)
     |     V128Load16x4SOp =>
     |       TInstr::unary(UnaryOp::i32x4_extend_low_i16x8s(), low64_in_v128)
     |     V128Load16x4UOp =>
     |       TInstr::unary(UnaryOp::i32x4_extend_low_i16x8u(), low64_in_v128)
     |     V128Load32x2SOp =>
     |       TInstr::unary(UnaryOp::i64x2_extend_low_i32x4s(), low64_in_v128)
     |     V128Load32x2UOp =>
     |       TInstr::unary(UnaryOp::i64x2_extend_low_i32x4u(), low64_in_v128)
 285 |     _ => low64_in_v128
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn finalize_load_op(op : LoadOp, i : TInstr) -> TInstr {
     |   match op {
     |     V128Load64SplatOp => TInstr::i64x2_splat(i)
     |     V128Load32SplatOp => TInstr::i32x4_splat(i)
 294 |     V128Load16SplatOp => TInstr::i16x8_splat(i)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load8SplatOp => TInstr::i8x16_splat(i)
     |     V128Load32ZeroOp =>
     |       TInstr::replace_lane(
     |         ReplaceLaneOp::i32x4_replace_lane(),
     |         LaneIdx::new(0),
     |         TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
     |         i,
     |       )
     |     V128Load64ZeroOp =>
     |       TInstr::replace_lane(
     |         ReplaceLaneOp::i64x2_replace_lane(),
     |         LaneIdx::new(0),
     |         TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
     |         i,
     |       )
 310 |     V128LoadOp => i
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load32UOp => i
 312 |     I64AtomicLoad32UOp => i
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load32SOp => TInstr::unary(UnaryOp::i64_extend32s(), i)
 314 |     I64Load16UOp => i
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64AtomicLoad16UOp => i
     |     I64Load16SOp => TInstr::unary(UnaryOp::i64_extend16s(), i)
     |     I64Load8UOp => i
     |     I64AtomicLoad8UOp => i
     |     I64Load8SOp => TInstr::unary(UnaryOp::i64_extend8s(), i)
     |     I32Load16UOp => i
 321 |     I32AtomicLoad16UOp => i
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Load16SOp => TInstr::unary(UnaryOp::i32_extend16s(), i)
 323 |     I32Load8UOp => i
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AtomicLoad8UOp => i
     |     I32Load8SOp => TInstr::unary(UnaryOp::i32_extend8s(), i)
     |     F64LoadOp => TInstr::unary(UnaryOp::f64_reinterpret_i64(), i)
     |     F32LoadOp => TInstr::unary(UnaryOp::f32_reinterpret_i32(), i)
     |     I64LoadOp => i
 329 |     I64AtomicLoadOp => i
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32LoadOp => i
 331 |     I32AtomicLoadOp => i
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load32x2SOp => finalize_v128_extending_load(op, i)
     |     V128Load16x4SOp => finalize_v128_extending_load(op, i)
     |     V128Load8x8SOp => finalize_v128_extending_load(op, i)
     |     V128Load32x2UOp => finalize_v128_extending_load(op, i)
     |     V128Load16x4UOp => finalize_v128_extending_load(op, i)
     |     V128Load8x8UOp => finalize_v128_extending_load(op, i)
     |   }
     | }
     …

     | fn alignment_lowering_pass(mod : Module) -> ModuleTransformer[IRContext] {
     |   let memories = match mod.mem_sec {
     |     Some(sec) => sec.0
 353 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut temp_locals : Array[ValType] = []
     |   ModuleTransformer::new()
     |   .on_func_evt(fn(self, t : IRContext, i) {
     |     match i {
 359 |       Func(_) => Err("Expected TFunc")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TFunc(locals, b) => {
     |         temp_locals = locals
     |         match self.walk_func_default(t, Func::t_func(locals, b)) {
     |           Ok(Some((t, func))) =>
     |             match func {
     |               TFunc(_, b) => {
     |                 let result_locals = temp_locals
     |                 temp_locals = []
     |                 change(t, Func::t_func(result_locals, b))
     |               }
 370 |               _ => Err("Expected TFunc")
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
 372 |           Err(t) => Err(t)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(None) => unchanged()
     |         }
     |       }
     |     }
     |   })
     |   .on_tinstruction_evt(fn(self, t, i) {
     |     match i {
     |       TLoad(op, MemArg(U32(align), mem_option, U64(offset)), a) => {
     |         let a = match self.walk_tinstruction_default(t, a) {
     |           Ok(Some((_, a))) => a
 383 |           Ok(None) => a
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |         let op_size = size_of_load_op(op)
     |         if op_size > 8 {
     |           return change(
     |             t,
     |             TInstr::load(
     |               op,
     |               MemArg::new(U32(align), mem_option, U64(offset)),
     |               a,
     |             ),
     |           )
     |         }
     |         let effective_align = @cmp.minimum(align, op_size)
     |         let c = chunks(op_size, effective_align, offset)
     |         if c.length() == 1 {
     |           return change(
     |             t,
     |             TInstr::load(
     |               op,
     |               MemArg::new(U32(align), mem_option, U64(offset)),
     |               a,
     |             ),
     |           )
     |         }
     |         let mem_idx = match mem_option {
     |           Some(MemIdx(mem_idx)) => mem_idx.reinterpret_as_int()
     |           None => 0
     |         }
     |         let ptr_valtype = match memories.get(mem_idx) {
     |           Some(mem_type) => mem_type.0.addr_valtype()
     |           None => return Err("Invalid memory index")
     |         }
     |         let next = temp_locals.length().reinterpret_as_uint()
     |         temp_locals.push(ptr_valtype)
     |         let local_idx = LocalIdx::new(next)
     |         let ptr_start_set = TInstr::local_tee(local_idx, a)
     |         let value_stack_size = load_op_stack_size(op)
     |         let first = c[0]
     |         let chunk_byte_count = first.0.byte_count()
     |         let load_op = match load_op_with_chunk_size(value_stack_size, first.0) {
     |           Ok(t) => t
 426 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let first_load = TInstr::load(
     |           load_op,
     |           MemArg::new(U32(chunk_byte_count), mem_option, U64(offset + first.1)),
     |           ptr_start_set,
     |         )
     |         let mut acc = load_shift_op(value_stack_size, first.1, first_load)
     |         loop 1 {
     |           n if c.get(n) is Some((chunk_size, relative_offset)) => {
     |             let chunk_byte_count = chunk_size.byte_count()
     |             let load_op = match
     |               load_op_with_chunk_size(value_stack_size, chunk_size) {
     |               Ok(t) => t
 440 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let load_instr = TInstr::load(
     |               load_op,
     |               MemArg::new(
     |                 U32(chunk_byte_count),
     |                 mem_option,
     |                 U64(relative_offset + offset),
     |               ),
     |               TInstr::local_get(local_idx),
     |             )
     |             let shift_op = load_shift_op(
     |               value_stack_size, relative_offset, load_instr,
     |             )
     |             acc = load_or_op(value_stack_size, shift_op, acc)
     |             continue n + 1
     |           }
     |           _ => break change(t, finalize_load_op(op, acc))
     |         }
     |       }
     |       TStore(op, MemArg(U32(align), mem_option, U64(offset)), a, b) => {
     |         let a = match self.walk_tinstruction(t, a) {
     |           Ok(Some((_, a))) => a
 463 |           Ok(None) => a
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |         let b = match self.walk_tinstruction(t, b) {
     |           Ok(Some((_, b))) => b
     |           Ok(None) => b
 469 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let op_size = size_of_store_op(op)
     |         if op_size > 8 {
     |           return change(
     |             t,
     |             TInstr::store(
     |               op,
     |               MemArg::new(U32(align), mem_option, U64(offset)),
     |               a,
     |               b,
     |             ),
     |           )
     |         }
     |         let effective_align = @cmp.minimum(align, op_size)
     |         let c = chunks(op_size, effective_align, offset)
     |         if c.length() == 1 {
     |           return change(
     |             t,
     |             TInstr::store(
     |               op,
     |               MemArg::new(U32(align), mem_option, U64(offset)),
     |               a,
     |               b,
     |             ),
     |           )
     |         }
     | 
     |         // Need locals for both pointer and value
     |         let mem_idx = match mem_option {
     |           Some(MemIdx(mem_idx)) => mem_idx.reinterpret_as_int()
     |           None => 0
     |         }
     |         let ptr_valtype = match memories.get(mem_idx) {
     |           Some(mem_type) => mem_type.0.addr_valtype()
 504 |           None => return Err("Invalid memory index")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let ptr_local_idx = temp_locals.length().reinterpret_as_uint()
     |         temp_locals.push(ptr_valtype)
     |         let ptr_local = LocalIdx::new(ptr_local_idx)
     |         let value_stack_size = store_op_stack_size(op)
     |         let value_valtype = match value_stack_size {
     |           StackSize32 => ValType::i32()
     |           StackSize64 => ValType::i64()
     |         }
     |         let value_local_idx = temp_locals.length().reinterpret_as_uint()
     |         temp_locals.push(value_valtype)
     |         let value_local = LocalIdx::new(value_local_idx)
     | 
     |         // Prepare the value (reinterpret floats to ints)
     |         let prepared_value = prepare_store_value(op, b)
     | 
     |         // Build a block containing all the stores
     |         let stores : Array[TInstr] = []
     | 
     |         // First instruction: set both locals
     |         // We'll use TLocalSet for ptr and TLocalTee for value, then drop
     |         stores.push(TInstr::local_set(ptr_local, a))
     |         stores.push(TInstr::local_set(value_local, prepared_value))
     |         for i = 0; i < c.length(); i = i + 1 {
     |           let (chunk_size, relative_offset) = c[i]
     |           let chunk_byte_count = chunk_size.byte_count()
     |           let store_op = match
     |             store_op_with_chunk_size(value_stack_size, chunk_size) {
     |             Ok(t) => t
 534 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let shifted_value = store_shift_op(
     |             value_stack_size,
     |             relative_offset,
     |             TInstr::local_get(value_local),
     |           )
     |           let store_instr = TInstr::store(
     |             store_op,
     |             MemArg::new(
     |               U32(chunk_byte_count),
     |               mem_option,
     |               U64(offset + relative_offset),
     |             ),
     |             TInstr::local_get(ptr_local),
     |             shifted_value,
     |           )
     |           stores.push(store_instr)
     |         }
     | 
     |         // Wrap in a block with empty result type
     |         change(t, TInstr::block(BlockType::void_(), TExpr::new(stores)))
     |       }
     |       TV128LoadLane(op, MemArg(U32(align), mem_option, U64(offset)), lane, a, b) => {
     |         let op_size = size_of_v128_load_lane_op(op)
     |         let effective_align = @cmp.minimum(align, op_size)
     |         let a = match self.walk_tinstruction_default(t, a) {
     |           Ok(Some((_, a))) => a
 562 |           Ok(None) => a
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |         let b = match self.walk_tinstruction_default(t, b) {
 566 |           Ok(Some((_, b))) => b
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(None) => b
 568 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let c = chunks(op_size, effective_align, offset)
     |         if c.length() == 1 {
     |           return change(
     |             t,
     |             TInstr::v128_load_lane(
     |               op,
     |               MemArg::new(U32(align), mem_option, U64(offset)),
     |               lane,
     |               a,
     |               b,
     |             ),
     |           )
     |         }
     | 
     |         // For V128LoadLane with unaligned access, we load the value using
     |         // regular unaligned load logic, then use replace_lane
     |         let mem_idx = match mem_option {
 587 |           Some(MemIdx(mem_idx)) => mem_idx.reinterpret_as_int()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => 0
     |         }
     |         let ptr_valtype = match memories.get(mem_idx) {
     |           Some(mem_type) => mem_type.0.addr_valtype()
 592 |           None => return Err("Invalid memory index")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let ptr_local_idx = temp_locals.length().reinterpret_as_uint()
     |         temp_locals.push(ptr_valtype)
     |         let ptr_local = LocalIdx::new(ptr_local_idx)
     | 
     |         // Determine the load operation based on lane size
     |         let (replace_op, stack_size) = match op {
 600 |           V128Load8LaneOp => (ReplaceLaneOp::i8x16_replace_lane(), StackSize32)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           V128Load16LaneOp => (ReplaceLaneOp::i16x8_replace_lane(), StackSize32)
     |           V128Load32LaneOp => (ReplaceLaneOp::i32x4_replace_lane(), StackSize32)
     |           V128Load64LaneOp => (ReplaceLaneOp::i64x2_replace_lane(), StackSize64)
     |         }
     | 
     |         // Build the chunked load
     |         let first = c[0]
     |         let chunk_byte_count = first.0.byte_count()
     |         let chunk_load_op = match load_op_with_chunk_size(stack_size, first.0) {
     |           Ok(t) => t
 611 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let first_load = TInstr::load(
     |           chunk_load_op,
     |           MemArg::new(U32(chunk_byte_count), mem_option, U64(offset + first.1)),
     |           TInstr::local_tee(ptr_local, a),
     |         )
     |         let mut acc = load_shift_op(stack_size, first.1, first_load)
     |         for i = 1; i < c.length(); i = i + 1 {
     |           let (chunk_size, relative_offset) = c[i]
     |           let chunk_byte_count = chunk_size.byte_count()
     |           let chunk_load_op = match
     |             load_op_with_chunk_size(stack_size, chunk_size) {
     |             Ok(t) => t
 625 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let load_instr = TInstr::load(
     |             chunk_load_op,
     |             MemArg::new(
     |               U32(chunk_byte_count),
     |               mem_option,
     |               U64(relative_offset + offset),
     |             ),
     |             TInstr::local_get(ptr_local),
     |           )
     |           let shift_op = load_shift_op(stack_size, relative_offset, load_instr)
     |           acc = load_or_op(stack_size, shift_op, acc)
     |         }
     | 
     |         // Use replace_lane to put the loaded value into the vector
     |         change(t, TInstr::replace_lane(replace_op, lane, b, acc))
     |       }
     |       _ => self.walk_tinstruction_default(t, i)
     |     }
     |   })
     | }
     …

     | fn run_func_pass(
     |   memories : Array[MemType],
     |   locals : Array[ValType],
     |   body : Array[TInstr],
     | ) -> Result[(Array[ValType], TExpr), String] {
     |   let mod = make_test_module(memories)
     |   let ctx = IRContext::new()
     |   ctx.set_mod(mod)
     |   let pass = alignment_lowering_pass(mod)
     |   let func = Func::t_func(locals, TExpr::new(body))
     |   match pass.walk_func(ctx, func) {
     |     Ok(Some((_, TFunc(new_locals, new_body)))) => Ok((new_locals, new_body))
 688 |     Ok(None) => Ok((locals, TExpr::new(body)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(Some(_)) => Err("Expected TFunc")
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn assert_v128_extending_load_passes_through(
     |   op : LoadOp,
     | ) -> Result[Unit, String] {
     |   let instr = TInstr::load(
     |     op,
     |     MemArg::new(U32(8), None, U64(0)),
     |     TInstr::local_get(LocalIdx::new(0)),
     |   )
     |   let result = run_pass(make_i32_mem(), instr)
     |   match result {
     |     Ok(TLoad(load_op, _, _)) if load_op == op => Ok(())
     |     Ok(other) =>
 707 |       Err("Expected aligned extending load to pass through: \{other}")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err("Error: \{e}")
     |   }
     | }
     …

     | fn assert_v128_extending_load_is_lowered(
     |   op : LoadOp,
     |   expected_unary : UnaryOp,
     |   memarg : MemArg,
     | ) -> Result[Unit, String] {
     |   let instr = TInstr::load(op, memarg, TInstr::local_get(LocalIdx::new(0)))
     |   let result = run_pass(make_i32_mem(), instr)
     |   match result {
     |     Ok(TUnary(unary_op, TReplaceLane(I64x2ReplaceLaneOp, LaneIdx(0), _, _))) if unary_op ==
     |       expected_unary => Ok(())
     |     Ok(TLoad(load_op, _, _)) if load_op == op =>
 724 |       Err("Expected extending load to be lowered")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(other) => Err("Unexpected result: \{other}")
     |     Err(e) => Err("Error: \{e}")
     |   }
     | }
     …

242 uncovered line(s) in src/passes/asyncify.mbt:

     | fn af_wildcard_match(pattern : String, value : String) -> Bool {
     |   // Greedy '*' wildcard matcher.
     |   let mut pi = 0
     |   let mut vi = 0
     |   let mut star_pi = -1
     |   let mut star_vi = -1
     |   while vi < value.length() {
     |     if pi < pattern.length() && pattern[pi] == '*' {
 109 |       star_pi = pi
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       pi += 1
     |       star_vi = vi
     |       continue
     |     }
     |     if pi < pattern.length() && pattern[pi] == value[vi] {
     |       pi += 1
     |       vi += 1
     |       continue
     |     }
     |     if star_pi >= 0 {
 120 |       pi = star_pi + 1
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       star_vi += 1
     |       vi = star_vi
     |       continue
     |     }
     |     return false
     |   }
     |   while pi < pattern.length() && pattern[pi] == '*' {
 128 |     pi += 1
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     |   pi == pattern.length()
     | }
     …

     | fn af_split_csv(s : String) -> Array[String] {
     |   if s.is_empty() {
 179 |     return []
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let out : Array[String] = []
     |   let mut part = StringBuilder::new()
     |   let mut has_part = false
     |   for i = 0; i < s.length(); i = i + 1 {
     |     if s[i] == ',' {
     |       if has_part {
     |         out.push(part.to_string())
     |         part = StringBuilder::new()
     |         has_part = false
     |       }
     |     } else {
     |       part.write_char(s[i].unsafe_to_char())
     |       has_part = true
     |     }
     |   }
     |   if has_part {
     |     out.push(part.to_string())
     |   }
     |   out
     | }
     …

     | fn af_parse_nonneg_int_from(s : String, start : Int) -> UInt64? {
 213 |   if start >= s.length() {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return None
     |   }
     |   let mut value : UInt64 = 0UL
 217 |   for i = start; i < s.length(); i = i + 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     let code = s[i].to_int()
     |     if code < 0x30 || code > 0x39 {
 220 |       return None
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 222 |     value = value * 10UL + (code - 0x30).to_uint64()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Some(value)
     | }
     …

     | fn af_push_unique(values : Array[String], value : String) -> Unit {
     |   for curr in values {
     |     if curr == value {
 231 |       return
     |       ^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   values.push(value)
     | }
     …

     | fn af_parse_list_arg(arg : String, prefix : String) -> Array[String]? {
     |   if arg.length() < prefix.length() {
 240 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut matched = true
     |   for i = 0; i < prefix.length(); i = i + 1 {
     |     if arg[i] != prefix[i] {
     |       matched = false
     |       break
     |     }
     |   }
     |   if !matched {
     |     return None
     |   }
     |   Some(af_split_csv(af_suffix(arg, prefix.length())))
     | }
     …

     | fn asyncify_apply_arguments(
     |   props : AsyncifyPassProps,
     |   args : Array[String],
     | ) -> Result[AsyncifyPassProps, String] {
     |   let imports = props.imports.copy()
     |   let removelist = props.removelist.copy()
     |   let addlist = props.addlist.copy()
     |   let onlylist = props.onlylist.copy()
     |   let mut ignore_imports = props.ignore_imports
     |   let mut ignore_indirect = props.ignore_indirect
     |   let mut asserts = props.asserts
     |   let mut ignore_unwind_from_catch = props.ignore_unwind_from_catch
     |   let mut verbose = props.verbose
     |   let mut memory = props.memory
     |   let mut propagate_addlist = props.propagate_addlist
     |   let mut import_globals = props.import_globals
     |   let mut export_globals = props.export_globals
     |   let mut in_secondary_memory = props.in_secondary_memory
     |   let mut secondary_memory_size = props.secondary_memory_size
     |   for arg in args {
     |     if arg == "asyncify-ignore-imports" {
     |       ignore_imports = true
     |       continue
     |     }
     |     if arg == "asyncify-ignore-indirect" {
     |       ignore_indirect = true
     |       continue
     |     }
     |     if arg == "asyncify-asserts" {
     |       asserts = true
     |       continue
     |     }
     |     if arg == "asyncify-ignore-unwind-from-catch" {
 289 |       ignore_unwind_from_catch = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     if arg == "asyncify-verbose" {
 293 |       verbose = true
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     if arg == "asyncify-propagate-addlist" {
     |       propagate_addlist = true
     |       continue
     |     }
     |     if arg == "asyncify-import-globals" || arg == "asyncify-relocatable" {
 301 |       import_globals = true
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     if arg == "asyncify-export-globals" {
 305 |       export_globals = true
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     if arg == "asyncify-in-secondary-memory" {
 309 |       in_secondary_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     match af_parse_list_arg(arg, "asyncify-imports@") {
     |       Some(values) => {
     |         for value in values {
     |           af_push_unique(imports, value)
     |         }
     |         continue
     |       }
     |       None => ()
     |     }
     |     match af_parse_list_arg(arg, "asyncify-removelist@") {
     |       Some(values) => {
     |         for value in values {
     |           af_push_unique(removelist, value)
     |         }
     |         continue
     |       }
     |       None => ()
     |     }
     |     match af_parse_list_arg(arg, "asyncify-blacklist@") {
 331 |       Some(values) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for value in values {
 333 |           af_push_unique(removelist, value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         continue
     |       }
     |       None => ()
     |     }
     |     match af_parse_list_arg(arg, "asyncify-addlist@") {
     |       Some(values) => {
     |         for value in values {
     |           af_push_unique(addlist, value)
     |         }
     |         continue
     |       }
     |       None => ()
     |     }
     |     match af_parse_list_arg(arg, "asyncify-onlylist@") {
 349 |       Some(values) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for value in values {
 351 |           af_push_unique(onlylist, value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         continue
     |       }
     |       None => ()
     |     }
     |     match af_parse_list_arg(arg, "asyncify-whitelist@") {
 358 |       Some(values) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for value in values {
 360 |           af_push_unique(onlylist, value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         continue
     |       }
     |       None => ()
     |     }
     |     match af_parse_list_arg(arg, "asyncify-memory@") {
     |       Some(values) =>
     |         match values {
     |           [name, ..] => memory = Some(name)
 370 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
 372 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let sec_mem_prefix = "asyncify-secondary-memory-size@"
     |     if arg.length() >= sec_mem_prefix.length() {
 376 |       let mut matched = true
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for i = 0; i < sec_mem_prefix.length(); i = i + 1 {
     |         if arg[i] != sec_mem_prefix[i] {
     |           matched = false
     |           break
     |         }
     |       }
     |       if matched {
 384 |         match af_parse_nonneg_int_from(arg, sec_mem_prefix.length()) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(v) => secondary_memory_size = v
     |           None => ()
     |         }
     |       }
     |     }
     |   }
     |   if !onlylist.is_empty() && (!addlist.is_empty() || !removelist.is_empty()) {
 392 |     return Err("asyncify: onlylist cannot be combined with addlist/removelist")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(
     |     AsyncifyPassProps::new(
     |       imports~,
     |       ignore_imports~,
     |       ignore_indirect~,
     |       asserts~,
     |       ignore_unwind_from_catch~,
     |       verbose~,
     |       memory~,
     |       removelist~,
     |       addlist~,
     |       propagate_addlist~,
     |       onlylist~,
     |       import_globals~,
     |       export_globals~,
     |       in_secondary_memory~,
     |       secondary_memory_size~,
     |     ),
     |   )
     | }
     …

     | fn af_eval_children(instr : TInstr) -> Array[TInstr] {
     |   match instr {
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TUnreachable
     |     | TNop
     |     | TLocalGet(_)
     |     | TGlobalGet(_)
     |     | TMemorySize(_)
     |     | TAtomicFence
     |     | TTableSize(_)
     |     | TDataDrop(_)
     |     | TElemDrop(_)
     |     | TStructNewDefault(_) => []
     |     TUnary(_, child)
     |     | TDrop(child)
     |     | TLocalSet(_, child)
     |     | TLocalTee(_, child)
     |     | TGlobalSet(_, child)
     |     | TRefIsNull(child)
     |     | TRefAsNonNull(child)
     |     | TI31GetS(child)
     |     | TI31GetU(child)
     |     | TRefI31(child)
     |     | TArrayLen(child)
     |     | TAnyConvertExtern(child)
     |     | TExternConvertAny(child)
     |     | TThrowRef(child)
     |     | TMemoryGrow(_, child)
     |     | TTableGet(_, child)
     |     | TLoad(_, _, child)
     |     | TArrayNewDefault(_, child)
     |     | TStructGet(_, _, child)
     |     | TStructGetS(_, _, child)
     |     | TStructGetU(_, _, child)
     |     | TI8x16Splat(child)
     |     | TI16x8Splat(child)
     |     | TI32x4Splat(child)
     |     | TI64x2Splat(child)
     |     | TF32x4Splat(child)
     |     | TF64x2Splat(child)
     |     | TExtractLane(_, _, child)
     |     | TRefTest(_, _, child)
     |     | TRefCast(_, _, child)
     |     | TRefGetDesc(child)
     |     | TRefTestDesc(_, _, child)
     |     | TRefCastDescEq(_, _, child) => [child]
     |     TBinary(_, left, right)
     |     | TRefEq(left, right)
     |     | TStore(_, _, left, right)
     |     | TMemoryAtomicNotify(_, left, right)
     |     | TAtomicRmw(_, _, left, right)
     |     | TTableSet(_, left, right)
     |     | TTableGrow(_, left, right)
     |     | TStructSet(_, _, left, right)
     |     | TArrayNew(_, left, right)
     |     | TArrayNewData(_, _, left, right)
     |     | TArrayNewElem(_, _, left, right)
     |     | TArrayGet(_, left, right)
     |     | TArrayGetS(_, left, right)
     |     | TArrayGetU(_, left, right)
     |     | TReplaceLane(_, _, left, right)
     |     | TI8x16Swizzle(left, right)
     |     | TI8x16RelaxedSwizzle(left, right)
     |     | TV128Shift(_, left, right)
     |     | TV128LoadLane(_, _, _, left, right)
     |     | TV128StoreLane(_, _, _, left, right) => [left, right]
     |     TMemoryFill(_, a, b, c)
     |     | TMemoryCopy(_, _, a, b, c)
     |     | TMemoryInit(_, _, a, b, c)
     |     | TMemoryAtomicWait32(_, a, b, c)
     |     | TMemoryAtomicWait64(_, a, b, c)
     |     | TAtomicCmpxchg(_, _, a, b, c)
     |     | TTableFill(_, a, b, c)
     |     | TTableCopy(_, _, a, b, c)
     |     | TTableInit(_, _, a, b, c)
     |     | TSelect(_, c, a, b)
 498 |     | TV128Ternary(_, a, b, c) => [a, b, c]
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TCall(_, args)
     |     | TReturnCall(_, args)
     |     | TThrow(_, args)
     |     | TBr(_, args)
     |     | TReturn(args)
     |     | TStructNew(_, args)
     |     | TArrayNewFixed(_, args) => args.copy()
     |     TCallIndirect(_, _, args, index) | TReturnCallIndirect(_, _, args, index) => {
     |       let out = args.copy()
     |       out.push(index)
     |       out
     |     }
 511 |     TCallRef(_, args, ref_) | TReturnCallRef(_, args, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = args.copy()
     |       out.push(ref_)
     |       out
     |     }
 516 |     TBrIf(_, cond, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = values.copy()
     |       out.push(cond)
     |       out
     |     }
 521 |     TBrTable(_, _, index, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = values.copy()
     |       out.push(index)
     |       out
     |     }
     |     TBrOnNull(_, ref_, values)
     |     | TBrOnNonNull(_, ref_, values)
     |     | TBrOnCast(_, _, _, _, ref_, values)
 529 |     | TBrOnCastFail(_, _, _, _, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = values.copy()
     |       out.push(ref_)
     |       out
     |     }
 534 |     TArraySet(_, a, b, c) => [a, b, c]
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayFill(_, a, b, c, d) => [a, b, c, d]
     |     TArrayCopy(_, _, a, b, c, d, e) => [a, b, c, d, e]
     |     TArrayInitData(_, _, a, b, c, d) => [a, b, c, d]
     |     TArrayInitElem(_, _, a, b, c, d) => [a, b, c, d]
     |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, left, right) =>
 540 |       [left, right]
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => []
     |   }
     | }
     …

     | fn af_make_zero(vt : ValType) -> TInstr? {
     |   match vt {
     |     NumTypeValType(I32NumType) => Some(TInstr::i32_const(I32(0)))
     |     NumTypeValType(I64NumType) => Some(TInstr::i64_const(I64(0L)))
 550 |     NumTypeValType(F32NumType) => Some(TInstr::f32_const(F32(0.0)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     NumTypeValType(F64NumType) => Some(TInstr::f64_const(F64(0.0)))
     |     VecTypeValType =>
 553 |       Some(TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) =>
 555 |       if rt.is_nullable() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(TInstr::ref_null(rt.get_heap_type()))
     |       } else {
 558 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
 560 |     BotValType => Some(TInstr::unreachable_())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_flattened_type_count(recs : Array[RecType]) -> Int {
     |   let mut n = 0
     |   for rec in recs {
     |     match rec {
     |       SingleRecType(_) => n += 1
 570 |       GroupRecType(sts) => n += sts.length()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   n
     | }
     …

     | fn af_append_function(
     |   mod : Module,
     |   params : Array[ValType],
     |   results : Array[ValType],
     |   locals : Array[ValType],
     |   body : TExpr,
     | ) -> (Module, FuncIdx) {
     |   let imported = af_count_imported_funcs(mod)
     |   let (mod, type_idx) = af_append_type_func(mod, params, results)
     |   let type_idxs = match mod.func_sec {
     |     Some(FuncSec(xs)) => xs.copy()
     |     None => []
     |   }
     |   type_idxs.push(type_idx)
     |   let mod = mod.with_func_sec(FuncSec::new(type_idxs))
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(xs)) => xs.copy()
 611 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let abs_idx = imported + funcs.length().reinterpret_as_uint()
     |   funcs.push(Func::t_func(locals, body))
     |   (mod.with_code_sec(CodeSec::new(funcs)), FuncIdx::new(abs_idx))
     | }
     …

     | fn af_first_memory_limits(mod : Module) -> Limits? {
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
 704 |           Import(_, _, MemExternType(MemType(limits))) => return Some(limits)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.mem_sec {
     |     Some(MemSec(mems)) =>
 712 |       match mems {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         [MemType(limits), ..] => Some(limits)
     |         _ => None
     |       }
     |     None => None
     |   }
     | }
     …

     | fn af_ensure_memory_exists(mod : Module) -> Module {
     |   match af_first_memory_limits(mod) {
 723 |     Some(_) => mod
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => mod.with_mem_sec(MemSec::new([MemType::new(Limits::i32(1, None))]))
     |   }
     | }
     …

     | fn af_collect_memory_export_names(mod : Module) -> Map[MemIdx, String] {
 730 |   let out = Map::new()
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
 733 |       for export_ in exports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match export_ {
     |           Export(name, MemExternIdx(idx)) => out[idx] = af_name_to_string(name)
     |           _ => ()
     |         }
     |       }
 739 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn af_collect_memory_limits(mod : Module) -> Array[Limits] {
     |   let out : Array[Limits] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
 751 |           Import(_, _, MemExternType(MemType(limits))) => out.push(limits)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.mem_sec {
     |     Some(MemSec(mems)) =>
     |       for mem in mems {
     |         let MemType(limits) = mem
     |         out.push(limits)
     |       }
 763 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn af_is_memory64(limits : Limits) -> Bool {
     |   match limits {
 771 |     I64Limits(_, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn af_memory_choice(
     |   mod : Module,
     |   props : AsyncifyPassProps,
     | ) -> Result[(Module, AFMemoryChoice), String] {
     |   let mod = if props.in_secondary_memory {
 782 |     let mems = match mod.mem_sec {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(MemSec(xs)) => xs.copy()
     |       None => []
     |     }
 786 |     mems.push(
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       MemType::new(
     |         Limits::i32(
     |           props.secondary_memory_size.to_uint(),
     |           Some(props.secondary_memory_size.to_uint()),
     |         ),
     |       ),
     |     )
 794 |     mod.with_mem_sec(MemSec::new(mems))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     af_ensure_memory_exists(mod)
     |   }
     |   let limits = af_collect_memory_limits(mod)
     |   if limits.is_empty() {
 800 |     return Err("asyncify: no memory available")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let chosen_idx = if props.in_secondary_memory {
 803 |     MemIdx::new((limits.length() - 1).reinterpret_as_uint())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else if limits.length() == 1 {
     |     MemIdx::new(0)
     |   } else {
 807 |     match props.memory {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(name) => {
     |         let exports = af_collect_memory_export_names(mod)
     |         let mut matched : MemIdx? = None
     |         for entry in exports {
 812 |           let (idx, export_name) = entry
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if export_name == name {
 814 |             matched = Some(idx)
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             break
     |           }
     |         }
 818 |         match matched {
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(idx) => idx
     |           None =>
 821 |             return Err(
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |               "asyncify: multiple memories present; set asyncify-memory@<export>",
     |             )
     |         }
     |       }
     |       None =>
 827 |         return Err(
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |           "asyncify: multiple memories present; set asyncify-memory@<export>",
     |         )
     |     }
     |   }
     |   let MemIdx(raw_idx) = chosen_idx
     |   let pointer_type = match limits.get(raw_idx.reinterpret_as_int()) {
     |     Some(lim) =>
     |       if af_is_memory64(lim) {
 836 |         ValType::i64()
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         ValType::i32()
     |       }
 840 |     None => ValType::i32()
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok((mod, { mem_idx: chosen_idx, pointer_type }))
     | }
     …

     | fn af_ptr_const(ptr_ty : ValType, v : Int) -> TInstr {
     |   match ptr_ty {
 862 |     NumTypeValType(I64NumType) => TInstr::i64_const(I64(v.to_int64()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => TInstr::i32_const(I32(v))
     |   }
     | }
     …

     | fn af_ptr_add(ptr_ty : ValType, lhs : TInstr, rhs : TInstr) -> TInstr {
     |   match ptr_ty {
 870 |     NumTypeValType(I64NumType) => TInstr::binary(BinaryOp::i64_add(), lhs, rhs)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => TInstr::binary(BinaryOp::i32_add(), lhs, rhs)
     |   }
     | }
     …

     | fn af_ptr_gt_u(ptr_ty : ValType, lhs : TInstr, rhs : TInstr) -> TInstr {
     |   match ptr_ty {
 878 |     NumTypeValType(I64NumType) => TInstr::binary(BinaryOp::i64_gt_u(), lhs, rhs)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => TInstr::binary(BinaryOp::i32_gt_u(), lhs, rhs)
     |   }
     | }
     …

     | fn af_ptr_load_op(ptr_ty : ValType) -> LoadOp {
     |   match ptr_ty {
 886 |     NumTypeValType(I64NumType) => LoadOp::i64_load()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => LoadOp::i32_load()
     |   }
     | }
     …

     | fn af_ptr_store_op(ptr_ty : ValType) -> StoreOp {
     |   match ptr_ty {
 894 |     NumTypeValType(I64NumType) => StoreOp::i64_store()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => StoreOp::i32_store()
     |   }
     | }
     …

     | fn af_ptr_align(ptr_ty : ValType) -> Int {
     |   match ptr_ty {
 902 |     NumTypeValType(I64NumType) => 8
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => 4
     |   }
     | }
     …

     | fn af_ptr_size(ptr_ty : ValType) -> Int {
     |   match ptr_ty {
 910 |     NumTypeValType(I64NumType) => 8
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => 4
     |   }
     | }
     …

     | fn af_add_asyncify_api(
     |   mod : Module,
     |   pointer_type : ValType,
     |   memory : MemIdx,
     |   import_globals : Bool,
     |   export_globals : Bool,
     | ) -> Result[(Module, AFApi), String] {
     |   let (mod, state_global, data_global) = if import_globals {
     |     let (mod, state_global) = af_append_import_global(
     |       mod,
     |       "env",
     |       AF_GLOBAL_STATE,
     |       ValType::i32(),
     |       true,
     |     )
     |     let (mod, data_global) = af_append_import_global(
     |       mod,
     |       "env",
     |       AF_GLOBAL_DATA,
     |       pointer_type,
     |       true,
     |     )
     |     (mod, state_global, data_global)
     |   } else {
     |     let (mod, state_global) = af_append_global(
     |       mod,
     |       ValType::i32(),
     |       true,
     |       TInstr::i32_const(I32(AF_STATE_NORMAL)),
     |     )
     |     let (mod, data_global) = match af_make_zero(pointer_type) {
     |       Some(zero) => af_append_global(mod, pointer_type, true, zero)
1026 |       None => return Err("asyncify: pointer type has no default value")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     (mod, state_global, data_global)
     |   }
     |   let mod = if export_globals {
     |     af_append_export_global(
     |       af_append_export_global(mod, AF_GLOBAL_STATE, state_global),
     |       AF_GLOBAL_DATA,
     |       data_global,
     |     )
     |   } else {
     |     mod
     |   }
     |   let builder = AsyncifyBuilder::new(
     |     pointer_type, memory, state_global, data_global,
     |   )
     |   let ptr_size = af_ptr_size(pointer_type)
     |   let stack_end_offset = ptr_size
     |   let start_check = TInstr::if_(
     |     BlockType::void_(),
     |     af_ptr_gt_u(
     |       pointer_type,
     |       TInstr::load(
     |         af_ptr_load_op(pointer_type),
     |         MemArg::new(
     |           U32(af_ptr_align(pointer_type).reinterpret_as_uint()),
     |           Some(memory),
     |           U64(stack_end_offset.reinterpret_as_uint().to_uint64()),
     |         ),
     |         TInstr::local_get(LocalIdx::new(0)),
     |       ),
     |       TInstr::load(
     |         af_ptr_load_op(pointer_type),
     |         MemArg::new(
     |           U32(af_ptr_align(pointer_type).reinterpret_as_uint()),
     |           Some(memory),
     |           U64(0UL),
     |         ),
     |         TInstr::local_get(LocalIdx::new(0)),
     |       ),
     |     ),
     |     TExpr::new([TInstr::unreachable_()]),
     |     None,
     |   )
     |   let start_unwind_body = TExpr::new([
     |     TInstr::global_set(data_global, TInstr::local_get(LocalIdx::new(0))),
     |     start_check,
     |     TInstr::global_set(state_global, TInstr::i32_const(I32(AF_STATE_UNWINDING))),
     |   ])
     |   let stop_unwind_body = TExpr::new([
     |     TInstr::global_set(state_global, TInstr::i32_const(I32(AF_STATE_NORMAL))),
     |   ])
     |   let start_rewind_body = TExpr::new([
     |     TInstr::global_set(data_global, TInstr::local_get(LocalIdx::new(0))),
     |     start_check,
     |     TInstr::global_set(state_global, TInstr::i32_const(I32(AF_STATE_REWINDING))),
     |   ])
     |   let stop_rewind_body = TExpr::new([
     |     TInstr::global_set(state_global, TInstr::i32_const(I32(AF_STATE_NORMAL))),
     |   ])
     |   let get_state_body = TExpr::new([TInstr::global_get(state_global)])
     |   let (mod, runtime_start_unwind) = af_append_exported_function(
     |     mod,
     |     AF_RUNTIME_START_UNWIND,
     |     [pointer_type],
     |     [],
     |     [],
     |     start_unwind_body,
     |   )
     |   let (mod, runtime_stop_unwind) = af_append_exported_function(
     |     mod,
     |     AF_RUNTIME_STOP_UNWIND,
     |     [],
     |     [],
     |     [],
     |     stop_unwind_body,
     |   )
     |   let (mod, runtime_start_rewind) = af_append_exported_function(
     |     mod,
     |     AF_RUNTIME_START_REWIND,
     |     [pointer_type],
     |     [],
     |     [],
     |     start_rewind_body,
     |   )
     |   let (mod, runtime_stop_rewind) = af_append_exported_function(
     |     mod,
     |     AF_RUNTIME_STOP_REWIND,
     |     [],
     |     [],
     |     [],
     |     stop_rewind_body,
     |   )
     |   let (mod, runtime_get_state) = af_append_exported_function(
     |     mod,
     |     AF_RUNTIME_GET_STATE,
     |     [],
     |     [ValType::i32()],
     |     [],
     |     get_state_body,
     |   )
     |   // Internal intrinsic placeholders lowered later.
     |   let (mod, intr_unwind) = af_append_function(
     |     mod,
     |     [ValType::i32()],
     |     [],
     |     [],
     |     TExpr::new([TInstr::nop()]),
     |   )
     |   let (mod, intr_get_call_index) = af_append_function(
     |     mod,
     |     [],
     |     [],
     |     [],
     |     TExpr::new([builder.make_inc_stack_pos(-4), TInstr::nop()]),
     |   )
     |   let (mod, intr_check_call_index) = af_append_function(
     |     mod,
     |     [ValType::i32()],
     |     [ValType::i32()],
     |     [],
     |     TExpr::new([TInstr::i32_const(I32(0))]),
     |   )
     |   Ok(
     |     (
     |       mod,
     |       {
     |         state_global,
     |         data_global,
     |         runtime_start_unwind,
     |         runtime_stop_unwind,
     |         runtime_start_rewind,
     |         runtime_stop_rewind,
     |         runtime_get_state,
     |         intr_unwind,
     |         intr_get_call_index,
     |         intr_check_call_index,
     |       },
     |     ),
     |   )
     | }
     …

     | fn af_remap_func_indices(
     |   mod : Module,
     |   remap : Map[FuncIdx, FuncIdx],
     | ) -> Result[Module, String] {
     |   if remap.is_empty() {
1174 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let transformer = ModuleTransformer::new().on_funcidx_evt(fn(_, _, idx) {
     |     match remap.get(idx) {
     |       Some(new_idx) =>
     |         if new_idx != idx {
     |           change((), new_idx)
     |         } else {
1182 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1184 |       None => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   match transformer.walk_module((), mod) {
     |     Ok(Some((_, next_mod))) => Ok(next_mod)
1189 |     Ok(None) => Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn af_remap_global_indices(
     |   mod : Module,
     |   remap : Map[GlobalIdx, GlobalIdx],
     | ) -> Result[Module, String] {
     |   if remap.is_empty() {
1200 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let transformer = ModuleTransformer::new().on_globalidx_evt(fn(_, _, idx) {
     |     match remap.get(idx) {
     |       Some(new_idx) =>
     |         if new_idx != idx {
1206 |           change((), new_idx)
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           unchanged()
     |         }
1210 |       None => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   match transformer.walk_module((), mod) {
     |     Ok(Some((_, next_mod))) => Ok(next_mod)
1215 |     Ok(None) => Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn af_remap_runtime_idx(
     |   remap : Map[FuncIdx, FuncIdx],
     |   idx : FuncIdx,
     | ) -> FuncIdx {
     |   match remap.get(idx) {
     |     Some(next) => next
1227 |     None => idx
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_runtime_redirect_target(runtime : AFApi, base_name : String) -> FuncIdx? {
     |   if base_name == "start_unwind" {
     |     return Some(runtime.runtime_start_unwind)
     |   }
     |   if base_name == "stop_unwind" {
1237 |     return Some(runtime.runtime_stop_unwind)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if base_name == "start_rewind" {
1240 |     return Some(runtime.runtime_start_rewind)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if base_name == "stop_rewind" {
1243 |     return Some(runtime.runtime_stop_rewind)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if base_name == "get_state" {
1246 |     return Some(runtime.runtime_get_state)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   None
     | }
     …

     | fn af_rewrite_asyncify_runtime_imports(
     |   mod : Module,
     |   runtime : AFApi,
     | ) -> Result[(Module, AFApi), String] {
     |   let imports = match mod.import_sec {
     |     Some(ImportSec(xs)) => xs
     |     None => return Ok((mod, runtime))
     |   }
     |   let imported_func_count = af_count_imported_funcs(mod).reinterpret_as_int()
     |   if imported_func_count <= 0 {
     |     return Ok((mod, runtime))
     |   }
     |   let redirect_target : Array[FuncIdx?] = Array::make(imported_func_count, None)
     |   let new_imports : Array[Import] = []
     |   let mut removed_count = 0
     |   let mut func_import_idx = 0
     |   for import_ in imports {
     |     match import_ {
     |       Import(module_name, base_name, FuncExternType(_)) => {
     |         let module_s = af_name_to_string(module_name)
     |         let base_s = af_name_to_string(base_name)
     |         let redirected = if module_s == "asyncify" {
     |           af_runtime_redirect_target(runtime, base_s)
     |         } else {
     |           None
     |         }
     |         match redirected {
     |           Some(target) => {
     |             if func_import_idx < 0 ||
     |               func_import_idx >= redirect_target.length() {
1282 |               return Err(
     |               ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 "asyncify: invalid function import index while rewriting runtime imports",
     |               )
     |             }
     |             redirect_target[func_import_idx] = Some(target)
     |             removed_count += 1
     |           }
     |           None => new_imports.push(import_)
     |         }
     |         func_import_idx += 1
     |       }
1293 |       _ => new_imports.push(import_)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if removed_count == 0 {
     |     return Ok((mod, runtime))
     |   }
     |   let total_funcs = Env::new().with_module(mod).funcs.length()
     |   let remap : Map[FuncIdx, FuncIdx] = Map::new()
     |   let mut removed_before = 0
     |   for old_idx = 0; old_idx < imported_func_count; old_idx = old_idx + 1 {
     |     let old = FuncIdx::new(old_idx.reinterpret_as_uint())
     |     match redirect_target[old_idx] {
     |       Some(target_old) => {
     |         let target_new = af_func_idx_to_int(target_old) - removed_count
     |         if target_new < 0 {
1308 |           return Err(
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             "asyncify: invalid remap target while removing runtime imports",
     |           )
     |         }
     |         remap[old] = FuncIdx::new(target_new.reinterpret_as_uint())
     |         removed_before += 1
     |       }
     |       None => {
     |         let new_idx = old_idx - removed_before
     |         remap[old] = FuncIdx::new(new_idx.reinterpret_as_uint())
     |       }
     |     }
     |   }
     |   for old_idx = imported_func_count
     |       old_idx < total_funcs
     |       old_idx = old_idx + 1 {
     |     let new_idx = old_idx - removed_count
     |     remap[FuncIdx::new(old_idx.reinterpret_as_uint())] = FuncIdx::new(
     |       new_idx.reinterpret_as_uint(),
     |     )
     |   }
     |   let mod = mod.with_import_sec(ImportSec::new(new_imports))
     |   let mod = match af_remap_func_indices(mod, remap) {
     |     Ok(next) => next
1332 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let runtime = {
     |     state_global: runtime.state_global,
     |     data_global: runtime.data_global,
     |     runtime_start_unwind: af_remap_runtime_idx(
     |       remap,
     |       runtime.runtime_start_unwind,
     |     ),
     |     runtime_stop_unwind: af_remap_runtime_idx(
     |       remap,
     |       runtime.runtime_stop_unwind,
     |     ),
     |     runtime_start_rewind: af_remap_runtime_idx(
     |       remap,
     |       runtime.runtime_start_rewind,
     |     ),
     |     runtime_stop_rewind: af_remap_runtime_idx(
     |       remap,
     |       runtime.runtime_stop_rewind,
     |     ),
     |     runtime_get_state: af_remap_runtime_idx(remap, runtime.runtime_get_state),
     |     intr_unwind: af_remap_runtime_idx(remap, runtime.intr_unwind),
     |     intr_get_call_index: af_remap_runtime_idx(
     |       remap,
     |       runtime.intr_get_call_index,
     |     ),
     |     intr_check_call_index: af_remap_runtime_idx(
     |       remap,
     |       runtime.intr_check_call_index,
     |     ),
     |   }
     |   Ok((mod, runtime))
     | }
     …

     | fn FakeGlobalHelper::new(
     |   mod : Module,
     |   env : Env,
     | ) -> Result[(Module, FakeGlobalHelper), String] {
     |   let global_by_type : Map[ValType, GlobalIdx] = Map::new()
     |   let type_by_global : Map[GlobalIdx, ValType] = Map::new()
     |   let mut next_mod = mod
     |   fn add_type(
     |     mod : Module,
     |     ty : ValType,
     |     by_type : Map[ValType, GlobalIdx],
     |     by_global : Map[GlobalIdx, ValType],
     |   ) -> Result[Module, String] {
     |     if by_type.contains(ty) {
1388 |       return Ok(mod)
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let init = match af_make_zero(ty) {
     |       Some(v) => v
     |       None =>
1393 |         return Err("asyncify: fake global needs defaultable call result type")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let (next_mod, idx) = af_append_global(mod, ty, true, init)
     |     by_type[ty] = idx
     |     by_global[idx] = ty
     |     Ok(next_mod)
     |   }
     | 
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TCall(target, _) | TReturnCall(target, _) =>
     |         match env.get_functype_by_funcidx(target) {
     |           Some(FuncType(_, [ret])) =>
     |             match add_type(next_mod, ret, global_by_type, type_by_global) {
     |               Ok(m) => next_mod = m
1408 |               Err(_) => ()
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           _ => ()
     |         }
     |       TCallIndirect(type_idx, _, _, _)
     |       | TReturnCallIndirect(type_idx, _, _, _)
     |       | TCallRef(type_idx, _, _)
     |       | TReturnCallRef(type_idx, _, _) =>
     |         match env.resolve_functype(type_idx) {
     |           Some(FuncType(_, [ret])) =>
1418 |             match add_type(next_mod, ret, global_by_type, type_by_global) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Ok(m) => next_mod = m
     |               Err(_) => ()
     |             }
     |           _ => ()
     |         }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_module((), mod))
     |   Ok((next_mod, { global_by_type, type_by_global }))
     | }
     …

     | fn af_module_references_any_global(
     |   mod : Module,
     |   targets : Set[GlobalIdx],
     | ) -> Result[Bool, String] {
     |   if targets.is_empty() {
1466 |     return Ok(false)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let found = Ref::new(false)
     |   let walker = ModuleTransformer::new().on_globalidx_evt(fn(_, _, idx) {
     |     if targets.contains(idx) {
1471 |       found.update(fn(_) { true })
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     unchanged()
     |   })
     |   match walker.walk_module((), mod) {
     |     Ok(_) => Ok(found.val)
1477 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_remove_fake_globals(
     |   mod : Module,
     |   fake_globals : FakeGlobalHelper,
     | ) -> Result[Module, String] {
     |   let fake_indices = fake_globals.all_global_indices()
     |   if fake_indices.is_empty() {
     |     return Ok(mod)
     |   }
     |   let targets = Set::new()
     |   for idx in fake_indices {
     |     targets.add(idx)
     |   }
     |   match af_module_references_any_global(mod, targets) {
     |     Ok(true) =>
1496 |       return Err("asyncify: fake call-result globals remained after lowering")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(false) => ()
1498 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let imported_globals = af_count_imported_globals(mod).reinterpret_as_int()
     |   let globals = match mod.global_sec {
     |     Some(GlobalSec(items)) => items
1503 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let kept : Array[Global] = []
     |   let remap : Map[GlobalIdx, GlobalIdx] = Map::new()
     |   for i = 0; i < globals.length(); i = i + 1 {
     |     let old_idx = GlobalIdx::new((imported_globals + i).reinterpret_as_uint())
     |     // Fake call-result globals are temporary implementation details and must
     |     // be removed from the final module.
     |     if targets.contains(old_idx) {
     |       continue
     |     }
     |     let new_idx = GlobalIdx::new(
     |       (imported_globals + kept.length()).reinterpret_as_uint(),
     |     )
     |     remap[old_idx] = new_idx
     |     kept.push(globals[i])
     |   }
     |   let next_mod = mod.with_global_sec(GlobalSec::new(kept))
     |   af_remap_global_indices(next_mod, remap)
     | }
     …

     | fn af_collect_function_names(mod : Module) -> Array[String] {
     |   let imported = af_count_imported_funcs(mod).reinterpret_as_int()
     |   let defined = match mod.code_sec {
     |     Some(CodeSec(funcs)) => funcs.length()
1551 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let total = imported + defined
     |   let names : Array[String] = []
     |   for i = 0; i < total; i = i + 1 {
     |     names.push("func:\{i}")
     |   }
     |   // Imports: module.base
     |   let mut fi = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(module_name, base_name, FuncExternType(_)) => {
     |             names[fi] = "\{af_name_to_string(module_name)}.\{af_name_to_string(base_name)}"
     |             fi += 1
     |           }
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   // Exports override human-readable names for defined functions.
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         match export_ {
     |           Export(name, FuncExternIdx(idx)) => {
     |             let i = af_func_idx_to_int(idx)
     |             if i >= 0 && i < names.length() {
     |               names[i] = af_name_to_string(name)
     |             }
     |           }
     |           _ => ()
     |         }
     |       }
1587 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   names
     | }
     …

     | fn af_collect_direct_edges(func : Func, out : Set[FuncIdx]) -> Unit {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TCall(target, _) | TReturnCall(target, _) => out.add(target)
1607 |       TReturnCallIndirect(_, _, _, _) | TReturnCallRef(_, _, _) => ()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_func((), func))
     | }
     …

     | fn AFModuleAnalyzer::new(
     |   mod : Module,
     |   props : AsyncifyPassProps,
     |   runtime : AFApi,
     | ) -> AFModuleAnalyzer {
     |   let env = Env::new().with_module(mod)
     |   let total = env.funcs.length()
     |   let may_change_state = Array::make(total, false)
     |   let top_most_runtime = Array::make(total, false)
     |   let bottom_most_runtime = Array::make(total, false)
     |   let needs_instrumentation = Array::make(total, false)
     |   let added_from_list = Array::make(total, false)
     |   let function_names = af_collect_function_names(mod)
     |   let imported = af_count_imported_funcs(mod).reinterpret_as_int()
     |   // Imported function policy.
     |   let mut imp_idx = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(module_name, base_name, FuncExternType(_)) => {
     |             let name = "\{af_name_to_string(module_name)}.\{af_name_to_string(base_name)}"
     |             let mut can_change = !props.ignore_imports
     |             if !props.imports.is_empty() {
     |               can_change = af_match_any_pattern(name, props.imports)
     |             }
     |             if module_name == Name::new("asyncify") &&
     |               (
     |                 base_name == Name::new("start_unwind") ||
     |                 base_name == Name::new("stop_rewind")
     |               ) {
1662 |               can_change = true
     |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             may_change_state[imp_idx] = can_change
     |             imp_idx += 1
     |           }
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   // Build callgraph and runtime classifications.
     |   let callers : Array[Set[Int]] = Array::make(total, Set::new())
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for i = 0; i < funcs.length(); i = i + 1 {
     |         let abs = imported + i
     |         let fi = FuncIdx::new(abs.reinterpret_as_uint())
     |         if af_func_calls(funcs[i], runtime.runtime_start_unwind) ||
     |           af_func_calls(funcs[i], runtime.runtime_stop_rewind) {
     |           top_most_runtime[abs] = true
     |           may_change_state[abs] = true
     |         }
     |         if af_func_calls(funcs[i], runtime.runtime_stop_unwind) ||
     |           af_func_calls(funcs[i], runtime.runtime_start_rewind) {
1686 |           bottom_most_runtime[abs] = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let edges = Set::new()
     |         af_collect_direct_edges(funcs[i], edges)
     |         for callee in edges {
     |           let ci = af_func_idx_to_int(callee)
     |           if ci >= 0 && ci < total {
     |             callers[ci].add(abs)
     |           }
     |         }
     |         ignore(fi)
     |       }
1698 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let work : Array[Int] = []
     |   for i = 0; i < total; i = i + 1 {
     |     if may_change_state[i] && !bottom_most_runtime[i] {
     |       work.push(i)
     |     }
     |   }
     |   while !work.is_empty() {
     |     let callee = work.pop().unwrap()
     |     for caller in callers[callee] {
     |       if !may_change_state[caller] && !bottom_most_runtime[callee] {
     |         may_change_state[caller] = true
     |         work.push(caller)
     |       }
     |     }
     |   }
     |   for i = 0; i < total; i = i + 1 {
     |     needs_instrumentation[i] = may_change_state[i] &&
     |       !top_most_runtime[i] &&
     |       !bottom_most_runtime[i]
     |   }
     |   if !props.onlylist.is_empty() {
     |     for i = 0; i < total; i = i + 1 {
     |       let matched = af_match_any_pattern(function_names[i], props.onlylist)
     |       needs_instrumentation[i] = matched
     |       added_from_list[i] = matched
     |     }
     |   } else {
     |     for i = 0; i < total; i = i + 1 {
     |       if af_match_any_pattern(function_names[i], props.removelist) {
     |         needs_instrumentation[i] = false
     |       }
     |       if af_match_any_pattern(function_names[i], props.addlist) {
     |         needs_instrumentation[i] = true
     |         added_from_list[i] = true
     |       }
     |     }
     |   }
     |   if props.propagate_addlist && !props.addlist.is_empty() {
     |     let queue : Array[Int] = []
     |     for i = 0; i < total; i = i + 1 {
     |       if added_from_list[i] {
     |         queue.push(i)
     |       }
     |     }
     |     while !queue.is_empty() {
     |       let callee = queue.pop().unwrap()
     |       for caller in callers[callee] {
     |         if !needs_instrumentation[caller] {
1748 |           needs_instrumentation[caller] = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           queue.push(caller)
     |         }
     |       }
     |     }
     |   }
     |   if props.verbose {
1755 |     let logs : Array[String] = []
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     for i = 0; i < total; i = i + 1 {
     |       if needs_instrumentation[i] {
     |         logs.push("asyncify instrument: \{function_names[i]}")
     |       }
     |     }
1761 |     logs.sort()
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |     for line in logs {
1763 |       println(line)
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   {
     |     env,
     |     can_indirect_change_state: !props.ignore_indirect,
     |     may_change_state,
     |     bottom_most_runtime,
     |     needs_instrumentation,
     |     added_from_list,
     |     runtime_start_unwind: runtime.runtime_start_unwind,
     |     runtime_stop_unwind: runtime.runtime_stop_unwind,
     |     runtime_start_rewind: runtime.runtime_start_rewind,
     |     runtime_stop_rewind: runtime.runtime_stop_rewind,
     |     intr_get_call_index: runtime.intr_get_call_index,
     |     intr_check_call_index: runtime.intr_check_call_index,
     |   }
     | }
     …

     | fn AFModuleAnalyzer::can_change_state(
     |   self : AFModuleAnalyzer,
     |   instr : TInstr,
     |   curr_func : FuncIdx,
     | ) -> Bool {
     |   match instr {
     |     TCall(target, _) | TReturnCall(target, _) => {
     |       if target == self.runtime_stop_unwind ||
     |         target == self.runtime_start_rewind {
1805 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if target == self.runtime_start_unwind ||
     |         target == self.runtime_stop_rewind ||
     |         target == self.intr_get_call_index ||
     |         target == self.intr_check_call_index {
     |         return true
     |       }
1813 |       let i = af_func_idx_to_int(target)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if i < 0 || i >= self.may_change_state.length() {
1815 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if self.bottom_most_runtime[i] {
1818 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       self.may_change_state[i]
     |     }
     |     TCallIndirect(_, _, _, _)
     |     | TCallRef(_, _, _)
     |     | TReturnCallIndirect(_, _, _, _)
     |     | TReturnCallRef(_, _, _) =>
1826 |       if self.can_indirect_change_state {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         true
     |       } else {
1829 |         let ci = af_func_idx_to_int(curr_func)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ci >= 0 &&
1831 |         ci < self.added_from_list.length() &&
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.added_from_list[ci]
     |       }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) => {
     |       for item in body.0 {
     |         if self.can_change_state(item, curr_func) {
     |           return true
     |         }
     |       }
     |       false
     |     }
     |     TIf(_, cond, then_, else_) => {
     |       if self.can_change_state(cond, curr_func) {
     |         return true
     |       }
     |       for item in then_.0 {
1847 |         if self.can_change_state(item, curr_func) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return true
     |         }
     |       }
1851 |       match else_ {
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) =>
1853 |           for item in other.0 {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             if self.can_change_state(item, curr_func) {
     |               return true
     |             }
     |           }
1858 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       false
     |     }
     |     _ => {
     |       for child in af_eval_children(instr) {
     |         if self.can_change_state(child, curr_func) {
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn af_eqz(v : TInstr) -> TInstr {
1880 |   TInstr::unary(UnaryOp::i32_eqz(), v)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn af_rewrite_if_for_rewinding(
     |   b : AsyncifyBuilder,
     |   then_ : TExpr,
     |   else_ : TExpr?,
     |   cond : TInstr,
     | ) -> TInstr {
1890 |   let rewinding = b.make_state_check(AF_STATE_REWINDING)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match else_ {
     |     Some(other) =>
1893 |       TInstr::block(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         BlockType::void_(),
     |         TExpr::new([
     |           TInstr::if_(BlockType::void_(), af_or(rewinding, cond), then_, None),
     |           TInstr::if_(
     |             BlockType::void_(),
     |             af_or(b.make_state_check(AF_STATE_REWINDING), af_eqz(cond)),
     |             other,
     |             None,
     |           ),
     |         ]),
     |       )
1905 |     None => TInstr::if_(BlockType::void_(), af_or(rewinding, cond), then_, None)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_rewrite_call_like(
     |   ctx : AFRewriterCtx,
     |   instr : TInstr,
     | ) -> Result[TInstr, String] {
     |   let call_index = ctx.next_call_index
     |   ctx.next_call_index += 1
     |   let wrapped_call = match instr {
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
     |     | TReturnCallRef(_, _, _) =>
1955 |       return Err("asyncify: tail calls are not supported")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalSet(idx, value) =>
     |       match value {
     |         TCall(target, args) =>
     |           match ctx.analyzer.env.get_functype_by_funcidx(target) {
     |             Some(FuncType(_, [ret])) =>
     |               match ctx.fake_globals.get_name(ret) {
     |                 Some(fake_global) =>
     |                   TInstr::block(
     |                     BlockType::void_(),
     |                     TExpr::new([
     |                       TInstr::global_set(
     |                         fake_global,
     |                         TInstr::call(target, args),
     |                       ),
     |                       TInstr::local_set(idx, TInstr::global_get(fake_global)),
     |                     ]),
     |                   )
1973 |                 None => instr
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1975 |             _ => instr
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         TCallIndirect(type_idx, table_idx, args, index) =>
1978 |           match ctx.analyzer.env.resolve_functype(type_idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(FuncType(_, [ret])) =>
1980 |               match ctx.fake_globals.get_name(ret) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(fake_global) =>
1982 |                   TInstr::block(
     |                   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     BlockType::void_(),
     |                     TExpr::new([
     |                       TInstr::global_set(
     |                         fake_global,
1987 |                         TInstr::call_indirect(type_idx, table_idx, args, index),
     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       ),
1989 |                       TInstr::local_set(idx, TInstr::global_get(fake_global)),
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     ]),
     |                   )
1992 |                 None => instr
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1994 |             _ => instr
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         TCallRef(type_idx, args, ref_) =>
1997 |           match ctx.analyzer.env.resolve_functype(type_idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(FuncType(_, [ret])) =>
1999 |               match ctx.fake_globals.get_name(ret) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(fake_global) =>
2001 |                   TInstr::block(
     |                   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     BlockType::void_(),
     |                     TExpr::new([
     |                       TInstr::global_set(
     |                         fake_global,
2006 |                         TInstr::call_ref(type_idx, args, ref_),
     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       ),
2008 |                       TInstr::local_set(idx, TInstr::global_get(fake_global)),
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     ]),
     |                   )
2011 |                 None => instr
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2013 |             _ => instr
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
2015 |         _ => instr
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => instr
     |   }
     |   let cond = af_or(
     |     ctx.builder.make_state_check(AF_STATE_NORMAL),
     |     TInstr::call(ctx.intr_check_call_index, [TInstr::i32_const(I32(call_index))]),
     |   )
     |   Ok(
     |     TInstr::if_(
     |       BlockType::void_(),
     |       cond,
     |       TExpr::new([
     |         wrapped_call,
     |         TInstr::if_(
     |           BlockType::void_(),
     |           ctx.builder.make_state_check(AF_STATE_UNWINDING),
     |           TExpr::new([
     |             TInstr::call(ctx.intr_unwind, [TInstr::i32_const(I32(call_index))]),
     |           ]),
     |           None,
     |         ),
     |       ]),
     |       None,
     |     ),
     |   )
     | }
     …

     | fn af_rewrite_instr(
     |   ctx : AFRewriterCtx,
     |   instr : TInstr,
     | ) -> Result[TInstr, String] {
     |   match instr {
     |     TBlock(bt, body) => {
     |       let out : Array[TInstr] = []
     |       for item in body.0 {
     |         let rewritten = match af_rewrite_instr(ctx, item) {
     |           Ok(v) => v
2054 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if ctx.analyzer.can_change_state(rewritten, ctx.curr_func) {
     |           out.push(rewritten)
     |         } else {
     |           out.push(af_wrap_skippable(ctx.builder, rewritten))
     |         }
     |       }
     |       Ok(TInstr::block(bt, TExpr::new(out)))
     |     }
2064 |     TLoop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out : Array[TInstr] = []
     |       for item in body.0 {
2067 |         let rewritten = match af_rewrite_instr(ctx, item) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(v) => v
     |           Err(e) => return Err(e)
     |         }
     |         if ctx.analyzer.can_change_state(rewritten, ctx.curr_func) {
2072 |           out.push(rewritten)
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
2074 |           out.push(af_wrap_skippable(ctx.builder, rewritten))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
2077 |       Ok(TInstr::loop_(bt, TExpr::new(out)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TTryTable(bt, catches, body) => {
     |       let out : Array[TInstr] = []
     |       for item in body.0 {
     |         let rewritten = match af_rewrite_instr(ctx, item) {
     |           Ok(v) => v
2084 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         out.push(rewritten)
     |       }
     |       Ok(TInstr::try_table(bt, catches, TExpr::new(out)))
     |     }
2090 |     TIf(bt, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_cond = match af_rewrite_instr(ctx, cond) {
     |         Ok(v) => v
     |         Err(e) => return Err(e)
     |       }
     |       let next_then_instrs : Array[TInstr] = []
     |       for item in then_.0 {
2097 |         next_then_instrs.push(
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           match af_rewrite_instr(ctx, item) {
     |             Ok(v) => v
     |             Err(e) => return Err(e)
     |           },
     |         )
     |       }
2104 |       let next_else = match else_ {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => {
     |           let xs : Array[TInstr] = []
     |           for item in other.0 {
2108 |             xs.push(
     |             ^^^^^^^^ 	<-- UNCOVERED
     |               match af_rewrite_instr(ctx, item) {
     |                 Ok(v) => v
     |                 Err(e) => return Err(e)
     |               },
     |             )
     |           }
2115 |           Some(TExpr::new(xs))
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
2117 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let _ = bt
     |       Ok(
2121 |         af_rewrite_if_for_rewinding(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ctx.builder,
2123 |           TExpr::new(next_then_instrs),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           next_else,
     |           next_cond,
     |         ),
     |       )
     |     }
     |     _ =>
     |       if af_is_call_like_none(instr) {
     |         af_rewrite_call_like(ctx, instr)
     |       } else {
     |         // Generic recursive rebuild for non-control instructions.
     |         let kids = af_eval_children(instr)
     |         if kids.is_empty() {
     |           Ok(instr)
     |         } else {
     |           let rebuilt_kids : Array[TInstr] = []
     |           for child in kids {
     |             rebuilt_kids.push(
     |               match af_rewrite_instr(ctx, child) {
     |                 Ok(v) => v
2143 |                 Err(e) => return Err(e)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               },
     |             )
     |           }
     |           match instr {
2148 |             TUnary(op, _) => Ok(TInstr::unary(op, rebuilt_kids[0]))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TDrop(_) => Ok(TInstr::drop(rebuilt_kids[0]))
     |             TLocalSet(idx, _) => Ok(TInstr::local_set(idx, rebuilt_kids[0]))
2151 |             TLocalTee(idx, _) => Ok(TInstr::local_tee(idx, rebuilt_kids[0]))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TGlobalSet(idx, _) => Ok(TInstr::global_set(idx, rebuilt_kids[0]))
     |             TRefIsNull(_) => Ok(TInstr::ref_is_null(rebuilt_kids[0]))
     |             TRefAsNonNull(_) => Ok(TInstr::ref_as_non_null(rebuilt_kids[0]))
     |             TI31GetS(_) => Ok(TInstr::i31_get_s(rebuilt_kids[0]))
     |             TI31GetU(_) => Ok(TInstr::i31_get_u(rebuilt_kids[0]))
     |             TRefI31(_) => Ok(TInstr::ref_i31(rebuilt_kids[0]))
     |             TArrayLen(_) => Ok(TInstr::array_len(rebuilt_kids[0]))
     |             TAnyConvertExtern(_) =>
2160 |               Ok(TInstr::any_convert_extern(rebuilt_kids[0]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TExternConvertAny(_) =>
2162 |               Ok(TInstr::extern_convert_any(rebuilt_kids[0]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TThrowRef(_) => Ok(TInstr::throw_ref(rebuilt_kids[0]))
     |             TMemoryGrow(mi, _) => Ok(TInstr::memory_grow(mi, rebuilt_kids[0]))
     |             TTableGet(ti, _) => Ok(TInstr::table_get(ti, rebuilt_kids[0]))
     |             TLoad(op, ma, _) => Ok(TInstr::load(op, ma, rebuilt_kids[0]))
     |             TBinary(op, _, _) =>
2168 |               Ok(TInstr::binary(op, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TRefEq(_, _) => Ok(TInstr::ref_eq(rebuilt_kids[0], rebuilt_kids[1]))
     |             TStore(op, ma, _, _) =>
2171 |               Ok(TInstr::store(op, ma, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TTableSet(ti, _, _) =>
2173 |               Ok(TInstr::table_set(ti, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TTableGrow(ti, _, _) =>
2175 |               Ok(TInstr::table_grow(ti, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TStructSet(ti, fi, _, _) =>
2177 |               Ok(TInstr::struct_set(ti, fi, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TArrayNew(ti, _, _) =>
2179 |               Ok(TInstr::array_new(ti, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TArrayNewData(ti, di, _, _) =>
2181 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::array_new_data(ti, di, rebuilt_kids[0], rebuilt_kids[1]),
     |               )
     |             TArrayNewElem(ti, ei, _, _) =>
2185 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::array_new_elem(ti, ei, rebuilt_kids[0], rebuilt_kids[1]),
     |               )
     |             TArrayGet(ti, _, _) =>
2189 |               Ok(TInstr::array_get(ti, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TArrayGetS(ti, _, _) =>
2191 |               Ok(TInstr::array_get_s(ti, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TArrayGetU(ti, _, _) =>
2193 |               Ok(TInstr::array_get_u(ti, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TReplaceLane(op, li, _, _) =>
2195 |               Ok(TInstr::replace_lane(op, li, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TI8x16Swizzle(_, _) =>
2197 |               Ok(TInstr::i8x16_swizzle(rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TI8x16RelaxedSwizzle(_, _) =>
2199 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::i8x16_relaxed_swizzle(rebuilt_kids[0], rebuilt_kids[1]),
     |               )
     |             TV128Shift(op, _, _) =>
2203 |               Ok(TInstr::v128_shift(op, rebuilt_kids[0], rebuilt_kids[1]))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TV128LoadLane(op, ma, li, _, _) =>
2205 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::v128_load_lane(
     |                   op,
     |                   ma,
     |                   li,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                 ),
     |               )
     |             TV128StoreLane(op, ma, li, _, _) =>
2215 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::v128_store_lane(
     |                   op,
     |                   ma,
     |                   li,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                 ),
     |               )
     |             TMemoryFill(mi, _, _, _) =>
2225 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::memory_fill(
     |                   mi,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TMemoryCopy(dst, src, _, _, _) =>
2234 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::memory_copy(
     |                   dst,
     |                   src,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TMemoryInit(di, mi, _, _, _) =>
2244 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::memory_init(
     |                   di,
     |                   mi,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TTableFill(ti, _, _, _) =>
2254 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::table_fill(
     |                   ti,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TTableCopy(t0, t1, _, _, _) =>
2263 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::table_copy(
     |                   t0,
     |                   t1,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TTableInit(ei, ti, _, _, _) =>
2273 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::table_init(
     |                   ei,
     |                   ti,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TSelect(tys, _, _, _) =>
2283 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::select(
     |                   tys,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
     |             TV128Ternary(op, _, _, _) =>
2292 |               Ok(
     |               ^^^ 	<-- UNCOVERED
     |                 TInstr::v128_ternary(
     |                   op,
     |                   rebuilt_kids[0],
     |                   rebuilt_kids[1],
     |                   rebuilt_kids[2],
     |                 ),
     |               )
2300 |             _ => Ok(instr)
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |   }
     | }
     …

     | fn af_instrument_flow_for_function(
     |   func : Func,
     |   func_idx : FuncIdx,
     |   analyzer : AFModuleAnalyzer,
     |   builder : AsyncifyBuilder,
     |   fake_globals : FakeGlobalHelper,
     |   runtime : AFApi,
     | ) -> Result[Func, String] {
     |   match func {
     |     TFunc(locals, body) => {
     |       let ctx : AFRewriterCtx = {
     |         analyzer,
     |         builder,
     |         fake_globals,
     |         intr_unwind: runtime.intr_unwind,
     |         intr_check_call_index: runtime.intr_check_call_index,
     |         curr_func: func_idx,
     |         next_call_index: 0,
     |       }
     |       let rewritten_items : Array[TInstr] = []
     |       for instr in body.0 {
     |         rewritten_items.push(
     |           match af_rewrite_instr(ctx, instr) {
     |             Ok(v) => v
2332 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           },
     |         )
     |       }
     |       let prefix = TInstr::if_(
     |         BlockType::void_(),
     |         builder.make_state_check(AF_STATE_REWINDING),
     |         TExpr::new([TInstr::call(runtime.intr_get_call_index, [])]),
     |         None,
     |       )
     |       let wrapped : Array[TInstr] = [prefix]
     |       for instr in rewritten_items {
     |         wrapped.push(instr)
     |       }
     |       if !wrapped.is_empty() {
     |         let last = wrapped[wrapped.length() - 1]
     |         match last {
2349 |           TUnreachable => ()
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |       Ok(
     |         Func::t_func(
     |           locals,
     |           TExpr::new([TInstr::block(BlockType::void_(), TExpr::new(wrapped))]),
     |         ),
     |       )
     |     }
2360 |     _ => Ok(func)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_local_byte_size(vt : ValType) -> Int? {
     |   match vt {
     |     NumTypeValType(I32NumType) | NumTypeValType(F32NumType) => Some(4)
2368 |     NumTypeValType(I64NumType) | NumTypeValType(F64NumType) => Some(8)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     VecTypeValType => Some(16)
     |     RefTypeValType(_) => None
     |     BotValType => Some(4)
     |   }
     | }
     …

     | fn af_align_up(v : Int, align : Int) -> Int {
     |   if align <= 1 {
     |     return v
     |   }
     |   let r = v % align
     |   if r == 0 {
     |     v
     |   } else {
2384 |     v + (align - r)
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_lower_intrinsics_and_locals(
     |   func : Func,
     |   builder : AsyncifyBuilder,
     |   runtime : AFApi,
     |   fake_globals : FakeGlobalHelper,
     | ) -> Result[Func, String] {
     |   match func {
     |     TFunc(locals, body) => {
     |       let relevant = af_collect_live_like_locals(body)
     |       let stack_ptr_local = LocalIdx::new(locals.length().reinterpret_as_uint())
     |       let unwind_idx_local = LocalIdx::new(
     |         (locals.length() + 1).reinterpret_as_uint(),
     |       )
     |       let extended_locals = locals.copy()
     |       extended_locals.push(builder.pointer_type)
     |       extended_locals.push(ValType::i32())
     |       let fake_tmp_by_global : Map[GlobalIdx, LocalIdx] = Map::new()
     |       let fake_tmp_for = fn(gidx : GlobalIdx, vt : ValType) -> LocalIdx {
     |         match fake_tmp_by_global.get(gidx) {
     |           Some(idx) => idx
     |           None => {
     |             let idx = LocalIdx::new(
     |               extended_locals.length().reinterpret_as_uint(),
     |             )
     |             extended_locals.push(vt)
     |             fake_tmp_by_global[gidx] = idx
     |             idx
     |           }
     |         }
     |       }
     |       let load_ops : Array[TInstr] = []
     |       let mut cursor = 0
     |       for idx in relevant {
     |         let LocalIdx(raw) = idx
     |         let i = raw.reinterpret_as_int()
     |         if i < 0 || i >= locals.length() {
2440 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let ty = locals[i]
     |         let sz = match af_local_byte_size(ty) {
     |           Some(s) => s
     |           None =>
2446 |             return Err(
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |               "asyncify: local save/restore does not support ref locals",
     |             )
     |         }
     |         let aligned = af_align_up(cursor, AF_STACK_ALIGN.reinterpret_as_int())
     |         load_ops.push(
     |           TInstr::local_set(
     |             idx,
     |             TInstr::load(
     |               match ty {
     |                 NumTypeValType(I32NumType) => LoadOp::i32_load()
2457 |                 NumTypeValType(I64NumType) => LoadOp::i64_load()
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 NumTypeValType(F32NumType) => LoadOp::f32_load()
     |                 NumTypeValType(F64NumType) => LoadOp::f64_load()
     |                 VecTypeValType => LoadOp::v128_load()
     |                 BotValType => LoadOp::i32_load()
     |                 RefTypeValType(_) => LoadOp::i32_load()
     |               },
     |               MemArg::new(
     |                 U32(af_align_up(sz, 1).reinterpret_as_uint()),
     |                 Some(builder.memory),
     |                 U64(aligned.reinterpret_as_uint().to_uint64()),
     |               ),
     |               TInstr::local_get(stack_ptr_local),
     |             ),
     |           ),
     |         )
     |         cursor = aligned + sz
     |       }
     |       let load_seq : Array[TInstr] = []
     |       if cursor > 0 {
     |         load_seq.push(builder.make_inc_stack_pos(-cursor))
     |       }
     |       load_seq.push(
     |         TInstr::local_set(stack_ptr_local, builder.make_get_stack_pos()),
     |       )
     |       for op in load_ops {
     |         load_seq.push(op)
     |       }
     |       let save_seq : Array[TInstr] = []
     |       save_seq.push(
     |         TInstr::local_set(stack_ptr_local, builder.make_get_stack_pos()),
     |       )
     |       cursor = 0
     |       for idx in relevant {
     |         let LocalIdx(raw) = idx
     |         let i = raw.reinterpret_as_int()
     |         if i < 0 || i >= locals.length() {
2494 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let ty = locals[i]
     |         let sz = match af_local_byte_size(ty) {
     |           Some(s) => s
     |           None =>
2500 |             return Err(
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |               "asyncify: local save/restore does not support ref locals",
     |             )
     |         }
     |         let aligned = af_align_up(cursor, AF_STACK_ALIGN.reinterpret_as_int())
     |         save_seq.push(
     |           TInstr::store(
     |             match ty {
     |               NumTypeValType(I32NumType) => StoreOp::i32_store()
2509 |               NumTypeValType(I64NumType) => StoreOp::i64_store()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               NumTypeValType(F32NumType) => StoreOp::f32_store()
     |               NumTypeValType(F64NumType) => StoreOp::f64_store()
     |               VecTypeValType => StoreOp::v128_store()
     |               BotValType => StoreOp::i32_store()
     |               RefTypeValType(_) => StoreOp::i32_store()
     |             },
     |             MemArg::new(
     |               U32(af_align_up(sz, 1).reinterpret_as_uint()),
     |               Some(builder.memory),
     |               U64(aligned.reinterpret_as_uint().to_uint64()),
     |             ),
     |             TInstr::local_get(stack_ptr_local),
     |             TInstr::local_get(idx),
     |           ),
     |         )
     |         cursor = aligned + sz
     |       }
     |       if cursor > 0 {
     |         save_seq.push(builder.make_inc_stack_pos(cursor))
     |       }
     |       let lowered = ModuleTransformer::new().on_tinstruction_evt(fn(
     |         self,
     |         _,
     |         instr,
     |       ) {
     |         match instr {
     |           TCall(target, [TI32Const(I32(ix))]) if target == runtime.intr_unwind =>
     |             change(
     |               (),
     |               TInstr::br(LabelIdx::new(0), [TInstr::i32_const(I32(ix))]),
     |             )
     |           TCall(target, []) if target == runtime.intr_get_call_index =>
     |             change(
     |               (),
     |               TInstr::block(
     |                 BlockType::void_(),
     |                 TExpr::new([
     |                   builder.make_inc_stack_pos(-4),
     |                   TInstr::local_set(
     |                     unwind_idx_local,
     |                     TInstr::load(
     |                       LoadOp::i32_load(),
     |                       MemArg::new(U32(4), Some(builder.memory), U64(0UL)),
     |                       builder.make_get_stack_pos(),
     |                     ),
     |                   ),
     |                 ]),
     |               ),
     |             )
     |           TCall(target, [arg]) if target == runtime.intr_check_call_index =>
     |             change(
     |               (),
     |               TInstr::binary(
     |                 BinaryOp::i32_eq(),
     |                 TInstr::local_get(unwind_idx_local),
     |                 arg,
     |               ),
     |             )
     |           TGlobalSet(gidx, value) =>
     |             match fake_globals.get_type_or_none(gidx) {
     |               Some(vt) => {
     |                 let tmp = fake_tmp_for(gidx, vt)
     |                 change((), TInstr::local_set(tmp, value))
     |               }
2574 |               None => self.walk_tinstruction_default((), instr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           TGlobalGet(gidx) =>
     |             match fake_globals.get_type_or_none(gidx) {
     |               Some(vt) => {
     |                 let tmp = fake_tmp_for(gidx, vt)
     |                 change((), TInstr::local_get(tmp))
     |               }
     |               None => unchanged()
     |             }
     |           _ => self.walk_tinstruction_default((), instr)
     |         }
     |       })
     |       let lowered_body = match lowered.walk_texpr((), body) {
     |         Ok(Some((_, next))) => next
2589 |         Ok(None) => body
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |       }
     |       let final_instrs : Array[TInstr] = []
     |       final_instrs.push(
     |         TInstr::if_(
     |           BlockType::void_(),
     |           builder.make_state_check(AF_STATE_REWINDING),
     |           TExpr::new(load_seq),
     |           None,
     |         ),
     |       )
     |       final_instrs.push(
     |         TInstr::local_set(
     |           unwind_idx_local,
     |           TInstr::block(
     |             BlockType::val_type(ValType::i32()),
     |             TExpr::new([
     |               TInstr::block(BlockType::void_(), lowered_body),
     |               TInstr::i32_const(I32(0)),
     |             ]),
     |           ),
     |         ),
     |       )
     |       final_instrs.push(
     |         TInstr::if_(
     |           BlockType::void_(),
     |           builder.make_state_check(AF_STATE_UNWINDING),
     |           TExpr::new([
     |             // Binaryen parity: trap if writing the call index would exceed the
     |             // configured asyncify stack end.
     |             TInstr::if_(
     |               BlockType::void_(),
     |               af_ptr_gt_u(
     |                 builder.pointer_type,
     |                 af_ptr_add(
     |                   builder.pointer_type,
     |                   builder.make_get_stack_pos(),
     |                   af_ptr_const(builder.pointer_type, 4),
     |                 ),
     |                 builder.make_get_stack_end(),
     |               ),
     |               TExpr::new([TInstr::unreachable_()]),
     |               None,
     |             ),
     |             TInstr::store(
     |               StoreOp::i32_store(),
     |               MemArg::new(U32(4), Some(builder.memory), U64(0UL)),
     |               builder.make_get_stack_pos(),
     |               TInstr::local_get(unwind_idx_local),
     |             ),
     |             builder.make_inc_stack_pos(4),
     |             TInstr::block(BlockType::void_(), TExpr::new(save_seq)),
     |           ]),
     |           None,
     |         ),
     |       )
     |       Ok(Func::t_func(extended_locals, TExpr::new(final_instrs)))
     |     }
2648 |     _ => Ok(func)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_assert_non_instrumented(
     |   mod : Module,
     |   analyzer : AFModuleAnalyzer,
     |   runtime : AFApi,
     | ) -> Module {
     |   let imported = af_count_imported_funcs(mod).reinterpret_as_int()
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(xs)) => xs.copy()
2661 |     None => return mod
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let rewritten : Array[Func] = []
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     let abs = FuncIdx::new((imported + i).reinterpret_as_uint())
     |     if analyzer.needs_instrumentation_for(abs) {
     |       rewritten.push(funcs[i])
     |       continue
     |     }
     |     match funcs[i] {
     |       TFunc(locals, body) => {
     |         let state_local = LocalIdx::new(locals.length().reinterpret_as_uint())
     |         let next_locals = locals.copy()
     |         next_locals.push(ValType::i32())
     |         let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |           self,
     |           _,
     |           instr,
     |         ) {
     |           match instr {
     |             TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
     |               change(
     |                 (),
     |                 TInstr::block(
     |                   BlockType::void_(),
     |                   TExpr::new([
     |                     instr,
     |                     TInstr::if_(
     |                       BlockType::void_(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_ne(),
     |                         TInstr::global_get(runtime.state_global),
     |                         TInstr::local_get(state_local),
     |                       ),
     |                       TExpr::new([TInstr::unreachable_()]),
     |                       None,
     |                     ),
     |                   ]),
     |                 ),
     |               )
     |             _ => self.walk_tinstruction_default((), instr)
     |           }
     |         })
     |         let next_body = match walker.walk_texpr((), body) {
     |           Ok(Some((_, t))) => t
2706 |           _ => body
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         rewritten.push(
     |           Func::t_func(
     |             next_locals,
     |             TExpr::new([
     |               TInstr::local_set(
     |                 state_local,
     |                 TInstr::global_get(runtime.state_global),
     |               ),
     |               TInstr::block(BlockType::void_(), next_body),
     |             ]),
     |           ),
     |         )
     |       }
2721 |       _ => rewritten.push(funcs[i])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   mod.with_code_sec(CodeSec::new(rewritten))
     | }
     …

     | fn af_catch_alloc_temp_local(ctx : AFCatchAssertCtx, vt : ValType) -> LocalIdx {
2738 |   match ctx.temp_by_type.get(vt) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(idx) => idx
     |     None => {
     |       let idx = LocalIdx::new(
     |         (ctx.base_local_count + ctx.extra_locals.length()).reinterpret_as_uint(),
     |       )
2744 |       ctx.extra_locals.push(vt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ctx.temp_by_type[vt] = idx
     |       idx
     |     }
     |   }
     | }
     …

     | fn af_catch_call_result_type(instr : TInstr, env : Env) -> ValType? {
     |   match instr {
     |     TCall(target, _) =>
     |       match env.get_functype_by_funcidx(target) {
2756 |         Some(FuncType(_, [ret])) => Some(ret)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
2760 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [ret])) => Some(ret)
     |         _ => None
     |       }
2764 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_catch_wrap_guarded_call(ctx : AFCatchAssertCtx, call : TInstr) -> TInstr {
     |   match af_catch_call_result_type(call, ctx.env) {
2785 |     Some(vt) => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let temp = af_catch_alloc_temp_local(ctx, vt)
     |       TInstr::block(
     |         BlockType::val_type(vt),
     |         TExpr::new([
     |           TInstr::local_set(temp, call),
     |           af_catch_make_guard(ctx.state_global),
     |           TInstr::local_get(temp),
     |         ]),
     |       )
     |     }
     |     None =>
     |       TInstr::block(
     |         BlockType::void_(),
     |         TExpr::new([call, af_catch_make_guard(ctx.state_global)]),
     |       )
     |   }
     | }
     …

     | fn af_catch_wrap_calls_in_instr(
     |   ctx : AFCatchAssertCtx,
     |   instr : TInstr,
     | ) -> TInstr {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
     |       TReturnCall(_, _)
     |       | TReturnCallIndirect(_, _, _, _)
2813 |       | TReturnCallRef(_, _, _) => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
     |         change((), af_catch_wrap_guarded_call(ctx, curr))
     |       _ => self.walk_tinstruction_default((), curr)
     |     }
     |   })
     |   match walker.walk_tinstruction((), instr) {
     |     Ok(Some((_, out))) => out
     |     Ok(None) => instr
2822 |     Err(_) => instr
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_catch_target_depth(catch_ : Catch) -> Int? {
     |   let label = match catch_ {
     |     Catch(_, label)
     |     | CatchRef(_, label)
     |     | CatchAll(label)
     |     | CatchAllRef(label) => label
     |   }
     |   let LabelIdx(raw) = label
     |   if raw > 0x7FFFFFFFU {
2836 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   } else {
     |     Some(raw.reinterpret_as_int())
     |   }
     | }
     …

     | fn af_catch_add_escapes(escapes : Set[Int], src : Set[Int]) -> Unit {
     |   for depth in src {
2845 |     escapes.add(depth)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn af_catch_add_scope_shifted_escapes(
     |   escapes : Set[Int],
     |   src : Set[Int],
     |   preserve_zero? : Bool = true,
     | ) -> Unit {
     |   for depth in src {
     |     if depth == 0 {
     |       if preserve_zero {
     |         escapes.add(0)
     |       }
2860 |     } else if depth > 0 {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       escapes.add(depth - 1)
     |     }
     |   }
     | }
     …

     | fn af_rewrite_catch_instr(
     |   ctx : AFCatchAssertCtx,
     |   instr : TInstr,
     |   in_catch_continuation : Bool,
     | ) -> (TInstr, Set[Int]) {
     |   // Escape depths model "exceptional branches from try_table catches" where:
     |   // depth == 0 means control can continue immediately after this instruction in
     |   // the current expression list, and depth > 0 means one or more enclosing
     |   // labels are targeted.
     |   match instr {
     |     TBlock(bt, body) => {
     |       let (next_body, body_escapes) = af_rewrite_catch_texpr(
     |         ctx, body, in_catch_continuation,
     |       )
     |       let escapes = Set::new()
     |       af_catch_add_scope_shifted_escapes(escapes, body_escapes)
     |       (TInstr::block(bt, next_body), escapes)
     |     }
     |     TIf(bt, cond, then_, else_) => {
     |       let next_cond = if in_catch_continuation {
     |         af_catch_wrap_calls_in_instr(ctx, cond)
     |       } else {
     |         cond
     |       }
     |       let (next_then, then_escapes) = af_rewrite_catch_texpr(
     |         ctx, then_, in_catch_continuation,
     |       )
     |       let next_else_and_escapes = match else_ {
     |         Some(other) =>
2896 |           Some(af_rewrite_catch_texpr(ctx, other, in_catch_continuation))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => None
     |       }
     |       let escapes = Set::new()
     |       af_catch_add_scope_shifted_escapes(escapes, then_escapes)
     |       let next_else = match next_else_and_escapes {
2902 |         Some((rewritten_else, else_escapes)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           af_catch_add_scope_shifted_escapes(escapes, else_escapes)
     |           Some(rewritten_else)
     |         }
     |         None => None
     |       }
     |       (TInstr::if_(bt, next_cond, next_then, next_else), escapes)
     |     }
2910 |     TLoop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_body, body_escapes) = af_rewrite_catch_texpr(
     |         ctx, body, in_catch_continuation,
     |       )
2914 |       let escapes = Set::new()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // loop label 0 branches to the loop head, not to code after the loop.
2916 |       af_catch_add_scope_shifted_escapes(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         escapes,
     |         body_escapes,
     |         preserve_zero=false,
     |       )
2921 |       (TInstr::loop_(bt, next_body), escapes)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TTryTable(bt, catches, body) => {
     |       // Keep current catch-context when rewriting the try body. If we are
     |       // already in a catch continuation from an outer try_table, calls here are
     |       // still inside catch-driven control flow and must be guarded.
     |       let (next_body, body_escapes) = af_rewrite_catch_texpr(
     |         ctx, body, in_catch_continuation,
     |       )
     |       let raw_escapes = Set::new()
     |       af_catch_add_escapes(raw_escapes, body_escapes)
     |       for catch_ in catches {
     |         match af_catch_target_depth(catch_) {
     |           Some(depth) if depth >= 0 => raw_escapes.add(depth)
2935 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       let escapes = Set::new()
     |       af_catch_add_scope_shifted_escapes(escapes, raw_escapes)
     |       (TInstr::try_table(bt, catches, next_body), escapes)
     |     }
     |     TLocalSet(idx, value) => {
     |       let (next_value, escapes) = af_rewrite_catch_instr(
     |         ctx, value, in_catch_continuation,
     |       )
     |       (TInstr::local_set(idx, next_value), escapes)
     |     }
2948 |     TLocalTee(idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_value, escapes) = af_rewrite_catch_instr(
     |         ctx, value, in_catch_continuation,
     |       )
2952 |       (TInstr::local_tee(idx, next_value), escapes)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2954 |     TDrop(value) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_value, escapes) = af_rewrite_catch_instr(
     |         ctx, value, in_catch_continuation,
     |       )
2958 |       (TInstr::drop(next_value), escapes)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TGlobalSet(idx, value) => {
     |       let (next_value, escapes) = af_rewrite_catch_instr(
     |         ctx, value, in_catch_continuation,
     |       )
     |       (TInstr::global_set(idx, next_value), escapes)
     |     }
     |     _ =>
     |       if in_catch_continuation {
     |         (af_catch_wrap_calls_in_instr(ctx, instr), Set::new())
     |       } else {
     |         (instr, Set::new())
     |       }
     |   }
     | }
     …

     | fn af_assert_unwind_catch(mod : Module, runtime : AFApi) -> Module {
     |   let imported = af_count_imported_funcs(mod).reinterpret_as_int()
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(xs)) => xs.copy()
3012 |     None => return mod
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let rewritten : Array[Func] = []
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     let abs_idx = FuncIdx::new((imported + i).reinterpret_as_uint())
     |     match funcs[i] {
     |       TFunc(locals, body) => {
     |         let func_locals = locals.copy()
     |         let mut full_env = Env::new().with_module(mod)
     |         let params = match full_env.get_functype_by_funcidx(abs_idx) {
     |           Some(FuncType(ps, _)) => ps
3023 |           None => []
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let all_locals = params.copy()
     |         for vt in func_locals {
     |           all_locals.push(vt)
     |         }
     |         full_env = full_env.with_locals(all_locals)
     |         let ctx : AFCatchAssertCtx = {
     |           env: full_env,
     |           state_global: runtime.state_global,
     |           base_local_count: func_locals.length(),
     |           temp_by_type: Map::new(),
     |           extra_locals: [],
     |         }
     |         let (next_body, _) = af_rewrite_catch_texpr(ctx, body, false)
     |         let next_locals = func_locals.copy()
     |         for vt in ctx.extra_locals {
3040 |           next_locals.push(vt)
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         rewritten.push(Func::t_func(next_locals, next_body))
     |       }
3044 |       _ => rewritten.push(funcs[i])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   mod.with_code_sec(CodeSec::new(rewritten))
     | }
     …

     | fn asyncify(
     |   mod : Module,
     |   props? : AsyncifyPassProps = AsyncifyPassProps::new(),
     |   optimize_level? : Int = 0,
     | ) -> Result[Module, String] {
     |   let (mod, memory) = match af_memory_choice(mod, props) {
     |     Ok(v) => v
3058 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (mod, runtime) = match
     |     af_add_asyncify_api(
     |       mod,
     |       memory.pointer_type,
     |       memory.mem_idx,
     |       props.import_globals,
     |       props.export_globals,
     |     ) {
     |     Ok(v) => v
3069 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (mod, runtime) = match af_rewrite_asyncify_runtime_imports(mod, runtime) {
     |     Ok(v) => v
3073 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let analyzer = AFModuleAnalyzer::new(mod, props, runtime)
     |   let env = Env::new().with_module(mod)
     |   let (mod, fake_globals) = match FakeGlobalHelper::new(mod, env) {
     |     Ok(v) => v
3079 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let imported = af_count_imported_funcs(mod).reinterpret_as_int()
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(xs)) => xs.copy()
3084 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let builder = AsyncifyBuilder::new(
     |     memory.pointer_type,
     |     memory.mem_idx,
     |     runtime.state_global,
     |     runtime.data_global,
     |   )
     |   let rewritten_funcs : Array[Func] = []
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     let abs = FuncIdx::new((imported + i).reinterpret_as_uint())
     |     let mut func = funcs[i]
     |     if analyzer.needs_instrumentation_for(abs) {
     |       func = match
     |         af_instrument_flow_for_function(
     |           func, abs, analyzer, builder, fake_globals, runtime,
     |         ) {
     |         Ok(f) => f
3102 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       func = match
     |         af_lower_intrinsics_and_locals(func, builder, runtime, fake_globals) {
     |         Ok(f) => f
3107 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     rewritten_funcs.push(func)
     |   }
     |   let mut out = mod.with_code_sec(CodeSec::new(rewritten_funcs))
     |   if props.asserts {
     |     out = af_assert_non_instrumented(out, analyzer, runtime)
     |     if !props.ignore_unwind_from_catch {
     |       out = af_assert_unwind_catch(out, runtime)
     |     }
     |   }
     |   out = match af_remove_fake_globals(out, fake_globals) {
     |     Ok(next) => next
3121 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   ignore(optimize_level)
     |   Ok(out)
     | }
     …

     | fn af_walk_instr(instr : TInstr, f : (TInstr) -> Unit) -> Unit {
     |   f(instr)
     |   match instr {
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       for item in body.0 {
     |         af_walk_instr(item, f)
     |       }
     |     TIf(_, cond, then_, else_) => {
     |       af_walk_instr(cond, f)
     |       for item in then_.0 {
     |         af_walk_instr(item, f)
     |       }
     |       match else_ {
     |         Some(other) =>
3150 |           for item in other.0 {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             af_walk_instr(item, f)
     |           }
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in af_eval_children(instr) {
     |         af_walk_instr(child, f)
     |       }
     |   }
     | }
     …

     | fn af_has_i32_store_const_zero(body : TExpr) -> Bool {
     |   let found = Ref::new(false)
     |   for instr in body.0 {
     |     af_walk_instr(instr, fn(curr) {
     |       match curr {
     |         TStore(I32StoreOp, _, _, TI32Const(I32(v))) if v == 0 =>
3247 |           found.update(fn(_) { true })
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |     })
     |   }
     |   found.val
     | }
     …

     | fn af_find_exported_func_idx(mod : Module, export_name : String) -> FuncIdx? {
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         match export_ {
     |           Export(Name(name), FuncExternIdx(idx)) =>
     |             if name.to_string() == export_name {
     |               return Some(idx)
     |             }
3279 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
3282 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   None
     | }
     …

     | fn af_has_unwind_push_stack_end_guard(body : TExpr) -> Bool {
     |   let found = Ref::new(false)
     |   for instr in body.0 {
     |     af_walk_instr(instr, fn(curr) {
     |       match curr {
     |         TIf(_, TBinary(I32GtUOp, _, _), TExpr([TUnreachable]), None) =>
     |           found.update(fn(_) { true })
     |         TIf(_, TBinary(I64GtUOp, _, _), TExpr([TUnreachable]), None) =>
3315 |           found.update(fn(_) { true })
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |     })
     |   }
     |   found.val
     | }
     …

9 uncovered line(s) in src/passes/avoid_reinterprets.mbt:

    | fn is_reinterpret(op : UnaryOp) -> Bool {
    |   match op {
    |     I32ReinterpretF32Op => true
  5 |     I64ReinterpretF64Op => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F32ReinterpretI32Op => true
    |     F64ReinterpretI64Op => true
    |     _ => false
    |   }
    | }
    …

    | fn reinterpret_load_op(op : LoadOp) -> LoadOp? {
    |   match op {
    |     F32LoadOp => Some(LoadOp::i32_load())
 16 |     I32LoadOp => Some(LoadOp::f32_load())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F64LoadOp => Some(LoadOp::i64_load())
    |     I64LoadOp => Some(LoadOp::f64_load())
    |     _ => None
    |   }
    | }
    …

    | fn reinterpret_compatible(op : UnaryOp, load_op : LoadOp) -> Bool {
    |   match (op, load_op) {
    |     (I32ReinterpretF32Op, F32LoadOp) => true
 27 |     (F32ReinterpretI32Op, I32LoadOp) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (I64ReinterpretF64Op, F64LoadOp) => true
    |     (F64ReinterpretI64Op, I64LoadOp) => true
    |     _ => false
    |   }
    | }
    …

    | fn rewrite_reinterpret_of_load(instr : TInstr) -> TInstr? {
    |   match instr {
    |     TUnary(op, TLoad(load_op, memarg, ptr)) => {
    |       if !reinterpret_compatible(op, load_op) {
    |         return None
    |       }
    |       match reinterpret_load_op(load_op) {
    |         Some(new_op) => Some(TInstr::load(new_op, memarg, ptr))
 43 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     _ => None
    |   }
    | }
    …

    | fn get_single_load_from_local(
    |   graph : LocalGraph,
    |   get_idx : Int,
    | ) -> (LoadOp, MemArg, TInstr)? {
    |   let sets = graph.get_sets(get_idx)
    |   if sets.length() != 1 {
 57 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match sets.to_array()[0] {
    |     LocalSet::Set(_, TLocalSet(_, TLoad(op, memarg, ptr))) =>
    |       Some((op, memarg, ptr))
 62 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn avoid_reinterprets() -> ModuleTransformer[IRContext] {
    |   let mut idx = 0
    |   ModuleTransformer::new()
    |   .on_func_evt(fn(self, state : IRContext, func) {
    |     match func {
 72 |       Func(_) => Err("Expected TFunc")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TFunc(_, body) => {
    |         state.set_body(body)
    |         self.walk_func_default(state, func)
    |       }
    |     }
    |   })
    |   .on_tinstruction_evt(fn(_self, state, instr) {
    |     let cur_idx = idx
    |     match instr {
    |       TInstr::TUnary(_, TInstr::TLocalGet(_)) => idx += 1
    |       _ => ()
    |     }
    | 
    |     // Case A: reinterpret(load)
    |     if rewrite_reinterpret_of_load(instr) is Some(new_instr) {
    |       return change(state, new_instr)
    |     }
    |     let graph = state.get_local_graph()
    | 
    |     // Case B: reinterpret(local.get)
    |     match instr {
    |       TInstr::TUnary(op, TInstr::TLocalGet(_)) if is_reinterpret(op) =>
    |         match get_single_load_from_local(graph, cur_idx) {
    |           Some((load_op, memarg, ptr)) =>
    |             match reinterpret_load_op(load_op) {
    |               Some(new_op) => change(state, TInstr::load(new_op, memarg, ptr))
 99 |               None => change(state, instr)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
101 |           None => change(state, instr)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       _ => unchanged()
    |     }
    |   })
    | }
    …

21 uncovered line(s) in src/passes/coalesce_locals.mbt:

     | fn value_of_expr(
     |   expr : TInstr,
     |   env : ValueEnv,
     |   counter : Ref[Int],
     |   consts : ConstTable,
     | ) -> ValueId? {
     |   match expr {
     |     // Constant literals: each literal gets its own value ID
     |     TI32Const(I32(n)) =>
     |       // Use consts table to get consistent ID for same constant
     |       match consts.get(ConstKey::I32Key(n)) {
     |         Some(id) => Some(id)
     |         None => {
     |           let id = counter.val
     |           counter.val += 1
     |           consts[ConstKey::I32Key(n)] = id
     |           Some(id)
     |         }
     |       }
     |     TI64Const(I64(n)) =>
     |       // Use consts table to get consistent ID for same constant
  57 |       match consts.get(ConstKey::I64Key(n)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(id) => Some(id)
     |         None => {
     |           let id = counter.val
     |           counter.val += 1
     |           consts[ConstKey::I64Key(n)] = id
     |           Some(id)
     |         }
     |       }
     |     TF32Const(F32(f)) =>
     |       // Use consts table to get consistent ID for same constant
     |       match consts.get(ConstKey::F32Key(f)) {
     |         Some(id) => Some(id)
     |         None => {
     |           let id = counter.val
     |           counter.val += 1
     |           consts[ConstKey::F32Key(f)] = id
     |           Some(id)
     |         }
     |       }
     |     TF64Const(F64(f)) =>
     |       // Use consts table to get consistent ID for same constant
  79 |       match consts.get(ConstKey::F64Key(f)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(id) => Some(id)
     |         None => {
     |           let id = counter.val
     |           counter.val += 1
     |           consts[ConstKey::F64Key(f)] = id
     |           Some(id)
     |         }
     |       }
     | 
     |     // Copy: produces fresh value
     |     TInstr::TLocalGet(idx) => env.get(idx)
     | 
     |     // Anything else: fresh value
  93 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn add_block_interference_with_values(
     |   block : Block,
     |   inter : Set[(LocalIdx, LocalIdx)],
     |   liveness : Map[Int, BlockLiveness],
     |   in_env : ValueEnv,
     |   counter : Ref[Int],
     |   consts : ConstTable,
     | ) -> Unit {
     |   let live = liveness[block.id].live_out.copy()
     | 
     |   // 1. Forward value environments
     |   let envs = [in_env.copy()]
     |   let curr = in_env.copy()
     |   for instr in block.instrs {
     |     match instr {
     |       TInstr::TLocalSet(idx, value) =>
     |         match value_of_expr(value, curr, counter, consts) {
     |           Some(v) => curr[idx] = v
 156 |           None => curr.remove(idx)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |     envs.push(curr.copy())
     |   }
     | 
     |   // 2. Backward interference
     |   for i in block.instrs.iter2().to_array().rev() {
     |     let (i, instr) = i
     |     let d = defs_shallow(instr)
     |     let u = uses_shallow(instr)
     |     let env_after = envs[i + 1]
     |     for x in d {
     |       for y in live {
     |         if x == y {
     |           continue
     |         }
     | 
     |         // Value numbering: if both have known values that are equal,
     |         // they can be coalesced ONLY if they have a future simultaneous use
     |         let vx = env_after.get(x)
     |         let vy = env_after.get(y)
     |         match (vx, vy) {
     |           (Some(vx_val), Some(vy_val)) =>
     |             if vx_val == vy_val {
     |               // Same value - check if they have a future simultaneous use
     |               if has_future_simultaneous_use(block.instrs, i + 1, x, y) {
     |                 // They will be used simultaneously, so no interference
     |                 continue
     |               }
     |             }
     |           _ => () // Unknown values - must add interference
     |         }
     | 
     |         // Otherwise, they interfere
     |         inter.add(ordered_pair(x, y))
     |       }
     |     }
     |     for x in d {
     |       live.remove(x)
     |     }
     |     for x in u {
     |       live.add(x)
     |     }
     |   }
     | }
     …

     | fn compute_coalesce_order(
     |   locals : Array[ValType],
     |   freq : Map[LocalIdx, Int],
     | ) -> Array[LocalIdx] {
     |   let order = Array::new()
     |   for i in 0..<locals.length() {
     |     order.push(LocalIdx::new(i.reinterpret_as_uint()))
     |   }
     |   order.sort_by(fn(a, b) {
     |     let l = freq.get(b).unwrap_or(0)
     |     let r = freq.get(a).unwrap_or(0)
     |     if l == r {
     |       0
 235 |     } else if l > r {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       1
     |     } else {
 238 |       -1
     |       ^^ 	<-- UNCOVERED
     |     }
     |   })
     |   order
     | }
     …

     | fn uses_shallow(instr : TInstr) -> Set[LocalIdx] {
     |   let result = Set::new()
     |   match instr {
     |     TInstr::TLocalGet(idx) => result.add(idx)
     |     TInstr::TLocalSet(_, value) =>
     |       // value is evaluated in this block
     |       for x in uses(value) {
     |         result.add(x)
     |       }
     |     TInstr::TIf(_, cond, _, _) =>
     |       // only condition belongs to this block
     |       for x in uses(cond) {
 257 |         result.add(x)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TInstr::TLoop(_, body) =>
     |       for b in body.0 {
     |         for x in uses(b) {
     |           result.add(x)
     |         }
     |       }
     |     _ =>
     |       for x in uses(instr) {
     |         result.add(x)
     |       }
     |   }
     |   result
     | }
     …

     | fn simulate_block_values(
     |   block : Block,
     |   in_env : ValueEnv,
     |   counter : Ref[Int],
     |   consts : ConstTable,
     | ) -> ValueEnv {
     |   let env = in_env.copy()
     |   for instr in block.instrs {
     |     match instr {
     |       TInstr::TLocalSet(idx, value) =>
     |         match value_of_expr(value, env, counter, consts) {
     |           Some(v) => env[idx] = v
     |           None =>
     |             // value becomes unknown
 298 |             env.remove(idx)
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |   }
     |   env
     | }
     …

     | fn compute_cfg_value_envs(
     |   blocks : Array[Block],
     |   locals : Array[ValType],
     |   counter : Ref[Int],
     |   consts : ConstTable,
     | ) -> (Map[Int, ValueEnv], Map[Int, ValueEnv]) {
     |   let values_in = Map::new()
     |   let values_out = Map::new()
     | 
     |   // Initialize
     |   for b in blocks {
     |     values_in[b.id] = Map::new()
     |     values_out[b.id] = Map::new()
     |   }
     |   let mut changed = true
     |   while changed {
     |     changed = false
     |     for b in blocks {
     | 
     |       // --- compute values_in ---
     |       let mut new_in = Map::new()
     |       if b.preds.length() == 1 {
     |         new_in = values_out[b.preds[0]]
     |       } else if b.preds.length() > 1 {
     |         // must-value intersection
     |         for i in 0..<locals.length() {
     |           let idx = LocalIdx::new(i.reinterpret_as_uint())
     |           let mut first = true
     |           let mut same : ValueId? = None
     |           for p in b.preds {
     |             match values_out[p].get(idx) {
     |               Some(v) =>
     |                 if first {
     |                   same = Some(v)
     |                   first = false
 342 |                 } else if same is Some(s) && s != v {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   same = None
     |                   break
     |                 }
     |               None => {
     |                 same = None
     |                 break
     |               }
     |             }
     |           }
     |           if same is Some(v) {
 353 |             new_in[idx] = v
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     | 
     |       // --- compute values_out ---
     |       let new_out = simulate_block_values(b, new_in, counter, consts)
     |       if new_out != values_out[b.id] {
     |         values_out[b.id] = new_out
     |         values_in[b.id] = new_in
     |         changed = true
     |       }
     |     }
     |   }
     |   (values_in, values_out)
     | }
     …

     | fn interferes(
     |   inter : Set[(LocalIdx, LocalIdx)],
     |   a : LocalIdx,
     |   b : LocalIdx,
     | ) -> Bool {
     |   if a == b {
 604 |     false
     |     ^^^^^ 	<-- UNCOVERED
     |   } else {
     |     inter.contains(ordered_pair(a, b))
     |   }
     | }
     …

     | fn must_be_same_value(
     |   a : LocalIdx,
     |   b : LocalIdx,
     |   blocks : Array[Block],
     |   values_out : Map[Int, ValueEnv],
     |   liveness : Map[Int, BlockLiveness],
     | ) -> Bool {
     | 
     |   // This function checks if two locals MUST hold the same value
     |   // at merge points (blocks with multiple predecessors).
     |   // It's used to allow coalescing even when there's interference,
     |   // if we can prove the locals always hold the same value.
     |   //
     |   // For single-block functions or non-merge points, we return false
     |   // because the interference graph already handles value numbering
     |   // for those cases.
     | 
     |   let mut found_merge_point = false
     |   for bblock in blocks {
     |     let bid = bblock.id
     | 
     |     // Only check merge points (blocks with multiple predecessors)
     |     if bblock.preds.length() <= 1 {
     |       continue
     |     }
     |     let live = liveness[bid].live_in
     | 
     |     // If both locals are not live here, skip
     |     if !live.contains(a) || !live.contains(b) {
 642 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     found_merge_point = true
     | 
     |     // Collect all defined values for a and b across all predecessors
     |     let mut defined_value : ValueId? = None
     |     let mut all_compatible = true
     |     for p in bblock.preds {
     |       let env = values_out[p]
     |       let va = env.get(a)
     |       let vb = env.get(b)
     | 
     |       // Check if either a or b is defined on this path
     |       match (va, vb) {
     |         // Both defined: must be equal
 657 |         (Some(x), Some(y)) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if x != y {
 659 |             all_compatible = false
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             break
     |           }
     |           // Both defined and equal: check against previously seen value
 663 |           match defined_value {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             None => defined_value = Some(x)
     |             Some(v) =>
 666 |               if v != x {
     |               ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 all_compatible = false
     |                 break
     |               }
     |           }
     |         }
     | 
     |         // Only a is defined
     |         (Some(x), None) =>
     |           match defined_value {
     |             None => defined_value = Some(x)
     |             Some(v) =>
     |               if v != x {
     |                 all_compatible = false
     |                 break
     |               }
     |           }
     | 
     |         // Only b is defined
     |         (None, Some(y)) =>
     |           match defined_value {
     |             None => defined_value = Some(y)
     |             Some(v) =>
     |               if v != y {
     |                 all_compatible = false
     |                 break
     |               }
     |           }
     | 
     |         // Neither defined: this path doesn't constrain the value
     |         (None, None) => ()
     |       }
     |     }
     |     if !all_compatible {
     |       return false
     |     }
     | 
     |     // If we found a consistent value across all paths, they can be coalesced
     |     if defined_value is None {
     |       return false
     |     }
     |   }
     | 
     |   // If we found at least one merge point where both are live,
     |   // and all checks passed, they must be equal
     |   found_merge_point
     | }
     …

     | fn coalesce_locals() -> ModuleTransformer[Unit] {
     |   ModuleTransformer::new().on_func_evt(fn(_, _, func) {
     |     match func {
 774 |       Func(_) => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TFunc(locals, body) => {
     |         let instrs = body.0
     |         let blocks = build_cfg(instrs)
     |         let (inter, _, values_out) = compute_interferences_cfg(blocks, locals)
     |         let liveness = compute_cfg_liveness(build_cfg(instrs))
     |         let copies = find_copies(instrs)
     |         let freq = copy_frequency(copies)
     |         let order = compute_coalesce_order(locals, freq)
     |         let mapping = compute_coalescing(
     |           locals, inter, order, blocks, values_out, liveness,
     |         )
     |         let (new_locals, rep_to_new) = compute_new_locals(locals, mapping)
     |         let final_map = compose_maps(mapping, rep_to_new)
     |         let new_body = rewrite_body_locals(body, final_map)
     |         change((), Func::t_func(new_locals, new_body))
     |       }
     |     }
     |   })
     | }
     …

     | fn coalesce_locals_pass(_mod : Module) -> ModuleTransformer[IRContext] {
 797 |   wrap_unit_func_pass(coalesce_locals())
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn rewrite_instr_locals(instr : TInstr, mapping : LocalMap) -> TInstr {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(_, _, i) {
     |     match i {
     |       TInstr::TLocalGet(idx) =>
     |         change((), TInstr::local_get(mapping.get(idx).unwrap()))
     |       TInstr::TLocalSet(idx, value) =>
     |         change((), TInstr::local_set(mapping.get(idx).unwrap(), value))
     |       TInstr::TLocalTee(idx, value) =>
 809 |         change((), TInstr::local_tee(mapping.get(idx).unwrap(), value))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => unchanged()
     |     }
     |   })
     |   let (_, expr) = walker
     |     .walk_texpr_default((), TExpr::new([instr]))
     |     .unwrap()
     |     .unwrap()
     |   let TExpr(instrs) = expr
     |   if instrs.length() == 1 {
     |     instrs[0]
     |   } else {
     |     // conservative fallback
 822 |     instr
     |     ^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn compute_coalescing_simple(
     |   locals : Array[ValType],
     |   inter : Set[(LocalIdx, LocalIdx)],
     |   order : Array[LocalIdx],
     | ) -> LocalMap {
     |   let mapping : LocalMap = Map::new()
     |   let reps : Array[LocalIdx] = Array::new()
     |   for li in order {
     |     let ty_i = locals[li.0.reinterpret_as_int()]
     |     let mut assigned = false
     |     for r in reps {
     |       let ty_r = locals[r.0.reinterpret_as_int()]
     |       if ty_i != ty_r {
 983 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if !interferes(inter, li, r) {
     |         mapping[li] = r
     |         assigned = true
     |         break
     |       }
     |     }
     |     if !assigned {
     |       mapping[li] = li
     |       reps.push(li)
     |     }
     |   }
     |   mapping
     | }
     …

57 uncovered line(s) in src/passes/code_folding.mbt:

     | fn is_terminating(instr : TInstr) -> Bool {
     |   match instr {
     |     TUnreachable => true
     |     TReturn(_) => true
     |     TReturnCall(_, _) => true
  95 |     TReturnCallIndirect(_, _, _, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TReturnCallRef(_, _, _) => true
     |     TThrow(_, _) => true
     |     TThrowRef(_) => true
     |     _ => false
     |   }
     | }
     …

     | fn is_branch(instr : TInstr) -> Bool {
     |   match instr {
     |     TBr(_, _) => true
     |     TBrIf(_, _, _) => true
 109 |     TBrTable(_, _, _, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBrOnNull(_, _, _) => true
     |     TBrOnNonNull(_, _, _) => true
     |     TBrOnCast(_, _, _, _, _, _) => true
     |     TBrOnCastFail(_, _, _, _, _, _) => true
     |     _ => false
     |   }
     | }
     …

     | fn get_branch_targets(instr : TInstr) -> Set[LabelIdx] {
     |   let targets = Set::new()
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, i) {
     |     match i {
     |       TBr(label, _) => targets.add(label)
 149 |       TBrIf(label, _, _) => targets.add(label)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TBrTable(labels, default, _, _) => {
     |         for label in labels {
     |           targets.add(label)
     |         }
     |         targets.add(default)
     |       }
 156 |       TBrOnNull(label, _, _) => targets.add(label)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TBrOnNonNull(label, _, _) => targets.add(label)
     |       TBrOnCast(label, _, _, _, _, _) => targets.add(label)
     |       TBrOnCastFail(label, _, _, _, _, _) => targets.add(label)
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), i)
     |   })
     |   ignore(walker.walk_tinstruction((), instr))
     |   targets
     | }
     …

     | fn can_move(items : Array[TInstr], container : TInstr) -> Bool {
     |   let all_targets = get_branch_targets(container)
     |   for item in items {
     |     let exiting = get_exiting_branches(item)
     |     // Check if there's any intersection
     |     for target in exiting.iter() {
 185 |       if all_targets.contains(target) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return false
     |       }
     |     }
     |   }
     |   true
     | }
     …

     | fn get_mergeable(tail : Tail, num : Int) -> TInstr? {
     |   if not(tail.is_fallthrough()) {
     |     // If there is a branch value, it is the first mergeable item
     |     match tail.instr {
     |       Some(TBr(_, values)) =>
 200 |         if values.length() > 0 && num == 0 {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Some(values[0])
     |         } else if values.is_empty() {
     |           // Skip the branch instruction at the end; it is not part of the merged tail
 204 |           let adjusted_num = num + 1
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if adjusted_num >= tail.block_instrs.length() {
 206 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           return Some(
 209 |             tail.block_instrs[tail.block_instrs.length() - adjusted_num - 1],
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           )
     |         }
     |       _ => ()
     |     }
     |   }
     |   if num >= tail.block_instrs.length() {
     |     return None
     |   }
     |   Some(tail.block_instrs[tail.block_instrs.length() - num - 1])
     | }
     …

     | fn optimize_expression_tails(
     |   state : CodeFoldingState,
     |   tails : Array[Tail],
     |   curr : TInstr,
     | ) -> TInstr? {
     |   if tails.length() < 2 {
 229 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Check if anything is untoward
     |   for tail in tails {
     |     match tail.instr {
 235 |       Some(i) if state.modifieds.contains(i) => return None
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |   }
     | 
     |   // Find mergeable items
     |   let mergeable : Array[TInstr] = []
     |   let mut saved = 0
     |   let mut num = 0
     |   while true {
     |     match get_mergeable(tails[0], num) {
 246 |       None => break
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(item) => {
     |         // Check if all tails have matching items
     |         let mut all_match = true
     |         for i = 1; i < tails.length(); i = i + 1 {
     |           match get_mergeable(tails[i], num) {
 252 |             None => {
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               all_match = false
     |               break
     |             }
     |             Some(other) =>
     |               if item != other {
     |                 all_match = false
     |                 break
     |               }
     |           }
     |         }
     |         if not(all_match) {
     |           break
     |         }
     | 
     |         // Check if we can move it
     |         if not(can_move([item], curr)) {
 269 |           break
     |           ^^^^^ 	<-- UNCOVERED
     |         }
     | 
     |         // We found another one we can merge
     |         mergeable.push(item)
     |         saved += measure(item)
     |         num += 1
     |       }
     |     }
     |   }
     |   if saved == 0 {
     |     return None
     |   }
     | 
     |   // Check if it's worth it
     |   if saved < WORTH_ADDING_BLOCK_TO_REMOVE_THIS_MUCH {
     |     // See if we get rid of a block
     |     let mut will_empty_block = false
     |     for tail in tails {
     |       if mergeable.length() >= tail.block_instrs.length() - 1 {
     |         will_empty_block = true
     |         break
     |       }
     |     }
     |     if not(will_empty_block) {
 294 |       return None
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   // Do the optimization - remove merged items from each tail
     |   state.another_pass = true
     |   let merge_count = mergeable.length()
     | 
     |   // Remove items from each tail's block
     |   for tail in tails {
     |     let block = tail.block_instrs
     |     // How many to remove from this block
     |     let to_remove = merge_count
     |     // Remove from the end
     |     let mut removed = 0
     |     while removed < to_remove && block.length() > 0 {
     |       ignore(block.pop())
     |       removed += 1
     |     }
     |     // Mark the tail's branch instruction as modified if present
     |     match tail.instr {
 315 |       Some(i) => state.modifieds.add(i)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => ()
     |     }
     |   }
     | 
     |   // Return the merged items in correct order (they were collected in reverse)
     |   // The caller will need to append these after the current instruction
     |   Some(mergeable[0]) // Return first merged item as indicator of change
     | }
     …

     | fn optimize_terminating_tails(
     |   state : CodeFoldingState,
     |   tails : Array[Tail],
     |   func_body : Array[TInstr],
     | ) -> Array[TInstr]? {
     |   if tails.length() < 2 {
     |     return None
     |   }
     | 
     |   // Check if anything is modified
     |   for tail in tails {
     |     match tail.instr {
 340 |       Some(i) if state.modifieds.contains(i) => return None
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |   }
     | 
     |   // Find mergeable items from the tails
     |   let mergeable : Array[TInstr] = []
     |   let mut saved = 0
     |   let mut num = 0
     |   while true {
     |     match get_mergeable(tails[0], num) {
 351 |       None => break
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(item) => {
     |         // Check if all tails have matching items
     |         let mut all_match = true
     |         for i = 1; i < tails.length(); i = i + 1 {
     |           match get_mergeable(tails[i], num) {
 357 |             None => {
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               all_match = false
     |               break
     |             }
     |             Some(other) =>
     |               if item != other {
     |                 all_match = false
     |                 break
     |               }
     |           }
     |         }
     |         if not(all_match) {
     |           break
     |         }
     | 
     |         // We found another one we can merge
 373 |         mergeable.push(item)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         saved += measure(item)
     |         num += 1
     |       }
     |     }
     |   }
     |   if saved < MIN_TERMINATING_TAIL_SAVINGS {
     |     return None
     |   }
     | 
     |   // Do the optimization
     |   state.another_pass = true
 385 |   let merge_count = mergeable.length()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Remove merged items from each tail
     |   for tail in tails {
 389 |     let block = tail.block_instrs
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     let mut removed = 0
     |     while removed < merge_count && block.length() > 0 {
 392 |       ignore(block.pop())
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       removed += 1
     |     }
 395 |     match tail.instr {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(i) => state.modifieds.add(i)
     |       None => ()
     |     }
     |   }
     | 
     |   // Build new function body with merged items at the end
     |   // The merged items should go before a final return/unreachable
     |   let result : Array[TInstr] = []
     |   for instr in func_body {
 405 |     result.push(instr)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   // Add merged items in reverse order (they were collected from end to start)
     |   let mut j = merge_count - 1
     |   while j >= 0 {
 410 |     result.push(mergeable[j])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     j -= 1
     |   }
     |   Some(result)
     | }
     …

     | fn collect_block_tails(
     |   state : CodeFoldingState,
     |   instrs : Array[TInstr],
     | ) -> Unit {
     |   for i = 0; i < instrs.length(); i = i + 1 {
     |     let instr = instrs[i]
     |     match instr {
     |       // Unconditional branch at end of block
     |       TBr(label, _) if i == instrs.length() - 1 => {
     |         let tails = state.break_tails.get(label).unwrap_or([])
     |         tails.push(Tail::branch(instr, instrs))
     |         state.break_tails.set(label, tails)
     |       }
     | 
     |       // Conditional branches are not optimizable
     |       TBrIf(label, _, _) => state.unoptimizables.add(label)
     |       TBrTable(labels, default, _, _) => {
     |         for label in labels {
     |           state.unoptimizables.add(label)
     |         }
     |         state.unoptimizables.add(default)
     |       }
 440 |       TBrOnNull(label, _, _) => state.unoptimizables.add(label)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TBrOnNonNull(label, _, _) => state.unoptimizables.add(label)
     |       TBrOnCast(label, _, _, _, _, _) => state.unoptimizables.add(label)
     |       TBrOnCastFail(label, _, _, _, _, _) => state.unoptimizables.add(label)
     | 
     |       // Unreachable at end of block
     |       TUnreachable if i == instrs.length() - 1 =>
     |         state.unreachable_tails.push(Tail::branch(instr, instrs))
     | 
     |       // Return at end of block
     |       TReturn(_) if i == instrs.length() - 1 =>
     |         state.return_tails.push(Tail::branch(instr, instrs))
     | 
     |       // Return calls
     |       TReturnCall(_, _) if i == instrs.length() - 1 =>
 455 |         state.return_tails.push(Tail::branch(instr, instrs))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TReturnCallIndirect(_, _, _, _) if i == instrs.length() - 1 =>
 457 |         state.return_tails.push(Tail::branch(instr, instrs))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TReturnCallRef(_, _, _) if i == instrs.length() - 1 =>
 459 |         state.return_tails.push(Tail::branch(instr, instrs))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |       // Recursively process nested blocks
     |       TBlock(_, body) => collect_block_tails(state, body.0)
     |       TLoop(_, body) => collect_block_tails(state, body.0)
     |       TIf(_, _, then_body, else_body) => {
     |         collect_block_tails(state, then_body.0)
     |         match else_body {
     |           Some(body) => collect_block_tails(state, body.0)
 468 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 471 |       TTryTable(_, _, body) => collect_block_tails(state, body.0)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |   }
     | }
     …

     | fn process_block(
     |   state : CodeFoldingState,
     |   label : LabelIdx,
     |   instrs : Array[TInstr],
     | ) -> TInstr? {
     |   if instrs.is_empty() {
 485 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if state.unoptimizables.contains(label) {
 488 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match state.break_tails.get(label) {
     |     None => None
 492 |     Some(tails) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // Check if the end of the block can be reached
     |       let mut include_fallthrough = true
     |       for instr in instrs {
 496 |         match instr {
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TUnreachable => {
     |             include_fallthrough = false
     |             break
     |           }
 501 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       let all_tails = if include_fallthrough {
 505 |         let result = tails.copy()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         result.push(Tail::fallthrough(instrs))
     |         result
     |       } else {
 509 |         tails
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       // Try to optimize
 513 |       optimize_expression_tails(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         state,
     |         all_tails,
 516 |         TInstr::block(BlockType::void_(), TExpr::new(instrs)),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
     |   }
     | }
     …

     | fn process_if(
     |   state : CodeFoldingState,
     |   cond : TInstr,
     |   then_body : TExpr,
     |   else_body : TExpr?,
     | ) -> TInstr? {
     |   match else_body {
 531 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(else_expr) => {
     |       // Both arms must be present
     |       let tails = [
     |         Tail::fallthrough(then_body.0),
     |         Tail::fallthrough(else_expr.0),
     |       ]
     |       optimize_expression_tails(
     |         state,
     |         tails,
     |         TInstr::if_(BlockType::void_(), cond, then_body, Some(else_expr)),
     |       )
     |     }
     |   }
     | }
     …

     | fn code_folding_pass() -> ModuleTransformer[CodeFoldingState] {
     |   ModuleTransformer::new()
     |   .on_tinstruction_evt(fn(self, state, instr) {
     |     // Process blocks and ifs for tail merging
     |     match instr {
     |       TBlock(bt, body) =>
     |         // First recurse into children
     |         match self.walk_tinstruction_default(state, instr) {
     |           Ok(Some((new_state, new_instr))) =>
     |             match new_instr {
     |               TBlock(_, new_body) =>
     |                 // Try to optimize the block's tails
     |                 match process_block(new_state, LabelIdx::new(0), new_body.0) {
     |                   Some(_) =>
     |                     // Block was modified
 564 |                     change(new_state, TInstr::block(bt, new_body))
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   None => change(new_state, new_instr)
     |                 }
 567 |               _ => change(new_state, new_instr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           Ok(None) =>
     |             // Try to optimize unchanged block
 571 |             match process_block(state, LabelIdx::new(0), body.0) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(_) => change(state, instr)
     |               None => unchanged()
     |             }
 575 |           Err(e) => Err(e)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TIf(bt, cond, then_body, else_body) =>
     |         // First recurse into children
     |         match self.walk_tinstruction_default(state, instr) {
     |           Ok(Some((new_state, new_instr))) =>
     |             match new_instr {
     |               TIf(_, new_cond, new_then, new_else) =>
     |                 // Try to optimize the if's tails
     |                 match process_if(new_state, new_cond, new_then, new_else) {
     |                   Some(_) =>
     |                     // If was modified
     |                     change(
     |                       new_state,
     |                       TInstr::if_(bt, new_cond, new_then, new_else),
     |                     )
     |                   None => change(new_state, new_instr)
     |                 }
 593 |               _ => change(new_state, new_instr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           Ok(None) =>
     |             // Try to optimize unchanged if
 597 |             match process_if(state, cond, then_body, else_body) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(_) => change(state, instr)
     |               None => unchanged()
     |             }
 601 |           Err(e) => Err(e)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => self.walk_tinstruction_default(state, instr)
     |     }
     |   })
     |   .on_func_evt(fn(self, state, func) {
     |     match func {
 608 |       Func(_) => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TFunc(locals, body) => {
     |         // Run multiple passes until no more changes
     |         let mut current_func = func
     |         let mut current_locals = locals
     |         let mut current_body = body
     |         state.another_pass = true
     |         while state.another_pass {
     |           state.another_pass = false
     |           state.clear()
     | 
     |           // Collect tails from function body
     |           collect_block_tails(state, current_body.0)
     | 
     |           // Try terminating tail optimization (returns/unreachables)
     |           match
     |             optimize_terminating_tails(
     |               state,
     |               state.return_tails.copy(),
     |               current_body.0,
     |             ) {
 629 |             Some(new_body_instrs) => {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               current_body = TExpr::new(new_body_instrs)
     |               current_func = Func::t_func(current_locals, current_body)
     |             }
     |             None =>
     |               // Try unreachable tails
     |               match
     |                 optimize_terminating_tails(
     |                   state,
     |                   state.unreachable_tails.copy(),
     |                   current_body.0,
     |                 ) {
 641 |                 Some(new_body_instrs) => {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   current_body = TExpr::new(new_body_instrs)
     |                   current_func = Func::t_func(current_locals, current_body)
     |                 }
     |                 None => ()
     |               }
     |           }
     | 
     |           // Process the function with collected information
     |           match self.walk_func_default(state, current_func) {
     |             Ok(Some((new_state, new_func))) => {
     |               state.another_pass = new_state.another_pass
     |               current_func = new_func
     |               match current_func {
     |                 TFunc(l, b) => {
     |                   current_locals = l
     |                   current_body = b
     |                 }
 659 |                 _ => ()
     |                 ^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
 662 |             Ok(None) => ()
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => return Err(e)
     |           }
     |         }
     |         if current_func == func {
     |           unchanged()
     |         } else {
 669 |           change(state, current_func)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   })
     | }
     …

     | fn code_folding_ir_pass(_mod : Module) -> ModuleTransformer[IRContext] {
     |   let pass = code_folding_pass()
     |   ModuleTransformer::new().on_func_evt(fn(_, ctx : IRContext, func : Func) {
     |     match pass.walk_func(CodeFoldingState::new(), func) {
     |       Ok(Some((_, new_func))) => change(ctx, new_func)
 682 |       Ok(None) => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Err(e) => Err(e)
     |     }
     |   })
     | }
     …

     | fn run_fold(f : Func) -> Func raise {
     |   let pass = code_folding_pass()
     |   let state = CodeFoldingState::{
     |     ..CodeFoldingState::new(),
     |     another_pass: false,
     |   }
     |   match pass.walk_func(state, f) {
     |     Ok(Some((_, new_f))) => return new_f
 736 |     Ok(None) => ()
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => assert_true(false, msg=e)
     |   }
     |   f
     | }
     …

136 uncovered line(s) in src/passes/code_pushing.mbt:

     | fn LocalAnalyzer::get_num_gets(self : LocalAnalyzer, index : LocalIdx) -> Int {
     |   let i = index.0.reinterpret_as_int()
     |   if i >= 0 && i < self.num_gets.length() {
  54 |     self.num_gets[i]
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     0
     |   }
     | }
     …

     | fn analyze_function(func : Func) -> LocalAnalyzer {
     |   match func {
     |     Func(_, _) =>
     |       // For non-TFunc, we can't analyze
  66 |       LocalAnalyzer::new(0)
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(params, body) => {
     |       let num_locals = params.length()
     |       let analyzer = LocalAnalyzer::new(num_locals)
     | 
     |       // Mark all non-parameters as potentially SFA
     |       for i = 0; i < num_locals; i = i + 1 {
     |         analyzer.sfa[i] = true
     |       }
     | 
     |       // Walk the function body to count sets and gets
     |       analyze_expr(body, analyzer, true)
     | 
     |       // Finalize: if no sets, not SFA
     |       for i = 0; i < num_locals; i = i + 1 {
     |         if analyzer.num_sets[i] == 0 {
  82 |           analyzer.sfa[i] = false
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       analyzer
     |     }
     |   }
     | }
     …

     | fn analyze_instr(
     |   instr : TInstr,
     |   analyzer : LocalAnalyzer,
     |   before_first_set : Bool,
     | ) -> Unit {
     |   match instr {
     |     TLocalGet(idx) => {
     |       let i = idx.0.reinterpret_as_int()
     |       if i >= 0 && i < analyzer.num_gets.length() {
     |         // If we see a get before any set, not SFA
     |         if before_first_set && analyzer.num_sets[i] == 0 {
     |           analyzer.sfa[i] = false
     |         }
     |         analyzer.num_gets[i] += 1
     |       }
     |     }
     |     TLocalSet(idx, value) => {
     |       let i = idx.0.reinterpret_as_int()
     |       if i >= 0 && i < analyzer.num_sets.length() {
     |         analyzer.num_sets[i] += 1
     |         // More than one set means not SFA
     |         if analyzer.num_sets[i] > 1 {
     |           analyzer.sfa[i] = false
     |         }
     |       }
     |       // Recurse into the value
     |       analyze_instr(value, analyzer, before_first_set)
     |     }
     |     TLocalTee(idx, value) => {
     |       let i = idx.0.reinterpret_as_int()
     |       if i >= 0 && i < analyzer.num_sets.length() {
     |         analyzer.num_sets[i] += 1
     |         if analyzer.num_sets[i] > 1 {
 137 |           analyzer.sfa[i] = false
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       analyze_instr(value, analyzer, before_first_set)
     |     }
     |     // Recurse into nested structures
     |     TBlock(_, body) => analyze_expr(body, analyzer, before_first_set)
 144 |     TLoop(_, body) => analyze_expr(body, analyzer, before_first_set)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       analyze_instr(cond, analyzer, before_first_set)
     |       analyze_expr(then_body, analyzer, before_first_set)
     |       match else_body {
     |         Some(body) => analyze_expr(body, analyzer, before_first_set)
 150 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => ()
     |   }
     | }
     …

     | fn Effects::invalidates(self : Effects, other : Effects) -> Bool {
     |   // Check local conflicts
     |   for loc in self.writes_locals {
     |     if other.reads_locals.contains(loc) || other.writes_locals.contains(loc) {
     |       return true
     |     }
     |   }
     |   for loc in self.reads_locals {
     |     if other.writes_locals.contains(loc) {
     |       return true
     |     }
     |   }
     |   // Check memory conflicts
     |   if (self.reads_memory && other.writes_memory) ||
     |     (self.writes_memory && other.reads_memory) ||
     |     (self.writes_memory && other.writes_memory) {
     |     return true
     |   }
     |   // Check global conflicts
     |   if (self.reads_globals && other.writes_globals) ||
     |     (self.writes_globals && other.reads_globals) ||
     |     (self.writes_globals && other.writes_globals) {
 213 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   // Calls can conflict with anything
     |   if self.calls || other.calls {
 217 |     if self.reads_memory ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.writes_memory ||
     |       other.reads_memory ||
     |       other.writes_memory ||
     |       self.reads_globals ||
     |       self.writes_globals ||
     |       other.reads_globals ||
     |       other.writes_globals {
 225 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   false
     | }
     …

     | fn Effects::merge(self : Effects, other : Effects) -> Unit {
     |   for loc in other.reads_locals {
 234 |     self.reads_locals.add(loc)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for loc in other.writes_locals {
     |     self.writes_locals.add(loc)
     |   }
     |   self.reads_memory = self.reads_memory || other.reads_memory
     |   self.writes_memory = self.writes_memory || other.writes_memory
     |   self.reads_globals = self.reads_globals || other.reads_globals
     |   self.writes_globals = self.writes_globals || other.writes_globals
     |   self.calls = self.calls || other.calls
     |   self.branches = self.branches || other.branches
     |   self.traps = self.traps || other.traps
     |   self.throws = self.throws || other.throws
     | }
     …

     | fn analyze_effects_into(instr : TInstr, effects : Effects) -> Unit {
     |   match instr {
     |     // Local operations
     |     TLocalGet(idx) => effects.reads_locals.add(idx)
     |     TLocalSet(idx, value) => {
     |       effects.writes_locals.add(idx)
     |       analyze_effects_into(value, effects)
     |     }
 266 |     TLocalTee(idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_locals.add(idx)
     |       effects.writes_locals.add(idx)
     |       analyze_effects_into(value, effects)
     |     }
     | 
     |     // Global operations
     |     TGlobalGet(_) => effects.reads_globals = true
     |     TGlobalSet(_, value) => {
     |       effects.writes_globals = true
     |       analyze_effects_into(value, effects)
     |     }
     | 
     |     // Memory operations
     |     TLoad(_, _, ptr) => {
     |       effects.reads_memory = true
     |       analyze_effects_into(ptr, effects)
     |     }
     |     TStore(_, _, ptr, value) => {
     |       effects.writes_memory = true
     |       analyze_effects_into(ptr, effects)
     |       analyze_effects_into(value, effects)
     |     }
 289 |     TMemoryGrow(_, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
 291 |       analyze_effects_into(value, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 293 |     TMemorySize(_) => effects.reads_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryCopy(_, _, dst, src, len) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
 297 |       analyze_effects_into(dst, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       analyze_effects_into(src, effects)
     |       analyze_effects_into(len, effects)
     |     }
 301 |     TMemoryFill(_, dst, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
 303 |       analyze_effects_into(dst, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       analyze_effects_into(val, effects)
     |       analyze_effects_into(len, effects)
     |     }
     | 
     |     // Calls - have arbitrary side effects
     |     TCall(_, args) => {
     |       effects.calls = true
     |       for i = 0; i < args.length(); i = i + 1 {
     |         analyze_effects_into(args[i], effects)
     |       }
     |     }
 315 |     TCallIndirect(_, _, args, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
 317 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         analyze_effects_into(args[i], effects)
     |       }
 320 |       analyze_effects_into(table_idx, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 322 |     TCallRef(_, args, funcref) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
 324 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         analyze_effects_into(args[i], effects)
     |       }
 327 |       analyze_effects_into(funcref, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 329 |     TReturnCall(_, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
     |       effects.branches = true
 332 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         analyze_effects_into(args[i], effects)
     |       }
     |     }
 336 |     TReturnCallIndirect(_, _, args, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
     |       effects.branches = true
 339 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         analyze_effects_into(args[i], effects)
     |       }
 342 |       analyze_effects_into(table_idx, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 344 |     TReturnCallRef(_, args, funcref) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
     |       effects.branches = true
 347 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         analyze_effects_into(args[i], effects)
     |       }
 350 |       analyze_effects_into(funcref, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Control flow
 354 |     TBr(_, args) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.branches = true
     |       for arg in args {
 357 |         analyze_effects_into(arg, effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 360 |     TBrIf(_, cond, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.branches = true
 362 |       analyze_effects_into(cond, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 364 |         analyze_effects_into(arg, effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 367 |     TBrTable(_, _, index, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.branches = true
 369 |       analyze_effects_into(index, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 371 |         analyze_effects_into(arg, effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 374 |     TReturn(args) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.branches = true
     |       for arg in args {
 377 |         analyze_effects_into(arg, effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     // Trapping operations
 382 |     TUnreachable => effects.traps = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Exception handling
 385 |     TThrow(_, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.throws = true
     |       for arg in args {
 388 |         analyze_effects_into(arg, effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 391 |     TThrowRef(value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.throws = true
 393 |       analyze_effects_into(value, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Nested structures - analyze their contents
 397 |     TBlock(_, body) => analyze_effects_expr(body, effects)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoop(_, body) => analyze_effects_expr(body, effects)
     |     TIf(_, cond, then_body, else_body) => {
     |       analyze_effects_into(cond, effects)
     |       analyze_effects_expr(then_body, effects)
     |       match else_body {
     |         Some(body) => analyze_effects_expr(body, effects)
     |         None => ()
     |       }
     |     }
 407 |     TTryTable(_, _, body) => analyze_effects_expr(body, effects)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Binary operations - check for trapping
     |     TBinary(op, lhs, rhs) => {
     |       // Division and remainder can trap
     |       match op {
     |         I32DivSOp
     |         | I32DivUOp
     |         | I32RemSOp
     |         | I32RemUOp
     |         | I64DivSOp
     |         | I64DivUOp
     |         | I64RemSOp
     |         | I64RemUOp => effects.traps = true
 421 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |       analyze_effects_into(lhs, effects)
     |       analyze_effects_into(rhs, effects)
     |     }
     | 
     |     // Unary operations - check for trapping conversions
 428 |     TUnary(op, operand) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match op {
     |         I32TruncF32SOp
     |         | I32TruncF32UOp
     |         | I32TruncF64SOp
     |         | I32TruncF64UOp
     |         | I64TruncF32SOp
     |         | I64TruncF32UOp
     |         | I64TruncF64SOp
 437 |         | I64TruncF64UOp => effects.traps = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
 440 |       analyze_effects_into(operand, effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Select
 444 |     TSelect(_, cond, if_true, if_false) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       analyze_effects_into(cond, effects)
     |       analyze_effects_into(if_true, effects)
     |       analyze_effects_into(if_false, effects)
     |     }
     | 
     |     // Drop
 451 |     TDrop(value) => analyze_effects_into(value, effects)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Pure instructions (no side effects beyond their children)
     |     TNop
     |     | TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TV128Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_) => ()
     | 
     |     // Default: assume no additional effects beyond children
 464 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn analyze_effects_expr(expr : TExpr, effects : Effects) -> Unit {
 470 |   for instr in expr.0 {
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     analyze_effects_into(instr, effects)
     |   }
     | }
     …

     | fn is_push_point(instr : TInstr) -> Bool {
     |   // Look through drops
     |   let target = match instr {
 480 |     TDrop(value) => value
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => instr
     |   }
     |   match target {
     |     TIf(_, _, _, _) => true
     |     TBrIf(_, _, _) => true
 486 |     TBrOnNull(_, _, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBrOnNonNull(_, _, _) => true
     |     TBrOnCast(_, _, _, _, _, _) => true
     |     TBrOnCastFail(_, _, _, _, _, _) => true
     |     _ => false
     |   }
     | }
     …

     | fn is_pushable(
     |   instr : TInstr,
     |   analyzer : LocalAnalyzer,
     |   num_gets_so_far : Array[Int],
     | ) -> (LocalIdx, TInstr)? {
     |   match instr {
     |     TLocalSet(idx, value) => {
     |       let i = idx.0.reinterpret_as_int()
     |       // Must be SFA and no gets have been seen yet (all gets are after this point)
     |       if i >= 0 &&
     |         i < analyzer.sfa.length() &&
     |         analyzer.is_sfa(idx) &&
     |         num_gets_so_far[i] == 0 {
     |         // Check if the value has unremovable side effects
     |         let effects = analyze_effects(value)
     |         // We can push if there are no side effects that would be problematic
     |         // Traps are ok since we're moving to execute less often
     |         if not(effects.calls) &&
     |           not(effects.throws) &&
     |           not(effects.writes_memory) &&
     |           not(effects.writes_globals) {
     |           return Some((idx, value))
     |         }
     |       }
     |       None
     |     }
 523 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn count_local_get(state : PushingState, idx : LocalIdx) -> Unit {
 538 |   let i = idx.0.reinterpret_as_int()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if i >= 0 && i < state.num_gets_so_far.length() {
 540 |     state.num_gets_so_far[i] += 1
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn count_gets_in_instr(state : PushingState, instr : TInstr) -> Unit {
 547 |   match instr {
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalGet(idx) => count_local_get(state, idx)
     |     TLocalSet(_, value) => count_gets_in_instr(state, value)
     |     TLocalTee(idx, value) => {
     |       count_local_get(state, idx)
     |       count_gets_in_instr(state, value)
     |     }
 554 |     TBlock(_, body) => count_gets_in_expr(state, body)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoop(_, body) => count_gets_in_expr(state, body)
     |     TIf(_, cond, then_body, else_body) => {
     |       count_gets_in_instr(state, cond)
     |       count_gets_in_expr(state, then_body)
     |       match else_body {
     |         Some(body) => count_gets_in_expr(state, body)
     |         None => ()
     |       }
     |     }
 564 |     _ => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       // Use a walker to find all local.gets
 566 |       let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, i) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match i {
     |           TLocalGet(idx) => count_local_get(state, idx)
     |           _ => ()
     |         }
 571 |         self.walk_tinstruction_default((), i)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       })
 573 |       ignore(walker.walk_tinstruction((), instr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn count_gets_in_expr(state : PushingState, expr : TExpr) -> Unit {
 580 |   for instr in expr.0 {
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     count_gets_in_instr(state, instr)
     |   }
     | }
     …

     | fn optimize_segment(
     |   list : Array[TInstr],
     |   first_pushable : Int,
     |   push_point : Int,
     |   state : PushingState,
     | ) -> Int {
     |   // Collect effects of the push point
 595 |   let cumulative_effects = analyze_effects(list[push_point])
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Find what we can push (working backwards from push point)
     |   let to_push : Array[Int] = []
     |   let mut i = push_point - 1
     |   while i >= first_pushable {
 601 |     match is_pushable(list[i], state.analyzer, state.num_gets_so_far) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some((_, _)) => {
     |         let effects = analyze_effects(list[i])
     |         if not(cumulative_effects.invalidates(effects)) {
     |           // Can push this!
 606 |           to_push.push(i)
     |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           // Can't push, add to cumulative effects
 609 |           cumulative_effects.merge(effects)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       None =>
     |         // Not pushable, add effects
 614 |         cumulative_effects.merge(analyze_effects(list[i]))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     i -= 1
     |   }
     |   if to_push.is_empty() {
 619 |     return push_point + 1
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Perform the push: remove items and reinsert after push point
     |   state.changed = true
     | 
     |   // Sort indices in descending order (we'll remove from back to front)
 626 |   to_push.rev_in_place()
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Collect the instructions to push
     |   let pushed_instrs : Array[TInstr] = []
     |   for idx in to_push {
 631 |     pushed_instrs.push(list[idx])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Replace pushed instructions with nops (we'll compact later)
     |   for idx in to_push {
 636 |     list[idx] = TInstr::nop()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Insert pushed instructions after push point
     |   // We need to splice them in
     |   let new_list : Array[TInstr] = []
 642 |   for j = 0; j <= push_point; j = j + 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     new_list.push(list[j])
     |   }
     |   // Add pushed instructions (in original order)
 646 |   pushed_instrs.rev_in_place()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for instr in pushed_instrs {
 648 |     new_list.push(instr)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 650 |   for j = push_point + 1; j < list.length(); j = j + 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     new_list.push(list[j])
     |   }
     | 
     |   // Update the list in place
 655 |   list.clear()
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for instr in new_list {
 657 |     list.push(instr)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Remove the nops
 661 |   compact_nops(list)
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Return position after push point minus the number we pushed
 664 |   push_point - to_push.length() + 1
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn compact_nops(list : Array[TInstr]) -> Unit {
 670 |   let new_list : Array[TInstr] = []
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for instr in list {
 672 |     match instr {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TNop => continue
     |       _ => new_list.push(instr)
     |     }
     |   }
 677 |   list.clear()
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for instr in new_list {
 679 |     list.push(instr)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn optimize_into_if(
     |   list : Array[TInstr],
     |   first_pushable : Int,
     |   push_point : Int,
     |   state : PushingState,
     | ) -> Unit {
     |   // Check if push point is an if
 692 |   let iff = match list[push_point] {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(bt, cond, then_body, else_body) => (bt, cond, then_body, else_body)
     |     _ => return
     |   }
     |   let (bt, cond, then_body, else_body_opt) = iff
     | 
     |   // Effects of the condition (must push past this)
 699 |   let cumulative_effects = analyze_effects(cond)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Effects of each arm
 702 |   let if_true_effects = analyze_effects_for_expr(then_body)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let if_false_effects = match else_body_opt {
     |     Some(body) => analyze_effects_for_expr(body)
     |     None => Effects::new()
     |   }
     | 
     |   // Effects after the if
 709 |   let post_if_effects = Effects::new()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for j = push_point + 1; j < list.length(); j = j + 1 {
     |     post_if_effects.merge(analyze_effects(list[j]))
     |   }
     | 
     |   // Work backwards from push point
     |   let mut i = push_point - 1
     |   while i >= first_pushable {
 717 |     match is_pushable(list[i], state.analyzer, state.num_gets_so_far) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some((idx, value)) => {
     |         let effects = analyze_effects(list[i])
     |         if cumulative_effects.invalidates(effects) {
     |           // Can't move past condition
 722 |           cumulative_effects.merge(effects)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           i -= 1
     |           continue
     |         }
     | 
     |         // Try to push into if-true arm
 728 |         let pushed = try_push_into_arm(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           list, i, idx, value, then_body, else_body_opt, if_true_effects, if_false_effects,
     |           post_if_effects, state, bt, cond, push_point, true,
     |         )
     |         if pushed {
     |           // Update cumulative effects with what we just pushed
 734 |           if_true_effects.merge(effects)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           i -= 1
     |           continue
     |         }
     | 
     |         // Try to push into if-false arm
 740 |         match else_body_opt {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(else_body) => {
     |             let pushed2 = try_push_into_arm(
     |               list,
     |               i,
     |               idx,
     |               value,
     |               else_body,
     |               Some(then_body),
     |               if_false_effects,
     |               if_true_effects,
     |               post_if_effects,
     |               state,
     |               bt,
     |               cond,
     |               push_point,
     |               false,
     |             )
     |             if pushed2 {
 759 |               if_false_effects.merge(effects)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               i -= 1
     |               continue
     |             }
     |           }
 764 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     | 
     |         // Couldn't push, add to cumulative
 768 |         cumulative_effects.merge(effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 770 |       None => cumulative_effects.merge(analyze_effects(list[i]))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     i -= 1
     |   }
     | }
     …

     | fn analyze_effects_for_expr(expr : TExpr) -> Effects {
 778 |   let effects = Effects::new()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   analyze_effects_expr(expr, effects)
     |   effects
     | }
     …

     | fn try_push_into_arm(
     |   list : Array[TInstr],
     |   set_idx : Int,
     |   local_idx : LocalIdx,
     |   _value : TInstr,
     |   arm : TExpr,
     |   other_arm : TExpr?,
     |   arm_effects : Effects,
     |   other_arm_effects : Effects,
     |   post_if_effects : Effects,
     |   state : PushingState,
     |   bt : BlockType,
     |   cond : TInstr,
     |   push_point : Int,
     |   is_then : Bool,
     | ) -> Bool {
     |   // The arm must read this local
 802 |   if not(arm_effects.reads_locals.contains(local_idx)) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return false
     |   }
     |   // The other arm must not read this local
     |   if other_arm_effects.reads_locals.contains(local_idx) {
 807 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   // If the local is read after the if, the other arm must be unreachable
     |   if post_if_effects.reads_locals.contains(local_idx) {
 811 |     match other_arm {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(other) => {
     |         // Check if other arm is unreachable
     |         let other_instrs = other.0
     |         if other_instrs.is_empty() {
 816 |           return false
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
 818 |         let last = other_instrs[other_instrs.length() - 1]
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match last {
     |           TUnreachable | TReturn(_) | TBr(_, _) => ()
     |           _ => return false
     |         }
     |       }
 824 |       None => return false
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   // We can push! Insert at the beginning of the arm
     |   state.changed = true
     |   let set_instr = list[set_idx]
 831 |   list[set_idx] = TInstr::nop()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Create new arm with the instruction prepended
     |   let new_arm_instrs : Array[TInstr] = [set_instr]
     |   for instr in arm.0 {
 836 |     new_arm_instrs.push(instr)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 838 |   let new_arm = TExpr::new(new_arm_instrs)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Rebuild the if
     |   let (new_then, new_else) = if is_then {
 842 |     (new_arm, other_arm)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
 844 |     let orig_then = match list[push_point] {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TIf(_, _, t, _) => t
     |       _ => arm // fallback
     |     }
     |     (orig_then, Some(new_arm))
     |   }
 850 |   list[push_point] = TInstr::if_(bt, cond, new_then, new_else)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   compact_nops(list)
     |   true
     | }
     …

     | fn push_code_in_block(list : Array[TInstr], state : PushingState) -> Unit {
 858 |   if list.length() < 2 {
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     | 
     |   // Find optimization segments
     |   let nothing : Int = -1
     |   let mut i = 0
     |   let mut first_pushable = nothing
     |   while i < list.length() {
     |     // Check if this is pushable
 868 |     if first_pushable == nothing {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match is_pushable(list[i], state.analyzer, state.num_gets_so_far) {
     |         Some(_) => first_pushable = i
     |         None => ()
     |       }
     |     }
     | 
     |     // Check if this is a push point
     |     if first_pushable != nothing && is_push_point(list[i]) {
     |       // Optimize into if first (doesn't move push point)
 878 |       optimize_into_if(list, first_pushable, i, state)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // Then optimize segment (may move things past push point)
     |       if i < list.length() - 1 {
 881 |         i = optimize_segment(list, first_pushable, i, state)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       first_pushable = nothing
     |       continue
     |     }
     | 
     |     // Count local.gets for tracking
 888 |     count_gets_in_instr(state, list[i])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     i += 1
     |   }
     | }
     …

     | fn code_pushing_pass() -> ModuleTransformer[Unit] {
     |   ModuleTransformer::new().on_func_evt(fn(_self, _state, func) {
     |     match func {
 898 |       Func(_, _) => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TFunc(params, body) => {
     |         let num_locals = params.length()
     |         if num_locals == 0 {
     |           return unchanged()
     |         }
     | 
     |         // Analyze the function
 906 |         let analyzer = analyze_function(func)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |         // Create pushing state
     |         let push_state = PushingState::{
     |           analyzer,
 911 |           num_gets_so_far: Array::make(num_locals, 0),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           changed: false,
     |         }
     | 
     |         // Process the function body
 916 |         let body_instrs = body.0.copy()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         push_code_in_block(body_instrs, push_state)
     | 
     |         // Also process nested blocks
 920 |         process_nested_blocks(body_instrs, push_state)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if push_state.changed {
 922 |           Ok(Some(((), Func::t_func(params, TExpr::new(body_instrs)))))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
 924 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   })
     | }
     …

     | fn code_pushing_ir_pass(_mod : Module) -> ModuleTransformer[IRContext] {
 933 |   wrap_unit_func_pass(code_pushing_pass())
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn process_nested_blocks(instrs : Array[TInstr], state : PushingState) -> Unit {
 939 |   for i = 0; i < instrs.length(); i = i + 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     match instrs[i] {
     |       TBlock(bt, body) => {
     |         let body_instrs = body.0.copy()
     |         push_code_in_block(body_instrs, state)
     |         process_nested_blocks(body_instrs, state)
     |         if state.changed {
 946 |           instrs[i] = TInstr::block(bt, TExpr::new(body_instrs))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 949 |       TLoop(bt, body) => {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let body_instrs = body.0.copy()
     |         push_code_in_block(body_instrs, state)
     |         process_nested_blocks(body_instrs, state)
     |         if state.changed {
 954 |           instrs[i] = TInstr::loop_(bt, TExpr::new(body_instrs))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 957 |       TIf(bt, cond, then_body, else_body) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let then_instrs = then_body.0.copy()
     |         push_code_in_block(then_instrs, state)
     |         process_nested_blocks(then_instrs, state)
     |         let new_else = match else_body {
     |           Some(eb) => {
     |             let else_instrs = eb.0.copy()
     |             push_code_in_block(else_instrs, state)
     |             process_nested_blocks(else_instrs, state)
     |             Some(TExpr::new(else_instrs))
     |           }
 968 |           None => None
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if state.changed {
 971 |           instrs[i] = TInstr::if_(bt, cond, TExpr::new(then_instrs), new_else)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 974 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

33 uncovered line(s) in src/passes/const_hoisting.mbt:

    | fn Literal::i64(val : Int64) -> Literal {
 25 |   let buf = @buffer.new(size_hint=8)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   buf.write_int64_le(val)
    |   Literal(I64LiteralKind, buf.to_bytes())
    | }
    …

    | fn Literal::f32(val : Float) -> Literal {
 32 |   let buf = @buffer.new(size_hint=4)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   buf.write_float_le(val)
    |   Literal(F32LiteralKind, buf.to_bytes())
    | }
    …

    | fn Literal::v128(
    |   a : Byte,
    |   b : Byte,
    |   c : Byte,
    |   d : Byte,
    |   e : Byte,
    |   f : Byte,
    |   g : Byte,
    |   h : Byte,
    |   i : Byte,
    |   j : Byte,
    |   k : Byte,
    |   l : Byte,
    |   m : Byte,
    |   n : Byte,
    |   o : Byte,
    |   p : Byte,
    | ) -> Literal {
 63 |   let val = Bytes::from_array([a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   Literal(V128LiteralKind, val)
    | }
    …

    | fn Literal::byte_size(self : Literal) -> Int {
    |   match self {
    |     Literal(I32LiteralKind, b) =>
    |       size_signed(
    |         b.unsafe_read_uint32_le(0).reinterpret_as_int().to_int64(),
    |         32,
    |       ).unwrap()
    |     Literal(I64LiteralKind, b) =>
 76 |       size_signed(b.unsafe_read_uint64_le(0).reinterpret_as_int64(), 64).unwrap()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Literal(F32LiteralKind, _) => 4
    |     Literal(F64LiteralKind, _) => 8
 79 |     Literal(V128LiteralKind, _) => 16
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn Literal::get_tinst(self : Literal) -> TInstr {
    |   match self {
    |     Literal(I32LiteralKind, b) =>
    |       TInstr::i32_const(b.unsafe_read_uint32_le(0).reinterpret_as_int())
    |     Literal(I64LiteralKind, b) =>
 89 |       TInstr::i64_const(b.unsafe_read_uint64_le(0).reinterpret_as_int64())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Literal(F32LiteralKind, b) =>
 91 |       TInstr::f32_const(
    |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         F32(Float::reinterpret_from_uint(b.unsafe_read_uint32_le(0))),
    |       )
    |     Literal(F64LiteralKind, b) =>
    |       TInstr::f64_const(b.unsafe_read_uint64_le(0).reinterpret_as_double())
    |     Literal(V128LiteralKind, b) =>
 97 |       TInstr::v128_const(
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         b.unsafe_get(0),
    |         b.unsafe_get(1),
    |         b.unsafe_get(2),
    |         b.unsafe_get(3),
    |         b.unsafe_get(4),
    |         b.unsafe_get(5),
    |         b.unsafe_get(6),
    |         b.unsafe_get(7),
    |         b.unsafe_get(8),
    |         b.unsafe_get(9),
    |         b.unsafe_get(10),
    |         b.unsafe_get(11),
    |         b.unsafe_get(12),
    |         b.unsafe_get(13),
    |         b.unsafe_get(14),
    |         b.unsafe_get(15),
    |       )
    |   }
    | }
    …

    | fn LiteralKind::rank(self : Self) -> Int {
120 |   match self {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I32LiteralKind => 0
    |     I64LiteralKind => 1
    |     F32LiteralKind => 2
    |     F64LiteralKind => 3
    |     V128LiteralKind => 4
    |   }
    | }
    …

    | fn LiteralKind::get_valtype(self : Self) -> ValType {
    |   match self {
    |     I32LiteralKind => ValType::i32()
133 |     I64LiteralKind => ValType::i64()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     F32LiteralKind => ValType::f32()
    |     F64LiteralKind => ValType::f64()
136 |     V128LiteralKind => ValType::v128()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Compare for Literal with compare(l, r) {
142 |   let kind = l.0.compare(r.0)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if kind == 0 {
144 |     l.1.compare(r.1)
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
146 |     kind
    |     ^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Compare for LiteralKind with compare(l, r) {
152 |   l.rank().compare(r.rank())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn replace_literal_pass() -> ModuleTransformer[Map[Literal, LocalIdx]] {
    |   ModuleTransformer::new().on_tinstruction_evt(fn(self, t, i) {
    |     match i {
    |       TI32Const(I32(val)) => {
    |         let lit = Literal::i32(val)
    |         if t.get(lit) is Some(idx) {
    |           change(t, TInstr::local_get(idx))
    |         } else {
    |           unchanged()
    |         }
    |       }
186 |       TI64Const(I64(val)) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let lit = Literal::i64(val)
    |         if t.get(lit) is Some(idx) {
189 |           change(t, TInstr::local_get(idx))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         } else {
191 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
194 |       TF32Const(F32(val)) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let lit = Literal::f32(val)
    |         if t.get(lit) is Some(idx) {
197 |           change(t, TInstr::local_get(idx))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         } else {
199 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       TF64Const(F64(val)) => {
    |         let lit = Literal::f64(val)
    |         if t.get(lit) is Some(idx) {
    |           change(t, TInstr::local_get(idx))
    |         } else {
207 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    | 
    |       // this is likely not to be used because v128 consts are hardly worth hoisting
    |       TV128Const(
    |         b0,
    |         b1,
    |         b2,
    |         b3,
    |         b4,
    |         b5,
    |         b6,
    |         b7,
    |         b8,
    |         b9,
    |         b10,
    |         b11,
    |         b12,
    |         b13,
    |         b14,
    |         b15
229 |       ) => {
    |       ^^^^^^ 	<-- UNCOVERED
    |         let lit = Literal::v128(
    |           b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,
    |         )
    |         if t.get(lit) is Some(idx) {
234 |           change(t, TInstr::local_get(idx))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         } else {
236 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
239 |       _ => self.walk_tinstruction_default(t, i)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn const_hoisting_pass() -> ModuleTransformer[ConstHoistingState] {
    |   ModuleTransformer::new()
    |   .on_func_evt(fn(self, t : ConstHoistingState, func) {
    |     // reset uses of consts per function
    |     t.usage.clear()
    |     let (t, func) = match self.walk_func_default(t, func) {
    |       Ok(Some((t, func))) => (t, func)
252 |       Ok(None) => (t, func)
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(t) => return Err(t)
    |     }
    |     let (locals, body) = match func {
    |       Func(_) =>
257 |         return Err(
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |           "Invalid transformer state. Expected TFunc but received Func",
    |         )
    |       TFunc(locals, body) => (locals, body)
    |     }
    |     let replacer_pass = replace_literal_pass()
    |     let replacers = Map::new()
    |     for k in t.usage.iter() {
    |       let lit = k.0
    |       let count = k.1
    |       if count >= MIN_USES {
    |         let size = lit.byte_size()
    |         let before = count * (size + 1)
    |         let after = size + 2 + 2 * count
    |         if after < before {
    |           let next = locals.length().reinterpret_as_uint()
    |           locals.push(lit.0.get_valtype())
    |           replacers.set(lit, LocalIdx::new(next))
    |         }
    |       }
    |     }
    |     let body = match replacer_pass.walk_texpr_default(replacers, body) {
    |       Ok(Some((_, body))) => body
280 |       Ok(None) => body
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(t) => return Err(t)
    |     }
    |     for k in replacers {
    |       let lit = k.0
    |       let idx = k.1
    |       let con = lit.get_tinst()
    |       body.0.insert(0, TInstr::local_set(idx, con))
    |     }
    |     change(t, Func::t_func(locals, body))
    |   })
    |   .on_tinstruction_evt(fn(self, t, i) {
    |     match i {
    |       TI32Const(I32(val)) => t.uses(Literal::i32(val))
294 |       TI64Const(I64(val)) => t.uses(Literal::i64(val))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TF32Const(F32(val)) => t.uses(Literal::f32(val))
    |       TF64Const(F64(val)) => t.uses(Literal::f64(val))
    |       // In the case of v128 constants, simd locals are expensive and encoding is tricky
    |       // TV128Const(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15) => 
    |       //   t.uses(v128_lit(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15))
300 |       _ => ()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     }
    |     self.walk_tinstruction_default(t, i)
    |   })
    | }
    …

    | fn const_hoisting_ir_pass(_mod : Module) -> ModuleTransformer[IRContext] {
308 |   let pass = const_hoisting_pass()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ModuleTransformer::new().on_func_evt(fn(_, ctx : IRContext, func : Func) {
    |     match pass.walk_func(ConstHoistingState::new(), func) {
    |       Ok(Some((_, new_func))) => change(ctx, new_func)
    |       Ok(None) => unchanged()
    |       Err(e) => Err(e)
    |     }
    |   })
    | }
    …

    | fn run_hoist(f : Func) -> Func raise {
    |   let pass = const_hoisting_pass()
    |   let empty_state = ConstHoistingState::new()
    |   match pass.walk_func(empty_state, f) {
    |     Ok(Some((_, f))) => return f
324 |     Ok(None) => ()
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => assert_true(false, msg=e)
    |   }
    |   f
    | }
    …

45 uncovered line(s) in src/passes/constant_field_propagation.mbt:

     | fn FieldValue::combine(self : FieldValue, other : FieldValue) -> FieldValue {
     |   match (self, other) {
     |     (Uninitialized, v) | (v, Uninitialized) => v
     |     (Constant(a), Constant(b)) => if a == b { Constant(a) } else { Unknown }
  41 |     _ => Unknown
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn CFPState::from_module(m : Module) -> CFPState {
  87 |   CFPState::{ field_values: @hashmap.new(), type_sec: m.type_sec }
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn get_default_constant(vt : ValType) -> TInstr? {
     |   match vt {
     |     NumTypeValType(nt) =>
     |       match nt {
     |         I32NumType => Some(TInstr::i32_const(I32(0)))
  97 |         I64NumType => Some(TInstr::i64_const(I64(0L)))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         F32NumType => Some(TInstr::f32_const(F32(0.0)))
     |         F64NumType => Some(TInstr::f64_const(F64(0.0)))
     |       }
 101 |     VecTypeValType => None // V128 default is complex
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) =>
     |       // Default for nullable references is ref.null
 104 |       if rt.is_nullable() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(TInstr::ref_null(rt.get_heap_type()))
     |       } else {
 107 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
 109 |     BotValType => None
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn get_struct_fields_from_type_sec(
     |   type_sec : @lib.TypeSec?,
     |   type_idx : TypeIdx,
     | ) -> Array[@lib.FieldType]? {
     |   match type_sec {
     |     None => None
     |     Some(TypeSec(rec_types)) => {
     |       let idx = match type_idx {
     |         TypeIdx(i) => i.reinterpret_as_int()
 144 |         RecIdx(i) => i.reinterpret_as_int()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match rec_types.get(idx) {
 147 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rec_type) => {
     |           let subtype = match rec_type {
     |             SingleRecType(st) => st
     |             GroupRecType(sts) =>
 152 |               match sts.get(0) {
     |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(st) => st
     |                 None => return None
     |               }
     |           }
     |           match subtype.get_comptype() {
     |             StructCompType(fields) => Some(fields)
 159 |             _ => None
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn get_super_types(
     |   type_sec : @lib.TypeSec?,
     |   type_idx : TypeIdx,
     | ) -> Array[TypeIdx] {
     |   match type_sec {
 174 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(TypeSec(rec_types)) => {
     |       let idx = match type_idx {
     |         TypeIdx(i) => i.reinterpret_as_int()
 178 |         RecIdx(i) => i.reinterpret_as_int()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match rec_types.get(idx) {
 181 |         None => []
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rec_type) => {
     |           let subtype = match rec_type {
     |             SingleRecType(st) => st
     |             GroupRecType(sts) =>
 186 |               match sts.get(0) {
     |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(st) => st
     |                 None => return []
     |               }
     |           }
     |           subtype.super_types()
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn propagate_to_supertypes(state : CFPState) -> Unit {
     |   // For each type that has a supertype, propagate its field values
     |   match state.type_sec {
 205 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(TypeSec(rec_types)) =>
     |       for i = 0; i < rec_types.length(); i = i + 1 {
     |         let type_idx = TypeIdx::new(i.reinterpret_as_uint())
     |         let supers = get_super_types(state.type_sec, type_idx)
     |         for super_idx in supers {
     |           propagate_fields_to_super(state, type_idx, super_idx)
     |         }
     |       }
     |   }
     | }
     …

     | fn propagate_fields_to_super(
     |   state : CFPState,
     |   sub_type_idx : TypeIdx,
     |   super_type_idx : TypeIdx,
     | ) -> Unit {
     |   let sub_id = type_idx_to_int(sub_type_idx)
     |   let super_id = type_idx_to_int(super_type_idx)
     | 
     |   // Get the fields from the supertype (which the subtype inherits)
     |   match get_struct_fields_from_type_sec(state.type_sec, super_type_idx) {
 229 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(super_fields) =>
     |       // For each field in the supertype
     |       for i = 0; i < super_fields.length(); i = i + 1 {
     |         let sub_value = get_field_value(state, sub_id, i)
     |         let super_value = get_field_value(state, super_id, i)
     | 
     |         // Combine the values - if they differ, both become Unknown
     |         let combined = super_value.combine(sub_value)
     |         if combined != super_value {
     |           state.field_values.set((super_id, i), combined)
     |         }
     |         // Also update the subtype to reflect the combined value
     |         if combined != sub_value {
     |           state.field_values.set((sub_id, i), combined)
     |         }
     |       }
     |   }
     | }
     …

     | fn constant_field_propagation_pass() -> ModuleTransformer[CFPState] {
     |   ModuleTransformer::new().on_func_evt(fn(_self, state, func) {
 279 |     match func {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Func(_, _) => unchanged()
     |       TFunc(_, body) => {
     |         // Scan the function for struct.new operations
 283 |         scan_for_struct_news(state, body)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         unchanged()
     |       }
     |     }
     |   })
     | }
     …

     | fn make_cfp_optimizer(state : CFPState) -> ModuleTransformer[Unit] {
     |   ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TStructGet(type_idx, field_idx, ref_instr)
     |       | TStructGetS(type_idx, field_idx, ref_instr)
     |       | TStructGetU(type_idx, field_idx, ref_instr) => {
     |         let type_id = type_idx_to_int(type_idx)
     |         let U32(field_id_uint) = field_idx
     |         let field_id = field_id_uint.reinterpret_as_int()
     |         let field_value = get_field_value(state, type_id, field_id)
     |         match field_value.get_constant() {
     |           Some(constant) => {
     |             // Replace with: (drop ref) ; constant
     |             // We need to keep the ref for side effects (null trap)
     |             let drop_ref = TInstr::drop(ref_instr)
     |             // Create a block to hold both instructions
     |             let result = TInstr::block(
     |               BlockType::void_(),
     |               TExpr::new([drop_ref, constant]),
     |             )
     |             change((), result)
     |           }
     |           None => self.walk_tinstruction_default((), instr)
     |         }
     |       }
     |       // Optimize ref.test when the input is a struct.get from a known ref.null field
     |       TRefTest(_, _, inner) =>
     |         match inner {
     |           TStructGet(type_idx, field_idx, ref_instr)
     |           | TStructGetS(type_idx, field_idx, ref_instr)
     |           | TStructGetU(type_idx, field_idx, ref_instr) => {
     |             let type_id = type_idx_to_int(type_idx)
     |             let U32(field_id_uint) = field_idx
     |             let field_id = field_id_uint.reinterpret_as_int()
     |             let field_value = get_field_value(state, type_id, field_id)
     |             match field_value.get_constant() {
     |               Some(constant) =>
     |                 if is_ref_null(constant) {
     |                   // ref.test on ref.null always returns 0 (false)
     |                   let drop_ref = TInstr::drop(ref_instr)
     |                   let result = TInstr::block(
     |                     BlockType::void_(),
     |                     TExpr::new([drop_ref, TInstr::i32_const(I32(0))]),
     |                   )
     |                   change((), result)
     |                 } else {
     |                   self.walk_tinstruction_default((), instr)
     |                 }
 340 |               None => self.walk_tinstruction_default((), instr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
 343 |           _ => self.walk_tinstruction_default((), instr)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => self.walk_tinstruction_default((), instr)
     |     }
     |   })
     | }
     …

     | fn constant_field_propagation_ir_pass(
     |   mod : Module,
     | ) -> ModuleTransformer[IRContext] {
 354 |   let state = CFPState::from_module(mod)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match mod.code_sec {
     |     None => ()
     |     Some(CodeSec(funcs)) =>
 358 |       for func in funcs {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match func {
     |           Func(_, _) => ()
     |           TFunc(_, body) => scan_for_struct_news(state, body)
     |         }
     |       }
     |   }
 365 |   propagate_to_supertypes(state)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   wrap_unit_func_pass(make_cfp_optimizer(state))
     | }
     …

     | fn scan_for_struct_news(state : CFPState, body : TExpr) -> Unit {
 372 |   for instr in body.0 {
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     scan_instruction(state, instr)
     |   }
     | }
     …

     | fn type_idx_to_int(type_idx : TypeIdx) -> Int {
     |   match type_idx {
     |     TypeIdx(idx) => idx.reinterpret_as_int()
 382 |     RecIdx(idx) => idx.reinterpret_as_int()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn scan_instruction(state : CFPState, instr : TInstr) -> Unit {
     |   match instr {
     |     // struct.new with explicit field values
     |     TStructNew(type_idx, field_values) => {
     |       let type_id = type_idx_to_int(type_idx)
     |       for i = 0; i < field_values.length(); i = i + 1 {
     |         // Check if the field value is a constant
     |         if is_constant_value(field_values[i]) {
     |           note_field_write(state, type_id, i, field_values[i])
     |         } else {
     |           // Check if value is a struct.get from a known constant field
     |           match get_copied_constant(state, field_values[i]) {
     |             Some(constant) => note_field_write(state, type_id, i, constant)
     |             None =>
     |               // Non-constant value, mark as unknown
 432 |               note_field_unknown(state, type_id, i)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         // Also scan the field value for nested struct operations
     |         scan_instruction(state, field_values[i])
     |       }
     |     }
     |     // struct.new.default - all fields get default (zero) values
     |     TStructNewDefault(type_idx) => {
     |       let type_id = type_idx_to_int(type_idx)
     |       // If we have type information, track the default values
     |       match get_struct_fields(state, type_idx) {
     |         Some(fields) =>
     |           for i = 0; i < fields.length(); i = i + 1 {
     |             let FieldType(storage_type, _) = fields[i]
     |             match get_storage_default_constant(storage_type) {
     |               Some(default_const) =>
     |                 note_field_write(state, type_id, i, default_const)
     |               None =>
     |                 // Can't determine default, mark as unknown
 452 |                 note_field_unknown(state, type_id, i)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |         None =>
     |           // No type info available, can't track defaults
     |           ()
     |       }
     |     }
     |     // struct.set - track the value being set
     |     TStructSet(type_idx, field_idx, struct_ref, value) => {
     |       let type_id = type_idx_to_int(type_idx)
     |       let U32(field_id_uint) = field_idx
     |       let field_id = field_id_uint.reinterpret_as_int()
     |       if is_constant_value(value) {
     |         note_field_write(state, type_id, field_id, value)
     |       } else {
     |         // Check if value is a struct.get from a known constant field
     |         match get_copied_constant(state, value) {
     |           Some(constant) => note_field_write(state, type_id, field_id, constant)
     |           None => note_field_unknown(state, type_id, field_id)
     |         }
     |       }
     |       // Also scan the sub-instructions
     |       scan_instruction(state, struct_ref)
     |       scan_instruction(state, value)
     |     }
     |     // Recursively scan nested instructions
 479 |     TBlock(_, body) => scan_for_struct_news(state, body)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoop(_, body) => scan_for_struct_news(state, body)
     |     TIf(_, cond, then_body, else_body) => {
     |       scan_instruction(state, cond)
     |       scan_for_struct_news(state, then_body)
     |       match else_body {
     |         Some(body) => scan_for_struct_news(state, body)
     |         None => ()
     |       }
     |     }
     |     // For other instructions with sub-expressions, scan recursively
     |     TStructGet(_, _, ref_instr)
     |     | TStructGetS(_, _, ref_instr)
     |     | TStructGetU(_, _, ref_instr) => scan_instruction(state, ref_instr)
 493 |     TDrop(sub) => scan_instruction(state, sub)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(_, a, b, c) => {
     |       scan_instruction(state, a)
     |       scan_instruction(state, b)
     |       scan_instruction(state, c)
     |     }
 499 |     TLocalSet(_, sub) | TLocalTee(_, sub) => scan_instruction(state, sub)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TGlobalSet(_, sub) => scan_instruction(state, sub)
     |     TCall(_, args) =>
 502 |       for arg in args {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         scan_instruction(state, arg)
     |       }
 505 |     TCallRef(_, args, funcref) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 507 |         scan_instruction(state, arg)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 509 |       scan_instruction(state, funcref)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 511 |     TCallIndirect(_, _, args, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
 513 |         scan_instruction(state, arg)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 515 |       scan_instruction(state, table_idx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TBr(_, args) =>
 518 |       for arg in args {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         scan_instruction(state, arg)
     |       }
 521 |     TBrIf(_, cond, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_instruction(state, cond)
     |       for arg in args {
 524 |         scan_instruction(state, arg)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TReturn(args) =>
 528 |       for arg in args {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         scan_instruction(state, arg)
     |       }
 531 |     TBrTable(_, _, idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_instruction(state, idx)
     |       for arg in args {
 534 |         scan_instruction(state, arg)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 537 |     TTryTable(_, _, body) => scan_for_struct_news(state, body)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     // For simple instructions with no sub-expressions, do nothing
     |     _ => ()
     |   }
     | }
     …

1 uncovered line(s) in src/passes/dataflow_opt.mbt:

    | fn dataflow_optimization_pass(mod : Module) -> ModuleTransformer[IRContext] {
    |   ignore(mod)
    |   ModuleTransformer::new().on_func_evt(fn(
    |     _self : ModuleTransformer[IRContext],
    |     ctx : IRContext,
    |     func : Func,
    |   ) -> TransformerResult[IRContext, Func] {
    |     match func {
    |       Func(_) => Err("Expected TFunc")
    |       TFunc(locals, body) =>
    |         match optimize_tfunc_with_ssa(ctx, locals, body) {
    |           Some(new_body) if new_body != body =>
    |             change(ctx, Func::t_func(locals, new_body))
 26 |           _ => unchanged()
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |     }
    |   })
    | }
    …

32 uncovered line(s) in src/passes/de_nan.mbt:

     | fn imported_func_count(mod : Module) -> UInt {
     |   let mut n = 0U
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(_) => n = n + 1
  57 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn unary_result_type(op : UnaryOp) -> ValType? {
     |   match op {
     |     F32AbsOp
     |     | F32NegOp
     |     | F32CeilOp
     |     | F32FloorOp
     |     | F32TruncOp
     |     | F32NearestOp
     |     | F32SqrtOp
     |     | F32ConvertI32SOp
     |     | F32ConvertI32UOp
     |     | F32ConvertI64SOp
     |     | F32ConvertI64UOp
     |     | F32DemoteF64Op
     |     | F32ReinterpretI32Op => Some(ValType::f32())
     |     F64AbsOp
     |     | F64NegOp
     |     | F64CeilOp
     |     | F64FloorOp
     |     | F64TruncOp
     |     | F64NearestOp
     |     | F64SqrtOp
     |     | F64ConvertI32SOp
     |     | F64ConvertI32UOp
     |     | F64ConvertI64SOp
     |     | F64ConvertI64UOp
     |     | F64PromoteF32Op
     |     | F64ReinterpretI64Op => Some(ValType::f64())
  94 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn load_result_type(op : LoadOp) -> ValType? {
     |   match op {
     |     F32LoadOp => Some(ValType::f32())
 123 |     F64LoadOp => Some(ValType::f64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn infer_tinstr_type(instr : TInstr, st : DeNaNState) -> ValType? {
     |   match instr {
     |     TI32Const(_) => Some(ValType::i32())
 132 |     TI64Const(_) => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => Some(ValType::f32())
     |     TF64Const(_) => Some(ValType::f64())
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 136 |       Some(ValType::v128())
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TUnary(op, _) => unary_result_type(op)
     |     TBinary(op, _, _) => binary_result_type(op)
     |     TLoad(op, _, _) => load_result_type(op)
     |     TLocalGet(idx) => st.env.get_local_type(idx)
     |     TGlobalGet(idx) =>
     |       match st.env.get_global_type(idx) {
     |         Some(GlobalType(vt, _)) => Some(vt)
 144 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 146 |     TLocalTee(_, value) => infer_tinstr_type(value, st)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(Some(types), _, _, _) if types.length() == 1 => Some(types[0])
     |     TCall(target, _) =>
     |       match st.env.get_functype_by_funcidx(target) {
     |         Some(FuncType(_, [r])) => Some(r)
 151 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 154 |       match st.env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
     |     TBlock(bt, _) | TLoop(bt, _) | TIf(bt, _, _, _) | TTryTable(bt, _, _) =>
     |       match st.env.expand_blocktype(bt) {
     |         Ok((_, [vt])) => Some(vt)
 161 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TStructGet(type_idx, field_idx, _)
     |     | TStructGetS(type_idx, field_idx, _)
     |     | TStructGetU(type_idx, field_idx, _) =>
 166 |       match st.env.resolve_struct_fields(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(fields) => {
     |           let U32(raw_idx) = field_idx
 169 |           match fields.get(raw_idx.reinterpret_as_int()) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(ft) => Some(ft.unpack())
     |             None => None
     |           }
     |         }
 174 |         Err(_) => None
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayGet(type_idx, _, _)
     |     | TArrayGetS(type_idx, _, _)
     |     | TArrayGetU(type_idx, _, _) =>
 179 |       match st.env.resolve_array_field(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(field) => Some(field.unpack())
     |         Err(_) => None
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn is_denam64_func(f : Func) -> Bool {
     |   match f {
     |     TFunc(
     |       [NumTypeValType(F64NumType)],
     |       TExpr(
     |         [
     |           TIf(
     |             ValTypeBlockType(NumTypeValType(F64NumType)),
     |             TBinary(F64EqOp, TLocalGet(LocalIdx(0)), TLocalGet(LocalIdx(0))),
     |             TExpr([TLocalGet(LocalIdx(0))]),
     |             Some(TExpr([TF64Const(F64(v))]))
     |           ),
     |         ]
     |       )
 237 |     ) => v == 0.0
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn find_existing_denan_helpers(mod : Module) -> (FuncIdx?, FuncIdx?) {
     |   let imported = imported_func_count(mod)
     |   let mut idx32 : FuncIdx? = None
     |   let mut idx64 : FuncIdx? = None
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for i, f in funcs {
     |         let abs_idx = FuncIdx::new(imported + i.reinterpret_as_uint())
     |         if idx32 is None && is_denam32_func(f) {
     |           idx32 = Some(abs_idx)
     |         }
     |         if idx64 is None && is_denam64_func(f) {
 255 |           idx64 = Some(abs_idx)
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   (idx32, idx64)
     | }
     …

     | fn find_func_type_idx(
     |   type_sec : TypeSec,
     |   params : Array[ValType],
     |   results : Array[ValType],
     | ) -> TypeIdx? {
     |   let TypeSec(rec_types) = type_sec
     |   let mut idx = 0U
     |   for rec in rec_types {
     |     match rec {
     |       SingleRecType(st) =>
     |         match st.get_comptype() {
     |           FuncCompType(ps, rs) if ps == params && rs == results =>
     |             return Some(TypeIdx::new(idx))
     |           _ => ()
     |         }
     |       GroupRecType(sts) =>
 280 |         for st in sts {
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           match st.get_comptype() {
     |             FuncCompType(ps, rs) if ps == params && rs == results =>
 283 |               return Some(TypeIdx::new(idx))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ => ()
     |           }
     |           idx = idx + 1
     |         }
     |     }
     |     if rec is SingleRecType(_) {
     |       idx = idx + 1
     |     }
     |   }
     |   None
     | }
     …

     | fn build_param_sanitizers(
     |   params : Array[ValType],
     |   denan32 : FuncIdx?,
     |   denan64 : FuncIdx?,
     | ) -> Array[TInstr] {
     |   let prefix : Array[TInstr] = []
     |   for i, vt in params {
     |     let local_idx = LocalIdx::new(i.reinterpret_as_uint())
     |     match vt {
     |       NumTypeValType(F32NumType) =>
     |         match denan32 {
     |           Some(idx) =>
     |             prefix.push(
     |               TInstr::local_set(
     |                 local_idx,
     |                 TInstr::call(idx, [TInstr::local_get(local_idx)]),
     |               ),
     |             )
 347 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       NumTypeValType(F64NumType) =>
     |         match denan64 {
     |           Some(idx) =>
     |             prefix.push(
     |               TInstr::local_set(
     |                 local_idx,
     |                 TInstr::call(idx, [TInstr::local_get(local_idx)]),
     |               ),
     |             )
 358 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |   }
     |   prefix
     | }
     …

     | fn make_denam_transformer() -> ModuleTransformer[DeNaNState] {
     |   ModuleTransformer::new()
     |   .on_func_evt(fn(self, st : DeNaNState, func : Func) {
     |     let abs_raw = st.next_func_abs
     |     let abs_idx = FuncIdx::new(abs_raw)
     |     let st = DeNaNState::{ ..st, next_func_abs: abs_raw + 1 }
     |     if st.wrap_enabled &&
     |       (st.deNan32 == Some(abs_idx) || st.deNan64 == Some(abs_idx)) {
     |       return change(st, func)
     |     }
     |     match func {
     |       TFunc(tlocals, _) => {
     |         let base_env = st.env
     |         let (params, local_types) = function_local_types(
     |           base_env, abs_idx, tlocals,
     |         )
     |         let mut st = DeNaNState::{
     |           ..st,
     |           in_func: true,
     |           current_param_types: params,
     |           env: base_env.with_locals(local_types),
     |         }
     |         for param in st.current_param_types {
     |           match param {
     |             NumTypeValType(F32NumType) =>
     |               st = DeNaNState::{ ..st, need_f32: true }
     |             NumTypeValType(F64NumType) =>
     |               st = DeNaNState::{ ..st, need_f64: true }
     |             _ => ()
     |           }
     |         }
     |         let (st, func) = match self.walk_func_default(st, func) {
     |           Ok(Some(t)) => t
 447 |           Ok(None) => (st, func)
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(t) => return Err(t)
     |         }
     |         change(
     |           DeNaNState::{
     |             ..st,
     |             in_func: false,
     |             current_param_types: [],
     |             env: base_env,
     |           },
     |           func,
     |         )
     |       }
 460 |       _ => self.walk_func_default(st, func)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   .on_tinstruction_evt(fn(self, st, instr) {
     |     match instr {
     |       TF32Const(f) =>
     |         if is_f32_nan(f) {
     |           Ok(Some((st, TInstr::f32_const(F32(0.0)))))
     |         } else {
     |           Ok(None)
     |         }
     |       TF64Const(f) =>
     |         if is_f64_nan(f) {
     |           Ok(Some((st, TInstr::f64_const(F64(0.0)))))
     |         } else {
     |           Ok(None)
     |         }
     |       TCall(idx, _) if st.wrap_enabled &&
     |         (st.deNan32 == Some(idx) || st.deNan64 == Some(idx)) =>
     |         change(st, instr)
     |       _ =>
     |         if st.in_func {
     |           match infer_float_kind(instr, st) {
     |             Some(Float32) => {
     |               let st = DeNaNState::{ ..st, need_f32: true }
     |               if !st.wrap_enabled {
     |                 return self.walk_tinstruction_default(st, instr)
     |               }
     |               match st.deNan32 {
     |                 Some(idx) => {
     |                   let (st, processed_instr) = match
     |                     self.walk_tinstruction_default(st, instr) {
     |                     Ok(Some(pair)) => pair
 493 |                     Ok(None) => (st, instr)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     Err(e) => return Err(e)
     |                   }
     |                   Ok(Some((st, TInstr::call(idx, [processed_instr]))))
     |                 }
 498 |                 None => self.walk_tinstruction_default(st, instr)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |             Some(Float64) => {
     |               let st = DeNaNState::{ ..st, need_f64: true }
     |               if !st.wrap_enabled {
     |                 return self.walk_tinstruction_default(st, instr)
     |               }
     |               match st.deNan64 {
     |                 Some(idx) => {
     |                   let (st, processed_instr) = match
     |                     self.walk_tinstruction_default(st, instr) {
     |                     Ok(Some(pair)) => pair
 511 |                     Ok(None) => (st, instr)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     Err(e) => return Err(e)
     |                   }
     |                   Ok(Some((st, TInstr::call(idx, [processed_instr]))))
     |                 }
 516 |                 None => self.walk_tinstruction_default(st, instr)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |             None => self.walk_tinstruction_default(st, instr)
     |           }
     |         } else {
 522 |           self.walk_tinstruction_default(st, instr)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |     }
     |   })
     | }
     …

     | fn run_denam(m : @lib.Module) -> Result[@lib.Module, String] {
     |   let env0 = Env::new().with_module(m)
     |   let imported = imported_func_count(m)
     |   let (existing_32, existing_64) = find_existing_denan_helpers(m)
     |   let tr = make_denam_transformer()
     |   let init_state = DeNaNState::{
     |     env: env0,
     |     in_func: false,
     |     wrap_enabled: false,
     |     next_func_abs: imported,
     |     current_param_types: [],
     |     need_f32: false,
     |     need_f64: false,
     |     deNan32: existing_32,
     |     deNan64: existing_64,
     |   }
     |   let (st1, mod1) = match tr.walk_module(init_state, m) {
     |     Ok(Some(pair)) => pair
 579 |     Ok(None) => return Ok(m) // unreachable for walk_module, but keeps behavior explicit
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => return Err(e)
     |   }
     |   let defined_count = match mod1.code_sec {
     |     Some(cs) => cs.0.length().reinterpret_as_uint()
     |     None => 0
     |   }
     |   let mut idx32 : FuncIdx? = st1.deNan32
     |   let mut idx64 : FuncIdx? = st1.deNan64
     |   let mut offset = 0U
     |   let need_new_32 = st1.need_f32 && idx32 is None
     |   let need_new_64 = st1.need_f64 && idx64 is None
     |   if need_new_32 {
     |     idx32 = Some(FuncIdx::new(imported + defined_count + offset))
     |     offset = offset + 1
     |   }
     |   if need_new_64 {
     |     idx64 = Some(FuncIdx::new(imported + defined_count + offset))
     |     offset = offset + 1
     |   }
     |   if !st1.need_f32 && !st1.need_f64 {
     |     return Ok(mod1)
     |   }
     |   let st2 = DeNaNState::{
     |     ..st1,
     |     env: Env::new().with_module(mod1),
     |     wrap_enabled: true,
     |     next_func_abs: imported,
     |     current_param_types: [],
     |     deNan32: idx32,
     |     deNan64: idx64,
     |   }
     |   let (st2, mod2) = match tr.walk_module(st2, mod1) {
     |     Ok(Some(pair)) => pair
 613 |     Ok(None) => (st2, mod1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => return Err(e)
     |   }
     |   let env2 = Env::new().with_module(mod2)
     |   let mut abs_idx = imported
     |   let current_funcs = match mod2.code_sec {
     |     Some(cs) => cs.0
 620 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let updated_funcs = current_funcs.map(fn(f) {
     |     let func_idx = FuncIdx::new(abs_idx)
     |     abs_idx = abs_idx + 1
     |     if st2.deNan32 == Some(func_idx) || st2.deNan64 == Some(func_idx) {
     |       return f
     |     }
     |     match f {
     |       TFunc(tlocals, body) => {
     |         let params = function_param_types(env2, func_idx, tlocals)
     |         let new_body = sanitize_params(params, body, st2.deNan32, st2.deNan64)
     |         Func::t_func(tlocals, new_body)
     |       }
 634 |       _ => f
     |       ^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   let final_funcs = updated_funcs
     |   if need_new_32 {
     |     final_funcs.push(make_denam32_func())
     |   }
     |   if need_new_64 {
     |     final_funcs.push(make_denam64_func())
     |   }
     |   let mod3 = mod2.with_code_sec(CodeSec::new(final_funcs))
     |   let final_mod = match mod3.func_sec {
     |     Some(FuncSec(type_idxs)) => {
     |       let type_sec = match mod3.type_sec {
     |         Some(ts) => ts
 649 |         None => return Err("de_nan: func_sec exists but type_sec is missing")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let type_idxs = type_idxs.copy()
     |       let (type_sec, ty32) = ensure_func_type(type_sec, [ValType::f32()], [
     |         ValType::f32(),
     |       ])
     |       let (type_sec, ty64) = ensure_func_type(type_sec, [ValType::f64()], [
     |         ValType::f64(),
     |       ])
     |       if need_new_32 {
     |         type_idxs.push(ty32)
     |       }
     |       if need_new_64 {
     |         type_idxs.push(ty64)
     |       }
     |       mod3.with_type_sec(type_sec).with_func_sec(FuncSec::new(type_idxs))
     |     }
     |     None => mod3
     |   }
     |   Ok(final_mod)
     | }
     …

138 uncovered line(s) in src/passes/dead_argument_elim.mbt:

     | fn extract_comp_type(sub_type : SubType) -> CompType {
     |   match sub_type {
   9 |     SubType(_, _, comp) => comp
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CompTypeSubType(comp) => comp
     |   }
     | }
     …

     | fn resolve_func_type(comp_types : Array[CompType], idx : TypeIdx) -> FuncType? {
     |   let i = match idx {
     |     TypeIdx(n) => n
  18 |     RecIdx(n) => n
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let j = i.reinterpret_as_int()
     |   if j < 0 || j >= comp_types.length() {
  22 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match comp_types[j] {
     |     FuncCompType(params, results) => Some(FuncType::new(params, results))
  26 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn count_imported_funcs(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  35 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(_) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn collect_func_types(mod : Module) -> Array[FuncType] {
     |   let comp_types : Array[CompType] = []
     |   match mod.type_sec {
     |     Some(TypeSec(rec_types)) =>
     |       for rec_type in rec_types {
     |         match rec_type {
     |           SingleRecType(sub_type) =>
     |             comp_types.push(extract_comp_type(sub_type))
     |           GroupRecType(sub_types) =>
  57 |             for sub_type in sub_types {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               comp_types.push(extract_comp_type(sub_type))
     |             }
     |         }
     |       }
  62 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_types : Array[FuncType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  67 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(type_idx) =>
  71 |             match resolve_func_type(comp_types, type_idx) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(ft) => func_types.push(ft)
     |               None => func_types.push(FuncType::new([], []))
     |             }
  75 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         match resolve_func_type(comp_types, type_idx) {
     |           Some(ft) => func_types.push(ft)
  85 |           None => func_types.push(FuncType::new([], []))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
  88 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   func_types
     | }
     …

     | fn flattened_type_count(rec_types : Array[RecType]) -> Int {
     |   let mut n = 0
     |   for rec_type in rec_types {
     |     match rec_type {
     |       SingleRecType(_) => n += 1
  99 |       GroupRecType(sub_types) => n += sub_types.length()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   n
     | }
     …

     | fn is_literal_const(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => true
 109 |     TRefNull(_) | TRefFunc(_) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
     |     _ => false
     |   }
     | }
     …

     | fn is_trivially_pure_arg(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => true
 119 |     TRefNull(_) | TRefFunc(_) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
     |     TLocalGet(_) | TGlobalGet(_) => true
 122 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn body_ends_with_explicit_return_or_unreachable(body : TExpr) -> Bool {
     |   if body.0.is_empty() {
 129 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match body.0[body.0.length() - 1] {
     |     TReturn(_) | TUnreachable => true
     |     _ => false
     |   }
     | }
     …

     | fn mark_exports_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         let Export(_, extern_idx) = export_
     |         match extern_idx {
     |           FuncExternIdx(FuncIdx(raw)) => {
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < has_unseen.length() {
     |               has_unseen[idx] = true
     |             }
     |           }
 150 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     | }
     …

     | fn mark_start_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
     |   match mod.start_sec {
 160 |     Some(StartSec(FuncIdx(raw))) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = raw.reinterpret_as_int()
     |       if idx >= 0 && idx < has_unseen.length() {
 163 |         has_unseen[idx] = true
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     None => ()
     |   }
     | }
     …

     | fn mark_elem_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
     |   match mod.elem_sec {
     |     Some(ElemSec(elems)) =>
     |       for elem in elems {
     |         let Elem(_, kind) = elem
     |         match kind {
     |           FuncsElemKind(funcs) =>
     |             for func_idx in funcs {
     |               let FuncIdx(raw) = func_idx
     |               let idx = raw.reinterpret_as_int()
     |               if idx >= 0 && idx < has_unseen.length() {
     |                 has_unseen[idx] = true
     |               }
     |             }
     |           FuncExprsElemKind(exprs) | TypedExprsElemKind(_, exprs) =>
 186 |             for expr in exprs {
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               for instr in expr.0 {
     |                 match instr {
     |                   RefFunc(FuncIdx(raw)) => {
     |                     let idx = raw.reinterpret_as_int()
     |                     if idx >= 0 && idx < has_unseen.length() {
 192 |                       has_unseen[idx] = true
     |                       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     }
     |                   }
 195 |                   _ => ()
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     | }
     …

     | fn record_call(
     |   caller_abs_idx : Int,
     |   target : FuncIdx,
     |   args : Array[TInstr],
     |   calls_by_target : Array[Array[CallSite]],
     |   call_counts : Array[Int],
     | ) -> Unit {
     |   let FuncIdx(raw) = target
     |   let idx = raw.reinterpret_as_int()
     |   if idx < 0 || idx >= calls_by_target.length() {
 227 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   call_counts[idx] += 1
     |   calls_by_target[idx].push(callsite(caller_abs_idx, args.copy()))
     | }
     …

     | fn analyze_function_body(
     |   abs_func_idx : Int,
     |   param_count : Int,
     |   body : TExpr,
     |   calls_by_target : Array[Array[CallSite]],
     |   call_counts : Array[Int],
     |   dropped_call_counts : Array[Int],
     |   has_unseen_calls : Array[Bool],
     |   has_tail_calls : Array[Bool],
     |   tail_callee : Array[Bool],
     |   return_callers : Array[Bool],
     |   used_params : Set[Int],
     | ) -> Unit {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TLocalGet(LocalIdx(raw)) => {
     |         let idx = raw.reinterpret_as_int()
     |         if idx >= 0 && idx < param_count {
     |           used_params.add(idx)
     |         }
     |       }
     |       TDrop(TCall(target, _)) => {
     |         let FuncIdx(raw) = target
     |         let idx = raw.reinterpret_as_int()
     |         if idx >= 0 && idx < dropped_call_counts.length() {
     |           dropped_call_counts[idx] += 1
     |         }
     |       }
     |       TCall(target, args) =>
     |         record_call(abs_func_idx, target, args, calls_by_target, call_counts)
 264 |       TReturnCall(target, args) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         record_call(abs_func_idx, target, args, calls_by_target, call_counts)
     |         let FuncIdx(raw) = target
 267 |         let idx = raw.reinterpret_as_int()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if idx >= 0 && idx < tail_callee.length() {
 269 |           tail_callee[idx] = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return_callers[idx] = true
     |         }
     |         if abs_func_idx >= 0 && abs_func_idx < has_tail_calls.length() {
 273 |           has_tail_calls[abs_func_idx] = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TReturnCallIndirect(_, _, _, _) | TReturnCallRef(_, _, _) =>
 277 |         if abs_func_idx >= 0 && abs_func_idx < has_tail_calls.length() {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           has_tail_calls[abs_func_idx] = true
     |         }
 280 |       TRefFunc(FuncIdx(raw)) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = raw.reinterpret_as_int()
     |         if idx >= 0 && idx < has_unseen_calls.length() {
 283 |           has_unseen_calls[idx] = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     | }
     …

     | fn compute_constant_params(
     |   param_types : Array[ValType],
     |   calls : Array[CallSite],
     | ) -> Map[Int, TInstr] {
     |   let constants : Map[Int, TInstr] = Map::new()
     |   if calls.is_empty() {
 300 |     return constants
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for p = 0; p < param_types.length(); p = p + 1 {
     |     let mut candidate : TInstr? = None
     |     let mut all_const = true
     |     for callsite in calls {
     |       let args = callsite.args
     |       if p >= args.length() {
 308 |         all_const = false
     |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         break
     |       }
     |       let arg = args[p]
     |       if not(is_literal_const(arg)) {
     |         all_const = false
     |         break
     |       }
     |       match candidate {
     |         None => candidate = Some(arg)
     |         Some(prev) =>
 319 |           if prev != arg {
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             all_const = false
     |             break
     |           }
     |       }
     |     }
     |     if all_const {
     |       match candidate {
     |         Some(c) => constants.set(p, c)
 328 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   constants
     | }
     …

     | fn all_calls_arg_pure(calls : Array[CallSite], param_idx : Int) -> Bool {
     |   for callsite in calls {
     |     let args = callsite.args
     |     if param_idx >= args.length() {
 340 |       return false
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if not(is_trivially_pure_arg(args[param_idx])) {
 343 |       return false
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   true
     | }
     …

     | fn collect_global_types(mod : Module) -> Array[ValType] {
     |   let out : Array[ValType] = []
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
 354 |       for global in globals {
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Global(GlobalType(vt, _), _) = global
     |         out.push(vt)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn build_local_types_by_abs(
     |   func_types : Array[FuncType],
     |   funcs : Array[Func],
     |   import_func_count : Int,
     | ) -> Array[Array[ValType]] {
     |   let out : Array[Array[ValType]] = []
     |   for abs_idx = 0; abs_idx < func_types.length(); abs_idx = abs_idx + 1 {
     |     let FuncType(params, _) = func_types[abs_idx]
     |     let locals = params.copy()
     |     let def_idx = abs_idx - import_func_count
     |     if def_idx >= 0 && def_idx < funcs.length() {
     |       match funcs[def_idx] {
     |         TFunc(extra_locals, _) =>
     |           for vt in extra_locals {
 378 |             locals.push(vt)
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 380 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     out.push(locals)
     |   }
     |   out
     | }
     …

     | fn known_instr_type(
     |   instr : TInstr,
     |   caller_abs_idx : Int,
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     | ) -> ValType? {
     |   match instr {
     |     TI32Const(_) => Some(ValType::i32())
 398 |     TI64Const(_) => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => Some(ValType::f32())
     |     TF64Const(_) => Some(ValType::f64())
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 402 |       Some(ValType::v128())
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
     |     TRefFunc(_) =>
 405 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         ValType::ref_type(
     |           RefType::new(false, HeapType::abs(AbsHeapType::func())),
     |         ),
     |       )
     |     TLocalGet(LocalIdx(raw)) => {
     |       let idx = raw.reinterpret_as_int()
     |       if caller_abs_idx < 0 || caller_abs_idx >= local_types_by_abs.length() {
 413 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let locals = local_types_by_abs[caller_abs_idx]
     |       if idx < 0 || idx >= locals.length() {
 417 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Some(locals[idx])
     |     }
 421 |     TGlobalGet(GlobalIdx(raw)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = raw.reinterpret_as_int()
     |       if idx < 0 || idx >= global_types.length() {
 424 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Some(global_types[idx])
     |     }
     |     TRefAsNonNull(value) =>
 429 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         known_instr_type(
     |           value, caller_abs_idx, local_types_by_abs, global_types, env,
     |         ) {
     |         Some(RefTypeValType(rt)) =>
 434 |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TRefCast(nullable, ht, _) =>
 438 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(Some(types), _, _, _) if types.length() == 1 => Some(types[0])
     |     TCall(target, _) =>
 441 |       match env.get_functype_by_funcidx(target) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 446 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
 450 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn common_supertype(a : ValType, b : ValType, env : Env) -> ValType? {
 456 |   if Match::matches(a, b, env) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return Some(b)
     |   }
     |   if Match::matches(b, a, env) {
 460 |     return Some(a)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   None
     | }
     …

     | fn refine_param_types(
     |   old_params : Array[ValType],
     |   calls : Array[CallSite],
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     | ) -> Array[ValType] {
     |   let new_params = old_params.copy()
     |   if calls.is_empty() {
     |     return new_params
     |   }
     |   for p = 0; p < old_params.length(); p = p + 1 {
     |     let old_param = old_params[p]
     |     match old_param {
     |       RefTypeValType(_) => ()
     |       _ => continue
     |     }
     |     let mut candidate : ValType? = None
     |     let mut can_refine = true
     |     for callsite in calls {
     |       let args = callsite.args
     |       if p >= args.length() {
 488 |         can_refine = false
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         break
     |       }
     |       let arg = args[p]
     |       match
     |         known_instr_type(
     |           arg,
     |           callsite.caller_abs_idx,
     |           local_types_by_abs,
     |           global_types,
     |           env,
     |         ) {
     |         Some(arg_ty) => {
     |           if not(Match::matches(arg_ty, old_param, env)) {
 502 |             can_refine = false
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             break
     |           }
     |           candidate = match candidate {
     |             None => Some(arg_ty)
 507 |             Some(prev) => common_supertype(prev, arg_ty, env)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if candidate is None {
 510 |             can_refine = false
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             break
     |           }
     |         }
 514 |         None => {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           can_refine = false
     |           break
     |         }
     |       }
     |     }
     |     if not(can_refine) {
 521 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match candidate {
     |       Some(new_ty) if new_ty != old_param &&
     |         Match::matches(new_ty, old_param, env) => new_params[p] = new_ty
     |       _ => ()
     |     }
     |   }
     |   new_params
     | }
     …

     | fn collect_explicit_return_types(
     |   body : TExpr,
     |   result_arity : Int,
     |   abs_func_idx : Int,
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     | ) -> Array[Array[ValType]]? {
     |   let rows : Array[Array[ValType]] = []
     |   let mut failed = false
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TReturn(values) =>
     |         if values.length() != result_arity {
 547 |           failed = true
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           let row : Array[ValType] = []
     |           for value in values {
     |             match
     |               known_instr_type(
     |                 value, abs_func_idx, local_types_by_abs, global_types, env,
     |               ) {
     |               Some(vt) => row.push(vt)
 556 |               None => {
     |               ^^^^^^^^^ 	<-- UNCOVERED
     |                 failed = true
     |                 break
     |               }
     |             }
     |           }
     |           if row.length() == result_arity {
     |             rows.push(row)
     |           }
     |         }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   if failed {
 572 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   } else {
     |     Some(rows)
     |   }
     | }
     …

     | fn refine_return_types(
     |   old_results : Array[ValType],
     |   body : TExpr,
     |   abs_func_idx : Int,
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     | ) -> Array[ValType] {
     |   if old_results.is_empty() {
     |     return old_results
     |   }
     |   let rows = match
     |     collect_explicit_return_types(
     |       body,
     |       old_results.length(),
     |       abs_func_idx,
     |       local_types_by_abs,
     |       global_types,
     |       env,
     |     ) {
     |     Some(r) => r
 600 |     None => return old_results
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if rows.is_empty() {
     |     return old_results
     |   }
     |   let new_results = old_results.copy()
     |   for i = 0; i < old_results.length(); i = i + 1 {
     |     let mut candidate = rows[0][i]
     |     for row_i = 1; row_i < rows.length(); row_i = row_i + 1 {
 609 |       match common_supertype(candidate, rows[row_i][i], env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(c) => candidate = c
     |         None => return old_results
     |       }
     |     }
     |     if not(Match::matches(candidate, old_results[i], env)) {
 615 |       return old_results
     |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     new_results[i] = candidate
     |   }
     |   new_results
     | }
     …

     | fn rewrite_local_index(
     |   idx : Int,
     |   old_param_count : Int,
     |   removed_unused : Set[Int],
     |   removed_const : Map[Int, TInstr],
     |   const_local_slots : Map[Int, Int],
     |   removed_total : Int,
     | ) -> Int? {
     |   if idx < 0 {
 647 |     return Some(idx)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if idx < old_param_count {
     |     if removed_unused.contains(idx) {
 651 |       return None
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if removed_const.contains(idx) {
     |       return const_local_slots.get(idx)
     |     }
     |     let mut removed_before = 0
     |     for p = 0; p < idx; p = p + 1 {
 658 |       if removed_unused.contains(p) || removed_const.contains(p) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         removed_before += 1
     |       }
     |     }
     |     return Some(idx - removed_before)
     |   }
     |   Some(idx - removed_total)
     | }
     …

     | fn rewrite_locals_and_returns(
     |   body : TExpr,
     |   old_param_count : Int,
     |   removed_unused : Set[Int],
     |   removed_const : Map[Int, TInstr],
     |   const_local_slots : Map[Int, Int],
     |   removed_total : Int,
     |   remove_result : Bool,
     | ) -> TExpr {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let processed = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, i))) => i
     |       Ok(None) => instr
 716 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match processed {
     |       TLocalGet(LocalIdx(raw)) => {
     |         let idx = raw.reinterpret_as_int()
     |         match
     |           rewrite_local_index(
     |             idx, old_param_count, removed_unused, removed_const, const_local_slots,
     |             removed_total,
     |           ) {
     |           Some(new_idx) =>
     |             if new_idx == idx {
     |               if processed != instr {
 729 |                 change((), processed)
     |                 ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               } else {
     |                 unchanged()
     |               }
     |             } else {
 734 |               change(
     |               ^^^^^^^ 	<-- UNCOVERED
     |                 (),
 736 |                 TInstr::local_get(LocalIdx::new(new_idx.reinterpret_as_uint())),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               )
     |             }
 739 |           None => change((), TInstr::unreachable_())
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 742 |       TLocalSet(LocalIdx(raw), value) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = raw.reinterpret_as_int()
     |         match
 745 |           rewrite_local_index(
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             idx, old_param_count, removed_unused, removed_const, const_local_slots,
     |             removed_total,
     |           ) {
     |           Some(new_idx) =>
 750 |             if new_idx == idx {
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               if processed != instr {
     |                 change((), processed)
     |               } else {
 754 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             } else {
 757 |               change(
     |               ^^^^^^^ 	<-- UNCOVERED
     |                 (),
 759 |                 TInstr::local_set(
     |                 ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   LocalIdx::new(new_idx.reinterpret_as_uint()),
     |                   value,
     |                 ),
     |               )
     |             }
 765 |           None => change((), TInstr::drop(value))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 768 |       TLocalTee(LocalIdx(raw), value) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = raw.reinterpret_as_int()
     |         match
 771 |           rewrite_local_index(
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             idx, old_param_count, removed_unused, removed_const, const_local_slots,
     |             removed_total,
     |           ) {
     |           Some(new_idx) =>
 776 |             if new_idx == idx {
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               if processed != instr {
     |                 change((), processed)
     |               } else {
 780 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             } else {
 783 |               change(
     |               ^^^^^^^ 	<-- UNCOVERED
     |                 (),
 785 |                 TInstr::local_tee(
     |                 ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   LocalIdx::new(new_idx.reinterpret_as_uint()),
     |                   value,
     |                 ),
     |               )
     |             }
 791 |           None => change((), value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TReturn(values) if remove_result && values.length() > 0 =>
     |         change((), TInstr::return_([]))
     |       _ => if processed != instr { change((), processed) } else { unchanged() }
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
     |     Ok(Some((_, new_body))) => new_body
 801 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn filter_call_args(args : Array[TInstr], removed : Set[Int]) -> Array[TInstr] {
     |   if removed.is_empty() {
     |     return args
     |   }
     |   let out : Array[TInstr] = []
     |   for i = 0; i < args.length(); i = i + 1 {
     |     if not(removed.contains(i)) {
 813 |       out.push(args[i])
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn rewrite_calls(
     |   body : TExpr,
     |   removed_params_by_target : Array[Set[Int]],
     |   result_removed_by_target : Array[Bool],
     |   target_remap : Array[Int],
     | ) -> TExpr {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let processed = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, i))) => i
     |       Ok(None) => instr
 830 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match processed {
     |       TDrop(TCall(target, args)) => {
     |         let FuncIdx(raw) = target
     |         let idx = raw.reinterpret_as_int()
     |         if idx < 0 || idx >= removed_params_by_target.length() {
 837 |           return if processed != instr {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change((), processed)
     |           } else {
 840 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         let remapped = target_remap[idx]
     |         let new_target = FuncIdx::new(remapped.reinterpret_as_uint())
     |         let new_args = filter_call_args(args, removed_params_by_target[idx])
     |         if result_removed_by_target[idx] {
     |           change((), TInstr::call(new_target, new_args))
 848 |         } else if new_args != args {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           change((), TInstr::drop(TInstr::call(new_target, new_args)))
     |         } else if remapped != idx {
     |           change((), TInstr::drop(TInstr::call(new_target, new_args)))
     |         } else if processed != instr {
     |           change((), processed)
     |         } else {
 855 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TCall(target, args) => {
     |         let FuncIdx(raw) = target
     |         let idx = raw.reinterpret_as_int()
     |         if idx < 0 || idx >= removed_params_by_target.length() {
 862 |           return if processed != instr {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change((), processed)
     |           } else {
 865 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         let remapped = target_remap[idx]
     |         let new_target = FuncIdx::new(remapped.reinterpret_as_uint())
     |         let new_args = filter_call_args(args, removed_params_by_target[idx])
     |         if new_args != args || remapped != idx {
     |           change((), TInstr::call(new_target, new_args))
     |         } else if processed != instr {
 874 |           change((), processed)
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           unchanged()
     |         }
     |       }
 879 |       TReturnCall(target, args) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let FuncIdx(raw) = target
 881 |         let idx = raw.reinterpret_as_int()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if idx < 0 || idx >= removed_params_by_target.length() {
 883 |           return if processed != instr {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change((), processed)
     |           } else {
 886 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         let remapped = target_remap[idx]
 890 |         let new_target = FuncIdx::new(remapped.reinterpret_as_uint())
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let new_args = filter_call_args(args, removed_params_by_target[idx])
     |         if new_args != args || remapped != idx {
 893 |           change((), TInstr::return_call(new_target, new_args))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else if processed != instr {
     |           change((), processed)
     |         } else {
 897 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => if processed != instr { change((), processed) } else { unchanged() }
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
     |     Ok(Some((_, new_body))) => new_body
 905 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn make_adapter_thunk(
     |   target_abs_idx : Int,
     |   old_params : Array[ValType],
     |   old_results : Array[ValType],
     |   removed_unused : Set[Int],
     |   removed_const : Map[Int, TInstr],
     |   remove_result : Bool,
     | ) -> Func {
     |   let call_args : Array[TInstr] = []
     |   for p = 0; p < old_params.length(); p = p + 1 {
     |     if removed_unused.contains(p) {
     |       continue
     |     }
 923 |     match removed_const.get(p) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(v) => call_args.push(v)
     |       None =>
 926 |         call_args.push(
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TInstr::local_get(LocalIdx::new(p.reinterpret_as_uint())),
     |         )
     |     }
     |   }
     |   let target = FuncIdx::new(target_abs_idx.reinterpret_as_uint())
     |   let body = if remove_result {
 933 |     TExpr::new([TInstr::call(target, call_args), TInstr::return_([])])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else if old_results.length() == 0 {
 935 |     TExpr::new([TInstr::call(target, call_args), TInstr::return_([])])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     TExpr::new([TInstr::return_([TInstr::call(target, call_args)])])
     |   }
     |   Func::t_func([], body)
     | }
     …

     | fn run_dead_argument_elim(mod : Module) -> Module {
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(funcs)) => funcs
 946 |     None => return mod
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_sec = match mod.func_sec {
     |     Some(FuncSec(type_idxs)) => type_idxs
 950 |     None => return mod
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if funcs.is_empty() {
 953 |     return mod
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_types = collect_func_types(mod)
     |   let total_func_count = func_types.length()
     |   if total_func_count == 0 {
 958 |     return mod
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_func_count = count_imported_funcs(mod)
     |   let calls_by_target : Array[Array[CallSite]] = []
     |   for i = 0; i < total_func_count; i = i + 1 {
     |     ignore(i)
     |     calls_by_target.push([])
     |   }
     |   let env = Env::new().with_module(mod)
     |   let local_types_by_abs = build_local_types_by_abs(
     |     func_types, funcs, import_func_count,
     |   )
     |   let global_types = collect_global_types(mod)
     |   let call_counts : Array[Int] = Array::make(total_func_count, 0)
     |   let dropped_call_counts : Array[Int] = Array::make(total_func_count, 0)
     |   let has_unseen_calls : Array[Bool] = Array::make(total_func_count, false)
     |   let has_tail_calls : Array[Bool] = Array::make(total_func_count, false)
     |   let tail_callee : Array[Bool] = Array::make(total_func_count, false)
     |   let return_callers : Array[Bool] = Array::make(total_func_count, false)
     |   mark_exports_unseen(mod, has_unseen_calls)
     |   mark_start_unseen(mod, has_unseen_calls)
     |   mark_elem_unseen(mod, has_unseen_calls)
     |   let used_params_by_defined : Array[Set[Int]] = []
     |   let body_can_remove_result : Array[Bool] = []
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     let abs_idx = import_func_count + i
     |     let used_params : Set[Int] = Set::new()
     |     used_params_by_defined.push(used_params)
     |     match funcs[i] {
     |       TFunc(_, body) => {
     |         body_can_remove_result.push(
     |           body_ends_with_explicit_return_or_unreachable(body),
     |         )
     |         if abs_idx >= 0 && abs_idx < total_func_count {
     |           let FuncType(params, _) = func_types[abs_idx]
     |           analyze_function_body(
     |             abs_idx,
     |             params.length(),
     |             body,
     |             calls_by_target,
     |             call_counts,
     |             dropped_call_counts,
     |             has_unseen_calls,
     |             has_tail_calls,
     |             tail_callee,
     |             return_callers,
     |             used_params,
     |           )
     |         }
     |       }
1008 |       _ => body_can_remove_result.push(false)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   let removed_unused_by_defined : Array[Set[Int]] = []
     |   let removed_const_by_defined : Array[Map[Int, TInstr]] = []
     |   let result_removed_by_defined : Array[Bool] = []
     |   let refined_params_by_defined : Array[Array[ValType]] = []
     |   let refined_results_by_defined : Array[Array[ValType]] = []
     |   let removed_params_by_target : Array[Set[Int]] = []
     |   for i = 0; i < total_func_count; i = i + 1 {
     |     ignore(i)
     |     removed_params_by_target.push(Set::new())
     |   }
     |   let result_removed_by_target : Array[Bool] = Array::make(
     |     total_func_count, false,
     |   )
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     let abs_idx = import_func_count + i
     |     let removed_unused : Set[Int] = Set::new()
     |     let removed_const : Map[Int, TInstr] = Map::new()
     |     let mut remove_result = false
     |     let mut refined_params : Array[ValType] = []
     |     let mut refined_results : Array[ValType] = []
     |     if abs_idx >= 0 && abs_idx < total_func_count {
     |       let FuncType(params, results) = func_types[abs_idx]
     |       let calls = calls_by_target[abs_idx]
     |       let used_params = used_params_by_defined[i]
     |       refined_params = if has_unseen_calls[abs_idx] {
     |         params.copy()
     |       } else {
     |         refine_param_types(params, calls, local_types_by_abs, global_types, env)
     |       }
     |       refined_results = if has_tail_calls[abs_idx] {
1041 |         results.copy()
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         match funcs[i] {
     |           TFunc(_, body) =>
     |             refine_return_types(
     |               results, body, abs_idx, local_types_by_abs, global_types, env,
     |             )
1048 |           _ => results.copy()
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       if not(return_callers[abs_idx]) && not(calls.is_empty()) {
     |         let constants = if has_unseen_calls[abs_idx] {
     |           Map::new()
     |         } else {
     |           compute_constant_params(refined_params, calls)
     |         }
     |         for p = 0; p < refined_params.length(); p = p + 1 {
     |           if not(all_calls_arg_pure(calls, p)) {
1059 |             continue
     |             ^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if not(has_unseen_calls[abs_idx]) {
     |             match constants.get(p) {
     |               Some(c) => removed_const.set(p, c)
1064 |               None => if not(used_params.contains(p)) { removed_unused.add(p) }
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           } else if not(used_params.contains(p)) {
     |             removed_unused.add(p)
     |           }
     |         }
     |       }
     |       let removed_all : Set[Int] = Set::new()
     |       for p = 0; p < refined_params.length(); p = p + 1 {
     |         if removed_unused.contains(p) || removed_const.contains(p) {
     |           removed_all.add(p)
     |         }
     |       }
     |       removed_params_by_target[abs_idx] = removed_all
     |       if not(has_unseen_calls[abs_idx]) &&
     |         not(return_callers[abs_idx]) &&
     |         not(has_tail_calls[abs_idx]) &&
     |         not(tail_callee[abs_idx]) &&
     |         results.length() > 0 &&
     |         call_counts[abs_idx] > 0 &&
     |         call_counts[abs_idx] == dropped_call_counts[abs_idx] &&
     |         body_can_remove_result[i] {
     |         remove_result = true
     |         result_removed_by_target[abs_idx] = true
     |       }
     |     } else {
1090 |       refined_params = []
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       refined_results = []
     |     }
     |     removed_unused_by_defined.push(removed_unused)
     |     removed_const_by_defined.push(removed_const)
     |     result_removed_by_defined.push(remove_result)
     |     refined_params_by_defined.push(refined_params)
     |     refined_results_by_defined.push(refined_results)
     |   }
     |   let type_recs = match mod.type_sec {
     |     Some(TypeSec(rs)) => rs.copy()
1101 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_type_idxs = func_sec.copy()
     |   let mut flat_type_count = flattened_type_count(type_recs)
     |   let mut signature_changed = false
     |   let has_signature_change_by_defined : Array[Bool] = Array::make(
     |     funcs.length(),
     |     false,
     |   )
     |   let adapted_by_defined : Array[Bool] = Array::make(funcs.length(), false)
     |   let cloned_new_type_idx_by_defined : Array[TypeIdx?] = Array::make(
     |     funcs.length(),
     |     None,
     |   )
     |   let target_remap : Array[Int] = []
     |   for i = 0; i < total_func_count; i = i + 1 {
     |     target_remap.push(i)
     |   }
     |   let old_total_func_count = total_func_count
     |   let mut appended_clones = 0
     |   for i = 0; i < funcs.length() && i < func_type_idxs.length(); i = i + 1 {
     |     let abs_idx = import_func_count + i
     |     if abs_idx < 0 || abs_idx >= total_func_count {
1124 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let removed = removed_params_by_target[abs_idx]
     |     let remove_result = result_removed_by_target[abs_idx]
     |     let FuncType(old_params, old_results) = func_types[abs_idx]
     |     let refined_params = refined_params_by_defined[i]
     |     let refined_results = refined_results_by_defined[i]
     |     let params_refined = refined_params != old_params
     |     let results_refined = refined_results != old_results
     |     if removed.is_empty() &&
     |       not(remove_result) &&
     |       not(params_refined) &&
     |       not(results_refined) {
     |       continue
     |     }
     |     has_signature_change_by_defined[i] = true
     |     if has_unseen_calls[abs_idx] && old_results.length() > 1 {
1141 |       has_signature_change_by_defined[i] = false
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       removed_params_by_target[abs_idx].clear()
     |       result_removed_by_target[abs_idx] = false
1144 |       removed_unused_by_defined[i].clear()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       removed_const_by_defined[i].clear()
     |       result_removed_by_defined[i] = false
1147 |       refined_params_by_defined[i] = old_params.copy()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       refined_results_by_defined[i] = old_results.copy()
     |       continue
     |     }
     |     let new_params : Array[ValType] = []
     |     for p = 0; p < refined_params.length(); p = p + 1 {
     |       if not(removed.contains(p)) {
     |         new_params.push(refined_params[p])
     |       }
     |     }
     |     let new_results = if remove_result { [] } else { refined_results.copy() }
     |     type_recs.push(make_func_type(new_params, new_results))
     |     let new_type_idx = TypeIdx::new(flat_type_count.reinterpret_as_uint())
     |     flat_type_count += 1
     |     if has_unseen_calls[abs_idx] {
     |       adapted_by_defined[i] = true
     |       cloned_new_type_idx_by_defined[i] = Some(new_type_idx)
     |       let new_abs_idx = old_total_func_count + appended_clones
     |       target_remap[abs_idx] = new_abs_idx
     |       appended_clones += 1
     |     } else {
     |       func_type_idxs[i] = new_type_idx
     |     }
     |     signature_changed = true
     |   }
     |   if appended_clones > 0 {
     |     for i = 0; i < funcs.length(); i = i + 1 {
     |       if not(adapted_by_defined[i]) {
     |         continue
     |       }
     |       match cloned_new_type_idx_by_defined[i] {
     |         Some(type_idx) => func_type_idxs.push(type_idx)
1179 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   let mut out_mod = mod
     |   if signature_changed {
     |     out_mod = out_mod
     |       .with_type_sec(TypeSec::new(type_recs))
     |       .with_func_sec(FuncSec::new(func_type_idxs))
     |   }
     |   let new_funcs : Array[Func] = []
     |   let appended_clones_funcs : Array[Func] = []
     |   let mut body_changed = false
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     let abs_idx = import_func_count + i
     |     match funcs[i] {
     |       TFunc(locals, body) if abs_idx >= 0 && abs_idx < total_func_count => {
     |         let FuncType(old_params, _) = func_types[abs_idx]
     |         let removed_unused = removed_unused_by_defined[i]
     |         let removed_const = removed_const_by_defined[i]
     |         let remove_result = result_removed_by_defined[i]
     |         let (new_locals, prologue, removed_total, const_local_slots) = build_local_plan(
     |           locals, old_params, removed_unused, removed_const,
     |         )
     |         let body1 = rewrite_locals_and_returns(
     |           body,
     |           old_params.length(),
     |           removed_unused,
     |           removed_const,
     |           const_local_slots,
     |           removed_total,
     |           remove_result,
     |         )
     |         let body2 = rewrite_calls(
     |           body1, removed_params_by_target, result_removed_by_target, target_remap,
     |         )
     |         let final_body = if prologue.is_empty() {
     |           body2
     |         } else {
     |           TExpr::new([..prologue, ..body2.0])
     |         }
     |         let new_func = Func::t_func(new_locals, final_body)
     |         if adapted_by_defined[i] {
     |           let FuncType(old_params, old_results) = func_types[abs_idx]
     |           let thunk = make_adapter_thunk(
     |             target_remap[abs_idx],
     |             old_params,
     |             old_results,
     |             removed_unused,
     |             removed_const,
     |             remove_result,
     |           )
     |           if thunk != funcs[i] {
     |             body_changed = true
     |           }
     |           new_funcs.push(thunk)
     |           appended_clones_funcs.push(new_func)
     |         } else {
     |           new_funcs.push(new_func)
     |         }
     |         if new_func != funcs[i] || has_signature_change_by_defined[i] {
     |           body_changed = true
     |         }
     |       }
1243 |       TFunc(_, body) => {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let rewritten = rewrite_calls(
     |           body, removed_params_by_target, result_removed_by_target, target_remap,
     |         )
     |         if rewritten != body {
1248 |           body_changed = true
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           match funcs[i] {
     |             TFunc(ls, _) => new_funcs.push(Func::t_func(ls, rewritten))
     |             _ => new_funcs.push(funcs[i])
     |           }
     |         } else {
1254 |           new_funcs.push(funcs[i])
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1257 |       _ => new_funcs.push(funcs[i])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   for clone in appended_clones_funcs {
     |     new_funcs.push(clone)
     |   }
     |   if not(signature_changed) && not(body_changed) {
1264 |     return mod
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out_mod.with_code_sec(CodeSec::new(new_funcs))
     | }
     …

     | fn dead_argument_elim_pass(mod : Module) -> ModuleTransformer[IRContext] {
     |   let rewritten = run_dead_argument_elim(mod)
     |   let rewritten_code = rewritten.code_sec
     |   let rewritten_types = rewritten.type_sec
     |   let rewritten_funcs = rewritten.func_sec
     |   ModuleTransformer::new()
     |   .on_typesec_evt(fn(_, ctx : IRContext, type_sec : TypeSec) {
     |     match rewritten_types {
     |       Some(new_type_sec) =>
     |         if new_type_sec == type_sec {
1280 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           change(ctx, new_type_sec)
     |         }
1284 |       None => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   .on_funcsec_evt(fn(_, ctx : IRContext, func_sec : FuncSec) {
     |     match rewritten_funcs {
     |       Some(new_func_sec) =>
     |         if new_func_sec == func_sec {
1291 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           change(ctx, new_func_sec)
     |         }
1295 |       None => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   .on_codesec_evt(fn(_, ctx : IRContext, code_sec : CodeSec) {
     |     match rewritten_code {
     |       Some(new_code) =>
     |         if new_code == code_sec {
1302 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           change(ctx, new_code)
     |         }
1306 |       None => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

23 uncovered line(s) in src/passes/dead_code_elimination.mbt:

    | fn dead_code_elimination_ir_pass(_mod : Module) -> ModuleTransformer[IRContext] {
 10 |   wrap_unit_func_pass(dead_code_elimination_pass())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn dce_texpr(
    |   transformer : ModuleTransformer[Unit],
    |   _ctx : Unit,
    |   expr : TExpr,
    | ) -> TransformerResult[Unit, TExpr] {
    |   let TExpr(instrs) = expr
    |   let out : Array[TInstr] = []
    |   let mut changed = false
    |   let mut after_unreachable = false
    |   for instr in instrs {
    |     if after_unreachable {
    |       changed = true
    |       continue
    |     }
    |     let new_instr = match transformer.walk_tinstruction((), instr) {
 29 |       Err(e) => return Err(e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Ok(None) => instr
    |       Ok(Some((_, updated))) => updated
    |     }
    |     if new_instr != instr {
    |       changed = true
    |     }
    |     out.push(new_instr)
    |     if is_unreachable_instr(new_instr) {
    |       after_unreachable = true
    |     }
    |   }
    |   if !changed {
    |     unchanged()
    |   } else {
    |     change((), TExpr::new(out))
    |   }
    | }
    …

    | fn dce_tinstr(
    |   transformer : ModuleTransformer[Unit],
    |   _ctx : Unit,
    |   instr : TInstr,
    | ) -> TransformerResult[Unit, TInstr] {
    |   let walked = match transformer.walk_tinstruction_default((), instr) {
 55 |     Err(e) => return Err(e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Ok(None) => instr
    |     Ok(Some((_, updated))) => updated
    |   }
    |   let mut rewritten = walked
    | 
    |   // Control-flow-structure rewrites that need explicit handling.
    |   rewritten = match rewritten {
    |     TBlock(_, body) if is_single_unreachable_texpr(body) =>
 64 |       TInstr::unreachable_()
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TIf(_, cond, _, _) if is_unreachable_instr(cond) => cond
    |     TLoop(_, body) if is_single_unreachable_texpr(body) =>
    |       TInstr::unreachable_()
    |     _ => rewritten
    |   }
    | 
    |   // Non-control rewrite:
    |   // If an unreachable child makes this expression unreachable,
    |   // keep effects before the first unreachable as drops, keep the first
    |   // unreachable child, and remove everything after.
    |   if !is_control_flow_structure(rewritten) &&
    |     is_unreachable_instr(rewritten) &&
    |     has_unreachable_child(rewritten) {
    |     rewritten = rewrite_non_control_unreachable(rewritten)
    |   }
    |   if rewritten == instr {
    |     unchanged()
    |   } else {
    |     change((), rewritten)
    |   }
    | }
    …

    | fn has_break_to_depth(instr : TInstr, depth : Int) -> Bool {
    |   match instr {
    |     TBr(label, _) => label_matches_depth(label, depth)
146 |     TBrIf(label, _, _) => label_matches_depth(label, depth)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TBrTable(labels, default, _, _) => {
    |       if label_matches_depth(default, depth) {
149 |         return true
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       for label in labels {
152 |         if label_matches_depth(label, depth) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           return true
    |         }
    |       }
    |       false
    |     }
    |     TBrOnNull(label, _, _)
    |     | TBrOnNonNull(label, _, _)
    |     | TBrOnCast(label, _, _, _, _, _)
161 |     | TBrOnCastFail(label, _, _, _, _, _) => label_matches_depth(label, depth)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TBlock(_, body) | TLoop(_, body) =>
    |       has_break_to_depth_in_texpr(body, depth + 1)
    |     TIf(_, cond, then_body, else_body) => {
    |       if has_break_to_depth(cond, depth) {
166 |         return true
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       if has_break_to_depth_in_texpr(then_body, depth + 1) {
169 |         return true
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       match else_body {
    |         Some(body) => has_break_to_depth_in_texpr(body, depth + 1)
173 |         None => false
    |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     TTryTable(_, catches, body) => {
    |       for catch_ in catches {
    |         if catch_targets_depth(catch_, depth + 1) {
    |           return true
    |         }
    |       }
    |       has_break_to_depth_in_texpr(body, depth + 1)
    |     }
    |     _ => {
    |       for child in eval_children(instr) {
    |         if has_break_to_depth(child, depth) {
187 |           return true
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       false
    |     }
    |   }
    | }
    …

    | fn is_unreachable_instr(instr : TInstr) -> Bool {
    |   match instr {
    |     TUnreachable => true
    | 
    |     // Always transfer control away from the current continuation.
    |     TBr(_, _)
    |     | TBrTable(_, _, _, _)
    |     | TReturn(_)
    |     | TReturnCall(_, _)
    |     | TReturnCallIndirect(_, _, _, _)
    |     | TReturnCallRef(_, _, _)
    |     | TThrow(_, _)
    |     | TThrowRef(_) => true
    | 
    |     // Block is unreachable only when its body is unreachable and there are
    |     // no breaks to the block itself.
    |     TBlock(_, body) =>
    |       texpr_is_unreachable(body) && !has_break_to_depth_in_texpr(body, 0)
    | 
    |     // If is unreachable when condition is unreachable or both branches are.
    |     TIf(_, cond, then_body, else_body) => {
    |       if is_unreachable_instr(cond) {
228 |         return true
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       match else_body {
    |         Some(other) =>
    |           texpr_is_unreachable(then_body) && texpr_is_unreachable(other)
    |         None => false
    |       }
    |     }
    | 
    |     // Loop can only fall through if the body can fall through.
    |     TLoop(_, body) => texpr_is_unreachable(body)
    | 
    |     // try_table can finish normally only when its body can finish normally.
    |     TTryTable(_, _, body) => texpr_is_unreachable(body)
    | 
    |     // For non-control ops, any unreachable child makes the parent unreachable.
    |     _ => has_unreachable_child(instr)
    |   }
    | }
    …

    | fn rewrite_non_control_unreachable(instr : TInstr) -> TInstr {
    |   let children = eval_children(instr)
    |   let remaining : Array[TInstr] = []
    |   let mut after_unreachable = false
    |   for child in children {
    |     if after_unreachable {
255 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     if is_unreachable_instr(child) {
    |       remaining.push(child)
    |       after_unreachable = true
    |     } else {
    |       remaining.push(TInstr::drop(child))
    |     }
    |   }
    |   match remaining {
    |     [single] => single
    |     _ => TInstr::block(BlockType::void_(), TExpr::new(remaining))
    |   }
    | }
    …

    | fn eval_children(instr : TInstr) -> Array[TInstr] {
    |   match instr {
    |     // Zero-operand instructions.
    |     TI32Const(_)
    |     | TI64Const(_)
    |     | TF32Const(_)
    |     | TF64Const(_)
    |     | TRefNull(_)
    |     | TRefFunc(_)
    |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
    |     | TUnreachable
    |     | TNop
    |     | TLocalGet(_)
    |     | TGlobalGet(_)
    |     | TMemorySize(_)
    |     | TAtomicFence
    |     | TTableSize(_)
    |     | TDataDrop(_)
    |     | TElemDrop(_)
    |     | TStructNewDefault(_) => []
    | 
    |     // Unary operands.
    |     TUnary(_, child)
    |     | TDrop(child)
    |     | TLocalSet(_, child)
    |     | TLocalTee(_, child)
    |     | TGlobalSet(_, child)
    |     | TRefIsNull(child)
    |     | TRefAsNonNull(child)
    |     | TI31GetS(child)
    |     | TI31GetU(child)
    |     | TRefI31(child)
    |     | TArrayLen(child)
    |     | TAnyConvertExtern(child)
    |     | TExternConvertAny(child)
    |     | TThrowRef(child)
    |     | TMemoryGrow(_, child)
    |     | TTableGet(_, child)
    |     | TLoad(_, _, child)
    |     | TArrayNewDefault(_, child)
    |     | TStructGet(_, _, child)
    |     | TStructGetS(_, _, child)
    |     | TStructGetU(_, _, child)
    |     | TI8x16Splat(child)
    |     | TI16x8Splat(child)
    |     | TI32x4Splat(child)
    |     | TI64x2Splat(child)
    |     | TF32x4Splat(child)
    |     | TF64x2Splat(child)
    |     | TExtractLane(_, _, child)
    |     | TRefTest(_, _, child)
    |     | TRefCast(_, _, child)
    |     | TRefGetDesc(child)
    |     | TRefTestDesc(_, _, child)
    |     | TRefCastDescEq(_, _, child) => [child]
    | 
    |     // Two operands.
    |     TBinary(_, left, right)
    |     | TRefEq(left, right)
    |     | TStore(_, _, left, right)
    |     | TMemoryAtomicNotify(_, left, right)
    |     | TAtomicRmw(_, _, left, right)
    |     | TTableSet(_, left, right)
    |     | TTableGrow(_, left, right)
    |     | TStructSet(_, _, left, right)
    |     | TArrayNew(_, left, right)
    |     | TArrayNewData(_, _, left, right)
    |     | TArrayNewElem(_, _, left, right)
    |     | TArrayGet(_, left, right)
    |     | TArrayGetS(_, left, right)
    |     | TArrayGetU(_, left, right)
    |     | TReplaceLane(_, _, left, right)
    |     | TI8x16Swizzle(left, right)
    |     | TI8x16RelaxedSwizzle(left, right)
    |     | TV128Shift(_, left, right)
    |     | TV128LoadLane(_, _, _, left, right)
    |     | TV128StoreLane(_, _, _, left, right) => [left, right]
    | 
    |     // Three operands.
    |     TMemoryFill(_, a, b, c)
    |     | TMemoryCopy(_, _, a, b, c)
    |     | TMemoryInit(_, _, a, b, c)
    |     | TMemoryAtomicWait32(_, a, b, c)
    |     | TMemoryAtomicWait64(_, a, b, c)
    |     | TAtomicCmpxchg(_, _, a, b, c)
    |     | TTableFill(_, a, b, c)
    |     | TTableCopy(_, _, a, b, c)
    |     | TTableInit(_, _, a, b, c)
    |     | TSelect(_, c, a, b)
360 |     | TV128Ternary(_, a, b, c) => [a, b, c]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |     // Variable-length operands.
    |     TCall(_, args)
    |     | TReturnCall(_, args)
    |     | TThrow(_, args)
    |     | TBr(_, args)
    |     | TReturn(args)
    |     | TStructNew(_, args)
    |     | TArrayNewFixed(_, args) => args.copy()
370 |     TCallIndirect(_, _, args, index) | TReturnCallIndirect(_, _, args, index) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = args.copy()
    |       out.push(index)
    |       out
    |     }
375 |     TCallRef(_, args, ref_) | TReturnCallRef(_, args, ref_) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = args.copy()
    |       out.push(ref_)
    |       out
    |     }
    |     TBrIf(_, cond, values) => {
    |       let out = values.copy()
    |       out.push(cond)
    |       out
    |     }
385 |     TBrTable(_, _, index, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(index)
    |       out
    |     }
    |     TBrOnNull(_, ref_, values)
    |     | TBrOnNonNull(_, ref_, values)
    |     | TBrOnCast(_, _, _, _, ref_, values)
393 |     | TBrOnCastFail(_, _, _, _, ref_, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(ref_)
    |       out
    |     }
398 |     TArraySet(_, a, b, c) => [a, b, c]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TArrayFill(_, a, b, c, d) => [a, b, c, d]
    |     TArrayCopy(_, _, a, b, c, d, e) => [a, b, c, d, e]
    |     TArrayInitData(_, _, a, b, c, d) => [a, b, c, d]
    |     TArrayInitElem(_, _, a, b, c, d) => [a, b, c, d]
    |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, left, right) =>
404 |       [left, right]
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |     // Control-flow structures are handled directly by control-flow logic.
407 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => []
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn run_dce_on_texpr(expr : TExpr) -> TExpr {
    |   let pass = dead_code_elimination_pass()
    |   match pass.walk_texpr((), expr) {
    |     Ok(Some((_, out))) => out
416 |     _ => expr
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

23 uncovered line(s) in src/passes/directize.mbt:

     | fn make_table_write_analyzer(infos : TableInfoMap) -> ModuleTransformer[Unit] {
     |   ModuleTransformer::new().on_tinstruction_evt(fn(_, _, instr : TInstr) {
     |     match instr {
     |       // Any runtime write invalidates entry-based initialization
     |       TTableSet(table_idx, _, _)
     |       | TTableFill(table_idx, _, _, _)
     |       | TTableInit(_, table_idx, _, _, _)
     |       | TTableCopy(table_idx, _, _, _, _) =>
     |         match infos.get(table_idx) {
     |           Some(info) =>
     |             infos.set(table_idx, TableInfo::{
     |               flat_names: info.flat_names,
     |               may_overwrite_entries: true,
     |               may_grow: info.may_grow,
     |               initial_contents_immutable: info.initial_contents_immutable,
     |               initialization_complete: false,
     |             })
  51 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     | 
     |       // Growing the table invalidates completeness but not existing writes
     |       TTableGrow(table_idx, _, _) =>
     |         match infos.get(table_idx) {
     |           Some(info) =>
     |             infos.set(table_idx, TableInfo::{
     |               flat_names: info.flat_names,
     |               may_overwrite_entries: info.may_overwrite_entries,
     |               may_grow: true,
     |               initial_contents_immutable: info.initial_contents_immutable,
     |               initialization_complete: false,
     |             })
  65 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |     Ok(None)
     |   })
     | }
     …

     | fn compute_table_info(
     |   m : Module,
     |   initial_immutable : Bool,
     | ) -> Result[TableInfoMap, String] {
     |   let infos = Map::new()
     | 
     |   // 1. Initialize tables from Table Section
     |   match m.table_sec {
     |     Some(TableSec(tables)) =>
     |       for i in 0..<tables.length() {
     |         let min_size = match tables[i].0.1 {
     |           I32Limits(min, _) => min
     |           I64Limits(min, _) => min.to_uint()
     |         }
     |         infos.set(TableIdx::new(i.reinterpret_as_uint()), TableInfo::{
     |           flat_names: Array::make(min_size.reinterpret_as_int(), None),
     |           may_overwrite_entries: false,
     |           may_grow: false,
     |           initial_contents_immutable: initial_immutable,
     |           initialization_complete: true,
     |         })
     |       }
     |     None => ()
     |   }
     | 
     |   // 2. Apply element segments
     |   match m.elem_sec {
     |     Some(ElemSec(elems)) =>
     |       for elem in elems {
     |         // Use the structure matching your Elem::new(mode, kind) test setup
     |         match (elem.0, elem.1) {
     |           (Active(table_idx, offset_expr), FuncsElemKind(funcs)) =>
     |             match infos.get(table_idx) {
     |               Some(info) =>
     |                 // We only handle a single I32Const as an offset
     |                 if offset_expr.0.length() == 1 {
     |                   match offset_expr.0[0] {
     |                     I32Const(I32(off)) => {
     |                       let names = info.flat_names
     |                       let mut ok = true
     |                       for j in 0..<funcs.length() {
     |                         let idx = off + j
     |                         if idx < 0 || idx >= names.length() {
     |                           // OOB initialization is a validation error in Wasm, 
     |                           // but for us, it just means we can't optimize.
 119 |                           ok = false
     |                           ^^^^^^^^^^ 	<-- UNCOVERED
     |                           break
     |                         }
     |                         if names[idx] is Some(_) {
 123 |                           ok = false // Overwriting existing entry
     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           break
     |                         }
     |                         names[idx] = Some(funcs[j])
     |                       }
     |                       infos.set(table_idx, {
     |                         ..info,
     |                         flat_names: names,
     |                         may_overwrite_entries: info.may_overwrite_entries || !ok,
     |                         initialization_complete: info.initialization_complete &&
     |                         ok,
     |                       })
     |                     }
     |                     // Complex offset expression: mark incomplete
     |                     _ =>
     |                       infos.set(table_idx, {
     |                         ..info,
     |                         initialization_complete: false,
     |                       })
     |                   }
     |                 } else {
 144 |                   infos.set(table_idx, {
     |                   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     ..info,
     |                     initialization_complete: false,
     |                   })
     |                 }
 149 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     | 
     |           // If it's an active segment we don't handle (like FuncExprs), 
     |           // we must invalidate that table's completeness.
     |           (Active(table_idx, _), _) =>
     |             match infos.get(table_idx) {
     |               Some(info) =>
     |                 infos.set(table_idx, { ..info, initialization_complete: false })
 158 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           _ => () // Passive/Declarative don't affect initial table state
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   // 3. Analyze runtime writes (TTableSet, etc.)
     |   let analyzer = make_table_write_analyzer(infos)
     |   match analyzer.walk_module((), m) {
     |     Ok(_) => Ok(infos)
 170 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn get_target_info(
     |   index : TInstr,
     |   table : TableInfo,
     |   call_type : TypeIdx,
     |   env : Env,
     | ) -> IndirectTargetInfo {
     |   match index {
     |     TI32Const(I32(i)) => {
     |       let idx = i.reinterpret_as_uint()
     |       let size = table.flat_names.length().reinterpret_as_uint()
     |       if idx >= size {
     |         if table.may_grow {
 187 |           Unknown
     |           ^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           Trap
     |         }
     |       } else {
     |         match table.flat_names[idx.reinterpret_as_int()] {
     |           None => Trap
     |           Some(func_idx) =>
     |             match env.get_functype_by_funcidx(func_idx) {
 196 |               None => Trap
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(func_ty) =>
     |                 match env.resolve_functype(call_type) {
 199 |                   None => Trap
     |                   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   Some(call_ty) =>
     |                     if func_ty == call_ty {
     |                       Known(func_idx)
     |                     } else {
     |                       Trap
     |                     }
     |                 }
     |             }
     |         }
     |       }
     |     }
     |     _ => Unknown
     |   }
     | }
     …

     | fn make_call_branch(info : IndirectTargetInfo, args : Array[TInstr]) -> TExpr {
     |   match info {
     |     Known(func_idx) => TExpr::new([TInstr::call(func_idx, args)])
     |     Trap => TExpr::new([TInstr::unreachable_()])
     |     Unknown =>
     |       // Should never be used if we check properly
 235 |       TExpr::new([TInstr::unreachable_()])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rewrite_select_call_indirect(
     |   type_idx : TypeIdx,
     |   table : TableInfo,
     |   args : Array[TInstr],
     |   then_idx : TInstr,
     |   else_idx : TInstr,
     |   cond : TInstr,
     |   env : Env,
     | ) -> TInstr? {
     |   let (then_info, else_info) = get_select_targets(
     |     then_idx, else_idx, table, type_idx, env,
     |   )
     |   match then_info {
 253 |     Unknown => None
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ =>
     |       match else_info {
 256 |         Unknown => None
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => {
     |           let then_expr = make_call_branch(then_info, args)
     |           let else_expr = make_call_branch(else_info, args)
     |           Some(
     |             TInstr::if_(
     |               BlockType::type_idx(type_idx),
     |               cond,
     |               then_expr,
     |               Some(else_expr),
     |             ),
     |           )
     |         }
     |       }
     |   }
     | }
     …

     | fn rewrite_br_table_call_indirect(
     |   type_idx : TypeIdx,
     |   table : TableInfo,
     |   args : Array[TInstr],
     |   labels : Array[LabelIdx],
     |   default_label : LabelIdx,
     |   index : TInstr,
     |   carried : Array[TInstr],
     |   env : Env,
     | ) -> TInstr? {
     |   let target_count = labels.length() + 1
     |   let targets = Array::new()
     | 
     |   // Resolve each possible numeric index
     |   for i in 0..<target_count {
     |     let idx_instr = TInstr::i32_const(I32(i))
     |     let info = get_target_info(idx_instr, table, type_idx, env)
     |     match info {
 292 |       Unknown => return None
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => targets.push(info)
     |     }
     |   }
     | 
     |   // Build nested blocks from bottom up
     |   let mut body = TExpr::new([
     |     TInstr::br_table(labels, default_label, index, carried),
     |   ])
     |   for info in targets.rev_iter() {
     |     let branch = match info {
     |       Known(func_idx) =>
     |         TExpr::new([TInstr::call(func_idx, args), TInstr::return_([])])
 305 |       Trap => TExpr::new([TInstr::unreachable_()])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Unknown => TExpr::new([TInstr::unreachable_()])
     |     }
     |     body = TExpr::new(
     |       [TInstr::block(BlockType::type_idx(type_idx), branch), ..body.0],
     |     )
     |   }
     |   Some(TInstr::block(BlockType::type_idx(type_idx), body))
     | }
     …

     | fn make_directize_transformer(
     |   tables : TableInfoMap,
     |   env : Env,
     | ) -> ModuleTransformer[Unit] {
     |   ModuleTransformer::new().on_tinstruction_evt(fn(_, _, instr) {
     |     match instr {
     |       TCallIndirect(type_idx, table_idx, args, index) =>
     |         match tables.get(table_idx) {
     |           Some(table) if table.can_optimize_by_entry() =>
     |             match index {
     |               TSelect(_, then_idx, else_idx, cond) =>
     |                 match
     |                   rewrite_select_call_indirect(
     |                     type_idx, table, args, then_idx, else_idx, cond, env,
     |                   ) {
     |                   Some(i) => change((), i)
 332 |                   None => unchanged()
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               TBrTable(labels, default_label, idx, carried) =>
     |                 match
     |                   rewrite_br_table_call_indirect(
     |                     type_idx, table, args, labels, default_label, idx, carried, env,
     |                   ) {
     |                   Some(i) => change((), i)
 340 |                   None => unchanged()
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               _ =>
     |                 match get_target_info(index, table, type_idx, env) {
     |                   Known(f) => change((), TInstr::call(f, args))
     |                   Trap => change((), TInstr::unreachable_())
     |                   Unknown => unchanged()
     |                 }
     |             }
     |           _ => Ok(None)
     |         }
     |       TReturnCallIndirect(type_idx, table_idx, args, index) =>
     |         match tables.get(table_idx) {
     |           Some(table) if table.can_optimize_by_entry() =>
     |             match get_target_info(index, table, type_idx, env) {
     |               Known(f) => change((), TInstr::return_call(f, args))
     |               Trap => change((), TInstr::unreachable_())
 357 |               Unknown => unchanged()
     |               ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
 359 |           _ => unchanged()
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => unchanged()
     |     }
     |   })
     | }
     …

     | fn directize_ir_pass(
     |   mod : Module,
     |   initial_immutable : Bool,
     | ) -> Result[ModuleTransformer[IRContext], String] {
     |   let env = Env::new().with_module(mod)
     |   let tables = match compute_table_info(mod, initial_immutable) {
 373 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(tables) => tables
     |   }
     |   Ok(wrap_unit_func_pass(make_directize_transformer(tables, env)))
     | }
     …

     | fn directize_module(
     |   m : Module,
     |   initial_immutable : Bool,
     | ) -> Result[Module, String] {
     |   let pass = match directize_ir_pass(m, initial_immutable) {
     |     Ok(pass) => pass
 386 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match pass.walk_module(IRContext::new(), m) {
     |     Ok(Some((_, new_m))) => Ok(new_m)
 390 |     Ok(None) => Ok(m)
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

26 uncovered line(s) in src/passes/duplicate_function_elimination.mbt:

    | fn dfe_imported_func_count(mod : Module) -> Int {
    |   let mut n = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 17 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(_) => n += 1
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   n
    | }
    …

    | fn dfe_extract_comp_type(sub_type : SubType) -> CompType {
    |   match sub_type {
 32 |     SubType(_, _, comp) => comp
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     CompTypeSubType(comp) => comp
    |   }
    | }
    …

    | fn dfe_resolve_func_type(
    |   comp_types : Array[CompType],
    |   idx : TypeIdx,
    | ) -> FuncType? {
    |   let i = match idx {
    |     TypeIdx(n) => n
 44 |     RecIdx(n) => n
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let j = i.reinterpret_as_int()
    |   if j < 0 || j >= comp_types.length() {
 48 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match comp_types[j] {
    |     FuncCompType(params, results) => Some(FuncType::new(params, results))
 52 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn dfe_collect_func_types(mod : Module) -> Array[FuncType] {
    |   let comp_types : Array[CompType] = []
    |   match mod.type_sec {
    |     Some(TypeSec(rec_types)) =>
    |       for rec_type in rec_types {
    |         match rec_type {
    |           SingleRecType(sub_type) =>
    |             comp_types.push(dfe_extract_comp_type(sub_type))
    |           GroupRecType(sub_types) =>
 66 |             for sub_type in sub_types {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               comp_types.push(dfe_extract_comp_type(sub_type))
    |             }
    |         }
    |       }
 71 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_types : Array[FuncType] = []
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 76 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(type_idx) =>
 80 |             match dfe_resolve_func_type(comp_types, type_idx) {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Some(ft) => func_types.push(ft)
    |               None => func_types.push(FuncType::new([], []))
    |             }
 84 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for type_idx in type_idxs {
    |         match dfe_resolve_func_type(comp_types, type_idx) {
    |           Some(ft) => func_types.push(ft)
 94 |           None => func_types.push(FuncType::new([], []))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
 97 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   func_types
    | }
    …

    | fn dfe_remap_func_indices(
    |   mod : Module,
    |   remap : Map[FuncIdx, FuncIdx],
    | ) -> Result[Module, String] {
    |   if remap.is_empty() {
127 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let transformer = ModuleTransformer::new().on_funcidx_evt(fn(_, _, idx) {
    |     match remap.get(idx) {
    |       Some(new_idx) =>
    |         if new_idx != idx {
    |           change((), new_idx)
    |         } else {
    |           unchanged()
    |         }
137 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   match transformer.walk_module((), mod) {
    |     Ok(Some((_, new_mod))) => Ok(new_mod)
142 |     Ok(None) => Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn dfe_run_iteration(mod : Module) -> Result[(Module, Bool), String] {
    |   let imported_func_count = dfe_imported_func_count(mod)
    |   let type_idxs = match mod.func_sec {
    |     Some(FuncSec(items)) => items
152 |     None => return Ok((mod, false))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let funcs = match mod.code_sec {
    |     Some(CodeSec(items)) => items
156 |     None => return Ok((mod, false))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if type_idxs.length() != funcs.length() {
159 |     return Err(
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |       "duplicate_function_elimination: func_sec/code_sec length mismatch",
    |     )
    |   }
    |   if funcs.is_empty() {
164 |     return Ok((mod, false))
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_types = dfe_collect_func_types(mod)
    |   let total_funcs = imported_func_count + funcs.length()
    |   if func_types.length() < total_funcs {
169 |     return Ok((mod, false))
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let canonical_by_key : Map[DFEKey, Int] = Map::new()
    |   let replacements_abs : Map[Int, Int] = Map::new()
    |   let remove_def : Array[Bool] = []
    |   for _ in funcs {
    |     remove_def.push(false)
    |   }
    |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
    |     let abs_idx = imported_func_count + def_idx
    |     let key = dfe_key(func_types[abs_idx], funcs[def_idx])
    |     match canonical_by_key.get(key) {
    |       Some(canonical_abs_idx) => {
    |         replacements_abs[abs_idx] = canonical_abs_idx
    |         remove_def[def_idx] = true
    |       }
    |       None => canonical_by_key[key] = abs_idx
    |     }
    |   }
    |   if replacements_abs.is_empty() {
    |     return Ok((mod, false))
    |   }
    |   let new_type_idxs : Array[TypeIdx] = []
    |   let new_funcs : Array[Func] = []
    |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
    |     if !remove_def[def_idx] {
    |       new_type_idxs.push(type_idxs[def_idx])
    |       new_funcs.push(funcs[def_idx])
    |     }
    |   }
    |   let old_abs_to_new_abs : Array[Int] = []
    |   for i = 0; i < imported_func_count; i = i + 1 {
201 |     old_abs_to_new_abs.push(i)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let mut next_def_abs = imported_func_count
    |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
    |     if remove_def[def_idx] {
    |       old_abs_to_new_abs.push(-1)
    |     } else {
    |       old_abs_to_new_abs.push(next_def_abs)
    |       next_def_abs += 1
    |     }
    |   }
    |   let remap : Map[FuncIdx, FuncIdx] = Map::new()
    |   for old_abs = 0; old_abs < old_abs_to_new_abs.length(); old_abs = old_abs + 1 {
    |     let new_abs = old_abs_to_new_abs[old_abs]
    |     if new_abs >= 0 {
    |       remap[dfe_func_idx_from_abs(old_abs)] = dfe_func_idx_from_abs(new_abs)
    |     }
    |   }
    |   for entry in replacements_abs {
    |     let (old_abs, canonical_abs) = entry
    |     if canonical_abs < 0 || canonical_abs >= old_abs_to_new_abs.length() {
222 |       return Err(
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |         "duplicate_function_elimination: invalid canonical function index",
    |       )
    |     }
    |     let canonical_new_abs = old_abs_to_new_abs[canonical_abs]
    |     if canonical_new_abs < 0 {
228 |       return Err("duplicate_function_elimination: canonical function removed")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     remap[dfe_func_idx_from_abs(old_abs)] = dfe_func_idx_from_abs(
    |       canonical_new_abs,
    |     )
    |   }
    |   let new_mod = mod
    |     .with_func_sec(FuncSec::new(new_type_idxs))
    |     .with_code_sec(CodeSec::new(new_funcs))
    |   match dfe_remap_func_indices(new_mod, remap) {
    |     Ok(out) => Ok((out, true))
239 |     Err(e) => Err(e)
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn duplicate_function_elimination(
    |   mod : Module,
    |   options : OptimizeOptions,
    | ) -> Result[Module, String] {
    |   let defined_func_count = match mod.code_sec {
    |     Some(CodeSec(funcs)) => funcs.length()
250 |     None => 0
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let mut limit = dfe_limit_for_options(defined_func_count, options)
    |   let mut mod = mod
    |   while limit > 0 {
    |     limit -= 1
    |     match dfe_run_iteration(mod) {
257 |       Err(e) => return Err(e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Ok((new_mod, changed)) => {
    |         mod = new_mod
    |         if !changed {
    |           break
    |         }
    |       }
    |     }
    |   }
    |   Ok(mod)
    | }
    …

11 uncovered line(s) in src/passes/duplicate_import_elimination.mbt:

    | fn die_defined_func_count(mod : Module) -> Result[Int, String] {
    |   let func_count = match mod.func_sec {
    |     Some(FuncSec(funcs)) => funcs.length()
    |     None => 0
    |   }
    |   let code_count = match mod.code_sec {
    |     Some(CodeSec(funcs)) => funcs.length()
    |     None => 0
    |   }
    |   if func_count != code_count {
 23 |     Err("duplicate_import_elimination: func_sec/code_sec length mismatch")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
    |     Ok(func_count)
    |   }
    | }
    …

    | fn die_remap_func_indices(
    |   mod : Module,
    |   remap : Map[FuncIdx, FuncIdx],
    | ) -> Result[Module, String] {
    |   if remap.is_empty() {
 35 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let transformer = ModuleTransformer::new().on_funcidx_evt(fn(_, _, idx) {
    |     match remap.get(idx) {
    |       Some(new_idx) =>
    |         if new_idx != idx {
    |           change((), new_idx)
    |         } else {
 43 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
 45 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   match transformer.walk_module((), mod) {
    |     Ok(Some((_, new_mod))) => Ok(new_mod)
 50 |     Ok(None) => Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn duplicate_import_elimination(mod : Module) -> Result[Module, String] {
    |   let imports = match mod.import_sec {
    |     Some(ImportSec(imports)) => imports
 59 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let defined_func_count = match die_defined_func_count(mod) {
    |     Ok(n) => n
 63 |     Err(e) => return Err(e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if imports.is_empty() {
 66 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let env = Env::new().with_module(mod)
    |   let seen : Map[DIEImportKey, Int] = Map::new()
    |   let duplicate_import_entry = Array::make(imports.length(), false)
    |   let duplicate_func_to_canonical : Map[Int, Int] = Map::new()
    |   let mut imported_func_count = 0
    |   for i = 0; i < imports.length(); i = i + 1 {
    |     match imports[i] {
    |       Import(module_name, base_name, FuncExternType(_)) => {
    |         let current_idx = imported_func_count
    |         let key = die_key(module_name, base_name)
    |         match seen.get(key) {
    |           Some(previous_idx) => {
    |             let previous_type = env.get_functype_by_funcidx(
    |               FuncIdx::new(previous_idx.reinterpret_as_uint()),
    |             )
    |             let current_type = env.get_functype_by_funcidx(
    |               FuncIdx::new(current_idx.reinterpret_as_uint()),
    |             )
    |             if previous_type is Some(_) && previous_type == current_type {
    |               duplicate_import_entry[i] = true
    |               duplicate_func_to_canonical[current_idx] = previous_idx
    |             }
    |           }
    |           None => ()
    |         }
    |         seen[key] = current_idx
    |         imported_func_count += 1
    |       }
    |       _ => ()
    |     }
    |   }
    |   if duplicate_func_to_canonical.is_empty() {
    |     return Ok(mod)
    |   }
    |   let old_import_to_new = Array::make(imported_func_count, -1)
    |   let mut new_imported_func_count = 0
    |   for old_idx = 0; old_idx < imported_func_count; old_idx = old_idx + 1 {
    |     match duplicate_func_to_canonical.get(old_idx) {
    |       Some(canonical_old_idx) => {
    |         if canonical_old_idx < 0 ||
    |           canonical_old_idx >= old_import_to_new.length() {
109 |           return Err(
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |             "duplicate_import_elimination: invalid canonical import index",
    |           )
    |         }
    |         let mapped = old_import_to_new[canonical_old_idx]
    |         if mapped < 0 {
115 |           return Err(
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |             "duplicate_import_elimination: canonical import mapping unresolved",
    |           )
    |         }
    |         old_import_to_new[old_idx] = mapped
    |       }
    |       None => {
    |         old_import_to_new[old_idx] = new_imported_func_count
    |         new_imported_func_count += 1
    |       }
    |     }
    |   }
    |   let total_old_funcs = imported_func_count + defined_func_count
    |   let remap : Map[FuncIdx, FuncIdx] = Map::new()
    |   for old_idx = 0; old_idx < imported_func_count; old_idx = old_idx + 1 {
    |     let new_idx = old_import_to_new[old_idx]
    |     if new_idx < 0 {
132 |       return Err("duplicate_import_elimination: unresolved import remap")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     remap[FuncIdx::new(old_idx.reinterpret_as_uint())] = FuncIdx::new(
    |       new_idx.reinterpret_as_uint(),
    |     )
    |   }
    |   for old_idx = imported_func_count
    |       old_idx < total_old_funcs
    |       old_idx = old_idx + 1 {
    |     let def_idx = old_idx - imported_func_count
    |     let new_idx = new_imported_func_count + def_idx
    |     remap[FuncIdx::new(old_idx.reinterpret_as_uint())] = FuncIdx::new(
    |       new_idx.reinterpret_as_uint(),
    |     )
    |   }
    |   let new_imports : Array[Import] = []
    |   for i = 0; i < imports.length(); i = i + 1 {
    |     if !duplicate_import_entry[i] {
    |       new_imports.push(imports[i])
    |     }
    |   }
    |   let new_mod = mod.with_import_sec(ImportSec::new(new_imports))
    |   die_remap_func_indices(new_mod, remap)
    | }
    …

73 uncovered line(s) in src/passes/global_refining.mbt:

    | fn gr_count_imported_globals(mod : Module) -> UInt {
    |   let mut n : UInt = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
  6 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match import_ {
    |           Import(_, _, GlobalExternType(_)) => n += 1
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   n
    | }
    …

    | fn gr_count_imported_funcs(mod : Module) -> UInt {
    |   let mut n : UInt = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 22 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match import_ {
    |           Import(_, _, FuncExternType(_)) => n += 1
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   n
    | }
    …

    | fn gr_collect_exported_globals(mod : Module) -> Set[GlobalIdx] {
    |   let out : Set[GlobalIdx] = Set::new()
    |   match mod.export_sec {
    |     Some(ExportSec(exports)) =>
    |       for export_ in exports {
    |         match export_ {
    |           Export(_, GlobalExternIdx(idx)) => out.add(idx)
 41 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   out
    | }
    …

    | fn gr_collect_func_type_idx_by_func(mod : Module) -> Map[FuncIdx, TypeIdx] {
    |   let out : Map[FuncIdx, TypeIdx] = Map::new()
    |   let mut next_idx : UInt = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 55 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match import_ {
    |           Import(_, _, FuncExternType(type_idx)) => {
    |             out[FuncIdx::new(next_idx)] = type_idx
    |             next_idx += 1
    |           }
 61 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for type_idx in type_idxs {
    |         out[FuncIdx::new(next_idx)] = type_idx
    |         next_idx += 1
    |       }
    |     None => ()
    |   }
    |   out
    | }
    …

    | fn gr_is_public_heap_type(ht : HeapType) -> Bool {
    |   match ht {
 80 |     AbsHeapTypeHeapType(_) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     HeapType(TypeIdx(_)) => true
 82 |     HeapType(RecIdx(_)) => false
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     DefTypeHeapType(_) => false
    |   }
    | }
    …

    | fn gr_is_public_ref_type(rt : RefType) -> Bool {
    |   match rt {
 90 |     AbsHeapTypeRefType(_) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     HeapTypeRefType(_, ht) => gr_is_public_heap_type(ht)
    |   }
    | }
    …

    | fn gr_is_public_val_type(vt : ValType) -> Bool {
    |   match vt {
    |     RefTypeValType(rt) => gr_is_public_ref_type(rt)
 99 |     _ => true
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn gr_common_ref_heap_supertype(
    |   a : HeapType,
    |   b : HeapType,
    |   env : Env,
    | ) -> HeapType? {
109 |   fn is_func_heap(ht : HeapType) -> Bool {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match ht {
    |       AbsHeapTypeHeapType(FuncAbsHeapType) => true
    |       HeapType(tidx) =>
113 |         match env.resolve_comptype(tidx) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(FuncCompType(_, _)) => true
    |           _ => false
    |         }
117 |       _ => false
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   if Match::matches(a, b, env) {
122 |     return Some(b)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if Match::matches(b, a, env) {
125 |     return Some(a)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let candidates = [
128 |     AbsHeapType::i31(),
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     AbsHeapType::struct_(),
    |     AbsHeapType::array(),
    |     AbsHeapType::eq(),
    |     AbsHeapType::func(),
    |     AbsHeapType::extern_(),
    |     AbsHeapType::exn(),
    |     AbsHeapType::any(),
    |   ]
    |   for abs in candidates {
138 |     let super_ht = HeapType::abs(abs)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     if Match::matches(a, super_ht, env) && Match::matches(b, super_ht, env) {
140 |       return Some(super_ht)
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   if is_func_heap(a) && is_func_heap(b) {
144 |     return Some(HeapType::abs(AbsHeapType::func()))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   None
    | }
    …

    | fn gr_common_ref_type_supertype(
    |   a : RefType,
    |   b : RefType,
    |   env : Env,
    | ) -> RefType? {
155 |   if Match::matches(a, b, env) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return Some(b)
    |   }
    |   if Match::matches(b, a, env) {
159 |     return Some(a)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match
162 |     gr_common_ref_heap_supertype(a.get_heap_type(), b.get_heap_type(), env) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ht) => Some(RefType::new(a.is_nullable() || b.is_nullable(), ht))
    |     None => None
    |   }
    | }
    …

    | fn gr_common_val_supertype(a : ValType, b : ValType, env : Env) -> ValType? {
    |   if Match::matches(a, b, env) {
    |     return Some(b)
    |   }
    |   if Match::matches(b, a, env) {
174 |     return Some(a)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
176 |   match (a, b) {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (RefTypeValType(r0), RefTypeValType(r1)) =>
178 |       match gr_common_ref_type_supertype(r0, r1, env) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(rt) => Some(ValType::ref_type(rt))
    |         None => None
    |       }
182 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn gr_lub_for_refining(
    |   a : ValType,
    |   b : ValType,
    |   old_type : ValType,
    |   env : Env,
    | ) -> ValType {
    |   match gr_common_val_supertype(a, b, env) {
    |     Some(candidate) =>
    |       if Match::matches(candidate, old_type, env) {
    |         candidate
    |       } else {
198 |         old_type
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
200 |     None => old_type
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn gr_infer_tinstr_type(
    |   instr : TInstr,
    |   env : Env,
    |   func_type_idx_by_func : Map[FuncIdx, TypeIdx],
    | ) -> ValType? {
    |   fn single_result_of_blocktype(bt : BlockType) -> ValType? {
226 |     match env.expand_blocktype(bt) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Ok((_, [vt])) => Some(vt)
    |       _ => None
    |     }
    |   }
    | 
    |   fn infer_texpr_type(texpr : TExpr) -> ValType? {
233 |     let TExpr(instrs) = texpr
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     if instrs.is_empty() {
235 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     } else {
237 |       gr_infer_tinstr_type(
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         instrs[instrs.length() - 1],
    |         env,
    |         func_type_idx_by_func,
    |       )
    |     }
    |   }
    | 
    |   match instr {
246 |     TI32Const(_) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TI64Const(_) => Some(ValType::i64())
    |     TF32Const(_) => Some(ValType::f32())
    |     TF64Const(_) => Some(ValType::f64())
    |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
251 |       Some(ValType::v128())
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
    |     TRefFunc(fi) =>
    |       match func_type_idx_by_func.get(fi) {
    |         Some(type_idx) =>
    |           Some(ValType::ref_type(RefType::new(false, HeapType::new(type_idx))))
257 |         None => Some(ValType::ref_type(RefType::abs(AbsHeapType::func())))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TLocalGet(idx) => env.get_local_type(idx)
    |     TGlobalGet(idx) =>
261 |       match env.get_global_type(idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(GlobalType(vt, _)) => Some(vt)
    |         None => None
    |       }
    |     TLocalTee(_, value) =>
266 |       gr_infer_tinstr_type(value, env, func_type_idx_by_func)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TRefAsNonNull(value) =>
268 |       match gr_infer_tinstr_type(value, env, func_type_idx_by_func) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(RefTypeValType(rt)) =>
270 |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ => None
    |       }
    |     TRefCast(nullable, ht, _) =>
274 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TStructNew(type_idx, _)
    |     | TStructNewDefault(type_idx)
    |     | TArrayNew(type_idx, _, _)
    |     | TArrayNewDefault(type_idx, _)
    |     | TArrayNewFixed(type_idx, _)
    |     | TArrayNewData(type_idx, _, _, _)
    |     | TArrayNewElem(type_idx, _, _, _) =>
    |       Some(ValType::ref_type(RefType::new(false, HeapType::new(type_idx))))
    |     TStructGet(type_idx, field_idx, _)
    |     | TStructGetS(type_idx, field_idx, _)
    |     | TStructGetU(type_idx, field_idx, _) =>
286 |       match env.resolve_struct_fields(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(fields) =>
288 |           match field_idx {
    |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             U32(raw_idx) =>
290 |               match fields.get(raw_idx.reinterpret_as_int()) {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Some(field_ty) => Some(field_ty.unpack())
    |                 None => None
    |               }
    |           }
295 |         Err(_) => None
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TArrayGet(type_idx, _, _)
    |     | TArrayGetS(type_idx, _, _)
    |     | TArrayGetU(type_idx, _, _) =>
300 |       match env.resolve_array_field(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(field_ty) => Some(field_ty.unpack())
    |         Err(_) => None
    |       }
    |     TSelect(types, _, if_true, if_false) => {
    |       let from_decl = match types {
    |         Some(vts) if vts.length() == 1 => Some(vts[0])
307 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let from_branches = match
    |         (
    |           gr_infer_tinstr_type(if_true, env, func_type_idx_by_func),
    |           gr_infer_tinstr_type(if_false, env, func_type_idx_by_func),
    |         ) {
    |         (Some(t), Some(f)) => gr_common_val_supertype(t, f, env)
315 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       match (from_branches, from_decl) {
    |         (Some(t), Some(vt)) =>
    |           if Match::matches(t, vt, env) {
    |             Some(t)
    |           } else {
322 |             Some(vt)
    |             ^^^^^^^^ 	<-- UNCOVERED
    |           }
324 |         (Some(t), None) => Some(t)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (None, Some(vt)) => Some(vt)
    |         _ => None
    |       }
    |     }
    |     TCall(target, _) =>
330 |       match env.get_functype_by_funcidx(target) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(FuncType(_, [r])) => Some(r)
    |         _ => None
    |       }
    |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
335 |       match env.resolve_functype(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(FuncType(_, [r])) => Some(r)
    |         _ => None
    |       }
339 |     TBlock(bt, body) | TLoop(bt, body) | TTryTable(bt, _, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let from_body = infer_texpr_type(body)
    |       let from_bt = single_result_of_blocktype(bt)
    |       match (from_body, from_bt) {
    |         (Some(t), Some(vt)) =>
344 |           if Match::matches(t, vt, env) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(t)
    |           } else {
347 |             Some(vt)
    |             ^^^^^^^^ 	<-- UNCOVERED
    |           }
349 |         (Some(t), None) => Some(t)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (None, Some(vt)) => Some(vt)
    |         _ => None
    |       }
    |     }
354 |     TIf(bt, _, then_, else_) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let from_bt = single_result_of_blocktype(bt)
    |       let from_branches = match else_ {
    |         Some(else_expr) =>
358 |           match (infer_texpr_type(then_), infer_texpr_type(else_expr)) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             (Some(t), Some(e)) => gr_common_val_supertype(t, e, env)
    |             _ => None
    |           }
362 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
364 |       match (from_branches, from_bt) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (Some(t), Some(vt)) =>
366 |           if Match::matches(t, vt, env) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(t)
    |           } else {
369 |             Some(vt)
    |             ^^^^^^^^ 	<-- UNCOVERED
    |           }
371 |         (Some(t), None) => Some(t)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (None, Some(vt)) => Some(vt)
    |         _ => None
    |       }
    |     }
376 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn gr_infer_expr_type(
    |   expr : Expr,
    |   env : Env,
    |   func_type_idx_by_func : Map[FuncIdx, TypeIdx],
    | ) -> ValType? {
    |   match to_texpr(expr, env) {
    |     Ok(TExpr(instrs)) if !instrs.is_empty() =>
    |       gr_infer_tinstr_type(
    |         instrs[instrs.length() - 1],
    |         env,
    |         func_type_idx_by_func,
    |       )
393 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn global_refining(mod : Module) -> Result[Module, String] {
    |   let globals = match mod.global_sec {
    |     Some(GlobalSec(globals)) => globals
401 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if globals.is_empty() {
404 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let env = Env::new().with_module(mod)
    |   let imported_globals = gr_count_imported_globals(mod)
    |   let imported_funcs = gr_count_imported_funcs(mod)
    |   let exported_globals = gr_collect_exported_globals(mod)
    |   let func_type_idx_by_func = gr_collect_func_type_idx_by_func(mod)
    |   let optimizable : Set[GlobalIdx] = Set::new()
    |   for i = 0; i < globals.length(); i = i + 1 {
    |     let idx = GlobalIdx::new(imported_globals + i.reinterpret_as_uint())
    |     let Global(GlobalType(_, is_mut), _) = globals[i]
    |     if exported_globals.contains(idx) && is_mut {
    |       continue
    |     }
    |     optimizable.add(idx)
    |   }
    |   let candidates : Map[GlobalIdx, ValType] = Map::new()
    |   let set_walker = ModuleTransformer::new().on_tinstruction_evt(fn(
    |     self,
    |     env : Env,
    |     instr,
    |   ) {
    |     match instr {
    |       TGlobalSet(idx, value) =>
    |         if optimizable.contains(idx) {
    |           match env.get_global_type(idx) {
    |             Some(GlobalType(old_type, _)) => {
    |               let observed = match
    |                 gr_infer_tinstr_type(value, env, func_type_idx_by_func) {
    |                 Some(vt) if Match::matches(vt, old_type, env) => vt
434 |                 _ => old_type
    |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |               gr_note_observed_type(candidates, idx, observed, old_type, env)
    |             }
438 |             None => ()
    |             ^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default(env, instr)
    |   })
    |   match mod.code_sec {
    |     Some(CodeSec(funcs)) =>
    |       for i, func in funcs {
    |         let func_idx = FuncIdx::new(imported_funcs + i.reinterpret_as_uint())
    |         match func {
    |           TFunc(locals, body) => {
    |             let func_params = match env.get_functype_by_funcidx(func_idx) {
    |               Some(FuncType(params, _)) => params
453 |               None => []
    |               ^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |             let all_locals = func_params.copy()
    |             all_locals.append(locals)
    |             let local_env = env.with_locals(all_locals)
    |             ignore(set_walker.walk_texpr(local_env, body))
    |           }
460 |           Func(_, _) => return Err("global_refining: expected TFunc")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   for i = 0; i < globals.length(); i = i + 1 {
    |     let idx = GlobalIdx::new(imported_globals + i.reinterpret_as_uint())
    |     if !optimizable.contains(idx) {
    |       continue
    |     }
    |     let Global(GlobalType(old_type, _), init) = globals[i]
    |     let observed = match gr_infer_expr_type(init, env, func_type_idx_by_func) {
    |       Some(vt) if Match::matches(vt, old_type, env) => vt
473 |       _ => old_type
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     gr_note_observed_type(candidates, idx, observed, old_type, env)
    |   }
    |   let new_globals = globals.copy()
    |   let mut optimized = false
    |   for i = 0; i < new_globals.length(); i = i + 1 {
    |     let idx = GlobalIdx::new(imported_globals + i.reinterpret_as_uint())
    |     if !optimizable.contains(idx) {
    |       continue
    |     }
    |     match candidates.get(idx) {
    |       Some(new_type) => {
    |         let Global(GlobalType(old_type, is_mut), init) = new_globals[i]
    |         if new_type == old_type || !Match::matches(new_type, old_type, env) {
488 |           continue
    |           ^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         if exported_globals.contains(idx) && !gr_is_public_val_type(new_type) {
491 |           continue
    |           ^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         new_globals[i] = Global::new(GlobalType::new(new_type, is_mut), init)
    |         optimized = true
    |       }
496 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   if optimized {
    |     Ok(mod.with_global_sec(GlobalSec::new(new_globals)))
    |   } else {
    |     Ok(mod)
    |   }
    | }
    …

97 uncovered line(s) in src/passes/global_struct_inference.mbt:

     | fn gsi_count_imported_globals(mod : Module) -> UInt {
     |   let mut n : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  40 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(_)) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn gsi_collect_all_type_indices(mod : Module) -> Array[TypeIdx] {
     |   let out : Array[TypeIdx] = []
     |   let mut next : UInt = 0
     |   match mod.type_sec {
     |     Some(TypeSec(rec_types)) =>
     |       for rec_type in rec_types {
     |         match rec_type {
     |           SingleRecType(_) => {
     |             out.push(TypeIdx::new(next))
     |             next += 1
     |           }
     |           GroupRecType(sts) =>
  64 |             for _ in sts {
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               out.push(TypeIdx::new(next))
     |               next += 1
     |             }
     |         }
     |       }
  70 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn gsi_single_root_init(init : Expr, env : Env) -> TInstr? {
     |   match to_texpr(init, env) {
     |     Ok(TExpr([root])) => Some(root)
 106 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_global_root_type(root : TInstr) -> TypeIdx? {
     |   match root {
     |     TStructNew(type_idx, _) | TStructNewDefault(type_idx) => Some(type_idx)
 114 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_global_root_init_info(root : TInstr) -> GSIGlobalInit? {
     |   match root {
     |     TStructNew(_, operands) => Some(GSIInitNew(operands))
     |     TStructNewDefault(_) => Some(GSIInitDefault)
 123 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_add_unique_global(globals : Array[GlobalIdx], idx : GlobalIdx) -> Unit {
     |   for old in globals {
     |     if old == idx {
 136 |       return
     |       ^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   globals.push(idx)
     | }
     …

     | fn gsi_get_super_types(env : Env, type_idx : TypeIdx) -> Array[TypeIdx] {
     |   match env.resolve_subtype(type_idx) {
     |     Some(st) => st.super_types()
 158 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_propagate_globals_to_supers(
     |   type_globals : Map[TypeIdx, Array[GlobalIdx]],
     |   unoptimizable : Set[TypeIdx],
     |   env : Env,
     |   all_types : Array[TypeIdx],
     | ) -> Unit {
     |   let snapshot : Array[(TypeIdx, Array[GlobalIdx])] = []
     |   for type_idx in all_types {
     |     match type_globals.get(type_idx) {
     |       Some(globals) => snapshot.push((type_idx, globals.copy()))
     |       None => ()
     |     }
     |   }
     |   for item in snapshot {
     |     let (type_idx, globals) = item
     |     let queue : Array[TypeIdx] = gsi_get_super_types(env, type_idx).copy()
     |     let seen : Set[TypeIdx] = Set::new()
     |     let mut i = 0
     |     while i < queue.length() {
     |       let curr = queue[i]
     |       i += 1
     |       if seen.contains(curr) {
 207 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       seen.add(curr)
     |       if !unoptimizable.contains(curr) {
     |         for global_idx in globals {
     |           gsi_add_type_global(type_globals, curr, global_idx)
     |         }
     |       }
     |       for super_type in gsi_get_super_types(env, curr) {
 216 |         queue.push(super_type)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | }
     …

     | fn gsi_collect_types_with_strict_subtypes(
     |   env : Env,
     |   all_types : Array[TypeIdx],
     | ) -> Set[TypeIdx] {
     |   let out : Set[TypeIdx] = Set::new()
     |   for type_idx in all_types {
     |     let queue : Array[TypeIdx] = gsi_get_super_types(env, type_idx).copy()
     |     let seen : Set[TypeIdx] = Set::new()
     |     let mut i = 0
     |     while i < queue.length() {
     |       let curr = queue[i]
     |       i += 1
     |       if seen.contains(curr) {
 236 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       seen.add(curr)
     |       out.add(curr)
     |       for super_type in gsi_get_super_types(env, curr) {
 241 |         queue.push(super_type)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn gsi_is_global_immutable(env : Env, idx : GlobalIdx) -> Bool {
     |   match env.get_global_type(idx) {
     |     Some(GlobalType(_, is_mut)) => !is_mut
 252 |     None => false
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_is_literal_const(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => true
 260 |     TRefNull(_) | TRefFunc(_) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
     |     _ => false
     |   }
     | }
     …

     | fn gsi_default_for_val_type(vt : ValType) -> TInstr? {
 268 |   match vt {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     NumTypeValType(I32NumType) => Some(TInstr::i32_const(I32(0)))
     |     NumTypeValType(I64NumType) => Some(TInstr::i64_const(I64(0L)))
     |     NumTypeValType(F32NumType) => Some(TInstr::f32_const(F32(0.0)))
     |     NumTypeValType(F64NumType) => Some(TInstr::f64_const(F64(0.0)))
     |     RefTypeValType(rt) =>
 274 |       if rt.is_nullable() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(TInstr::ref_null(rt.get_heap_type()))
     |       } else {
 277 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
 279 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_default_for_storage_type(st : StorageType) -> TInstr? {
     |   match st {
 286 |     ValTypeStorageType(vt) => gsi_default_for_val_type(vt)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PackTypeStorageType(_) => Some(TInstr::i32_const(I32(0)))
     |   }
     | }
     …

     | fn gsi_struct_field(
     |   env : Env,
     |   type_idx : TypeIdx,
     |   field_idx : @lib.U32,
     | ) -> FieldType? {
     |   let @lib.U32(iu) = field_idx
     |   let i = iu.reinterpret_as_int()
     |   if i < 0 {
 300 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match env.resolve_struct_fields(type_idx) {
     |     Ok(fields) => fields.get(i)
 304 |     Err(_) => None
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_result_type_for_get(field : FieldType, kind : GSIGetKind) -> ValType? {
     |   let FieldType(storage, _) = field
     |   match kind {
     |     NormalGet =>
     |       match storage {
     |         ValTypeStorageType(vt) => Some(vt)
 315 |         PackTypeStorageType(_) => None
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     SignedGet | UnsignedGet =>
     |       match storage {
     |         PackTypeStorageType(_) => Some(ValType::i32())
 320 |         ValTypeStorageType(_) => None
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn gsi_apply_packed_get(
     |   value : TInstr,
     |   pack : @lib.PackType,
     |   kind : GSIGetKind,
     | ) -> TInstr {
     |   let (mask, shift) = match pack {
     |     I8PackType => (0xFF, 24)
 333 |     I16PackType => (0xFFFF, 16)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match kind {
     |     UnsignedGet =>
     |       TInstr::binary(BinaryOp::i32_and(), value, TInstr::i32_const(I32(mask)))
 338 |     SignedGet => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shl = TInstr::binary(
     |         BinaryOp::i32_shl(),
     |         value,
 342 |         TInstr::i32_const(I32(shift)),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
 344 |       TInstr::binary(BinaryOp::i32_shr_s(), shl, TInstr::i32_const(I32(shift)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 346 |     NormalGet => value
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_emit_global_field_read(
     |   type_idx : TypeIdx,
     |   field_idx : @lib.U32,
     |   kind : GSIGetKind,
     |   global_idx : GlobalIdx,
     | ) -> TInstr {
     |   let ref_ = TInstr::global_get(global_idx)
     |   match kind {
     |     NormalGet => TInstr::struct_get(type_idx, field_idx, ref_)
 360 |     SignedGet => TInstr::struct_get_s(type_idx, field_idx, ref_)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     UnsignedGet => TInstr::struct_get_u(type_idx, field_idx, ref_)
     |   }
     | }
     …

     | fn gsi_normalize_global_field_value(
     |   raw : TInstr,
     |   field : FieldType,
     |   kind : GSIGetKind,
     |   env : Env,
     | ) -> TInstr? {
     |   let normalized_raw = match raw {
 373 |     TGlobalGet(idx) if gsi_is_global_immutable(env, idx) => Some(raw)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ if gsi_is_literal_const(raw) => Some(raw)
     |     _ => None
     |   }
     |   match normalized_raw {
     |     Some(base) => {
     |       let FieldType(storage, _) = field
     |       match (storage, kind) {
     |         (ValTypeStorageType(_), NormalGet) => Some(base)
     |         (PackTypeStorageType(pack), SignedGet)
     |         | (PackTypeStorageType(pack), UnsignedGet) =>
     |           Some(gsi_apply_packed_get(base, pack, kind))
 385 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     None => None
     |   }
     | }
     …

     | fn gsi_read_value_from_global(
     |   global_idx : GlobalIdx,
     |   field : FieldType,
     |   field_idx : @lib.U32,
     |   kind : GSIGetKind,
     |   analysis : GSIAnalysis,
     |   env : Env,
     | ) -> GSIReadValue? {
     |   let @lib.U32(field_idx_u) = field_idx
     |   let raw = match analysis.global_inits.get(global_idx) {
     |     Some(GSIInitNew(operands)) => operands.get(field_idx_u.reinterpret_as_int())
     |     Some(GSIInitDefault) =>
     |       match field {
     |         FieldType(storage, _) => gsi_default_for_storage_type(storage)
     |       }
 408 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match raw {
     |     Some(v) =>
     |       match gsi_normalize_global_field_value(v, field, kind, env) {
     |         Some(normalized) => Some(GSIConstValue(normalized))
     |         None => Some(GSIValueFromGlobal(global_idx))
     |       }
 416 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_read_values_equal(a : GSIReadValue, b : GSIReadValue) -> Bool {
     |   match (a, b) {
     |     (GSIConstValue(v0), GSIConstValue(v1)) => v0 == v1
     |     (GSIValueFromGlobal(g0), GSIValueFromGlobal(g1)) => g0 == g1
 457 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_collect_values_for_globals(
     |   globals : Array[GlobalIdx],
     |   field : FieldType,
     |   field_idx : @lib.U32,
     |   kind : GSIGetKind,
     |   analysis : GSIAnalysis,
     |   env : Env,
     | ) -> (Array[GSIReadValue], Array[Array[GlobalIdx]])? {
     |   let values : Array[GSIReadValue] = []
     |   let groups : Array[Array[GlobalIdx]] = []
     |   for global_idx in globals {
     |     let value = match
     |       gsi_read_value_from_global(
     |         global_idx, field, field_idx, kind, analysis, env,
     |       ) {
     |       Some(v) => v
 478 |       None => return None
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let mut grouped = false
     |     for i = 0; i < values.length(); i = i + 1 {
     |       if gsi_read_values_equal(values[i], value) {
     |         groups[i].push(global_idx)
     |         grouped = true
     |         break
     |       }
     |     }
     |     if !grouped {
     |       values.push(value)
     |       groups.push([global_idx])
     |       if values.length() > 2 {
     |         return None
     |       }
     |     }
     |   }
     |   Some((values, groups))
     | }
     …

     | fn gsi_ref_nullability(instr : TInstr, env : Env) -> Bool? {
     |   match instr {
     |     TLocalGet(idx) =>
     |       match env.get_local_type(idx) {
     |         Some(RefTypeValType(rt)) => Some(rt.is_nullable())
 505 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TGlobalGet(idx) =>
     |       match env.get_global_type(idx) {
     |         Some(GlobalType(RefTypeValType(rt), _)) => Some(rt.is_nullable())
 510 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
 512 |     TRefNull(_) => Some(true)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefFunc(_) => Some(false)
     |     TRefAsNonNull(_) => Some(false)
     |     TRefCast(nullable, _, _) => Some(nullable)
     |     TRefCastDescEq(nullable, _, _) => Some(nullable)
     |     TStructNew(_, _) | TStructNewDefault(_) => Some(false)
     |     TSelect(Some([RefTypeValType(rt)]), _, _, _) => Some(rt.is_nullable())
     |     TBlock(bt, _) | TLoop(bt, _) | TIf(bt, _, _, _) | TTryTable(bt, _, _) =>
 520 |       match env.expand_blocktype(bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok((_, [RefTypeValType(rt)])) => Some(rt.is_nullable())
     |         _ => None
     |       }
     |     TCall(func_idx, _) =>
 525 |       match env.get_functype_by_funcidx(func_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [RefTypeValType(rt)])) => Some(rt.is_nullable())
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 530 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [RefTypeValType(rt)])) => Some(rt.is_nullable())
     |         _ => None
     |       }
 534 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_ref_heap_type(instr : TInstr, env : Env) -> HeapType? {
     |   match instr {
     |     TLocalGet(idx) =>
     |       match env.get_local_type(idx) {
     |         Some(RefTypeValType(rt)) => Some(rt.get_heap_type())
 544 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TGlobalGet(idx) =>
 547 |       match env.get_global_type(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(GlobalType(RefTypeValType(rt), _)) => Some(rt.get_heap_type())
     |         _ => None
     |       }
 551 |     TRefNull(ht) => Some(ht)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefFunc(_) => Some(HeapType::abs(AbsHeapType::func()))
     |     TRefAsNonNull(value) =>
 554 |       match gsi_ref_heap_type(value, env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(ht) => Some(ht)
     |         None => None
     |       }
 558 |     TRefCast(_, ht, _) | TRefCastDescEq(_, ht, _) => Some(ht)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructNew(type_idx, _) | TStructNewDefault(type_idx) =>
 560 |       Some(HeapType::new(type_idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(Some([RefTypeValType(rt)]), _, _, _) => Some(rt.get_heap_type())
     |     TBlock(bt, _) | TLoop(bt, _) | TIf(bt, _, _, _) | TTryTable(bt, _, _) =>
 563 |       match env.expand_blocktype(bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok((_, [RefTypeValType(rt)])) => Some(rt.get_heap_type())
     |         _ => None
     |       }
     |     TCall(func_idx, _) =>
 568 |       match env.get_functype_by_funcidx(func_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [RefTypeValType(rt)])) => Some(rt.get_heap_type())
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 573 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [RefTypeValType(rt)])) => Some(rt.get_heap_type())
     |         _ => None
     |       }
 577 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_ref_with_trap_semantics(ref_ : TInstr, env : Env) -> TInstr? {
     |   match gsi_ref_nullability(ref_, env) {
     |     Some(true) => Some(TInstr::ref_as_non_null(ref_))
     |     Some(false) => Some(ref_)
 586 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gsi_select_for_two_values(
     |   values : Array[TInstr],
     |   groups : Array[Array[GlobalIdx]],
     |   result_vt : ValType,
     |   ref_ : TInstr,
     |   env : Env,
     | ) -> TInstr? {
     |   if values.length() != 2 || groups.length() != 2 {
 599 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut single_idx = -1
     |   if groups[0].length() == 1 {
     |     single_idx = 0
     |   } else if groups[1].length() == 1 {
     |     single_idx = 1
     |   } else {
 607 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let other_idx = if single_idx == 0 { 1 } else { 0 }
     |   let check_global = groups[single_idx][0]
     |   let checked_ref = match gsi_ref_with_trap_semantics(ref_, env) {
     |     Some(v) => v
 613 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let cond = TInstr::ref_eq(checked_ref, TInstr::global_get(check_global))
     |   Some(
     |     TInstr::select(
     |       Some([result_vt]),
     |       cond,
     |       values[single_idx],
     |       values[other_idx],
     |     ),
     |   )
     | }
     …

     | fn gsi_desc_expr_from_global(global_idx : GlobalIdx, env : Env) -> TInstr? {
     |   let checked_ref = match
     |     gsi_ref_with_trap_semantics(TInstr::global_get(global_idx), env) {
     |     Some(v) => v
 631 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Some(TInstr::ref_get_desc(checked_ref))
     | }
     …

     | fn gsi_collect_desc_values_for_globals(
     |   globals : Array[GlobalIdx],
     |   analysis : GSIAnalysis,
     |   env : Env,
     | ) -> (Array[TInstr], Array[Array[GlobalIdx]])? {
     |   let root_types : Array[TypeIdx] = []
     |   let values : Array[TInstr] = []
     |   let groups : Array[Array[GlobalIdx]] = []
     |   for global_idx in globals {
     |     let root_type = match analysis.global_root_types.get(global_idx) {
     |       Some(t) => t
 648 |       None => return None
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let mut grouped = false
     |     for i = 0; i < root_types.length(); i = i + 1 {
     |       if root_types[i] == root_type {
 653 |         groups[i].push(global_idx)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         grouped = true
     |         break
     |       }
     |     }
     |     if !grouped {
     |       let value = match gsi_desc_expr_from_global(global_idx, env) {
     |         Some(v) => v
 661 |         None => return None
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       root_types.push(root_type)
     |       values.push(value)
     |       groups.push([global_idx])
     |       if values.length() > 2 {
 667 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   Some((values, groups))
     | }
     …

     | fn gsi_candidate_globals_for_ref(
     |   ref_ : TInstr,
     |   state : GSIRewriteState,
     | ) -> Array[GlobalIdx]? {
     |   match ref_ {
     |     TGlobalGet(global_idx) =>
 681 |       if gsi_is_global_immutable(state.env, global_idx) &&
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         state.analysis.global_root_types.get(global_idx) is Some(_) {
 683 |         Some([global_idx])
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 685 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     _ =>
     |       match gsi_ref_heap_type(ref_, state.env) {
     |         Some(HeapType(type_idx)) =>
     |           match state.analysis.type_globals.get(type_idx) {
     |             Some(globals) if !globals.is_empty() => Some(globals)
 692 |             _ => None
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
 694 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn gsi_drop_and_value(ref_ : TInstr, value : TInstr, env : Env) -> TInstr? {
     |   let checked_ref = match gsi_ref_with_trap_semantics(ref_, env) {
     |     Some(v) => v
 703 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   TInstr::block(
     |     BlockType::void_(),
     |     TExpr::new([TInstr::drop(checked_ref), value]),
     |   )
     |   |> Some
     | }
     …

     | fn gsi_optimize_struct_get(
     |   type_idx : TypeIdx,
     |   field_idx : @lib.U32,
     |   ref_ : TInstr,
     |   kind : GSIGetKind,
     |   state : GSIRewriteState,
     | ) -> TInstr? {
     |   let field = match gsi_struct_field(state.env, type_idx, field_idx) {
     |     Some(field) => field
 722 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FieldType(_, mutability) = field
     |   if mutability == Var {
     |     return None
     |   }
     |   let result_vt = match gsi_result_type_for_get(field, kind) {
     |     Some(vt) => vt
 730 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Trivial direct-global case.
     |   match ref_ {
     |     TGlobalGet(global_idx) if gsi_is_global_immutable(state.env, global_idx) =>
     |       match
     |         gsi_read_const_value_from_global(
     |           global_idx,
     |           field,
     |           field_idx,
     |           kind,
     |           state.analysis,
     |           state.env,
     |         ) {
     |         Some(value) => return Some(value)
     |         None => ()
     |       }
     |     _ => ()
     |   }
     |   let globals = match state.analysis.type_globals.get(type_idx) {
     |     Some(globals) if !globals.is_empty() => globals
     |     _ => return None
     |   }
     |   if globals.length() == 1 {
     |     let value = match
     |       gsi_read_value_from_global(
     |         globals[0],
     |         field,
     |         field_idx,
     |         kind,
     |         state.analysis,
     |         state.env,
     |       ) {
     |       Some(value) => value
 765 |       None => return None
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match ref_ {
     |       TGlobalGet(ref_global) =>
     |         match value {
     |           GSIValueFromGlobal(value_global) =>
     |             if ref_global == value_global {
     |               return None
     |             } else {
 774 |               ()
     |               ^^ 	<-- UNCOVERED
     |             }
 776 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |     return gsi_drop_and_value(
     |       ref_,
     |       gsi_emit_read_value(value, type_idx, field_idx, kind),
     |       state.env,
     |     )
     |   }
     |   let (values, groups) = match
     |     gsi_collect_values_for_globals(
     |       globals,
     |       field,
     |       field_idx,
     |       kind,
     |       state.analysis,
     |       state.env,
     |     ) {
     |     Some(pair) => pair
     |     None => return None
     |   }
     |   let materialized_values : Array[TInstr] = []
     |   for value in values {
     |     materialized_values.push(
     |       gsi_emit_read_value(value, type_idx, field_idx, kind),
     |     )
     |   }
     |   if materialized_values.length() == 1 {
 805 |     return gsi_drop_and_value(ref_, materialized_values[0], state.env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   gsi_select_for_two_values(
     |     materialized_values,
     |     groups,
     |     result_vt,
     |     ref_,
     |     state.env,
     |   )
     | }
     …

     | fn gsi_optimize_ref_cast_desc_mode(
     |   nullable : Bool,
     |   target_ht : HeapType,
     |   ref_ : TInstr,
     |   state : GSIRewriteState,
     | ) -> TInstr? {
     |   if !state.optimize_to_desc_casts {
 824 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let target_type_idx = match target_ht {
     |     HeapType(type_idx) => type_idx
 828 |     _ => return None
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if state.analysis.types_with_strict_subtypes.contains(target_type_idx) {
     |     return None
     |   }
     |   let globals = match state.analysis.type_globals.get(target_type_idx) {
     |     Some(globals) if globals.length() == 1 => globals
 835 |     _ => return None
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   ignore(globals)
     |   Some(TInstr::ref_cast_desc_eq(nullable, target_ht, ref_))
     | }
     …

     | fn gsi_optimize_ref_get_desc(ref_ : TInstr, state : GSIRewriteState) -> TInstr? {
     |   if !state.optimize_to_desc_casts {
 844 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let globals = match gsi_candidate_globals_for_ref(ref_, state) {
     |     Some(gs) if !gs.is_empty() => gs
 848 |     _ => return None
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if globals.length() == 1 {
     |     match ref_ {
 852 |       TGlobalGet(curr) if curr == globals[0] => return None
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |   }
     |   let (values, groups) = match
     |     gsi_collect_desc_values_for_globals(globals, state.analysis, state.env) {
     |     Some(pair) => pair
 859 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if values.length() == 1 {
     |     return gsi_drop_and_value(ref_, values[0], state.env)
     |   }
     |   gsi_select_for_two_values(
     |     values,
     |     groups,
     |     state.env.descriptor_result_type(),
     |     ref_,
     |     state.env,
     |   )
     | }
     …

     | fn gsi_optimize_tinstruction(instr : TInstr, state : GSIRewriteState) -> TInstr {
     |   match instr {
     |     TStructGet(type_idx, field_idx, ref_) =>
     |       match
     |         gsi_optimize_struct_get(type_idx, field_idx, ref_, NormalGet, state) {
     |         Some(new_instr) => new_instr
     |         None => instr
     |       }
     |     TStructGetS(type_idx, field_idx, ref_) =>
 883 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         gsi_optimize_struct_get(type_idx, field_idx, ref_, SignedGet, state) {
     |         Some(new_instr) => new_instr
     |         None => instr
     |       }
     |     TStructGetU(type_idx, field_idx, ref_) =>
     |       match
     |         gsi_optimize_struct_get(type_idx, field_idx, ref_, UnsignedGet, state) {
     |         Some(new_instr) => new_instr
 892 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefCast(nullable, target_ht, ref_) =>
     |       match gsi_optimize_ref_cast_desc_mode(nullable, target_ht, ref_, state) {
     |         Some(new_instr) => new_instr
     |         None => instr
     |       }
     |     TRefGetDesc(ref_) =>
     |       match gsi_optimize_ref_get_desc(ref_, state) {
     |         Some(new_instr) => new_instr
 902 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => instr
     |   }
     | }
     …

     | fn gsi_rewrite_func(
     |   transformer : ModuleTransformer[GSIRewriteState],
     |   state : GSIRewriteState,
     |   func : Func,
     | ) -> TransformerResult[GSIRewriteState, Func] {
     |   match func {
 915 |     Func(_, _) => unchanged()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(locals, body) => {
     |       let local_state = GSIRewriteState::{
     |         ..state,
     |         env: state.env.with_locals(locals),
     |       }
     |       match transformer.walk_texpr(local_state, body) {
     |         Ok(Some((_, new_body))) =>
     |           if new_body != body {
     |             change(state, Func::t_func(locals, new_body))
     |           } else {
     |             unchanged()
     |           }
 928 |         Ok(None) => unchanged()
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |       }
     |     }
     |   }
     | }
     …

     | fn gsi_rewrite_tinstruction(
     |   transformer : ModuleTransformer[GSIRewriteState],
     |   state : GSIRewriteState,
     |   instr : TInstr,
     | ) -> TransformerResult[GSIRewriteState, TInstr] {
     |   let walked = match transformer.walk_tinstruction_default(state, instr) {
     |     Ok(Some((next_state, next_instr))) => {
     |       let optimized_instr = gsi_optimize_tinstruction(next_instr, next_state)
     |       if optimized_instr != instr {
     |         return change(next_state, optimized_instr)
     |       }
     |       return if next_instr != instr {
 948 |         change(next_state, next_instr)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         unchanged()
     |       }
     |     }
     |     Ok(None) => instr
 954 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let optimized_instr = gsi_optimize_tinstruction(walked, state)
     |   if optimized_instr != instr {
 958 |     change(state, optimized_instr)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     unchanged()
     |   }
     | }
     …

     | fn analyze_global_struct_inference(mod : Module) -> Result[GSIAnalysis, String] {
     |   let env = Env::new().with_module(mod)
     |   let created_in_funcs : Set[TypeIdx] = Set::new()
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for func in funcs {
     |         match func {
     |           TFunc(_, body) =>
     |             gsi_collect_struct_types_in_texpr(body, created_in_funcs)
 974 |           Func(_, _) => return Err("global_struct_inference: expected TFunc")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 977 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let unoptimizable : Set[TypeIdx] = created_in_funcs.copy()
     |   let type_globals : Map[TypeIdx, Array[GlobalIdx]] = Map::new()
     |   let global_inits : Map[GlobalIdx, GSIGlobalInit] = Map::new()
     |   let global_root_types : Map[GlobalIdx, TypeIdx] = Map::new()
     |   let imported_globals = gsi_count_imported_globals(mod)
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for i = 0; i < globals.length(); i = i + 1 {
     |         let global_idx = GlobalIdx::new(
     |           imported_globals + i.reinterpret_as_uint(),
     |         )
     |         let Global(GlobalType(vt, is_mut), init) = globals[i]
     |         let root = match gsi_single_root_init(init, env) {
     |           Some(root) => root
 993 |           None => continue
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     | 
     |         // Nested struct.new/default types in global init are unoptimizable.
     |         match root {
     |           TStructNew(_, operands) =>
     |             for operand in operands {
     |               gsi_collect_struct_types_in_tinstr(operand, unoptimizable)
     |             }
     |           TStructNewDefault(_) => ()
1003 |           _ => gsi_collect_struct_types_in_tinstr(root, unoptimizable)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let root_type = match gsi_global_root_type(root) {
     |           Some(type_idx) => type_idx
1007 |           None => continue
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if !gsi_is_eqref_compatible(vt, env) || is_mut {
     |           unoptimizable.add(root_type)
     |           continue
     |         }
     |         gsi_add_type_global(type_globals, root_type, global_idx)
     |         global_root_types[global_idx] = root_type
     |         match gsi_global_root_init_info(root) {
     |           Some(info) => global_inits[global_idx] = info
1017 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1020 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   gsi_propagate_unoptimizable_to_supers(unoptimizable, env)
     |   for type_idx in unoptimizable {
     |     ignore(type_globals.remove(type_idx))
     |   }
     |   let all_types = gsi_collect_all_type_indices(mod)
     |   let types_with_strict_subtypes = gsi_collect_types_with_strict_subtypes(
     |     env, all_types,
     |   )
     |   gsi_propagate_globals_to_supers(type_globals, unoptimizable, env, all_types)
     |   Ok({
     |     type_globals,
     |     global_inits,
     |     global_root_types,
     |     types_with_strict_subtypes,
     |   })
     | }
     …

     | fn run_global_struct_inference(
     |   mod : Module,
     |   optimize_to_desc_casts : Bool,
     | ) -> Result[Module, String] {
     |   let analysis = match analyze_global_struct_inference(mod) {
     |     Ok(analysis) => analysis
1046 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let state = GSIRewriteState::{
     |     env: Env::new().with_module(mod),
     |     analysis,
     |     optimize_to_desc_casts,
     |   }
     |   let pass = ModuleTransformer::new()
     |     .on_func_evt(gsi_rewrite_func)
     |     .on_tinstruction_evt(gsi_rewrite_tinstruction)
     |   match pass.walk_module(state, mod) {
     |     Ok(Some((_, new_mod))) => Ok(new_mod)
1059 |     Ok(None) => Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

201 uncovered line(s) in src/passes/global_type_optimization.mbt:

     | fn gto_typeidx_raw_int(type_idx : TypeIdx) -> Int {
     |   match type_idx {
     |     TypeIdx(i) => i.reinterpret_as_int()
  48 |     RecIdx(i) => i.reinterpret_as_int()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_resolve_type_idx(
     |   type_idx : TypeIdx,
     |   group_start : Int,
     |   total : Int,
     | ) -> Int? {
     |   let idx = match type_idx {
     |     TypeIdx(i) => i.reinterpret_as_int()
  66 |     RecIdx(i) => group_start + i.reinterpret_as_int()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if idx < 0 || idx >= total {
  69 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   } else {
     |     Some(idx)
     |   }
     | }
     …

     | fn gto_flatten_types(type_sec : TypeSec) -> GTOFlatTypes {
     |   let TypeSec(recs) = type_sec
     |   let subtypes : Array[SubType] = []
     |   let group_starts : Array[Int] = []
     |   let mut next = 0
     |   for rec in recs {
     |     match rec {
     |       SingleRecType(st) => {
     |         subtypes.push(st)
     |         group_starts.push(next)
     |         next += 1
     |       }
  88 |       GroupRecType(sts) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let group_start = next
     |         for st in sts {
  91 |           subtypes.push(st)
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           group_starts.push(group_start)
     |           next += 1
     |         }
     |       }
     |     }
     |   }
     |   let struct_fields : Array[Array[FieldType]?] = []
     |   for st in subtypes {
     |     match st.get_comptype() {
     |       StructCompType(fields) => struct_fields.push(Some(fields))
     |       _ => struct_fields.push(None)
     |     }
     |   }
     |   let supers : Array[Array[Int]] = []
     |   for i in 0..<subtypes.length() {
     |     let curr : Array[Int] = []
     |     for super_tidx in subtypes[i].super_types() {
     |       match
     |         gto_resolve_type_idx(super_tidx, group_starts[i], subtypes.length()) {
     |         Some(idx) => curr.push(idx)
 112 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     supers.push(curr)
     |   }
     |   let children : Array[Array[Int]] = []
     |   for _ in 0..<subtypes.length() {
     |     children.push([])
     |   }
     |   for child in 0..<supers.length() {
     |     for super_idx in supers[child] {
     |       if super_idx >= 0 && super_idx < children.length() {
     |         children[super_idx].push(child)
     |       }
     |     }
     |   }
     |   { subtypes, group_starts, struct_fields, supers, children }
     | }
     …

     | fn gto_supertypes_first_order(flat : GTOFlatTypes) -> Array[Int] {
     |   let n = flat.subtypes.length()
     |   let indegree = Array::make(n, 0)
     |   for i in 0..<n {
     |     indegree[i] = flat.supers[i].length()
     |   }
     |   let queue : Array[Int] = []
     |   for i in 0..<n {
     |     if indegree[i] == 0 {
     |       queue.push(i)
     |     }
     |   }
     |   let out : Array[Int] = []
     |   let mut qi = 0
     |   while qi < queue.length() {
     |     let curr = queue[qi]
     |     qi += 1
     |     out.push(curr)
     |     for child in flat.children[curr] {
     |       indegree[child] = indegree[child] - 1
     |       if indegree[child] == 0 {
     |         queue.push(child)
     |       }
     |     }
     |   }
     |   if out.length() < n {
 158 |     for i in 0..<n {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let mut found = false
     |       for seen in out {
 161 |         if seen == i {
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           found = true
     |           break
     |         }
     |       }
     |       if !found {
 167 |         out.push(i)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn gto_rebuild_type_sec(
     |   old_type_sec : TypeSec,
     |   subtypes : Array[SubType],
     | ) -> TypeSec {
     |   let TypeSec(old_recs) = old_type_sec
     |   let new_recs : Array[RecType] = []
     |   let mut cursor = 0
     |   for rec in old_recs {
     |     match rec {
     |       SingleRecType(_) => {
     |         new_recs.push(RecType::new(subtypes[cursor]))
     |         cursor += 1
     |       }
 188 |       GroupRecType(sts) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let next_group : Array[SubType] = []
     |         for _ in 0..<sts.length() {
 191 |           next_group.push(subtypes[cursor])
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           cursor += 1
     |         }
 194 |         new_recs.push(RecType::group(next_group))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   TypeSec::new(new_recs)
     | }
     …

     | fn gto_combine_field_info(
     |   dst : GTOFieldInfo,
     |   src : GTOFieldInfo,
     | ) -> (GTOFieldInfo, Bool) {
     |   let mut out = dst
     |   let mut changed = false
     |   if !out.has_write && src.has_write {
 209 |     out = { ..out, has_write: true }
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     changed = true
     |   }
     |   if !out.has_read && src.has_read {
     |     out = { ..out, has_read: true }
     |     changed = true
     |   }
     |   (out, changed)
     | }
     …

     | fn gto_note_write(
     |   infos : Array[Array[GTOFieldInfo]],
     |   type_idx : TypeIdx,
     |   field_idx : @lib.U32,
     | ) -> Unit {
 246 |   let ti = gto_typeidx_raw_int(type_idx)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if ti < 0 || ti >= infos.length() {
 248 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
 250 |   let fi = gto_u32_to_int(field_idx)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if fi < 0 || fi >= infos[ti].length() {
 252 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   let info = infos[ti][fi]
     |   if !info.has_write {
 256 |     infos[ti][fi] = { ..info, has_write: true }
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_note_read(
     |   infos : Array[Array[GTOFieldInfo]],
     |   type_idx : TypeIdx,
     |   field_idx : @lib.U32,
     | ) -> Unit {
     |   let ti = gto_typeidx_raw_int(type_idx)
     |   if ti < 0 || ti >= infos.length() {
 268 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   let fi = gto_u32_to_int(field_idx)
     |   if fi < 0 || fi >= infos[ti].length() {
 272 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   let info = infos[ti][fi]
     |   if !info.has_read {
     |     infos[ti][fi] = { ..info, has_read: true }
     |   }
     | }
     …

     | fn gto_scan_texpr(texpr : TExpr, infos : Array[Array[GTOFieldInfo]]) -> Unit {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TStructSet(type_idx, field_idx, _, _) =>
 285 |         gto_note_write(infos, type_idx, field_idx)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TStructGet(type_idx, field_idx, _)
     |       | TStructGetS(type_idx, field_idx, _)
     |       | TStructGetU(type_idx, field_idx, _) =>
     |         gto_note_read(infos, type_idx, field_idx)
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), texpr))
     | }
     …

     | fn gto_scan_expr(
     |   expr : Expr,
     |   env : Env,
     |   infos : Array[Array[GTOFieldInfo]],
     | ) -> Unit {
     |   match to_texpr(expr, env) {
     |     Ok(texpr) => gto_scan_texpr(texpr, infos)
 305 |     Err(_) => ()
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_expand_locals(locals : Array[Locals]) -> Array[ValType]? {
 311 |   match expand_locals(locals) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(ls) => Some(ls)
     |     Err(_) => None
     |   }
     | }
     …

     | fn gto_scan_module_uses(
     |   mod : Module,
     |   env : Env,
     |   infos : Array[Array[GTOFieldInfo]],
     | ) -> Unit {
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for func in funcs {
     |         match func {
     |           TFunc(_, body) => gto_scan_texpr(body, infos)
     |           Func(locals, body) =>
 329 |             match gto_expand_locals(locals) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(expanded) => {
     |                 let local_env = env.with_locals(expanded)
     |                 gto_scan_expr(body, local_env, infos)
     |               }
 334 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for global in globals {
     |         let Global(_, init) = global
     |         gto_scan_expr(init, env, infos)
     |       }
     |     None => ()
     |   }
     |   match mod.table_sec {
     |     Some(TableSec(tables)) =>
 350 |       for table in tables {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Table(_, init_expr) = table
     |         match init_expr {
     |           Some(expr) => gto_scan_expr(expr, env, infos)
     |           None => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.elem_sec {
     |     Some(ElemSec(elems)) =>
 361 |       for elem in elems {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Elem(mode, kind) = elem
     |         match mode {
     |           Active(_, offset) => gto_scan_expr(offset, env, infos)
     |           _ => ()
     |         }
 367 |         match kind {
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           FuncExprsElemKind(exprs) | TypedExprsElemKind(_, exprs) =>
 369 |             for expr in exprs {
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               gto_scan_expr(expr, env, infos)
     |             }
 372 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.data_sec {
     |     Some(DataSec(datas)) =>
 379 |       for data in datas {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Data(mode, _) = data
     |         match mode {
     |           Active(_, offset) => gto_scan_expr(offset, env, infos)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     | }
     …

     | fn gto_propagate_to_super_and_subs(
     |   infos : Array[Array[GTOFieldInfo]],
     |   flat : GTOFlatTypes,
     | ) -> Unit {
     |   let mut changed = true
     |   while changed {
     |     changed = false
     |     for child in 0..<flat.supers.length() {
     |       for super_idx in flat.supers[child] {
     |         if super_idx < 0 || super_idx >= infos.length() {
 401 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if gto_combine_field_info_vec(infos[super_idx], infos[child]) {
 404 |           changed = true
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if gto_combine_field_info_vec(infos[child], infos[super_idx]) {
     |           changed = true
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn gto_collect_func_type_idx_by_func(mod : Module) -> Map[FuncIdx, TypeIdx] {
     |   let out : Map[FuncIdx, TypeIdx] = Map::new()
     |   let mut next : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 433 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) => {
     |             out[FuncIdx::new(next)] = type_idx
     |             next += 1
     |           }
 439 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out[FuncIdx::new(next)] = type_idx
     |         next += 1
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn gto_collect_all_global_types(mod : Module) -> Array[GlobalType] {
     |   let out : Array[GlobalType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 460 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(global_type)) => out.push(global_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for global in globals {
     |         let Global(global_type, _) = global
     |         out.push(global_type)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn gto_collect_all_table_types(mod : Module) -> Array[TableType] {
     |   let out : Array[TableType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 484 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, TableExternType(table_type)) => out.push(table_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.table_sec {
     |     Some(TableSec(tables)) =>
 494 |       for table in tables {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Table(table_type, _) = table
     |         out.push(table_type)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn gto_collect_all_tag_types(mod : Module) -> Array[TagType] {
     |   let out : Array[TagType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 508 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, TagExternType(tag_type)) => out.push(tag_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.tag_sec {
     |     Some(TagSec(tags)) =>
 518 |       for tag in tags {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         out.push(tag)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn gto_mark_public_heaptype(
     |   public_types : Set[Int],
     |   flat : GTOFlatTypes,
     |   group_start : Int,
     |   ht : HeapType,
     | ) -> Unit {
     |   match ht {
     |     HeapType(tidx) =>
     |       match gto_resolve_type_idx(tidx, group_start, flat.subtypes.length()) {
     |         Some(idx) => gto_mark_public_type_idx(public_types, flat, idx)
 537 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 539 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_mark_public_reftype(
     |   public_types : Set[Int],
     |   flat : GTOFlatTypes,
     |   group_start : Int,
     |   rt : RefType,
     | ) -> Unit {
     |   match rt {
     |     HeapTypeRefType(_, ht) =>
     |       gto_mark_public_heaptype(public_types, flat, group_start, ht)
 553 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_mark_public_storage_type(
     |   public_types : Set[Int],
     |   flat : GTOFlatTypes,
     |   group_start : Int,
     |   st : StorageType,
     | ) -> Unit {
     |   match st {
     |     ValTypeStorageType(vt) =>
     |       gto_mark_public_valtype(public_types, flat, group_start, vt)
 581 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_mark_public_type_idx(
     |   public_types : Set[Int],
     |   flat : GTOFlatTypes,
     |   idx : Int,
     | ) -> Unit {
     |   if idx < 0 || idx >= flat.subtypes.length() || public_types.contains(idx) {
 592 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   public_types.add(idx)
     |   for super_idx in flat.supers[idx] {
 596 |     gto_mark_public_type_idx(public_types, flat, super_idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let subtype = flat.subtypes[idx]
     |   let group_start = flat.group_starts[idx]
     |   match subtype.get_comptype() {
 601 |     FuncCompType(params, results) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for p in params {
 603 |         gto_mark_public_valtype(public_types, flat, group_start, p)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for r in results {
 606 |         gto_mark_public_valtype(public_types, flat, group_start, r)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructCompType(fields) =>
     |       for field in fields {
     |         let FieldType(st, _) = field
     |         gto_mark_public_storage_type(public_types, flat, group_start, st)
     |       }
 614 |     ArrayCompType(field) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let FieldType(st, _) = field
 616 |       gto_mark_public_storage_type(public_types, flat, group_start, st)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn gto_collect_public_types(mod : Module, flat : GTOFlatTypes) -> Set[Int] {
     |   let public_types : Set[Int] = Set::new()
     |   let func_types = gto_collect_func_type_idx_by_func(mod)
     |   let global_types = gto_collect_all_global_types(mod)
     |   let table_types = gto_collect_all_table_types(mod)
     |   let tag_types = gto_collect_all_tag_types(mod)
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 630 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) =>
 633 |             match gto_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(idx) => gto_mark_public_type_idx(public_types, flat, idx)
     |               None => ()
     |             }
     |           Import(_, _, TagExternType(TagType(type_idx))) =>
 638 |             match gto_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(idx) => gto_mark_public_type_idx(public_types, flat, idx)
     |               None => ()
     |             }
     |           Import(_, _, GlobalExternType(GlobalType(vt, _))) =>
 643 |             gto_mark_public_valtype(public_types, flat, 0, vt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Import(_, _, TableExternType(TableType(rt, _))) =>
 645 |             gto_mark_public_reftype(public_types, flat, 0, rt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         let Export(_, extern_idx) = export_
     |         match extern_idx {
     |           FuncExternIdx(func_idx) =>
 657 |             match func_types.get(func_idx) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(type_idx) =>
 659 |                 match
     |                 ^^^^^ 	<-- UNCOVERED
     |                   gto_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |                   Some(idx) => gto_mark_public_type_idx(public_types, flat, idx)
     |                   None => ()
     |                 }
 664 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           GlobalExternIdx(GlobalIdx(raw)) => {
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < global_types.length() {
     |               let GlobalType(vt, _) = global_types[idx]
     |               gto_mark_public_valtype(public_types, flat, 0, vt)
     |             }
     |           }
 673 |           TableExternIdx(TableIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < table_types.length() {
 676 |               let TableType(rt, _) = table_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               gto_mark_public_reftype(public_types, flat, 0, rt)
     |             }
     |           }
 680 |           TagExternIdx(TagIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < tag_types.length() {
 683 |               let TagType(type_idx) = tag_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match gto_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |                 Some(type_i) =>
 686 |                   gto_mark_public_type_idx(public_types, flat, type_i)
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 None => ()
     |               }
     |             }
     |           }
 691 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   public_types
     | }
     …

     | fn gto_super_field_can_be_immutable(
     |   flat : GTOFlatTypes,
     |   can_become_immutable : Map[Int, Array[Bool]],
     |   super_idx : Int,
     |   field_idx : Int,
     | ) -> Bool {
     |   match flat.struct_fields[super_idx] {
 751 |     None => true
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(fields) => {
     |       if field_idx >= fields.length() {
     |         return true
     |       }
     |       if !fields[field_idx].is_mutable() {
 757 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match can_become_immutable.get(super_idx) {
     |         Some(vec) => field_idx < vec.length() && vec[field_idx]
 761 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | }
     …

     | fn gto_compute_updates(
     |   flat : GTOFlatTypes,
     |   combined_infos : Array[Array[GTOFieldInfo]],
     |   public_types : Set[Int],
     | ) -> (Map[Int, Array[Bool]], Map[Int, Array[Int]]) {
     |   let can_become_immutable : Map[Int, Array[Bool]] = Map::new()
     |   let indexes_after_removals : Map[Int, Array[Int]] = Map::new()
     |   let infos_subs_supers = gto_copy_field_infos(combined_infos)
     |   gto_propagate_to_super_and_subs(infos_subs_supers, flat)
     |   let infos_supers = gto_copy_field_infos(combined_infos)
     |   gto_propagate_to_subs(infos_supers, flat)
     |   let order = gto_supertypes_first_order(flat)
     |   for type_idx in order {
     |     if public_types.contains(type_idx) {
     |       continue
     |     }
     |     let fields = match flat.struct_fields[type_idx] {
     |       Some(fields) => fields
     |       None => continue
     |     }
     |     if flat.supers[type_idx].length() > 1 {
 789 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let infos_a = infos_subs_supers[type_idx]
     |     let infos_b = infos_supers[type_idx]
     |     for i in 0..<fields.length() {
     |       if !fields[i].is_mutable() {
 795 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if infos_a[i].has_write {
 798 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut super_ok = true
     |       for super_idx in flat.supers[type_idx] {
     |         if !gto_super_field_can_be_immutable(
     |             flat, can_become_immutable, super_idx, i,
     |           ) {
 805 |           super_ok = false
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           break
     |         }
     |       }
     |       if super_ok {
     |         gto_mark_can_become_immutable(can_become_immutable, type_idx, i)
     |       }
     |     }
     |     let removable : Array[Bool] = []
     |     let mut has_removable = false
     |     for i in 0..<fields.length() {
     |       let no_reads_anywhere = !infos_a[i].has_read
     |       let no_reads_writes_in_supers = !infos_b[i].has_read &&
     |         !infos_b[i].has_write
     |       let rem = no_reads_anywhere || no_reads_writes_in_supers
     |       removable.push(rem)
     |       if rem {
     |         has_removable = true
     |       }
     |     }
     |     let super_opt = if flat.supers[type_idx].is_empty() {
     |       None
     |     } else {
     |       Some(flat.supers[type_idx][0])
     |     }
     |     let super_has_updates = match super_opt {
     |       Some(super_idx) => indexes_after_removals.contains(super_idx)
     |       None => false
     |     }
     |     if !has_removable && !super_has_updates {
     |       continue
     |     }
     |     let indexes = Array::make(fields.length(), 0)
     |     let mut next = 0
     |     let mut num_super_fields = 0
     |     match super_opt {
     |       Some(super_idx) => {
     |         let super_len = match flat.struct_fields[super_idx] {
     |           Some(super_fields) => super_fields.length()
 844 |           None => 0
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let super_indexes = match indexes_after_removals.get(super_idx) {
     |           Some(existing) => existing.copy()
 848 |           None => gto_identity_indexes(super_len)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         num_super_fields = super_indexes.length()
     |         let kept_not_in_super : Array[Int] = []
     |         for i in 0..<super_indexes.length() {
     |           let super_new_idx = super_indexes[i]
     |           if super_new_idx == gto_removed_field {
     |             if i < removable.length() && removable[i] {
     |               indexes[i] = gto_removed_field
     |             } else {
 858 |               kept_not_in_super.push(i)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           } else {
     |             indexes[i] = super_new_idx
     |             if super_new_idx + 1 > next {
     |               next = super_new_idx + 1
     |             }
     |           }
     |         }
     |         for i in kept_not_in_super {
 868 |           indexes[i] = next
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           next += 1
     |         }
     |       }
     |       None => ()
     |     }
     |     for i in num_super_fields..<fields.length() {
     |       if i < removable.length() && removable[i] {
     |         indexes[i] = gto_removed_field
     |       } else {
     |         indexes[i] = next
     |         next += 1
     |       }
     |     }
     |     if indexes != gto_identity_indexes(indexes.length()) {
     |       indexes_after_removals[type_idx] = indexes
     |     }
     |   }
     |   (can_become_immutable, indexes_after_removals)
     | }
     …

     | fn gto_apply_type_updates(
     |   mod : Module,
     |   flat : GTOFlatTypes,
     |   can_become_immutable : Map[Int, Array[Bool]],
     |   indexes_after_removals : Map[Int, Array[Int]],
     | ) -> Module {
     |   let type_sec = match mod.type_sec {
     |     Some(type_sec) => type_sec
 898 |     None => return mod
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let new_subtypes = flat.subtypes.copy()
     |   for i in 0..<new_subtypes.length() {
     |     let old_subtype = new_subtypes[i]
     |     let old_comp = old_subtype.get_comptype()
     |     let new_comp = match old_comp {
     |       StructCompType(fields) => {
     |         let updated_fields = fields.copy()
     |         match can_become_immutable.get(i) {
     |           Some(vec) =>
     |             for field_idx in 0..<vec.length() {
     |               if field_idx >= updated_fields.length() {
 911 |                 break
     |                 ^^^^^ 	<-- UNCOVERED
     |               }
     |               if vec[field_idx] {
     |                 let FieldType(st, _) = updated_fields[field_idx]
     |                 updated_fields[field_idx] = FieldType::new(st, Const)
     |               }
     |             }
 918 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match indexes_after_removals.get(i) {
     |           Some(indexes) => {
     |             let kept_len = updated_fields.length() - gto_count_removed(indexes)
     |             let slots : Map[Int, FieldType] = Map::new()
     |             for field_idx in 0..<updated_fields.length() {
     |               let new_idx = indexes[field_idx]
     |               if new_idx != gto_removed_field {
     |                 slots[new_idx] = updated_fields[field_idx]
     |               }
     |             }
     |             let out : Array[FieldType] = []
     |             for new_idx in 0..<kept_len {
     |               match slots.get(new_idx) {
     |                 Some(field) => out.push(field)
 934 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |             CompType::struct_(out)
     |           }
     |           None => CompType::struct_(updated_fields)
     |         }
     |       }
     |       _ => old_comp
     |     }
     |     let next_subtype = match old_subtype {
     |       SubType(is_final, supers, _) => SubType::new(is_final, supers, new_comp)
     |       CompTypeSubType(_) => SubType::comp_type(new_comp)
     |     }
     |     new_subtypes[i] = next_subtype
     |   }
     |   mod.with_type_sec(gto_rebuild_type_sec(type_sec, new_subtypes))
     | }
     …

     | fn gto_get_new_field_index(
     |   indexes_after_removals : Map[Int, Array[Int]],
     |   type_idx : TypeIdx,
     |   old_field_idx : Int,
     | ) -> Int {
     |   let ti = gto_typeidx_raw_int(type_idx)
     |   match indexes_after_removals.get(ti) {
 961 |     None => old_field_idx
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(indexes) =>
     |       if old_field_idx < 0 || old_field_idx >= indexes.length() {
 964 |         old_field_idx
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         indexes[old_field_idx]
     |       }
     |   }
     | }
     …

     | fn gto_is_reorder_safe_operand(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => true
     |     TRefNull(_)
     |     | TRefFunc(_)
 977 |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalGet(_) | TGlobalGet(_) => true
     |     _ => false
     |   }
     | }
     …

     | fn gto_may_trap(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => false
     |     TRefNull(_)
     |     | TRefFunc(_)
 989 |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => false
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalGet(_) | TGlobalGet(_) | TNop => false
     |     _ => true
     |   }
     | }
     …

     | fn gto_count_imported_funcs(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
1000 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(_)) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn gto_alloc_temp_local(
     |   next_local : Array[Int],
     |   extra_locals : Array[ValType],
     |   ty : ValType,
     | ) -> LocalIdx {
1017 |   let idx = next_local[0]
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   next_local[0] = idx + 1
1019 |   extra_locals.push(ty)
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   LocalIdx::new(idx.reinterpret_as_uint())
     | }
     …

     | fn gto_build_reordered_operands(
     |   operands : Array[TInstr],
     |   indexes_after_removal : Array[Int],
     | ) -> Result[Array[TInstr], String] {
     |   let kept = indexes_after_removal.length() -
     |     gto_count_removed(indexes_after_removal)
     |   let slots : Map[Int, TInstr] = Map::new()
     |   let upto = if operands.length() < indexes_after_removal.length() {
1032 |     operands.length()
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     indexes_after_removal.length()
     |   }
     |   for i in 0..<upto {
     |     let new_idx = indexes_after_removal[i]
     |     if new_idx != gto_removed_field {
     |       slots[new_idx] = operands[i]
     |     }
     |   }
     |   let out : Array[TInstr] = []
     |   for i in 0..<kept {
     |     match slots.get(i) {
     |       Some(instr) => out.push(instr)
1046 |       None => return Err("global_type_optimization: invalid field remap")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(out)
     | }
     …

     | fn gto_rewrite_function_texpr(
     |   body : TExpr,
     |   flat : GTOFlatTypes,
     |   indexes_after_removals : Map[Int, Array[Int]],
     |   next_local : Array[Int],
     |   extra_locals : Array[ValType],
     | ) -> Result[TExpr, String] {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let rewritten = match self.walk_tinstruction_default((), instr) {
1062 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Ok(None) => instr
     |       Ok(Some((_, next))) => next
     |     }
     |     match rewritten {
     |       TStructNew(type_idx, operands) => {
     |         let type_i = gto_typeidx_raw_int(type_idx)
     |         match indexes_after_removals.get(type_i) {
1070 |           None => change((), rewritten)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(indexes) => {
     |             let remapped = match
     |               gto_build_reordered_operands(operands, indexes) {
     |               Ok(v) => v
1075 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let mut safe = true
     |             for operand in operands {
     |               if !gto_is_reorder_safe_operand(operand) {
1080 |                 safe = false
     |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 break
     |               }
     |             }
     |             if safe {
     |               change((), TInstr::struct_new(type_idx, remapped))
     |             } else {
1087 |               let fields = match flat.struct_fields.get(type_i) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(Some(fields)) => fields
     |                 _ => return Err("global_type_optimization: missing struct type")
     |               }
     |               if operands.length() != fields.length() {
1092 |                 return Err(
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |                   "global_type_optimization: struct.new field mismatch",
     |                 )
     |               }
     |               let temp_by_old : Array[LocalIdx] = []
     |               let block_instrs : Array[TInstr] = []
     |               for i in 0..<operands.length() {
1099 |                 let temp = gto_alloc_temp_local(
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   next_local,
     |                   extra_locals,
1102 |                   fields[i].unpack(),
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 )
1104 |                 temp_by_old.push(temp)
     |                 ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 block_instrs.push(TInstr::local_set(temp, operands[i]))
     |               }
     |               let new_ops : Array[TInstr] = []
     |               for old_i in 0..<indexes.length() {
1109 |                 let new_i = indexes[old_i]
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if new_i == gto_removed_field {
1111 |                   continue
     |                   ^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |                 while new_ops.length() <= new_i {
1114 |                   new_ops.push(TInstr::nop())
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1116 |                 new_ops[new_i] = TInstr::local_get(temp_by_old[old_i])
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1118 |               block_instrs.push(TInstr::struct_new(type_idx, new_ops))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               let bt = BlockType::val_type(
     |                 ValType::ref_type(RefType::new(false, HeapType::new(type_idx))),
     |               )
1122 |               change((), TInstr::block(bt, TExpr::new(block_instrs)))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |         }
     |       }
1127 |       TStructSet(type_idx, field_idx, ref_, value) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx != gto_removed_field {
1133 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1135 |             TInstr::struct_set(
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1137 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |               value,
     |             ),
     |           )
     |         } else {
1143 |           let temp_ref = gto_alloc_temp_local(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             next_local,
     |             extra_locals,
1146 |             ValType::ref_type(RefType::new(true, HeapType::new(type_idx))),
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           )
1148 |           let replacement = TInstr::block(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             BlockType::void_(),
     |             TExpr::new([
     |               TInstr::local_set(temp_ref, ref_),
     |               TInstr::drop(value),
     |               TInstr::drop(TInstr::ref_as_non_null(TInstr::local_get(temp_ref))),
     |             ]),
     |           )
1156 |           change((), replacement)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TStructGet(type_idx, field_idx, ref_) => {
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx == gto_removed_field {
1165 |           Err("global_type_optimization: removed field still read")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           change(
     |             (),
     |             TInstr::struct_get(
     |               type_idx,
     |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ref_,
     |             ),
     |           )
     |         }
     |       }
1177 |       TStructGetS(type_idx, field_idx, ref_) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx == gto_removed_field {
1183 |           Err("global_type_optimization: removed field still read")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1185 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1187 |             TInstr::struct_get_s(
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1189 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |             ),
     |           )
     |         }
     |       }
1195 |       TStructGetU(type_idx, field_idx, ref_) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx == gto_removed_field {
1201 |           Err("global_type_optimization: removed field still read")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1203 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1205 |             TInstr::struct_get_u(
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1207 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |             ),
     |           )
     |         }
     |       }
     |       _ => change((), rewritten)
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
1217 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(body)
     |     Ok(Some((_, next_body))) => Ok(next_body)
     |   }
     | }
     …

     | fn gto_rewrite_module_texpr(
     |   body : TExpr,
     |   flat : GTOFlatTypes,
     |   indexes_after_removals : Map[Int, Array[Int]],
     |   removed_trapping_inits : Array[(ValType, TInstr)],
     | ) -> Result[TExpr, String] {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let rewritten = match self.walk_tinstruction_default((), instr) {
1232 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Ok(None) => instr
     |       Ok(Some((_, next))) => next
     |     }
     |     match rewritten {
     |       TStructNew(type_idx, operands) => {
     |         let type_i = gto_typeidx_raw_int(type_idx)
     |         match indexes_after_removals.get(type_i) {
1240 |           None => change((), rewritten)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(indexes) => {
     |             let remapped = match
     |               gto_build_reordered_operands(operands, indexes) {
     |               Ok(v) => v
1245 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             match flat.struct_fields.get(type_i) {
     |               Some(Some(fields)) => {
     |                 let upto = if indexes.length() < operands.length() {
1250 |                   indexes.length()
     |                   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 } else {
     |                   operands.length()
     |                 }
     |                 for i in 0..<upto {
     |                   if indexes[i] == gto_removed_field &&
     |                     i < fields.length() &&
     |                     gto_may_trap(operands[i]) {
     |                     removed_trapping_inits.push(
     |                       (fields[i].unpack(), operands[i]),
     |                     )
     |                   }
     |                 }
     |               }
1264 |               _ => ()
     |               ^^^^^^^ 	<-- UNCOVERED
     |             }
     |             change((), TInstr::struct_new(type_idx, remapped))
     |           }
     |         }
     |       }
1270 |       TStructSet(type_idx, field_idx, ref_, value) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx != gto_removed_field {
1276 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1278 |             TInstr::struct_set(
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1280 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |               value,
     |             ),
     |           )
     |         } else {
1286 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1288 |             TInstr::block(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               BlockType::void_(),
     |               TExpr::new([
     |                 TInstr::drop(value),
     |                 TInstr::drop(TInstr::ref_as_non_null(ref_)),
     |               ]),
     |             ),
     |           )
     |         }
     |       }
1298 |       TStructGet(type_idx, field_idx, ref_) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx == gto_removed_field {
1304 |           Err("global_type_optimization: removed field still read")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1306 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1308 |             TInstr::struct_get(
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1310 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |             ),
     |           )
     |         }
     |       }
1316 |       TStructGetS(type_idx, field_idx, ref_) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx == gto_removed_field {
1322 |           Err("global_type_optimization: removed field still read")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1324 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1326 |             TInstr::struct_get_s(
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1328 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |             ),
     |           )
     |         }
     |       }
1334 |       TStructGetU(type_idx, field_idx, ref_) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let old_idx = gto_u32_to_int(field_idx)
     |         let new_idx = gto_get_new_field_index(
     |           indexes_after_removals, type_idx, old_idx,
     |         )
     |         if new_idx == gto_removed_field {
1340 |           Err("global_type_optimization: removed field still read")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1342 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             (),
1344 |             TInstr::struct_get_u(
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx,
1346 |               @lib.U32(new_idx.reinterpret_as_uint()),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ref_,
     |             ),
     |           )
     |         }
     |       }
     |       _ => change((), rewritten)
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
1356 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(body)
     |     Ok(Some((_, next_body))) => Ok(next_body)
     |   }
     | }
     …

     | fn gto_rewrite_module_expr(
     |   expr : Expr,
     |   env : Env,
     |   flat : GTOFlatTypes,
     |   indexes_after_removals : Map[Int, Array[Int]],
     |   removed_trapping_inits : Array[(ValType, TInstr)],
     | ) -> Result[Expr, String] {
     |   match to_texpr(expr, env) {
     |     Ok(texpr) =>
     |       match
     |         gto_rewrite_module_texpr(
     |           texpr, flat, indexes_after_removals, removed_trapping_inits,
     |         ) {
     |         Ok(next_texpr) => Ok(next_texpr.to_expr())
1377 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1379 |     Err(_) => Ok(expr)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gto_update_instructions(
     |   mod : Module,
     |   env : Env,
     |   flat : GTOFlatTypes,
     |   indexes_after_removals : Map[Int, Array[Int]],
     | ) -> Result[Module, String] {
     |   let mut mod = mod
     |   let imported_funcs = gto_count_imported_funcs(mod)
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) => {
     |       let new_funcs : Array[Func] = []
     |       for def_idx in 0..<funcs.length() {
     |         let abs_idx = imported_funcs + def_idx
     |         let abs_func_idx = FuncIdx::new(abs_idx.reinterpret_as_uint())
     |         let param_count = match env.get_functype_by_funcidx(abs_func_idx) {
     |           Some(FuncType(params, _)) => params.length()
1400 |           None => 0
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match funcs[def_idx] {
     |           TFunc(locals, body) => {
     |             let next_local = [param_count + locals.length()]
     |             let extra_locals : Array[ValType] = []
     |             let new_body = match
     |               gto_rewrite_function_texpr(
     |                 body, flat, indexes_after_removals, next_local, extra_locals,
     |               ) {
     |               Ok(next_body) => next_body
1411 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let new_locals = locals.copy()
     |             for local_ty in extra_locals {
1415 |               new_locals.push(local_ty)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             new_funcs.push(Func::t_func(new_locals, new_body))
     |           }
     |           Func(locals, body) =>
1420 |             match gto_expand_locals(locals) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(expanded) => {
     |                 let local_env = env.with_locals(expanded)
     |                 match to_texpr(body, local_env) {
     |                   Ok(texpr) => {
     |                     let next_local = [param_count + expanded.length()]
     |                     let extra_locals : Array[ValType] = []
     |                     let next_texpr = match
1428 |                       gto_rewrite_function_texpr(
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         texpr, flat, indexes_after_removals, next_local, extra_locals,
     |                       ) {
1431 |                       Ok(next_texpr) => next_texpr
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       Err(e) => return Err(e)
     |                     }
1434 |                     let all_locals = expanded.copy()
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     for local_ty in extra_locals {
1436 |                       all_locals.push(local_ty)
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     }
1438 |                     new_funcs.push(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       Func::new(
     |                         tlocals_to_locals(all_locals),
     |                         next_texpr.to_expr(),
     |                       ),
     |                     )
     |                   }
1445 |                   Err(_) => new_funcs.push(funcs[def_idx])
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
1448 |               None => new_funcs.push(funcs[def_idx])
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |         }
     |       }
     |       mod = mod.with_code_sec(CodeSec::new(new_funcs))
     |     }
     |     None => ()
     |   }
     |   let removed_trapping_inits : Array[(ValType, TInstr)] = []
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) => {
     |       let next_globals : Array[Global] = []
     |       for global in globals {
     |         let Global(global_type, init) = global
     |         let next_init = match
     |           gto_rewrite_module_expr(
     |             init, env, flat, indexes_after_removals, removed_trapping_inits,
     |           ) {
     |           Ok(expr) => expr
1467 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         next_globals.push(Global::new(global_type, next_init))
     |       }
     |       mod = mod.with_global_sec(GlobalSec::new(next_globals))
     |     }
     |     None => ()
     |   }
     |   match mod.table_sec {
1476 |     Some(TableSec(tables)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_tables : Array[Table] = []
     |       for table in tables {
1479 |         let Table(table_type, init_expr) = table
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let next_init = match init_expr {
     |           Some(expr) =>
1482 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               gto_rewrite_module_expr(
     |                 expr, env, flat, indexes_after_removals, removed_trapping_inits,
     |               ) {
1486 |               Ok(next_expr) => Some(next_expr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
1489 |           None => None
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1491 |         next_tables.push(Table::new(table_type, next_init))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1493 |       mod = mod.with_table_sec(TableSec::new(next_tables))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     None => ()
     |   }
     |   match mod.elem_sec {
1498 |     Some(ElemSec(elems)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_elems : Array[Elem] = []
     |       for elem in elems {
1501 |         let Elem(mode, kind) = elem
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let next_mode = match mode {
     |           Active(table_idx, offset) =>
1504 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               gto_rewrite_module_expr(
     |                 offset, env, flat, indexes_after_removals, removed_trapping_inits,
     |               ) {
1508 |               Ok(next_offset) => ElemMode::active(table_idx, next_offset)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
1511 |           Passive => ElemMode::passive()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Declarative => ElemMode::declarative()
     |         }
1514 |         let next_kind = match kind {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           FuncsElemKind(funcs) => ElemKind::funcs(funcs)
     |           FuncExprsElemKind(exprs) => {
     |             let next_exprs : Array[Expr] = []
     |             for expr in exprs {
1519 |               match
     |               ^^^^^ 	<-- UNCOVERED
     |                 gto_rewrite_module_expr(
     |                   expr, env, flat, indexes_after_removals, removed_trapping_inits,
     |                 ) {
1523 |                 Ok(next_expr) => next_exprs.push(next_expr)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Err(e) => return Err(e)
     |               }
     |             }
1527 |             ElemKind::func_exprs(next_exprs)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1529 |           TypedExprsElemKind(rt, exprs) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let next_exprs : Array[Expr] = []
     |             for expr in exprs {
1532 |               match
     |               ^^^^^ 	<-- UNCOVERED
     |                 gto_rewrite_module_expr(
     |                   expr, env, flat, indexes_after_removals, removed_trapping_inits,
     |                 ) {
1536 |                 Ok(next_expr) => next_exprs.push(next_expr)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Err(e) => return Err(e)
     |               }
     |             }
1540 |             ElemKind::typed_exprs(rt, next_exprs)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
1543 |         next_elems.push(Elem::new(next_mode, next_kind))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1545 |       mod = mod.with_elem_sec(ElemSec::new(next_elems))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     None => ()
     |   }
     |   match mod.data_sec {
1550 |     Some(DataSec(datas)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_datas : Array[Data] = []
     |       for data in datas {
1553 |         let Data(mode, bytes) = data
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let next_mode = match mode {
     |           Active(mem_idx, offset) =>
1556 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               gto_rewrite_module_expr(
     |                 offset, env, flat, indexes_after_removals, removed_trapping_inits,
     |               ) {
1560 |               Ok(next_offset) => DataMode::active(mem_idx, next_offset)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
1563 |           Passive => DataMode::passive()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1565 |         next_datas.push(Data::new(next_mode, bytes))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1567 |       mod = mod.with_data_sec(DataSec::new(next_datas))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     None => ()
     |   }
     |   if !removed_trapping_inits.is_empty() {
     |     let next_globals = match mod.global_sec {
     |       Some(GlobalSec(globals)) => globals.copy()
1574 |       None => []
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     for item in removed_trapping_inits {
     |       let (vt, instr) = item
     |       next_globals.push(
     |         Global::new(GlobalType::new(vt, false), TExpr::new([instr]).to_expr()),
     |       )
     |     }
     |     mod = mod.with_global_sec(GlobalSec::new(next_globals))
     |   }
     |   Ok(mod)
     | }
     …

     | fn global_type_optimization(mod : Module) -> Result[Module, String] {
     |   let type_sec = match mod.type_sec {
     |     Some(type_sec) => type_sec
1591 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let flat = gto_flatten_types(type_sec)
     |   if flat.subtypes.is_empty() {
1595 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let combined_infos : Array[Array[GTOFieldInfo]] = []
     |   for i in 0..<flat.subtypes.length() {
     |     match flat.struct_fields[i] {
     |       Some(fields) =>
     |         combined_infos.push(gto_make_field_info_vec(fields.length()))
     |       None => combined_infos.push([])
     |     }
     |   }
     |   let env = Env::new().with_module(mod)
     |   gto_scan_module_uses(mod, env, combined_infos)
     |   let public_types = gto_collect_public_types(mod, flat)
     |   let (can_become_immutable, indexes_after_removals) = gto_compute_updates(
     |     flat, combined_infos, public_types,
     |   )
     |   if can_become_immutable.is_empty() && indexes_after_removals.is_empty() {
     |     return Ok(mod)
     |   }
     |   let mod = if indexes_after_removals.is_empty() {
     |     mod
     |   } else {
     |     match gto_update_instructions(mod, env, flat, indexes_after_removals) {
     |       Ok(next_mod) => next_mod
1619 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(
     |     gto_apply_type_updates(
     |       mod, flat, can_become_immutable, indexes_after_removals,
     |     ),
     |   )
     | }
     …

     | fn gto_get_struct_fields(mod : Module, idx : Int) -> Array[FieldType]? {
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) =>
     |       match recs.get(idx) {
     |         Some(SingleRecType(st)) =>
     |           match st.get_comptype() {
     |             StructCompType(fields) => Some(fields)
1641 |             _ => None
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
1643 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
1645 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

140 uncovered line(s) in src/passes/gufa.mbt:

     | fn imported_global_count(mod : Module) -> UInt {
     |   let mut n : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  42 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(_)) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn collect_func_type_idx_by_func(mod : Module) -> Map[FuncIdx, TypeIdx] {
     |   let out : Map[FuncIdx, TypeIdx] = Map::new()
     |   let mut next_idx : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  59 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) => {
     |             out[FuncIdx::new(next_idx)] = type_idx
     |             next_idx += 1
     |           }
  65 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out[FuncIdx::new(next_idx)] = type_idx
     |         next_idx += 1
     |       }
  76 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn global_init_known_contents(expr : Expr) -> PossibleContents? {
     |   let Expr(instrs) = expr
     |   match instrs {
  85 |     [I32Const(I32(v))] => Some(PCI32(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     [I64Const(I64(v))] => Some(PCI64(v))
  87 |     [F32Const(v)] => Some(PCF32(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     [F64Const(v)] => Some(PCF64(v))
     |     [RefNull(ht)] => Some(known_ref_to_contents(KRNull(ht)))
     |     [RefFunc(fi)] => Some(known_ref_to_contents(KRFunc(fi)))
  91 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn collect_immutable_global_contents(
     |   mod : Module,
     | ) -> Map[GlobalIdx, PossibleContents] {
     |   let out : Map[GlobalIdx, PossibleContents] = Map::new()
     |   let base = imported_global_count(mod)
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for i = 0; i < globals.length(); i = i + 1 {
     |         match globals[i] {
     |           Global(GlobalType(_, is_mut), init) =>
     |             if !is_mut {
     |               match global_init_known_contents(init) {
     |                 Some(v) =>
     |                   out[GlobalIdx::new(base + i.reinterpret_as_uint())] = v
 110 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn known_ref_type(v : KnownRefValue, state : GUFAState) -> RefType {
     |   match v {
 131 |     KRNull(ht) => RefType::new(true, ht)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     KRFunc(fi) =>
     |       match state.analysis.func_type_idx_by_func.get(fi) {
     |         Some(type_idx) => RefType::new(false, HeapType::new(type_idx))
 135 |         None => RefType::new(false, HeapType::abs(AbsHeapType::func()))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn contents_make_expression(contents : PossibleContents) -> TInstr? {
     |   match contents {
     |     PCI32(v) => Some(TInstr::i32_const(I32(v)))
     |     PCI64(v) => Some(TInstr::i64_const(I64(v)))
 150 |     PCF32(v) => Some(TInstr::f32_const(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCF64(v) => Some(TInstr::f64_const(v))
     |     PCRef(KRNull(ht)) => Some(TInstr::ref_null(ht))
     |     PCRef(KRFunc(fi)) => Some(TInstr::ref_func(fi))
     |     _ => None
     |   }
     | }
     …

     | fn contents_ref_type(
     |   contents : PossibleContents,
     |   state : GUFAState,
     | ) -> RefType? {
     |   match contents {
     |     PCRef(v) => Some(known_ref_type(v, state))
 165 |     PCRefType(rt) => Some(rt)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn contents_val_type(
     |   contents : PossibleContents,
     |   state : GUFAState,
     | ) -> ValType? {
     |   match contents {
     |     PCI32(_) => Some(ValType::i32())
     |     PCI64(_) => Some(ValType::i64())
 178 |     PCF32(_) => Some(ValType::f32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCF64(_) => Some(ValType::f64())
     |     PCRef(v) => Some(ValType::ref_type(known_ref_type(v, state)))
 181 |     PCRefType(rt) => Some(ValType::ref_type(rt))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn declared_ref_type(instr : TInstr, state : GUFAState) -> RefType? {
     |   match instr {
     |     TLocalGet(idx) =>
 209 |       match state.env.get_local_type(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(RefTypeValType(rt)) => Some(rt)
     |         _ => None
     |       }
     |     TGlobalGet(idx) =>
 214 |       match state.env.get_global_type(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(GlobalType(RefTypeValType(rt), _)) => Some(rt)
     |         _ => None
     |       }
 218 |     TRefNull(ht) => Some(RefType::new(true, ht))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefFunc(_) => Some(RefType::abs(AbsHeapType::func()))
     |     TRefAsNonNull(value) =>
 221 |       match declared_ref_type(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rt) => Some(RefType::new(false, rt.get_heap_type()))
     |         None => None
     |       }
     |     TRefCast(nullable, ht, _) | TRefCastDescEq(nullable, ht, _) =>
 226 |       Some(RefType::new(nullable, ht))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TCall(func_idx, _) =>
 228 |       match state.env.get_functype_by_funcidx(func_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [RefTypeValType(rt)])) => Some(rt)
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 233 |       match state.env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [RefTypeValType(rt)])) => Some(rt)
     |         _ => None
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn gufa_get_contents(instr : TInstr, state : GUFAState) -> PossibleContents {
     |   match instr {
 249 |     TUnreachable => PCUnreachable
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TI32Const(I32(v)) => PCI32(v)
     |     TI64Const(I64(v)) => PCI64(v)
 252 |     TF32Const(v) => PCF32(v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF64Const(v) => PCF64(v)
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => PCUnknown
     |     TRefNull(ht) => known_ref_to_contents(KRNull(ht))
     |     TRefFunc(fi) => known_ref_to_contents(KRFunc(fi))
     |     TLocalGet(idx) =>
     |       match state.local_contents.get(idx) {
     |         Some(c) => c
     |         None =>
     |           match state.env.get_local_type(idx) {
 262 |             Some(RefTypeValType(rt)) => PCRefType(rt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ => PCUnknown
     |           }
     |       }
     |     TGlobalGet(idx) =>
     |       match state.analysis.immutable_global_contents.get(idx) {
     |         Some(v) => v
     |         None =>
 270 |           match state.env.get_global_type(idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(GlobalType(RefTypeValType(rt), _)) => PCRefType(rt)
     |             _ => PCUnknown
     |           }
     |       }
 275 |     TLocalTee(_, value) => gufa_get_contents(value, state)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefAsNonNull(value) =>
 277 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCRef(KRNull(_)) => PCUnreachable
     |         PCRef(KRFunc(fi)) => known_ref_to_contents(KRFunc(fi))
     |         PCRefType(rt) => PCRefType(RefType::new(false, rt.get_heap_type()))
     |         _ => PCUnknown
     |       }
     |     TRefIsNull(value) =>
 285 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCRef(KRNull(_)) => PCI32(1)
     |         PCRef(KRFunc(_)) => PCI32(0)
     |         PCRefType(rt) => if rt.is_nullable() { PCUnknown } else { PCI32(0) }
     |         _ => PCUnknown
     |       }
     |     TUnary(I32EqzOp, value) =>
 293 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCI32(v) => PCI32(if v == 0 { 1 } else { 0 })
     |         _ => PCUnknown
     |       }
     |     TUnary(I64EqzOp, value) =>
 299 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCI64(v) => PCI32(if v == 0L { 1 } else { 0 })
     |         _ => PCUnknown
     |       }
     |     TSelect(_, cond, if_true, if_false) =>
 305 |       match gufa_get_contents(cond, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCI32(0) => gufa_get_contents(if_false, state)
     |         PCI32(_) => gufa_get_contents(if_true, state)
     |         _ => {
     |           let t = gufa_get_contents(if_true, state)
     |           let f = gufa_get_contents(if_false, state)
     |           if t == f {
 313 |             t
     |             ^ 	<-- UNCOVERED
     |           } else {
 315 |             PCUnknown
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |     TRefEq(left, right) =>
 320 |       match (gufa_get_contents(left, state), gufa_get_contents(right, state)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (PCUnreachable, _) | (_, PCUnreachable) => PCUnreachable
     |         (PCRef(KRNull(_)), PCRef(KRNull(_))) => PCI32(1)
     |         (PCRef(KRNull(_)), PCRef(KRFunc(_)))
 324 |         | (PCRef(KRFunc(_)), PCRef(KRNull(_))) => PCI32(0)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (PCRef(KRFunc(f0)), PCRef(KRFunc(f1))) =>
 326 |           PCI32(if f0 == f1 { 1 } else { 0 })
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => PCUnknown
     |       }
     |     TRefTest(nullable, target_ht, value) =>
 330 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCRef(v) =>
 333 |           if known_ref_fails_target(v, nullable, target_ht, state) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             PCI32(0)
     |           } else if known_ref_passes_target(v, nullable, target_ht, state) {
     |             PCI32(1)
     |           } else {
 338 |             PCUnknown
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         PCRefType(rt) =>
 341 |           if Match::matches(rt, RefType::new(nullable, target_ht), state.env) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             PCI32(1)
     |           } else {
 344 |             PCUnknown
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
 346 |         _ => PCUnknown
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefTestDesc(nullable, _, value) =>
 349 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCRef(KRNull(_)) => PCI32(if nullable { 1 } else { 0 })
     |         _ => PCUnknown
     |       }
     |     TRefCast(nullable, target_ht, value) =>
     |       match gufa_get_contents(value, state) {
 356 |         PCUnreachable => PCUnreachable
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCRef(v) =>
     |           if known_ref_fails_target(v, nullable, target_ht, state) {
     |             PCUnreachable
     |           } else if known_ref_passes_target(v, nullable, target_ht, state) {
     |             match v {
 362 |               KRNull(_) => known_ref_to_contents(KRNull(target_ht))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               KRFunc(fi) => known_ref_to_contents(KRFunc(fi))
     |             }
     |           } else {
 366 |             PCUnknown
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
 368 |         PCRefType(rt) => {
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let target = RefType::new(nullable, target_ht)
     |           if Match::matches(rt, target, state.env) {
 371 |             if is_strict_ref_subtype(rt, target, state) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               PCRefType(rt)
     |             } else {
 374 |               PCRefType(target)
     |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           } else {
 377 |             PCUnknown
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
 380 |         _ => PCUnknown
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefCastDescEq(nullable, target_ht, value) =>
 383 |       match gufa_get_contents(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         PCUnreachable => PCUnreachable
     |         PCRef(KRNull(_)) =>
 386 |           if nullable {
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             known_ref_to_contents(KRNull(target_ht))
     |           } else {
 389 |             PCUnreachable
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 391 |         _ => PCUnknown
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 393 |     _ => PCUnknown
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn record_local_contents(
     |   state : GUFAState,
     |   idx : LocalIdx,
     |   value : PossibleContents,
     | ) -> GUFAState {
     |   let next : Map[LocalIdx, PossibleContents] = Map::new()
     |   for entry in state.local_contents {
     |     let (k, v) = entry
     |     if k != idx {
 412 |       next[k] = v
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   next[idx] = value
     |   { ..state, local_contents: next }
     | }
     …

     | fn state_for_nested_walk(instr : TInstr, state : GUFAState) -> GUFAState {
     |   match instr {
     |     // Avoid unsound branch/loop merging when tracking known locals.
     |     TBlock(_, _) | TLoop(_, _) | TTryTable(_, _, _) =>
 424 |       clear_local_contents(state)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => state
     |   }
     | }
     …

     | fn func_matches_target_heap(
     |   func_idx : FuncIdx,
     |   target_ht : HeapType,
     |   state : GUFAState,
     | ) -> Bool {
     |   let func_ht = match state.analysis.func_type_idx_by_func.get(func_idx) {
     |     Some(type_idx) => HeapType::new(type_idx)
 437 |     None => HeapType::abs(AbsHeapType::func())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Match::matches(func_ht, target_ht, state.env)
     | }
     …

     | fn known_ref_passes_target(
     |   value : KnownRefValue,
     |   nullable : Bool,
     |   target_ht : HeapType,
     |   state : GUFAState,
     | ) -> Bool {
     |   match value {
 450 |     KRNull(_) => nullable
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     KRFunc(fi) => func_matches_target_heap(fi, target_ht, state)
     |   }
     | }
     …

     | fn drop_children_and_append(
     |   children : Array[TInstr],
     |   last : TInstr,
     |   block_type : BlockType,
     | ) -> TInstr {
     |   if children.is_empty() {
 489 |     return last
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let seq : Array[TInstr] = []
     |   for child in children {
     |     seq.push(TInstr::drop(child))
     |   }
     |   seq.push(last)
     |   TInstr::block(block_type, TExpr::new(seq))
     | }
     …

     | fn optimize_ref_eq(left : TInstr, right : TInstr, state : GUFAState) -> TInstr? {
     |   let out_type = BlockType::val_type(ValType::i32())
     |   match (oracle_contents(left, state), oracle_contents(right, state)) {
     |     (PCUnreachable, _) | (_, PCUnreachable) =>
 504 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         drop_children_and_append(
     |           [left, right],
 507 |           TInstr::unreachable_(),
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           out_type,
     |         ),
     |       )
     |     (PCRef(KRNull(_)), PCRef(KRNull(_))) =>
 512 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         drop_children_and_append(
     |           [left, right],
 515 |           TInstr::i32_const(I32(1)),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           out_type,
     |         ),
     |       )
     |     (PCRef(KRNull(_)), PCRef(KRFunc(_)))
     |     | (PCRef(KRFunc(_)), PCRef(KRNull(_))) =>
 521 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         drop_children_and_append(
     |           [left, right],
 524 |           TInstr::i32_const(I32(0)),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           out_type,
     |         ),
     |       )
     |     (PCRef(KRFunc(f0)), PCRef(KRFunc(f1))) =>
     |       Some(
     |         drop_children_and_append(
     |           [left, right],
     |           TInstr::i32_const(I32(if f0 == f1 { 1 } else { 0 })),
     |           out_type,
     |         ),
     |       )
 536 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn optimize_ref_test(
     |   nullable : Bool,
     |   target_ht : HeapType,
     |   value : TInstr,
     |   state : GUFAState,
     | ) -> TInstr? {
     |   let out_type = BlockType::val_type(ValType::i32())
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 550 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCRef(v) =>
     |       if known_ref_fails_target(v, nullable, target_ht, state) {
     |         Some(
     |           drop_children_and_append([value], TInstr::i32_const(I32(0)), out_type),
     |         )
 556 |       } else if known_ref_passes_target(v, nullable, target_ht, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(
     |           drop_children_and_append([value], TInstr::i32_const(I32(1)), out_type),
     |         )
     |       } else {
 561 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
 563 |     PCRefType(rt) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let target = RefType::new(nullable, target_ht)
     |       if Match::matches(rt, target, state.env) {
 566 |         Some(
     |         ^^^^^ 	<-- UNCOVERED
     |           drop_children_and_append([value], TInstr::i32_const(I32(1)), out_type),
     |         )
     |       } else {
 570 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ =>
 574 |       match declared_ref_type(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rt) => {
     |           let target = RefType::new(nullable, target_ht)
     |           if Match::matches(rt, target, state.env) {
 578 |             Some(
     |             ^^^^^ 	<-- UNCOVERED
     |               drop_children_and_append(
     |                 [value],
 581 |                 TInstr::i32_const(I32(1)),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 out_type,
     |               ),
     |             )
     |           } else {
 586 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         }
 589 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn optimize_ref_cast(
     |   nullable : Bool,
     |   target_ht : HeapType,
     |   value : TInstr,
     |   state : GUFAState,
     | ) -> TInstr? {
     |   let original_target = RefType::new(nullable, target_ht)
     |   let refined_target = match
     |     inferred_ref_type(TInstr::ref_cast(nullable, target_ht, value), state) {
     |     Some(rt) if is_strict_ref_subtype(rt, original_target, state) => rt
     |     _ => original_target
     |   }
     |   let out_type = ref_block_type(
     |     refined_target.is_nullable(),
     |     refined_target.get_heap_type(),
     |   )
     |   let rewritten_cast = TInstr::ref_cast(
     |     refined_target.is_nullable(),
     |     refined_target.get_heap_type(),
     |     value,
     |   )
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 618 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCRef(v) =>
     |       if known_ref_fails_target(
     |           v,
     |           refined_target.is_nullable(),
     |           refined_target.get_heap_type(),
     |           state,
     |         ) {
     |         Some(
     |           drop_children_and_append([value], TInstr::unreachable_(), out_type),
     |         )
     |       } else if known_ref_passes_target(
     |           v,
     |           refined_target.is_nullable(),
     |           refined_target.get_heap_type(),
     |           state,
     |         ) {
     |         match v {
     |           KRNull(_) =>
 637 |             Some(
     |             ^^^^^ 	<-- UNCOVERED
     |               drop_children_and_append(
     |                 [value],
 640 |                 TInstr::ref_null(refined_target.get_heap_type()),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 out_type,
     |               ),
     |             )
     |           KRFunc(_) =>
     |             match declared_ref_type(value, state) {
     |               Some(rt) =>
     |                 if Match::matches(rt, refined_target, state.env) {
 648 |                   Some(value)
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 } else if refined_target != original_target {
     |                   Some(rewritten_cast)
     |                 } else {
 652 |                   None
     |                   ^^^^ 	<-- UNCOVERED
     |                 }
 654 |               None => None
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |         }
     |       } else {
 658 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     PCRefType(rt) =>
 661 |       if Match::matches(rt, refined_target, state.env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(value)
     |       } else if refined_target != original_target {
     |         Some(rewritten_cast)
     |       } else {
 666 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     _ =>
 669 |       match declared_ref_type(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rt) =>
 671 |           if Match::matches(rt, refined_target, state.env) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(value)
     |           } else if refined_target != original_target {
     |             Some(rewritten_cast)
     |           } else {
 676 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         None =>
 679 |           if refined_target != original_target {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(rewritten_cast)
     |           } else {
 682 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |   }
     | }
     …

     | fn optimize_ref_test_desc(
     |   nullable : Bool,
     |   _target_ht : HeapType,
     |   value : TInstr,
     |   state : GUFAState,
     | ) -> TInstr? {
     |   let out_type = BlockType::val_type(ValType::i32())
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 698 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCRef(KRNull(_)) =>
     |       Some(
     |         drop_children_and_append(
     |           [value],
     |           TInstr::i32_const(I32(if nullable { 1 } else { 0 })),
     |           out_type,
     |         ),
     |       )
 707 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn optimize_ref_cast_desc_eq(
     |   nullable : Bool,
     |   target_ht : HeapType,
     |   value : TInstr,
     |   state : GUFAState,
     | ) -> TInstr? {
     |   let out_type = ref_block_type(nullable, target_ht)
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 721 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCRef(KRNull(_)) =>
     |       if nullable {
 724 |         Some(
     |         ^^^^^ 	<-- UNCOVERED
     |           drop_children_and_append(
     |             [value],
 727 |             TInstr::ref_null(target_ht),
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             out_type,
     |           ),
     |         )
     |       } else {
     |         Some(
     |           drop_children_and_append([value], TInstr::unreachable_(), out_type),
     |         )
     |       }
 736 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn optimize_ref_as_non_null(value : TInstr, state : GUFAState) -> TInstr? {
 742 |   match oracle_contents(value, state) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCUnreachable => Some(value)
     |     PCRef(KRNull(ht)) =>
 745 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         drop_children_and_append(
     |           [value],
 748 |           TInstr::unreachable_(),
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ref_block_type(false, ht),
     |         ),
     |       )
 752 |     PCRef(KRFunc(_)) => Some(value)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCRefType(rt) => if !rt.is_nullable() { Some(value) } else { None }
     |     _ =>
 755 |       match declared_ref_type(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rt) => if !rt.is_nullable() { Some(value) } else { None }
     |         None => None
     |       }
     |   }
     | }
     …

     | fn optimize_ref_is_null(value : TInstr, state : GUFAState) -> TInstr? {
     |   let out_type = BlockType::val_type(ValType::i32())
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 767 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCRef(KRNull(_)) =>
 769 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         drop_children_and_append([value], TInstr::i32_const(I32(1)), out_type),
     |       )
     |     PCRef(KRFunc(_)) =>
     |       Some(
     |         drop_children_and_append([value], TInstr::i32_const(I32(0)), out_type),
     |       )
     |     PCRefType(rt) =>
 777 |       if rt.is_nullable() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None
     |       } else {
 780 |         Some(
     |         ^^^^^ 	<-- UNCOVERED
     |           drop_children_and_append([value], TInstr::i32_const(I32(0)), out_type),
     |         )
     |       }
 784 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn optimize_i32_eqz(value : TInstr, state : GUFAState) -> TInstr? {
     |   let out_type = BlockType::val_type(ValType::i32())
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 793 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCI32(v) =>
     |       Some(
     |         drop_children_and_append(
     |           [value],
     |           TInstr::i32_const(I32(if v == 0 { 1 } else { 0 })),
     |           out_type,
     |         ),
     |       )
     |     _ => None
     |   }
     | }
     …

     | fn optimize_i64_eqz(value : TInstr, state : GUFAState) -> TInstr? {
     |   let out_type = BlockType::val_type(ValType::i32())
     |   match oracle_contents(value, state) {
     |     PCUnreachable =>
 811 |       Some(drop_children_and_append([value], TInstr::unreachable_(), out_type))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCI64(v) =>
     |       Some(
     |         drop_children_and_append(
     |           [value],
     |           TInstr::i32_const(I32(if v == 0L { 1 } else { 0 })),
     |           out_type,
     |         ),
     |       )
 820 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn maybe_replace_leaf_with_known_contents(
     |   instr : TInstr,
     |   state : GUFAState,
     | ) -> TInstr {
     |   match instr {
     |     TLocalGet(_) | TGlobalGet(_) =>
     |       match contents_make_expression(oracle_contents(instr, state)) {
     |         Some(replacement) => {
     |           let curr_type : ValType? = match instr {
     |             TLocalGet(idx) => state.env.get_local_type(idx)
     |             TGlobalGet(idx) =>
     |               match state.env.get_global_type(idx) {
     |                 Some(GlobalType(vt, _)) => Some(vt)
 838 |                 None => None
     |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 840 |             _ => None
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let replacement_type = contents_val_type(
     |             oracle_contents(replacement, state),
     |             state,
     |           )
     |           match (curr_type, replacement_type) {
     |             (Some(curr_ty), Some(rep_ty)) =>
     |               if Match::matches(rep_ty, curr_ty, state.env) {
     |                 replacement
     |               } else {
 851 |                 instr
     |                 ^^^^^ 	<-- UNCOVERED
     |               }
 853 |             _ => instr
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         None => instr
     |       }
     |     _ => instr
     |   }
     | }
     …

     | fn maybe_add_cast_all(instr : TInstr, state : GUFAState) -> TInstr {
     |   if !state.cast_all {
     |     return instr
     |   }
     |   match instr {
     |     // Existing casts are handled by ref.cast simplification/refinement.
 869 |     TRefCast(_, _, _) | TRefCastDescEq(_, _, _) => return instr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => ()
     |   }
     |   let declared = match declared_ref_type(instr, state) {
     |     Some(rt) => rt
     |     None => return instr
     |   }
     |   let inferred = match inferred_ref_type(instr, state) {
     |     Some(rt) => rt
 878 |     None => return instr
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if is_strict_ref_subtype(inferred, declared, state) {
     |     TInstr::ref_cast(inferred.is_nullable(), inferred.get_heap_type(), instr)
     |   } else {
 883 |     instr
     |     ^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gufa_optimize_tinstr(instr : TInstr, state : GUFAState) -> TInstr {
     |   let optimized = match instr {
     |     TRefEq(left, right) =>
     |       match optimize_ref_eq(left, right, state) {
     |         Some(opt) => opt
 893 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefTest(nullable, target_ht, value) =>
     |       match optimize_ref_test(nullable, target_ht, value, state) {
     |         Some(opt) => opt
 898 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefCast(nullable, target_ht, value) =>
     |       match optimize_ref_cast(nullable, target_ht, value, state) {
     |         Some(opt) => opt
 903 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefTestDesc(nullable, target_ht, value) =>
     |       match optimize_ref_test_desc(nullable, target_ht, value, state) {
     |         Some(opt) => opt
 908 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefCastDescEq(nullable, target_ht, value) =>
     |       match optimize_ref_cast_desc_eq(nullable, target_ht, value, state) {
     |         Some(opt) => opt
 913 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefAsNonNull(value) =>
 916 |       match optimize_ref_as_non_null(value, state) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(opt) => opt
     |         None => instr
     |       }
     |     TRefIsNull(value) =>
     |       match optimize_ref_is_null(value, state) {
     |         Some(opt) => opt
 923 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TUnary(I32EqzOp, value) =>
     |       match optimize_i32_eqz(value, state) {
     |         Some(opt) => opt
     |         None => instr
     |       }
     |     TUnary(I64EqzOp, value) =>
     |       match optimize_i64_eqz(value, state) {
     |         Some(opt) => opt
 933 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => instr
     |   }
     |   maybe_add_cast_all(
     |     maybe_replace_leaf_with_known_contents(optimized, state),
     |     state,
     |   )
     | }
     …

     | fn post_instr_state(state : GUFAState, instr : TInstr) -> (GUFAState, Bool) {
     |   match instr {
     |     TLocalSet(idx, value) =>
     |       (record_local_contents(state, idx, oracle_contents(value, state)), true)
     |     TLocalTee(idx, value) =>
 949 |       (record_local_contents(state, idx, oracle_contents(value, state)), true)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBlock(_, _) | TLoop(_, _) | TTryTable(_, _, _) =>
     |       if state.local_contents.is_empty() {
     |         (state, false)
     |       } else {
     |         (clear_local_contents(state), true)
     |       }
     |     _ => (state, false)
     |   }
     | }
     …

     | fn intersect_local_contents(
     |   left : Map[LocalIdx, PossibleContents],
     |   right : Map[LocalIdx, PossibleContents],
     | ) -> Map[LocalIdx, PossibleContents] {
     |   let out : Map[LocalIdx, PossibleContents] = Map::new()
     |   for item in left {
     |     let (idx, left_value) = item
     |     match right.get(idx) {
     |       Some(right_value) =>
     |         if left_value == right_value {
     |           out[idx] = left_value
     |         }
 973 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn walk_child_tinstr(
     |   transformer : ModuleTransformer[GUFAState],
     |   state : GUFAState,
     |   instr : TInstr,
     | ) -> Result[(GUFAState, TInstr, Bool), String] {
     |   match transformer.walk_tinstruction(state, instr) {
     |     Ok(Some((next_state, next_instr))) => Ok((next_state, next_instr, true))
 987 |     Ok(None) => Ok((state, instr, false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn walk_child_texpr(
     |   transformer : ModuleTransformer[GUFAState],
     |   state : GUFAState,
     |   expr : TExpr,
     | ) -> Result[(GUFAState, TExpr, Bool), String] {
     |   match transformer.walk_texpr(state, expr) {
     |     Ok(Some((next_state, next_expr))) => Ok((next_state, next_expr, true))
1000 |     Ok(None) => Ok((state, expr, false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn gufa_transform_tinstr(
     |   transformer : ModuleTransformer[GUFAState],
     |   state : GUFAState,
     |   instr : TInstr,
     | ) -> TransformerResult[GUFAState, TInstr] {
     |   match instr {
     |     TIf(bt, cond, then_, else_) => {
     |       let (cond_state, new_cond, cond_changed) = match
     |         walk_child_tinstr(transformer, state, cond) {
     |         Ok(v) => v
1016 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let branch_entry = cond_state
     |       let (then_state, new_then, then_changed) = match
     |         walk_child_texpr(transformer, branch_entry, then_) {
     |         Ok(v) => v
1022 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut walk_changed = cond_changed || then_changed
     |       let (new_else, merged_locals) = match else_ {
     |         Some(else_expr) => {
     |           let (else_state, walked_else, else_changed) = match
     |             walk_child_texpr(transformer, branch_entry, else_expr) {
     |             Ok(v) => v
1030 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           walk_changed = walk_changed || else_changed
     |           (
     |             Some(walked_else),
     |             intersect_local_contents(
     |               then_state.local_contents,
     |               else_state.local_contents,
     |             ),
     |           )
     |         }
     |         None =>
     |           (
     |             None,
     |             intersect_local_contents(
     |               then_state.local_contents,
     |               branch_entry.local_contents,
     |             ),
     |           )
     |       }
     |       let walked = TInstr::if_(bt, new_cond, new_then, new_else)
     |       let merged_state = { ..cond_state, local_contents: merged_locals }
     |       let optimized = gufa_optimize_tinstr(walked, merged_state)
     |       let (next_state, state_changed) = post_instr_state(
     |         merged_state, optimized,
     |       )
     |       let local_state_changed = next_state.local_contents !=
     |         state.local_contents
     |       return if optimized == instr &&
     |         !walk_changed &&
     |         !state_changed &&
     |         !local_state_changed {
1062 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         change(next_state, optimized)
     |       }
     |     }
     |     _ => ()
     |   }
     |   let walk_state = state_for_nested_walk(instr, state)
     |   let (state, walked) = match
     |     transformer.walk_tinstruction_default(walk_state, instr) {
     |     Ok(None) => (walk_state, instr)
     |     Ok(Some((state, walked))) => (state, walked)
1074 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let optimized = gufa_optimize_tinstr(walked, state)
     |   let (next_state, state_changed) = post_instr_state(state, optimized)
     |   if optimized == instr && !state_changed {
     |     unchanged()
     |   } else {
     |     change(next_state, optimized)
     |   }
     | }
     …

     | fn gufa_transform_func(
     |   transformer : ModuleTransformer[GUFAState],
     |   state : GUFAState,
     |   func : Func,
     | ) -> TransformerResult[GUFAState, Func] {
     |   match func {
1092 |     Func(_, _) => unchanged()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(locals, body) => {
     |       let local_state = GUFAState::{
     |         ..state,
     |         env: state.env.with_locals(locals),
     |         local_contents: Map::new(),
     |       }
     |       match transformer.walk_texpr(local_state, body) {
     |         Ok(Some((_, new_body))) =>
     |           if new_body != body {
     |             change(state, Func::t_func(locals, new_body))
     |           } else {
     |             unchanged()
     |           }
1106 |         Ok(None) => unchanged()
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |       }
     |     }
     |   }
     | }
     …

     | fn gufa_ir_pass(mod : Module, cast_all : Bool) -> ModuleTransformer[IRContext] {
     |   let base_state = {
     |     oracle: ContentOracle::new(),
     |     env: Env::new().with_module(mod),
     |     analysis: build_gufa_analysis(mod),
     |     cast_all,
     |     local_contents: Map::new(),
     |   }
     |   let pass = ModuleTransformer::new()
     |     .on_func_evt(gufa_transform_func)
     |     .on_tinstruction_evt(gufa_transform_tinstr)
     |   ModuleTransformer::new().on_func_evt(fn(_, ctx : IRContext, func : Func) {
     |     match pass.walk_func(base_state, func) {
     |       Ok(Some((_, new_func))) =>
     |         if new_func != func {
     |           change(ctx, new_func)
     |         } else {
     |           unchanged()
     |         }
1133 |       Ok(None) => unchanged()
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Err(e) => Err(e)
     |     }
     |   })
     | }
     …

     | fn run_gufa_module(
     |   mod : Module,
     |   cast_all? : Bool = false,
     | ) -> Result[Module, String] {
     |   let ctx = IRContext::new()
     |   ctx.set_mod(mod)
     |   let pass = gufa_ir_pass(mod, cast_all)
     |   match pass.walk_module(ctx, mod) {
     |     Ok(Some((_, new_mod))) => Ok(new_mod)
1149 |     Ok(None) => Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

366 uncovered line(s) in src/passes/heap2local.mbt:

     | fn h2l_load_is_atomic(op : LoadOp) -> Bool {
     |   match op {
     |     I32AtomicLoadOp
     |     | I64AtomicLoadOp
     |     | I32AtomicLoad8UOp
     |     | I32AtomicLoad16UOp
     |     | I64AtomicLoad8UOp
     |     | I64AtomicLoad16UOp
     |     | I64AtomicLoad32UOp => true
  87 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_store_is_atomic(op : StoreOp) -> Bool {
     |   match op {
     |     I32AtomicStoreOp
     |     | I64AtomicStoreOp
     |     | I32AtomicStore8Op
     |     | I32AtomicStore16Op
     |     | I64AtomicStore8Op
     |     | I64AtomicStore16Op
     |     | I64AtomicStore32Op => true
 101 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_field_has_local_representation(field : FieldType) -> Bool {
     |   match field.unpack() {
     |     NumTypeValType(_) => true
 130 |     VecTypeValType => true
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(_) => true
 132 |     BotValType => false
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_unpack_from_slot(
     |   value : TInstr,
     |   field : FieldType,
     |   signed : Bool,
     | ) -> TInstr {
     |   match field.get_storage_type() {
     |     PackTypeStorageType(I8PackType) =>
     |       if signed {
     |         TInstr::unary(UnaryOp::i32_extend8s(), value)
     |       } else {
     |         TInstr::binary(BinaryOp::i32_and(), value, TInstr::i32_const(I32(0xFF)))
     |       }
     |     PackTypeStorageType(I16PackType) =>
     |       if signed {
     |         TInstr::unary(UnaryOp::i32_extend16s(), value)
     |       } else {
     |         TInstr::binary(
     |           BinaryOp::i32_and(),
     |           value,
     |           TInstr::i32_const(I32(0xFFFF)),
     |         )
     |       }
 177 |     _ => value
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_extract_shape(env : Env, value : TInstr) -> H2LShape? {
     |   match value {
     |     TStructNew(type_idx, _) | TStructNewDefault(type_idx) =>
     |       match env.resolve_struct_fields(type_idx) {
     |         Ok(fields) => {
     |           for field in fields {
     |             if !h2l_field_has_local_representation(field) {
 189 |               return None
     |               ^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           Some(StructShape(type_idx, fields))
     |         }
 194 |         Err(_) => None
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayNew(type_idx, _, len) | TArrayNewDefault(type_idx, len) =>
 197 |       match (env.resolve_array_field(type_idx), h2l_const_i32_nonneg(len)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Ok(field), Some(size)) =>
 199 |           if h2l_field_has_local_representation(field) &&
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             h2l_is_valid_array_size(size) {
 201 |             Some(ArrayShape(type_idx, field, size))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else {
 203 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
 205 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayNewFixed(type_idx, values) =>
     |       match env.resolve_array_field(type_idx) {
     |         Ok(field) => {
     |           let size = values.length()
     |           if h2l_field_has_local_representation(field) &&
     |             h2l_is_valid_array_size(size) {
     |             Some(ArrayShape(type_idx, field, size))
     |           } else {
 215 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         }
 218 |         Err(_) => None
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayNewData(type_idx, _, offset, len) =>
     |       match
     |         (
     |           env.resolve_array_field(type_idx),
     |           h2l_const_i32_nonneg(offset),
     |           h2l_const_i32_nonneg(len),
     |         ) {
     |         (Ok(field), Some(_), Some(size)) =>
     |           if h2l_field_has_local_representation(field) &&
     |             h2l_is_valid_array_size(size) {
     |             Some(ArrayShape(type_idx, field, size))
     |           } else {
 232 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
 234 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayNewElem(type_idx, _, offset, len) =>
     |       match
     |         (
     |           env.resolve_array_field(type_idx),
     |           h2l_const_i32_nonneg(offset),
     |           h2l_const_i32_nonneg(len),
     |         ) {
     |         (Ok(field), Some(_), Some(size)) =>
     |           if h2l_field_has_local_representation(field) &&
     |             h2l_is_valid_array_size(size) {
     |             Some(ArrayShape(type_idx, field, size))
     |           } else {
 248 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
 250 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn h2l_note_set_shape(
     |   state : H2LAnalyzeState,
     |   idx : Int,
     |   shape : H2LShape,
     | ) -> Unit {
     |   if state.invalid.contains(idx) {
 263 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   match state.shapes.get(idx) {
 266 |     Some(existing) => if existing != shape { h2l_mark_invalid(state, idx) }
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => state.shapes[idx] = shape
     |   }
     | }
     …

     | fn h2l_scan_body(env : Env, body : TExpr) -> H2LAnalyzeState {
     |   let state : H2LAnalyzeState = {
     |     env,
     |     shapes: Map::new(),
     |     invalid: Map::new(),
     |     set_counts: Map::new(),
     |     total_get_counts: Map::new(),
     |     safe_get_counts: Map::new(),
     |     uses: Map::new(),
     |     has_sync_atomic: false,
     |   }
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     s : H2LAnalyzeState,
     |     instr : TInstr,
     |   ) {
     |     match instr {
     |       TLoad(op, _, _) => if h2l_load_is_atomic(op) { s.has_sync_atomic = true }
     |       TStore(op, _, _, _) =>
     |         if h2l_store_is_atomic(op) {
     |           s.has_sync_atomic = true
     |         }
     |       TMemoryAtomicNotify(_, _, _)
     |       | TMemoryAtomicWait32(_, _, _, _)
     |       | TMemoryAtomicWait64(_, _, _, _)
     |       | TAtomicFence
     |       | TAtomicRmw(_, _, _, _)
     |       | TAtomicCmpxchg(_, _, _, _, _) => s.has_sync_atomic = true
     |       TLocalSet(loc, value) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.set_counts, idx)
     |         match h2l_extract_shape(s.env, value) {
     |           Some(shape) => h2l_note_set_shape(s, idx, shape)
     |           None => h2l_mark_invalid(s, idx)
     |         }
     |       }
     |       TLocalTee(loc, _) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.set_counts, idx)
     |         h2l_mark_invalid(s, idx)
     |       }
     |       TLocalGet(loc) => h2l_inc_count(s.total_get_counts, h2l_local_to_int(loc))
     |       TStructGet(type_idx, field_idx, TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructGet(type_idx, field_idx))
     |       }
     |       TStructGet(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc))) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructGet(type_idx, field_idx))
     |       }
     |       TStructGetS(type_idx, field_idx, TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructGetS(type_idx, field_idx))
     |       }
 329 |       TStructGetS(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc))) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructGetS(type_idx, field_idx))
     |       }
     |       TStructGetU(type_idx, field_idx, TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructGetU(type_idx, field_idx))
     |       }
 339 |       TStructGetU(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc))) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructGetU(type_idx, field_idx))
     |       }
     |       TStructSet(type_idx, field_idx, TLocalGet(loc), _) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructSet(type_idx, field_idx))
     |       }
 349 |       TStructSet(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc)), _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::StructSet(type_idx, field_idx))
     |       }
     |       TArrayGet(type_idx, TLocalGet(loc), index) =>
     |         match h2l_const_i32_nonneg(index) {
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArrayGet(type_idx, i))
     |           }
     |           None => ()
     |         }
     |       TArrayGet(type_idx, TRefAsNonNull(TLocalGet(loc)), index) =>
 364 |         match h2l_const_i32_nonneg(index) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArrayGet(type_idx, i))
     |           }
 370 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArrayGetS(type_idx, TLocalGet(loc), index) =>
     |         match h2l_const_i32_nonneg(index) {
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArrayGetS(type_idx, i))
     |           }
 379 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArrayGetS(type_idx, TRefAsNonNull(TLocalGet(loc)), index) =>
 382 |         match h2l_const_i32_nonneg(index) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArrayGetS(type_idx, i))
     |           }
 388 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArrayGetU(type_idx, TLocalGet(loc), index) =>
     |         match h2l_const_i32_nonneg(index) {
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArrayGetU(type_idx, i))
     |           }
 397 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArrayGetU(type_idx, TRefAsNonNull(TLocalGet(loc)), index) =>
 400 |         match h2l_const_i32_nonneg(index) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArrayGetU(type_idx, i))
     |           }
 406 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArraySet(type_idx, TLocalGet(loc), index, _) =>
     |         match h2l_const_i32_nonneg(index) {
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArraySet(type_idx, i))
     |           }
 415 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArraySet(type_idx, TRefAsNonNull(TLocalGet(loc)), index, _) =>
 418 |         match h2l_const_i32_nonneg(index) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(i) => {
     |             let idx = h2l_local_to_int(loc)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::ArraySet(type_idx, i))
     |           }
 424 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TArrayLen(TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::ArrayLen)
     |       }
 431 |       TArrayLen(TRefAsNonNull(TLocalGet(loc))) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::ArrayLen)
     |       }
     |       TDrop(TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::DropOnly)
     |       }
 441 |       TDrop(TRefAsNonNull(TLocalGet(loc))) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::DropOnly)
     |       }
     |       TRefIsNull(TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefIsNull)
     |       }
 451 |       TRefIsNull(TRefAsNonNull(TLocalGet(loc))) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefIsNull)
     |       }
     |       TRefTest(_, _, TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefTest)
     |       }
     |       TRefGetDesc(TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefGetDesc)
     |       }
 466 |       TRefGetDesc(TRefAsNonNull(TLocalGet(loc))) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefGetDesc)
     |       }
     |       TRefTestDesc(_, _, TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefTestDesc)
     |       }
     |       TRefTestDesc(_, _, TRefAsNonNull(TLocalGet(loc))) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefTestDesc)
     |       }
     |       TRefCastDescEq(_, _, TLocalGet(loc)) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefCastDescEq)
     |       }
     |       TRefCastDescEq(_, _, TRefAsNonNull(TLocalGet(loc))) => {
     |         let idx = h2l_local_to_int(loc)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefCastDescEq)
     |       }
     |       TRefEq(TLocalGet(left), right) => {
     |         let idx = h2l_local_to_int(left)
     |         h2l_inc_count(s.safe_get_counts, idx)
     |         h2l_add_use(s.uses, idx, H2LUse::RefEq)
     |         match right {
     |           TLocalGet(right_loc) => {
     |             let right_idx = h2l_local_to_int(right_loc)
     |             h2l_inc_count(s.safe_get_counts, right_idx)
     |             h2l_add_use(s.uses, right_idx, H2LUse::RefEq)
     |           }
 501 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TRefEq(left, TLocalGet(right)) =>
 505 |         match left {
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TLocalGet(_) => ()
     |           _ => {
     |             let idx = h2l_local_to_int(right)
     |             h2l_inc_count(s.safe_get_counts, idx)
     |             h2l_add_use(s.uses, idx, H2LUse::RefEq)
     |           }
     |         }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default(s, instr)
     |   })
     |   match walker.walk_texpr(state, body) {
     |     Ok(Some((out, _))) => out
 519 |     Ok(None) => state
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(_) => state
     |   }
     | }
     …

     | fn h2l_uses_compatible(shape : H2LShape, uses : Array[H2LUse]) -> Bool {
     |   match shape {
     |     StructShape(type_idx, fields) => {
     |       for use_kind in uses {
     |         match use_kind {
     |           H2LUse::StructGet(used_type, field_idx)
     |           | H2LUse::StructGetS(used_type, field_idx)
     |           | H2LUse::StructGetU(used_type, field_idx)
     |           | H2LUse::StructSet(used_type, field_idx) => {
     |             if used_type != type_idx {
 555 |               return false
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let idx = h2l_u32_to_int(field_idx)
     |             if idx < 0 || idx >= fields.length() {
 559 |               return false
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           H2LUse::RefIsNull
     |           | H2LUse::RefEq
     |           | H2LUse::RefTest
     |           | H2LUse::RefGetDesc
     |           | H2LUse::RefTestDesc
     |           | H2LUse::RefCastDescEq => ()
     |           H2LUse::DropOnly => ()
 569 |           _ => return false
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       true
     |     }
     |     ArrayShape(type_idx, _, _) => {
     |       for use_kind in uses {
     |         match use_kind {
     |           H2LUse::ArrayGet(used_type, idx)
     |           | H2LUse::ArrayGetS(used_type, idx)
     |           | H2LUse::ArrayGetU(used_type, idx)
     |           | H2LUse::ArraySet(used_type, idx) =>
     |             if used_type != type_idx || idx < 0 {
 582 |               return false
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           H2LUse::ArrayLen
     |           | H2LUse::RefIsNull
     |           | H2LUse::RefTest
     |           | H2LUse::RefGetDesc
     |           | H2LUse::RefTestDesc
     |           | H2LUse::RefCastDescEq
     |           | H2LUse::RefEq
     |           | H2LUse::DropOnly => ()
 592 |           _ => return false
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       true
     |     }
     |   }
     | }
     …

     | fn h2l_collect_candidates(analysis : H2LAnalyzeState) -> Map[Int, H2LShape] {
     |   let out : Map[Int, H2LShape] = Map::new()
     |   if analysis.has_sync_atomic {
     |     return out
     |   }
     |   for entry in analysis.shapes {
     |     let (loc, shape) = entry
     |     if analysis.invalid.contains(loc) {
     |       continue
     |     }
     |     if analysis.set_counts.get(loc).unwrap_or(0) == 0 {
 612 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let total_gets = analysis.total_get_counts.get(loc).unwrap_or(0)
     |     let safe_gets = analysis.safe_get_counts.get(loc).unwrap_or(0)
     |     if total_gets != safe_gets {
     |       continue
     |     }
     |     let uses = analysis.uses.get(loc).unwrap_or([])
     |     if !h2l_uses_compatible(shape, uses) {
 621 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     out[loc] = shape
     |   }
     |   out
     | }
     …

     | fn h2l_flatten_instrs(instrs : Array[TInstr]) -> Array[TInstr] {
     |   let out : Array[TInstr] = []
     |   for instr in instrs {
     |     match instr {
     |       TIf(bt, cond, then_expr, else_expr) => {
     |         out.push(TInstr::if_(bt, cond, TExpr::new([]), None))
     |         for child in h2l_flatten_instrs(then_expr.0) {
     |           out.push(child)
     |         }
     |         if else_expr is Some(e) {
 639 |           for child in h2l_flatten_instrs(e.0) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             out.push(child)
     |           }
     |         }
     |       }
     |       _ => out.push(instr)
     |     }
     |   }
     |   out
     | }
     …

     | fn h2l_shape_matches_allocation_value(
     |   env : Env,
     |   shape : H2LShape,
     |   value : TInstr,
     | ) -> Bool {
     |   match h2l_extract_shape(env, value) {
     |     Some(found) => found == shape
 679 |     None => false
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_filter_by_local_graph(
     |   env : Env,
     |   body : TExpr,
     |   graph : LocalGraph,
     |   candidates : Map[Int, H2LShape],
     | ) -> Map[Int, H2LShape] {
     |   let out : Map[Int, H2LShape] = Map::new()
     |   let get_order = h2l_local_graph_get_order(body)
     |   for entry in candidates {
     |     let (loc, shape) = entry
     |     let target = LocalIdx::new(loc.reinterpret_as_uint())
     |     let mut ok = true
     |     for get_id in 0..<get_order.length() {
     |       if get_order[get_id] != target {
 721 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let sets = graph.get_sets(get_id)
     |       if sets.is_empty() {
 725 |         ok = false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |         break
     |       }
     |       for set_src in sets {
     |         match set_src {
 730 |           LocalSet::InitValue => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ok = false
     |             break
     |           }
     |           LocalSet::Set(set_loc, root) =>
     |             if set_loc != target ||
     |               !h2l_root_has_matching_set(env, root, target, shape) {
 737 |               ok = false
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |               break
     |             }
     |         }
     |       }
     |       if !ok {
 743 |         break
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if ok {
     |       out[loc] = shape
     |     }
     |   }
     |   out
     | }
     …

     | fn h2l_has_nonuniform_if_set(expr : TExpr, target : LocalIdx) -> Bool {
     |   for instr in expr.0 {
     |     match instr {
     |       TIf(_, _, then_expr, else_expr) => {
     |         let then_has = h2l_texpr_has_local_set(then_expr, target)
     |         let else_has = match else_expr {
 774 |           Some(e) => h2l_texpr_has_local_set(e, target)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => false
     |         }
     |         if then_has != else_has && (then_has || else_has) {
     |           return true
     |         }
     |         if h2l_has_nonuniform_if_set(then_expr, target) {
 781 |           return true
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if else_expr is Some(e) && h2l_has_nonuniform_if_set(e, target) {
 784 |           return true
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |         if h2l_has_nonuniform_if_set(body, target) {
 789 |           return true
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |   }
     |   false
     | }
     …

     | fn h2l_default_tinstr(vt : ValType) -> TInstr? {
 908 |   match vt {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     NumTypeValType(nt) =>
 910 |       match nt {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I32NumType => Some(TInstr::i32_const(I32(0)))
     |         I64NumType => Some(TInstr::i64_const(I64(0L)))
     |         F32NumType => Some(TInstr::f32_const(F32(0.0)))
     |         F64NumType => Some(TInstr::f64_const(F64(0.0)))
     |       }
     |     VecTypeValType =>
 917 |       Some(TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) =>
 919 |       if rt.is_nullable() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(TInstr::ref_null(rt.get_heap_type()))
     |       } else {
 922 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
 924 |     BotValType => None
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_is_indexed_heap_subtype(
     |   env : Env,
     |   sub : TypeIdx,
     |   target : TypeIdx,
     | ) -> Bool {
 942 |   if sub == target {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return true
     |   }
 945 |   match env.resolve_subtype(sub) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(st) => {
     |       for super_idx in st.super_types() {
 948 |         if h2l_is_indexed_heap_subtype(env, super_idx, target) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return true
     |         }
     |       }
     |       false
     |     }
 954 |     None => false
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_is_heap_subtype(env : Env, sub : HeapType, target : HeapType) -> Bool {
     |   if sub == target {
     |     return true
     |   }
     |   match target {
 964 |     AbsHeapTypeHeapType(AnyAbsHeapType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AbsHeapTypeHeapType(EqAbsHeapType) => sub.is_gc_aggregate()
     |     AbsHeapTypeHeapType(StructAbsHeapType) => sub.is_struct()
     |     AbsHeapTypeHeapType(ArrayAbsHeapType) => sub.is_array()
 968 |     AbsHeapTypeHeapType(_) => false
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     HeapType(target_idx) =>
 970 |       match sub {
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         HeapType(sub_idx) =>
 972 |           h2l_is_indexed_heap_subtype(env, sub_idx, target_idx)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => false
     |       }
 975 |     DefTypeHeapType(_) => false
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_read_u32_le(bytes : Bytes, at : Int) -> UInt {
 993 |   bytes[at].to_uint() |
     |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   (bytes[at + 1].to_uint() << 8) |
     |   (bytes[at + 2].to_uint() << 16) |
     |   (bytes[at + 3].to_uint() << 24)
     | }
     …

     | fn h2l_read_u64_le(bytes : Bytes, at : Int) -> UInt64 {
1001 |   bytes[at].to_uint64() |
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   (bytes[at + 1].to_uint64() << 8) |
     |   (bytes[at + 2].to_uint64() << 16) |
     |   (bytes[at + 3].to_uint64() << 24) |
     |   (bytes[at + 4].to_uint64() << 32) |
     |   (bytes[at + 5].to_uint64() << 40) |
     |   (bytes[at + 6].to_uint64() << 48) |
     |   (bytes[at + 7].to_uint64() << 56)
     | }
     …

     | fn h2l_array_new_data_init(
     |   mod : Module,
     |   field : FieldType,
     |   data_idx : DataIdx,
     |   offset : Int,
     |   len : Int,
     | ) -> H2LArrayInitResult? {
     |   let bytes = match mod.data_sec {
     |     Some(DataSec(datas)) =>
     |       match datas.get(h2l_data_idx_to_int(data_idx)) {
     |         Some(Data(_, content)) => content
1023 |         None => return None
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1025 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let width = match field.get_storage_type() {
     |     PackTypeStorageType(I8PackType) => 1
1029 |     PackTypeStorageType(I16PackType) => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ValTypeStorageType(vt) =>
     |       match vt {
     |         NumTypeValType(I32NumType) => 4
1033 |         NumTypeValType(I64NumType) => 8
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         NumTypeValType(F32NumType) => 4
     |         NumTypeValType(F64NumType) => 8
     |         _ => return None
     |       }
     |   }
     |   if offset < 0 || len < 0 {
1040 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let end = offset + len * width
     |   if end > bytes.length() {
     |     return Some(H2LArrayInitResult::Trap)
     |   }
     |   let out : Array[TInstr] = []
     |   for i in 0..<len {
     |     let at = offset + i * width
     |     match field.get_storage_type() {
     |       PackTypeStorageType(I8PackType) =>
     |         out.push(TInstr::i32_const(I32(bytes[at].to_int())))
     |       PackTypeStorageType(I16PackType) =>
1053 |         out.push(
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           TInstr::i32_const(
     |             I32(bytes[at].to_int() | (bytes[at + 1].to_int() << 8)),
     |           ),
     |         )
     |       ValTypeStorageType(vt) =>
1059 |         match vt {
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |           NumTypeValType(I32NumType) =>
1061 |             out.push(
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::i32_const(
     |                 I32(h2l_read_u32_le(bytes, at).reinterpret_as_int()),
     |               ),
     |             )
     |           NumTypeValType(I64NumType) =>
1067 |             out.push(
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::i64_const(
     |                 I64(h2l_read_u64_le(bytes, at).reinterpret_as_int64()),
     |               ),
     |             )
     |           NumTypeValType(F32NumType) =>
1073 |             out.push(
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::f32_const(
     |                 F32(Float::reinterpret_from_uint(h2l_read_u32_le(bytes, at))),
     |               ),
     |             )
     |           NumTypeValType(F64NumType) =>
1079 |             out.push(
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::f64_const(
     |                 F64(h2l_read_u64_le(bytes, at).reinterpret_as_double()),
     |               ),
     |             )
1084 |           _ => return None
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |     }
     |   }
     |   Some(H2LArrayInitResult::Init(out))
     | }
     …

     | fn h2l_const_expr_to_tinstr(expr : Expr, env : Env) -> TInstr? {
1093 |   match to_texpr(expr, env) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(TExpr(instrs)) =>
1095 |       if instrs.length() == 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match instrs[0] {
     |           TRefNull(_) | TRefFunc(_) => Some(instrs[0])
     |           _ => None
     |         }
     |       } else {
1101 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
1103 |     Err(_) => None
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_array_new_elem_init(
     |   env : Env,
     |   elem_idx : ElemIdx,
     |   offset : Int,
     |   len : Int,
     | ) -> H2LArrayInitResult? {
     |   if offset < 0 || len < 0 {
1115 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let values = match env.get_elem(elem_idx) {
     |     Some(Elem(_, kind)) =>
     |       match kind {
     |         FuncsElemKind(funcs) => {
     |           let out : Array[TInstr] = []
     |           for fi in funcs {
     |             out.push(TInstr::ref_func(fi))
     |           }
     |           out
     |         }
1127 |         FuncExprsElemKind(exprs) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let out : Array[TInstr] = []
     |           for expr in exprs {
1130 |             match h2l_const_expr_to_tinstr(expr, env) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(value) => out.push(value)
     |               None => return None
     |             }
     |           }
     |           out
     |         }
1137 |         TypedExprsElemKind(_, exprs) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let out : Array[TInstr] = []
     |           for expr in exprs {
1140 |             match h2l_const_expr_to_tinstr(expr, env) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(value) => out.push(value)
     |               None => return None
     |             }
     |           }
     |           out
     |         }
     |       }
1148 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let end = offset + len
     |   if end > values.length() {
1152 |     return Some(H2LArrayInitResult::Trap)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let out : Array[TInstr] = []
     |   for i in offset..<end {
     |     out.push(values[i])
     |   }
     |   Some(H2LArrayInitResult::Init(out))
     | }
     …

     | fn h2l_void_block(instrs : Array[TInstr]) -> TInstr {
     |   if instrs.is_empty() {
1196 |     TInstr::nop()
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     TInstr::block(BlockType::void_(), TExpr::new(instrs))
     |   }
     | }
     …

     | fn h2l_materialize_plan_ref(plan : H2LPlan) -> TInstr {
     |   match plan.shape {
     |     StructShape(type_idx, fields) => {
     |       let operands : Array[TInstr] = []
     |       for i in 0..<fields.length() {
     |         operands.push(TInstr::local_get(plan.slots[i]))
     |       }
     |       TInstr::struct_new(type_idx, operands)
     |     }
1212 |     ArrayShape(type_idx, _, size) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let values : Array[TInstr] = []
     |       for i in 0..<size {
1215 |         values.push(TInstr::local_get(plan.slots[i]))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1217 |       TInstr::array_new_fixed(type_idx, values)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn h2l_rewrite_struct_local_set(
     |   state : H2LRewriteState,
     |   plan : H2LPlan,
     |   type_idx : TypeIdx,
     |   value : TInstr,
     | ) -> (H2LRewriteState, TInstr)? {
     |   let slots = plan.slots
     |   match plan.shape {
     |     StructShape(shape_type_idx, fields) => {
     |       if shape_type_idx != type_idx || fields.length() != slots.length() {
1233 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let slot_types = h2l_shape_slots_valtypes(plan.shape)
     |       let out : Array[TInstr] = []
     |       match value {
     |         TStructNew(set_type_idx, operands) => {
     |           if set_type_idx != shape_type_idx ||
     |             operands.length() != slots.length() {
1241 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let temps : Array[LocalIdx] = []
     |           for i in 0..<operands.length() {
     |             let temp = h2l_alloc_temp(state, slot_types[i])
     |             temps.push(temp)
     |             out.push(TInstr::local_set(temp, operands[i]))
     |           }
     |           for i in 0..<slots.length() {
     |             out.push(
     |               TInstr::local_set(
     |                 slots[i],
     |                 h2l_pack_for_store(TInstr::local_get(temps[i]), fields[i]),
     |               ),
     |             )
     |           }
     |           Some((state, h2l_void_block(out)))
     |         }
1259 |         TStructNewDefault(set_type_idx) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if set_type_idx != shape_type_idx {
1261 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           for i in 0..<slots.length() {
1264 |             match h2l_default_tinstr(slot_types[i]) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(default_value) =>
1266 |                 out.push(TInstr::local_set(slots[i], default_value))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               None => return None
     |             }
     |           }
1270 |           Some((state, h2l_void_block(out)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1272 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1275 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_rewrite_array_local_set(
     |   state : H2LRewriteState,
     |   plan : H2LPlan,
     |   env : Env,
     |   mod : Module,
     |   type_idx : TypeIdx,
     |   value : TInstr,
     | ) -> (H2LRewriteState, TInstr)? {
     |   match plan.shape {
     |     ArrayShape(shape_type_idx, field, size) => {
     |       if shape_type_idx != type_idx || plan.slots.length() != size {
1291 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let elem_ty = field.unpack()
     |       let out : Array[TInstr] = []
     |       match value {
1296 |         TArrayNew(set_type_idx, init, len) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if set_type_idx != shape_type_idx {
1298 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if h2l_const_i32_nonneg(len) != Some(size) {
1301 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1303 |           let temp = h2l_alloc_temp(state, elem_ty)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           out.push(TInstr::local_set(temp, init))
     |           for slot in plan.slots {
1306 |             out.push(
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::local_set(
     |                 slot,
1309 |                 h2l_pack_for_store(TInstr::local_get(temp), field),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ),
     |             )
     |           }
1313 |           Some((state, h2l_void_block(out)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1315 |         TArrayNewDefault(set_type_idx, len) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if set_type_idx != shape_type_idx {
1317 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if h2l_const_i32_nonneg(len) != Some(size) {
1320 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1322 |           match h2l_default_tinstr(elem_ty) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(default_value) => {
     |               for slot in plan.slots {
1325 |                 out.push(TInstr::local_set(slot, default_value))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1327 |               Some((state, h2l_void_block(out)))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
1329 |             None => None
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         TArrayNewFixed(set_type_idx, values) => {
     |           if set_type_idx != shape_type_idx || values.length() != size {
1334 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let temps : Array[LocalIdx] = []
     |           for value in values {
     |             let temp = h2l_alloc_temp(state, elem_ty)
     |             temps.push(temp)
     |             out.push(TInstr::local_set(temp, value))
     |           }
     |           for i in 0..<plan.slots.length() {
     |             out.push(
     |               TInstr::local_set(
     |                 plan.slots[i],
     |                 h2l_pack_for_store(TInstr::local_get(temps[i]), field),
     |               ),
     |             )
     |           }
     |           Some((state, h2l_void_block(out)))
     |         }
     |         TArrayNewData(set_type_idx, data_idx, offset, len) => {
     |           if set_type_idx != shape_type_idx {
1354 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let offset_val = match h2l_const_i32_nonneg(offset) {
     |             Some(v) => v
1358 |             None => return None
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if h2l_const_i32_nonneg(len) != Some(size) {
1361 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           match
     |             h2l_array_new_data_init(mod, field, data_idx, offset_val, size) {
     |             Some(H2LArrayInitResult::Trap) =>
     |               Some((state, TInstr::unreachable_()))
     |             Some(H2LArrayInitResult::Init(values)) => {
     |               if values.length() != size {
1369 |                 return None
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               for i in 0..<plan.slots.length() {
     |                 out.push(
     |                   TInstr::local_set(
     |                     plan.slots[i],
     |                     h2l_pack_for_store(values[i], field),
     |                   ),
     |                 )
     |               }
     |               Some((state, h2l_void_block(out)))
     |             }
1381 |             None => None
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         TArrayNewElem(set_type_idx, elem_idx, offset, len) => {
     |           if set_type_idx != shape_type_idx {
1386 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let offset_val = match h2l_const_i32_nonneg(offset) {
     |             Some(v) => v
1390 |             None => return None
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if h2l_const_i32_nonneg(len) != Some(size) {
1393 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           match h2l_array_new_elem_init(env, elem_idx, offset_val, size) {
     |             Some(H2LArrayInitResult::Trap) =>
1397 |               Some((state, TInstr::unreachable_()))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(H2LArrayInitResult::Init(values)) => {
     |               if values.length() != size {
1400 |                 return None
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               for i in 0..<plan.slots.length() {
     |                 out.push(TInstr::local_set(plan.slots[i], values[i]))
     |               }
     |               Some((state, h2l_void_block(out)))
     |             }
1407 |             None => None
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
1410 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1413 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_rewrite_tinstr(
     |   transformer : ModuleTransformer[H2LRewriteState],
     |   state : H2LRewriteState,
     |   env : Env,
     |   mod : Module,
     |   instr : TInstr,
     | ) -> TransformerResult[H2LRewriteState, TInstr] {
     |   let (state_after_walk, walked, walked_changed) = match
     |     transformer.walk_tinstruction_default(state, instr) {
     |     Ok(Some((next_state, next_instr))) => (next_state, next_instr, true)
     |     Ok(None) => (state, instr, false)
1429 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match walked {
     |     TLocalSet(loc, value) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             StructShape(type_idx, _) =>
     |               match
     |                 h2l_rewrite_struct_local_set(
     |                   state_after_walk, plan, type_idx, value,
     |                 ) {
     |                 Some((next_state, rewritten)) => change(next_state, rewritten)
     |                 None =>
1443 |                   if walked_changed {
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     change(state_after_walk, walked)
     |                   } else {
1446 |                     unchanged()
     |                     ^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |               }
     |             ArrayShape(type_idx, _, _) =>
     |               match
     |                 h2l_rewrite_array_local_set(
     |                   state_after_walk, plan, env, mod, type_idx, value,
     |                 ) {
     |                 Some((next_state, rewritten)) => change(next_state, rewritten)
     |                 None =>
1456 |                   if walked_changed {
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     change(state_after_walk, walked)
     |                   } else {
1459 |                     unchanged()
     |                     ^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |               }
     |           }
     |         None =>
1464 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1467 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructGet(type_idx, field_idx, TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             StructShape(shape_type_idx, fields) =>
     |               if type_idx == shape_type_idx {
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
     |                   change(state_after_walk, TInstr::local_get(plan.slots[idx]))
1479 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1482 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1484 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1487 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1490 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1493 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1497 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1500 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructGet(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc))) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             StructShape(shape_type_idx, fields) =>
     |               if type_idx == shape_type_idx {
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
     |                   change(state_after_walk, TInstr::local_get(plan.slots[idx]))
1512 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1515 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1517 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1520 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1523 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1526 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1530 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1533 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructGetS(type_idx, field_idx, TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             StructShape(shape_type_idx, fields) =>
     |               if type_idx == shape_type_idx {
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
     |                   change(
     |                     state_after_walk,
     |                     h2l_unpack_from_slot(
     |                       TInstr::local_get(plan.slots[idx]),
     |                       fields[idx],
     |                       true,
     |                     ),
     |                   )
1552 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1555 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1557 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1560 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1563 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1566 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1570 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1573 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructGetS(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc))) =>
1577 |       match h2l_plan_for(state_after_walk, loc) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(plan) =>
1579 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             StructShape(shape_type_idx, fields) =>
1581 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
1584 |                   change(
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                     state_after_walk,
1586 |                     h2l_unpack_from_slot(
     |                     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       TInstr::local_get(plan.slots[idx]),
     |                       fields[idx],
     |                       true,
     |                     ),
     |                   )
1592 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1595 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1597 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1600 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1603 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1606 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1610 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1613 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructGetU(type_idx, field_idx, TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             StructShape(shape_type_idx, fields) =>
     |               if type_idx == shape_type_idx {
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
     |                   change(
     |                     state_after_walk,
     |                     h2l_unpack_from_slot(
     |                       TInstr::local_get(plan.slots[idx]),
     |                       fields[idx],
     |                       false,
     |                     ),
     |                   )
1632 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1635 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1637 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1640 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1643 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1646 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1650 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1653 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructGetU(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc))) =>
1657 |       match h2l_plan_for(state_after_walk, loc) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(plan) =>
1659 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             StructShape(shape_type_idx, fields) =>
1661 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
1664 |                   change(
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                     state_after_walk,
1666 |                     h2l_unpack_from_slot(
     |                     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       TInstr::local_get(plan.slots[idx]),
     |                       fields[idx],
     |                       false,
     |                     ),
     |                   )
1672 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1675 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1677 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1680 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1683 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1686 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1690 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1693 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructSet(type_idx, field_idx, TLocalGet(loc), value) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             StructShape(shape_type_idx, fields) =>
     |               if type_idx == shape_type_idx {
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
     |                   change(
     |                     state_after_walk,
     |                     TInstr::local_set(
     |                       plan.slots[idx],
     |                       h2l_pack_for_store(value, fields[idx]),
     |                     ),
     |                   )
1711 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1714 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1716 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1719 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1722 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1725 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1729 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1732 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TStructSet(type_idx, field_idx, TRefAsNonNull(TLocalGet(loc)), value) =>
1736 |       match h2l_plan_for(state_after_walk, loc) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(plan) =>
1738 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             StructShape(shape_type_idx, fields) =>
1740 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = h2l_u32_to_int(field_idx)
     |                 if idx >= 0 && idx < fields.length() {
1743 |                   change(
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                     state_after_walk,
1745 |                     TInstr::local_set(
     |                     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       plan.slots[idx],
1747 |                       h2l_pack_for_store(value, fields[idx]),
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     ),
     |                   )
1750 |                 } else if walked_changed {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   change(state_after_walk, walked)
     |                 } else {
1753 |                   unchanged()
     |                   ^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1755 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1758 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1761 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1764 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
1768 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1771 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayGet(type_idx, TLocalGet(loc), index) =>
     |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |         (Some(plan), Some(idx)) =>
     |           match plan.shape {
     |             ArrayShape(shape_type_idx, _, size) =>
     |               if type_idx == shape_type_idx {
     |                 if idx < size {
     |                   change(state_after_walk, TInstr::local_get(plan.slots[idx]))
     |                 } else {
     |                   change(state_after_walk, TInstr::unreachable_())
     |                 }
1785 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1788 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1791 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1794 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
1798 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1801 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayGet(type_idx, TRefAsNonNull(TLocalGet(loc)), index) =>
1805 |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(plan), Some(idx)) =>
1807 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ArrayShape(shape_type_idx, _, size) =>
1809 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if idx < size {
     |                   change(state_after_walk, TInstr::local_get(plan.slots[idx]))
     |                 } else {
1813 |                   change(state_after_walk, TInstr::unreachable_())
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1815 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1818 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1821 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1824 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
1828 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1831 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayGetS(type_idx, TLocalGet(loc), index) =>
     |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |         (Some(plan), Some(idx)) =>
     |           match plan.shape {
     |             ArrayShape(shape_type_idx, field, size) =>
     |               if type_idx == shape_type_idx {
     |                 if idx < size {
     |                   change(
     |                     state_after_walk,
     |                     h2l_unpack_from_slot(
     |                       TInstr::local_get(plan.slots[idx]),
     |                       field,
     |                       true,
     |                     ),
     |                   )
     |                 } else {
1850 |                   change(state_after_walk, TInstr::unreachable_())
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1852 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1855 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1858 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1861 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
1865 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1868 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayGetS(type_idx, TRefAsNonNull(TLocalGet(loc)), index) =>
1872 |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(plan), Some(idx)) =>
1874 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ArrayShape(shape_type_idx, field, size) =>
1876 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if idx < size {
     |                   change(
     |                     state_after_walk,
1880 |                     h2l_unpack_from_slot(
     |                     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       TInstr::local_get(plan.slots[idx]),
     |                       field,
     |                       true,
     |                     ),
     |                   )
     |                 } else {
1887 |                   change(state_after_walk, TInstr::unreachable_())
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1889 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1892 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1895 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1898 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
1902 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1905 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayGetU(type_idx, TLocalGet(loc), index) =>
     |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |         (Some(plan), Some(idx)) =>
     |           match plan.shape {
     |             ArrayShape(shape_type_idx, field, size) =>
     |               if type_idx == shape_type_idx {
     |                 if idx < size {
     |                   change(
     |                     state_after_walk,
     |                     h2l_unpack_from_slot(
     |                       TInstr::local_get(plan.slots[idx]),
     |                       field,
     |                       false,
     |                     ),
     |                   )
     |                 } else {
1924 |                   change(state_after_walk, TInstr::unreachable_())
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1926 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1929 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1932 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1935 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
1939 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1942 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayGetU(type_idx, TRefAsNonNull(TLocalGet(loc)), index) =>
1946 |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(plan), Some(idx)) =>
1948 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ArrayShape(shape_type_idx, field, size) =>
1950 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if idx < size {
     |                   change(
     |                     state_after_walk,
1954 |                     h2l_unpack_from_slot(
     |                     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       TInstr::local_get(plan.slots[idx]),
     |                       field,
     |                       false,
     |                     ),
     |                   )
     |                 } else {
1961 |                   change(state_after_walk, TInstr::unreachable_())
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
1963 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1966 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
1969 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
1972 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
1976 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
1979 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArraySet(type_idx, TLocalGet(loc), index, value) =>
     |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |         (Some(plan), Some(idx)) =>
     |           match plan.shape {
     |             ArrayShape(shape_type_idx, field, size) =>
     |               if type_idx == shape_type_idx {
     |                 if idx < size {
     |                   change(
     |                     state_after_walk,
     |                     TInstr::local_set(
     |                       plan.slots[idx],
     |                       h2l_pack_for_store(value, field),
     |                     ),
     |                   )
     |                 } else {
1997 |                   change(
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                     state_after_walk,
1999 |                     TInstr::block(
     |                     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BlockType::void_(),
     |                       TExpr::new([TInstr::drop(value), TInstr::unreachable_()]),
     |                     ),
     |                   )
     |                 }
2005 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
2008 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
2011 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
2014 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
2018 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2021 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArraySet(type_idx, TRefAsNonNull(TLocalGet(loc)), index, value) =>
2025 |       match (h2l_plan_for(state_after_walk, loc), h2l_const_i32_nonneg(index)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(plan), Some(idx)) =>
2027 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ArrayShape(shape_type_idx, field, size) =>
2029 |               if type_idx == shape_type_idx {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if idx < size {
     |                   change(
     |                     state_after_walk,
2033 |                     TInstr::local_set(
     |                     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       plan.slots[idx],
2035 |                       h2l_pack_for_store(value, field),
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     ),
     |                   )
     |                 } else {
2039 |                   change(
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                     state_after_walk,
2041 |                     TInstr::block(
     |                     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BlockType::void_(),
     |                       TExpr::new([TInstr::drop(value), TInstr::unreachable_()]),
     |                     ),
     |                   )
     |                 }
2047 |               } else if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
2050 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
2053 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
2056 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         _ =>
2060 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2063 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayLen(TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           match plan.shape {
     |             ArrayShape(_, _, size) =>
     |               change(state_after_walk, TInstr::i32_const(I32(size)))
     |             _ =>
2073 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
2076 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
2080 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2083 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TArrayLen(TRefAsNonNull(TLocalGet(loc))) =>
2087 |       match h2l_plan_for(state_after_walk, loc) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(plan) =>
2089 |           match plan.shape {
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ArrayShape(_, _, size) =>
2091 |               change(state_after_walk, TInstr::i32_const(I32(size)))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ =>
2093 |               if walked_changed {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change(state_after_walk, walked)
     |               } else {
2096 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         None =>
2100 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2103 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TDrop(TLocalGet(loc)) =>
     |       if h2l_plan_for(state_after_walk, loc) is Some(_) {
     |         change(state_after_walk, TInstr::nop())
     |       } else if walked_changed {
     |         change(state_after_walk, walked)
     |       } else {
2112 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TDrop(TRefAsNonNull(TLocalGet(loc))) =>
2115 |       if h2l_plan_for(state_after_walk, loc) is Some(_) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(state_after_walk, TInstr::nop())
     |       } else if walked_changed {
     |         change(state_after_walk, walked)
     |       } else {
2120 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefIsNull(TLocalGet(loc)) =>
     |       if h2l_plan_for(state_after_walk, loc) is Some(_) {
     |         change(state_after_walk, TInstr::i32_const(I32(0)))
2125 |       } else if walked_changed {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(state_after_walk, walked)
     |       } else {
2128 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefIsNull(TRefAsNonNull(TLocalGet(loc))) =>
2131 |       if h2l_plan_for(state_after_walk, loc) is Some(_) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(state_after_walk, TInstr::i32_const(I32(0)))
     |       } else if walked_changed {
     |         change(state_after_walk, walked)
     |       } else {
2136 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefGetDesc(TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           change(
     |             state_after_walk,
     |             TInstr::ref_get_desc(h2l_materialize_plan_ref(plan)),
     |           )
     |         None =>
2146 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2149 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefGetDesc(TRefAsNonNull(TLocalGet(loc))) =>
2153 |       match h2l_plan_for(state_after_walk, loc) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(plan) =>
2155 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             state_after_walk,
2157 |             TInstr::ref_get_desc(h2l_materialize_plan_ref(plan)),
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           )
     |         None =>
2160 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2163 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefTest(_, target_ht, TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           change(
     |             state_after_walk,
     |             TInstr::i32_const(
     |               I32(
     |                 if h2l_is_heap_subtype(
     |                     env,
     |                     h2l_shape_heap_type(plan.shape),
     |                     target_ht,
     |                   ) {
     |                   1
     |                 } else {
     |                   0
     |                 },
     |               ),
     |             ),
     |           )
     |         None =>
2186 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2189 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefTest(_, target_ht, TRefAsNonNull(TLocalGet(loc))) =>
2193 |       match h2l_plan_for(state_after_walk, loc) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(plan) =>
2195 |           change(
     |           ^^^^^^^ 	<-- UNCOVERED
     |             state_after_walk,
2197 |             TInstr::i32_const(
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               I32(
     |                 if h2l_is_heap_subtype(
     |                     env,
     |                     h2l_shape_heap_type(plan.shape),
     |                     target_ht,
     |                   ) {
2204 |                   1
     |                   ^ 	<-- UNCOVERED
     |                 } else {
2206 |                   0
     |                   ^ 	<-- UNCOVERED
     |                 },
     |               ),
     |             ),
     |           )
     |         None =>
2212 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2215 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefTestDesc(_, target_ht, TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           change(
     |             state_after_walk,
     |             TInstr::i32_const(
     |               I32(
     |                 if h2l_is_heap_subtype(
     |                     env,
     |                     h2l_shape_heap_type(plan.shape),
     |                     target_ht,
     |                   ) {
     |                   1
     |                 } else {
2232 |                   0
     |                   ^ 	<-- UNCOVERED
     |                 },
     |               ),
     |             ),
     |           )
     |         None =>
2238 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2241 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefTestDesc(_, target_ht, TRefAsNonNull(TLocalGet(loc))) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           change(
     |             state_after_walk,
     |             TInstr::i32_const(
     |               I32(
     |                 if h2l_is_heap_subtype(
     |                     env,
     |                     h2l_shape_heap_type(plan.shape),
     |                     target_ht,
     |                   ) {
2256 |                   1
     |                   ^ 	<-- UNCOVERED
     |                 } else {
     |                   0
     |                 },
     |               ),
     |             ),
     |           )
     |         None =>
2264 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2267 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefCastDescEq(_, target_ht, TLocalGet(loc)) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           if h2l_is_heap_subtype(
     |               env,
     |               h2l_shape_heap_type(plan.shape),
     |               target_ht,
     |             ) {
2278 |             change(state_after_walk, h2l_materialize_plan_ref(plan))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else {
     |             change(state_after_walk, TInstr::unreachable_())
     |           }
     |         None =>
2283 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2286 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefCastDescEq(_, target_ht, TRefAsNonNull(TLocalGet(loc))) =>
     |       match h2l_plan_for(state_after_walk, loc) {
     |         Some(plan) =>
     |           if h2l_is_heap_subtype(
     |               env,
     |               h2l_shape_heap_type(plan.shape),
     |               target_ht,
     |             ) {
     |             change(state_after_walk, h2l_materialize_plan_ref(plan))
     |           } else {
2299 |             change(state_after_walk, TInstr::unreachable_())
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         None =>
2302 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2305 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefEq(TLocalGet(left), TLocalGet(right)) =>
     |       match
     |         (
     |           h2l_plan_for(state_after_walk, left),
     |           h2l_plan_for(state_after_walk, right),
     |         ) {
     |         (Some(_), Some(_)) =>
     |           if left == right {
     |             change(state_after_walk, TInstr::i32_const(I32(1)))
     |           } else {
2318 |             change(state_after_walk, TInstr::i32_const(I32(0)))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         (Some(_), None) | (None, Some(_)) =>
2321 |           change(state_after_walk, TInstr::i32_const(I32(0)))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ =>
2323 |           if walked_changed {
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
2326 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     TRefEq(TLocalGet(left), right) =>
2330 |       if h2l_plan_for(state_after_walk, left) is Some(_) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(
     |           state_after_walk,
2333 |           TInstr::block(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             BlockType::val_type(ValType::i32()),
     |             TExpr::new([TInstr::drop(right), TInstr::i32_const(I32(0))]),
     |           ),
     |         )
2338 |       } else if walked_changed {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(state_after_walk, walked)
     |       } else {
2341 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefEq(left, TLocalGet(right)) =>
2344 |       if h2l_plan_for(state_after_walk, right) is Some(_) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(
     |           state_after_walk,
2347 |           TInstr::block(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             BlockType::val_type(ValType::i32()),
     |             TExpr::new([TInstr::drop(left), TInstr::i32_const(I32(0))]),
     |           ),
     |         )
2352 |       } else if walked_changed {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         change(state_after_walk, walked)
     |       } else {
2355 |         unchanged()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ =>
     |       if walked_changed {
     |         change(state_after_walk, walked)
     |       } else {
     |         unchanged()
     |       }
     |   }
     | }
     …

     | fn h2l_optimize_func_once(
     |   func : Func,
     |   env : Env,
     |   mod : Module,
     |   graph : LocalGraph?,
     | ) -> Func? {
     |   match func {
2374 |     Func(_) => None
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(locals, body) => {
     |       let analysis = h2l_scan_body(env.with_locals(locals), body)
     |       let candidates = h2l_collect_candidates(analysis)
     |       let candidates = h2l_filter_nonuniform_if_sets(body, candidates)
     |       let candidates = h2l_filter_branchy_sets(analysis.env, body, candidates)
     |       let candidates = match graph {
     |         Some(g) => h2l_filter_by_local_graph(analysis.env, body, g, candidates)
2382 |         None => candidates
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if candidates.is_empty() {
     |         return None
     |       }
     |       let state = h2l_new_state(locals, candidates)
     |       let rewrite = ModuleTransformer::new().on_tinstruction_evt(fn(
     |         transformer,
     |         st,
     |         instr,
     |       ) {
     |         h2l_rewrite_tinstr(transformer, st, analysis.env, mod, instr)
     |       })
     |       let (final_state, rewritten, changed_body) = match
     |         rewrite.walk_texpr(state, body) {
     |         Ok(Some((s, expr))) => (s, expr, true)
2398 |         Ok(None) => (state, body, false)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(_) => return None
     |       }
     |       if !changed_body {
2402 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let new_locals = locals.copy()
     |       for local_ty in final_state.new_locals {
     |         new_locals.push(local_ty)
     |       }
     |       Some(Func::t_func(new_locals, rewritten))
     |     }
     |   }
     | }
     …

     | fn h2l_optimize_func(func : Func, env : Env, mod : Module) -> Func? {
     |   let mut curr = func
     |   let mut changed = false
     |   for _ in 0..<4 {
     |     let graph = match curr {
     |       TFunc(_, body) => Some(LocalGraph::new(body.0))
2420 |       _ => None
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match h2l_optimize_func_once(curr, env, mod, graph) {
     |       Some(next) => {
     |         curr = next
     |         changed = true
     |       }
     |       None => break
     |     }
     |   }
     |   if changed {
     |     Some(curr)
     |   } else {
     |     None
     |   }
     | }
     …

     | fn run_heap2local(mod : Module) -> Module {
     |   let pass = heap2local_ir_pass(mod)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, new_mod))) => new_mod
2453 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn h2l_has_local_get(body : TExpr, idx : UInt) -> Bool {
     |   let found = Ref::new(false)
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
2545 |       TLocalGet(LocalIdx(i)) if i == idx => found.update(fn(_) { true })
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   found.val
     | }
     …

53 uncovered line(s) in src/passes/heap_store_optimization.mbt:

     | fn HSOEffects::invalidates(self : HSOEffects, other : HSOEffects) -> Bool {
     |   for local_idx in self.locals_written {
     |     if other.locals_read.contains(local_idx) ||
     |       other.locals_written.contains(local_idx) {
     |       return true
     |     }
     |   }
     |   for local_idx in self.locals_read {
     |     if other.locals_written.contains(local_idx) {
     |       return true
     |     }
     |   }
     |   if (self.reads_memory && other.writes_memory) ||
     |     (self.writes_memory && other.reads_memory) ||
     |     (self.writes_memory && other.writes_memory) {
  58 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.reads_globals && other.writes_globals) ||
     |     (self.writes_globals && other.reads_globals) ||
     |     (self.writes_globals && other.writes_globals) {
  63 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if self.calls || other.calls {
  66 |     if self.reads_memory ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.writes_memory ||
     |       other.reads_memory ||
     |       other.writes_memory ||
     |       self.reads_globals ||
     |       self.writes_globals ||
     |       other.reads_globals ||
     |       other.writes_globals {
  74 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if self.transfers_control_flow() || other.transfers_control_flow() {
  78 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.traps && other.has_unremovable_side_effects()) ||
     |     (other.traps && self.has_unremovable_side_effects()) {
     |     return true
     |   }
     |   false
     | }
     …

     | fn hso_collect_effects(instr : TInstr) -> HSOEffects {
     |   let effects = HSOEffects::new()
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
     |       TLocalGet(idx) => effects.locals_read.add(idx)
     |       TLocalSet(idx, _) => effects.locals_written.add(idx)
 122 |       TLocalTee(idx, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.locals_read.add(idx)
     |         effects.locals_written.add(idx)
     |       }
 126 |       TGlobalGet(_) => effects.reads_globals = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TGlobalSet(_, _) => effects.writes_globals = true
 128 |       TLoad(_, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.reads_memory = true
     |         effects.traps = true
     |       }
 132 |       TStore(_, _, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.writes_memory = true
     |         effects.traps = true
     |       }
 136 |       TMemoryGrow(_, _) => effects.writes_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TMemorySize(_) => effects.reads_memory = true
     |       TMemoryCopy(_, _, _, _, _) => {
     |         effects.reads_memory = true
     |         effects.writes_memory = true
     |       }
 142 |       TMemoryFill(_, _, _, _) => effects.writes_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TMemoryInit(_, _, _, _, _) => {
     |         effects.reads_memory = true
     |         effects.writes_memory = true
     |       }
 147 |       TDataDrop(_) => effects.writes_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TMemoryAtomicNotify(_, _, _)
     |       | TMemoryAtomicWait32(_, _, _, _)
     |       | TMemoryAtomicWait64(_, _, _, _) => {
     |         effects.reads_memory = true
     |         effects.traps = true
     |       }
     |       TAtomicRmw(_, _, _, _) | TAtomicCmpxchg(_, _, _, _, _) => {
     |         effects.reads_memory = true
     |         effects.writes_memory = true
     |         effects.traps = true
     |       }
     |       TAtomicFence =>
     |         // Keep ordering-sensitive synchronization effects as memory reads.
     |         effects.reads_memory = true
     |       TTableSet(_, _, _) | TTableGrow(_, _, _) | TTableFill(_, _, _, _) =>
 163 |         effects.writes_memory = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TTableGet(_, _) | TTableSize(_) => effects.reads_memory = true
     |       TTableCopy(_, _, _, _, _) | TTableInit(_, _, _, _, _) | TElemDrop(_) => {
     |         effects.reads_memory = true
     |         effects.writes_memory = true
     |       }
     |       TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
     |         effects.calls = true
     |       TReturnCall(_, _)
     |       | TReturnCallIndirect(_, _, _, _)
 173 |       | TReturnCallRef(_, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.calls = true
     |         effects.branches = true
     |       }
     |       TBr(_, _)
     |       | TBrIf(_, _, _)
     |       | TBrTable(_, _, _, _)
     |       | TBrOnNull(_, _, _)
     |       | TBrOnNonNull(_, _, _)
     |       | TBrOnCast(_, _, _, _, _, _)
     |       | TBrOnCastFail(_, _, _, _, _, _)
     |       | TReturn(_) => effects.branches = true
 185 |       TThrow(_, _) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.throws = true
     |         effects.branches = true
     |       }
 189 |       TThrowRef(_) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.throws = true
     |         effects.branches = true
     |       }
 193 |       TUnreachable => effects.traps = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TRefAsNonNull(_) | TRefCast(_, _, _) => effects.traps = true
     |       TStructGet(_, _, _) | TStructGetS(_, _, _) | TStructGetU(_, _, _) => {
     |         effects.reads_memory = true
     |         effects.traps = true
     |       }
 199 |       TStructSet(_, _, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.writes_memory = true
     |         effects.traps = true
     |       }
     |       TArrayNew(_, _, _)
     |       | TArrayNewDefault(_, _)
     |       | TArrayNewFixed(_, _)
     |       | TArrayNewData(_, _, _, _)
 207 |       | TArrayNewElem(_, _, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.writes_memory = true
     |         effects.traps = true
     |       }
     |       TArrayGet(_, _, _)
     |       | TArrayGetS(_, _, _)
     |       | TArrayGetU(_, _, _)
 214 |       | TArrayLen(_) => {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.reads_memory = true
     |         effects.traps = true
     |       }
     |       TArraySet(_, _, _, _)
     |       | TArrayFill(_, _, _, _, _)
     |       | TArrayCopy(_, _, _, _, _, _, _)
     |       | TArrayInitData(_, _, _, _, _, _)
 222 |       | TArrayInitElem(_, _, _, _, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         effects.reads_memory = true
     |         effects.writes_memory = true
     |         effects.traps = true
     |       }
     |       TBinary(op, _, _) =>
 228 |         match op {
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |           I32DivSOp
     |           | I32DivUOp
     |           | I32RemSOp
     |           | I32RemUOp
     |           | I64DivSOp
     |           | I64DivUOp
     |           | I64RemSOp
 236 |           | I64RemUOp => effects.traps = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       TUnary(op, _) =>
 240 |         match op {
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |           I32TruncF32SOp
     |           | I32TruncF32UOp
     |           | I32TruncF64SOp
     |           | I32TruncF64UOp
     |           | I64TruncF32SOp
     |           | I64TruncF32UOp
     |           | I64TruncF64SOp
 248 |           | I64TruncF64UOp => effects.traps = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), curr)
     |   })
     |   ignore(walker.walk_tinstruction((), instr))
     |   effects
     | }
     …

     | fn hso_struct_field_default(field : FieldType) -> TInstr? {
     |   match field.get_storage_type() {
 268 |     PackTypeStorageType(_) => Some(TInstr::i32_const(I32(0)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ValTypeStorageType(vt) =>
     |       match vt {
     |         NumTypeValType(nt) =>
     |           match nt {
     |             I32NumType => Some(TInstr::i32_const(I32(0)))
 274 |             I64NumType => Some(TInstr::i64_const(I64(0L)))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             F32NumType => Some(TInstr::f32_const(F32(0.0)))
     |             F64NumType => Some(TInstr::f64_const(F64(0.0)))
     |           }
     |         VecTypeValType =>
 279 |           Some(
     |           ^^^^^ 	<-- UNCOVERED
     |             TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
     |           )
     |         RefTypeValType(rt) =>
 283 |           if rt.is_nullable() {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(TInstr::ref_null(rt.get_heap_type()))
     |           } else {
 286 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
 288 |         BotValType => None
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn hso_is_struct_new_like(instr : TInstr) -> Bool {
     |   match instr {
     |     TStructNew(_, _) | TStructNewDefault(_) => true
 297 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn hso_flatten_instrs_with_origin(
     |   instrs : Array[TInstr],
     |   origin : Int,
     |   flat : Array[TInstr],
     |   origins : Array[Int],
     | ) -> Unit {
     |   for instr in instrs {
     |     match instr {
 310 |       TIf(bt, cond, then_expr, else_expr) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         flat.push(TInstr::if_(bt, cond, TExpr::new([]), None))
     |         origins.push(origin)
     |         hso_flatten_instrs_with_origin(then_expr.0, origin, flat, origins)
     |         if else_expr is Some(other) {
 315 |           hso_flatten_instrs_with_origin(other.0, origin, flat, origins)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => {
     |         flat.push(instr)
     |         origins.push(origin)
     |       }
     |     }
     |   }
     | }
     …

     | fn hso_can_skip_local_set(
     |   list : Array[TInstr],
     |   local_set_idx : Int,
     |   struct_set_idx : Int,
     |   local_idx : LocalIdx,
     | ) -> Bool {
     |   if local_set_idx < 0 ||
     |     local_set_idx >= list.length() ||
     |     struct_set_idx < 0 ||
     |     struct_set_idx >= list.length() {
 363 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let local_set_instr = list[local_set_idx]
     |   let get_infos = hso_local_get_infos(list)
     |   let graph = LocalGraph::new(list)
     |   let mut get_id = 0
     |   for info in get_infos {
     |     if info.local_idx == local_idx && info.top_instr_idx > struct_set_idx {
     |       let sets = graph.get_sets(get_id)
     |       for set_src in sets {
     |         match set_src {
     |           LocalSet::Set(set_idx, root) =>
     |             if set_idx == local_idx && root == local_set_instr {
     |               return false
     |             }
 378 |           LocalSet::InitValue => ()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |     get_id += 1
     |   }
     |   true
     | }
     …

     | fn hso_collect_shallow_new_effects(instr : TInstr) -> HSOEffects {
     |   let effects = HSOEffects::new()
     |   match instr {
     |     TStructNew(_, _) | TStructNewDefault(_) => {
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
 430 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     |   effects
     | }
     …

     | fn hso_shallow_new_invalidates_set_value(
     |   new_effects : HSOEffects,
     |   set_value_effects : HSOEffects,
     | ) -> Bool {
     |   if (new_effects.reads_memory && set_value_effects.writes_memory) ||
     |     (new_effects.writes_memory && set_value_effects.reads_memory) ||
     |     (new_effects.writes_memory && set_value_effects.writes_memory) {
     |     return true
     |   }
     |   if (new_effects.reads_globals && set_value_effects.writes_globals) ||
     |     (new_effects.writes_globals && set_value_effects.reads_globals) ||
     |     (new_effects.writes_globals && set_value_effects.writes_globals) {
 448 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if set_value_effects.calls &&
     |     (
     |       new_effects.reads_memory ||
     |       new_effects.writes_memory ||
     |       new_effects.reads_globals ||
     |       new_effects.writes_globals
     |     ) {
     |     return true
     |   }
     |   if new_effects.traps && set_value_effects.has_non_control_side_effects() {
     |     return true
     |   }
     |   false
     | }
     …

     | fn hso_try_fold_into_new(
     |   env : Env,
     |   new_value : TInstr,
     |   set_type_idx : TypeIdx,
     |   field_idx : @lib.U32,
     |   set_value : TInstr,
     |   ref_local_idx : LocalIdx,
     |   set_value_effects : HSOEffects,
     |   can_skip_local_set : Bool,
     | ) -> TInstr? {
     |   let (new_type_idx, fields, operands) = match new_value {
     |     TStructNew(type_idx, ops) =>
     |       match env.resolve_struct_fields(type_idx) {
     |         Ok(fs) =>
     |           if fs.length() != ops.length() {
 481 |             return None
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else {
     |             (type_idx, fs, ops.copy())
     |           }
 485 |         Err(_) => return None
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TStructNewDefault(type_idx) =>
     |       match env.resolve_struct_fields(type_idx) {
     |         Ok(fs) => {
     |           let defaults : Array[TInstr] = []
     |           for field in fs {
     |             match hso_struct_field_default(field) {
     |               Some(value) => defaults.push(value)
 494 |               None => return None
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           (type_idx, fs, defaults)
     |         }
 499 |         Err(_) => return None
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 501 |     _ => return None
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if new_type_idx != set_type_idx {
 504 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let index = hso_u32_to_int(field_idx)
     |   if index < 0 || index >= operands.length() || index >= fields.length() {
 508 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if set_value_effects.locals_read.contains(ref_local_idx) ||
     |     set_value_effects.locals_written.contains(ref_local_idx) {
     |     return None
     |   }
     |   if set_value_effects.transfers_control_flow() && !can_skip_local_set {
     |     return None
     |   }
     |   if hso_shallow_new_invalidates_set_value(
     |       hso_collect_shallow_new_effects(new_value),
     |       set_value_effects,
     |     ) {
     |     return None
     |   }
     |   for i = index + 1; i < operands.length(); i = i + 1 {
     |     let operand_effects = hso_collect_effects(operands[i])
     |     if operand_effects.invalidates(set_value_effects) {
     |       return None
     |     }
     |   }
     |   let old_value_effects = hso_collect_effects(operands[index])
     |   if old_value_effects.has_unremovable_side_effects() {
     |     operands[index] = TInstr::block(
     |       BlockType::val_type(fields[index].unpack()),
     |       TExpr::new([TInstr::drop(operands[index]), set_value]),
     |     )
     |   } else {
     |     operands[index] = set_value
     |   }
     |   Some(TInstr::struct_new(new_type_idx, operands))
     | }
     …

     | fn hso_optimize_block_list(list : Array[TInstr], env : Env) -> Bool {
     |   let mut changed = false
     |   for i = 0; i < list.length(); i = i + 1 {
     |     let (local_idx, local_value) = match list[i] {
     |       TLocalSet(idx, value) if hso_is_struct_new_like(value) => (idx, value)
     |       _ => continue
     |     }
     |     let mut local_set_index = i
     |     let mut current_new = local_value
     |     let mut j = local_set_index + 1
     |     while j < list.length() {
     |       let matched = match list[j] {
     |         TStructSet(set_type_idx, field_idx, TLocalGet(get_idx), set_value) =>
     |           if get_idx == local_idx {
     |             Some((set_type_idx, field_idx, set_value))
     |           } else {
 558 |             None
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         _ => None
     |       }
     |       match matched {
     |         Some((set_type_idx, field_idx, set_value)) => {
     |           let set_value_effects = hso_collect_effects(set_value)
     |           let can_skip_local_set = !set_value_effects.transfers_control_flow() ||
     |             hso_can_skip_local_set(list, local_set_index, j, local_idx)
     |           match
     |             hso_try_fold_into_new(
     |               env, current_new, set_type_idx, field_idx, set_value, local_idx, set_value_effects,
     |               can_skip_local_set,
     |             ) {
     |             Some(updated_new) => {
     |               current_new = updated_new
     |               list[local_set_index] = TInstr::local_set(local_idx, current_new)
     |               list[j] = TInstr::nop()
     |               changed = true
     |               j += 1
     |             }
     |             None => break
     |           }
     |         }
     |         None => {
     |           if hso_try_swap(list, local_set_index, j) {
     |             local_set_index = j
     |             changed = true
     |             j = local_set_index + 1
     |             continue
     |           }
     |           break
     |         }
     |       }
     |     }
     |   }
     |   if changed {
     |     hso_compact_nops(list)
     |   }
     |   changed
     | }
     …

     | fn hso_rewrite_tinstruction(
     |   transformer : ModuleTransformer[HSOState],
     |   state : HSOState,
     |   instr : TInstr,
     | ) -> TransformerResult[HSOState, TInstr] {
     |   let (state_after_walk, walked, walk_changed) = match
     |     transformer.walk_tinstruction_default(state, instr) {
     |     Ok(Some((next_state, next_instr))) => (next_state, next_instr, true)
     |     Ok(None) => (state, instr, false)
 610 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match walked {
     |     TStructSet(
     |       set_type_idx,
     |       field_idx,
     |       TLocalTee(local_idx, new_value),
     |       set_value
     |     ) => {
     |       let set_value_effects = hso_collect_effects(set_value)
     |       let can_skip_local_set = !set_value_effects.transfers_control_flow()
     |       match
     |         hso_try_fold_into_new(
     |           state_after_walk.env,
     |           new_value,
     |           set_type_idx,
     |           field_idx,
     |           set_value,
     |           local_idx,
     |           set_value_effects,
     |           can_skip_local_set,
     |         ) {
     |         Some(updated_new) =>
     |           change(state_after_walk, TInstr::local_set(local_idx, updated_new))
     |         None =>
 635 |           if walk_changed {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change(state_after_walk, walked)
     |           } else {
 638 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     }
     |     _ =>
     |       if walk_changed {
     |         change(state_after_walk, walked)
     |       } else {
     |         unchanged()
     |       }
     |   }
     | }
     …

     | fn hso_rewrite_texpr(
     |   transformer : ModuleTransformer[HSOState],
     |   state : HSOState,
     |   expr : TExpr,
     | ) -> TransformerResult[HSOState, TExpr] {
     |   let TExpr(instrs) = expr
     |   let rewritten : Array[TInstr] = []
     |   let mut changed = false
     |   let mut curr_state = state
     |   for instr in instrs {
     |     match transformer.walk_tinstruction(curr_state, instr) {
     |       Ok(Some((next_state, next_instr))) => {
     |         curr_state = next_state
     |         rewritten.push(next_instr)
     |         changed = true
     |       }
     |       Ok(None) => rewritten.push(instr)
 669 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if hso_optimize_block_list(rewritten, curr_state.env) {
     |     changed = true
     |   }
     |   if changed {
     |     change(curr_state, TExpr::new(rewritten))
     |   } else {
     |     unchanged()
     |   }
     | }
     …

     | fn heap_store_optimization_ir_pass(
     |   mod : Module,
     | ) -> ModuleTransformer[IRContext] {
     |   let env = Env::new().with_module(mod)
     |   let pass = ModuleTransformer::new()
     |     .on_texpr_evt(hso_rewrite_texpr)
     |     .on_tinstruction_evt(hso_rewrite_tinstruction)
     |   ModuleTransformer::new().on_func_evt(fn(_, ctx, func) {
     |     match func {
     |       TFunc(locals, body) => {
     |         let state = { env: env.with_locals(locals) }
     |         match pass.walk_texpr(state, body) {
     |           Ok(Some((_, new_body))) => change(ctx, Func::t_func(locals, new_body))
 696 |           Ok(None) => unchanged()
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => Err(e)
     |         }
     |       }
 700 |       _ => unchanged()
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

     | fn run_heap_store_optimization(mod : Module) -> Module {
     |   let pass = heap_store_optimization_ir_pass(mod)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
 710 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

201 uncovered line(s) in src/passes/i64_to_i32_lowering.mbt:

     | fn i64l_lower_valtype(vt : ValType) -> Array[ValType] {
     |   if i64l_is_i64(vt) {
     |     [ValType::i32(), ValType::i32()]
     |   } else {
  35 |     [vt]
     |     ^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn i64l_count_imported_globals(mod : Module) -> UInt {
     |   let mut n : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, GlobalExternType(_)) => n += 1
  88 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn i64l_count_imported_funcs(mod : Module) -> UInt {
     |   let mut n : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
 103 |           Import(_, _, FuncExternType(_)) => n += 1
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn i64l_first_memory_limits(mod : Module) -> Limits? {
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 116 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, MemExternType(MemType(limits))) => return Some(limits)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.mem_sec {
     |     Some(MemSec(mems)) =>
 126 |       match mems {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         [MemType(limits), ..] => Some(limits)
     |         _ => None
     |       }
     |     None => None
     |   }
     | }
     …

     | fn i64l_has_any_memory(mod : Module) -> Bool {
     |   match i64l_first_memory_limits(mod) {
 137 |     Some(_) => true
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => false
     |   }
     | }
     …

     | fn i64l_default_mem_is_i64(mod : Module) -> Bool {
     |   match i64l_first_memory_limits(mod) {
 145 |     Some(I64Limits(_, _)) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn i64l_collect_old_type_func_types(mod : Module) -> Map[TypeIdx, FuncType] {
     |   let out : Map[TypeIdx, FuncType] = Map::new()
     |   let mut next : UInt = 0
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) =>
     |       for rec in recs {
     |         match rec {
     |           SingleRecType(st) => {
     |             match st.get_comptype() {
     |               FuncCompType(params, results) =>
     |                 out[TypeIdx::new(next)] = FuncType::new(params, results)
 170 |               _ => ()
     |               ^^^^^^^ 	<-- UNCOVERED
     |             }
     |             next += 1
     |           }
     |           GroupRecType(sts) =>
 175 |             for st in sts {
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match st.get_comptype() {
     |                 FuncCompType(params, results) =>
 178 |                   out[TypeIdx::new(next)] = FuncType::new(params, results)
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 _ => ()
     |               }
     |               next += 1
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn i64l_collect_old_func_types(mod : Module) -> Map[FuncIdx, FuncType] {
     |   let env = Env::new().with_module(mod)
     |   let out : Map[FuncIdx, FuncType] = Map::new()
     |   let imported_funcs = i64l_count_imported_funcs(mod)
     |   let mut idx : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
 200 |           Import(_, _, FuncExternType(_)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let fi = FuncIdx::new(idx)
     |             match env.get_functype_by_funcidx(fi) {
     |               Some(ft) => out[fi] = ft
     |               None => out[fi] = FuncType::new([], [])
     |             }
     |             idx += 1
     |           }
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for i = 0; i < funcs.length(); i = i + 1 {
     |         let fi = FuncIdx::new(imported_funcs + i.reinterpret_as_uint())
     |         match env.get_functype_by_funcidx(fi) {
     |           Some(ft) => out[fi] = ft
     |           None => out[fi] = FuncType::new([], [])
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn i64l_lower_type_sec(mod : Module) -> Result[Module, String] {
     |   match mod.type_sec {
     |     None => Ok(mod)
     |     Some(TypeSec(recs)) => {
     |       let new_recs : Array[RecType] = []
     |       for rec in recs {
     |         match rec {
     |           SingleRecType(st) => {
     |             let new_st = match st {
     |               CompTypeSubType(ct) =>
     |                 match ct {
     |                   FuncCompType(params, results) =>
     |                     match i64l_lower_func_type(FuncType::new(params, results)) {
     |                       Ok(FuncType(new_params, new_results)) =>
     |                         SubType::comp_type(
     |                           CompType::func(new_params, new_results),
     |                         )
     |                       Err(e) => return Err(e)
     |                     }
 247 |                   _ => st
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               SubType(final_, supers, ct) =>
 250 |                 match ct {
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |                   FuncCompType(params, results) =>
 252 |                     match i64l_lower_func_type(FuncType::new(params, results)) {
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       Ok(FuncType(new_params, new_results)) =>
 254 |                         SubType::new(
     |                         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           final_,
     |                           supers,
 257 |                           CompType::func(new_params, new_results),
     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         )
 259 |                       Err(e) => return Err(e)
     |                       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     }
 261 |                   _ => st
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                 }
     |             }
     |             new_recs.push(RecType::new(new_st))
     |           }
 266 |           GroupRecType(sts) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let lowered_group : Array[SubType] = []
     |             for st in sts {
 269 |               let new_st = match st {
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 CompTypeSubType(ct) =>
 271 |                   match ct {
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                     FuncCompType(params, results) =>
 273 |                       match
     |                       ^^^^^ 	<-- UNCOVERED
     |                         i64l_lower_func_type(FuncType::new(params, results)) {
     |                         Ok(FuncType(new_params, new_results)) =>
 276 |                           SubType::comp_type(
     |                           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                             CompType::func(new_params, new_results),
     |                           )
 279 |                         Err(e) => return Err(e)
     |                         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
 281 |                     _ => st
     |                     ^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 SubType(final_, supers, ct) =>
 284 |                   match ct {
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                     FuncCompType(params, results) =>
 286 |                       match
     |                       ^^^^^ 	<-- UNCOVERED
     |                         i64l_lower_func_type(FuncType::new(params, results)) {
     |                         Ok(FuncType(new_params, new_results)) =>
 289 |                           SubType::new(
     |                           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                             final_,
     |                             supers,
 292 |                             CompType::func(new_params, new_results),
     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           )
 294 |                         Err(e) => return Err(e)
     |                         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
 296 |                     _ => st
     |                     ^^^^^^^ 	<-- UNCOVERED
     |                   }
     |               }
 299 |               lowered_group.push(new_st)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
 301 |             new_recs.push(RecType::group(lowered_group))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |       Ok(mod.with_type_sec(TypeSec::new(new_recs)))
     |     }
     |   }
     | }
     …

     | fn i64l_min_align_4(align : @lib.U32) -> @lib.U32 {
     |   let @lib.U32(a) = align
     |   if a > 4 {
     |     @lib.U32(4)
     |   } else {
 337 |     @lib.U32(a)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn i64l_lower_i64_load_op(op : LoadOp) -> (LoadOp, Bool)? {
     |   // (low_op, sign_extend_high_from_low)
     |   match op {
     |     I64LoadOp => Some((LoadOp::i32_load(), false))
 346 |     I64Load8SOp => Some((LoadOp::i32_load8s(), true))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64Load8UOp => Some((LoadOp::i32_load8u(), false))
     |     I64Load16SOp => Some((LoadOp::i32_load16s(), true))
     |     I64Load16UOp => Some((LoadOp::i32_load16u(), false))
     |     I64Load32SOp => Some((LoadOp::i32_load(), true))
     |     I64Load32UOp => Some((LoadOp::i32_load(), false))
     |     _ => None
     |   }
     | }
     …

     | fn i64l_old_typeidx_result_is_i64(ctx : I64LFuncCtx, tidx : TypeIdx) -> Bool {
     |   match ctx.info.old_type_func_types.get(tidx) {
     |     Some(FuncType(_, [vt])) => i64l_is_i64(vt)
 368 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn i64l_mem_zero_ptr(ctx : I64LFuncCtx) -> TInstr {
     |   if ctx.info.default_mem_is_i64 {
 409 |     TInstr::i64_const(I64(0L))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     TInstr::i32_const(I32(0))
     |   }
     | }
     …

     | fn i64l_old_instr_is_i64(ctx : I64LFuncCtx, instr : TInstr) -> Bool {
     |   match instr {
     |     TI64Const(_) => true
     |     TLocalGet(idx) =>
     |       match ctx.high_map[i64l_local_to_int(idx)] {
     |         Some(_) => true
 422 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TLocalTee(idx, _) =>
 425 |       match ctx.high_map[i64l_local_to_int(idx)] {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(_) => true
     |         None => false
     |       }
     |     TGlobalGet(idx) =>
 430 |       match ctx.info.i64_global_hi.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(_) => true
     |         None => false
     |       }
     |     TLoad(op, _, _) =>
 435 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I64LoadOp
     |         | I64Load8SOp
     |         | I64Load8UOp
     |         | I64Load16SOp
     |         | I64Load16UOp
     |         | I64Load32SOp
 442 |         | I64Load32UOp => true
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => false
     |       }
     |     TCall(target, _) =>
 446 |       match ctx.info.old_func_types.get(target) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(ft) => i64l_is_i64_result(ft)
     |         None => false
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 451 |       match ctx.info.old_type_func_types.get(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(ft) => i64l_is_i64_result(ft)
     |         None => false
     |       }
     |     TUnary(op, _) =>
 456 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I64ClzOp
     |         | I64CtzOp
     |         | I64PopcntOp
     |         | I64ExtendI32SOp
     |         | I64ExtendI32UOp
     |         | I64TruncF32SOp
     |         | I64TruncF32UOp
     |         | I64TruncF64SOp
     |         | I64TruncF64UOp
     |         | I64ReinterpretF64Op
     |         | I64Extend8SOp
     |         | I64Extend16SOp
     |         | I64Extend32SOp
     |         | I64TruncSatF32SOp
     |         | I64TruncSatF32UOp
     |         | I64TruncSatF64SOp
 473 |         | I64TruncSatF64UOp => true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => false
     |       }
     |     TBinary(op, _, _) =>
     |       match op {
     |         I64AddOp
     |         | I64SubOp
     |         | I64MulOp
     |         | I64DivSOp
     |         | I64DivUOp
     |         | I64RemSOp
     |         | I64RemUOp
     |         | I64AndOp
     |         | I64OrOp
     |         | I64XorOp
     |         | I64ShlOp
     |         | I64ShrSOp
     |         | I64ShrUOp
     |         | I64RotlOp
     |         | I64RotrOp => true
 493 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 495 |     TSelect(Some([vt]), _, _, _) => i64l_is_i64(vt)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TSelect(None, _, if_true, _) => i64l_old_instr_is_i64(ctx, if_true)
     |     TBlock(bt, _) | TLoop(bt, _) | TIf(bt, _, _, _) | TTryTable(bt, _, _) =>
     |       match bt {
     |         TypeIdxBlockType(tidx) => i64l_old_typeidx_result_is_i64(ctx, tidx)
 500 |         _ => i64l_type_is_i64_block(bt)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => false
     |   }
     | }
     …

     | fn i64l_build_udivrem(
     |   ctx : I64LFuncCtx,
     |   prefix : Array[TInstr],
     |   n_lo : LocalIdx,
     |   n_hi : LocalIdx,
     |   d_lo : LocalIdx,
     |   d_hi : LocalIdx,
     |   return_rem : Bool,
     | ) -> TInstr {
     |   let q_lo = i64l_alloc_temp(ctx, ValType::i32())
     |   let q_hi = i64l_alloc_temp(ctx, ValType::i32())
     |   let r_lo = i64l_alloc_temp(ctx, ValType::i32())
     |   let r_hi = i64l_alloc_temp(ctx, ValType::i32())
     |   let sub_lo = i64l_alloc_temp(ctx, ValType::i32())
     |   let borrow = i64l_alloc_temp(ctx, ValType::i32())
     |   let sub_hi = i64l_alloc_temp(ctx, ValType::i32())
     |   let out = prefix.copy()
     |   i64l_emit_udivrem_core(
     |     out, n_lo, n_hi, d_lo, d_hi, q_lo, q_hi, r_lo, r_hi, sub_lo, borrow, sub_hi,
     |   )
     |   if return_rem {
 757 |     out.push(i64l_stash_set(ctx, TInstr::local_get(r_hi)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     out.push(TInstr::local_get(r_lo))
     |   } else {
     |     out.push(i64l_stash_set(ctx, TInstr::local_get(q_hi)))
     |     out.push(TInstr::local_get(q_lo))
     |   }
     |   i64l_make_block_i32(out)
     | }
     …

     | fn i64l_lower_call_args(
     |   args : Array[TInstr],
     |   params : Array[ValType],
     |   ctx : I64LFuncCtx,
     | ) -> Result[Array[TInstr], String] {
     |   if args.length() != params.length() {
1077 |     return Err("i64_to_i32_lowering: call arg/param length mismatch")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let out : Array[TInstr] = []
     |   for i = 0; i < args.length(); i = i + 1 {
     |     let arg = args[i]
     |     let param = params[i]
     |     if i64l_is_i64(param) {
     |       out.push(arg)
     |       out.push(i64l_stash_get(ctx))
     |     } else {
1087 |       out.push(arg)
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(out)
     | }
     …

     | fn i64l_rewrite_tinstruction(
     |   transformer : ModuleTransformer[I64LFuncCtx],
     |   ctx : I64LFuncCtx,
     |   instr : TInstr,
     | ) -> TransformerResult[I64LFuncCtx, TInstr] {
     |   let walked = match transformer.walk_tinstruction_default(ctx, instr) {
     |     Ok(Some((next_ctx, next_instr))) => (next_ctx, next_instr)
     |     Ok(None) => (ctx, instr)
1108 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (ctx, curr) = walked
     |   let rewritten = match curr {
     |     TI64Const(value) => {
     |       let (low, high) = i64l_split_i64_literal(value)
     |       i64l_pack_i64(
     |         ctx,
     |         TInstr::i32_const(I32(low)),
     |         TInstr::i32_const(I32(high)),
     |       )
     |     }
     |     TLocalGet(old_idx) => {
     |       let i = i64l_local_to_int(old_idx)
     |       let low_idx = ctx.low_map[i]
     |       match ctx.high_map[i] {
     |         Some(high_idx) =>
     |           i64l_make_block_i32([
     |             i64l_stash_set(ctx, TInstr::local_get(high_idx)),
     |             TInstr::local_get(low_idx),
     |           ])
     |         None =>
1130 |           if low_idx == old_idx {
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             curr
     |           } else {
1133 |             TInstr::local_get(low_idx)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     }
     |     TLocalSet(old_idx, value) => {
     |       let i = i64l_local_to_int(old_idx)
     |       let low_idx = ctx.low_map[i]
     |       match ctx.high_map[i] {
     |         Some(high_idx) =>
     |           i64l_make_block_void([
     |             TInstr::local_set(low_idx, value),
     |             TInstr::local_set(high_idx, i64l_stash_get(ctx)),
     |           ])
     |         None =>
1147 |           if low_idx == old_idx {
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             curr
     |           } else {
1150 |             TInstr::local_set(low_idx, value)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     }
1154 |     TLocalTee(old_idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let i = i64l_local_to_int(old_idx)
     |       let low_idx = ctx.low_map[i]
1157 |       match ctx.high_map[i] {
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(high_idx) => {
     |           let tee_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_i32([
     |             TInstr::local_set(tee_tmp, TInstr::local_tee(low_idx, value)),
     |             TInstr::local_set(high_idx, i64l_stash_get(ctx)),
     |             TInstr::local_get(tee_tmp),
     |           ])
     |         }
     |         None =>
1167 |           if low_idx == old_idx {
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             curr
     |           } else {
1170 |             TInstr::local_tee(low_idx, value)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     }
     |     TGlobalGet(idx) =>
     |       match ctx.info.i64_global_hi.get(idx) {
     |         Some(hi_idx) =>
     |           i64l_make_block_i32([
     |             i64l_stash_set(ctx, TInstr::global_get(hi_idx)),
     |             TInstr::global_get(idx),
     |           ])
1181 |         None => curr
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TGlobalSet(idx, value) =>
     |       match ctx.info.i64_global_hi.get(idx) {
     |         Some(hi_idx) =>
     |           i64l_make_block_void([
     |             TInstr::global_set(idx, value),
     |             TInstr::global_set(hi_idx, i64l_stash_get(ctx)),
     |           ])
1190 |         None => curr
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TCall(target, args) =>
     |       match ctx.info.old_func_types.get(target) {
     |         Some(ft) => {
     |           let FuncType(params, _) = ft
     |           let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |             Ok(a) => a
1198 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let call = TInstr::call(target, lowered_args)
     |           if i64l_is_i64_result(ft) {
     |             let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |             i64l_make_block_i32([
     |               TInstr::local_set(low_tmp, call),
     |               i64l_stash_set(
     |                 ctx,
     |                 TInstr::global_get(ctx.info.return_high_global),
     |               ),
     |               TInstr::local_get(low_tmp),
     |             ])
     |           } else {
1212 |             call
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         None =>
1216 |           return Err("i64_to_i32_lowering: missing function signature for call")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TCallIndirect(type_idx, table_idx, args, target) =>
     |       match ctx.info.old_type_func_types.get(type_idx) {
     |         Some(ft) => {
     |           let FuncType(params, _) = ft
     |           let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |             Ok(a) => a
1224 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let call = TInstr::call_indirect(
     |             type_idx, table_idx, lowered_args, target,
     |           )
     |           if i64l_is_i64_result(ft) {
     |             let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |             i64l_make_block_i32([
     |               TInstr::local_set(low_tmp, call),
     |               i64l_stash_set(
     |                 ctx,
     |                 TInstr::global_get(ctx.info.return_high_global),
     |               ),
     |               TInstr::local_get(low_tmp),
     |             ])
     |           } else {
1240 |             call
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         None =>
1244 |           return Err("i64_to_i32_lowering: missing indirect call signature")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TCallRef(type_idx, args, ref_) =>
     |       match ctx.info.old_type_func_types.get(type_idx) {
     |         Some(ft) => {
     |           let FuncType(params, _) = ft
     |           let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |             Ok(a) => a
1252 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let call = TInstr::call_ref(type_idx, lowered_args, ref_)
     |           if i64l_is_i64_result(ft) {
     |             let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |             i64l_make_block_i32([
     |               TInstr::local_set(low_tmp, call),
     |               i64l_stash_set(
     |                 ctx,
     |                 TInstr::global_get(ctx.info.return_high_global),
     |               ),
     |               TInstr::local_get(low_tmp),
     |             ])
     |           } else {
1266 |             call
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |         }
1269 |         None => return Err("i64_to_i32_lowering: missing call_ref signature")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TReturnCall(target, args) =>
     |       match ctx.info.old_func_types.get(target) {
     |         Some(ft) =>
     |           if i64l_is_i64_result(ft) {
     |             let FuncType(params, _) = ft
     |             let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |               Ok(a) => a
1278 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |             i64l_make_block_void([
     |               TInstr::local_set(low_tmp, TInstr::call(target, lowered_args)),
     |               TInstr::return_([TInstr::local_get(low_tmp)]),
     |             ])
     |           } else {
1286 |             let FuncType(params, _) = ft
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |               Ok(a) => a
     |               Err(e) => return Err(e)
     |             }
1291 |             TInstr::return_call(target, lowered_args)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1293 |         None => return Err("i64_to_i32_lowering: missing return_call signature")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TReturnCallIndirect(type_idx, table_idx, args, target) =>
     |       match ctx.info.old_type_func_types.get(type_idx) {
     |         Some(ft) =>
     |           if i64l_is_i64_result(ft) {
     |             let FuncType(params, _) = ft
     |             let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |               Ok(a) => a
1302 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |             i64l_make_block_void([
     |               TInstr::local_set(
     |                 low_tmp,
     |                 TInstr::call_indirect(type_idx, table_idx, lowered_args, target),
     |               ),
     |               TInstr::return_([TInstr::local_get(low_tmp)]),
     |             ])
     |           } else {
1313 |             let FuncType(params, _) = ft
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |               Ok(a) => a
     |               Err(e) => return Err(e)
     |             }
1318 |             TInstr::return_call_indirect(
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               type_idx, table_idx, lowered_args, target,
     |             )
     |           }
     |         None =>
1323 |           return Err(
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             "i64_to_i32_lowering: missing return_call_indirect signature",
     |           )
     |       }
     |     TReturnCallRef(type_idx, args, ref_) =>
     |       match ctx.info.old_type_func_types.get(type_idx) {
     |         Some(ft) =>
     |           if i64l_is_i64_result(ft) {
     |             let FuncType(params, _) = ft
     |             let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |               Ok(a) => a
1334 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |             i64l_make_block_void([
     |               TInstr::local_set(
     |                 low_tmp,
     |                 TInstr::call_ref(type_idx, lowered_args, ref_),
     |               ),
     |               TInstr::return_([TInstr::local_get(low_tmp)]),
     |             ])
     |           } else {
1345 |             let FuncType(params, _) = ft
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let lowered_args = match i64l_lower_call_args(args, params, ctx) {
     |               Ok(a) => a
     |               Err(e) => return Err(e)
     |             }
1350 |             TInstr::return_call_ref(type_idx, lowered_args, ref_)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         None =>
1353 |           return Err("i64_to_i32_lowering: missing return_call_ref signature")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TLoad(op, memarg, ptr) =>
     |       match i64l_lower_i64_load_op(op) {
     |         Some((low_op, sign_high)) => {
     |           let MemArg(align, memidx, offset_raw) = memarg
     |           let @lib.U64(offset) = offset_raw
     |           let ptr_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let high_expr = match op {
     |             I64LoadOp =>
     |               TInstr::load(
     |                 LoadOp::i32_load(),
     |                 MemArg::new(
     |                   i64l_min_align_4(align),
     |                   memidx,
     |                   @lib.U64(offset + 4),
     |                 ),
     |                 TInstr::local_get(ptr_tmp),
     |               )
     |             _ =>
1374 |               if sign_high {
     |               ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::binary(
     |                   BinaryOp::i32_shr_s(),
     |                   TInstr::local_get(low_tmp),
     |                   TInstr::i32_const(I32(31)),
     |                 )
     |               } else {
1381 |                 TInstr::i32_const(I32(0))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |           i64l_make_block_i32([
     |             TInstr::local_set(ptr_tmp, ptr),
     |             TInstr::local_set(
     |               low_tmp,
     |               TInstr::load(
     |                 low_op,
     |                 MemArg::new(i64l_min_align_4(align), memidx, @lib.U64(offset)),
     |                 TInstr::local_get(ptr_tmp),
     |               ),
     |             ),
     |             i64l_stash_set(ctx, high_expr),
     |             TInstr::local_get(low_tmp),
     |           ])
     |         }
1398 |         None => curr
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TStore(store_op, memarg, ptr, value) =>
     |       match store_op {
     |         I64StoreOp => {
     |           let MemArg(align, memidx, offset_raw) = memarg
     |           let @lib.U64(offset) = offset_raw
     |           let ptr_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_void([
     |             TInstr::local_set(ptr_tmp, ptr),
     |             TInstr::store(
     |               StoreOp::i32_store(),
     |               MemArg::new(i64l_min_align_4(align), memidx, @lib.U64(offset)),
     |               TInstr::local_get(ptr_tmp),
     |               value,
     |             ),
     |             TInstr::store(
     |               StoreOp::i32_store(),
     |               MemArg::new(i64l_min_align_4(align), memidx, @lib.U64(offset + 4)),
     |               TInstr::local_get(ptr_tmp),
     |               i64l_stash_get(ctx),
     |             ),
     |           ])
     |         }
1422 |         I64Store32Op => TInstr::store(StoreOp::i32_store(), memarg, ptr, value)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         I64Store16Op =>
1424 |           TInstr::store(StoreOp::i32_store16(), memarg, ptr, value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         I64Store8Op => TInstr::store(StoreOp::i32_store8(), memarg, ptr, value)
     |         _ => curr
     |       }
     |     TUnary(op, value) =>
     |       match op {
     |         I64EqzOp =>
1431 |           TInstr::unary(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             UnaryOp::i32_eqz(),
     |             TInstr::binary(BinaryOp::i32_or(), value, i64l_stash_get(ctx)),
     |           )
1435 |         I64ExtendI32UOp => i64l_pack_i64(ctx, value, TInstr::i32_const(I32(0)))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         I64ExtendI32SOp => {
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_i32([
     |             TInstr::local_set(low_tmp, value),
     |             i64l_stash_set(
     |               ctx,
1442 |               TInstr::binary(
     |               ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_shr_s(),
     |                 TInstr::local_get(low_tmp),
     |                 TInstr::i32_const(I32(31)),
     |               ),
     |             ),
1448 |             TInstr::local_get(low_tmp),
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ])
     |         }
1451 |         I32WrapI64Op => value
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         I64Extend8SOp => {
     |           let low = TInstr::unary(UnaryOp::i32_extend8s(), value)
     |           i64l_pack_i64(
     |             ctx,
     |             low,
1457 |             TInstr::binary(
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               BinaryOp::i32_shr_s(),
     |               low,
1460 |               TInstr::i32_const(I32(31)),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
1464 |         I64Extend16SOp => {
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let low = TInstr::unary(UnaryOp::i32_extend16s(), value)
     |           i64l_pack_i64(
     |             ctx,
     |             low,
1469 |             TInstr::binary(
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               BinaryOp::i32_shr_s(),
     |               low,
1472 |               TInstr::i32_const(I32(31)),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
     |         I64Extend32SOp =>
1477 |           i64l_pack_i64(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ctx,
     |             value,
1480 |             TInstr::binary(
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               BinaryOp::i32_shr_s(),
     |               value,
1483 |               TInstr::i32_const(I32(31)),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
1486 |         I64ClzOp => {
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_i32([
     |             TInstr::local_set(low_tmp, value),
     |             TInstr::local_set(high_tmp, i64l_stash_get(ctx)),
     |             TInstr::if_(
     |               BlockType::val_type(ValType::i32()),
     |               TInstr::binary(
     |                 BinaryOp::i32_eq(),
     |                 TInstr::local_get(high_tmp),
     |                 TInstr::i32_const(I32(0)),
     |               ),
1499 |               TExpr::new([
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::binary(
     |                   BinaryOp::i32_add(),
     |                   TInstr::unary(UnaryOp::i32_clz(), TInstr::local_get(low_tmp)),
     |                   TInstr::i32_const(I32(32)),
     |                 ),
     |               ]),
     |               Some(
1507 |                 TExpr::new([
     |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   TInstr::unary(UnaryOp::i32_clz(), TInstr::local_get(high_tmp)),
     |                 ]),
     |               ),
     |             ),
     |           ])
     |         }
     |         I64CtzOp => {
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_i32([
     |             TInstr::local_set(low_tmp, value),
     |             TInstr::local_set(high_tmp, i64l_stash_get(ctx)),
     |             i64l_stash_set(ctx, TInstr::i32_const(I32(0))),
     |             TInstr::if_(
     |               BlockType::val_type(ValType::i32()),
     |               TInstr::binary(
     |                 BinaryOp::i32_ne(),
     |                 TInstr::local_get(low_tmp),
     |                 TInstr::i32_const(I32(0)),
     |               ),
     |               TExpr::new([
     |                 TInstr::unary(UnaryOp::i32_ctz(), TInstr::local_get(low_tmp)),
     |               ]),
     |               Some(
     |                 TExpr::new([
     |                   TInstr::binary(
     |                     BinaryOp::i32_add(),
     |                     TInstr::unary(
     |                       UnaryOp::i32_ctz(),
     |                       TInstr::local_get(high_tmp),
     |                     ),
     |                     TInstr::i32_const(I32(32)),
     |                   ),
     |                 ]),
     |               ),
     |             ),
     |           ])
     |         }
     |         I64PopcntOp => {
     |           let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_i32([
     |             TInstr::local_set(high_tmp, i64l_stash_get(ctx)),
     |             i64l_stash_set(ctx, TInstr::i32_const(I32(0))),
     |             TInstr::binary(
     |               BinaryOp::i32_add(),
     |               TInstr::unary(UnaryOp::i32_popcnt(), value),
     |               TInstr::unary(UnaryOp::i32_popcnt(), TInstr::local_get(high_tmp)),
     |             ),
     |           ])
     |         }
     |         I64TruncF32SOp
     |         | I64TruncF32UOp
     |         | I64TruncF64SOp
     |         | I64TruncF64UOp
     |         | I64TruncSatF32SOp
     |         | I64TruncSatF32UOp
     |         | I64TruncSatF64SOp
     |         | I64TruncSatF64UOp => {
     |           let is_f32 = match op {
     |             I64TruncF32SOp
     |             | I64TruncF32UOp
     |             | I64TruncSatF32SOp
     |             | I64TruncSatF32UOp => true
     |             _ => false
     |           }
     |           let is_sat = match op {
     |             I64TruncSatF32SOp
     |             | I64TruncSatF32UOp
     |             | I64TruncSatF64SOp
     |             | I64TruncSatF64UOp => true
     |             _ => false
     |           }
     |           let tmp_ty = if is_f32 { ValType::f32() } else { ValType::f64() }
     |           let f_tmp = i64l_alloc_temp(ctx, tmp_ty)
     |           let trunc_u = if is_f32 {
     |             if is_sat {
     |               UnaryOp::i32_trunc_sat_f32u()
     |             } else {
1586 |               UnaryOp::i32_trunc_f32u()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           } else if is_sat {
     |             UnaryOp::i32_trunc_sat_f64u()
     |           } else {
     |             UnaryOp::i32_trunc_f64u()
     |           }
     |           let convert_u = if is_f32 {
     |             UnaryOp::f32_convert_i32u()
     |           } else {
     |             UnaryOp::f64_convert_i32u()
     |           }
     |           let abs_op = if is_f32 {
     |             UnaryOp::f32_abs()
     |           } else {
     |             UnaryOp::f64_abs()
     |           }
     |           let floor_op = if is_f32 {
     |             UnaryOp::f32_floor()
     |           } else {
     |             UnaryOp::f64_floor()
     |           }
     |           let ceil_op = if is_f32 {
     |             UnaryOp::f32_ceil()
     |           } else {
     |             UnaryOp::f64_ceil()
     |           }
     |           let ge_op = if is_f32 {
     |             BinaryOp::f32_ge()
     |           } else {
     |             BinaryOp::f64_ge()
     |           }
     |           let gt_op = if is_f32 {
     |             BinaryOp::f32_gt()
     |           } else {
     |             BinaryOp::f64_gt()
     |           }
     |           let min_op = if is_f32 {
     |             BinaryOp::f32_min()
     |           } else {
     |             BinaryOp::f64_min()
     |           }
     |           let div_op = if is_f32 {
     |             BinaryOp::f32_div()
     |           } else {
     |             BinaryOp::f64_div()
     |           }
     |           let sub_op = if is_f32 {
     |             BinaryOp::f32_sub()
     |           } else {
     |             BinaryOp::f64_sub()
     |           }
     |           let lit_zero = if is_f32 {
     |             TInstr::f32_const(F32(0.0))
     |           } else {
     |             TInstr::f64_const(F64(0.0))
     |           }
     |           let lit_one = if is_f32 {
     |             TInstr::f32_const(F32(1.0))
     |           } else {
     |             TInstr::f64_const(F64(1.0))
     |           }
     |           let u32_max = if is_f32 {
     |             TInstr::f32_const(F32(4294967296.0))
     |           } else {
     |             TInstr::f64_const(F64(4294967296.0))
     |           }
     |           let u32_max_minus_one = if is_f32 {
     |             TInstr::f32_const(F32(4294967295.0))
     |           } else {
     |             TInstr::f64_const(F64(4294967295.0))
     |           }
     |           let f_get = TInstr::local_get(f_tmp)
     |           let gt_zero_branch = TInstr::binary(
     |             min_op,
     |             TInstr::unary(floor_op, TInstr::binary(div_op, f_get, u32_max)),
     |             u32_max_minus_one,
     |           )
     |           let lt_zero_branch = TInstr::unary(
     |             ceil_op,
     |             TInstr::binary(
     |               div_op,
     |               TInstr::binary(
     |                 sub_op,
     |                 TInstr::local_get(f_tmp),
     |                 TInstr::unary(
     |                   convert_u,
     |                   TInstr::unary(trunc_u, TInstr::local_get(f_tmp)),
     |                 ),
     |               ),
     |               if is_f32 {
     |                 TInstr::f32_const(F32(4294967296.0))
     |               } else {
     |                 TInstr::f64_const(F64(4294967296.0))
     |               },
     |             ),
     |           )
     |           let high_calc = TInstr::if_(
     |             BlockType::val_type(ValType::i32()),
     |             TInstr::binary(gt_op, TInstr::local_get(f_tmp), lit_zero),
     |             TExpr::new([TInstr::unary(trunc_u, gt_zero_branch)]),
     |             Some(TExpr::new([TInstr::unary(trunc_u, lt_zero_branch)])),
     |           )
     |           let high_val = TInstr::if_(
     |             BlockType::val_type(ValType::i32()),
     |             TInstr::binary(
     |               ge_op,
     |               TInstr::unary(abs_op, TInstr::local_get(f_tmp)),
     |               lit_one,
     |             ),
     |             TExpr::new([high_calc]),
     |             Some(TExpr::new([TInstr::i32_const(I32(0))])),
     |           )
     |           i64l_make_block_i32([
     |             TInstr::local_set(f_tmp, value),
     |             i64l_stash_set(ctx, high_val),
     |             TInstr::unary(trunc_u, TInstr::local_get(f_tmp)),
     |           ])
     |         }
     |         I64ReinterpretF64Op => {
     |           ctx.info.needs_scratch_memory[0] = true
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           i64l_make_block_i32([
     |             TInstr::store(
     |               StoreOp::f64_store(),
     |               MemArg::new(U32(8), None, U64(0)),
     |               i64l_mem_zero_ptr(ctx),
     |               value,
     |             ),
     |             TInstr::local_set(
     |               low_tmp,
     |               TInstr::load(
     |                 LoadOp::i32_load(),
     |                 MemArg::new(U32(4), None, U64(0)),
     |                 i64l_mem_zero_ptr(ctx),
     |               ),
     |             ),
     |             TInstr::local_set(
     |               high_tmp,
     |               TInstr::load(
     |                 LoadOp::i32_load(),
     |                 MemArg::new(U32(4), None, U64(4)),
     |                 i64l_mem_zero_ptr(ctx),
     |               ),
     |             ),
     |             i64l_stash_set(ctx, TInstr::local_get(high_tmp)),
     |             TInstr::local_get(low_tmp),
     |           ])
     |         }
     |         F64ReinterpretI64Op => {
     |           ctx.info.needs_scratch_memory[0] = true
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           TInstr::block(
     |             BlockType::val_type(ValType::f64()),
     |             TExpr::new([
     |               TInstr::local_set(low_tmp, value),
     |               TInstr::local_set(high_tmp, i64l_stash_get(ctx)),
     |               TInstr::store(
     |                 StoreOp::i32_store(),
     |                 MemArg::new(U32(4), None, U64(0)),
     |                 i64l_mem_zero_ptr(ctx),
     |                 TInstr::local_get(low_tmp),
     |               ),
     |               TInstr::store(
     |                 StoreOp::i32_store(),
     |                 MemArg::new(U32(4), None, U64(4)),
     |                 i64l_mem_zero_ptr(ctx),
     |                 TInstr::local_get(high_tmp),
     |               ),
     |               TInstr::load(
     |                 LoadOp::f64_load(),
     |                 MemArg::new(U32(8), None, U64(0)),
     |                 i64l_mem_zero_ptr(ctx),
     |               ),
     |             ]),
     |           )
     |         }
     |         F32ConvertI64SOp
     |         | F32ConvertI64UOp
     |         | F64ConvertI64SOp
     |         | F64ConvertI64UOp => {
     |           let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |           let convert_high = match op {
     |             F32ConvertI64SOp | F64ConvertI64SOp => UnaryOp::f64_convert_i32s()
     |             _ => UnaryOp::f64_convert_i32u()
     |           }
     |           let as_f64 = TInstr::binary(
     |             BinaryOp::f64_add(),
     |             TInstr::unary(
     |               UnaryOp::f64_convert_i32u(),
     |               TInstr::local_get(low_tmp),
     |             ),
     |             TInstr::binary(
     |               BinaryOp::f64_mul(),
     |               TInstr::f64_const(F64(4294967296.0)),
     |               TInstr::unary(convert_high, TInstr::local_get(high_tmp)),
     |             ),
     |           )
     |           let result = match op {
     |             F32ConvertI64SOp | F32ConvertI64UOp =>
     |               TInstr::unary(UnaryOp::f32_demote_f64(), as_f64)
     |             _ => as_f64
     |           }
     |           TInstr::block(
     |             BlockType::val_type(
     |               match op {
     |                 F32ConvertI64SOp | F32ConvertI64UOp => ValType::f32()
     |                 _ => ValType::f64()
     |               },
     |             ),
     |             TExpr::new([
     |               TInstr::local_set(low_tmp, value),
     |               TInstr::local_set(high_tmp, i64l_stash_get(ctx)),
     |               result,
     |             ]),
     |           )
     |         }
1806 |         _ => curr
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TBinary(op, left, right) =>
     |       match op {
     |         I64AddOp
     |         | I64SubOp
     |         | I64MulOp
     |         | I64DivSOp
     |         | I64DivUOp
     |         | I64RemSOp
     |         | I64RemUOp
     |         | I64AndOp
     |         | I64OrOp
     |         | I64XorOp
     |         | I64ShlOp
     |         | I64ShrSOp
     |         | I64ShrUOp
     |         | I64RotlOp
     |         | I64RotrOp
     |         | I64EqOp
     |         | I64NeOp
     |         | I64LtUOp
     |         | I64LeUOp
     |         | I64GtUOp
     |         | I64GeUOp
     |         | I64LtSOp
     |         | I64LeSOp
     |         | I64GtSOp
     |         | I64GeSOp => {
     |           let (left_prefix, left_low, left_high) = i64l_capture_i64_operand(
     |             ctx, left,
     |           )
     |           let (right_prefix, right_low, right_high) = i64l_capture_i64_operand(
     |             ctx, right,
     |           )
     |           let prefix = left_prefix.copy()
     |           for i in right_prefix {
     |             prefix.push(i)
     |           }
     |           match op {
     |             I64AddOp => {
     |               let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let result = prefix.copy()
     |               result.push(
     |                 TInstr::local_set(
     |                   low_tmp,
     |                   TInstr::binary(
     |                     BinaryOp::i32_add(),
     |                     TInstr::local_get(left_low),
     |                     TInstr::local_get(right_low),
     |                   ),
     |                 ),
     |               )
     |               result.push(
     |                 TInstr::local_set(
     |                   high_tmp,
     |                   TInstr::binary(
     |                     BinaryOp::i32_add(),
     |                     TInstr::local_get(left_high),
     |                     TInstr::local_get(right_high),
     |                   ),
     |                 ),
     |               )
     |               result.push(
     |                 TInstr::if_(
     |                   BlockType::void_(),
     |                   TInstr::binary(
     |                     BinaryOp::i32_lt_u(),
     |                     TInstr::local_get(low_tmp),
     |                     TInstr::local_get(right_low),
     |                   ),
     |                   TExpr::new([
     |                     TInstr::local_set(
     |                       high_tmp,
     |                       TInstr::binary(
     |                         BinaryOp::i32_add(),
     |                         TInstr::local_get(high_tmp),
     |                         TInstr::i32_const(I32(1)),
     |                       ),
     |                     ),
     |                   ]),
     |                   None,
     |                 ),
     |               )
     |               result.push(i64l_stash_set(ctx, TInstr::local_get(high_tmp)))
     |               result.push(TInstr::local_get(low_tmp))
     |               i64l_make_block_i32(result)
     |             }
1895 |             I64SubOp => {
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let borrow_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let result = prefix.copy()
     |               result.push(
     |                 TInstr::local_set(
     |                   low_tmp,
1903 |                   TInstr::binary(
     |                   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     BinaryOp::i32_sub(),
     |                     TInstr::local_get(left_low),
     |                     TInstr::local_get(right_low),
     |                   ),
     |                 ),
     |               )
1910 |               result.push(
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_set(
     |                   borrow_tmp,
1913 |                   TInstr::binary(
     |                   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     BinaryOp::i32_lt_u(),
     |                     TInstr::local_get(left_low),
     |                     TInstr::local_get(right_low),
     |                   ),
     |                 ),
     |               )
1920 |               result.push(
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_set(
     |                   high_tmp,
1923 |                   TInstr::binary(
     |                   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     BinaryOp::i32_sub(),
     |                     TInstr::local_get(left_high),
     |                     TInstr::binary(
     |                       BinaryOp::i32_add(),
     |                       TInstr::local_get(right_high),
     |                       TInstr::local_get(borrow_tmp),
     |                     ),
     |                   ),
     |                 ),
     |               )
1934 |               result.push(i64l_stash_set(ctx, TInstr::local_get(high_tmp)))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               result.push(TInstr::local_get(low_tmp))
     |               i64l_make_block_i32(result)
     |             }
     |             I64MulOp =>
     |               i64l_build_mul(
     |                 ctx, prefix, left_low, left_high, right_low, right_high,
     |               )
1942 |             I64AndOp | I64OrOp | I64XorOp => {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               let op32 = match op {
     |                 I64AndOp => BinaryOp::i32_and()
     |                 I64OrOp => BinaryOp::i32_or()
     |                 _ => BinaryOp::i32_xor()
     |               }
1948 |               let result = prefix.copy()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               result.push(
     |                 i64l_stash_set(
     |                   ctx,
1952 |                   TInstr::binary(
     |                   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     op32,
1954 |                     TInstr::local_get(left_high),
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     TInstr::local_get(right_high),
     |                   ),
     |                 ),
     |               )
1959 |               result.push(
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::binary(
     |                   op32,
1962 |                   TInstr::local_get(left_low),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   TInstr::local_get(right_low),
     |                 ),
     |               )
1966 |               i64l_make_block_i32(result)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
1968 |             I64ShlOp | I64ShrSOp | I64ShrUOp => {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               let shift_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let result = prefix.copy()
     |               result.push(
     |                 TInstr::local_set(
     |                   shift_tmp,
1976 |                   TInstr::binary(
     |                   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     BinaryOp::i32_and(),
     |                     TInstr::local_get(right_low),
     |                     TInstr::i32_const(I32(63)),
     |                   ),
     |                 ),
     |               )
1983 |               let small_shift = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_and(),
     |                 TInstr::local_get(shift_tmp),
     |                 TInstr::i32_const(I32(31)),
     |               )
1988 |               let width_minus_shift = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_sub(),
     |                 TInstr::i32_const(I32(32)),
     |                 small_shift,
     |               )
1993 |               let large = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_ge_u(),
     |                 TInstr::local_get(shift_tmp),
     |                 TInstr::i32_const(I32(32)),
     |               )
1998 |               let (large_low, large_high, small_low, small_high) = match op {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 I64ShlOp =>
2000 |                   (
     |                   ^ 	<-- UNCOVERED
     |                     TInstr::i32_const(I32(0)),
     |                     TInstr::binary(
     |                       BinaryOp::i32_shl(),
     |                       TInstr::local_get(left_low),
     |                       small_shift,
     |                     ),
2007 |                     TInstr::binary(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BinaryOp::i32_shl(),
     |                       TInstr::local_get(left_low),
     |                       small_shift,
     |                     ),
2012 |                     TInstr::binary(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_high),
     |                         small_shift,
     |                       ),
2019 |                       TInstr::binary(
     |                       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         BinaryOp::i32_and(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_shr_u(),
     |                           TInstr::local_get(left_low),
     |                           width_minus_shift,
     |                         ),
2026 |                         TInstr::binary(
     |                         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           BinaryOp::i32_sub(),
     |                           TInstr::binary(
     |                             BinaryOp::i32_shl(),
     |                             TInstr::i32_const(I32(1)),
     |                             small_shift,
     |                           ),
2033 |                           TInstr::i32_const(I32(1)),
     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         ),
     |                       ),
     |                     ),
     |                   )
     |                 I64ShrSOp =>
2039 |                   (
     |                   ^ 	<-- UNCOVERED
     |                     TInstr::binary(
     |                       BinaryOp::i32_shr_s(),
     |                       TInstr::local_get(left_high),
     |                       small_shift,
     |                     ),
2045 |                     TInstr::binary(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BinaryOp::i32_shr_s(),
     |                       TInstr::local_get(left_high),
     |                       TInstr::i32_const(I32(31)),
     |                     ),
2050 |                     TInstr::binary(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shr_u(),
     |                         TInstr::local_get(left_low),
     |                         small_shift,
     |                       ),
2057 |                       TInstr::binary(
     |                       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_high),
     |                         width_minus_shift,
     |                       ),
     |                     ),
2063 |                     TInstr::binary(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BinaryOp::i32_shr_s(),
     |                       TInstr::local_get(left_high),
     |                       small_shift,
     |                     ),
     |                   )
     |                 _ =>
2070 |                   (
     |                   ^ 	<-- UNCOVERED
     |                     TInstr::binary(
     |                       BinaryOp::i32_shr_u(),
     |                       TInstr::local_get(left_high),
     |                       small_shift,
     |                     ),
2076 |                     TInstr::i32_const(I32(0)),
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shr_u(),
     |                         TInstr::local_get(left_low),
     |                         small_shift,
     |                       ),
2084 |                       TInstr::binary(
     |                       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_high),
     |                         width_minus_shift,
     |                       ),
     |                     ),
2090 |                     TInstr::binary(
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       BinaryOp::i32_shr_u(),
     |                       TInstr::local_get(left_high),
     |                       small_shift,
     |                     ),
     |                   )
     |               }
2097 |               result.push(
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_set(
     |                   low_tmp,
2100 |                   TInstr::select(None, large, large_low, small_low),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 ),
     |               )
2103 |               result.push(
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_set(
     |                   high_tmp,
2106 |                   TInstr::select(None, large, large_high, small_high),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 ),
     |               )
2109 |               result.push(i64l_stash_set(ctx, TInstr::local_get(high_tmp)))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               result.push(TInstr::local_get(low_tmp))
     |               i64l_make_block_i32(result)
     |             }
     |             I64RotlOp | I64RotrOp => {
     |               let shift_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let high_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |               let result = prefix.copy()
     |               result.push(
     |                 TInstr::local_set(
     |                   shift_tmp,
     |                   TInstr::binary(
     |                     BinaryOp::i32_and(),
     |                     TInstr::local_get(right_low),
     |                     TInstr::i32_const(I32(63)),
     |                   ),
     |                 ),
     |               )
     |               let small_shift = TInstr::binary(
     |                 BinaryOp::i32_and(),
     |                 TInstr::local_get(shift_tmp),
     |                 TInstr::i32_const(I32(31)),
     |               )
     |               let width_minus_shift = TInstr::binary(
     |                 BinaryOp::i32_sub(),
     |                 TInstr::i32_const(I32(32)),
     |                 small_shift,
     |               )
     |               let shift_mask = TInstr::binary(
     |                 BinaryOp::i32_sub(),
     |                 TInstr::binary(
     |                   BinaryOp::i32_shl(),
     |                   TInstr::i32_const(I32(1)),
     |                   small_shift,
     |                 ),
     |                 TInstr::i32_const(I32(1)),
     |               )
     |               let large = TInstr::binary(
     |                 BinaryOp::i32_ge_u(),
     |                 TInstr::local_get(shift_tmp),
     |                 TInstr::i32_const(I32(32)),
     |               )
     |               let (large_low, large_high, small_low, small_high) = match op {
     |                 I64RotlOp =>
     |                   (
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_high),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_low),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_low),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_high),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_low),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_high),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::local_get(left_high),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_low),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                   )
     |                 _ =>
     |                   (
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shr_u(),
     |                         TInstr::local_get(left_high),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_low),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shr_u(),
     |                         TInstr::local_get(left_low),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_high),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shr_u(),
     |                         TInstr::local_get(left_low),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_high),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                     TInstr::binary(
     |                       BinaryOp::i32_or(),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shr_u(),
     |                         TInstr::local_get(left_high),
     |                         small_shift,
     |                       ),
     |                       TInstr::binary(
     |                         BinaryOp::i32_shl(),
     |                         TInstr::binary(
     |                           BinaryOp::i32_and(),
     |                           shift_mask,
     |                           TInstr::local_get(left_low),
     |                         ),
     |                         width_minus_shift,
     |                       ),
     |                     ),
     |                   )
     |               }
     |               result.push(
     |                 TInstr::local_set(
     |                   low_tmp,
     |                   TInstr::select(None, large, large_low, small_low),
     |                 ),
     |               )
     |               result.push(
     |                 TInstr::local_set(
     |                   high_tmp,
     |                   TInstr::select(None, large, large_high, small_high),
     |                 ),
     |               )
     |               result.push(i64l_stash_set(ctx, TInstr::local_get(high_tmp)))
     |               result.push(TInstr::local_get(low_tmp))
     |               i64l_make_block_i32(result)
     |             }
     |             I64DivUOp =>
     |               i64l_build_udivrem(
     |                 ctx, prefix, left_low, left_high, right_low, right_high, false,
     |               )
     |             I64RemUOp =>
2317 |               i64l_build_udivrem(
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 ctx, prefix, left_low, left_high, right_low, right_high, true,
     |               )
     |             I64DivSOp =>
     |               i64l_build_sdivrem(
     |                 ctx, prefix, left_low, left_high, right_low, right_high, false,
     |               )
     |             I64RemSOp =>
     |               i64l_build_sdivrem(
     |                 ctx, prefix, left_low, left_high, right_low, right_high, true,
     |               )
2328 |             I64EqOp | I64NeOp => {
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               let is_eq = match op {
     |                 I64EqOp => true
     |                 _ => false
     |               }
2333 |               let cmp_low = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if is_eq {
2335 |                   BinaryOp::i32_eq()
     |                   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 } else {
2337 |                   BinaryOp::i32_ne()
     |                   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 },
2339 |                 TInstr::local_get(left_low),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_get(right_low),
     |               )
2342 |               let cmp_high = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if is_eq {
2344 |                   BinaryOp::i32_eq()
     |                   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 } else {
2346 |                   BinaryOp::i32_ne()
     |                   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 },
2348 |                 TInstr::local_get(left_high),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_get(right_high),
     |               )
     |               let comb = if is_eq {
2352 |                 BinaryOp::i32_and()
     |                 ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               } else {
2354 |                 BinaryOp::i32_or()
     |                 ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
2356 |               let result = prefix.copy()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               result.push(TInstr::binary(comb, cmp_low, cmp_high))
     |               i64l_make_block_i32(result)
     |             }
2360 |             I64LtUOp | I64LeUOp | I64GtUOp | I64GeUOp => {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               let (high_op, low_op) = match op {
     |                 I64LtUOp => (BinaryOp::i32_lt_u(), BinaryOp::i32_lt_u())
     |                 I64LeUOp => (BinaryOp::i32_lt_u(), BinaryOp::i32_le_u())
     |                 I64GtUOp => (BinaryOp::i32_gt_u(), BinaryOp::i32_gt_u())
     |                 _ => (BinaryOp::i32_gt_u(), BinaryOp::i32_ge_u())
     |               }
2367 |               let comp_high = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 high_op,
2369 |                 TInstr::local_get(left_high),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_get(right_high),
     |               )
2372 |               let eq_high = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_eq(),
     |                 TInstr::local_get(left_high),
     |                 TInstr::local_get(right_high),
     |               )
2377 |               let comp_low = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 low_op,
2379 |                 TInstr::local_get(left_low),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_get(right_low),
     |               )
2382 |               let result = prefix.copy()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               result.push(
     |                 TInstr::binary(
     |                   BinaryOp::i32_or(),
     |                   comp_high,
2387 |                   TInstr::binary(BinaryOp::i32_and(), eq_high, comp_low),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 ),
     |               )
2390 |               i64l_make_block_i32(result)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
2392 |             _ => {
     |             ^^^^^^ 	<-- UNCOVERED
     |               let (high_op, low_op) = match op {
     |                 I64LtSOp => (BinaryOp::i32_lt_s(), BinaryOp::i32_lt_u())
     |                 I64LeSOp => (BinaryOp::i32_lt_s(), BinaryOp::i32_le_u())
     |                 I64GtSOp => (BinaryOp::i32_gt_s(), BinaryOp::i32_gt_u())
     |                 _ => (BinaryOp::i32_gt_s(), BinaryOp::i32_ge_u())
     |               }
2399 |               let comp_high = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 high_op,
2401 |                 TInstr::local_get(left_high),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_get(right_high),
     |               )
2404 |               let eq_high = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_eq(),
     |                 TInstr::local_get(left_high),
     |                 TInstr::local_get(right_high),
     |               )
2409 |               let comp_low = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 low_op,
2411 |                 TInstr::local_get(left_low),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TInstr::local_get(right_low),
     |               )
2414 |               let result = prefix.copy()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               result.push(
     |                 TInstr::binary(
     |                   BinaryOp::i32_or(),
     |                   comp_high,
2419 |                   TInstr::binary(BinaryOp::i32_and(), eq_high, comp_low),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 ),
     |               )
2422 |               i64l_make_block_i32(result)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |         }
2426 |         _ => curr
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TSelect(_, cond, if_true, if_false) => {
     |       let select_is_i64 = match instr {
     |         TSelect(Some([vt]), _, _, _) => i64l_is_i64(vt)
     |         TSelect(None, _, old_if_true, _) =>
     |           i64l_old_instr_is_i64(ctx, old_if_true)
2433 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if !select_is_i64 {
2436 |         curr
     |         ^^^^ 	<-- UNCOVERED
     |       } else {
     |         let cond_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |         let true_low = i64l_alloc_temp(ctx, ValType::i32())
     |         let true_high = i64l_alloc_temp(ctx, ValType::i32())
     |         let false_low = i64l_alloc_temp(ctx, ValType::i32())
     |         let false_high = i64l_alloc_temp(ctx, ValType::i32())
     |         i64l_make_block_i32([
     |           TInstr::local_set(true_low, if_true),
     |           TInstr::local_set(true_high, i64l_stash_get(ctx)),
     |           TInstr::local_set(false_low, if_false),
     |           TInstr::local_set(false_high, i64l_stash_get(ctx)),
     |           TInstr::local_set(cond_tmp, cond),
     |           i64l_stash_set(
     |             ctx,
     |             TInstr::select(
     |               None,
     |               TInstr::local_get(cond_tmp),
     |               TInstr::local_get(true_high),
     |               TInstr::local_get(false_high),
     |             ),
     |           ),
     |           TInstr::select(
     |             None,
     |             TInstr::local_get(cond_tmp),
     |             TInstr::local_get(true_low),
     |             TInstr::local_get(false_low),
     |           ),
     |         ])
     |       }
     |     }
     |     TDrop(value) => TInstr::drop(value)
     |     TReturn(values) =>
     |       if !ctx.old_result_is_i64 {
2470 |         curr
     |         ^^^^ 	<-- UNCOVERED
     |       } else if values.length() == 1 {
     |         let low_tmp = i64l_alloc_temp(ctx, ValType::i32())
     |         i64l_make_block_void([
     |           TInstr::local_set(low_tmp, values[0]),
     |           TInstr::global_set(ctx.info.return_high_global, i64l_stash_get(ctx)),
     |           TInstr::return_([TInstr::local_get(low_tmp)]),
     |         ])
     |       } else {
2479 |         curr
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     TBlock(bt, body) =>
     |       if i64l_type_is_i64_block(bt) {
     |         TInstr::block(BlockType::val_type(ValType::i32()), body)
     |       } else {
     |         curr
     |       }
     |     TLoop(bt, body) =>
     |       if i64l_type_is_i64_block(bt) {
     |         TInstr::loop_(BlockType::val_type(ValType::i32()), body)
     |       } else {
2491 |         curr
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     TIf(bt, cond, then_, else_) =>
     |       if i64l_type_is_i64_block(bt) {
     |         TInstr::if_(BlockType::val_type(ValType::i32()), cond, then_, else_)
     |       } else {
2497 |         curr
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     TTryTable(bt, catches, body) =>
2500 |       if i64l_type_is_i64_block(bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::try_table(BlockType::val_type(ValType::i32()), catches, body)
     |       } else {
2503 |         curr
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     _ => curr
     |   }
     |   if rewritten != curr {
     |     change(ctx, rewritten)
     |   } else if curr != instr {
     |     change(ctx, curr)
     |   } else {
     |     unchanged()
     |   }
     | }
     …

     | fn i64l_rewrite_one_func(
     |   func_idx : FuncIdx,
     |   func : Func,
     |   info : I64LModuleInfo,
     | ) -> Result[Func, String] {
     |   let old_ft = match info.old_func_types.get(func_idx) {
     |     Some(ft) => ft
2524 |     None => FuncType::new([], [])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FuncType(old_params, old_results) = old_ft
     |   let old_result_is_i64 = old_results.length() == 1 &&
     |     i64l_is_i64(old_results[0])
     |   match func {
2530 |     Func(_, _) => Ok(func)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(locals, body) => {
     |       let low_map : Array[LocalIdx] = []
     |       let high_map : Array[LocalIdx?] = []
     |       let mut next_abs = 0
     |       for vt in old_params {
     |         low_map.push(LocalIdx::new(next_abs.reinterpret_as_uint()))
     |         if i64l_is_i64(vt) {
     |           high_map.push(
     |             Some(LocalIdx::new((next_abs + 1).reinterpret_as_uint())),
     |           )
     |           next_abs += 2
     |         } else {
2543 |           high_map.push(None)
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           next_abs += 1
     |         }
     |       }
     |       let new_locals_base : Array[ValType] = []
     |       for vt in locals {
     |         low_map.push(LocalIdx::new(next_abs.reinterpret_as_uint()))
     |         if i64l_is_i64(vt) {
     |           high_map.push(
     |             Some(LocalIdx::new((next_abs + 1).reinterpret_as_uint())),
     |           )
     |           new_locals_base.push(ValType::i32())
     |           new_locals_base.push(ValType::i32())
     |           next_abs += 2
     |         } else {
2558 |           high_map.push(None)
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           new_locals_base.push(vt)
     |           next_abs += 1
     |         }
     |       }
     |       let extra_locals : Array[ValType] = []
     |       let next_local = [next_abs]
     |       let stash_local = LocalIdx::new(next_abs.reinterpret_as_uint())
     |       extra_locals.push(ValType::i32())
     |       next_local[0] = next_abs + 1
     |       let ctx : I64LFuncCtx = {
     |         info,
     |         low_map,
     |         high_map,
     |         stash_local,
     |         next_local,
     |         extra_locals,
     |         old_result_is_i64,
     |       }
     |       let pass = ModuleTransformer::new().on_tinstruction_evt(
     |         i64l_rewrite_tinstruction,
     |       )
     |       let rewritten_body = match pass.walk_texpr(ctx, body) {
     |         Ok(Some((_, next_body))) => next_body
2582 |         Ok(None) => body
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |       }
     |       let needs_implicit_return_wrap = if old_result_is_i64 {
     |         let TExpr(old_instrs) = body
     |         !old_instrs.is_empty() &&
     |         i64l_old_instr_is_i64(ctx, old_instrs[old_instrs.length() - 1])
     |       } else {
     |         false
     |       }
     |       let final_body = if needs_implicit_return_wrap {
     |         let TExpr(instrs) = rewritten_body
     |         if instrs.is_empty() {
2595 |           rewritten_body
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           let prefix : Array[TInstr] = []
     |           for i = 0; i < instrs.length() - 1; i = i + 1 {
     |             prefix.push(instrs[i])
     |           }
     |           let last = instrs[instrs.length() - 1]
     |           let tmp = LocalIdx::new(next_local[0].reinterpret_as_uint())
     |           extra_locals.push(ValType::i32())
     |           next_local[0] = next_local[0] + 1
     |           prefix.push(
     |             i64l_make_block_i32([
     |               TInstr::local_set(tmp, last),
     |               TInstr::global_set(
     |                 info.return_high_global,
     |                 TInstr::local_get(stash_local),
     |               ),
     |               TInstr::local_get(tmp),
     |             ]),
     |           )
     |           TExpr::new(prefix)
     |         }
     |       } else {
     |         rewritten_body
     |       }
     |       let final_locals = new_locals_base.copy()
     |       for ty in extra_locals {
     |         final_locals.push(ty)
     |       }
     |       Ok(Func::t_func(final_locals, final_body))
     |     }
     |   }
     | }
     …

     | fn i64l_rewrite_globals(
     |   mod : Module,
     | ) -> Result[(Module, Map[GlobalIdx, GlobalIdx], GlobalIdx), String] {
     |   let imported_globals = i64l_count_imported_globals(mod)
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, GlobalExternType(GlobalType(vt, _))) =>
     |             if i64l_is_i64(vt) {
     |               return Err(
     |                 "i64_to_i32_lowering: imported i64 globals are unsupported",
     |               )
     |             }
2644 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   let globals = match mod.global_sec {
     |     Some(GlobalSec(gs)) => gs
     |     None => []
     |   }
     |   let i64_global_abs : Array[GlobalIdx] = []
     |   for i = 0; i < globals.length(); i = i + 1 {
     |     let Global(GlobalType(vt, _), _) = globals[i]
     |     if i64l_is_i64(vt) {
     |       i64_global_abs.push(
     |         GlobalIdx::new(imported_globals + i.reinterpret_as_uint()),
     |       )
     |     }
     |   }
     |   let hi_map : Map[GlobalIdx, GlobalIdx] = Map::new()
     |   let first_hi = imported_globals + globals.length().reinterpret_as_uint()
     |   for i = 0; i < i64_global_abs.length(); i = i + 1 {
     |     hi_map[i64_global_abs[i]] = GlobalIdx::new(
     |       first_hi + i.reinterpret_as_uint(),
     |     )
     |   }
     |   let new_globals : Array[Global] = []
     |   let hi_globals : Array[Global] = []
     |   for i = 0; i < globals.length(); i = i + 1 {
     |     let abs_idx = GlobalIdx::new(imported_globals + i.reinterpret_as_uint())
     |     let Global(GlobalType(vt, is_mut), init) = globals[i]
     |     if !i64l_is_i64(vt) {
2675 |       new_globals.push(globals[i])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     let root = match to_texpr(init, Env::new().with_module(mod)) {
     |       Ok(TExpr([x])) => x
2680 |       _ => return Err("i64_to_i32_lowering: unsupported i64 global init")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let (low_init, hi_init) = match root {
     |       TI64Const(v) => {
     |         let (low, hi) = i64l_split_i64_literal(v)
     |         (
     |           TExpr::new([TInstr::i32_const(I32(low))]).to_expr(),
     |           TExpr::new([TInstr::i32_const(I32(hi))]).to_expr(),
     |         )
     |       }
     |       TGlobalGet(from_idx) =>
2691 |         match hi_map.get(from_idx) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(from_hi_idx) =>
2693 |             (
     |             ^ 	<-- UNCOVERED
     |               TExpr::new([TInstr::global_get(from_idx)]).to_expr(),
     |               TExpr::new([TInstr::global_get(from_hi_idx)]).to_expr(),
     |             )
     |           None =>
2698 |             return Err(
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |               "i64_to_i32_lowering: unsupported i64 global.get init source",
     |             )
     |         }
     |       _ => return Err("i64_to_i32_lowering: unsupported i64 global init root")
     |     }
     |     new_globals.push(
     |       Global::new(GlobalType::new(ValType::i32(), is_mut), low_init),
     |     )
     |     hi_globals.push(
     |       Global::new(GlobalType::new(ValType::i32(), is_mut), hi_init),
     |     )
     |     ignore(abs_idx)
     |   }
     |   for g in hi_globals {
     |     new_globals.push(g)
     |   }
     |   let return_high_idx = GlobalIdx::new(
     |     imported_globals + new_globals.length().reinterpret_as_uint(),
     |   )
     |   new_globals.push(
     |     Global::new(
     |       GlobalType::new(ValType::i32(), true),
     |       TExpr::new([TInstr::i32_const(I32(0))]).to_expr(),
     |     ),
     |   )
     |   Ok(
     |     (mod.with_global_sec(GlobalSec::new(new_globals)), hi_map, return_high_idx),
     |   )
     | }
     …

     | fn i64_to_i32_lowering(mod : Module) -> Result[Module, String] {
     |   let old_func_types = i64l_collect_old_func_types(mod)
     |   let old_type_func_types = i64l_collect_old_type_func_types(mod)
     |   let mod = match i64l_lower_type_sec(mod) {
     |     Ok(next_mod) => next_mod
     |     Err(e) => return Err(e)
     |   }
     |   let (mod, hi_map, return_hi) = match i64l_rewrite_globals(mod) {
     |     Ok(v) => v
     |     Err(e) => return Err(e)
     |   }
     |   let needs_scratch_memory = [false]
     |   let info : I64LModuleInfo = {
     |     old_func_types,
     |     old_type_func_types,
     |     i64_global_hi: hi_map,
     |     return_high_global: return_hi,
     |     default_mem_is_i64: i64l_default_mem_is_i64(mod),
     |     needs_scratch_memory,
     |   }
     |   let lowered = match mod.code_sec {
     |     Some(CodeSec(funcs)) => {
     |       let imported_funcs = i64l_count_imported_funcs(mod)
     |       let new_funcs : Array[Func] = []
     |       for i = 0; i < funcs.length(); i = i + 1 {
     |         let abs_idx = FuncIdx::new(imported_funcs + i.reinterpret_as_uint())
     |         match i64l_rewrite_one_func(abs_idx, funcs[i], info) {
     |           Ok(f) => new_funcs.push(f)
2758 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       mod.with_code_sec(CodeSec::new(new_funcs))
     |     }
2763 |     None => mod
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(i64l_ensure_scratch_memory(lowered, info.needs_scratch_memory[0]))
     | }
     …

159 uncovered line(s) in src/passes/inlining.mbt:

     | fn il_count_imported_funcs(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  70 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(_)) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn il_total_functions(mod : Module, imported : Int) -> Int {
     |   let defined = match mod.code_sec {
     |     Some(CodeSec(funcs)) => funcs.length()
  85 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   imported + defined
     | }
     …

     | fn il_collect_func_types(mod : Module, total_funcs : Int) -> Array[FuncType] {
     |   let env = Env::new().with_module(mod)
     |   let out : Array[FuncType] = []
     |   for i = 0; i < total_funcs; i = i + 1 {
     |     match env.get_functype_by_funcidx(il_func_idx_from_abs(i)) {
     |       Some(ft) => out.push(ft)
  97 |       None => out.push(FuncType::new([], []))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn il_collect_funcs_by_abs(mod : Module, imported : Int) -> Array[Func?] {
     |   let out : Array[Func?] = []
     |   for i = 0; i < imported; i = i + 1 {
 107 |     out.push(None)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for func in funcs {
     |         out.push(Some(func))
     |       }
 114 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn il_compute_used_globally(mod : Module, total_funcs : Int) -> Array[Bool] {
     |   let used : Array[Bool] = []
     |   for i = 0; i < total_funcs; i = i + 1 {
     |     used.push(false)
     |   }
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
 136 |       for export_ in exports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match export_ {
     |           Export(_, FuncExternIdx(idx)) => il_mark_func_used(used, idx)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.start_sec {
 145 |     Some(StartSec(idx)) => il_mark_func_used(used, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.elem_sec {
     |     Some(ElemSec(elems)) =>
     |       for elem in elems {
     |         match elem {
     |           Elem(_, kind) =>
     |             match kind {
     |               FuncsElemKind(funcs) =>
     |                 for idx in funcs {
     |                   il_mark_func_used(used, idx)
     |                 }
     |               FuncExprsElemKind(exprs) | TypedExprsElemKind(_, exprs) =>
 159 |                 for expr in exprs {
     |                 ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   for instr in expr.0 {
     |                     match instr {
     |                       RefFunc(idx) => il_mark_func_used(used, idx)
     |                       _ => ()
     |                     }
     |                   }
     |                 }
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TRefFunc(idx) => il_mark_func_used(used, idx)
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for func in funcs {
     |         match func {
     |           TFunc(_, body) => ignore(walker.walk_texpr((), body))
 184 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 187 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
 191 |       for global in globals {
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match global {
     |           Global(_, init) =>
 194 |             for instr in init.0 {
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match instr {
     |                 RefFunc(idx) => il_mark_func_used(used, idx)
     |                 _ => ()
     |               }
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   used
     | }
     …

     | fn il_is_trivial_leaf(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TLocalGet(_)
 256 |     | TGlobalGet(_) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn il_is_shrink_wrapper(instr : TInstr, _param_count : Int) -> Bool {
     |   if !il_is_non_control(instr) {
 264 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let children = eval_children(instr)
     |   if children.is_empty() {
     |     return false
     |   }
     |   let seen : Set[Int] = Set::new()
     |   let mut last_idx = -1
     |   for child in children {
     |     match child {
     |       TLocalGet(LocalIdx(raw)) => {
     |         let idx = raw.reinterpret_as_int()
     |         if seen.contains(idx) || idx < last_idx {
 277 |           return false
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         seen.add(idx)
     |         last_idx = idx
     |       }
     |       _ => return false
     |     }
     |   }
     |   true
     | }
     …

     | fn il_analyze_func(
     |   func : Func?,
     |   func_type : FuncType,
     |   used_globally : Bool,
     | ) -> ILFunctionInfo {
     |   match func {
     |     None =>
 316 |       ILFunctionInfo::{
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         imported: true,
     |         func_type,
     |         body: None,
     |         size: 0,
     |         has_loops: false,
     |         has_calls: false,
     |         has_try_delegate: false,
     |         direct_call_refs: 0,
     |         ref_func_refs: 0,
     |         used_globally,
     |         trivial_kind: ILNotTrivial,
     |         tail_wrapper: false,
     |       }
     |     Some(TFunc(locals, body)) => {
     |       let mut has_loops = false
     |       let mut has_calls = false
     |       let mut has_try_delegate = false
     |       let mut direct_call_refs = 0
     |       let mut ref_func_refs = 0
     |       let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |         self,
     |         _,
     |         instr,
     |       ) {
     |         match instr {
 342 |           TLoop(_, _) => has_loops = true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TCall(_, _)
     |           | TCallIndirect(_, _, _, _)
     |           | TCallRef(_, _, _)
     |           | TReturnCall(_, _)
     |           | TReturnCallIndirect(_, _, _, _)
     |           | TReturnCallRef(_, _, _) => {
     |             has_calls = true
     |             match instr {
     |               TCall(_, _) | TReturnCall(_, _) => direct_call_refs += 1
     |               _ => ()
     |             }
     |           }
     |           TTryTable(_, _, _) => has_try_delegate = true
     |           TRefFunc(_) => ref_func_refs += 1
     |           _ => ()
     |         }
     |         self.walk_tinstruction_default((), instr)
     |       })
     |       ignore(walker.walk_texpr((), body))
     |       let FuncType(params, _) = func_type
     |       let tail_wrapper = if locals.is_empty() {
     |         match body.0 {
     |           [TReturnCall(_, _)] => true
     |           [TReturnCallIndirect(_, _, _, _)] => true
     |           [TReturnCallRef(_, _, _)] => true
     |           _ => false
     |         }
     |       } else {
     |         false
     |       }
     |       ILFunctionInfo::{
     |         imported: false,
     |         func_type,
     |         body: Some(body),
     |         size: il_measure_body(body),
     |         has_loops,
     |         has_calls,
     |         has_try_delegate,
     |         direct_call_refs,
     |         ref_func_refs,
     |         used_globally,
     |         trivial_kind: il_detect_trivial_kind(body, params.length()),
     |         tail_wrapper,
     |       }
     |     }
     |     Some(Func(_, _)) =>
 389 |       ILFunctionInfo::{
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         imported: false,
     |         func_type,
     |         body: None,
     |         size: 0,
     |         has_loops: false,
     |         has_calls: false,
     |         has_try_delegate: false,
     |         direct_call_refs: 0,
     |         ref_func_refs: 0,
     |         used_globally,
     |         trivial_kind: ILNotTrivial,
     |         tail_wrapper: false,
     |       }
     |   }
     | }
     …

     | fn il_any_unreachable(values : Array[TInstr]) -> Bool {
     |   for value in values {
     |     if is_unreachable_instr(value) {
 424 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   false
     | }
     …

     | fn il_collect_callsites_for_body(
     |   caller_abs_idx : Int,
     |   body : TExpr,
     | ) -> Array[ILCallSite] {
     |   let sites : Array[ILCallSite] = []
     |   let mut next_id = 0
     |   let mut try_depth = 0
     |   let reachable_stack : Array[Bool] = []
     |   let mut reachable_depth = 0
     |   let walker = ModuleTransformer::new()
     |     .on_texpr_evt(fn(self, _, expr) {
     |       let start_reachable = if reachable_depth > 0 {
     |         reachable_stack[reachable_depth - 1]
     |       } else {
     |         true
     |       }
     |       if reachable_depth == reachable_stack.length() {
     |         reachable_stack.push(start_reachable)
     |       } else {
     |         reachable_stack[reachable_depth] = start_reachable
     |       }
     |       reachable_depth += 1
     |       let mut curr_reachable = start_reachable
     |       for instr in expr.0 {
     |         reachable_stack[reachable_depth - 1] = curr_reachable
     |         match self.walk_tinstruction((), instr) {
     |           Ok(_) => ()
 458 |           Err(e) => {
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             reachable_depth -= 1
     |             return Err(e)
     |           }
     |         }
     |         if curr_reachable && is_unreachable_instr(instr) {
     |           curr_reachable = false
     |         }
     |       }
     |       reachable_depth -= 1
     |       change((), expr)
     |     })
     |     .on_tinstruction_evt(fn(self, _, instr) {
     |       match instr {
     |         TTryTable(bt, catches, try_body) => {
     |           try_depth += 1
     |           let walked_body = match self.walk_texpr((), try_body) {
     |             Ok(Some((_, next))) => next
 476 |             Ok(None) => try_body
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => {
     |               try_depth -= 1
     |               return Err(e)
     |             }
     |           }
     |           try_depth -= 1
     |           if walked_body == try_body {
     |             unchanged()
     |           } else {
 486 |             change((), TInstr::try_table(bt, catches, walked_body))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         _ => {
     |           let walked = match self.walk_tinstruction_default((), instr) {
     |             Ok(Some((_, next))) => next
     |             Ok(None) => instr
 493 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let is_reachable = if reachable_depth > 0 {
     |             reachable_stack[reachable_depth - 1]
     |           } else {
 498 |             true
     |             ^^^^ 	<-- UNCOVERED
     |           }
     |           match walked {
     |             TCall(fi, args) => {
     |               let FuncIdx(raw) = fi
     |               let callee_abs_idx = raw.reinterpret_as_int()
     |               if is_reachable {
     |                 sites.push({
     |                   id: next_id,
     |                   caller_abs_idx,
     |                   callee_abs_idx,
     |                   kind: ILDirectCall,
     |                   try_depth,
     |                   force_unreachable: il_any_unreachable(args),
     |                 })
     |               }
     |               next_id += 1
     |             }
     |             TReturnCall(fi, args) => {
     |               let FuncIdx(raw) = fi
     |               let callee_abs_idx = raw.reinterpret_as_int()
     |               if is_reachable {
     |                 sites.push({
     |                   id: next_id,
     |                   caller_abs_idx,
     |                   callee_abs_idx,
     |                   kind: ILReturnCall,
     |                   try_depth,
     |                   force_unreachable: il_any_unreachable(args),
     |                 })
     |               }
     |               next_id += 1
     |             }
     |             _ => ()
     |           }
     |           if walked == instr {
     |             unchanged()
     |           } else {
 536 |             change((), walked)
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |     })
     |   ignore(walker.walk_texpr((), body))
     |   sites
     | }
     …

     | fn il_collect_callsites(
     |   mod : Module,
     |   imported : Int,
     | ) -> Array[Array[ILCallSite]] {
     |   let total = il_total_functions(mod, imported)
     |   let out : Array[Array[ILCallSite]] = []
     |   for i = 0; i < total; i = i + 1 {
     |     out.push([])
     |   }
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
     |         let abs_idx = imported + def_idx
     |         match funcs[def_idx] {
     |           TFunc(_, body) =>
     |             out[abs_idx] = il_collect_callsites_for_body(abs_idx, body)
 562 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 565 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn il_worth_full_inlining(
     |   info : ILFunctionInfo,
     |   incoming_calls : Int,
     |   options : OptimizeOptions,
     | ) -> Bool {
     |   if info.imported || info.body is None {
 606 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if info.has_try_delegate {
 609 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let inlining_options = options.inlining
     |   if !inlining_options.allow_functions_with_loops && info.has_loops {
 613 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if options.optimize_level == 0 &&
     |     options.shrink_level == 0 &&
     |     info.has_calls &&
     |     info.size > inlining_options.always_inline_max_size {
 619 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if options.shrink_level > 0 &&
     |     info.used_globally &&
     |     info.ref_func_refs > 0 &&
     |     incoming_calls > 1 {
 625 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if options.shrink_level > 1 && info.direct_call_refs > 0 && incoming_calls > 1 {
 628 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FuncType(_, results) = info.func_type
     |   if results.length() > 1 {
 632 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if info.trivial_kind == ILShrinks {
     |     return true
     |   }
     |   if info.size <= inlining_options.always_inline_max_size {
     |     return true
     |   }
     |   if incoming_calls == 1 {
     |     if inlining_options.one_caller_inline_max_size < 0 {
 642 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if info.size <= inlining_options.one_caller_inline_max_size {
 645 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if options.shrink_level == 0 && options.optimize_level >= 2 {
 649 |     if info.trivial_kind == ILMayNotShrink {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       return true
     |     }
     |     if info.size <= inlining_options.flexible_inline_max_size {
 653 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   false
     | }
     …

     | fn il_apply_ir_transformer_pass(
     |   mod : Module,
     |   pass : ModuleTransformer[IRContext],
     | ) -> Result[Module, String] {
 664 |   let ctx = IRContext::new()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match pass.walk_module(ctx, mod) {
     |     Ok(Some((_, new_mod))) => Ok(new_mod)
     |     Ok(None) => Ok(mod)
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn il_zero_of_type(vt : ValType) -> TInstr? {
     |   match vt {
     |     NumTypeValType(I32NumType) => Some(TInstr::i32_const(I32(0)))
 676 |     NumTypeValType(I64NumType) => Some(TInstr::i64_const(I64(0L)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     NumTypeValType(F32NumType) => Some(TInstr::f32_const(F32(0.0)))
     |     NumTypeValType(F64NumType) => Some(TInstr::f64_const(F64(0.0)))
     |     VecTypeValType =>
 680 |       Some(TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) =>
     |       if rt.is_nullable() {
 683 |         Some(TInstr::ref_null(rt.get_heap_type()))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         None
     |       }
 687 |     BotValType => Some(TInstr::unreachable_())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn il_make_block_type(results : Array[ValType]) -> BlockType? {
     |   match results {
     |     [] => Some(BlockType::void_())
     |     [r] => Some(BlockType::val_type(r))
 696 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn il_wrap_force_unreachable(
     |   replacement : TInstr,
     |   results : Array[ValType],
     | ) -> TInstr {
 705 |   match results {
     |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     [] =>
 707 |       TInstr::block(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         BlockType::void_(),
     |         TExpr::new([replacement, TInstr::unreachable_()]),
     |       )
     |     [r] =>
 712 |       TInstr::block(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         BlockType::val_type(r),
     |         TExpr::new([TInstr::drop(replacement), TInstr::unreachable_()]),
     |       )
 716 |     _ => replacement
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn il_rewrite_inlined_body(
     |   body : TExpr,
     |   callee_param_count : Int,
     |   mapped_params : Array[LocalIdx],
     |   mapped_locals : Array[LocalIdx],
     |   callee_results : Array[ValType],
     |   site_is_tail : Bool,
     | ) -> Result[TExpr, String] {
     |   let mapper = ModuleTransformer::new()
     |     .on_localidx_evt(fn(_, _, idx) {
     |       let LocalIdx(raw) = idx
     |       let i = raw.reinterpret_as_int()
     |       let mapped = if i < callee_param_count {
     |         mapped_params.get(i)
     |       } else {
     |         mapped_locals.get(i - callee_param_count)
     |       }
     |       match mapped {
     |         Some(next) => if next == idx { unchanged() } else { change((), next) }
 740 |         None => Err("inlining: local index mapping out of range")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     .on_labelidx_evt(fn(_, _, idx) {
     |       let LabelIdx(raw) = idx
     |       change((), il_label_idx_from_int(raw.reinterpret_as_int() + 1))
     |     })
     |     .on_tinstruction_evt(fn(self, _, instr) {
     |       let walked = match self.walk_tinstruction_default((), instr) {
     |         Ok(Some((_, next))) => next
     |         Ok(None) => instr
 751 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let rewritten = match walked {
     |         TReturn(values) => TInstr::br(LabelIdx::new(0), values)
     |         TReturnCall(target, args) =>
     |           if site_is_tail {
 757 |             TInstr::return_call(target, args)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else {
     |             match callee_results {
     |               [] =>
 761 |                 TInstr::block(
     |                 ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   BlockType::void_(),
     |                   TExpr::new([
     |                     TInstr::call(target, args),
     |                     TInstr::br(LabelIdx::new(0), []),
     |                   ]),
     |                 )
     |               [_] => TInstr::br(LabelIdx::new(0), [TInstr::call(target, args)])
     |               _ =>
 770 |                 return Err(
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |                   "inlining: return_call rewrite for multi-value results is unsupported",
     |                 )
     |             }
     |           }
     |         TReturnCallIndirect(type_idx, table_idx, args, idx) =>
 776 |           if site_is_tail {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TInstr::return_call_indirect(type_idx, table_idx, args, idx)
     |           } else {
 779 |             match callee_results {
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               [] =>
 781 |                 TInstr::block(
     |                 ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   BlockType::void_(),
     |                   TExpr::new([
     |                     TInstr::call_indirect(type_idx, table_idx, args, idx),
     |                     TInstr::br(LabelIdx::new(0), []),
     |                   ]),
     |                 )
     |               [_] =>
 789 |                 TInstr::br(LabelIdx::new(0), [
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   TInstr::call_indirect(type_idx, table_idx, args, idx),
     |                 ])
     |               _ =>
 793 |                 return Err(
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |                   "inlining: return_call_indirect rewrite for multi-value results is unsupported",
     |                 )
     |             }
     |           }
     |         TReturnCallRef(type_idx, args, ref_) =>
 799 |           if site_is_tail {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TInstr::return_call_ref(type_idx, args, ref_)
     |           } else {
 802 |             match callee_results {
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               [] =>
 804 |                 TInstr::block(
     |                 ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   BlockType::void_(),
     |                   TExpr::new([
     |                     TInstr::call_ref(type_idx, args, ref_),
     |                     TInstr::br(LabelIdx::new(0), []),
     |                   ]),
     |                 )
     |               [_] =>
 812 |                 TInstr::br(LabelIdx::new(0), [
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   TInstr::call_ref(type_idx, args, ref_),
     |                 ])
     |               _ =>
 816 |                 return Err(
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |                   "inlining: return_call_ref rewrite for multi-value results is unsupported",
     |                 )
     |             }
     |           }
     |         _ => walked
     |       }
     |       if rewritten == instr {
     |         unchanged()
     |       } else {
     |         change((), rewritten)
     |       }
     |     })
     |   match mapper.walk_texpr((), body) {
     |     Ok(Some((_, out))) => Ok(out)
 831 |     Ok(None) => Ok(body)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn il_substitute_params_in_instr(
     |   instr : TInstr,
     |   args : Array[TInstr],
     | ) -> Result[TInstr, String] {
     |   let sub = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     let walked = match self.walk_tinstruction_default((), curr) {
     |       Ok(Some((_, next))) => next
     |       Ok(None) => curr
 845 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match walked {
 848 |       TLocalGet(LocalIdx(raw)) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = raw.reinterpret_as_int()
     |         match args.get(idx) {
     |           Some(arg) => change((), arg)
     |           None =>
 853 |             Err(
     |             ^^^^ 	<-- UNCOVERED
     |               "inlining: tail wrapper references non-parameter local during substitution",
     |             )
     |         }
     |       }
     |       TLocalSet(_, _) | TLocalTee(_, _) =>
 859 |         Err("inlining: tail wrapper local writes are unsupported")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => if walked == curr { unchanged() } else { change((), walked) }
     |     }
     |   })
     |   match sub.walk_tinstruction((), instr) {
     |     Ok(Some((_, out))) => Ok(out)
 865 |     Ok(None) => Ok(instr)
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn il_inline_tail_wrapper_call(
     |   callee_func : Func,
     |   args : Array[TInstr],
     | ) -> Result[TInstr?, String] {
     |   match callee_func {
     |     TFunc(locals, TExpr([TReturnCall(target, tail_args)])) =>
     |       if locals.is_empty() {
     |         match
     |           il_substitute_params_in_instr(
     |             TInstr::return_call(target, tail_args),
     |             args,
     |           ) {
     |           Ok(out) => Ok(Some(out))
 884 |           Err(e) => Err(e)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
 887 |         Ok(None)
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TFunc(
     |       locals,
     |       TExpr([TReturnCallIndirect(type_idx, table_idx, tail_args, idx)])
     |     ) =>
     |       if locals.is_empty() {
     |         match
     |           il_substitute_params_in_instr(
     |             TInstr::return_call_indirect(type_idx, table_idx, tail_args, idx),
     |             args,
     |           ) {
     |           Ok(out) => Ok(Some(out))
 900 |           Err(e) => Err(e)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
 903 |         Ok(None)
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TFunc(locals, TExpr([TReturnCallRef(type_idx, tail_args, ref_)])) =>
     |       if locals.is_empty() {
     |         match
     |           il_substitute_params_in_instr(
     |             TInstr::return_call_ref(type_idx, tail_args, ref_),
     |             args,
     |           ) {
     |           Ok(out) => Ok(Some(out))
 913 |           Err(e) => Err(e)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
 916 |         Ok(None)
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
 918 |     _ => Ok(None)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn il_inline_normal_call(
     |   action : ILInlineAction,
     |   callee_func : Func,
     |   callee_type : FuncType,
     |   args : Array[TInstr],
     |   caller_param_count : Int,
     |   caller_locals : Array[ValType],
     | ) -> Result[TInstr, String] {
     |   let FuncType(callee_params, callee_results) = callee_type
     |   let block_type = match il_make_block_type(callee_results) {
     |     Some(bt) => bt
     |     None =>
 935 |       return Err(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         "inlining: multi-value function results are not currently supported",
     |       )
     |   }
     |   if callee_params.length() != args.length() {
 940 |     return Err("inlining: call argument count mismatch")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match callee_func {
     |     TFunc(callee_locals, callee_body) => {
     |       let mapped_params : Array[LocalIdx] = []
     |       let mapped_locals : Array[LocalIdx] = []
     |       for param_ty in callee_params {
     |         let idx = caller_param_count + caller_locals.length()
     |         caller_locals.push(param_ty)
     |         mapped_params.push(il_local_idx_from_int(idx))
     |       }
     |       for local_ty in callee_locals {
     |         let idx = caller_param_count + caller_locals.length()
     |         caller_locals.push(local_ty)
     |         mapped_locals.push(il_local_idx_from_int(idx))
     |       }
     |       let prologue : Array[TInstr] = []
     |       for i = 0; i < mapped_params.length(); i = i + 1 {
     |         prologue.push(TInstr::local_set(mapped_params[i], args[i]))
     |       }
     |       for i = 0; i < mapped_locals.length(); i = i + 1 {
     |         match il_zero_of_type(callee_locals[i]) {
     |           Some(zero) => prologue.push(TInstr::local_set(mapped_locals[i], zero))
     |           None => ()
     |         }
     |       }
     |       let rewritten_body = match
     |         il_rewrite_inlined_body(
     |           callee_body,
     |           callee_params.length(),
     |           mapped_params,
     |           mapped_locals,
     |           callee_results,
     |           false,
     |         ) {
     |         Ok(body) => body
 976 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let wrapped_instrs = prologue.copy()
     |       for instr in rewritten_body.0 {
     |         wrapped_instrs.push(instr)
     |       }
     |       let mut replacement = TInstr::block(
     |         block_type,
     |         TExpr::new(wrapped_instrs),
     |       )
     |       if action.force_unreachable {
 987 |         replacement = il_wrap_force_unreachable(replacement, callee_results)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(replacement)
     |     }
 991 |     _ => Err("inlining: callee must be a TFunc for inlining")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn il_inline_at_callsite(
     |   action : ILInlineAction,
     |   callee_func : Func,
     |   callee_type : FuncType,
     |   args : Array[TInstr],
     |   caller_param_count : Int,
     |   caller_locals : Array[ValType],
     | ) -> Result[TInstr?, String] {
     |   match action.kind {
     |     ILReturnCall =>
     |       match il_inline_tail_wrapper_call(callee_func, args) {
     |         Ok(Some(instr)) => Ok(Some(instr))
1008 |         Ok(None) => Ok(None)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |       }
     |     ILDirectCall =>
     |       match
     |         il_inline_normal_call(
     |           action, callee_func, callee_type, args, caller_param_count, caller_locals,
     |         ) {
     |         Ok(instr) => Ok(Some(instr))
1017 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn il_prepare_hoisted_tail_call(
     |   callee_func : Func,
     |   call_args : Array[TInstr],
     |   caller_param_count : Int,
     |   caller_locals : Array[ValType],
     |   env : Env,
     |   func_types : Array[FuncType],
     | ) -> Result[(TInstr, TInstr, TInstr), String] {
     |   let inlined = match il_inline_tail_wrapper_call(callee_func, call_args) {
     |     Ok(Some(instr)) => instr
     |     Ok(None) =>
1034 |       return Err("inlining: expected a tail-wrapper callee for hoisting")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => return Err(e)
     |   }
     |   match inlined {
     |     TReturnCall(target, hoisted_args) => {
     |       let FuncIdx(target_raw) = target
     |       let target_abs = target_raw.reinterpret_as_int()
     |       if target_abs < 0 || target_abs >= func_types.length() {
1042 |         return Err("inlining: hoisted return_call target index out of range")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let FuncType(target_params, _) = func_types[target_abs]
     |       if target_params.length() != hoisted_args.length() {
1046 |         return Err("inlining: hoisted return_call argument count mismatch")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let stores : Array[TInstr] = []
     |       let localized_args : Array[TInstr] = []
     |       for i = 0; i < hoisted_args.length(); i = i + 1 {
1051 |         let idx = caller_param_count + caller_locals.length()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         caller_locals.push(target_params[i])
     |         let local_idx = il_local_idx_from_int(idx)
     |         stores.push(TInstr::local_set(local_idx, hoisted_args[i]))
     |         localized_args.push(TInstr::local_get(local_idx))
     |       }
     |       let flag_local_i = caller_param_count + caller_locals.length()
     |       caller_locals.push(ValType::i32())
     |       let flag_local = il_local_idx_from_int(flag_local_i)
     |       let flag_init = TInstr::local_set(flag_local, TInstr::i32_const(I32(0)))
     |       stores.push(TInstr::local_set(flag_local, TInstr::i32_const(I32(1))))
     |       stores.push(TInstr::unreachable_())
     |       let replacement = TInstr::block(BlockType::void_(), TExpr::new(stores))
     |       let followup = TInstr::if_(
     |         BlockType::void_(),
     |         TInstr::local_get(flag_local),
     |         TExpr::new([TInstr::return_call(target, localized_args)]),
     |         None,
     |       )
     |       Ok((replacement, flag_init, followup))
     |     }
     |     TReturnCallIndirect(type_idx, table_idx, hoisted_args, idx) => {
     |       let FuncType(target_params, _) = match env.resolve_functype(type_idx) {
     |         Some(ft) => ft
     |         None =>
1076 |           return Err(
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             "inlining: hoisted return_call_indirect has invalid function type index",
     |           )
     |       }
     |       if target_params.length() != hoisted_args.length() {
1081 |         return Err(
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |           "inlining: hoisted return_call_indirect argument count mismatch",
     |         )
     |       }
     |       let stores : Array[TInstr] = []
     |       let localized_args : Array[TInstr] = []
     |       for i = 0; i < hoisted_args.length(); i = i + 1 {
1088 |         let local_i = caller_param_count + caller_locals.length()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         caller_locals.push(target_params[i])
     |         let local_idx = il_local_idx_from_int(local_i)
     |         stores.push(TInstr::local_set(local_idx, hoisted_args[i]))
     |         localized_args.push(TInstr::local_get(local_idx))
     |       }
     |       let idx_local_i = caller_param_count + caller_locals.length()
     |       caller_locals.push(ValType::i32())
     |       let idx_local = il_local_idx_from_int(idx_local_i)
     |       stores.push(TInstr::local_set(idx_local, idx))
     |       let flag_local_i = caller_param_count + caller_locals.length()
     |       caller_locals.push(ValType::i32())
     |       let flag_local = il_local_idx_from_int(flag_local_i)
     |       let flag_init = TInstr::local_set(flag_local, TInstr::i32_const(I32(0)))
     |       stores.push(TInstr::local_set(flag_local, TInstr::i32_const(I32(1))))
     |       stores.push(TInstr::unreachable_())
     |       let replacement = TInstr::block(BlockType::void_(), TExpr::new(stores))
     |       let followup = TInstr::if_(
     |         BlockType::void_(),
     |         TInstr::local_get(flag_local),
     |         TExpr::new([
     |           TInstr::return_call_indirect(
     |             type_idx,
     |             table_idx,
     |             localized_args,
     |             TInstr::local_get(idx_local),
     |           ),
     |         ]),
     |         None,
     |       )
     |       Ok((replacement, flag_init, followup))
     |     }
     |     TReturnCallRef(type_idx, hoisted_args, ref_) => {
     |       let FuncType(target_params, _) = match env.resolve_functype(type_idx) {
     |         Some(ft) => ft
     |         None =>
1124 |           return Err(
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             "inlining: hoisted return_call_ref has invalid function type index",
     |           )
     |       }
     |       if target_params.length() != hoisted_args.length() {
1129 |         return Err("inlining: hoisted return_call_ref argument count mismatch")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let stores : Array[TInstr] = []
     |       let localized_args : Array[TInstr] = []
     |       for i = 0; i < hoisted_args.length(); i = i + 1 {
1134 |         let local_i = caller_param_count + caller_locals.length()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         caller_locals.push(target_params[i])
     |         let local_idx = il_local_idx_from_int(local_i)
     |         stores.push(TInstr::local_set(local_idx, hoisted_args[i]))
     |         localized_args.push(TInstr::local_get(local_idx))
     |       }
     |       let ref_local_i = caller_param_count + caller_locals.length()
     |       caller_locals.push(ValType::funcref())
     |       let ref_local = il_local_idx_from_int(ref_local_i)
     |       stores.push(TInstr::local_set(ref_local, ref_))
     |       let flag_local_i = caller_param_count + caller_locals.length()
     |       caller_locals.push(ValType::i32())
     |       let flag_local = il_local_idx_from_int(flag_local_i)
     |       let flag_init = TInstr::local_set(flag_local, TInstr::i32_const(I32(0)))
     |       stores.push(TInstr::local_set(flag_local, TInstr::i32_const(I32(1))))
     |       stores.push(TInstr::unreachable_())
     |       let replacement = TInstr::block(BlockType::void_(), TExpr::new(stores))
     |       let followup = TInstr::if_(
     |         BlockType::void_(),
     |         TInstr::local_get(flag_local),
     |         TExpr::new([
     |           TInstr::return_call_ref(
     |             type_idx,
     |             localized_args,
     |             TInstr::local_get(ref_local),
     |           ),
     |         ]),
     |         None,
     |       )
     |       Ok((replacement, flag_init, followup))
     |     }
     |     _ =>
1166 |       Err(
     |       ^^^^ 	<-- UNCOVERED
     |         "inlining: hoist currently supports return_call/return_call_indirect/return_call_ref wrappers",
     |       )
     |   }
     | }
     …

     | fn il_apply_actions_to_func(
     |   caller_type : FuncType,
     |   caller_func : Func,
     |   actions : Map[Int, ILInlineAction],
     |   funcs_by_abs : Array[Func?],
     |   env : Env,
     |   func_types : Array[FuncType],
     | ) -> Result[(Func, Int), String] {
     |   if actions.is_empty() {
1182 |     return Ok((caller_func, 0))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FuncType(caller_params, _) = caller_type
     |   match caller_func {
     |     TFunc(locals, body) => {
     |       let caller_locals = locals.copy()
     |       let FuncType(_, caller_results) = caller_type
     |       let mut next_id = 0
     |       let mut applied = 0
     |       let mut changed = false
     |       let hoisted_inits : Array[TInstr] = []
     |       let hoisted_followups : Array[TInstr] = []
     |       let rewriter = ModuleTransformer::new().on_tinstruction_evt(fn(
     |         self,
     |         _,
     |         instr,
     |       ) {
     |         match instr {
     |           TTryTable(bt, catches, try_body) => {
     |             let walked_body = match self.walk_texpr((), try_body) {
     |               Ok(Some((_, next))) => next
1203 |               Ok(None) => try_body
     |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |             if walked_body == try_body {
1207 |               unchanged()
     |               ^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else {
     |               changed = true
     |               change((), TInstr::try_table(bt, catches, walked_body))
     |             }
     |           }
     |           _ => {
     |             let walked = match self.walk_tinstruction_default((), instr) {
     |               Ok(Some((_, next))) => next
     |               Ok(None) => instr
1217 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let maybe_action = match walked {
     |               TCall(fi, args) => {
     |                 let id = next_id
     |                 next_id += 1
     |                 match actions.get(id) {
     |                   Some(action) => {
     |                     let FuncIdx(raw) = fi
     |                     let callee_abs_idx = raw.reinterpret_as_int()
     |                     if action.callee_abs_idx == callee_abs_idx &&
     |                       action.kind == ILDirectCall {
     |                       Some((action, args))
     |                     } else {
1231 |                       None
     |                       ^^^^ 	<-- UNCOVERED
     |                     }
     |                   }
1234 |                   None => None
     |                   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
     |               TReturnCall(fi, args) => {
     |                 let id = next_id
     |                 next_id += 1
     |                 match actions.get(id) {
     |                   Some(action) => {
     |                     let FuncIdx(raw) = fi
     |                     let callee_abs_idx = raw.reinterpret_as_int()
     |                     if action.callee_abs_idx == callee_abs_idx &&
     |                       action.kind == ILReturnCall {
     |                       Some((action, args))
     |                     } else {
1248 |                       None
     |                       ^^^^ 	<-- UNCOVERED
     |                     }
     |                   }
1251 |                   None => None
     |                   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
     |               _ => None
     |             }
     |             match maybe_action {
     |               Some((action, call_args)) =>
     |                 if action.callee_abs_idx < 0 ||
     |                   action.callee_abs_idx >= funcs_by_abs.length() {
1260 |                   Err("inlining: callee index out of range")
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 } else {
     |                   match funcs_by_abs[action.callee_abs_idx] {
     |                     Some(callee_func) =>
     |                       if action.kind == ILReturnCall && action.try_depth > 0 {
     |                         match
     |                           il_prepare_hoisted_tail_call(
     |                             callee_func,
     |                             call_args,
     |                             caller_params.length(),
     |                             caller_locals,
     |                             env,
     |                             func_types,
     |                           ) {
     |                           Ok((replacement, init, followup)) => {
     |                             hoisted_inits.push(init)
     |                             hoisted_followups.push(followup)
     |                             changed = true
     |                             applied += 1
     |                             change((), replacement)
     |                           }
1281 |                           Err(e) => Err(e)
     |                           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         }
     |                       } else {
     |                         match
     |                           il_inline_at_callsite(
     |                             ILInlineAction::{
     |                               callsite_id: action.callsite_id,
     |                               caller_abs_idx: action.caller_abs_idx,
     |                               callee_abs_idx: action.callee_abs_idx,
     |                               kind: action.kind,
     |                               try_depth: action.try_depth,
     |                               force_unreachable: action.force_unreachable,
     |                             },
     |                             callee_func,
     |                             func_types[action.callee_abs_idx],
     |                             call_args,
     |                             caller_params.length(),
     |                             caller_locals,
     |                           ) {
     |                           Ok(Some(replacement)) => {
     |                             changed = true
     |                             applied += 1
     |                             change((), replacement)
     |                           }
     |                           Ok(None) =>
1306 |                             if walked == instr {
     |                             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                               unchanged()
     |                             } else {
1309 |                               change((), walked)
     |                               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                             }
1311 |                           Err(e) => Err(e)
     |                           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         }
     |                       }
1314 |                     None => Err("inlining: callee function body is missing")
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |               None =>
     |                 if walked == instr {
     |                   unchanged()
     |                 } else {
     |                   changed = true
     |                   change((), walked)
     |                 }
     |             }
     |           }
     |         }
     |       })
     |       let new_body = match rewriter.walk_texpr((), body) {
     |         Ok(Some((_, next))) => next
1330 |         Ok(None) => body
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |       }
     |       let final_body = if hoisted_followups.is_empty() {
     |         new_body
     |       } else {
     |         let wrapper_type = match il_make_block_type(caller_results) {
     |           Some(bt) => bt
     |           None =>
1339 |             return Err(
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |               "inlining: hoisted tail-call rewrite does not support multi-value results",
     |             )
     |         }
     |         let wrapped_instrs = hoisted_inits.copy()
     |         for instr in new_body.0 {
     |           wrapped_instrs.push(instr)
     |         }
     |         let final_instrs : Array[TInstr] = [
     |           TInstr::block(wrapper_type, TExpr::new(wrapped_instrs)),
     |         ]
     |         for instr in hoisted_followups {
     |           final_instrs.push(instr)
     |         }
     |         TExpr::new(final_instrs)
     |       }
     |       if changed || caller_locals != locals {
     |         Ok((Func::t_func(caller_locals, final_body), applied))
     |       } else {
1358 |         Ok((caller_func, 0))
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1361 |     _ => Ok((caller_func, 0))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn il_run_partial_splitting(
     |   mod : Module,
     |   options : OptimizeOptions,
     | ) -> Result[Module, String] {
     |   if options.optimize_level < 3 ||
     |     options.shrink_level != 0 ||
     |     options.inlining.partial_inlining_ifs <= 0 {
     |     return Ok(mod)
     |   }
     |   let import_count = il_count_imported_funcs(mod)
     |   let func_types = il_collect_func_types(
     |     mod,
     |     il_total_functions(mod, import_count),
     |   )
     |   let type_idxs = match mod.func_sec {
     |     Some(FuncSec(items)) => items.copy()
1382 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items.copy()
1386 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let original_len = funcs.length()
     |   let mut changed = false
     |   let max_ifs = options.inlining.partial_inlining_ifs
     |   for def_idx = 0; def_idx < original_len; def_idx = def_idx + 1 {
     |     let abs_idx = import_count + def_idx
     |     let func_type = func_types[abs_idx]
     |     let FuncType(params, results) = func_type
     |     if results.length() != 0 {
1396 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let curr = funcs[def_idx]
     |     match curr {
     |       TFunc(locals, body) => {
     |         // Pattern A: top-level if (cond) return; then remainder.
     |         if body.0.length() >= 2 {
     |           match body.0[0] {
     |             TIf(VoidBlockType, cond, then_body, None) => {
     |               let mut has_return = false
     |               for instr in then_body.0 {
     |                 match instr {
     |                   TReturn([]) => has_return = true
     |                   _ => ()
     |                 }
     |               }
     |               if has_return {
     |                 let outlined_abs = import_count + funcs.length()
     |                 let outlined_args : Array[TInstr] = []
     |                 for p = 0; p < params.length(); p = p + 1 {
     |                   outlined_args.push(
     |                     TInstr::local_get(il_local_idx_from_int(p)),
     |                   )
     |                 }
     |                 let outlined_instrs : Array[TInstr] = []
     |                 for i = 1; i < body.0.length(); i = i + 1 {
     |                   outlined_instrs.push(body.0[i])
     |                 }
     |                 funcs.push(Func::t_func(locals, TExpr::new(outlined_instrs)))
     |                 type_idxs.push(type_idxs[def_idx])
     |                 funcs[def_idx] = Func::t_func(
     |                   locals,
     |                   TExpr::new([
     |                     TInstr::if_(BlockType::void_(), cond, then_body, None),
     |                     TInstr::call(
     |                       il_func_idx_from_abs(outlined_abs),
     |                       outlined_args,
     |                     ),
     |                   ]),
     |                 )
     |                 changed = true
     |                 continue
     |               }
     |             }
1440 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     | 
     |         // Pattern B: 1..MaxIfs top-level ifs, optional trailing item.
     |         let mut prefix_ifs = 0
     |         while prefix_ifs < body.0.length() && prefix_ifs < max_ifs {
     |           match body.0[prefix_ifs] {
     |             TIf(VoidBlockType, _, _, None) => prefix_ifs += 1
     |             _ => break
     |           }
     |         }
     |         if prefix_ifs == 0 {
1453 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if body.0.length() > prefix_ifs + 1 {
1456 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let trailing = if body.0.length() == prefix_ifs + 1 {
     |           Some(body.0[prefix_ifs])
     |         } else {
1461 |           None
     |           ^^^^ 	<-- UNCOVERED
     |         }
     |         let if_writes : Set[LocalIdx] = Set::new()
     |         let mut invalid = false
     |         for i = 0; i < prefix_ifs; i = i + 1 {
     |           match body.0[i] {
     |             TIf(_, _, then_body, None) => {
     |               let then_is_unreachable = if then_body.0.length() == 1 {
     |                 match then_body.0[0] {
1470 |                   TUnreachable => true
     |                   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   _ => false
     |                 }
     |               } else {
1474 |                 false
     |                 ^^^^^ 	<-- UNCOVERED
     |               }
     |               if !then_is_unreachable {
     |                 let mut has_return = false
     |                 let scan = ModuleTransformer::new().on_tinstruction_evt(fn(
     |                   self,
     |                   _,
     |                   instr,
     |                 ) {
     |                   match instr {
1484 |                     TReturn(_) => has_return = true
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     TLocalSet(idx, _) | TLocalTee(idx, _) => if_writes.add(idx)
     |                     _ => ()
     |                   }
     |                   self.walk_tinstruction_default((), instr)
     |                 })
     |                 ignore(scan.walk_texpr((), then_body))
     |                 if has_return {
1492 |                   invalid = true
     |                   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
     |             }
1496 |             _ => invalid = true
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         if invalid {
1500 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match trailing {
     |           Some(last) => {
     |             let trailing_reads : Set[LocalIdx] = Set::new()
     |             let scan = ModuleTransformer::new().on_tinstruction_evt(fn(
     |               self,
     |               _,
     |               instr,
     |             ) {
     |               match instr {
     |                 TLocalGet(idx) => trailing_reads.add(idx)
     |                 _ => ()
     |               }
     |               self.walk_tinstruction_default((), instr)
     |             })
     |             ignore(scan.walk_tinstruction((), last))
     |             let mut dep = false
     |             for idx in trailing_reads.iter() {
     |               if if_writes.contains(idx) {
     |                 dep = true
     |               }
     |             }
     |             if dep {
     |               continue
     |             }
     |           }
1527 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let outlined_args : Array[TInstr] = []
1530 |         for p = 0; p < params.length(); p = p + 1 {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           outlined_args.push(TInstr::local_get(il_local_idx_from_int(p)))
     |         }
     |         let replaced : Array[TInstr] = []
1534 |         for i = 0; i < prefix_ifs; i = i + 1 {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           match body.0[i] {
     |             TIf(_, cond, then_body, None) => {
     |               let outlined_abs = import_count + funcs.length()
     |               funcs.push(Func::t_func(locals, then_body))
     |               type_idxs.push(type_idxs[def_idx])
     |               replaced.push(
     |                 TInstr::if_(
     |                   BlockType::void_(),
     |                   cond,
1544 |                   TExpr::new([
     |                   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     TInstr::call(
     |                       il_func_idx_from_abs(outlined_abs),
     |                       outlined_args,
     |                     ),
     |                   ]),
     |                   None,
     |                 ),
     |               )
     |               changed = true
     |             }
1555 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
1558 |         match trailing {
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Some(last) => replaced.push(last)
     |           None => ()
     |         }
     |         if !replaced.is_empty() {
1563 |           funcs[def_idx] = Func::t_func(locals, TExpr::new(replaced))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1566 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if !changed {
     |     Ok(mod)
     |   } else {
     |     Ok(
     |       mod
     |       .with_func_sec(FuncSec::new(type_idxs))
     |       .with_code_sec(CodeSec::new(funcs)),
     |     )
     |   }
     | }
     …

     | fn il_plan_actions(
     |   infos : Array[ILFunctionInfo],
     |   callsites_by_caller : Array[Array[ILCallSite]],
     |   incoming_counts : Array[Int],
     |   options : OptimizeOptions,
     |   import_count : Int,
     |   inlined_into_count : Array[Int],
     |   module_size : Int,
     | ) -> Array[ILInlineAction] {
     |   let prelim : Array[ILInlineAction] = []
     |   let mut planned_growth = 0
     |   for caller_abs = 0
     |       caller_abs < callsites_by_caller.length()
     |       caller_abs = caller_abs + 1 {
     |     if caller_abs < import_count {
1596 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let caller_def = caller_abs - import_count
     |     if caller_def < 0 || caller_def >= inlined_into_count.length() {
1600 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if inlined_into_count[caller_def] >= 5 {
1603 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     for site in callsites_by_caller[caller_abs] {
     |       let callee_abs = site.callee_abs_idx
     |       if callee_abs < 0 || callee_abs >= infos.length() {
1608 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if callee_abs == caller_abs {
1611 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let callee_info = infos[callee_abs]
     |       if !il_worth_full_inlining(
     |           callee_info,
     |           incoming_counts[callee_abs],
     |           options,
     |         ) {
     |         continue
     |       }
     |       if site.kind == ILReturnCall && !callee_info.tail_wrapper {
     |         continue
     |       }
     |       let growth = if callee_info.size > 1 { callee_info.size - 1 } else { 0 }
     |       if module_size + planned_growth + growth >
     |         options.inlining.max_combined_binary_size {
     |         continue
     |       }
     |       planned_growth += growth
     |       prelim.push({
     |         callsite_id: site.id,
     |         caller_abs_idx: site.caller_abs_idx,
     |         callee_abs_idx: site.callee_abs_idx,
     |         kind: site.kind,
     |         try_depth: site.try_depth,
     |         force_unreachable: site.force_unreachable,
     |       })
     |     }
     |   }
     |   let inlined_callees : Set[Int] = Set::new()
     |   for action in prelim {
     |     inlined_callees.add(action.callee_abs_idx)
     |   }
     |   let final_actions : Array[ILInlineAction] = []
     |   for action in prelim {
     |     if !inlined_callees.contains(action.caller_abs_idx) {
     |       final_actions.push(action)
     |     }
     |   }
     |   final_actions
     | }
     …

     | fn il_apply_actions_iteration(
     |   mod : Module,
     |   import_count : Int,
     |   func_types : Array[FuncType],
     |   funcs_by_abs : Array[Func?],
     |   actions : Array[ILInlineAction],
     | ) -> Result[(Module, Array[Int], Bool), String] {
     |   if actions.is_empty() {
1662 |     return Ok((mod, [], false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items.copy()
1666 |     None => return Ok((mod, [], false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let action_maps : Array[Map[Int, ILInlineAction]] = []
     |   for i = 0; i < funcs_by_abs.length(); i = i + 1 {
     |     action_maps.push(Map::new())
     |   }
     |   for action in actions {
     |     if action.caller_abs_idx >= 0 &&
     |       action.caller_abs_idx < action_maps.length() {
     |       action_maps[action.caller_abs_idx].set(action.callsite_id, action)
     |     }
     |   }
     |   let applied_by_def : Array[Int] = []
     |   for i = 0; i < funcs.length(); i = i + 1 {
     |     applied_by_def.push(0)
     |   }
     |   let mut changed = false
     |   let env = Env::new().with_module(mod)
     |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
     |     let abs_idx = import_count + def_idx
     |     let actions_for_func = action_maps[abs_idx]
     |     if actions_for_func.is_empty() {
     |       continue
     |     }
     |     let result = match
     |       il_apply_actions_to_func(
     |         func_types[abs_idx],
     |         funcs[def_idx],
     |         actions_for_func,
     |         funcs_by_abs,
     |         env,
     |         func_types,
     |       ) {
     |       Ok(next) => next
1700 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let (next_func, applied) = result
     |     if applied > 0 {
     |       funcs[def_idx] = next_func
     |       applied_by_def[def_idx] += applied
     |       changed = true
     |     }
     |   }
     |   if !changed {
1710 |     Ok((mod, applied_by_def, false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     Ok((mod.with_code_sec(CodeSec::new(funcs)), applied_by_def, true))
     |   }
     | }
     …

     | fn inlining(
     |   mod : Module,
     |   options : OptimizeOptions,
     |   optimizing : Bool,
     | ) -> Result[Module, String] {
     |   let mut mod = mod
     |   mod = match il_run_partial_splitting(mod, options) {
     |     Ok(m) => m
1725 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_count = il_count_imported_funcs(mod)
     |   let original_defined = match mod.code_sec {
     |     Some(CodeSec(funcs)) => funcs.length()
1730 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let max_iterations = if original_defined > 0 { original_defined } else { 1 }
     |   let inlined_into_count : Array[Int] = []
     |   for i = 0; i < original_defined; i = i + 1 {
     |     inlined_into_count.push(0)
     |   }
     |   let mut changed_any = false
     |   for iter_i = 0; iter_i < max_iterations; iter_i = iter_i + 1 {
     |     let total_funcs = il_total_functions(mod, import_count)
     |     let func_types = il_collect_func_types(mod, total_funcs)
     |     let funcs_by_abs = il_collect_funcs_by_abs(mod, import_count)
     |     let infos = il_collect_infos(mod, funcs_by_abs, func_types)
     |     let callsites_by_caller = il_collect_callsites(mod, import_count)
     |     let incoming_counts = il_collect_incoming_counts(
     |       callsites_by_caller, total_funcs,
     |     )
     |     let module_size = il_estimate_module_size(infos)
     |     let actions = il_plan_actions(
     |       infos, callsites_by_caller, incoming_counts, options, import_count, inlined_into_count,
     |       module_size,
     |     )
     |     if actions.is_empty() {
     |       break
     |     }
     |     let iter = match
     |       il_apply_actions_iteration(
     |         mod, import_count, func_types, funcs_by_abs, actions,
     |       ) {
     |       Ok(next) => next
1760 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let (next_mod, applied_by_def, changed) = iter
     |     if !changed {
1764 |       break
     |       ^^^^^ 	<-- UNCOVERED
     |     }
     |     for i = 0; i < inlined_into_count.length(); i = i + 1 {
     |       inlined_into_count[i] += applied_by_def[i]
     |     }
     |     mod = next_mod
     |     changed_any = true
     |   }
     |   if optimizing && changed_any {
1773 |     mod = match
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       il_apply_ir_transformer_pass(mod, dead_code_elimination_ir_pass(mod)) {
     |       Ok(next) => next
     |       Err(e) => return Err(e)
     |     }
1778 |     mod = match il_apply_ir_transformer_pass(mod, code_folding_ir_pass(mod)) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Ok(next) => next
     |       Err(e) => return Err(e)
     |     }
     |   }
     |   Ok(mod)
     | }
     …

     | fn il_find_exported_func(mod : Module, name : String) -> FuncIdx? {
     |   let expected = Name::new(name)
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         match export_ {
     |           Export(n, FuncExternIdx(idx)) if n == expected => return Some(idx)
     |           _ => ()
     |         }
     |       }
1797 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   None
     | }
     …

     | fn inline_main(
     |   mod : Module,
     |   _options : OptimizeOptions,
     | ) -> Result[Module, String] {
     |   let main_idx = match il_find_exported_func(mod, "main") {
     |     Some(idx) => idx
1809 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let original_idx = match il_find_exported_func(mod, "__original_main") {
     |     Some(idx) => idx
1813 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_count = il_count_imported_funcs(mod)
     |   let FuncIdx(main_raw) = main_idx
     |   let FuncIdx(orig_raw) = original_idx
     |   let main_abs = main_raw.reinterpret_as_int()
     |   let orig_abs = orig_raw.reinterpret_as_int()
     |   if main_abs < import_count || orig_abs < import_count {
1821 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let main_def = main_abs - import_count
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items.copy()
1826 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if main_def < 0 || main_def >= funcs.length() {
1829 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let sites = match funcs[main_def] {
     |     TFunc(_, body) => il_collect_callsites_for_body(main_abs, body)
1833 |     _ => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let target_sites : Array[ILCallSite] = []
     |   for site in sites {
     |     if site.kind == ILDirectCall && site.callee_abs_idx == orig_abs {
     |       target_sites.push(site)
     |     }
     |   }
     |   if target_sites.length() != 1 {
     |     return Ok(mod)
     |   }
     |   let total_funcs = il_total_functions(mod, import_count)
     |   let func_types = il_collect_func_types(mod, total_funcs)
     |   let funcs_by_abs = il_collect_funcs_by_abs(mod, import_count)
     |   let action_map : Map[Int, ILInlineAction] = Map::new()
     |   let site = target_sites[0]
     |   action_map.set(site.id, {
     |     callsite_id: site.id,
     |     caller_abs_idx: main_abs,
     |     callee_abs_idx: orig_abs,
     |     kind: ILDirectCall,
     |     try_depth: site.try_depth,
     |     force_unreachable: site.force_unreachable,
     |   })
     |   let applied = match
     |     il_apply_actions_to_func(
     |       func_types[main_abs],
     |       funcs[main_def],
     |       action_map,
     |       funcs_by_abs,
     |       Env::new().with_module(mod),
     |       func_types,
     |     ) {
     |     Ok(next) => next
1867 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (new_main, n_applied) = applied
     |   if n_applied == 0 {
1871 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   funcs[main_def] = new_main
     |   Ok(mod.with_code_sec(CodeSec::new(funcs)))
     | }
     …

     | fn il_count_calls(body : TExpr, target : FuncIdx) -> Int {
     |   let mut calls = 0
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
1887 |       TCall(fi, _) | TReturnCall(fi, _) => if fi == target { calls += 1 }
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   calls
     | }
     …

     | fn il_has_return(body : TExpr) -> Bool {
     |   let mut found = false
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
1957 |       TReturn(_) => found = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   found
     | }
     …

2 uncovered line(s) in src/passes/lift_to_texpr.mbt:

   | fn lift_to_texpr_pass() -> ModuleTransformer[Unit] {
   |   ModuleTransformer::new().on_func_evt(fn(
   |     _ : ModuleTransformer[Unit],
   |     _ : Unit,
   |     f : Func,
   |   ) -> TransformerResult[Unit, Func] {
   |     match f {
   |       Func(l, t) =>
   |         match to_texpr(t, Env::new()) {
   |           Ok(t) =>
   |             match expand_locals(l) {
   |               Ok(l) => change((), Func::t_func(l, t))
14 |               Err(t) => Err(t)
   |               ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |             }
16 |           Err(t) => Err(t)
   |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         }
   |       TFunc(_, _) => unchanged()
   |     }
   |   })
   | }
   …

186 uncovered line(s) in src/passes/local_cse.mbt:

     | fn lcs_collect_shallow_effects_into(
     |   instr : TInstr,
     |   effects : LCSEffects,
     | ) -> Unit {
     |   match instr {
     |     TLocalGet(idx) => effects.locals_read.add(idx)
     |     TLocalSet(idx, _) => effects.locals_written.add(idx)
     |     TLocalTee(idx, _) => {
     |       effects.locals_read.add(idx)
     |       effects.locals_written.add(idx)
     |     }
     |     TGlobalGet(_) => effects.reads_globals = true
     |     TGlobalSet(_, _) => effects.writes_globals = true
     |     TLoad(_, _, _) => {
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
     |     TStore(_, _, _, _) => {
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TMemoryGrow(_, _) => effects.writes_memory = true
 215 |     TMemorySize(_) => effects.reads_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryCopy(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
     |     TMemoryFill(_, _, _, _) => effects.writes_memory = true
 221 |     TMemoryInit(_, _, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
     |     TDataDrop(_) => effects.writes_memory = true
     |     TTableSet(_, _, _) | TTableGrow(_, _, _) | TTableFill(_, _, _, _) =>
     |       effects.writes_memory = true
 228 |     TTableGet(_, _) | TTableSize(_) => effects.reads_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableCopy(_, _, _, _, _) | TTableInit(_, _, _, _, _) | TElemDrop(_) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
     |     TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
     |       effects.calls = true
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
     |     | TReturnCallRef(_, _, _) => {
     |       effects.calls = true
     |       effects.branches = true
     |     }
     |     TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
     |     | TReturn(_) => effects.branches = true
     |     TThrow(_, _) => {
     |       effects.throws = true
     |       effects.branches = true
     |     }
     |     TThrowRef(_) => {
     |       effects.throws = true
     |       effects.branches = true
     |     }
     |     TUnreachable => effects.traps = true
     |     TRefAsNonNull(_) | TRefCast(_, _, _) => effects.traps = true
 259 |     TStructGet(_, _, _) | TStructGetS(_, _, _) | TStructGetU(_, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
     |     TStructSet(_, _, _, _) => {
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TArrayNew(_, _, _)
     |     | TArrayNewDefault(_, _)
     |     | TArrayNewFixed(_, _)
     |     | TArrayNewData(_, _, _, _)
     |     | TArrayNewElem(_, _, _, _) => {
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TArrayGet(_, _, _)
     |     | TArrayGetS(_, _, _)
     |     | TArrayGetU(_, _, _)
     |     | TArrayLen(_) => {
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
     |     TArraySet(_, _, _, _)
     |     | TArrayFill(_, _, _, _, _)
     |     | TArrayCopy(_, _, _, _, _, _, _)
     |     | TArrayInitData(_, _, _, _, _, _)
     |     | TArrayInitElem(_, _, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TBinary(op, _, _) =>
     |       match op {
     |         I32DivSOp
     |         | I32DivUOp
     |         | I32RemSOp
     |         | I32RemUOp
     |         | I64DivSOp
     |         | I64DivUOp
     |         | I64RemSOp
     |         | I64RemUOp => effects.traps = true
     |         _ => ()
     |       }
     |     TUnary(op, _) =>
     |       match op {
     |         I32TruncF32SOp
     |         | I32TruncF32UOp
     |         | I32TruncF64SOp
     |         | I32TruncF64UOp
     |         | I64TruncF32SOp
     |         | I64TruncF32UOp
     |         | I64TruncF64SOp
     |         | I64TruncF64UOp => effects.traps = true
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn lcs_is_shallowly_generative(instr : TInstr) -> Bool {
     |   match instr {
     |     TStructNew(_, _)
     |     | TStructNewDefault(_)
     |     | TArrayNew(_, _, _)
     |     | TArrayNewDefault(_, _)
     |     | TArrayNewFixed(_, _)
     |     | TArrayNewData(_, _, _, _)
 340 |     | TArrayNewElem(_, _, _, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn lcs_measure(instr : TInstr) -> Int {
     |   let mut total = 1
     |   match instr {
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       total += lcs_measure_texpr(body)
 404 |     TIf(_, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       total += lcs_measure(cond)
     |       total += lcs_measure_texpr(then_)
     |       match else_ {
     |         Some(other) => total += lcs_measure_texpr(other)
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         total += lcs_measure(child)
     |       }
     |   }
     |   total
     | }
     …

     | fn lcs_unary_result_type(op : UnaryOp, operand_ty : ValType?) -> ValType? {
     |   match op {
     |     I32EqzOp
     |     | I32ClzOp
     |     | I32CtzOp
     |     | I32PopcntOp
     |     | I32WrapI64Op
     |     | I32TruncF32SOp
     |     | I32TruncF32UOp
     |     | I32TruncF64SOp
     |     | I32TruncF64UOp
     |     | I32ReinterpretF32Op
     |     | I32Extend8SOp
     |     | I32Extend16SOp
     |     | I32TruncSatF32SOp
     |     | I32TruncSatF32UOp
     |     | I32TruncSatF64SOp
     |     | I32TruncSatF64UOp
     |     | I64EqzOp
     |     | V128AnyTrueOp
     |     | I8x16AllTrueOp
     |     | I8x16BitmaskOp
     |     | I16x8AllTrueOp
     |     | I16x8BitmaskOp
     |     | I32x4AllTrueOp
     |     | I32x4BitmaskOp
     |     | I64x2AllTrueOp
     |     | I64x2BitmaskOp => Some(ValType::i32())
     |     I64ClzOp
     |     | I64CtzOp
     |     | I64PopcntOp
     |     | I64ExtendI32SOp
     |     | I64ExtendI32UOp
     |     | I64TruncF32SOp
     |     | I64TruncF32UOp
     |     | I64TruncF64SOp
     |     | I64TruncF64UOp
     |     | I64ReinterpretF64Op
     |     | I64Extend8SOp
     |     | I64Extend16SOp
     |     | I64Extend32SOp
     |     | I64TruncSatF32SOp
     |     | I64TruncSatF32UOp
     |     | I64TruncSatF64SOp
 491 |     | I64TruncSatF64UOp => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32AbsOp
     |     | F32NegOp
     |     | F32CeilOp
     |     | F32FloorOp
     |     | F32TruncOp
     |     | F32NearestOp
     |     | F32SqrtOp
     |     | F32ConvertI32SOp
     |     | F32ConvertI32UOp
     |     | F32ConvertI64SOp
     |     | F32ConvertI64UOp
     |     | F32DemoteF64Op
 504 |     | F32ReinterpretI32Op => Some(ValType::f32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64AbsOp
     |     | F64NegOp
     |     | F64CeilOp
     |     | F64FloorOp
     |     | F64TruncOp
     |     | F64NearestOp
     |     | F64SqrtOp
     |     | F64ConvertI32SOp
     |     | F64ConvertI32UOp
     |     | F64ConvertI64SOp
     |     | F64ConvertI64UOp
     |     | F64PromoteF32Op
 517 |     | F64ReinterpretI64Op => Some(ValType::f64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => operand_ty
     |   }
     | }
     …

     | fn lcs_binary_result_type(op : BinaryOp, lhs_ty : ValType?) -> ValType? {
     |   match op {
     |     I32EqOp
     |     | I32NeOp
     |     | I32LtSOp
     |     | I32LtUOp
     |     | I32GtSOp
     |     | I32GtUOp
     |     | I32LeSOp
     |     | I32LeUOp
     |     | I32GeSOp
     |     | I32GeUOp
     |     | I64EqOp
     |     | I64NeOp
     |     | I64LtSOp
     |     | I64LtUOp
     |     | I64GtSOp
     |     | I64GtUOp
     |     | I64LeSOp
     |     | I64LeUOp
     |     | I64GeSOp
     |     | I64GeUOp
     |     | F32EqOp
     |     | F32NeOp
     |     | F32LtOp
     |     | F32GtOp
     |     | F32LeOp
     |     | F32GeOp
     |     | F64EqOp
     |     | F64NeOp
     |     | F64LtOp
     |     | F64GtOp
     |     | F64LeOp
 556 |     | F64GeOp => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AddOp
     |     | I32SubOp
     |     | I32MulOp
     |     | I32DivSOp
     |     | I32DivUOp
     |     | I32RemSOp
     |     | I32RemUOp
     |     | I32AndOp
     |     | I32OrOp
     |     | I32XorOp
     |     | I32ShlOp
     |     | I32ShrSOp
     |     | I32ShrUOp
     |     | I32RotlOp
     |     | I32RotrOp => Some(ValType::i32())
     |     I64AddOp
     |     | I64SubOp
     |     | I64MulOp
     |     | I64DivSOp
     |     | I64DivUOp
     |     | I64RemSOp
     |     | I64RemUOp
     |     | I64AndOp
     |     | I64OrOp
     |     | I64XorOp
     |     | I64ShlOp
     |     | I64ShrSOp
     |     | I64ShrUOp
     |     | I64RotlOp
 586 |     | I64RotrOp => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32AddOp
     |     | F32SubOp
     |     | F32MulOp
     |     | F32DivOp
     |     | F32MinOp
     |     | F32MaxOp
 593 |     | F32CopysignOp => Some(ValType::f32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64AddOp
     |     | F64SubOp
     |     | F64MulOp
     |     | F64DivOp
     |     | F64MinOp
     |     | F64MaxOp
 600 |     | F64CopysignOp => Some(ValType::f64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => lhs_ty
     |   }
     | }
     …

     | fn lcs_load_result_type(op : LoadOp) -> ValType {
     |   match op {
     |     I32LoadOp | I32Load8SOp | I32Load8UOp | I32Load16SOp | I32Load16UOp =>
     |       ValType::i32()
     |     I64LoadOp
     |     | I64Load8SOp
     |     | I64Load8UOp
     |     | I64Load16SOp
     |     | I64Load16UOp
     |     | I64Load32SOp
 616 |     | I64Load32UOp => ValType::i64()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32LoadOp => ValType::f32()
     |     F64LoadOp => ValType::f64()
     |     _ => ValType::v128()
     |   }
     | }
     …

     | fn lcs_ref_func_type(fi : FuncIdx, env : Env) -> ValType {
 625 |   match env.get_functype_by_funcidx(fi) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(_) => ValType::funcref()
     |     None => ValType::funcref()
     |   }
     | }
     …

     | fn lcs_infer_tinstr_type(instr : TInstr, env : Env) -> ValType? {
     |   fn single_result_of_blocktype(bt : BlockType, env : Env) -> ValType? {
     |     match env.expand_blocktype(bt) {
 635 |       Ok((_, [vt])) => Some(vt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => None
     |     }
     |   }
     | 
     |   fn infer_texpr_type(texpr : TExpr, env : Env) -> ValType? {
 641 |     let TExpr(instrs) = texpr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     if instrs.is_empty() {
 643 |       None
     |       ^^^^ 	<-- UNCOVERED
     |     } else {
 645 |       lcs_infer_tinstr_type(instrs[instrs.length() - 1], env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   match instr {
     |     TI32Const(_) => Some(ValType::i32())
 651 |     TI64Const(_) => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => Some(ValType::f32())
     |     TF64Const(_) => Some(ValType::f64())
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 655 |       Some(ValType::v128())
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
     |     TRefFunc(fi) => Some(lcs_ref_func_type(fi, env))
     |     TLocalGet(idx) => env.get_local_type(idx)
     |     TGlobalGet(idx) =>
 660 |       match env.get_global_type(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(GlobalType(vt, _)) => Some(vt)
     |         None => None
     |       }
     |     TLocalTee(_, value) => lcs_infer_tinstr_type(value, env)
     |     TUnary(op, value) =>
     |       lcs_unary_result_type(op, lcs_infer_tinstr_type(value, env))
     |     TBinary(op, lhs, _) =>
     |       lcs_binary_result_type(op, lcs_infer_tinstr_type(lhs, env))
 669 |     TRefEq(_, _) | TRefIsNull(_) | TRefTest(_, _, _) => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoad(op, _, _) => Some(lcs_load_result_type(op))
 671 |     TMemorySize(_) | TTableSize(_) => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefAsNonNull(value) =>
 673 |       match lcs_infer_tinstr_type(value, env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(RefTypeValType(rt)) =>
 675 |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TRefCast(nullable, ht, _) =>
 679 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructNew(type_idx, _)
     |     | TStructNewDefault(type_idx)
     |     | TArrayNew(type_idx, _, _)
     |     | TArrayNewDefault(type_idx, _)
     |     | TArrayNewFixed(type_idx, _)
     |     | TArrayNewData(type_idx, _, _, _)
     |     | TArrayNewElem(type_idx, _, _, _) =>
 687 |       Some(ValType::ref_type(RefType::new(false, HeapType::new(type_idx))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(type_idx, field_idx, _)
     |     | TStructGetS(type_idx, field_idx, _)
     |     | TStructGetU(type_idx, field_idx, _) =>
 691 |       match env.resolve_struct_fields(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(fields) =>
 693 |           match field_idx {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             U32(raw_idx) =>
 695 |               match fields.get(raw_idx.reinterpret_as_int()) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(field_ty) => Some(field_ty.unpack())
     |                 None => None
     |               }
     |           }
 700 |         Err(_) => None
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayGet(type_idx, _, _)
     |     | TArrayGetS(type_idx, _, _)
     |     | TArrayGetU(type_idx, _, _) =>
 705 |       match env.resolve_array_field(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(field_ty) => Some(field_ty.unpack())
     |         Err(_) => None
     |       }
 709 |     TArrayLen(_) => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TExtractLane(op, _, _) =>
 711 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I8x16ExtractLaneSOp
     |         | I8x16ExtractLaneUOp
     |         | I16x8ExtractLaneSOp
     |         | I16x8ExtractLaneUOp
 716 |         | I32x4ExtractLaneOp => Some(ValType::i32())
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         I64x2ExtractLaneOp => Some(ValType::i64())
     |         F32x4ExtractLaneOp => Some(ValType::f32())
     |         F64x2ExtractLaneOp => Some(ValType::f64())
     |       }
 721 |     TI31GetS(_) | TI31GetU(_) => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefI31(_) =>
 723 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         ValType::ref_type(
     |           RefType::new(false, HeapType::abs(AbsHeapType::i31())),
     |         ),
     |       )
 728 |     TAnyConvertExtern(_) => Some(ValType::anyref())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TExternConvertAny(_) => Some(ValType::externref())
     |     TSelect(types, _, if_true, if_false) => {
     |       let from_decl = match types {
     |         Some(vts) if vts.length() == 1 => Some(vts[0])
     |         _ => None
     |       }
     |       let from_branches = match
 736 |         (
     |         ^ 	<-- UNCOVERED
     |           lcs_infer_tinstr_type(if_true, env),
     |           lcs_infer_tinstr_type(if_false, env),
     |         ) {
 740 |         (Some(t), Some(f)) if t == f => Some(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
 743 |       match (from_branches, from_decl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(t), _) => Some(t)
     |         (_, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
     |     TCall(target, _) =>
     |       match env.get_functype_by_funcidx(target) {
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 755 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
     |     TBlock(bt, body) | TLoop(bt, body) | TTryTable(bt, _, body) =>
 760 |       match (infer_texpr_type(body, env), single_result_of_blocktype(bt, env)) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(t), _) => Some(t)
     |         (_, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     TIf(bt, _, then_, else_) => {
     |       let from_bt = single_result_of_blocktype(bt, env)
     |       let from_branches = match else_ {
     |         Some(else_expr) =>
 769 |           match
     |           ^^^^^ 	<-- UNCOVERED
     |             (infer_texpr_type(then_, env), infer_texpr_type(else_expr, env)) {
     |             (Some(t), Some(e)) if t == e => Some(t)
     |             _ => None
     |           }
     |         None => None
     |       }
     |       match (from_branches, from_bt) {
 777 |         (Some(t), _) => Some(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (_, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
     |     _ => None
     |   }
     | }
     …

     | fn lcs_is_relevant(instr : TInstr, env : Env, shrink_level : Int) -> Bool {
     |   if lcs_is_constant_instr(instr) {
     |     return false
     |   }
     |   match instr {
     |     TLocalGet(_) | TLocalSet(_, _) => return false
     |     _ => ()
     |   }
     |   let vt = match lcs_infer_tinstr_type(instr, env) {
     |     Some(vt) => vt
     |     None => return false
     |   }
     |   if !lcs_can_handle_as_local(vt) {
 800 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let size = lcs_measure(instr)
     |   if shrink_level > 0 {
     |     return size >= 3
     |   }
     |   lcs_cost(instr) > 0 && size >= 2
     | }
     …

     | fn lcs_shallow_hash(instr : TInstr) -> UInt64 {
     |   let tag : UInt64 = match instr {
     |     TI32Const(_) => 1UL
 813 |     TI64Const(_) => 2UL
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => 3UL
     |     TF64Const(_) => 4UL
     |     TRefNull(_) => 5UL
     |     TRefFunc(_) => 6UL
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => 7UL
     |     TUnreachable => 8UL
     |     TNop => 9UL
     |     TLocalGet(_) => 10UL
 822 |     TGlobalGet(_) => 11UL
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemorySize(_) => 12UL
     |     TTableSize(_) => 13UL
     |     TUnary(_, _) => 14UL
     |     TDrop(_) => 15UL
 827 |     TLocalSet(_, _) => 16UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalTee(_, _) => 17UL
 829 |     TGlobalSet(_, _) => 18UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefIsNull(_) => 19UL
     |     TRefAsNonNull(_) => 20UL
     |     TI31GetS(_) => 21UL
     |     TI31GetU(_) => 22UL
     |     TRefI31(_) => 23UL
     |     TArrayLen(_) => 24UL
     |     TAnyConvertExtern(_) => 25UL
     |     TExternConvertAny(_) => 26UL
     |     TThrowRef(_) => 27UL
     |     TBinary(_, _, _) => 28UL
 840 |     TRefEq(_, _) => 29UL
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStore(_, _, _, _) => 30UL
     |     TLoad(_, _, _) => 31UL
 843 |     TMemoryGrow(_, _) => 32UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryAtomicNotify(_, _, _) => 33UL
     |     TMemoryAtomicWait32(_, _, _, _) => 34UL
     |     TMemoryAtomicWait64(_, _, _, _) => 35UL
     |     TAtomicFence => 36UL
     |     TAtomicRmw(_, _, _, _) => 37UL
     |     TAtomicCmpxchg(_, _, _, _, _) => 38UL
     |     TMemoryFill(_, _, _, _) => 39UL
     |     TMemoryCopy(_, _, _, _, _) => 40UL
     |     TMemoryInit(_, _, _, _, _) => 41UL
     |     TDataDrop(_) => 42UL
     |     TTableGet(_, _) => 43UL
     |     TTableSet(_, _, _) => 44UL
     |     TTableGrow(_, _, _) => 45UL
     |     TTableFill(_, _, _, _) => 46UL
     |     TTableCopy(_, _, _, _, _) => 47UL
     |     TTableInit(_, _, _, _, _) => 48UL
     |     TElemDrop(_) => 49UL
     |     TCall(_, _) => 50UL
     |     TCallIndirect(_, _, _, _) => 51UL
     |     TCallRef(_, _, _) => 52UL
     |     TReturnCall(_, _) => 53UL
     |     TReturnCallIndirect(_, _, _, _) => 54UL
     |     TReturnCallRef(_, _, _) => 55UL
     |     TBlock(_, _) => 56UL
     |     TLoop(_, _) => 57UL
     |     TIf(_, _, _, _) => 58UL
 870 |     TTryTable(_, _, _) => 59UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TThrow(_, _) => 60UL
     |     TBr(_, _) => 61UL
     |     TBrIf(_, _, _) => 62UL
     |     TBrTable(_, _, _, _) => 63UL
     |     TBrOnNull(_, _, _) => 64UL
     |     TBrOnNonNull(_, _, _) => 65UL
     |     TBrOnCast(_, _, _, _, _, _) => 66UL
     |     TBrOnCastFail(_, _, _, _, _, _) => 67UL
     |     TReturn(_) => 68UL
     |     TSelect(_, _, _, _) => 69UL
     |     TStructNew(_, _) => 70UL
     |     TStructNewDefault(_) => 71UL
     |     TStructGet(_, _, _) => 72UL
     |     TStructGetS(_, _, _) => 73UL
     |     TStructGetU(_, _, _) => 74UL
     |     TStructSet(_, _, _, _) => 75UL
     |     TArrayNew(_, _, _) => 76UL
     |     TArrayNewDefault(_, _) => 77UL
     |     TArrayNewFixed(_, _) => 78UL
     |     TArrayNewData(_, _, _, _) => 79UL
     |     TArrayNewElem(_, _, _, _) => 80UL
     |     TArrayGet(_, _, _) => 81UL
     |     TArrayGetS(_, _, _) => 82UL
     |     TArrayGetU(_, _, _) => 83UL
     |     TArraySet(_, _, _, _) => 84UL
     |     TArrayFill(_, _, _, _, _) => 85UL
     |     TArrayCopy(_, _, _, _, _, _, _) => 86UL
     |     TArrayInitData(_, _, _, _, _, _) => 87UL
     |     TArrayInitElem(_, _, _, _, _, _) => 88UL
     |     TRefTest(_, _, _) => 89UL
     |     TRefCast(_, _, _) => 90UL
     |     TRefGetDesc(_) => 91UL
     |     TRefTestDesc(_, _, _) => 92UL
     |     TRefCastDescEq(_, _, _) => 93UL
     |     TI8x16Splat(_) => 94UL
     |     TI16x8Splat(_) => 95UL
     |     TI32x4Splat(_) => 96UL
     |     TI64x2Splat(_) => 97UL
     |     TF32x4Splat(_) => 98UL
     |     TF64x2Splat(_) => 99UL
     |     TExtractLane(_, _, _) => 100UL
     |     TReplaceLane(_, _, _, _) => 101UL
     |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => 102UL
     |     TI8x16Swizzle(_, _) => 103UL
     |     TI8x16RelaxedSwizzle(_, _) => 104UL
     |     TV128Shift(_, _, _) => 105UL
     |     TV128Ternary(_, _, _, _) => 106UL
     |     TV128LoadLane(_, _, _, _, _) => 107UL
     |     TV128StoreLane(_, _, _, _, _) => 108UL
     |   }
     |   tag * 11400714819323198485UL
     | }
     …

     | fn lcs_scanner_suppress_child(scanner : Scanner, child_id : Int) -> Unit {
     |   if child_id < 0 || child_id >= scanner.request_infos.length() {
 936 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   match scanner.request_infos[child_id] {
     |     None => ()
     |     Some(info) => {
     |       let original_id = info.original
     |       if original_id == child_id {
 943 |         let next_requests = info.requests - 1
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if next_requests <= 0 {
 945 |           scanner.request_infos[child_id] = None
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
 947 |           scanner.request_infos[child_id] = Some({
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             original: original_id,
     |             requests: next_requests,
     |           })
     |         }
     |       } else {
     |         scanner.request_infos[child_id] = None
     |         if original_id >= 0 && original_id < scanner.request_infos.length() {
     |           match scanner.request_infos[original_id] {
     |             Some(orig_info) => {
     |               let next_requests = orig_info.requests - 1
     |               if next_requests <= 0 {
 959 |                 scanner.request_infos[original_id] = None
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               } else {
     |                 scanner.request_infos[original_id] = Some({
     |                   original: original_id,
     |                   requests: next_requests,
     |                 })
     |               }
     |             }
 967 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn lcs_scan_tinstr(
     |   scanner : Scanner,
     |   instr : TInstr,
     |   active_exprs : Map[UInt64, Array[HashedExpression]],
     | ) -> (Int, Map[UInt64, Array[HashedExpression]]) {
     |   let mut active_exprs = active_exprs
     |   if lcs_is_non_linear_boundary(instr) {
     |     active_exprs = Map::new()
     |   }
     |   match instr {
1044 |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       lcs_scan_texpr(scanner, body)
     |       let (id, _) = lcs_scanner_finalize_node(scanner, instr, [], active_exprs)
     |       (id, Map::new())
     |     }
     |     TIf(_, cond, then_, else_) => {
     |       let (cond_id, _) = lcs_scan_tinstr(scanner, cond, active_exprs)
     |       lcs_scan_texpr(scanner, then_)
     |       match else_ {
1053 |         Some(other) => lcs_scan_texpr(scanner, other)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => ()
     |       }
     |       let (id, _) = lcs_scanner_finalize_node(
     |         scanner,
     |         instr,
     |         [cond_id],
     |         Map::new(),
     |       )
     |       (id, Map::new())
     |     }
     |     _ => {
     |       let child_ids : Array[Int] = []
     |       let mut curr_active = active_exprs
     |       for child in eval_children(instr) {
     |         let (child_id, next_active) = lcs_scan_tinstr(
     |           scanner, child, curr_active,
     |         )
     |         child_ids.push(child_id)
     |         curr_active = next_active
     |       }
     |       lcs_scanner_finalize_node(scanner, instr, child_ids, curr_active)
     |     }
     |   }
     | }
     …

     | fn lcs_checker_invalidate_original(
     |   checker : Checker,
     |   original_id : Int,
     |   active_info : LCSActiveOriginal,
     | ) -> Unit {
     |   match checker.request_infos[original_id] {
     |     Some(info) => {
     |       let next_requests = info.requests - active_info.requests_left
     |       if next_requests <= 0 {
     |         checker.request_infos[original_id] = None
     |       } else {
1100 |         checker.request_infos[original_id] = Some({
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           original: info.original,
     |           requests: next_requests,
     |         })
     |       }
     |     }
1106 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn lcs_checker_process_node(
     |   checker : Checker,
     |   id : Int,
     |   instr : TInstr,
     |   active_originals : Map[Int, LCSActiveOriginal],
     | ) -> Map[Int, LCSActiveOriginal] {
     |   let active_originals = active_originals
     |   let curr_effects = lcs_collect_shallow_effects(instr)
     |   curr_effects.traps = false
     |   let to_invalidate : Array[Int] = []
     |   for original_id, active_info in active_originals {
     |     if curr_effects.invalidates(active_info.effects) {
     |       to_invalidate.push(original_id)
     |     }
     |   }
     |   for original_id in to_invalidate {
     |     match active_originals.get(original_id) {
     |       Some(active_info) => {
     |         lcs_checker_invalidate_original(checker, original_id, active_info)
     |         active_originals.remove(original_id)
     |       }
1132 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   match checker.request_infos[id] {
     |     Some(info) if info.original == id && info.requests > 0 =>
     |       active_originals[id] = {
     |         requests_left: info.requests,
     |         effects: lcs_collect_effects(instr),
     |       }
     |     _ => ()
     |   }
     |   match checker.request_infos[id] {
     |     Some(info) if info.original != id => {
     |       let original_id = info.original
     |       match active_originals.get(original_id) {
     |         None => checker.request_infos[id] = None
     |         Some(active_info) => {
     |           let next_left = active_info.requests_left - 1
     |           if next_left <= 0 {
     |             active_originals.remove(original_id)
     |           } else {
1153 |             active_originals[original_id] = {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               requests_left: next_left,
     |               effects: active_info.effects,
     |             }
     |           }
     |         }
     |       }
     |     }
     |     _ => ()
     |   }
     |   active_originals
     | }
     …

     | fn lcs_check_tinstr(
     |   checker : Checker,
     |   instr : TInstr,
     |   active_originals : Map[Int, LCSActiveOriginal],
     | ) -> (Int, Map[Int, LCSActiveOriginal]) {
     |   let mut active_originals = active_originals
     |   if lcs_is_non_linear_boundary(instr) {
1174 |     active_originals = Map::new()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match instr {
1177 |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       lcs_check_texpr(checker, body)
     |       let id = checker.next_id
     |       checker.next_id += 1
1181 |       let next_active = lcs_checker_process_node(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         checker, id, instr, active_originals,
     |       )
     |       (
     |         id,
     |         if lcs_is_non_linear_boundary(instr) {
1187 |           Map::new()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1189 |           next_active
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         },
     |       )
     |     }
1193 |     TIf(_, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (_, _) = lcs_check_tinstr(checker, cond, active_originals)
     |       lcs_check_texpr(checker, then_)
     |       match else_ {
     |         Some(other) => lcs_check_texpr(checker, other)
     |         None => ()
     |       }
     |       let id = checker.next_id
     |       checker.next_id += 1
1202 |       ignore(lcs_checker_process_node(checker, id, instr, Map::new()))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       (id, Map::new())
     |     }
     |     _ => {
     |       let mut curr_active = active_originals
     |       for child in eval_children(instr) {
     |         let (_, next_active) = lcs_check_tinstr(checker, child, curr_active)
     |         curr_active = next_active
     |       }
     |       let id = checker.next_id
     |       checker.next_id += 1
     |       let next_active = lcs_checker_process_node(
     |         checker, id, instr, curr_active,
     |       )
     |       (id, next_active)
     |     }
     |   }
     | }
     …

     | fn lcs_check_texpr(checker : Checker, expr : TExpr) -> Unit {
     |   let mut active_originals : Map[Int, LCSActiveOriginal] = Map::new()
     |   for instr in expr.0 {
     |     let (_, next_active) = lcs_check_tinstr(checker, instr, active_originals)
     |     active_originals = next_active
     |   }
     |   if !active_originals.is_empty() {
1229 |     active_originals = Map::new()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ignore(active_originals)
     |   }
     | }
     …

     | fn lcs_rebuild_non_control(instr : TInstr, children : Array[TInstr]) -> TInstr {
     |   match instr {
     |     // Zero-operand instructions.
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TUnreachable
     |     | TNop
     |     | TLocalGet(_)
     |     | TGlobalGet(_)
     |     | TMemorySize(_)
     |     | TAtomicFence
     |     | TTableSize(_)
     |     | TDataDrop(_)
     |     | TElemDrop(_)
     |     | TStructNewDefault(_) => instr
     | 
     |     // Unary operands.
1257 |     TUnary(op, _) => TInstr::unary(op, children[0])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TDrop(_) => TInstr::drop(children[0])
1259 |     TLocalSet(idx, _) => TInstr::local_set(idx, children[0])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalTee(idx, _) => TInstr::local_tee(idx, children[0])
     |     TGlobalSet(idx, _) => TInstr::global_set(idx, children[0])
     |     TRefIsNull(_) => TInstr::ref_is_null(children[0])
     |     TRefAsNonNull(_) => TInstr::ref_as_non_null(children[0])
     |     TI31GetS(_) => TInstr::i31_get_s(children[0])
     |     TI31GetU(_) => TInstr::i31_get_u(children[0])
     |     TRefI31(_) => TInstr::ref_i31(children[0])
     |     TArrayLen(_) => TInstr::array_len(children[0])
     |     TAnyConvertExtern(_) => TInstr::any_convert_extern(children[0])
     |     TExternConvertAny(_) => TInstr::extern_convert_any(children[0])
     |     TThrowRef(_) => TInstr::throw_ref(children[0])
     |     TMemoryGrow(idx, _) => TInstr::memory_grow(idx, children[0])
     |     TTableGet(idx, _) => TInstr::table_get(idx, children[0])
     |     TLoad(op, memarg, _) => TInstr::load(op, memarg, children[0])
     |     TArrayNewDefault(type_idx, _) =>
1275 |       TInstr::array_new_default(type_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(type_idx, field_idx, _) =>
1277 |       TInstr::struct_get(type_idx, field_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGetS(type_idx, field_idx, _) =>
1279 |       TInstr::struct_get_s(type_idx, field_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGetU(type_idx, field_idx, _) =>
1281 |       TInstr::struct_get_u(type_idx, field_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TI8x16Splat(_) => TInstr::i8x16_splat(children[0])
     |     TI16x8Splat(_) => TInstr::i16x8_splat(children[0])
     |     TI32x4Splat(_) => TInstr::i32x4_splat(children[0])
     |     TI64x2Splat(_) => TInstr::i64x2_splat(children[0])
     |     TF32x4Splat(_) => TInstr::f32x4_splat(children[0])
     |     TF64x2Splat(_) => TInstr::f64x2_splat(children[0])
     |     TExtractLane(op, lane, _) => TInstr::extract_lane(op, lane, children[0])
     |     TRefTest(nullable, ht, _) => TInstr::ref_test(nullable, ht, children[0])
     |     TRefCast(nullable, ht, _) => TInstr::ref_cast(nullable, ht, children[0])
     |     TRefGetDesc(_) => TInstr::ref_get_desc(children[0])
     |     TRefTestDesc(nullable, ht, _) =>
1293 |       TInstr::ref_test_desc(nullable, ht, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefCastDescEq(nullable, ht, _) =>
1295 |       TInstr::ref_cast_desc_eq(nullable, ht, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Two operands.
     |     TBinary(op, _, _) => TInstr::binary(op, children[0], children[1])
1299 |     TRefEq(_, _) => TInstr::ref_eq(children[0], children[1])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStore(op, memarg, _, _) =>
1301 |       TInstr::store(op, memarg, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryAtomicNotify(memarg, _, _) =>
1303 |       TInstr::memory_atomic_notify(memarg, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TAtomicRmw(op, memarg, _, _) =>
1305 |       TInstr::atomic_rmw(op, memarg, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableSet(table_idx, _, _) =>
1307 |       TInstr::table_set(table_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableGrow(table_idx, _, _) =>
1309 |       TInstr::table_grow(table_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructSet(type_idx, field_idx, _, _) =>
1311 |       TInstr::struct_set(type_idx, field_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNew(type_idx, _, _) =>
1313 |       TInstr::array_new(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNewData(type_idx, data_idx, _, _) =>
1315 |       TInstr::array_new_data(type_idx, data_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNewElem(type_idx, elem_idx, _, _) =>
1317 |       TInstr::array_new_elem(type_idx, elem_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayGet(type_idx, _, _) =>
1319 |       TInstr::array_get(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayGetS(type_idx, _, _) =>
1321 |       TInstr::array_get_s(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayGetU(type_idx, _, _) =>
1323 |       TInstr::array_get_u(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TReplaceLane(op, lane, _, _) =>
1325 |       TInstr::replace_lane(op, lane, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TI8x16Swizzle(_, _) => TInstr::i8x16_swizzle(children[0], children[1])
     |     TI8x16RelaxedSwizzle(_, _) =>
1328 |       TInstr::i8x16_relaxed_swizzle(children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Shift(op, _, _) => TInstr::v128_shift(op, children[0], children[1])
     |     TV128LoadLane(op, memarg, lane, _, _) =>
1331 |       TInstr::v128_load_lane(op, memarg, lane, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128StoreLane(op, memarg, lane, _, _) =>
1333 |       TInstr::v128_store_lane(op, memarg, lane, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Three operands.
     |     TMemoryFill(mem_idx, _, _, _) =>
1337 |       TInstr::memory_fill(mem_idx, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryCopy(dst, src, _, _, _) =>
1339 |       TInstr::memory_copy(dst, src, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryInit(data_idx, mem_idx, _, _, _) =>
1341 |       TInstr::memory_init(
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         data_idx,
     |         mem_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TMemoryAtomicWait32(memarg, _, _, _) =>
1349 |       TInstr::memory_atomic_wait32(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         memarg,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TMemoryAtomicWait64(memarg, _, _, _) =>
1356 |       TInstr::memory_atomic_wait64(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         memarg,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TAtomicCmpxchg(op, memarg, _, _, _) =>
1363 |       TInstr::atomic_cmpxchg(op, memarg, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableFill(table_idx, _, _, _) =>
1365 |       TInstr::table_fill(table_idx, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableCopy(dst, src, _, _, _) =>
1367 |       TInstr::table_copy(dst, src, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableInit(elem_idx, table_idx, _, _, _) =>
1369 |       TInstr::table_init(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         elem_idx,
     |         table_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TSelect(types, _, _, _) =>
1377 |       TInstr::select(types, children[2], children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Ternary(op, _, _, _) =>
1379 |       TInstr::v128_ternary(op, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Variable-length operands.
1382 |     TCall(func_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
1384 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
1387 |       TInstr::call(func_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1389 |     TReturnCall(func_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
1391 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
1394 |       TInstr::return_call(func_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1396 |     TThrow(tag_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
1398 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
1401 |       TInstr::throw_(tag_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1403 |     TBr(label_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
1405 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
1408 |       TInstr::br(label_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TReturn(args) => {
     |       let rebuilt = []
     |       for i = 0; i < args.length(); i = i + 1 {
     |         rebuilt.push(children[i])
     |       }
     |       TInstr::return_(rebuilt)
     |     }
1417 |     TStructNew(type_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
1419 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
1422 |       TInstr::struct_new(type_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1424 |     TArrayNewFixed(type_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
1426 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
1429 |       TInstr::array_new_fixed(type_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1431 |     TCallIndirect(type_idx, table_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
1433 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
1436 |       TInstr::call_indirect(
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         table_idx,
     |         rebuilt_args,
1440 |         children[args.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
1443 |     TReturnCallIndirect(type_idx, table_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
1445 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
1448 |       TInstr::return_call_indirect(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         table_idx,
     |         rebuilt_args,
1452 |         children[args.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
1455 |     TCallRef(type_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
1457 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
1460 |       TInstr::call_ref(type_idx, rebuilt_args, children[args.length()])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1462 |     TReturnCallRef(type_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
1464 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
1467 |       TInstr::return_call_ref(type_idx, rebuilt_args, children[args.length()])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1469 |     TBrIf(label_idx, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
1471 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
1474 |       TInstr::br_if(label_idx, children[values.length()], rebuilt_values)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1476 |     TBrTable(labels, default, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
1478 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
1481 |       TInstr::br_table(
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         labels,
     |         default,
1484 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
1488 |     TBrOnNull(label_idx, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
1490 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
1493 |       TInstr::br_on_null(label_idx, children[values.length()], rebuilt_values)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1495 |     TBrOnNonNull(label_idx, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
1497 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
1500 |       TInstr::br_on_non_null(
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         label_idx,
1502 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
1506 |     TBrOnCast(label_idx, castop, ht1, ht2, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
1508 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
1511 |       TInstr::br_on_cast(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         label_idx,
     |         castop.0,
     |         ht1,
     |         castop.1,
     |         ht2,
1517 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
1521 |     TBrOnCastFail(label_idx, castop, ht1, ht2, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
1523 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
1526 |       TInstr::br_on_cast_fail(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         label_idx,
     |         castop.0,
     |         ht1,
     |         castop.1,
     |         ht2,
1532 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
     |     TArraySet(type_idx, _, _, _) =>
1537 |       TInstr::array_set(type_idx, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayFill(type_idx, _, _, _, _) =>
1539 |       TInstr::array_fill(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |       )
     |     TArrayCopy(dst_type, src_type, _, _, _, _, _) =>
1547 |       TInstr::array_copy(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         dst_type,
     |         src_type,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |         children[4],
     |       )
     |     TArrayInitData(type_idx, data_idx, _, _, _, _) =>
1557 |       TInstr::array_init_data(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         data_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |       )
     |     TArrayInitElem(type_idx, elem_idx, _, _, _, _) =>
1566 |       TInstr::array_init_elem(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         elem_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |       )
     |     TI8x16Shuffle(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15,
     |       _,
     |       _
     |     ) =>
1594 |       TInstr::i8x16_shuffle(
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         l0,
     |         l1,
     |         l2,
     |         l3,
     |         l4,
     |         l5,
     |         l6,
     |         l7,
     |         l8,
     |         l9,
     |         l10,
     |         l11,
     |         l12,
     |         l13,
     |         l14,
     |         l15,
     |         children[0],
     |         children[1],
     |       )
     | 
     |     // Control-flow structures are rebuilt in dedicated handlers.
1616 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => instr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn lcs_applier_finalize_node(
     |   applier : Applier,
     |   rewritten : TInstr,
     | ) -> (TInstr, Int) {
     |   let id = applier.next_id
     |   applier.next_id += 1
     |   let mut out = rewritten
     |   if id < applier.request_infos.length() {
     |     match applier.request_infos[id] {
     |       Some(info) if info.original == id && info.requests > 0 =>
     |         match lcs_infer_tinstr_type(applier.node_instrs[id], applier.env) {
     |           Some(vt) => {
     |             let local_idx = LocalIdx::new(
     |               applier.locals.length().reinterpret_as_uint(),
     |             )
     |             applier.locals.push(vt)
     |             applier.original_to_local[id] = local_idx
     |             out = TInstr::local_tee(local_idx, out)
     |             applier.changed = true
     |           }
1641 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       Some(info) if info.original != id => {
     |         let original_id = info.original
     |         match applier.request_infos.get(original_id) {
     |           Some(Some(original_info)) if original_info.requests > 0 =>
     |             match applier.original_to_local.get(original_id) {
     |               Some(local_idx) => {
     |                 out = TInstr::local_get(local_idx)
     |                 applier.changed = true
     |                 let next_requests = original_info.requests - 1
     |                 if next_requests <= 0 {
     |                   applier.request_infos[original_id] = None
     |                   applier.original_to_local.remove(original_id)
     |                 } else {
1656 |                   applier.request_infos[original_id] = Some({
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     original: original_info.original,
     |                     requests: next_requests,
     |                   })
     |                 }
     |               }
1662 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
1664 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => ()
     |     }
     |   }
     |   (out, id)
     | }
     …

     | fn lcs_apply_tinstr(applier : Applier, instr : TInstr) -> (TInstr, Int) {
     |   if lcs_is_non_linear_boundary(instr) {
1676 |     applier.original_to_local = Map::new()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (rewritten, id) = match instr {
1679 |     TBlock(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let new_body = lcs_apply_texpr(applier, body)
     |       lcs_applier_finalize_node(applier, TInstr::block(bt, new_body))
     |     }
1683 |     TLoop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let new_body = lcs_apply_texpr(applier, body)
     |       lcs_applier_finalize_node(applier, TInstr::loop_(bt, new_body))
     |     }
1687 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let new_body = lcs_apply_texpr(applier, body)
     |       lcs_applier_finalize_node(
     |         applier,
1691 |         TInstr::try_table(bt, catches, new_body),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
1694 |     TIf(bt, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (new_cond, _) = lcs_apply_tinstr(applier, cond)
     |       let new_then = lcs_apply_texpr(applier, then_)
     |       let new_else = match else_ {
     |         Some(other) => Some(lcs_apply_texpr(applier, other))
     |         None => None
     |       }
1701 |       lcs_applier_finalize_node(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         applier,
1703 |         TInstr::if_(bt, new_cond, new_then, new_else),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
     |     _ => {
     |       let rewritten_children : Array[TInstr] = []
     |       for child in eval_children(instr) {
     |         let (new_child, _) = lcs_apply_tinstr(applier, child)
     |         rewritten_children.push(new_child)
     |       }
     |       let rebuilt = lcs_rebuild_non_control(instr, rewritten_children)
     |       lcs_applier_finalize_node(applier, rebuilt)
     |     }
     |   }
     |   if lcs_is_non_linear_boundary(instr) {
1717 |     applier.original_to_local = Map::new()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   (rewritten, id)
     | }
     …

     | fn local_cse_ir_pass(
     |   mod : Module,
     |   options : OptimizeOptions,
     | ) -> ModuleTransformer[IRContext] {
     |   let base_env = Env::new().with_module(mod)
     |   ModuleTransformer::new().on_func_evt(fn(_, ctx, func) {
     |     match func {
     |       TFunc(locals, body) => {
     |         let env = base_env.with_locals(locals)
     |         let (new_locals, new_body, changed) = run_local_cse_on_func(
     |           env,
     |           locals,
     |           body,
     |           options.shrink_level,
     |         )
     |         if changed {
     |           change(ctx, Func::t_func(new_locals, new_body))
     |         } else {
     |           unchanged()
     |         }
     |       }
1798 |       _ => unchanged()
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

     | fn run_local_cse(
     |   mod : Module,
     |   options? : OptimizeOptions = OptimizeOptions::new(),
     | ) -> Module {
     |   let pass = local_cse_ir_pass(mod, options)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
1811 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

84 uncovered line(s) in src/passes/local_subtyping.mbt:

    | fn ls_count_imported_funcs(mod : Module) -> UInt {
    |   let mut n : UInt = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 17 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match import_ {
    |           Import(_, _, FuncExternType(_)) => n += 1
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   n
    | }
    …

    | fn ls_collect_func_type_idx_by_func(mod : Module) -> Map[FuncIdx, TypeIdx] {
    |   let out : Map[FuncIdx, TypeIdx] = Map::new()
    |   let mut next_idx : UInt = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 34 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match import_ {
    |           Import(_, _, FuncExternType(type_idx)) => {
    |             out[FuncIdx::new(next_idx)] = type_idx
    |             next_idx += 1
    |           }
 40 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for type_idx in type_idxs {
    |         out[FuncIdx::new(next_idx)] = type_idx
    |         next_idx += 1
    |       }
 51 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   out
    | }
    …

    | fn ls_is_none_ref_type(vt : ValType) -> Bool {
    |   match vt {
    |     RefTypeValType(rt) =>
    |       match rt.get_heap_type() {
 85 |         AbsHeapTypeHeapType(NoneAbsHeapType) => true
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ => false
    |       }
 88 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ls_common_ref_heap_supertype(
    |   a : HeapType,
    |   b : HeapType,
    |   env : Env,
    | ) -> HeapType? {
 98 |   fn is_func_heap(ht : HeapType) -> Bool {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match ht {
    |       AbsHeapTypeHeapType(FuncAbsHeapType) => true
    |       HeapType(tidx) =>
102 |         match env.resolve_comptype(tidx) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(FuncCompType(_, _)) => true
    |           _ => false
    |         }
106 |       _ => false
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   if Match::matches(a, b, env) {
111 |     return Some(b)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if Match::matches(b, a, env) {
114 |     return Some(a)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let candidates = [
117 |     AbsHeapType::i31(),
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     AbsHeapType::struct_(),
    |     AbsHeapType::array(),
    |     AbsHeapType::eq(),
    |     AbsHeapType::func(),
    |     AbsHeapType::extern_(),
    |     AbsHeapType::exn(),
    |     AbsHeapType::any(),
    |   ]
    |   for abs in candidates {
127 |     let super_ht = HeapType::abs(abs)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     if Match::matches(a, super_ht, env) && Match::matches(b, super_ht, env) {
129 |       return Some(super_ht)
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   if is_func_heap(a) && is_func_heap(b) {
133 |     return Some(HeapType::abs(AbsHeapType::func()))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   None
    | }
    …

    | fn ls_common_ref_type_supertype(
    |   a : RefType,
    |   b : RefType,
    |   env : Env,
    | ) -> RefType? {
144 |   if Match::matches(a, b, env) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return Some(b)
    |   }
    |   if Match::matches(b, a, env) {
148 |     return Some(a)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match
151 |     ls_common_ref_heap_supertype(a.get_heap_type(), b.get_heap_type(), env) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ht) => Some(RefType::new(a.is_nullable() || b.is_nullable(), ht))
    |     None => None
    |   }
    | }
    …

    | fn ls_common_val_supertype(a : ValType, b : ValType, env : Env) -> ValType? {
    |   if Match::matches(a, b, env) {
160 |     return Some(b)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if Match::matches(b, a, env) {
    |     return Some(a)
    |   }
165 |   match (a, b) {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (RefTypeValType(r0), RefTypeValType(r1)) =>
167 |       match ls_common_ref_type_supertype(r0, r1, env) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(rt) => Some(ValType::ref_type(rt))
    |         None => None
    |       }
171 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ls_lub_for_refining(
    |   a : ValType,
    |   b : ValType,
    |   old_type : ValType,
    |   env : Env,
    | ) -> ValType {
    |   match ls_common_val_supertype(a, b, env) {
    |     Some(candidate) =>
    |       if Match::matches(candidate, old_type, env) {
    |         candidate
    |       } else {
187 |         old_type
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
189 |     None => old_type
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ls_infer_tinstr_type(
    |   instr : TInstr,
    |   env : Env,
    |   func_type_idx_by_func : Map[FuncIdx, TypeIdx],
    | ) -> ValType? {
    |   fn single_result_of_blocktype(bt : BlockType) -> ValType? {
200 |     match env.expand_blocktype(bt) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Ok((_, [vt])) => Some(vt)
    |       _ => None
    |     }
    |   }
    | 
    |   fn infer_texpr_type(texpr : TExpr) -> ValType? {
207 |     let TExpr(instrs) = texpr
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     if instrs.is_empty() {
209 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     } else {
211 |       ls_infer_tinstr_type(
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         instrs[instrs.length() - 1],
    |         env,
    |         func_type_idx_by_func,
    |       )
    |     }
    |   }
    | 
    |   match instr {
220 |     TI32Const(_) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TI64Const(_) => Some(ValType::i64())
    |     TF32Const(_) => Some(ValType::f32())
    |     TF64Const(_) => Some(ValType::f64())
    |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
225 |       Some(ValType::v128())
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
227 |     TRefFunc(_) => Some(ValType::funcref())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TLocalGet(idx) => env.get_local_type(idx)
    |     TGlobalGet(idx) =>
230 |       match env.get_global_type(idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(GlobalType(vt, _)) => Some(vt)
    |         None => None
    |       }
    |     TLocalTee(_, value) =>
235 |       ls_infer_tinstr_type(value, env, func_type_idx_by_func)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TRefAsNonNull(value) =>
    |       match ls_infer_tinstr_type(value, env, func_type_idx_by_func) {
    |         Some(RefTypeValType(rt)) =>
    |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
240 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TRefCast(nullable, ht, _) =>
243 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TStructNew(type_idx, _)
    |     | TStructNewDefault(type_idx)
    |     | TArrayNew(type_idx, _, _)
    |     | TArrayNewDefault(type_idx, _)
    |     | TArrayNewFixed(type_idx, _)
    |     | TArrayNewData(type_idx, _, _, _)
    |     | TArrayNewElem(type_idx, _, _, _) =>
251 |       Some(ValType::ref_type(RefType::new(false, HeapType::new(type_idx))))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TStructGet(type_idx, field_idx, _)
    |     | TStructGetS(type_idx, field_idx, _)
    |     | TStructGetU(type_idx, field_idx, _) =>
255 |       match env.resolve_struct_fields(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(fields) =>
257 |           match field_idx {
    |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             U32(raw_idx) =>
259 |               match fields.get(raw_idx.reinterpret_as_int()) {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Some(field_ty) => Some(field_ty.unpack())
    |                 None => None
    |               }
    |           }
264 |         Err(_) => None
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TArrayGet(type_idx, _, _)
    |     | TArrayGetS(type_idx, _, _)
    |     | TArrayGetU(type_idx, _, _) =>
269 |       match env.resolve_array_field(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(field_ty) => Some(field_ty.unpack())
    |         Err(_) => None
    |       }
273 |     TSelect(types, _, if_true, if_false) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let from_decl = match types {
    |         Some(vts) if vts.length() == 1 => Some(vts[0])
    |         _ => None
    |       }
    |       let from_branches = match
279 |         (
    |         ^ 	<-- UNCOVERED
    |           ls_infer_tinstr_type(if_true, env, func_type_idx_by_func),
    |           ls_infer_tinstr_type(if_false, env, func_type_idx_by_func),
    |         ) {
283 |         (Some(t), Some(f)) => ls_common_val_supertype(t, f, env)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ => None
    |       }
286 |       match (from_branches, from_decl) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (Some(t), Some(vt)) =>
288 |           if Match::matches(t, vt, env) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(t)
    |           } else {
291 |             Some(vt)
    |             ^^^^^^^^ 	<-- UNCOVERED
    |           }
293 |         (Some(t), None) => Some(t)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (None, Some(vt)) => Some(vt)
    |         _ => None
    |       }
    |     }
    |     TCall(target, _) =>
299 |       match env.get_functype_by_funcidx(target) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(FuncType(_, [r])) => Some(r)
    |         _ => None
    |       }
    |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
304 |       match env.resolve_functype(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(FuncType(_, [r])) => Some(r)
    |         _ => None
    |       }
308 |     TBlock(bt, body) | TLoop(bt, body) | TTryTable(bt, _, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let from_body = infer_texpr_type(body)
    |       let from_bt = single_result_of_blocktype(bt)
    |       match (from_body, from_bt) {
    |         (Some(t), Some(vt)) =>
313 |           if Match::matches(t, vt, env) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(t)
    |           } else {
316 |             Some(vt)
    |             ^^^^^^^^ 	<-- UNCOVERED
    |           }
318 |         (Some(t), None) => Some(t)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (None, Some(vt)) => Some(vt)
    |         _ => None
    |       }
    |     }
323 |     TIf(bt, _, then_, else_) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let from_bt = single_result_of_blocktype(bt)
    |       let from_branches = match else_ {
    |         Some(else_expr) =>
327 |           match (infer_texpr_type(then_), infer_texpr_type(else_expr)) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             (Some(t), Some(e)) => ls_common_val_supertype(t, e, env)
    |             _ => None
    |           }
331 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
333 |       match (from_branches, from_bt) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (Some(t), Some(vt)) =>
335 |           if Match::matches(t, vt, env) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(t)
    |           } else {
338 |             Some(vt)
    |             ^^^^^^^^ 	<-- UNCOVERED
    |           }
340 |         (Some(t), None) => Some(t)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         (None, Some(vt)) => Some(vt)
    |         _ => None
    |       }
    |     }
345 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ls_eval_children(instr : TInstr) -> Array[TInstr] {
    |   match instr {
    |     TI32Const(_)
    |     | TI64Const(_)
    |     | TF32Const(_)
    |     | TF64Const(_)
    |     | TRefNull(_)
    |     | TRefFunc(_)
    |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
    |     | TUnreachable
    |     | TNop
    |     | TLocalGet(_)
    |     | TGlobalGet(_)
    |     | TMemorySize(_)
    |     | TAtomicFence
    |     | TTableSize(_)
    |     | TDataDrop(_)
    |     | TElemDrop(_)
    |     | TStructNewDefault(_) => []
    |     TUnary(_, child)
    |     | TDrop(child)
    |     | TLocalSet(_, child)
    |     | TLocalTee(_, child)
    |     | TGlobalSet(_, child)
    |     | TRefIsNull(child)
    |     | TRefAsNonNull(child)
    |     | TI31GetS(child)
    |     | TI31GetU(child)
    |     | TRefI31(child)
    |     | TArrayLen(child)
    |     | TAnyConvertExtern(child)
    |     | TExternConvertAny(child)
    |     | TThrowRef(child)
    |     | TMemoryGrow(_, child)
    |     | TTableGet(_, child)
    |     | TLoad(_, _, child)
    |     | TArrayNewDefault(_, child)
    |     | TStructGet(_, _, child)
    |     | TStructGetS(_, _, child)
    |     | TStructGetU(_, _, child)
    |     | TI8x16Splat(child)
    |     | TI16x8Splat(child)
    |     | TI32x4Splat(child)
    |     | TI64x2Splat(child)
    |     | TF32x4Splat(child)
    |     | TF64x2Splat(child)
    |     | TExtractLane(_, _, child)
    |     | TRefTest(_, _, child)
    |     | TRefCast(_, _, child)
    |     | TRefGetDesc(child)
    |     | TRefTestDesc(_, _, child)
    |     | TRefCastDescEq(_, _, child) => [child]
    |     TBinary(_, left, right)
    |     | TRefEq(left, right)
    |     | TStore(_, _, left, right)
    |     | TMemoryAtomicNotify(_, left, right)
    |     | TAtomicRmw(_, _, left, right)
    |     | TTableSet(_, left, right)
    |     | TTableGrow(_, left, right)
    |     | TStructSet(_, _, left, right)
    |     | TArrayNew(_, left, right)
    |     | TArrayNewData(_, _, left, right)
    |     | TArrayNewElem(_, _, left, right)
    |     | TArrayGet(_, left, right)
    |     | TArrayGetS(_, left, right)
    |     | TArrayGetU(_, left, right)
    |     | TReplaceLane(_, _, left, right)
    |     | TI8x16Swizzle(left, right)
    |     | TI8x16RelaxedSwizzle(left, right)
    |     | TV128Shift(_, left, right)
    |     | TV128LoadLane(_, _, _, left, right)
454 |     | TV128StoreLane(_, _, _, left, right) => [left, right]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TMemoryFill(_, a, b, c)
    |     | TMemoryCopy(_, _, a, b, c)
    |     | TMemoryInit(_, _, a, b, c)
    |     | TMemoryAtomicWait32(_, a, b, c)
    |     | TMemoryAtomicWait64(_, a, b, c)
    |     | TAtomicCmpxchg(_, _, a, b, c)
    |     | TTableFill(_, a, b, c)
    |     | TTableCopy(_, _, a, b, c)
    |     | TTableInit(_, _, a, b, c)
    |     | TSelect(_, c, a, b)
465 |     | TV128Ternary(_, a, b, c) => [a, b, c]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TCall(_, args)
    |     | TReturnCall(_, args)
    |     | TThrow(_, args)
    |     | TBr(_, args)
    |     | TReturn(args)
    |     | TStructNew(_, args)
472 |     | TArrayNewFixed(_, args) => args.copy()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TCallIndirect(_, _, args, index) | TReturnCallIndirect(_, _, args, index) => {
    |       let out = args.copy()
    |       out.push(index)
    |       out
    |     }
478 |     TCallRef(_, args, ref_) | TReturnCallRef(_, args, ref_) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = args.copy()
    |       out.push(ref_)
    |       out
    |     }
483 |     TBrIf(_, cond, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(cond)
    |       out
    |     }
488 |     TBrTable(_, _, index, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(index)
    |       out
    |     }
    |     TBrOnNull(_, ref_, values)
    |     | TBrOnNonNull(_, ref_, values)
    |     | TBrOnCast(_, _, _, _, ref_, values)
496 |     | TBrOnCastFail(_, _, _, _, ref_, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(ref_)
    |       out
    |     }
501 |     TArraySet(_, a, b, c) => [a, b, c]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TArrayFill(_, a, b, c, d) => [a, b, c, d]
    |     TArrayCopy(_, _, a, b, c, d, e) => [a, b, c, d, e]
    |     TArrayInitData(_, _, a, b, c, d) => [a, b, c, d]
    |     TArrayInitElem(_, _, a, b, c, d) => [a, b, c, d]
    |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, left, right) =>
507 |       [left, right]
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => []
    |   }
    | }
    …

    | fn ls_structural_dominance_instr(
    |   instr : TInstr,
    |   definitely_set : Set[Int],
    |   relevant_locals : Set[Int],
    |   cannot_be_non_nullable : Set[Int],
    | ) -> Set[Int] {
    |   match instr {
    |     TLocalGet(idx) => {
    |       let local_idx = ls_local_idx_to_int(idx)
    |       if relevant_locals.contains(local_idx) &&
    |         !definitely_set.contains(local_idx) {
    |         cannot_be_non_nullable.add(local_idx)
    |       }
    |       definitely_set
    |     }
    |     TLocalSet(idx, value) | TLocalTee(idx, value) => {
    |       let after_value = ls_structural_dominance_instr(
    |         value, definitely_set, relevant_locals, cannot_be_non_nullable,
    |       )
    |       let local_idx = ls_local_idx_to_int(idx)
    |       let out = after_value.copy()
    |       if relevant_locals.contains(local_idx) {
    |         out.add(local_idx)
    |       }
    |       out
    |     }
    |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
540 |       ls_structural_dominance_texpr(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         body, definitely_set, relevant_locals, cannot_be_non_nullable,
    |       )
    |     TIf(_, cond, then_, else_) => {
    |       let after_cond = ls_structural_dominance_instr(
    |         cond, definitely_set, relevant_locals, cannot_be_non_nullable,
    |       )
    |       let after_then = ls_structural_dominance_texpr(
    |         then_, after_cond, relevant_locals, cannot_be_non_nullable,
    |       )
    |       let after_else = match else_ {
    |         Some(other) =>
552 |           ls_structural_dominance_texpr(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             other, after_cond, relevant_locals, cannot_be_non_nullable,
    |           )
    |         None => after_cond
    |       }
    |       let merged : Set[Int] = Set::new()
    |       for local_idx in relevant_locals {
    |         if after_then.contains(local_idx) && after_else.contains(local_idx) {
560 |           merged.add(local_idx)
    |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       merged
    |     }
    |     _ => {
    |       let mut state = definitely_set
    |       for child in ls_eval_children(instr) {
    |         state = ls_structural_dominance_instr(
    |           child, state, relevant_locals, cannot_be_non_nullable,
    |         )
    |       }
    |       state
    |     }
    |   }
    | }
    …

    | fn ls_compute_cannot_be_non_nullable(
    |   scan : LocalSubtypingScan,
    |   graph : LocalGraph,
    |   body : TExpr,
    |   relevant_locals : Set[Int],
    | ) -> Set[Int] {
    |   let cannot : Set[Int] = Set::new()
    |   for local_idx in relevant_locals {
    |     match scan.gets_for_local.get(local_idx) {
    |       Some(get_ids) =>
    |         for get_id in get_ids {
    |           let sets = graph.get_sets(get_id)
    |           if sets.is_empty() {
607 |             cannot.add(local_idx)
    |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             break
    |           }
    |           let mut hit_init = false
    |           for set_ in sets {
    |             match set_ {
    |               InitValue => {
    |                 hit_init = true
    |                 break
    |               }
    |               _ => ()
    |             }
    |           }
    |           if hit_init {
    |             cannot.add(local_idx)
    |             break
    |           }
    |         }
    |       None => ()
    |     }
    |   }
    |   ignore(
    |     ls_structural_dominance_texpr(body, Set::new(), relevant_locals, cannot),
    |   )
    |   cannot
    | }
    …

    | fn ls_compute_assigned_lub(
    |   local_idx : Int,
    |   old_type : ValType,
    |   scan : LocalSubtypingScan,
    |   env : Env,
    |   func_type_idx_by_func : Map[FuncIdx, TypeIdx],
    | ) -> ValType? {
    |   match scan.sets_for_local.get(local_idx) {
    |     Some(values) if !values.is_empty() => {
    |       let mut candidate : ValType? = None
    |       for value in values {
    |         let observed = match
    |           ls_infer_tinstr_type(value, env, func_type_idx_by_func) {
    |           Some(vt) if Match::matches(vt, old_type, env) => vt
649 |           _ => old_type
    |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         candidate = match candidate {
    |           Some(prev) => Some(ls_lub_for_refining(prev, observed, old_type, env))
    |           None => Some(observed)
    |         }
    |       }
    |       candidate
    |     }
    |     _ => None
    |   }
    | }
    …

    | fn ls_refine_function_locals(
    |   params : Array[ValType],
    |   locals : Array[ValType],
    |   body : TExpr,
    |   base_env : Env,
    |   func_type_idx_by_func : Map[FuncIdx, TypeIdx],
    | ) -> (Array[ValType], Bool) {
    |   let param_count = params.length()
    |   let full_locals = params.copy()
    |   full_locals.append(locals)
    |   let relevant_locals : Set[Int] = Set::new()
    |   for i = param_count; i < full_locals.length(); i = i + 1 {
    |     if full_locals[i].is_ref_type() {
    |       relevant_locals.add(i)
    |     }
    |   }
    |   if relevant_locals.is_empty() {
    |     return (locals, false)
    |   }
    |   let scan = ls_scan_body(body, relevant_locals)
    |   let graph = LocalGraph::new(body.0)
    |   let cannot_be_non_nullable = ls_compute_cannot_be_non_nullable(
    |     scan, graph, body, relevant_locals,
    |   )
    |   let mut changed = false
    |   let mut more = true
    |   while more {
    |     more = false
    |     let env = base_env.with_locals(full_locals)
    |     for i = param_count; i < full_locals.length(); i = i + 1 {
    |       if !relevant_locals.contains(i) {
694 |         continue
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let old_type = full_locals[i]
    |       let mut new_type = match
    |         ls_compute_assigned_lub(i, old_type, scan, env, func_type_idx_by_func) {
    |         Some(vt) => vt
    |         None => continue
    |       }
    |       if ls_is_none_ref_type(new_type) {
703 |         continue
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let may_be_non_nullable = !cannot_be_non_nullable.contains(i)
    |       let mut allowed_non_nullable_case = false
    |       match new_type {
    |         RefTypeValType(rt) =>
    |           if rt.is_non_nullable() {
    |             if may_be_non_nullable {
    |               allowed_non_nullable_case = true
    |             } else {
    |               new_type = ValType::ref_type(rt.make_nullable())
    |             }
    |           }
716 |         _ => ()
    |         ^^^^^^^ 	<-- UNCOVERED
    |       }
    |       if !@lib.has_default(new_type) && !allowed_non_nullable_case {
719 |         continue
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       if !Match::matches(new_type, old_type, env) {
    |         continue
    |       }
    |       if Match::matches(old_type, new_type, env) {
    |         continue
    |       }
    |       full_locals[i] = new_type
    |       changed = true
    |       more = true
    |     }
    |   }
    |   if !changed {
    |     return (locals, false)
    |   }
    |   let new_locals : Array[ValType] = []
    |   for i = param_count; i < full_locals.length(); i = i + 1 {
    |     new_locals.push(full_locals[i])
    |   }
    |   (new_locals, true)
    | }
    …

    | fn local_subtyping(mod : Module) -> Result[Module, String] {
    |   let env = Env::new().with_module(mod)
    |   let func_type_idx_by_func = ls_collect_func_type_idx_by_func(mod)
    |   let imported_funcs = ls_count_imported_funcs(mod)
    |   match mod.code_sec {
    |     Some(CodeSec(funcs)) => {
    |       let out_funcs = funcs.copy()
    |       let mut changed = false
    |       for i = 0; i < funcs.length(); i = i + 1 {
    |         let func_abs_idx = FuncIdx::new(
    |           imported_funcs + i.reinterpret_as_uint(),
    |         )
    |         match funcs[i] {
    |           TFunc(locals, body) => {
    |             let params = match env.get_functype_by_funcidx(func_abs_idx) {
    |               Some(FuncType(ps, _)) => ps
759 |               None => []
    |               ^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |             let (new_locals, local_changed) = ls_refine_function_locals(
    |               params, locals, body, env, func_type_idx_by_func,
    |             )
    |             if local_changed {
    |               out_funcs[i] = Func::t_func(new_locals, body)
    |               changed = true
    |             }
    |           }
769 |           _ => return Err("local_subtyping: expected TFunc")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       if changed {
    |         Ok(mod.with_code_sec(CodeSec::new(out_funcs)))
    |       } else {
    |         Ok(mod)
    |       }
    |     }
778 |     None => Ok(mod)
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn run_local_subtyping(mod : Module) -> Module {
    |   match local_subtyping(mod) {
    |     Ok(out) => out
786 |     Err(_) => mod
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

37 uncovered line(s) in src/passes/loop_invariant_code_motion.mbt:

    | fn LICMEffects::invalidates(self : LICMEffects, other : LICMEffects) -> Bool {
    |   for local_idx in self.locals_written {
    |     if other.locals_read.contains(local_idx) ||
    |       other.locals_written.contains(local_idx) {
    |       return true
    |     }
    |   }
    |   for local_idx in self.locals_read {
 58 |     if other.locals_written.contains(local_idx) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       return true
    |     }
    |   }
    |   if (self.reads_memory && other.writes_memory) ||
    |     (self.writes_memory && other.reads_memory) ||
    |     (self.writes_memory && other.writes_memory) {
    |     return true
    |   }
    |   if (self.reads_globals && other.writes_globals) ||
    |     (self.writes_globals && other.reads_globals) ||
    |     (self.writes_globals && other.writes_globals) {
 70 |     return true
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if self.calls || other.calls {
 73 |     if self.reads_memory ||
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       self.writes_memory ||
    |       other.reads_memory ||
    |       other.writes_memory ||
    |       self.reads_globals ||
    |       self.writes_globals ||
    |       other.reads_globals ||
    |       other.writes_globals {
 81 |       return true
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   if self.transfers_control_flow() || other.transfers_control_flow() {
 85 |     return true
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if (self.traps && other.has_unremovable_side_effects()) ||
    |     (other.traps && self.has_unremovable_side_effects()) {
 89 |     return true
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   false
    | }
    …

    | fn licm_collect_effects(instr : TInstr) -> LICMEffects {
    |   let effects = LICMEffects::new()
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
    |     match curr {
    |       TLocalGet(idx) => effects.locals_read.add(idx)
    |       TLocalSet(idx, _) => effects.locals_written.add(idx)
127 |       TLocalTee(idx, _) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.locals_read.add(idx)
    |         effects.locals_written.add(idx)
    |       }
131 |       TGlobalGet(_) => effects.reads_globals = true
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TGlobalSet(_, _) => effects.writes_globals = true
    |       TLoad(_, _, _) => {
    |         effects.reads_memory = true
    |         effects.traps = true
    |       }
    |       TStore(_, _, _, _) => {
    |         effects.writes_memory = true
    |         effects.traps = true
    |       }
141 |       TMemoryGrow(_, _) => effects.writes_memory = true
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TMemorySize(_) => effects.reads_memory = true
    |       TMemoryCopy(_, _, _, _, _) => {
    |         effects.reads_memory = true
    |         effects.writes_memory = true
    |       }
147 |       TMemoryFill(_, _, _, _) => effects.writes_memory = true
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TMemoryInit(_, _, _, _, _) => {
    |         effects.reads_memory = true
    |         effects.writes_memory = true
    |       }
152 |       TDataDrop(_) => effects.writes_memory = true
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TTableSet(_, _, _) | TTableGrow(_, _, _) | TTableFill(_, _, _, _) =>
154 |         effects.writes_memory = true
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TTableGet(_, _) | TTableSize(_) => effects.reads_memory = true
    |       TTableCopy(_, _, _, _, _) | TTableInit(_, _, _, _, _) | TElemDrop(_) => {
    |         effects.reads_memory = true
    |         effects.writes_memory = true
    |       }
    |       TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
161 |         effects.calls = true
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TReturnCall(_, _)
    |       | TReturnCallIndirect(_, _, _, _)
164 |       | TReturnCallRef(_, _, _) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.calls = true
    |         effects.branches = true
    |       }
    |       TBr(_, _)
    |       | TBrIf(_, _, _)
    |       | TBrTable(_, _, _, _)
    |       | TBrOnNull(_, _, _)
    |       | TBrOnNonNull(_, _, _)
    |       | TBrOnCast(_, _, _, _, _, _)
    |       | TBrOnCastFail(_, _, _, _, _, _)
    |       | TReturn(_) => effects.branches = true
176 |       TThrow(_, _) => {
    |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.throws = true
    |         effects.branches = true
    |       }
    |       TThrowRef(_) => {
    |         effects.throws = true
    |         effects.branches = true
    |       }
    |       TUnreachable => effects.traps = true
185 |       TRefAsNonNull(_) | TRefCast(_, _, _) => effects.traps = true
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       TStructGet(_, _, _) | TStructGetS(_, _, _) | TStructGetU(_, _, _) => {
    |         effects.reads_memory = true
    |         effects.traps = true
    |       }
190 |       TStructSet(_, _, _, _) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.writes_memory = true
    |         effects.traps = true
    |       }
    |       TArrayNew(_, _, _)
    |       | TArrayNewDefault(_, _)
    |       | TArrayNewFixed(_, _)
    |       | TArrayNewData(_, _, _, _)
198 |       | TArrayNewElem(_, _, _, _) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.writes_memory = true
    |         effects.traps = true
    |       }
    |       TArrayGet(_, _, _)
    |       | TArrayGetS(_, _, _)
    |       | TArrayGetU(_, _, _)
205 |       | TArrayLen(_) => {
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.reads_memory = true
    |         effects.traps = true
    |       }
    |       TArraySet(_, _, _, _)
    |       | TArrayFill(_, _, _, _, _)
    |       | TArrayCopy(_, _, _, _, _, _, _)
    |       | TArrayInitData(_, _, _, _, _, _)
213 |       | TArrayInitElem(_, _, _, _, _, _) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         effects.reads_memory = true
    |         effects.writes_memory = true
    |         effects.traps = true
    |       }
    |       TBinary(op, _, _) =>
    |         match op {
    |           I32DivSOp
    |           | I32DivUOp
    |           | I32RemSOp
    |           | I32RemUOp
    |           | I64DivSOp
    |           | I64DivUOp
    |           | I64RemSOp
227 |           | I64RemUOp => effects.traps = true
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           _ => ()
    |         }
    |       TUnary(op, _) =>
231 |         match op {
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |           I32TruncF32SOp
    |           | I32TruncF32UOp
    |           | I32TruncF64SOp
    |           | I32TruncF64UOp
    |           | I64TruncF32SOp
    |           | I64TruncF32UOp
    |           | I64TruncF64SOp
239 |           | I64TruncF64UOp => effects.traps = true
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           _ => ()
    |         }
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), curr)
    |   })
    |   ignore(walker.walk_tinstruction((), instr))
    |   effects
    | }
    …

    | fn licm_is_void_block_type(bt : BlockType) -> Bool {
    |   match bt {
    |     VoidBlockType => true
280 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn licm_is_none_typed(instr : TInstr) -> Bool {
    |   match instr {
    |     TNop
    |     | TDrop(_)
    |     | TLocalSet(_, _)
    |     | TGlobalSet(_, _)
    |     | TStore(_, _, _, _)
    |     | TMemoryFill(_, _, _, _)
    |     | TMemoryCopy(_, _, _, _, _)
    |     | TMemoryInit(_, _, _, _, _)
    |     | TDataDrop(_)
    |     | TTableSet(_, _, _)
    |     | TTableFill(_, _, _, _)
    |     | TTableCopy(_, _, _, _, _)
    |     | TTableInit(_, _, _, _, _)
    |     | TElemDrop(_)
    |     | TBr(_, _)
    |     | TBrIf(_, _, _)
    |     | TBrTable(_, _, _, _)
    |     | TBrOnNull(_, _, _)
    |     | TBrOnNonNull(_, _, _)
    |     | TBrOnCast(_, _, _, _, _, _)
    |     | TBrOnCastFail(_, _, _, _, _, _)
    |     | TReturn(_)
    |     | TReturnCall(_, _)
    |     | TReturnCallIndirect(_, _, _, _)
    |     | TReturnCallRef(_, _, _)
    |     | TThrow(_, _)
    |     | TThrowRef(_)
    |     | TUnreachable
    |     | TStructSet(_, _, _, _)
    |     | TArraySet(_, _, _, _)
    |     | TArrayFill(_, _, _, _, _)
    |     | TArrayCopy(_, _, _, _, _, _, _)
    |     | TArrayInitData(_, _, _, _, _, _)
    |     | TArrayInitElem(_, _, _, _, _, _)
    |     | TV128StoreLane(_, _, _, _, _) => true
    |     TBlock(bt, _) | TLoop(bt, _) | TIf(bt, _, _, _) | TTryTable(bt, _, _) =>
    |       licm_is_void_block_type(bt)
324 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn licm_local_set_chain_final_rhs(value : TInstr) -> TInstr {
    |   let mut curr = value
    |   let mut done = false
    |   while !done {
    |     match curr {
    |       TLocalSet(_, next) => curr = next
335 |       TLocalTee(_, next) => curr = next
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => done = true
    |     }
    |   }
    |   curr
    | }
    …

    | fn licm_interesting_to_move(curr : TInstr) -> Bool {
    |   if !licm_is_none_typed(curr) {
345 |     return false
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match curr {
    |     TNop | TBlock(_, _) | TLoop(_, _) => false
    |     TLocalSet(_, value) => {
    |       let final_rhs = licm_local_set_chain_final_rhs(value)
    |       match final_rhs {
    |         TLocalGet(_) => false
    |         _ => !licm_is_const_instr(final_rhs)
    |       }
    |     }
    |     _ => true
    |   }
    | }
    …

    | fn licm_has_get_depending_on_loop_set(
    |   get_ids : Array[Int],
    |   local_graph : LocalGraph,
    |   loop_sets : Set[TInstr],
    | ) -> Bool {
    |   for get_id in get_ids {
    |     let sets = local_graph.get_sets(get_id)
    |     for set_ in sets {
    |       match set_ {
    |         LocalSet::InitValue => ()
389 |         LocalSet::Set(_, root) => if loop_sets.contains(root) { return true }
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    |   false
    | }
    …

    | fn licm_collect_set_info(instr : TInstr) -> LICMSetInfo {
    |   let set_indices : Array[Int] = []
    |   let local_sets : Array[TInstr] = []
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
    |     match curr {
    |       TLocalSet(idx, _) => {
    |         set_indices.push(licm_local_idx_to_int(idx))
    |         local_sets.push(curr)
    |       }
412 |       TLocalTee(idx, _) => set_indices.push(licm_local_idx_to_int(idx))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), curr)
    |   })
    |   ignore(walker.walk_tinstruction((), instr))
    |   { set_indices, local_sets }
    | }
    …

    | fn licm_collect_loop_sets_and_counts(
    |   body : TExpr,
    | ) -> (Set[TInstr], Map[Int, Int]) {
    |   let loop_sets : Set[TInstr] = Set::new()
    |   let num_sets_for_index : Map[Int, Int] = Map::new()
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     match instr {
    |       TLocalSet(idx, _) => {
    |         loop_sets.add(instr)
    |         licm_count_set(num_sets_for_index, idx)
    |       }
433 |       TLocalTee(idx, _) => licm_count_set(num_sets_for_index, idx)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), instr)
    |   })
    |   ignore(walker.walk_texpr((), body))
    |   (loop_sets, num_sets_for_index)
    | }
    …

    | fn licm_visit_loop(
    |   loop_instr : TInstr,
    |   loop_body_start_get_id : Int,
    |   local_graph : LocalGraph,
    | ) -> TInstr {
    |   match loop_instr {
    |     TLoop(loop_type, loop_body) => {
    |       let moved_code : Array[TInstr] = []
    |       let effects_so_far = LICMEffects::new()
    |       let loop_effects = licm_collect_effects(loop_instr)
    |       let (loop_sets, num_sets_for_index) = licm_collect_loop_sets_and_counts(
    |         loop_body,
    |       )
    |       fn scan_entrance(
    |         body : TExpr,
    |         start_get_id : Int,
    |       ) -> (TExpr, Int, Bool, Bool) {
    |         let items = body.0.copy()
    |         let mut changed = false
    |         let mut next_get_id = start_get_id
    |         for i = 0; i < items.length(); i = i + 1 {
    |           match items[i] {
    |             TBlock(bt, child_body) => {
    |               let (next_body, next_get, stop, child_changed) = scan_entrance(
    |                 child_body, next_get_id,
    |               )
    |               next_get_id = next_get
    |               if child_changed {
    |                 changed = true
    |                 items[i] = TInstr::block(bt, next_body)
    |               }
    |               if stop {
475 |                 return (TExpr::new(items), next_get_id, true, changed)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             }
    |             curr => {
    |               let curr_effects = licm_collect_effects(curr)
    |               let (curr_get_ids, next_get) = licm_collect_get_ids(
    |                 curr, next_get_id,
    |               )
    |               next_get_id = next_get
    |               if curr_effects.transfers_control_flow() {
    |                 return (TExpr::new(items), next_get_id, true, changed)
    |               }
    |               if licm_interesting_to_move(curr) {
    |                 let mut unsafe_to_move = curr_effects.writes_global_state() ||
    |                   effects_so_far.invalidates(curr_effects) ||
    |                   (
    |                     curr_effects.reads_mutable_global_state() &&
    |                     loop_effects.writes_global_state()
    |                   ) ||
    |                   curr_effects.throws ||
    |                   loop_effects.throws
    |                 if !unsafe_to_move && curr_effects.locals_read.length() > 0 {
    |                   unsafe_to_move = licm_has_get_depending_on_loop_set(
    |                     curr_get_ids, local_graph, loop_sets,
    |                   )
    |                 }
    |                 if !unsafe_to_move {
    |                   let set_info = licm_collect_set_info(curr)
    |                   for idx in set_info.set_indices {
    |                     num_sets_for_index[idx] = num_sets_for_index
    |                       .get(idx)
    |                       .unwrap_or(0) -
    |                       1
    |                   }
    |                   let mut interferes = false
    |                   for idx in set_info.set_indices {
    |                     if num_sets_for_index.get(idx).unwrap_or(0) > 0 {
    |                       interferes = true
    |                       break
    |                     }
    |                   }
    |                   if interferes {
    |                     for idx in set_info.set_indices {
    |                       num_sets_for_index[idx] = num_sets_for_index
    |                         .get(idx)
    |                         .unwrap_or(0) +
    |                         1
    |                     }
    |                   } else {
    |                     moved_code.push(curr)
    |                     items[i] = TInstr::nop()
    |                     changed = true
    |                     for set_ in set_info.local_sets {
    |                       loop_sets.remove(set_)
    |                     }
    |                     continue
    |                   }
    |                 }
    |               }
    |               effects_so_far.merge(curr_effects)
    |             }
    |           }
    |         }
    |         (TExpr::new(items), next_get_id, false, changed)
    |       }
    | 
    |       let (next_loop_body, _, _, body_changed) = scan_entrance(
    |         loop_body, loop_body_start_get_id,
    |       )
    |       if moved_code.is_empty() {
    |         if body_changed {
546 |           TInstr::loop_(loop_type, next_loop_body)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         } else {
    |           loop_instr
    |         }
    |       } else {
    |         let preheader_items = moved_code.copy()
    |         preheader_items.push(TInstr::loop_(loop_type, next_loop_body))
    |         TInstr::block(loop_type, TExpr::new(preheader_items))
    |       }
    |     }
556 |     _ => loop_instr
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn licm_run_on_body(body : TExpr) -> (TExpr, Bool) {
    |   let mut curr_body = body
    |   let mut changed_any = false
    | 
    |   // Hoisting only moves expressions outward; rounds ensure nested-loop
    |   // opportunities can bubble to outer loops deterministically.
    |   let mut rounds = 0
    |   while rounds < 64 {
    |     let local_graph = LocalGraph::new(curr_body.0)
    |     let loop_entry_get_ids = licm_collect_loop_entry_get_ids(curr_body)
    |     let loop_visit = Ref::new(0)
    |     let licm_pass = ModuleTransformer::new().on_tinstruction_evt(fn(
    |       self,
    |       _,
    |       instr,
    |     ) {
    |       match instr {
    |         TLoop(_, _) => {
    |           let loop_index = loop_visit.val
    |           loop_visit.update(fn(n) { n + 1 })
    |           let walked = match self.walk_tinstruction_default((), instr) {
    |             Ok(Some((_, updated))) => updated
599 |             Ok(None) => instr
    |             ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Err(e) => return Err(e)
    |           }
    |           if loop_index >= loop_entry_get_ids.length() {
    |             if walked == instr {
    |               unchanged()
    |             } else {
606 |               change((), walked)
    |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |           } else {
    |             let rewritten = licm_visit_loop(
    |               walked,
    |               loop_entry_get_ids[loop_index],
    |               local_graph,
    |             )
    |             if rewritten == instr {
    |               unchanged()
    |             } else {
    |               change((), rewritten)
    |             }
    |           }
    |         }
    |         _ => self.walk_tinstruction_default((), instr)
    |       }
    |     })
    |     let next_body = match licm_pass.walk_texpr((), curr_body) {
    |       Ok(Some((_, updated))) => updated
626 |       Ok(None) => curr_body
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(_) => curr_body
    |     }
    |     if next_body == curr_body {
    |       break
    |     }
    |     changed_any = true
    |     curr_body = next_body
    |     rounds += 1
    |   }
    |   (curr_body, changed_any)
    | }
    …

    | fn loop_invariant_code_motion_pass() -> ModuleTransformer[Unit] {
    |   ModuleTransformer::new().on_func_evt(fn(_, _, func) {
    |     match func {
    |       TFunc(locals, body) => {
    |         let (next_body, changed) = licm_run_on_body(body)
    |         if changed {
    |           change((), Func::t_func(locals, next_body))
    |         } else {
    |           unchanged()
    |         }
    |       }
651 |       _ => unchanged()
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

1 uncovered line(s) in src/passes/lower_to_expr.mbt:

   | fn lower_to_expr_pass() -> ModuleTransformer[Unit] {
   |   ModuleTransformer::new().on_func_evt(fn(
   |     _ : ModuleTransformer[Unit],
   |     _ : Unit,
   |     f : Func,
   |   ) -> TransformerResult[Unit, Func] {
   |     match f {
   |       TFunc(l, t) => {
   |         let locals = tlocals_to_locals(l)
   |         let expr = t.to_expr()
   |         change((), Func::new(locals, expr))
   |       }
14 |       Func(_, _) => unchanged()
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     }
   |   })
   | }
   …

128 uncovered line(s) in src/passes/memory_packing.mbt:

     | fn mp_count_imported_funcs(mod : Module) -> UInt {
     |   let mut n : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
 105 |           Import(_, _, FuncExternType(_)) => n += 1
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn mp_count_imported_globals(mod : Module) -> UInt {
     |   let mut n : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 119 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(_)) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn mp_count_imported_memories(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, MemExternType(_)) => n += 1
 138 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn mp_collect_memory_limits(mod : Module) -> Array[Limits] {
     |   let out : Array[Limits] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, MemExternType(MemType(limits))) => out.push(limits)
 154 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.mem_sec {
     |     Some(MemSec(mems)) =>
     |       for mem in mems {
     |         let MemType(limits) = mem
     |         out.push(limits)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn mp_is_memory64(limits : Limits) -> Bool {
     |   match limits {
 173 |     I64Limits(_, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn mp_const_offset_expr(expr : Expr) -> MPConstOffset? {
     |   match expr {
     |     Expr([I32Const(I32(v))]) =>
     |       Some(MPConstOffset::I32(v.reinterpret_as_uint()))
     |     Expr([I64Const(I64(v))]) =>
 196 |       Some(MPConstOffset::I64(v.reinterpret_as_uint64()))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn mp_const_u64(instr : TInstr) -> UInt64? {
     |   match instr {
     |     TI32Const(I32(v)) => Some(v.reinterpret_as_uint().to_uint64())
 205 |     TI64Const(I64(v)) => Some(v.reinterpret_as_uint64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn mp_u64_add_saturating(a : UInt64, b : UInt64) -> UInt64 {
     |   let sum = a + b
     |   if sum < a {
 214 |     MP_U64_MAX
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     sum
     |   }
     | }
     …

     | fn saturating_add_start_offset(
     |   start : Int,
     |   base_offset_const : MPConstOffset,
     | ) -> MPConstOffset {
     |   let add = if start <= 0 {
 226 |     0UL
     |     ^^^ 	<-- UNCOVERED
     |   } else {
     |     start.reinterpret_as_uint().to_uint64()
     |   }
     |   match base_offset_const {
     |     MPConstOffset::I32(base) => {
     |       let sum = mp_u64_add_saturating(base.to_uint64(), add)
     |       if sum > MP_U32_MAX {
 234 |         MPConstOffset::I32(0xFFFFFFFFU)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         MPConstOffset::I32(sum.to_uint())
     |       }
     |     }
     |     MPConstOffset::I64(base) =>
 240 |       MPConstOffset::I64(mp_u64_add_saturating(base, add))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mp_offset_const_to_expr(offset : MPConstOffset) -> Expr {
     |   match offset {
     |     MPConstOffset::I32(v) =>
     |       TExpr::new([TInstr::i32_const(I32(v.reinterpret_as_int()))]).to_expr()
     |     MPConstOffset::I64(v) =>
 250 |       TExpr::new([TInstr::i64_const(I64(v.reinterpret_as_int64()))]).to_expr()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mp_ptr_const_for_limits(limits : Limits, val : UInt64) -> TInstr {
     |   if mp_is_memory64(limits) {
 257 |     TInstr::i64_const(I64(val.reinterpret_as_int64()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     let v = if val > MP_U32_MAX { MP_U32_MAX } else { val }
     |     TInstr::i32_const(I32(v.to_uint().reinterpret_as_int()))
     |   }
     | }
     …

     | fn mp_ptr_add_for_limits(
     |   limits : Limits,
     |   base : TInstr,
     |   delta : UInt64,
     | ) -> TInstr {
     |   if delta == 0UL {
     |     return base
     |   }
     |   if mp_is_memory64(limits) {
 274 |     TInstr::binary(
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       BinaryOp::i64_add(),
     |       base,
 277 |       TInstr::i64_const(I64(delta.reinterpret_as_int64())),
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     )
     |   } else {
     |     let d = if delta > MP_U32_MAX { MP_U32_MAX } else { delta }
     |     TInstr::binary(
     |       BinaryOp::i32_add(),
     |       base,
     |       TInstr::i32_const(I32(d.to_uint().reinterpret_as_int())),
     |     )
     |   }
     | }
     …

     | fn mp_compute_ranges(bytes : Bytes) -> Array[MPRange] {
     |   let ranges : Array[MPRange] = []
     |   let n = bytes.length()
     |   if n == 0 {
 294 |     return ranges
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut start = 0
     |   let mut is_zero = bytes[0] == b'\x00'
     |   for i in 1..<n {
     |     let zero = bytes[i] == b'\x00'
     |     if zero != is_zero {
     |       ranges.push({ start, end: i, is_zero })
     |       start = i
     |       is_zero = zero
     |     }
     |   }
     |   ranges.push({ start, end: n, is_zero })
     |   ranges
     | }
     …

     | fn mp_merge_left_edge_zero(
     |   ranges : Array[MPRange],
     |   edge_threshold : Int,
     | ) -> Array[MPRange] {
     |   if ranges.length() < 2 {
     |     return ranges
     |   }
     |   if !(ranges[0].is_zero && ranges[0].len() <= edge_threshold) {
     |     return ranges
     |   }
     |   let out : Array[MPRange] = []
     |   out.push({ start: ranges[0].start, end: ranges[1].end, is_zero: false })
     |   for i in 2..<ranges.length() {
 324 |     out.push(ranges[i])
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn mp_merge_right_edge_zero(
     |   ranges : Array[MPRange],
     |   edge_threshold : Int,
     | ) -> Array[MPRange] {
     |   if ranges.length() < 2 {
     |     return ranges
     |   }
     |   let last = ranges.length() - 1
     |   if !(ranges[last].is_zero && ranges[last].len() <= edge_threshold) {
     |     return ranges
     |   }
     |   let out : Array[MPRange] = []
     |   for i in 0..<(last - 1) {
 343 |     out.push(ranges[i])
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 345 |   out.push({
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     start: ranges[last - 1].start,
     |     end: ranges[last].end,
     |     is_zero: false,
     |   })
     |   out
     | }
     …

     | fn mp_merge_small_interior_zeros(
     |   ranges : Array[MPRange],
     |   threshold : Int,
     | ) -> Array[MPRange] {
     |   if ranges.length() < 3 {
     |     return ranges
     |   }
     |   for i in 1..<(ranges.length() - 1) {
     |     let curr = ranges[i]
     |     if !(curr.is_zero && curr.len() <= threshold) {
     |       continue
     |     }
     |     let left = ranges[i - 1]
     |     let right = ranges[i + 1]
     |     if left.is_zero || right.is_zero {
 369 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let out : Array[MPRange] = []
     |     for j in 0..<(i - 1) {
 373 |       out.push(ranges[j])
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     out.push({ start: left.start, end: right.end, is_zero: false })
     |     for j in (i + 2)..<ranges.length() {
 377 |       out.push(ranges[j])
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     return out
     |   }
     |   ranges
     | }
     …

     | fn mp_initial_memory_bytes(limits : Limits) -> UInt64 {
     |   let pages = match limits {
     |     I32Limits(min, _) => min.to_uint64()
 428 |     I64Limits(min, _) => min
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if pages == 0UL {
 431 |     return 0UL
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let shifted = pages << 16
     |   if shifted >> 16 != pages {
 435 |     MP_U64_MAX
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     shifted
     |   }
     | }
     …

     | fn mp_active_startup_may_trap(
     |   offset : MPConstOffset,
     |   size : Int,
     |   limits : Limits,
     | ) -> Bool {
     |   let base = match offset {
     |     MPConstOffset::I32(v) => v.to_uint64()
 449 |     MPConstOffset::I64(v) => v
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let size_u64 = if size <= 0 {
 452 |     0UL
     |     ^^^ 	<-- UNCOVERED
     |   } else {
     |     size.reinterpret_as_uint().to_uint64()
     |   }
     |   let end = mp_u64_add_saturating(base, size_u64)
     |   let mem_bytes = mp_initial_memory_bytes(limits)
     |   end > mem_bytes
     | }
     …

     | fn mp_has_trailing_zero_range(ranges : Array[MPRange]) -> Bool {
     |   if ranges.is_empty() {
 464 |     false
     |     ^^^^^ 	<-- UNCOVERED
     |   } else {
     |     ranges[ranges.length() - 1].is_zero
     |   }
     | }
     …

     | fn mp_preserve_active_trap_byte(ranges : Array[MPRange]) -> Array[MPRange] {
     |   if ranges.is_empty() {
 473 |     return ranges
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let last = ranges.length() - 1
     |   if !ranges[last].is_zero || ranges[last].len() <= 0 {
 477 |     return ranges
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let shrunk = {
     |     start: ranges[last].start,
     |     end: ranges[last].end - 1,
     |     is_zero: true,
     |   }
     |   let one = {
     |     start: ranges[last].end - 1,
     |     end: ranges[last].end,
     |     is_zero: false,
     |   }
     |   let out : Array[MPRange] = []
     |   for i in 0..<last {
 491 |     out.push(ranges[i])
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if shrunk.len() > 0 {
     |     out.push(shrunk)
     |   }
     |   out.push(one)
     |   out
     | }
     …

     | fn calculate_ranges(
     |   mod : Module,
     |   segment : Data,
     |   referrers : MPSegmentReferrers,
     |   options : MemoryPackingPassProps,
     | ) -> Array[MPRange] {
     |   let Data(mode, bytes) = segment
     |   let mut ranges = mp_compute_ranges(bytes)
     |   ranges = match mode {
     |     Passive => mp_merge_small_zeros_passive(ranges, referrers)
     |     Active(_, _) => mp_merge_small_zeros_active(ranges)
     |   }
     |   match mode {
     |     Active(mem_idx, offset_expr) =>
     |       if !options.traps_never_happen {
     |         match mp_const_offset_expr(offset_expr) {
     |           Some(offset_const) =>
     |             match mp_get_memory_limits(mp_collect_memory_limits(mod), mem_idx) {
     |               Some(limits) =>
     |                 if mp_active_startup_may_trap(
     |                     offset_const,
     |                     bytes.length(),
     |                     limits,
     |                   ) &&
     |                   mp_has_trailing_zero_range(ranges) {
     |                   ranges = mp_preserve_active_trap_byte(ranges)
     |                 }
 528 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
 530 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     _ => ()
     |   }
     |   ranges
     | }
     …

     | fn mp_last_non_zero_range_idx(ranges : Array[MPRange]) -> Int {
 559 |   let mut idx = -1
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i in 0..<ranges.length() {
 561 |     if !ranges[i].is_zero && ranges[i].len() > 0 {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       idx = i
     |     }
     |   }
     |   idx
     | }
     …

     | fn mp_reduce_ranges_to_capacity(
     |   ranges : Array[MPRange],
     |   capacity : Int,
     | ) -> Array[MPRange] {
     |   let non_zero = mp_count_non_zero_ranges(ranges)
     |   if non_zero <= capacity {
     |     return ranges
     |   }
 577 |   let last_non_zero = mp_last_non_zero_range_idx(ranges)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if last_non_zero < 0 {
 579 |     return ranges
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if capacity <= 0 {
 582 |     return [
     |     ^^^^^^^^ 	<-- UNCOVERED
     |       { start: ranges[0].start, end: ranges[last_non_zero].end, is_zero: false },
     |     ]
     |   }
     |   let out : Array[MPRange] = []
     |   let mut seen_non_zero = 0
     |   let mut i = 0
     |   while i < ranges.length() {
 590 |     let r = ranges[i]
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     if !r.is_zero && r.len() > 0 {
 592 |       if seen_non_zero == capacity - 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         out.push({
     |           start: r.start,
     |           end: ranges[last_non_zero].end,
     |           is_zero: false,
     |         })
     |         break
     |       }
 600 |       out.push(r)
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |       seen_non_zero += 1
     |       i += 1
     |       continue
     |     }
 605 |     out.push(r)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |     i += 1
     |   }
     |   while !out.is_empty() && out[out.length() - 1].is_zero {
 609 |     ignore(out.pop())
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn can_split_segment(
     |   segment : Data,
     |   referrers : MPSegmentReferrers,
     |   module_features : MPModuleFeatures,
     | ) -> Bool {
     |   let Data(mode, bytes) = segment
     |   if bytes.length() == 0 {
     |     return false
     |   }
     |   if referrers.gc_data_refs > 0 {
 625 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   // Data segment names are not modeled in core IR; keep this flag plumbed
     |   // so callers can gate specific segments from split decisions.
     |   if module_features.segment_is_llvm_named {
     |     return false
     |   }
     |   match mode {
     |     Active(_, expr) => mp_const_offset_expr(expr) is Some(_)
     |     Passive => !referrers.passive_has_non_const_meminit
     |   }
     | }
     …

     | fn mp_ranges_to_non_zero_segments(
     |   segment : Data,
     |   ranges : Array[MPRange],
     | ) -> Array[Data] {
     |   let Data(mode, bytes) = segment
     |   let out : Array[Data] = []
     |   match mode {
     |     Passive =>
     |       for range in ranges {
     |         if range.is_zero || range.len() <= 0 {
     |           continue
     |         }
     |         out.push(
     |           Data::new(
     |             DataMode::passive(),
     |             bytes[range.start:range.end].to_bytes(),
     |           ),
     |         )
     |       }
     |     Active(mem_idx, offset_expr) =>
     |       match mp_const_offset_expr(offset_expr) {
     |         Some(base_const) =>
     |           for range in ranges {
     |             if range.is_zero || range.len() <= 0 {
     |               continue
     |             }
     |             let offset = saturating_add_start_offset(range.start, base_const)
     |             out.push(
     |               Data::new(
     |                 DataMode::active(mem_idx, mp_offset_const_to_expr(offset)),
     |                 bytes[range.start:range.end].to_bytes(),
     |               ),
     |             )
     |           }
     |         None =>
     |           // Non-constant active offsets are not split in this pass.
 675 |           out.push(segment)
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     |   out
     | }
     …

     | fn make_gt_shifted_memory_size(
     |   mem : MemIdx,
     |   dest : TInstr,
     |   limits : Limits,
     | ) -> TInstr {
     |   if mp_is_memory64(limits) {
 698 |     TInstr::binary(
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       BinaryOp::i64_gt_u(),
     |       dest,
 701 |       TInstr::binary(
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         BinaryOp::i64_shl(),
     |         TInstr::memory_size(mem),
     |         TInstr::i64_const(I64(16L)),
     |       ),
     |     )
     |   } else {
     |     TInstr::binary(
     |       BinaryOp::i32_gt_u(),
     |       dest,
     |       TInstr::binary(
     |         BinaryOp::i32_shl(),
     |         TInstr::memory_size(mem),
     |         TInstr::i32_const(I32(16)),
     |       ),
     |     )
     |   }
     | }
     …

     | fn ensure_drop_state_global(mod : Module) -> (Module, GlobalIdx) {
     |   let imported_globals = mp_count_imported_globals(mod)
     |   let existing_defined = match mod.global_sec {
 745 |     Some(GlobalSec(globals)) => globals.length().reinterpret_as_uint()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => 0U
     |   }
     |   let idx = GlobalIdx::new(imported_globals + existing_defined)
     |   let globals = match mod.global_sec {
 750 |     Some(GlobalSec(gs)) => gs.copy()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => []
     |   }
     |   globals.push(
     |     Global::new(
     |       GlobalType::new(ValType::i32(), true),
     |       TExpr::new([TInstr::i32_const(I32(0))]).to_expr(),
     |     ),
     |   )
     |   (mod.with_global_sec(GlobalSec::new(globals)), idx)
     | }
     …

     | fn collect_segment_referrers(mod : Module) -> Map[Int, MPSegmentReferrers] {
     |   let out : Map[Int, MPSegmentReferrers] = Map::new()
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     fn update_ref(
     |       out : Map[Int, MPSegmentReferrers],
     |       idx : Int,
     |       f : (MPSegmentReferrers) -> MPSegmentReferrers,
     |     ) -> Unit {
     |       let curr = out.get(idx).unwrap_or(mp_empty_referrers())
     |       out[idx] = f(curr)
     |     }
     | 
     |     match instr {
     |       TMemoryInit(di, _, _, src, len) => {
     |         let idx = mp_data_idx_to_int(di)
     |         update_ref(out, idx, fn(r) {
     |           {
     |             memory_init_refs: r.memory_init_refs + 1,
     |             data_drop_refs: r.data_drop_refs,
     |             gc_data_refs: r.gc_data_refs,
     |             passive_has_non_const_meminit: r.passive_has_non_const_meminit ||
     |             !(mp_const_u64(src) is Some(_)) ||
     |             !(mp_const_u64(len) is Some(_)),
     |             has_any_non_drop_ref: true,
     |           }
     |         })
     |       }
     |       TDataDrop(di) => {
     |         let idx = mp_data_idx_to_int(di)
     |         update_ref(out, idx, fn(r) {
     |           {
     |             memory_init_refs: r.memory_init_refs,
     |             data_drop_refs: r.data_drop_refs + 1,
     |             gc_data_refs: r.gc_data_refs,
     |             passive_has_non_const_meminit: r.passive_has_non_const_meminit,
     |             has_any_non_drop_ref: r.has_any_non_drop_ref,
     |           }
     |         })
     |       }
 802 |       TArrayNewData(_, di, _, _) | TArrayInitData(_, di, _, _, _, _) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let idx = mp_data_idx_to_int(di)
     |         update_ref(out, idx, fn(r) {
     |           {
     |             memory_init_refs: r.memory_init_refs,
     |             data_drop_refs: r.data_drop_refs,
     |             gc_data_refs: r.gc_data_refs + 1,
     |             passive_has_non_const_meminit: r.passive_has_non_const_meminit,
     |             has_any_non_drop_ref: true,
     |           }
     |         })
     |       }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_module((), mod))
     |   out
     | }
     …

     | fn drop_unused_segments(
     |   mod : Module,
     |   referrers : Map[Int, MPSegmentReferrers],
     | ) -> Set[Int] {
     |   let removed : Set[Int] = Set::new()
     |   match mod.data_sec {
     |     Some(DataSec(datas)) =>
     |       for i in 0..<datas.length() {
     |         let refs = referrers.get(i).unwrap_or(mp_empty_referrers())
     |         match datas[i] {
     |           Data(Passive, _) => if !refs.has_any_non_drop_ref { removed.add(i) }
     |           _ => ()
     |         }
     |       }
 837 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   removed
     | }
     …

     | fn mp_active_segment_indices(mod : Module) -> Set[Int] {
     |   let out : Set[Int] = Set::new()
     |   match mod.data_sec {
     |     Some(DataSec(datas)) =>
     |       for i in 0..<datas.length() {
     |         match datas[i] {
     |           Data(Active(_, _), _) => out.add(i)
     |           _ => ()
     |         }
     |       }
 853 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn mp_drop_and_unreachable(dest : TInstr, src : TInstr, len : TInstr) -> TInstr {
 860 |   TInstr::block(
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BlockType::void_(),
     |     TExpr::new([
     |       TInstr::drop(dest),
     |       TInstr::drop(src),
     |       TInstr::drop(len),
     |       TInstr::unreachable_(),
     |     ]),
     |   )
     | }
     …

     | fn optimize_segment_ops(
     |   mod : Module,
     |   _options : MemoryPackingPassProps,
     | ) -> Module {
     |   let active = mp_active_segment_indices(mod)
     |   let referrers = collect_segment_referrers(mod)
     |   let memories = mp_collect_memory_limits(mod)
     |   let data_segments = match mod.data_sec {
     |     Some(DataSec(datas)) => datas
 881 |     None => return mod
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let rewriter = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     _,
     |     instr,
     |   ) {
     |     let walked = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, out))) => out
     |       Ok(None) => instr
 891 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match walked {
     |       TDataDrop(di) =>
     |         if active.contains(mp_data_idx_to_int(di)) {
 896 |           change((), TInstr::nop())
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           unchanged()
     |         }
     |       TMemoryInit(di, mi, dest, src, len) => {
     |         let idx = mp_data_idx_to_int(di)
     |         if idx < 0 || idx >= data_segments.length() {
 903 |           return unchanged()
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let seg_len = match data_segments[idx] {
     |           Data(_, bytes) => bytes.length()
     |         }
     |         match (mp_const_u64(src), mp_const_u64(len)) {
     |           (Some(src_u), Some(len_u)) => {
     |             let seg_len_u = seg_len.reinterpret_as_uint().to_uint64()
     |             let must_trap = src_u > seg_len_u ||
     |               len_u > seg_len_u ||
     |               src_u + len_u < src_u ||
     |               src_u + len_u > seg_len_u
     |             if must_trap {
 916 |               change((), mp_drop_and_unreachable(dest, src, len))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else if active.contains(idx) {
 918 |               let mem_limits = match mp_get_memory_limits(memories, mi) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(l) => l
     |                 None => Limits::i32(0, None)
     |               }
     |               // Active segment refs are lowered to an explicit trap predicate.
     |               let src_non_zero = if src_u == 0UL {
 924 |                 TInstr::i32_const(I32(0))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               } else {
 926 |                 TInstr::i32_const(I32(1))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               let len_non_zero = if len_u == 0UL {
 929 |                 TInstr::i32_const(I32(0))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               } else {
 931 |                 TInstr::i32_const(I32(1))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 933 |               let cond = TInstr::binary(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 BinaryOp::i32_or(),
     |                 make_gt_shifted_memory_size(mi, dest, mem_limits),
     |                 TInstr::binary(BinaryOp::i32_or(), src_non_zero, len_non_zero),
     |               )
 938 |               change(
     |               ^^^^^^^ 	<-- UNCOVERED
     |                 (),
 940 |                 TInstr::if_(
     |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   BlockType::void_(),
     |                   cond,
 943 |                   TExpr::new([TInstr::unreachable_()]),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   None,
     |                 ),
     |               )
     |             } else if len_u == 0UL {
     |               let refs = referrers.get(idx).unwrap_or(mp_empty_referrers())
     |               if refs.data_drop_refs > 0 {
 950 |                 return unchanged()
     |                 ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               let mem_limits = match mp_get_memory_limits(memories, mi) {
     |                 Some(l) => l
 954 |                 None => Limits::i32(0, None)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               change(
     |                 (),
     |                 TInstr::if_(
     |                   BlockType::void_(),
     |                   make_gt_shifted_memory_size(mi, dest, mem_limits),
     |                   TExpr::new([TInstr::unreachable_()]),
     |                   None,
     |                 ),
     |               )
     |             } else {
     |               unchanged()
     |             }
     |           }
     |           _ => unchanged()
     |         }
     |       }
     |       _ => unchanged()
     |     }
     |   })
     |   match rewriter.walk_module((), mod) {
     |     Ok(Some((_, out))) => out
 977 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mp_collect_active_constant_spans(
     |   mod : Module,
     | ) -> (Bool, Array[(UInt64, UInt64)]) {
     |   let spans : Array[(UInt64, UInt64)] = []
     |   match mod.data_sec {
     |     Some(DataSec(datas)) =>
     |       for data in datas {
     |         match data {
     |           Data(Active(_, offset_expr), bytes) =>
     |             match mp_const_offset_expr(offset_expr) {
     |               Some(offset) => {
     |                 let start = match offset {
     |                   MPConstOffset::I32(v) => v.to_uint64()
 995 |                   MPConstOffset::I64(v) => v
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |                 let end = mp_u64_add_saturating(
     |                   start,
     |                   bytes.length().reinterpret_as_uint().to_uint64(),
     |                 )
     |                 spans.push((start, end))
     |               }
     |               None => return (false, [])
     |             }
     |           _ => ()
     |         }
     |       }
1008 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   (true, spans)
     | }
     …

     | fn can_optimize(mod : Module, options : MemoryPackingPassProps) -> Bool {
     |   let memories = mp_collect_memory_limits(mod)
     |   if memories.length() == 0 || memories.length() > 1 {
     |     return false
     |   }
     |   let imported_mems = mp_count_imported_memories(mod)
     |   if imported_mems == 1 && !options.zero_filled_memory {
     |     return false
     |   }
     |   let data_len = match mod.data_sec {
     |     Some(DataSec(datas)) => datas.length()
1025 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if data_len > 1 {
     |     let (all_const, _) = mp_collect_active_constant_spans(mod)
     |     if !all_const {
     |       return false
     |     }
     |   }
     |   let (_, spans) = mp_collect_active_constant_spans(mod)
     |   for i in 0..<spans.length() {
     |     let (s0, e0) = spans[i]
     |     if e0 <= s0 {
1037 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     for j in (i + 1)..<spans.length() {
     |       let (s1, e1) = spans[j]
     |       if e1 <= s1 {
1042 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if s0 < e1 && s1 < e0 {
     |         return false
     |       }
     |     }
     |   }
     |   true
     | }
     …

     | fn mp_transformed_intersections_start_zero(
     |   transform : MPSegmentTransform,
     |   src : UInt64,
     |   size : UInt64,
     | ) -> Bool {
     |   if transform.ranges.is_empty() || size == 0UL {
1059 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let end = src + size
     |   let mut first_seen = false
     |   let mut first_is_zero = false
     |   for range in transform.ranges {
     |     let rs = range.start.reinterpret_as_uint().to_uint64()
     |     let re = range.end.reinterpret_as_uint().to_uint64()
     |     let isect_start = if rs > src { rs } else { src }
     |     let isect_end = if re < end { re } else { end }
     |     if isect_end > isect_start {
     |       first_seen = true
     |       first_is_zero = range.is_zero
     |       break
     |     }
     |   }
     |   first_seen && first_is_zero
     | }
     …

     | fn mp_segment_has_zero_range(transform : MPSegmentTransform) -> Bool {
1080 |   for range in transform.ranges {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     if range.is_zero && range.len() > 0 {
     |       return true
     |     }
     |   }
     |   false
     | }
     …

     | fn mp_needs_drop_state_global(
     |   mod : Module,
     |   transforms : Map[Int, MPSegmentTransform],
     | ) -> Bool {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     state,
     |     instr,
     |   ) {
     |     let mut needed = state
     |     match instr {
     |       TMemoryInit(di, _, _, src, len) => {
     |         let idx = mp_data_idx_to_int(di)
     |         match transforms.get(idx) {
     |           Some(transform) if transform.transformed =>
     |             match (mp_const_u64(src), mp_const_u64(len)) {
     |               (Some(src_u), Some(len_u)) =>
     |                 if len_u == 0UL ||
     |                   mp_transformed_intersections_start_zero(
     |                     transform, src_u, len_u,
     |                   ) {
     |                   needed = true
     |                 }
1112 |               _ => if mp_segment_has_zero_range(transform) { needed = true }
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           _ => ()
     |         }
     |       }
     |       _ => ()
     |     }
     |     if needed {
     |       Ok(Some((true, instr)))
     |     } else {
     |       self.walk_tinstruction_default(false, instr)
     |     }
     |   })
     |   match walker.walk_module(false, mod) {
     |     Ok(Some((needed, _))) => needed
1127 |     Ok(None) => false
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(_) => false
     |   }
     | }
     …

     | fn mp_build_drop_check(
     |   mem : MemIdx,
     |   dest : TInstr,
     |   limits : Limits,
     |   drop_state_global : GlobalIdx?,
     | ) -> TInstr {
1194 |   let mem_oob = make_gt_shifted_memory_size(mem, dest, limits)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match drop_state_global {
     |     Some(drop_idx) =>
1197 |       TInstr::binary(
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         BinaryOp::i32_or(),
     |         mem_oob,
1200 |         TInstr::binary(
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           BinaryOp::i32_ne(),
     |           TInstr::global_get(drop_idx),
     |           TInstr::i32_const(I32(0)),
     |         ),
     |       )
1206 |     None => mem_oob
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mp_build_memory_init_replacement(
     |   state : MPRewriteFuncState,
     |   plan : MPReplacementPlan,
     |   transform : MPSegmentTransform,
     |   old_di : DataIdx,
     |   mem : MemIdx,
     |   dest : TInstr,
     |   src : TInstr,
     |   len : TInstr,
     | ) -> TInstr? {
     |   let src_u = match mp_const_u64(src) {
     |     Some(v) => v
1223 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let len_u = match mp_const_u64(len) {
     |     Some(v) => v
1227 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let limits = match mp_get_memory_limits(plan.memory_limits, mem) {
     |     Some(l) => l
1231 |     None => Limits::i32(0, None)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let seq : Array[TInstr] = []
     |   let mut base_dest = dest
     |   if !(mp_const_u64(dest) is Some(_)) {
     |     let temp = mp_alloc_local(state, limits.addr_valtype())
     |     seq.push(TInstr::local_set(temp, dest))
     |     base_dest = TInstr::local_get(temp)
     |   }
     |   if len_u == 0UL {
1241 |     let cond = mp_build_drop_check(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mem,
     |       base_dest,
     |       limits,
     |       plan.drop_state_global,
     |     )
1247 |     seq.push(
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |       TInstr::if_(
     |         BlockType::void_(),
     |         cond,
1251 |         TExpr::new([TInstr::unreachable_()]),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None,
     |       ),
     |     )
1255 |     return Some(TInstr::block(BlockType::void_(), TExpr::new(seq)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let src_end = src_u + len_u
     |   let mut first_emitted = false
     |   for i in 0..<transform.ranges.length() {
     |     let range = transform.ranges[i]
     |     let rs = range.start.reinterpret_as_uint().to_uint64()
     |     let re = range.end.reinterpret_as_uint().to_uint64()
     |     let isect_start = if rs > src_u { rs } else { src_u }
     |     let isect_end = if re < src_end { re } else { src_end }
     |     if isect_end <= isect_start {
     |       continue
     |     }
     |     let chunk_len = isect_end - isect_start
     |     let written = mp_range_dest_offset(isect_start, src_u)
     |     let chunk_dest = mp_ptr_add_for_limits(limits, base_dest, written)
     |     if range.is_zero {
     |       if !first_emitted {
     |         match plan.drop_state_global {
     |           Some(drop_idx) =>
     |             seq.push(
     |               TInstr::if_(
     |                 BlockType::void_(),
     |                 TInstr::binary(
     |                   BinaryOp::i32_ne(),
     |                   TInstr::global_get(drop_idx),
     |                   TInstr::i32_const(I32(0)),
     |                 ),
     |                 TExpr::new([TInstr::unreachable_()]),
     |                 None,
     |               ),
     |             )
1287 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       seq.push(
     |         emit_memory_fill(
     |           mem,
     |           chunk_dest,
     |           mp_ptr_const_for_limits(limits, chunk_len),
     |         ),
     |       )
     |     } else {
     |       let new_idx = match transform.range_new_indices[i] {
     |         Some(di) => di
1300 |         None => old_di
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let offset_inside_split = isect_start - rs
     |       seq.push(
     |         emit_memory_init(
     |           new_idx,
     |           mem,
     |           chunk_dest,
     |           mp_ptr_const_for_limits(limits, offset_inside_split),
     |           mp_ptr_const_for_limits(limits, chunk_len),
     |         ),
     |       )
     |     }
     |     first_emitted = true
     |   }
     |   if seq.is_empty() {
1316 |     Some(TInstr::nop())
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else if seq.length() == 1 {
     |     Some(seq[0])
     |   } else {
     |     Some(TInstr::block(BlockType::void_(), TExpr::new(seq)))
     |   }
     | }
     …

     | fn apply_replacements(
     |   mod : Module,
     |   plan : MPReplacementPlan,
     | ) -> Result[Module, String] {
     |   let mut mod = mod
     |   let imported_funcs = mp_count_imported_funcs(mod)
     |   let env = Env::new().with_module(mod)
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) => {
     |       let new_funcs : Array[Func] = []
     |       for i in 0..<funcs.length() {
     |         let abs_idx = imported_funcs + i.reinterpret_as_uint()
     |         let param_count = match
     |           env.get_functype_by_funcidx(FuncIdx::new(abs_idx)) {
     |           Some(FuncType(params, _)) => params.length()
1340 |           None => 0
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match funcs[i] {
     |           TFunc(locals, body) => {
     |             let init_state = {
     |               next_local: param_count + locals.length(),
     |               new_locals: [],
     |             }
     |             let rewriter = ModuleTransformer::new().on_tinstruction_evt(fn(
     |               self,
     |               state : MPRewriteFuncState,
     |               instr : TInstr,
     |             ) {
     |               let walked = match self.walk_tinstruction_default(state, instr) {
     |                 Ok(Some((s, out))) => (s, out)
     |                 Ok(None) => (state, instr)
1356 |                 Err(e) => return Err(e)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               let (state, curr) = walked
     |               match curr {
     |                 TDataDrop(di) => {
     |                   let idx = mp_data_idx_to_int(di)
     |                   if plan.removed_passive.contains(idx) {
     |                     return change(state, TInstr::nop())
     |                   }
     |                   match plan.transforms.get(idx) {
     |                     Some(transform) if transform.transformed => {
     |                       let seq : Array[TInstr] = []
     |                       match plan.drop_state_global {
     |                         Some(drop_idx) =>
     |                           seq.push(
     |                             TInstr::global_set(
     |                               drop_idx,
     |                               TInstr::i32_const(I32(1)),
     |                             ),
     |                           )
1376 |                         None => ()
     |                         ^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
     |                       for maybe_idx in transform.range_new_indices {
     |                         match maybe_idx {
     |                           Some(new_idx) => seq.push(emit_data_drop(new_idx))
     |                           None => ()
     |                         }
     |                       }
     |                       if seq.is_empty() {
1385 |                         change(state, TInstr::nop())
     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       } else if seq.length() == 1 {
1387 |                         change(state, seq[0])
     |                         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       } else {
     |                         change(
     |                           state,
     |                           TInstr::block(BlockType::void_(), TExpr::new(seq)),
     |                         )
     |                       }
     |                     }
     |                     Some(transform) =>
1396 |                       match transform.new_single_index {
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         Some(new_idx) if new_idx != di =>
1398 |                           change(state, TInstr::data_drop(new_idx))
     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         _ => unchanged()
     |                       }
1401 |                     None => unchanged()
     |                     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |                 TMemoryInit(di, mi, dest, src, len) => {
     |                   let idx = mp_data_idx_to_int(di)
     |                   if plan.removed_passive.contains(idx) {
1407 |                     return change(state, TInstr::nop())
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                   match plan.transforms.get(idx) {
     |                     Some(transform) if transform.transformed =>
     |                       match
     |                         mp_build_memory_init_replacement(
     |                           state, plan, transform, di, mi, dest, src, len,
     |                         ) {
     |                         Some(repl) => change(state, repl)
1416 |                         None => unchanged()
     |                         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
     |                     Some(transform) =>
     |                       match transform.new_single_index {
     |                         Some(new_idx) if new_idx != di =>
1421 |                           change(
     |                           ^^^^^^^ 	<-- UNCOVERED
     |                             state,
1423 |                             TInstr::memory_init(new_idx, mi, dest, src, len),
     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           )
     |                         _ => unchanged()
     |                       }
1427 |                     None => unchanged()
     |                     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
1430 |                 TArrayNewData(ti, di, off, len) => {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   let idx = mp_data_idx_to_int(di)
     |                   if plan.removed_passive.contains(idx) {
1433 |                     return unchanged()
     |                     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
1435 |                   match plan.transforms.get(idx) {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     Some(transform) =>
1437 |                       match transform.new_single_index {
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         Some(new_idx) if new_idx != di =>
1439 |                           change(
     |                           ^^^^^^^ 	<-- UNCOVERED
     |                             state,
1441 |                             TInstr::array_new_data(ti, new_idx, off, len),
     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           )
1443 |                         _ => unchanged()
     |                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
1445 |                     None => unchanged()
     |                     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
1448 |                 TArrayInitData(ti, di, d, o, s, sz) => {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   let idx = mp_data_idx_to_int(di)
     |                   if plan.removed_passive.contains(idx) {
1451 |                     return unchanged()
     |                     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
1453 |                   match plan.transforms.get(idx) {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     Some(transform) =>
1455 |                       match transform.new_single_index {
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         Some(new_idx) if new_idx != di =>
1457 |                           change(
     |                           ^^^^^^^ 	<-- UNCOVERED
     |                             state,
1459 |                             TInstr::array_init_data(ti, new_idx, d, o, s, sz),
     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           )
1461 |                         _ => unchanged()
     |                         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       }
1463 |                     None => unchanged()
     |                     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |                 _ => unchanged()
     |               }
     |             })
     |             let (final_state, new_body) = match
     |               rewriter.walk_texpr(init_state, body) {
     |               Ok(Some((s, rewritten))) => (s, rewritten)
1472 |               Ok(None) => (init_state, body)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |             let new_locals = locals.copy()
     |             for local_ty in final_state.new_locals {
     |               new_locals.push(local_ty)
     |             }
     |             new_funcs.push(Func::t_func(new_locals, new_body))
     |           }
1481 |           _ => new_funcs.push(funcs[i])
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       mod = mod.with_code_sec(CodeSec::new(new_funcs))
     |     }
     |     None => ()
     |   }
     |   Ok(mod)
     | }
     …

     | fn mp_build_transforms_and_segments(
     |   mod : Module,
     |   referrers : Map[Int, MPSegmentReferrers],
     |   removed_passive : Set[Int],
     |   options : MemoryPackingPassProps,
     | ) -> (Module, Map[Int, MPSegmentTransform]) {
     |   let mut mod = mod
     |   let datas = match mod.data_sec {
     |     Some(DataSec(ds)) => ds
1501 |     None => return (mod, Map::new())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let new_datas : Array[Data] = []
     |   let transforms : Map[Int, MPSegmentTransform] = Map::new()
     |   let features = MPModuleFeatures::new()
     |   for old_idx in 0..<datas.length() {
     |     let segment = datas[old_idx]
     |     if removed_passive.contains(old_idx) {
     |       transforms[old_idx] = {
     |         transformed: false,
     |         ranges: [],
     |         range_new_indices: [],
     |         new_single_index: None,
     |       }
     |       continue
     |     }
     |     let refs = referrers.get(old_idx).unwrap_or(mp_empty_referrers())
     |     let Data(_, bytes) = segment
     |     let can_split = can_split_segment(segment, refs, features)
     |     let base_identity = [{ start: 0, end: bytes.length(), is_zero: false }]
     |     let mut ranges = if can_split {
     |       calculate_ranges(mod, segment, refs, options)
     |     } else {
     |       base_identity
     |     }
     |     let remaining_capacity = options.max_data_segments - new_datas.length()
     |     ranges = mp_reduce_ranges_to_capacity(ranges, remaining_capacity)
     |     let transformed = can_split &&
     |       !mp_segment_is_unsplit_identity(ranges, bytes.length())
     |     if !transformed {
     |       let new_idx = mp_int_to_data_idx(new_datas.length())
     |       new_datas.push(segment)
     |       transforms[old_idx] = {
     |         transformed: false,
     |         ranges: base_identity,
     |         range_new_indices: [Some(new_idx)],
     |         new_single_index: Some(new_idx),
     |       }
     |       continue
     |     }
     |     let split_segments = create_split_segments(
     |       segment,
     |       ranges,
     |       options.max_data_segments - new_datas.length(),
     |     )
     |     let range_new_indices : Array[DataIdx?] = Array::make(ranges.length(), None)
     |     let mut split_cursor = 0
     |     for i in 0..<ranges.length() {
     |       let range = ranges[i]
     |       if range.is_zero || range.len() <= 0 {
     |         continue
     |       }
     |       if split_cursor < split_segments.length() {
     |         let new_idx = mp_int_to_data_idx(new_datas.length())
     |         range_new_indices[i] = Some(new_idx)
     |         new_datas.push(split_segments[split_cursor])
     |         split_cursor += 1
     |       }
     |     }
     |     transforms[old_idx] = {
     |       transformed: true,
     |       ranges,
     |       range_new_indices,
     |       new_single_index: None,
     |     }
     |   }
     |   mod = mod.with_data_sec(DataSec::new(new_datas))
     |   match mod.data_cnt_sec {
     |     Some(_) =>
1570 |       mod = mod.with_data_cnt_sec(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         DataCntSec::new(U32(new_datas.length().reinterpret_as_uint())),
     |       )
     |     None => ()
     |   }
     |   (mod, transforms)
     | }
     …

     | fn mp_run(
     |   mod : Module,
     |   options? : MemoryPackingPassProps = MemoryPackingPassProps::new(
     |     zero_filled_memory=true,
     |   ),
     | ) -> Module {
     |   match run_memory_packing_on_module(mod, options) {
     |     Ok(out) => out
1642 |     Err(_) => mod
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mp_first_body(mod : Module) -> TExpr {
     |   match mod.code_sec {
     |     Some(CodeSec([TFunc(_, body), ..])) => body
1650 |     _ => TExpr::new([])
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

306 uncovered line(s) in src/passes/merge_blocks.mbt:

     | fn MBEffects::merge(self : MBEffects, other : MBEffects) -> Unit {
     |   for idx in other.locals_read {
  50 |     self.locals_read.add(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for idx in other.locals_written {
  53 |     self.locals_written.add(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.reads_memory = self.reads_memory || other.reads_memory
     |   self.writes_memory = self.writes_memory || other.writes_memory
     |   self.reads_globals = self.reads_globals || other.reads_globals
     |   self.writes_globals = self.writes_globals || other.writes_globals
     |   self.calls = self.calls || other.calls
     |   self.branches = self.branches || other.branches
     |   self.traps = self.traps || other.traps
     |   self.throws = self.throws || other.throws
     | }
     …

     | fn MBEffects::invalidates(self : MBEffects, other : MBEffects) -> Bool {
     |   for local_idx in self.locals_written {
  68 |     if other.locals_read.contains(local_idx) ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       other.locals_written.contains(local_idx) {
  70 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   for local_idx in self.locals_read {
  74 |     if other.locals_written.contains(local_idx) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       return true
     |     }
     |   }
     |   if (self.reads_memory && other.writes_memory) ||
     |     (self.writes_memory && other.reads_memory) ||
     |     (self.writes_memory && other.writes_memory) {
  81 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.reads_globals && other.writes_globals) ||
     |     (self.writes_globals && other.reads_globals) ||
     |     (self.writes_globals && other.writes_globals) {
  86 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if self.calls || other.calls {
     |     if self.reads_memory ||
     |       self.writes_memory ||
     |       other.reads_memory ||
     |       other.writes_memory ||
     |       self.reads_globals ||
     |       self.writes_globals ||
     |       other.reads_globals ||
     |       other.writes_globals {
     |       return true
     |     }
     |   }
     |   if self.branches || other.branches || self.throws || other.throws {
 101 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if self.traps || other.traps {
     |     if self.has_side_effects() || other.has_side_effects() {
     |       return true
     |     }
     |   }
     |   false
     | }
     …

     | fn mb_collect_shallow_effects(instr : TInstr, effects : MBEffects) -> Unit {
     |   match instr {
 141 |     TLocalGet(idx) => effects.locals_read.add(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalSet(idx, _) => effects.locals_written.add(idx)
     |     TLocalTee(idx, _) => {
     |       effects.locals_read.add(idx)
     |       effects.locals_written.add(idx)
     |     }
 147 |     TGlobalGet(_) => effects.reads_globals = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TGlobalSet(_, _) => effects.writes_globals = true
     |     TLoad(_, _, _) => {
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
 153 |     TStore(_, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
 157 |     TMemoryGrow(_, _) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemorySize(_) => effects.reads_memory = true
     |     TMemoryCopy(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
 163 |     TMemoryFill(_, _, _, _) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryInit(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
 168 |     TDataDrop(_) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableSet(_, _, _) | TTableGrow(_, _, _) | TTableFill(_, _, _, _) =>
 170 |       effects.writes_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableGet(_, _) | TTableSize(_) => effects.reads_memory = true
     |     TTableCopy(_, _, _, _, _) | TTableInit(_, _, _, _, _) | TElemDrop(_) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
     |     TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
     |       effects.calls = true
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
 180 |     | TReturnCallRef(_, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
     |       effects.branches = true
     |     }
     |     TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
     |     | TReturn(_) => effects.branches = true
 192 |     TThrow(_, _) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.throws = true
     |       effects.branches = true
     |     }
 196 |     TThrowRef(_) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.throws = true
     |       effects.branches = true
     |     }
     |     TUnreachable => effects.traps = true
     |     TRefAsNonNull(_) | TRefCast(_, _, _) => effects.traps = true
 202 |     TStructGet(_, _, _) | TStructGetS(_, _, _) | TStructGetU(_, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
 206 |     TStructSet(_, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
 210 |     TArrayGet(_, _, _) | TArrayGetS(_, _, _) | TArrayGetU(_, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
 214 |     TArraySet(_, _, _, _) | TArrayFill(_, _, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TArrayCopy(_, _, _, _, _, _, _)
     |     | TArrayInitData(_, _, _, _, _, _)
 220 |     | TArrayInitElem(_, _, _, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TArrayNew(_, _, _)
     |     | TArrayNewDefault(_, _)
     |     | TArrayNewFixed(_, _)
     |     | TArrayNewData(_, _, _, _)
     |     | TArrayNewElem(_, _, _, _)
     |     | TStructNew(_, _)
 231 |     | TStructNewDefault(_) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => ()
     |   }
     | }
     …

     | fn mb_has_any_branch(instr : TInstr) -> Bool {
     |   match instr {
     |     TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
     |     | TReturn(_) => true
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       mb_has_any_branch_in_expr(body)
 295 |     TIf(_, cond, then_body, else_body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if mb_has_any_branch(cond) || mb_has_any_branch_in_expr(then_body) {
 297 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 299 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(else_) => mb_has_any_branch_in_expr(else_)
     |         None => false
     |       }
     |     }
     |     _ => {
     |       for child in mb_eval_children(instr) {
     |         if mb_has_any_branch(child) {
 307 |           return true
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn mb_has_branch_to_depth_uncached(
     |   instr : TInstr,
     |   depth : Int,
     |   cache : BranchCache,
     | ) -> Bool {
     |   match instr {
     |     TBr(label, _) => mb_label_matches_depth(label, depth)
     |     TBrIf(label, _, _) => mb_label_matches_depth(label, depth)
     |     TBrTable(labels, default, _, _) => {
     |       if mb_label_matches_depth(default, depth) {
     |         return true
     |       }
     |       for label in labels {
 356 |         if mb_label_matches_depth(label, depth) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return true
     |         }
     |       }
     |       false
     |     }
     |     TBrOnNull(label, _, _)
     |     | TBrOnNonNull(label, _, _)
     |     | TBrOnCast(label, _, _, _, _, _)
     |     | TBrOnCastFail(label, _, _, _, _, _) =>
 366 |       mb_label_matches_depth(label, depth)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBlock(_, body) | TLoop(_, body) =>
     |       mb_has_branch_to_depth_in_expr(body, depth + 1, cache)
 369 |     TIf(_, cond, then_body, else_body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if mb_has_branch_to_depth(cond, depth, cache) {
 371 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if mb_has_branch_to_depth_in_expr(then_body, depth + 1, cache) {
 374 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 376 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => mb_has_branch_to_depth_in_expr(other, depth + 1, cache)
     |         None => false
     |       }
     |     }
     |     TTryTable(_, catches, body) => {
     |       for catch_ in catches {
     |         if mb_catch_targets_depth(catch_, depth + 1) {
     |           return true
     |         }
     |       }
 387 |       mb_has_branch_to_depth_in_expr(body, depth + 1, cache)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => {
     |       for child in mb_eval_children(instr) {
     |         if mb_has_branch_to_depth(child, depth, cache) {
 392 |           return true
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn mb_unary_result_type(op : UnaryOp, operand_ty : ValType?) -> ValType? {
 434 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32EqzOp
     |     | I32ClzOp
     |     | I32CtzOp
     |     | I32PopcntOp
     |     | I32WrapI64Op
     |     | I32TruncF32SOp
     |     | I32TruncF32UOp
     |     | I32TruncF64SOp
     |     | I32TruncF64UOp
     |     | I32ReinterpretF32Op
     |     | I32Extend8SOp
     |     | I32Extend16SOp
     |     | I32TruncSatF32SOp
     |     | I32TruncSatF32UOp
     |     | I32TruncSatF64SOp
     |     | I32TruncSatF64UOp
     |     | I64EqzOp
     |     | V128AnyTrueOp
     |     | I8x16AllTrueOp
     |     | I8x16BitmaskOp
     |     | I16x8AllTrueOp
     |     | I16x8BitmaskOp
     |     | I32x4AllTrueOp
     |     | I32x4BitmaskOp
     |     | I64x2AllTrueOp
 460 |     | I64x2BitmaskOp => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64ClzOp
     |     | I64CtzOp
     |     | I64PopcntOp
     |     | I64ExtendI32SOp
     |     | I64ExtendI32UOp
     |     | I64TruncF32SOp
     |     | I64TruncF32UOp
     |     | I64TruncF64SOp
     |     | I64TruncF64UOp
     |     | I64ReinterpretF64Op
     |     | I64Extend8SOp
     |     | I64Extend16SOp
     |     | I64Extend32SOp
     |     | I64TruncSatF32SOp
     |     | I64TruncSatF32UOp
     |     | I64TruncSatF64SOp
 477 |     | I64TruncSatF64UOp => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32AbsOp
     |     | F32NegOp
     |     | F32CeilOp
     |     | F32FloorOp
     |     | F32TruncOp
     |     | F32NearestOp
     |     | F32SqrtOp
     |     | F32ConvertI32SOp
     |     | F32ConvertI32UOp
     |     | F32ConvertI64SOp
     |     | F32ConvertI64UOp
     |     | F32DemoteF64Op
 490 |     | F32ReinterpretI32Op => Some(ValType::f32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64AbsOp
     |     | F64NegOp
     |     | F64CeilOp
     |     | F64FloorOp
     |     | F64TruncOp
     |     | F64NearestOp
     |     | F64SqrtOp
     |     | F64ConvertI32SOp
     |     | F64ConvertI32UOp
     |     | F64ConvertI64SOp
     |     | F64ConvertI64UOp
     |     | F64PromoteF32Op
 503 |     | F64ReinterpretI64Op => Some(ValType::f64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => operand_ty
     |   }
     | }
     …

     | fn mb_binary_result_type(op : BinaryOp, lhs_ty : ValType?) -> ValType? {
 510 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32EqOp
     |     | I32NeOp
     |     | I32LtSOp
     |     | I32LtUOp
     |     | I32GtSOp
     |     | I32GtUOp
     |     | I32LeSOp
     |     | I32LeUOp
     |     | I32GeSOp
     |     | I32GeUOp
     |     | I64EqOp
     |     | I64NeOp
     |     | I64LtSOp
     |     | I64LtUOp
     |     | I64GtSOp
     |     | I64GtUOp
     |     | I64LeSOp
     |     | I64LeUOp
     |     | I64GeSOp
     |     | I64GeUOp
     |     | F32EqOp
     |     | F32NeOp
     |     | F32LtOp
     |     | F32GtOp
     |     | F32LeOp
     |     | F32GeOp
     |     | F64EqOp
     |     | F64NeOp
     |     | F64LtOp
     |     | F64GtOp
     |     | F64LeOp
 542 |     | F64GeOp => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AddOp
     |     | I32SubOp
     |     | I32MulOp
     |     | I32DivSOp
     |     | I32DivUOp
     |     | I32RemSOp
     |     | I32RemUOp
     |     | I32AndOp
     |     | I32OrOp
     |     | I32XorOp
     |     | I32ShlOp
     |     | I32ShrSOp
     |     | I32ShrUOp
     |     | I32RotlOp
 557 |     | I32RotrOp => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64AddOp
     |     | I64SubOp
     |     | I64MulOp
     |     | I64DivSOp
     |     | I64DivUOp
     |     | I64RemSOp
     |     | I64RemUOp
     |     | I64AndOp
     |     | I64OrOp
     |     | I64XorOp
     |     | I64ShlOp
     |     | I64ShrSOp
     |     | I64ShrUOp
     |     | I64RotlOp
 572 |     | I64RotrOp => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32AddOp
     |     | F32SubOp
     |     | F32MulOp
     |     | F32DivOp
     |     | F32MinOp
     |     | F32MaxOp
 579 |     | F32CopysignOp => Some(ValType::f32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64AddOp
     |     | F64SubOp
     |     | F64MulOp
     |     | F64DivOp
     |     | F64MinOp
     |     | F64MaxOp
 586 |     | F64CopysignOp => Some(ValType::f64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => lhs_ty
     |   }
     | }
     …

     | fn mb_load_result_type(op : LoadOp) -> ValType {
 593 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     I32LoadOp | I32Load8SOp | I32Load8UOp | I32Load16SOp | I32Load16UOp =>
 595 |       ValType::i32()
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I64LoadOp
     |     | I64Load8SOp
     |     | I64Load8UOp
     |     | I64Load16SOp
     |     | I64Load16UOp
     |     | I64Load32SOp
 602 |     | I64Load32UOp => ValType::i64()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32LoadOp => ValType::f32()
     |     F64LoadOp => ValType::f64()
     |     _ => ValType::v128()
     |   }
     | }
     …

     | fn mb_ref_func_type(fi : FuncIdx, env : Env) -> ValType {
 611 |   match env.get_functype_by_funcidx(fi) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(_) => ValType::funcref()
     |     None => ValType::funcref()
     |   }
     | }
     …

     | fn mb_infer_texpr_type(texpr : TExpr, env : Env) -> ValType? {
     |   let TExpr(instrs) = texpr
     |   if instrs.is_empty() {
 621 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   } else {
     |     mb_infer_tinstr_type(instrs[instrs.length() - 1], env)
     |   }
     | }
     …

     | fn mb_infer_tinstr_type(instr : TInstr, env : Env) -> ValType? {
     |   match instr {
     |     TI32Const(_) => Some(ValType::i32())
 631 |     TI64Const(_) => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => Some(ValType::f32())
     |     TF64Const(_) => Some(ValType::f64())
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 635 |       Some(ValType::v128())
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
     |     TRefFunc(fi) => Some(mb_ref_func_type(fi, env))
     |     TLocalGet(idx) => env.get_local_type(idx)
     |     TGlobalGet(idx) =>
 640 |       match env.get_global_type(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(GlobalType(vt, _)) => Some(vt)
     |         None => None
     |       }
 644 |     TLocalTee(_, value) => mb_infer_tinstr_type(value, env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TUnary(op, value) =>
 646 |       mb_unary_result_type(op, mb_infer_tinstr_type(value, env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBinary(op, lhs, _) =>
 648 |       mb_binary_result_type(op, mb_infer_tinstr_type(lhs, env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefEq(_, _) | TRefIsNull(_) | TRefTest(_, _, _) => Some(ValType::i32())
     |     TLoad(op, _, _) => Some(mb_load_result_type(op))
     |     TMemorySize(_) | TTableSize(_) => Some(ValType::i32())
     |     TRefAsNonNull(value) =>
 653 |       match mb_infer_tinstr_type(value, env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(RefTypeValType(rt)) =>
 655 |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TRefCast(nullable, ht, _) =>
 659 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructNew(type_idx, _)
     |     | TStructNewDefault(type_idx)
     |     | TArrayNew(type_idx, _, _)
     |     | TArrayNewDefault(type_idx, _)
     |     | TArrayNewFixed(type_idx, _)
     |     | TArrayNewData(type_idx, _, _, _)
     |     | TArrayNewElem(type_idx, _, _, _) =>
 667 |       Some(ValType::ref_type(RefType::new(false, HeapType::new(type_idx))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(type_idx, field_idx, _)
     |     | TStructGetS(type_idx, field_idx, _)
     |     | TStructGetU(type_idx, field_idx, _) =>
 671 |       match env.resolve_struct_fields(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(fields) =>
 673 |           match field_idx {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             U32(raw_idx) =>
 675 |               match fields.get(raw_idx.reinterpret_as_int()) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(field_ty) => Some(field_ty.unpack())
     |                 None => None
     |               }
     |           }
 680 |         Err(_) => None
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TArrayGet(type_idx, _, _)
     |     | TArrayGetS(type_idx, _, _)
     |     | TArrayGetU(type_idx, _, _) =>
 685 |       match env.resolve_array_field(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(field_ty) => Some(field_ty.unpack())
     |         Err(_) => None
     |       }
 689 |     TArrayLen(_) => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TExtractLane(op, _, _) =>
 691 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I8x16ExtractLaneSOp
     |         | I8x16ExtractLaneUOp
     |         | I16x8ExtractLaneSOp
     |         | I16x8ExtractLaneUOp
 696 |         | I32x4ExtractLaneOp => Some(ValType::i32())
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         I64x2ExtractLaneOp => Some(ValType::i64())
     |         F32x4ExtractLaneOp => Some(ValType::f32())
     |         F64x2ExtractLaneOp => Some(ValType::f64())
     |       }
 701 |     TI31GetS(_) | TI31GetU(_) => Some(ValType::i32())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefI31(_) =>
 703 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         ValType::ref_type(
     |           RefType::new(false, HeapType::abs(AbsHeapType::i31())),
     |         ),
     |       )
 708 |     TAnyConvertExtern(_) => Some(ValType::anyref())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TExternConvertAny(_) => Some(ValType::externref())
     |     TSelect(types, _, if_true, if_false) => {
     |       let from_decl = match types {
     |         Some(vts) if vts.length() == 1 => Some(vts[0])
     |         _ => None
     |       }
     |       let from_branches = match
 716 |         (
     |         ^ 	<-- UNCOVERED
     |           mb_infer_tinstr_type(if_true, env),
     |           mb_infer_tinstr_type(if_false, env),
     |         ) {
 720 |         (Some(t), Some(f)) if t == f => Some(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
 723 |       match (from_branches, from_decl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(t), _) => Some(t)
     |         (_, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
     |     TCall(target, _) =>
     |       match env.get_functype_by_funcidx(target) {
 731 |         Some(FuncType(_, [r])) => Some(r)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 735 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
     |     TBlock(bt, body) | TLoop(bt, body) | TTryTable(bt, _, body) =>
     |       match
     |         (mb_infer_texpr_type(body, env), mb_single_result_of_blocktype(bt, env)) {
     |         (Some(t), _) => Some(t)
 743 |         (_, Some(vt)) => Some(vt)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
 746 |     TIf(bt, _, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let from_bt = mb_single_result_of_blocktype(bt, env)
     |       let from_branches = match else_ {
     |         Some(else_expr) =>
 750 |           match
     |           ^^^^^ 	<-- UNCOVERED
     |             (
     |               mb_infer_texpr_type(then_, env),
     |               mb_infer_texpr_type(else_expr, env),
     |             ) {
 755 |             (Some(t), Some(e)) if t == e => Some(t)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ => None
     |           }
 758 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 760 |       match (from_branches, from_bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(t), _) => Some(t)
     |         (_, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
     |     _ => None
     |   }
     | }
     …

     | fn mb_is_unreachable_instr(instr : TInstr) -> Bool {
     |   match instr {
     |     TUnreachable
     |     | TBr(_, _)
     |     | TBrTable(_, _, _, _)
     |     | TReturn(_)
     |     | TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
     |     | TReturnCallRef(_, _, _)
     |     | TThrow(_, _)
     |     | TThrowRef(_) => true
     |     TBlock(_, body) => mb_texpr_is_unreachable(body)
     |     TLoop(_, body) => mb_texpr_is_unreachable(body)
 800 |     TIf(_, cond, then_body, else_body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if mb_is_unreachable_instr(cond) {
 802 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 804 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(else_) =>
 806 |           mb_texpr_is_unreachable(then_body) && mb_texpr_is_unreachable(else_)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => false
     |       }
     |     }
     |     TTryTable(_, _, body) => mb_texpr_is_unreachable(body)
     |     _ => false
     |   }
     | }
     …

     | fn has_dead_code(block : TInstr) -> Bool {
     |   match block {
     |     TBlock(_, body) | TLoop(_, body) => mb_has_dead_code_in_expr(body)
 829 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_finalize_block(block : TInstr, env : Env) -> TInstr {
     |   match block {
     |     TBlock(bt, body) => {
     |       let next_bt = mb_finalize_block_type(bt, body, env)
     |       TInstr::block(next_bt, body)
     |     }
     |     TLoop(bt, body) => {
     |       let next_bt = mb_finalize_block_type(bt, body, env)
     |       TInstr::loop_(next_bt, body)
     |     }
     |     TTryTable(bt, catches, body) => {
     |       let next_bt = mb_finalize_block_type(bt, body, env)
     |       TInstr::try_table(next_bt, catches, body)
     |     }
 859 |     _ => block
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_finalize_block_type(bt : BlockType, body : TExpr, env : Env) -> BlockType {
     |   match bt {
     |     VoidBlockType => BlockType::void_()
     |     ValTypeBlockType(_) =>
     |       match mb_infer_texpr_type(body, env) {
     |         Some(vt) => BlockType::val_type(vt)
 870 |         None => BlockType::void_()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 872 |     TypeIdxBlockType(_) => bt
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_refinalize_instr(instr : TInstr, env : Env) -> TInstr {
     |   match instr {
     |     TBlock(bt, body) => {
     |       let next_body = mb_refinalize_texpr(body, env)
     |       mb_finalize_block(TInstr::block(bt, next_body), env)
     |     }
     |     TLoop(bt, body) => {
     |       let next_body = mb_refinalize_texpr(body, env)
     |       mb_finalize_block(TInstr::loop_(bt, next_body), env)
     |     }
     |     TTryTable(bt, catches, body) => {
     |       let next_body = mb_refinalize_texpr(body, env)
     |       mb_finalize_block(TInstr::try_table(bt, catches, next_body), env)
     |     }
 891 |     TIf(bt, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_cond = mb_refinalize_instr(cond, env)
     |       let next_then = mb_refinalize_texpr(then_, env)
     |       let next_else = match else_ {
     |         Some(e) => Some(mb_refinalize_texpr(e, env))
     |         None => None
     |       }
 898 |       let next_bt = match bt {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TypeIdxBlockType(_) => bt
     |         _ =>
 901 |           match next_else {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(e) =>
 903 |               match
     |               ^^^^^ 	<-- UNCOVERED
     |                 (
     |                   mb_infer_texpr_type(next_then, env),
     |                   mb_infer_texpr_type(e, env),
     |                 ) {
 908 |                 (Some(t), Some(u)) if t == u => BlockType::val_type(t)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 _ => BlockType::void_()
     |               }
 911 |             None => BlockType::void_()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
 914 |       TInstr::if_(next_bt, next_cond, next_then, next_else)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => {
     |       let children = mb_eval_children(instr)
     |       if children.is_empty() {
     |         instr
     |       } else {
     |         let next_children = []
     |         for child in children {
     |           next_children.push(mb_refinalize_instr(child, env))
     |         }
     |         mb_rebuild_non_control(instr, next_children)
     |       }
     |     }
     |   }
     | }
     …

     | fn mb_sequence(instrs : Array[TInstr]) -> TInstr {
     |   match instrs {
 943 |     [] => TInstr::nop()
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     [single] => single
     |     _ => TInstr::block(BlockType::void_(), TExpr::new(instrs))
     |   }
     | }
     …

     | fn mb_drop_or_value(value : TInstr, env : Env) -> TInstr {
     |   if mb_instr_is_concrete(value, env) {
     |     TInstr::drop(value)
     |   } else {
 954 |     value
     |     ^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_can_extract_child_block(
     |   bt : BlockType,
     |   body : TExpr,
     |   env : Env,
     |   branch_cache : BranchCache,
     | ) -> (Bool, Array[TInstr], TInstr) {
     |   let items = body.0
     |   if items.length() < 2 {
 967 |     return (false, [], TInstr::nop())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if mb_has_branch_to_depth_in_expr(body, 0, branch_cache) {
     |     return (false, [], TInstr::nop())
     |   }
 972 |   let back = items[items.length() - 1]
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if mb_is_unreachable_instr(back) {
 974 |     return (false, [], TInstr::nop())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 976 |   let block_ty = mb_single_result_of_blocktype(bt, env)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let back_ty = mb_infer_tinstr_type(back, env)
     |   match bt {
     |     TypeIdxBlockType(_) => return (false, [], TInstr::nop())
     |     _ => ()
     |   }
     |   if block_ty != back_ty {
 983 |     return (false, [], TInstr::nop())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let prefix = []
 986 |   for i = 0; i + 1 < items.length(); i = i + 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     prefix.push(items[i])
     |   }
     |   (true, prefix, back)
     | }
     …

     | fn optimize_expression_restructure(
     |   parent_expr : TInstr,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> (TInstr, Bool) {
     |   match parent_expr {
     |     TIf(bt, cond, then_, else_) =>
1002 |       match cond {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TBlock(cbt, cbody) => {
     |           let (ok, prefix, back) = mb_can_extract_child_block(
     |             cbt,
     |             cbody,
     |             ctx.env,
     |             branch_cache,
     |           )
     |           if !ok {
1011 |             return (parent_expr, false)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1013 |           let moved_effects = MBEffects::new()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           for item in prefix {
1015 |             moved_effects.merge(compute_effects(item))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if moved_effects.has_side_effects() {
1018 |             ctx.needs_refinalize = true
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let wrapped = []
     |           for item in prefix {
1022 |             wrapped.push(item)
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1024 |           wrapped.push(TInstr::if_(bt, back, then_, else_))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let wrapper_bt = match mb_infer_tinstr_type(parent_expr, ctx.env) {
     |             Some(vt) => BlockType::val_type(vt)
     |             None => BlockType::void_()
     |           }
1029 |           return (TInstr::block(wrapper_bt, TExpr::new(wrapped)), true)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1031 |         _ => (parent_expr, false)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1033 |     TThrow(_, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for arg in args {
1035 |         if compute_effects(arg).has_side_effects() {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return (parent_expr, false)
     |         }
     |       }
1039 |       mb_restructure_non_control(parent_expr, mod, options, branch_cache, ctx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TBlock(_, _) | TLoop(_, _) | TTryTable(_, _, _) => (parent_expr, false)
     |     _ =>
     |       mb_restructure_non_control(parent_expr, mod, options, branch_cache, ctx)
     |   }
     | }
     …

     | fn mb_restructure_non_control(
     |   parent_expr : TInstr,
     |   _mod : Module,
     |   _options : OptimizeOptions,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> (TInstr, Bool) {
     |   let children = mb_eval_children(parent_expr)
     |   if children.is_empty() {
     |     return (parent_expr, false)
     |   }
     |   let pulled : Array[TInstr] = []
     |   let rebuilt_children : Array[TInstr] = []
     |   let effects_before = MBEffects::new()
     |   let mut changed = false
     |   for child in children {
     |     let mut next_child = child
     |     match child {
     |       TBlock(bt, body) => {
     |         let (ok, prefix, back) = mb_can_extract_child_block(
     |           bt,
     |           body,
     |           ctx.env,
     |           branch_cache,
     |         )
     |         if ok {
1074 |           let moved_effects = MBEffects::new()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let mut move_ok = true
     |           for item in prefix {
1077 |             moved_effects.merge(compute_effects(item))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             if mb_has_any_branch(item) {
1079 |               move_ok = false
     |               ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           if move_ok &&
     |             !invalidates(moved_effects, effects_before) &&
     |             !invalidates(effects_before, moved_effects) {
1085 |             for item in prefix {
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               pulled.push(item)
     |             }
     |             next_child = back
     |             changed = true
     |             ctx.needs_refinalize = true
     |           }
     |         }
     |       }
     |       _ => ()
     |     }
     |     rebuilt_children.push(next_child)
     |     effects_before.merge(compute_effects(next_child))
     |   }
     |   if !changed {
     |     return (parent_expr, false)
     |   }
1102 |   let rebuilt_parent = mb_rebuild_non_control(parent_expr, rebuilt_children)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let wrapper_items = []
     |   for item in pulled {
1105 |     wrapper_items.push(item)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
1107 |   wrapper_items.push(rebuilt_parent)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let wrapper_bt = match mb_infer_tinstr_type(rebuilt_parent, ctx.env) {
     |     Some(vt) => BlockType::val_type(vt)
     |     None => BlockType::void_()
     |   }
1112 |   (TInstr::block(wrapper_bt, TExpr::new(wrapper_items)), true)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn mb_problem_finder_walk(
     |   origin : LabelIdx,
     |   expr : TInstr,
     |   depth : Int,
     |   under_drop : Bool,
     |   st : ProblemFinderState,
     |   env : Env,
     | ) -> Unit {
     |   if st.blocked is Some(_) {
1148 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   let origin_depth = mb_label_to_int(origin) + depth
     |   match expr {
     |     TBr(label, values) =>
     |       if mb_label_matches_depth(label, origin_depth) && !values.is_empty() {
     |         for value in values {
     |           if compute_effects(value).has_side_effects() {
     |             st.blocked = Some("side effects in br value")
     |             return
     |           }
     |         }
     |       }
     |     TBrIf(label, cond, values) => {
     |       mb_problem_finder_walk(origin, cond, depth, false, st, env)
     |       if st.blocked is Some(_) {
1164 |         return
     |         ^^^^^^ 	<-- UNCOVERED
     |       }
     |       if mb_label_matches_depth(label, origin_depth) && !values.is_empty() {
     |         st.total_br_if_values += 1
     |         if under_drop {
1169 |           st.dropped_br_if_values += 1
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         for value in values {
     |           if compute_effects(value).has_side_effects() {
1173 |             st.blocked = Some("side effects in br_if value")
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             return
     |           }
     |         }
     |       }
     |       for value in values {
     |         mb_problem_finder_walk(origin, value, depth, false, st, env)
     |         if st.blocked is Some(_) {
1181 |           return
     |           ^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |     TBrTable(labels, default, index, values) => {
     |       let mut targets_origin = mb_label_matches_depth(default, origin_depth)
     |       if !targets_origin {
1188 |         for label in labels {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           if mb_label_matches_depth(label, origin_depth) {
     |             targets_origin = true
     |             break
     |           }
     |         }
     |       }
     |       if targets_origin {
     |         st.blocked = Some("unsupported branch op targeting origin")
     |         return
     |       }
1199 |       mb_problem_finder_walk(origin, index, depth, false, st, env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
1201 |         mb_problem_finder_walk(origin, value, depth, false, st, env)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TBrOnNull(label, ref_, values)
     |     | TBrOnNonNull(label, ref_, values)
     |     | TBrOnCast(label, _, _, _, ref_, values)
1207 |     | TBrOnCastFail(label, _, _, _, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if mb_label_matches_depth(label, origin_depth) {
1209 |         st.blocked = Some("unsupported branch op targeting origin")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return
     |       }
1212 |       mb_problem_finder_walk(origin, ref_, depth, false, st, env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for value in values {
1214 |         mb_problem_finder_walk(origin, value, depth, false, st, env)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TTryTable(_, catches, body) => {
     |       for catch_ in catches {
     |         match catch_ {
     |           Catch(_, label)
     |           | CatchRef(_, label)
     |           | CatchAll(label)
     |           | CatchAllRef(label) =>
     |             if mb_label_matches_depth(label, origin_depth + 1) {
     |               match catch_ {
     |                 CatchAllRef(_) => ()
     |                 CatchRef(tag_idx, _) =>
     |                   match env.resolve_tag_functype(tag_idx) {
1229 |                     Some(FuncType(params, _)) if params.is_empty() => ()
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     _ => {
     |                       st.blocked = Some(
     |                         "catch_ref with paramful tag targets origin",
     |                       )
     |                       return
     |                     }
     |                   }
1237 |                 _ => {
     |                 ^^^^^^ 	<-- UNCOVERED
     |                   st.blocked = Some("unsupported catch targeting origin")
     |                   return
     |                 }
     |               }
     |             }
     |         }
     |       }
     |       mb_problem_finder_walk_expr(origin, body, depth + 1, false, st, env)
     |     }
1247 |     TDrop(value) => mb_problem_finder_walk(origin, value, depth, true, st, env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBlock(_, body) | TLoop(_, body) =>
1249 |       mb_problem_finder_walk_expr(origin, body, depth + 1, false, st, env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_, else_) => {
     |       mb_problem_finder_walk(origin, cond, depth, false, st, env)
     |       if st.blocked is Some(_) {
1253 |         return
     |         ^^^^^^ 	<-- UNCOVERED
     |       }
1255 |       mb_problem_finder_walk_expr(origin, then_, depth + 1, false, st, env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if st.blocked is Some(_) {
1257 |         return
     |         ^^^^^^ 	<-- UNCOVERED
     |       }
1259 |       match else_ {
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(e) =>
1261 |           mb_problem_finder_walk_expr(origin, e, depth + 1, false, st, env)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in mb_eval_children(expr) {
1267 |         mb_problem_finder_walk(origin, child, depth, false, st, env)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if st.blocked is Some(_) {
1269 |           return
     |           ^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |   }
     | }
     …

     | fn mb_problem_finder_walk_expr(
     |   origin : LabelIdx,
     |   expr : TExpr,
     |   depth : Int,
     |   under_drop : Bool,
     |   st : ProblemFinderState,
     |   env : Env,
     | ) -> Unit {
     |   for instr in expr.0 {
     |     mb_problem_finder_walk(origin, instr, depth, under_drop, st, env)
     |     if st.blocked is Some(_) {
1287 |       return
     |       ^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn mb_break_value_dropper_walk(
     |   origin : LabelIdx,
     |   expr : TInstr,
     |   depth : Int,
     |   mod : Module,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> TInstr {
     |   let origin_depth = mb_label_to_int(origin) + depth
     |   match expr {
     |     TBr(label, values) =>
     |       if mb_label_matches_depth(label, origin_depth) && !values.is_empty() {
     |         let prefix : Array[TInstr] = []
     |         for value in values {
     |           if mb_is_unreachable_instr(value) {
1321 |             return TInstr::unreachable_()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           prefix.push(mb_drop_or_value(value, ctx.env))
     |         }
     |         prefix.push(TInstr::br(label, []))
     |         mb_sequence(prefix)
     |       } else {
1328 |         expr
     |         ^^^^ 	<-- UNCOVERED
     |       }
1330 |     TBrIf(label, cond, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_cond = mb_break_value_dropper_walk(
     |         origin, cond, depth, mod, branch_cache, ctx,
     |       )
     |       let next_values : Array[TInstr] = []
     |       for value in values {
1336 |         next_values.push(
     |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           mb_break_value_dropper_walk(
     |             origin, value, depth, mod, branch_cache, ctx,
     |           ),
     |         )
     |       }
     |       if mb_label_matches_depth(label, origin_depth) && !next_values.is_empty() {
1343 |         let prefix : Array[TInstr] = []
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for value in next_values {
1345 |           if mb_is_unreachable_instr(value) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             return TInstr::unreachable_()
     |           }
1348 |           prefix.push(mb_drop_or_value(value, ctx.env))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1350 |         prefix.push(TInstr::br_if(label, next_cond, []))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         mb_sequence(prefix)
     |       } else {
1353 |         TInstr::br_if(label, next_cond, next_values)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TTryTable(bt, catches, body) => {
     |       let next_catches : Array[Catch] = []
     |       for catch_ in catches {
     |         let next = match catch_ {
     |           CatchRef(tag, label) if mb_label_matches_depth(
     |               label,
     |               origin_depth + 1,
1363 |             ) => Catch::new(tag, label)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           CatchAllRef(label) if mb_label_matches_depth(label, origin_depth + 1) =>
     |             Catch::all(label)
1366 |           _ => catch_
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         next_catches.push(next)
     |       }
     |       let next_body = mb_break_value_dropper_expr(
     |         origin,
     |         body,
     |         depth + 1,
     |         mod,
     |         branch_cache,
     |         ctx,
     |       )
     |       let rewritten = TInstr::try_table(bt, next_catches, next_body)
     |       let (optimized, _) = optimize_block(
     |         rewritten,
     |         mod,
     |         OptimizeOptions::new(),
     |         branch_cache,
     |         ctx,
     |       )
     |       optimized
     |     }
1388 |     TDrop(value) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_value = mb_break_value_dropper_walk(
     |         origin, value, depth, mod, branch_cache, ctx,
     |       )
     |       if mb_instr_is_concrete(next_value, ctx.env) {
1393 |         TInstr::drop(next_value)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
1395 |         next_value
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1398 |     TBlock(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_body = mb_break_value_dropper_expr(
     |         origin,
     |         body,
     |         depth + 1,
     |         mod,
     |         branch_cache,
     |         ctx,
     |       )
1407 |       let rewritten = TInstr::block(bt, next_body)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (optimized, _) = optimize_block(
     |         rewritten,
     |         mod,
1411 |         OptimizeOptions::new(),
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         branch_cache,
     |         ctx,
     |       )
     |       optimized
     |     }
1417 |     TLoop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_body = mb_break_value_dropper_expr(
     |         origin,
     |         body,
     |         depth + 1,
     |         mod,
     |         branch_cache,
     |         ctx,
     |       )
1426 |       let rewritten = TInstr::loop_(bt, next_body)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (optimized, _) = optimize_block(
     |         rewritten,
     |         mod,
1430 |         OptimizeOptions::new(),
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         branch_cache,
     |         ctx,
     |       )
     |       optimized
     |     }
1436 |     TIf(bt, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_cond = mb_break_value_dropper_walk(
     |         origin, cond, depth, mod, branch_cache, ctx,
     |       )
1440 |       let next_then = mb_break_value_dropper_expr(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         origin,
     |         then_,
     |         depth + 1,
     |         mod,
     |         branch_cache,
     |         ctx,
     |       )
1448 |       let next_else = match else_ {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(e) =>
1450 |           Some(
     |           ^^^^^ 	<-- UNCOVERED
     |             mb_break_value_dropper_expr(
     |               origin,
     |               e,
     |               depth + 1,
     |               mod,
     |               branch_cache,
     |               ctx,
     |             ),
     |           )
1460 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1462 |       TInstr::if_(bt, next_cond, next_then, next_else)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => {
     |       let children = mb_eval_children(expr)
     |       if children.is_empty() {
     |         expr
     |       } else {
1469 |         let next_children = []
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for child in children {
1471 |           next_children.push(
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             mb_break_value_dropper_walk(
     |               origin, child, depth, mod, branch_cache, ctx,
     |             ),
     |           )
     |         }
1477 |         mb_rebuild_non_control(expr, next_children)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | }
     …

     | fn optimize_dropped_block(
     |   drop_instr : TInstr,
     |   block_instr : TInstr,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> (TInstr, Bool) {
     |   ignore(options)
     |   ignore(block_instr)
     |   let mut next_body = match drop_instr {
     |     TDrop(TBlock(_, body)) => body
1514 |     _ => return (drop_instr, false)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for instr in next_body.0 {
     |     match problem_finder(LabelIdx::new(0), instr, mod, options, ctx) {
     |       ProblemBlocked => return (drop_instr, false)
     |       ProblemOk => ()
     |     }
     |   }
     |   {
     |     let rewritten_items : Array[TInstr] = []
     |     for instr in next_body.0 {
     |       rewritten_items.push(
     |         break_value_dropper(
     |           LabelIdx::new(0),
     |           instr,
     |           mod,
     |           options,
     |           branch_cache,
     |           ctx,
     |         ),
     |       )
     |     }
     |     next_body = TExpr::new(rewritten_items)
     |   }
     |   let next_items = next_body.0.copy()
     |   if !next_items.is_empty() {
     |     let last = next_items.pop().unwrap()
     |     next_items.push(mb_drop_or_value(last, ctx.env))
     |   }
     |   let rewritten = mb_finalize_block(
     |     TInstr::block(BlockType::void_(), TExpr::new(next_items)),
     |     ctx.env,
     |   )
     |   let (optimized, _) = optimize_block(
     |     rewritten, mod, options, branch_cache, ctx,
     |   )
     |   (optimized, true)
     | }
     …

     | fn optimize_block(
     |   block : TInstr,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> (TInstr, Bool) {
     |   match block {
     |     TBlock(bt, body) => {
     |       let curr_items = body.0.copy()
     |       let mut any_change = false
     |       let mut rounds = 0
     |       while rounds < 20 {
     |         rounds += 1
     |         let out : Array[TInstr] = []
     |         let mut round_change = false
     |         let n = curr_items.length()
     |         for i = 0; i < curr_items.length(); i = i + 1 {
     |           let item0 = curr_items[i]
     |           let (item1, nested_changed) = mb_optimize_instr(
     |             item0, mod, options, branch_cache, ctx,
     |           )
     |           if nested_changed {
     |             round_change = true
     |           }
     |           match item1 {
     |             TDrop(TBlock(_, _)) => {
     |               let (rewritten, changed) = optimize_dropped_block(
     |                 item1,
     |                 match item1 {
     |                   TDrop(inner) => inner
1594 |                   _ => item1
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                 },
     |                 mod,
     |                 options,
     |                 branch_cache,
     |                 ctx,
     |               )
     |               if changed {
     |                 out.push(rewritten)
     |                 round_change = true
     |                 continue
     |               }
     |             }
     |             _ => ()
     |           }
     |           match item1 {
     |             TBlock(child_bt, child_body) => {
     |               if has_dead_code(item1) {
     |                 out.push(item1)
     |                 continue
     |               }
     |               let child_items = child_body.0
     |               let mut split = child_items.length()
     |               let mut named = false
     |               for j = 0; j < child_items.length(); j = j + 1 {
     |                 if has_branch(child_items[j], LabelIdx::new(0)) {
     |                   split = j
     |                   named = true
     |                   break
     |                 }
     |               }
     |               if named && mb_blocktype_is_concrete(child_bt, ctx.env) {
1626 |                 out.push(item1)
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 continue
     |               }
     |               if split == 0 {
     |                 out.push(item1)
     |                 continue
     |               }
     |               let mut can_move = true
     |               for j = 0; j < split; j = j + 1 {
     |                 if mb_has_any_branch(child_items[j]) {
     |                   can_move = false
     |                   break
     |                 }
     |               }
     |               if !can_move {
     |                 out.push(item1)
     |                 continue
     |               }
     |               for j = 0; j < split; j = j + 1 {
     |                 let has_after = j + 1 < split ||
     |                   split < child_items.length() ||
     |                   i + 1 < n
     |                 out.push(
     |                   mb_prepare_moved_item(child_items[j], has_after, ctx.env),
     |                 )
     |               }
     |               if split < child_items.length() {
     |                 let rest : Array[TInstr] = []
     |                 for j = split; j < child_items.length(); j = j + 1 {
     |                   rest.push(child_items[j])
     |                 }
     |                 out.push(
     |                   mb_finalize_block(
     |                     TInstr::block(child_bt, TExpr::new(rest)),
     |                     ctx.env,
     |                   ),
     |                 )
     |               }
     |               round_change = true
     |               continue
     |             }
     |             TLoop(loop_bt, TExpr([TBlock(inner_bt, inner_body)])) => {
     |               if mb_has_dead_code_in_expr(inner_body) {
1669 |                 out.push(item1)
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 continue
     |               }
     |               let inner_items = inner_body.0
     |               if inner_items.is_empty() {
1674 |                 out.push(item1)
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 continue
     |               }
     |               let mut last_back_branch = -1
     |               for j = 0; j < inner_items.length(); j = j + 1 {
     |                 if mb_has_branch_to_depth(inner_items[j], 1, branch_cache) {
     |                   last_back_branch = j
     |                 }
     |               }
     |               let split = last_back_branch + 1
     |               if split >= inner_items.length() {
     |                 out.push(item1)
     |                 continue
     |               }
     |               if split > 0 && mb_blocktype_is_concrete(loop_bt, ctx.env) {
     |                 out.push(item1)
     |                 continue
     |               }
     |               let mut can_move = true
     |               for j = split; j < inner_items.length(); j = j + 1 {
     |                 if mb_has_branch_to_depth(inner_items[j], 0, branch_cache) ||
     |                   mb_has_branch_to_depth(inner_items[j], 1, branch_cache) ||
     |                   mb_has_any_branch(inner_items[j]) {
1697 |                   can_move = false
     |                   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   break
     |                 }
     |               }
     |               if !can_move {
1702 |                 out.push(item1)
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 continue
     |               }
     |               let keep : Array[TInstr] = []
     |               for j = 0; j < split; j = j + 1 {
     |                 keep.push(inner_items[j])
     |               }
     |               let updated_loop = TInstr::loop_(
     |                 loop_bt,
     |                 TExpr::new([
     |                   mb_finalize_block(
     |                     TInstr::block(inner_bt, TExpr::new(keep)),
     |                     ctx.env,
     |                   ),
     |                 ]),
     |               )
     |               out.push(updated_loop)
     |               for j = split; j < inner_items.length(); j = j + 1 {
     |                 let has_after = j + 1 < inner_items.length() || i + 1 < n
     |                 out.push(
     |                   mb_prepare_moved_item(inner_items[j], has_after, ctx.env),
     |                 )
     |               }
     |               round_change = true
     |               continue
     |             }
     |             _ => ()
     |           }
     |           let (restructured, restructured_changed) = optimize_expression_restructure(
     |             item1, mod, options, branch_cache, ctx,
     |           )
     |           if restructured_changed {
1734 |             out.push(restructured)
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             round_change = true
     |           } else {
     |             out.push(item1)
     |           }
     |         }
     |         if !round_change {
     |           break
     |         }
     |         any_change = true
     |         curr_items.clear()
     |         for item in out {
     |           curr_items.push(item)
     |         }
     |       }
     |       let finalized = mb_finalize_block(
     |         TInstr::block(bt, TExpr::new(curr_items)),
     |         ctx.env,
     |       )
     |       (finalized, any_change)
     |     }
     |     _ => (block, false)
     |   }
     | }
     …

     | fn mb_optimize_instr(
     |   instr : TInstr,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> (TInstr, Bool) {
     |   match instr {
     |     TBlock(_, _) => optimize_block(instr, mod, options, branch_cache, ctx)
     |     TLoop(bt, body) => {
     |       let (next_body, changed) = mb_optimize_texpr(
     |         body, mod, options, branch_cache, ctx,
     |       )
     |       (mb_finalize_block(TInstr::loop_(bt, next_body), ctx.env), changed)
     |     }
     |     TTryTable(bt, catches, body) => {
     |       let (next_body, changed) = mb_optimize_texpr(
     |         body, mod, options, branch_cache, ctx,
     |       )
     |       (
     |         mb_finalize_block(TInstr::try_table(bt, catches, next_body), ctx.env),
     |         changed,
     |       )
     |     }
1784 |     TIf(bt, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_cond, changed_cond) = mb_optimize_instr(
     |         cond, mod, options, branch_cache, ctx,
     |       )
1788 |       let (next_then, changed_then) = mb_optimize_texpr(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         then_, mod, options, branch_cache, ctx,
     |       )
1791 |       let (next_else, changed_else) = match else_ {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(e) => {
     |           let (next, changed) = mb_optimize_texpr(
     |             e, mod, options, branch_cache, ctx,
     |           )
     |           (Some(next), changed)
     |         }
1798 |         None => (None, false)
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       (
1801 |         TInstr::if_(bt, next_cond, next_then, next_else),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         changed_cond || changed_then || changed_else,
     |       )
     |     }
     |     _ => {
     |       let children = mb_eval_children(instr)
     |       if children.is_empty() {
     |         (instr, false)
     |       } else {
     |         let next_children = []
     |         let mut changed = false
     |         for child in children {
     |           let (next_child, child_changed) = mb_optimize_instr(
     |             child, mod, options, branch_cache, ctx,
     |           )
     |           if child_changed {
1817 |             changed = true
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           next_children.push(next_child)
     |         }
     |         if changed {
1822 |           (mb_rebuild_non_control(instr, next_children), true)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           (instr, false)
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn mb_optimize_texpr(
     |   expr : TExpr,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   branch_cache : BranchCache,
     |   ctx : MBContext,
     | ) -> (TExpr, Bool) {
     |   let out : Array[TInstr] = []
     |   let mut changed = false
     |   for instr in expr.0 {
     |     let (next, child_changed) = mb_optimize_instr(
     |       instr, mod, options, branch_cache, ctx,
     |     )
     |     if child_changed {
1846 |       changed = true
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     out.push(next)
     |   }
     |   (TExpr::new(out), changed)
     | }
     …

     | fn run_on_function(
     |   func : Func,
     |   mod : Module,
     |   options : OptimizeOptions,
     | ) -> (Func, Bool) {
     |   match func {
     |     TFunc(locals, body) => {
     |       let env = Env::new().with_module(mod).with_locals(locals)
     |       let ctx = MBContext::new(env)
     |       let root = TInstr::block(BlockType::void_(), body)
     |       let (next_root, changed) = optimize_block(
     |         root,
     |         mod,
     |         options,
     |         ctx.branch_cache,
     |         ctx,
     |       )
     |       let next_body = match next_root {
     |         TBlock(_, b) => b
1873 |         _ => body
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut final_body = next_body
     |       if changed {
     |         final_body = mb_refinalize_texpr(final_body, env)
     |       }
     |       if ctx.needs_refinalize {
1880 |         final_body = mb_refinalize_texpr(final_body, env)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if changed || ctx.needs_refinalize {
     |         (Func::t_func(locals, final_body), true)
     |       } else {
     |         (func, false)
     |       }
     |     }
1888 |     _ => (func, false)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn run_merge_blocks(
     |   mod : Module,
     |   options? : OptimizeOptions = OptimizeOptions::new(),
     | ) -> Module {
     |   let pass = merge_blocks_ir_pass(mod, options~)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
1915 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_eval_children(instr : TInstr) -> Array[TInstr] {
     |   match instr {
     |     // Zero-operand instructions.
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TUnreachable
     |     | TNop
     |     | TLocalGet(_)
     |     | TGlobalGet(_)
     |     | TMemorySize(_)
     |     | TAtomicFence
     |     | TTableSize(_)
     |     | TDataDrop(_)
     |     | TElemDrop(_)
     |     | TStructNewDefault(_) => []
     | 
     |     // Unary operands.
     |     TUnary(_, child)
     |     | TDrop(child)
     |     | TLocalSet(_, child)
     |     | TLocalTee(_, child)
     |     | TGlobalSet(_, child)
     |     | TRefIsNull(child)
     |     | TRefAsNonNull(child)
     |     | TI31GetS(child)
     |     | TI31GetU(child)
     |     | TRefI31(child)
     |     | TArrayLen(child)
     |     | TAnyConvertExtern(child)
     |     | TExternConvertAny(child)
     |     | TThrowRef(child)
     |     | TMemoryGrow(_, child)
     |     | TTableGet(_, child)
     |     | TLoad(_, _, child)
     |     | TArrayNewDefault(_, child)
     |     | TStructGet(_, _, child)
     |     | TStructGetS(_, _, child)
     |     | TStructGetU(_, _, child)
     |     | TI8x16Splat(child)
     |     | TI16x8Splat(child)
     |     | TI32x4Splat(child)
     |     | TI64x2Splat(child)
     |     | TF32x4Splat(child)
     |     | TF64x2Splat(child)
     |     | TExtractLane(_, _, child)
     |     | TRefTest(_, _, child)
     |     | TRefCast(_, _, child)
     |     | TRefGetDesc(child)
     |     | TRefTestDesc(_, _, child)
     |     | TRefCastDescEq(_, _, child) => [child]
     | 
     |     // Two operands.
     |     TBinary(_, left, right)
     |     | TRefEq(left, right)
     |     | TStore(_, _, left, right)
     |     | TMemoryAtomicNotify(_, left, right)
     |     | TAtomicRmw(_, _, left, right)
     |     | TTableSet(_, left, right)
     |     | TTableGrow(_, left, right)
     |     | TStructSet(_, _, left, right)
     |     | TArrayNew(_, left, right)
     |     | TArrayNewData(_, _, left, right)
     |     | TArrayNewElem(_, _, left, right)
     |     | TArrayGet(_, left, right)
     |     | TArrayGetS(_, left, right)
     |     | TArrayGetU(_, left, right)
     |     | TReplaceLane(_, _, left, right)
     |     | TI8x16Swizzle(left, right)
     |     | TI8x16RelaxedSwizzle(left, right)
     |     | TV128Shift(_, left, right)
     |     | TV128LoadLane(_, _, _, left, right)
     |     | TV128StoreLane(_, _, _, left, right) => [left, right]
     | 
     |     // Three operands.
     |     TMemoryFill(_, a, b, c)
     |     | TMemoryCopy(_, _, a, b, c)
     |     | TMemoryInit(_, _, a, b, c)
     |     | TMemoryAtomicWait32(_, a, b, c)
     |     | TMemoryAtomicWait64(_, a, b, c)
     |     | TAtomicCmpxchg(_, _, a, b, c)
     |     | TTableFill(_, a, b, c)
     |     | TTableCopy(_, _, a, b, c)
     |     | TTableInit(_, _, a, b, c)
     |     | TSelect(_, c, a, b)
2009 |     | TV128Ternary(_, a, b, c) => [a, b, c]
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Variable-length operands.
     |     TCall(_, args)
     |     | TReturnCall(_, args)
     |     | TThrow(_, args)
     |     | TBr(_, args)
     |     | TReturn(args)
     |     | TStructNew(_, args)
     |     | TArrayNewFixed(_, args) => args.copy()
2019 |     TCallIndirect(_, _, args, index) | TReturnCallIndirect(_, _, args, index) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = args.copy()
     |       out.push(index)
     |       out
     |     }
2024 |     TCallRef(_, args, ref_) | TReturnCallRef(_, args, ref_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = args.copy()
     |       out.push(ref_)
     |       out
     |     }
     |     TBrIf(_, cond, values) => {
     |       let out = values.copy()
     |       out.push(cond)
     |       out
     |     }
     |     TBrTable(_, _, index, values) => {
     |       let out = values.copy()
     |       out.push(index)
     |       out
     |     }
     |     TBrOnNull(_, ref_, values)
     |     | TBrOnNonNull(_, ref_, values)
     |     | TBrOnCast(_, _, _, _, ref_, values)
2042 |     | TBrOnCastFail(_, _, _, _, ref_, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let out = values.copy()
     |       out.push(ref_)
     |       out
     |     }
2047 |     TArraySet(_, a, b, c) => [a, b, c]
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayFill(_, a, b, c, d) => [a, b, c, d]
     |     TArrayCopy(_, _, a, b, c, d, e) => [a, b, c, d, e]
     |     TArrayInitData(_, _, a, b, c, d) => [a, b, c, d]
     |     TArrayInitElem(_, _, a, b, c, d) => [a, b, c, d]
     |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, left, right) =>
2053 |       [left, right]
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Control-flow structures are handled directly by control-flow logic.
2056 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => []
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_rebuild_non_control(instr : TInstr, children : Array[TInstr]) -> TInstr {
     |   match instr {
     |     // Zero-operand instructions.
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TUnreachable
     |     | TNop
     |     | TLocalGet(_)
     |     | TGlobalGet(_)
     |     | TMemorySize(_)
     |     | TAtomicFence
     |     | TTableSize(_)
     |     | TDataDrop(_)
     |     | TElemDrop(_)
2080 |     | TStructNewDefault(_) => instr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Unary operands.
     |     TUnary(op, _) => TInstr::unary(op, children[0])
     |     TDrop(_) => TInstr::drop(children[0])
     |     TLocalSet(idx, _) => TInstr::local_set(idx, children[0])
     |     TLocalTee(idx, _) => TInstr::local_tee(idx, children[0])
2087 |     TGlobalSet(idx, _) => TInstr::global_set(idx, children[0])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefIsNull(_) => TInstr::ref_is_null(children[0])
     |     TRefAsNonNull(_) => TInstr::ref_as_non_null(children[0])
     |     TI31GetS(_) => TInstr::i31_get_s(children[0])
     |     TI31GetU(_) => TInstr::i31_get_u(children[0])
     |     TRefI31(_) => TInstr::ref_i31(children[0])
     |     TArrayLen(_) => TInstr::array_len(children[0])
     |     TAnyConvertExtern(_) => TInstr::any_convert_extern(children[0])
     |     TExternConvertAny(_) => TInstr::extern_convert_any(children[0])
     |     TThrowRef(_) => TInstr::throw_ref(children[0])
     |     TMemoryGrow(idx, _) => TInstr::memory_grow(idx, children[0])
     |     TTableGet(idx, _) => TInstr::table_get(idx, children[0])
     |     TLoad(op, memarg, _) => TInstr::load(op, memarg, children[0])
     |     TArrayNewDefault(type_idx, _) =>
2101 |       TInstr::array_new_default(type_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(type_idx, field_idx, _) =>
2103 |       TInstr::struct_get(type_idx, field_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGetS(type_idx, field_idx, _) =>
2105 |       TInstr::struct_get_s(type_idx, field_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGetU(type_idx, field_idx, _) =>
2107 |       TInstr::struct_get_u(type_idx, field_idx, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TI8x16Splat(_) => TInstr::i8x16_splat(children[0])
     |     TI16x8Splat(_) => TInstr::i16x8_splat(children[0])
     |     TI32x4Splat(_) => TInstr::i32x4_splat(children[0])
     |     TI64x2Splat(_) => TInstr::i64x2_splat(children[0])
     |     TF32x4Splat(_) => TInstr::f32x4_splat(children[0])
     |     TF64x2Splat(_) => TInstr::f64x2_splat(children[0])
     |     TExtractLane(op, lane, _) => TInstr::extract_lane(op, lane, children[0])
     |     TRefTest(nullable, ht, _) => TInstr::ref_test(nullable, ht, children[0])
     |     TRefCast(nullable, ht, _) => TInstr::ref_cast(nullable, ht, children[0])
     |     TRefGetDesc(_) => TInstr::ref_get_desc(children[0])
     |     TRefTestDesc(nullable, ht, _) =>
2119 |       TInstr::ref_test_desc(nullable, ht, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefCastDescEq(nullable, ht, _) =>
2121 |       TInstr::ref_cast_desc_eq(nullable, ht, children[0])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Two operands.
2124 |     TBinary(op, _, _) => TInstr::binary(op, children[0], children[1])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefEq(_, _) => TInstr::ref_eq(children[0], children[1])
     |     TStore(op, memarg, _, _) =>
2127 |       TInstr::store(op, memarg, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryAtomicNotify(memarg, _, _) =>
2129 |       TInstr::memory_atomic_notify(memarg, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TAtomicRmw(op, memarg, _, _) =>
2131 |       TInstr::atomic_rmw(op, memarg, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableSet(table_idx, _, _) =>
2133 |       TInstr::table_set(table_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableGrow(table_idx, _, _) =>
2135 |       TInstr::table_grow(table_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructSet(type_idx, field_idx, _, _) =>
2137 |       TInstr::struct_set(type_idx, field_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNew(type_idx, _, _) =>
2139 |       TInstr::array_new(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNewData(type_idx, data_idx, _, _) =>
2141 |       TInstr::array_new_data(type_idx, data_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayNewElem(type_idx, elem_idx, _, _) =>
2143 |       TInstr::array_new_elem(type_idx, elem_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayGet(type_idx, _, _) =>
2145 |       TInstr::array_get(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayGetS(type_idx, _, _) =>
2147 |       TInstr::array_get_s(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayGetU(type_idx, _, _) =>
2149 |       TInstr::array_get_u(type_idx, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TReplaceLane(op, lane, _, _) =>
2151 |       TInstr::replace_lane(op, lane, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TI8x16Swizzle(_, _) => TInstr::i8x16_swizzle(children[0], children[1])
     |     TI8x16RelaxedSwizzle(_, _) =>
2154 |       TInstr::i8x16_relaxed_swizzle(children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Shift(op, _, _) => TInstr::v128_shift(op, children[0], children[1])
     |     TV128LoadLane(op, memarg, lane, _, _) =>
2157 |       TInstr::v128_load_lane(op, memarg, lane, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128StoreLane(op, memarg, lane, _, _) =>
2159 |       TInstr::v128_store_lane(op, memarg, lane, children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Three operands.
     |     TMemoryFill(mem_idx, _, _, _) =>
2163 |       TInstr::memory_fill(mem_idx, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryCopy(dst, src, _, _, _) =>
2165 |       TInstr::memory_copy(dst, src, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryInit(data_idx, mem_idx, _, _, _) =>
2167 |       TInstr::memory_init(
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         data_idx,
     |         mem_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TMemoryAtomicWait32(memarg, _, _, _) =>
2175 |       TInstr::memory_atomic_wait32(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         memarg,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TMemoryAtomicWait64(memarg, _, _, _) =>
2182 |       TInstr::memory_atomic_wait64(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         memarg,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TAtomicCmpxchg(op, memarg, _, _, _) =>
2189 |       TInstr::atomic_cmpxchg(op, memarg, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableFill(table_idx, _, _, _) =>
2191 |       TInstr::table_fill(table_idx, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableCopy(dst, src, _, _, _) =>
2193 |       TInstr::table_copy(dst, src, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableInit(elem_idx, table_idx, _, _, _) =>
2195 |       TInstr::table_init(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         elem_idx,
     |         table_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |       )
     |     TSelect(types, _, _, _) =>
2203 |       TInstr::select(types, children[2], children[0], children[1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TV128Ternary(op, _, _, _) =>
2205 |       TInstr::v128_ternary(op, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Variable-length operands.
2208 |     TCall(func_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2210 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2213 |       TInstr::call(func_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2215 |     TReturnCall(func_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2217 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2220 |       TInstr::return_call(func_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2222 |     TThrow(tag_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2224 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2227 |       TInstr::throw_(tag_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2229 |     TBr(label_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2231 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2234 |       TInstr::br(label_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2236 |     TReturn(args) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2238 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2241 |       TInstr::return_(rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2243 |     TStructNew(type_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2245 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2248 |       TInstr::struct_new(type_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2250 |     TArrayNewFixed(type_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt = []
2252 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt.push(children[i])
     |       }
2255 |       TInstr::array_new_fixed(type_idx, rebuilt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2257 |     TCallIndirect(type_idx, table_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
2259 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
2262 |       TInstr::call_indirect(
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         table_idx,
     |         rebuilt_args,
2266 |         children[args.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
2269 |     TReturnCallIndirect(type_idx, table_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
2271 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
2274 |       TInstr::return_call_indirect(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         table_idx,
     |         rebuilt_args,
2278 |         children[args.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
2281 |     TCallRef(type_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
2283 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
2286 |       TInstr::call_ref(type_idx, rebuilt_args, children[args.length()])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2288 |     TReturnCallRef(type_idx, args, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_args = []
2290 |       for i = 0; i < args.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_args.push(children[i])
     |       }
2293 |       TInstr::return_call_ref(type_idx, rebuilt_args, children[args.length()])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TBrIf(label_idx, _, values) => {
     |       let rebuilt_values = []
     |       for i = 0; i < values.length(); i = i + 1 {
     |         rebuilt_values.push(children[i])
     |       }
     |       TInstr::br_if(label_idx, children[values.length()], rebuilt_values)
     |     }
2302 |     TBrTable(labels, default, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
2304 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
2307 |       TInstr::br_table(
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         labels,
     |         default,
2310 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
2314 |     TBrOnNull(label_idx, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
2316 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
2319 |       TInstr::br_on_null(label_idx, children[values.length()], rebuilt_values)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2321 |     TBrOnNonNull(label_idx, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
2323 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
2326 |       TInstr::br_on_non_null(
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         label_idx,
2328 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
2332 |     TBrOnCast(label_idx, castop, ht1, ht2, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
2334 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
2337 |       TInstr::br_on_cast(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         label_idx,
     |         castop.0,
     |         ht1,
     |         castop.1,
     |         ht2,
2343 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
2347 |     TBrOnCastFail(label_idx, castop, ht1, ht2, _, values) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rebuilt_values = []
2349 |       for i = 0; i < values.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values.push(children[i])
     |       }
2352 |       TInstr::br_on_cast_fail(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         label_idx,
     |         castop.0,
     |         ht1,
     |         castop.1,
     |         ht2,
2358 |         children[values.length()],
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         rebuilt_values,
     |       )
     |     }
     |     TArraySet(type_idx, _, _, _) =>
2363 |       TInstr::array_set(type_idx, children[0], children[1], children[2])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayFill(type_idx, _, _, _, _) =>
2365 |       TInstr::array_fill(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |       )
     |     TArrayCopy(dst_type, src_type, _, _, _, _, _) =>
2373 |       TInstr::array_copy(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         dst_type,
     |         src_type,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |         children[4],
     |       )
     |     TArrayInitData(type_idx, data_idx, _, _, _, _) =>
2383 |       TInstr::array_init_data(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         data_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |       )
     |     TArrayInitElem(type_idx, elem_idx, _, _, _, _) =>
2392 |       TInstr::array_init_elem(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         type_idx,
     |         elem_idx,
     |         children[0],
     |         children[1],
     |         children[2],
     |         children[3],
     |       )
     |     TI8x16Shuffle(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15,
     |       _,
     |       _
     |     ) =>
2420 |       TInstr::i8x16_shuffle(
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         l0,
     |         l1,
     |         l2,
     |         l3,
     |         l4,
     |         l5,
     |         l6,
     |         l7,
     |         l8,
     |         l9,
     |         l10,
     |         l11,
     |         l12,
     |         l13,
     |         l14,
     |         l15,
     |         children[0],
     |         children[1],
     |       )
     | 
     |     // Control-flow structures are rebuilt in dedicated handlers.
2442 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => instr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_extract_only_tfunc(mod : Module) -> Func? {
     |   match mod.code_sec {
     |     Some(CodeSec([func])) => Some(func)
2466 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mb_run_on_body(body : TExpr, locals? : Array[ValType] = []) -> TExpr {
     |   let mod = mb_make_test_module_with_body(locals, body)
     |   let out = run_merge_blocks(mod)
     |   match mb_extract_only_tfunc(out) {
     |     Some(TFunc(_, new_body)) => new_body
2476 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

24 uncovered line(s) in src/passes/merge_locals.mbt:

    | fn ml_default_reaching() -> Set[MLSSetRef] {
 65 |   let out = Set::new()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   out.add(MLSSetRef::InitValue)
    |   out
    | }
    …

    | fn ml_get_reaching(flow : MLFlowState, idx : LocalIdx) -> Set[MLSSetRef] {
    |   match flow.get(idx) {
    |     Some(sets) => ml_copy_set(sets)
 74 |     None => ml_default_reaching()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ml_instrument_copies(body : TExpr) -> (TExpr, Bool) {
    |   let changed = Ref::new(false)
    |   let transformer = ModuleTransformer::new().on_tinstruction_evt(fn(
    |     self,
    |     _,
    |     instr : TInstr,
    |   ) {
    |     match instr {
    |       TLocalSet(_, _) => {
    |         let (next, did_change) = visit_local_set(instr)
    |         if did_change {
    |           changed.update(fn(_) { true })
    |           change((), next)
    |         } else {
    |           self.walk_tinstruction_default((), instr)
    |         }
    |       }
    |       _ => self.walk_tinstruction_default((), instr)
    |     }
    |   })
    |   match transformer.walk_texpr((), body) {
    |     Ok(Some((_, out))) => (out, changed.val)
137 |     Ok(None) => (body, changed.val)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(_) => (body, false)
    |   }
    | }
    …

    | fn ml_eval_children(instr : TInstr) -> Array[TInstr] {
    |   match instr {
    |     TI32Const(_)
    |     | TI64Const(_)
    |     | TF32Const(_)
    |     | TF64Const(_)
    |     | TRefNull(_)
    |     | TRefFunc(_)
    |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
    |     | TUnreachable
    |     | TNop
    |     | TLocalGet(_)
    |     | TGlobalGet(_)
    |     | TMemorySize(_)
    |     | TAtomicFence
    |     | TTableSize(_)
    |     | TDataDrop(_)
    |     | TElemDrop(_)
    |     | TStructNewDefault(_) => []
    |     TUnary(_, child)
    |     | TDrop(child)
    |     | TLocalSet(_, child)
    |     | TLocalTee(_, child)
    |     | TGlobalSet(_, child)
    |     | TRefIsNull(child)
    |     | TRefAsNonNull(child)
    |     | TI31GetS(child)
    |     | TI31GetU(child)
    |     | TRefI31(child)
    |     | TArrayLen(child)
    |     | TAnyConvertExtern(child)
    |     | TExternConvertAny(child)
    |     | TThrowRef(child)
    |     | TMemoryGrow(_, child)
    |     | TTableGet(_, child)
    |     | TLoad(_, _, child)
    |     | TArrayNewDefault(_, child)
    |     | TStructGet(_, _, child)
    |     | TStructGetS(_, _, child)
    |     | TStructGetU(_, _, child)
    |     | TI8x16Splat(child)
    |     | TI16x8Splat(child)
    |     | TI32x4Splat(child)
    |     | TI64x2Splat(child)
    |     | TF32x4Splat(child)
    |     | TF64x2Splat(child)
    |     | TExtractLane(_, _, child)
    |     | TRefTest(_, _, child)
    |     | TRefCast(_, _, child)
    |     | TRefGetDesc(child)
    |     | TRefTestDesc(_, _, child)
    |     | TRefCastDescEq(_, _, child) => [child]
    |     TBinary(_, left, right)
    |     | TRefEq(left, right)
    |     | TStore(_, _, left, right)
    |     | TMemoryAtomicNotify(_, left, right)
    |     | TAtomicRmw(_, _, left, right)
    |     | TTableSet(_, left, right)
    |     | TTableGrow(_, left, right)
    |     | TStructSet(_, _, left, right)
    |     | TArrayNew(_, left, right)
    |     | TArrayNewData(_, _, left, right)
    |     | TArrayNewElem(_, _, left, right)
    |     | TArrayGet(_, left, right)
    |     | TArrayGetS(_, left, right)
    |     | TArrayGetU(_, left, right)
    |     | TReplaceLane(_, _, left, right)
    |     | TI8x16Swizzle(left, right)
    |     | TI8x16RelaxedSwizzle(left, right)
    |     | TV128Shift(_, left, right)
    |     | TV128LoadLane(_, _, _, left, right)
214 |     | TV128StoreLane(_, _, _, left, right) => [left, right]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TMemoryFill(_, a, b, c)
    |     | TMemoryCopy(_, _, a, b, c)
    |     | TMemoryInit(_, _, a, b, c)
    |     | TMemoryAtomicWait32(_, a, b, c)
    |     | TMemoryAtomicWait64(_, a, b, c)
    |     | TAtomicCmpxchg(_, _, a, b, c)
    |     | TTableFill(_, a, b, c)
    |     | TTableCopy(_, _, a, b, c)
    |     | TTableInit(_, _, a, b, c)
    |     | TSelect(_, c, a, b)
225 |     | TV128Ternary(_, a, b, c) => [a, b, c]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TCall(_, args)
    |     | TReturnCall(_, args)
    |     | TThrow(_, args)
    |     | TBr(_, args)
    |     | TReturn(args)
    |     | TStructNew(_, args)
232 |     | TArrayNewFixed(_, args) => args.copy()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TCallIndirect(_, _, args, index) | TReturnCallIndirect(_, _, args, index) => {
    |       let out = args.copy()
    |       out.push(index)
    |       out
    |     }
238 |     TCallRef(_, args, ref_) | TReturnCallRef(_, args, ref_) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = args.copy()
    |       out.push(ref_)
    |       out
    |     }
243 |     TBrIf(_, cond, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(cond)
    |       out
    |     }
248 |     TBrTable(_, _, index, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(index)
    |       out
    |     }
    |     TBrOnNull(_, ref_, values)
    |     | TBrOnNonNull(_, ref_, values)
    |     | TBrOnCast(_, _, _, _, ref_, values)
256 |     | TBrOnCastFail(_, _, _, _, ref_, values) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = values.copy()
    |       out.push(ref_)
    |       out
    |     }
261 |     TArraySet(_, a, b, c) => [a, b, c]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TArrayFill(_, a, b, c, d) => [a, b, c, d]
    |     TArrayCopy(_, _, a, b, c, d, e) => [a, b, c, d, e]
    |     TArrayInitData(_, _, a, b, c, d) => [a, b, c, d]
    |     TArrayInitElem(_, _, a, b, c, d) => [a, b, c, d]
    |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, left, right) =>
267 |       [left, right]
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => []
    |   }
    | }
    …

    | fn ml_analyze_tinstruction(
    |   instr : TInstr,
    |   in_flow : MLFlowState,
    |   state : MLAnalyzeState,
    | ) -> MLFlowState {
    |   match instr {
    |     TLocalGet(idx) => {
    |       let get_id = state.next_get_id
    |       state.next_get_id = get_id + 1
    |       state.get_nodes[get_id] = MLGetNode::{ idx, }
    |       state.get_sets[get_id] = ml_get_reaching(in_flow, idx)
    |       in_flow
    |     }
    |     TLocalTee(idx, value) => {
    |       let out_flow = ml_analyze_tinstruction(value, in_flow, state)
    |       let set_id = state.next_set_id
    |       state.next_set_id = set_id + 1
    |       let reaching = Set::new()
    |       reaching.add(MLSSetRef::Set(set_id))
    |       out_flow[idx] = reaching
    |       out_flow
    |     }
    |     TLocalSet(idx, value) => {
    |       let out_flow = ml_analyze_tinstruction(value, in_flow, state)
    |       let mut trivial_set_id : Int? = None
    |       let mut copy_src_idx : LocalIdx? = None
    |       match value {
    |         TLocalTee(src, TLocalGet(src_get)) if src == src_get && idx != src => {
    |           trivial_set_id = Some(state.next_set_id - 1)
    |           copy_src_idx = Some(src)
    |         }
    |         _ => ()
    |       }
    |       let set_id = state.next_set_id
    |       state.next_set_id = set_id + 1
    |       let reaching = Set::new()
    |       reaching.add(MLSSetRef::Set(set_id))
    |       out_flow[idx] = reaching
    |       if trivial_set_id is Some(tid) && copy_src_idx is Some(src) {
    |         state.copies.push(MLCopySite::{
    |           copy_set_id: set_id,
    |           trivial_set_id: tid,
    |           copy_idx: idx,
    |           trivial_idx: src,
    |         })
    |       }
    |       out_flow
    |     }
    |     TIf(_, cond, then_, else_) => {
    |       let flow_after_cond = ml_analyze_tinstruction(cond, in_flow, state)
    |       let then_flow = ml_analyze_texpr(
    |         then_,
    |         ml_copy_flow_state(flow_after_cond),
    |         state,
    |       )
    |       let else_flow = match else_ {
    |         Some(else_expr) =>
    |           ml_analyze_texpr(
    |             else_expr,
    |             ml_copy_flow_state(flow_after_cond),
    |             state,
    |           )
    |         None => ml_copy_flow_state(flow_after_cond)
    |       }
    |       ml_merge_flow_states(then_flow, else_flow)
    |     }
352 |     TBlock(_, body) => ml_analyze_texpr(body, in_flow, state)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TLoop(_, body) => {
    |       let one_iter = ml_analyze_texpr(body, ml_copy_flow_state(in_flow), state)
    |       ml_merge_flow_states(in_flow, one_iter)
    |     }
357 |     TTryTable(_, _, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let body_flow = ml_analyze_texpr(body, ml_copy_flow_state(in_flow), state)
    |       ml_merge_flow_states(in_flow, body_flow)
    |     }
    |     _ => {
    |       let mut flow = in_flow
    |       for child in ml_eval_children(instr) {
    |         flow = ml_analyze_tinstruction(child, flow, state)
    |       }
    |       flow
    |     }
    |   }
    | }
    …

    | fn build_local_graph_snapshot(
    |   func : Func,
    |   mod_ : Module,
    | ) -> MLLocalGraphSnapshot {
    |   ignore(mod_)
    |   match func {
    |     TFunc(_, body) => {
    |       // Build eagerly to avoid IR mutation races with later rewrites.
    |       ignore(LocalGraph::new(body.0))
    |       let state = MLAnalyzeState::{
    |         next_get_id: 0,
    |         next_set_id: 0,
    |         get_sets: Map::new(),
    |         get_nodes: Map::new(),
    |         copies: [],
    |       }
    |       ignore(ml_analyze_texpr(body, Map::new(), state))
    |       {
    |         get_sets: state.get_sets,
    |         set_influences: Map::new(),
    |         get_nodes: state.get_nodes,
    |         copies: state.copies,
    |         get_count: state.next_get_id,
    |       }
    |     }
    |     _ =>
398 |       {
    |       ^ 	<-- UNCOVERED
    |         get_sets: Map::new(),
    |         set_influences: Map::new(),
    |         get_nodes: Map::new(),
    |         copies: [],
    |         get_count: 0,
    |       }
    |   }
    | }
    …

    | fn compute_set_influences(graph : MLLocalGraphSnapshot) -> Unit {
    |   let out = Map::new()
    |   for get_id in 0..<graph.get_count {
    |     let sets = graph.get_sets.get(get_id).unwrap_or(Set::new())
    |     for set_ref in sets {
    |       match set_ref {
    |         MLSSetRef::Set(set_id) => {
    |           let arr = out.get(set_id).unwrap_or([])
    |           arr.push(get_id)
    |           out[set_id] = arr
    |         }
420 |         MLSSetRef::InitValue => ()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    |   graph.set_influences = out
    | }
    …

    | fn ml_local_type(locals : Array[ValType], idx : LocalIdx) -> ValType? {
    |   let i = ml_local_idx_to_int(idx)
    |   if i < 0 || i >= locals.length() {
449 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
    |     Some(locals[i])
    |   }
    | }
    …

    | fn ml_local_types_equal(
    |   locals : Array[ValType],
    |   a : LocalIdx,
    |   b : LocalIdx,
    | ) -> Bool {
    |   match (ml_local_type(locals, a), ml_local_type(locals, b)) {
    |     (Some(ta), Some(tb)) => ta == tb
463 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ml_can_rewrite_gets(
    |   graph : MLLocalGraphSnapshot,
    |   get_ids : Array[Int],
    |   required_set_id : Int,
    |   locals : Array[ValType],
    |   target_local_idx : LocalIdx,
    |   planned_rewrites : Map[Int, LocalIdx],
    | ) -> Bool {
    |   for get_id in get_ids {
    |     if !ml_sets_exactly_set_id(get_sets(graph, get_id), required_set_id) {
    |       return false
    |     }
    |     let get_node = match graph.get_nodes.get(get_id) {
    |       Some(node) => node
482 |       None => return false
    |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     if !ml_local_types_equal(locals, target_local_idx, get_node.idx) {
    |       return false
    |     }
    |     if planned_rewrites.get(get_id) is Some(existing) &&
    |       existing != target_local_idx {
489 |       return false
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   true
    | }
    …

    | fn ml_rewrite_get_indices(
    |   body : TExpr,
    |   rewrites : Map[Int, LocalIdx],
    | ) -> (TExpr, Bool) {
    |   if rewrites.is_empty() {
    |     return (body, false)
    |   }
    |   let get_id = Ref::new(0)
    |   let changed = Ref::new(false)
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     match instr {
    |       TLocalGet(curr_idx) => {
    |         let id = get_id.val
    |         get_id.update(fn(n) { n + 1 })
    |         match rewrites.get(id) {
    |           Some(next_idx) if next_idx != curr_idx => {
    |             changed.update(fn(_) { true })
    |             change((), TInstr::local_get(next_idx))
    |           }
    |           _ => unchanged()
    |         }
    |       }
    |       _ => self.walk_tinstruction_default((), instr)
    |     }
    |   })
    |   match walker.walk_texpr((), body) {
    |     Ok(Some((_, out))) => (out, changed.val)
523 |     Ok(None) => (body, false)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(_) => (body, false)
    |   }
    | }
    …

    | fn ml_cleanup_instrumentation(body : TExpr) -> (TExpr, Bool) {
    |   let changed = Ref::new(false)
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     match instr {
    |       TLocalSet(dst, TLocalTee(src, TLocalGet(src_get))) if src == src_get => {
    |         changed.update(fn(_) { true })
    |         change((), TInstr::local_set(dst, TInstr::local_get(src)))
    |       }
    |       _ => self.walk_tinstruction_default((), instr)
    |     }
    |   })
    |   match walker.walk_texpr((), body) {
    |     Ok(Some((_, out))) => (out, changed.val)
542 |     Ok(None) => (body, false)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(_) => (body, false)
    |   }
    | }
    …

    | fn optimize_copies(func : Func, mod_ : Module) -> (Func, Bool) {
    |   match func {
    |     TFunc(locals, body) => {
    |       let (instrumented_body, _) = ml_instrument_copies(body)
    |       let instrumented_func = Func::t_func(locals, instrumented_body)
    |       let pre_graph = build_local_graph_snapshot(instrumented_func, mod_)
    |       compute_set_influences(pre_graph)
    |       let rewrites : Map[Int, LocalIdx] = Map::new()
    |       let optimized_to_copy : Array[MLRewriteRecord] = []
    |       let optimized_to_trivial : Array[MLRewriteRecord] = []
    |       for copy in pre_graph.copies {
    |         let trivial_influences = get_set_influences(
    |           pre_graph,
    |           copy.trivial_set_id,
    |         )
    |         let has_trivial_influences = !trivial_influences.is_empty()
    |         let copy_influences = get_set_influences(pre_graph, copy.copy_set_id)
    |         let can_optimize_to_copy = has_trivial_influences &&
    |           ml_can_rewrite_gets(
    |             pre_graph,
    |             trivial_influences,
    |             copy.trivial_set_id,
    |             locals,
    |             copy.copy_idx,
    |             rewrites,
    |           )
    |         let can_optimize_to_trivial = has_trivial_influences &&
    |           !copy_influences.is_empty() &&
    |           ml_can_rewrite_gets(
    |             pre_graph,
    |             copy_influences,
    |             copy.copy_set_id,
    |             locals,
    |             copy.trivial_idx,
    |             rewrites,
    |           )
    |         if can_optimize_to_copy && can_optimize_to_trivial {
    |           // Avoid bidirectional oscillation by skipping ambiguous dual-direction copies.
    |           ()
    |         } else if can_optimize_to_copy {
    |           for get_id in trivial_influences {
    |             rewrites[get_id] = copy.copy_idx
    |           }
    |           optimized_to_copy.push(MLRewriteRecord::{
    |             copy_set_id: copy.copy_set_id,
    |             trivial_set_id: copy.trivial_set_id,
    |             get_ids: trivial_influences,
    |           })
    |         } else if can_optimize_to_trivial {
    |           for get_id in copy_influences {
    |             rewrites[get_id] = copy.trivial_idx
    |           }
    |           optimized_to_trivial.push(MLRewriteRecord::{
    |             copy_set_id: copy.copy_set_id,
    |             trivial_set_id: copy.trivial_set_id,
    |             get_ids: copy_influences,
    |           })
    |         }
    |       }
    |       let optimized_body = if rewrites.is_empty() {
    |         instrumented_body
    |       } else {
    |         let (tentative_body, _) = ml_rewrite_get_indices(
    |           instrumented_body, rewrites,
    |         )
    |         let post_func = Func::t_func(locals, tentative_body)
    |         let post_graph = build_local_graph_snapshot(post_func, mod_)
    |         compute_set_influences(post_graph)
    |         let verified_rewrites : Map[Int, LocalIdx] = Map::new()
    |         for entry in rewrites {
    |           let (get_id, idx) = entry
    |           verified_rewrites[get_id] = idx
    |         }
    |         for record in optimized_to_copy {
    |           if !ml_verify_direction(
    |               post_graph,
    |               record.get_ids,
    |               record.copy_set_id,
    |             ) {
    |             for get_id in record.get_ids {
    |               ignore(verified_rewrites.remove(get_id))
    |             }
    |           }
    |         }
    |         for record in optimized_to_trivial {
    |           if !ml_verify_direction(
    |               post_graph,
    |               record.get_ids,
    |               record.trivial_set_id,
    |             ) {
652 |             for get_id in record.get_ids {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               ignore(verified_rewrites.remove(get_id))
    |             }
    |           }
    |         }
    |         if verified_rewrites.length() == rewrites.length() {
    |           tentative_body
    |         } else {
    |           let (rebuilt_body, _) = ml_rewrite_get_indices(
    |             instrumented_body, verified_rewrites,
    |           )
    |           rebuilt_body
    |         }
    |       }
    |       let (cleaned_body, _) = ml_cleanup_instrumentation(optimized_body)
    |       let changed = cleaned_body != body
    |       (Func::t_func(locals, cleaned_body), changed)
    |     }
670 |     _ => (func, false)
    |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

4 uncovered line(s) in src/passes/merge_locals_tests.mbt:

    | fn ml_single_func_body(mod : Module) -> TExpr {
    |   match mod.code_sec {
    |     Some(CodeSec(funcs)) =>
    |       if funcs.length() == 1 {
    |         match funcs[0] {
    |           TFunc(_, body) => body
 13 |           _ => TExpr::new([])
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       } else {
 16 |         TExpr::new([])
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 18 |     None => TExpr::new([])
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ml_trivial_tee_count(body : TExpr) -> Int {
    |   let mut count = 0
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     match instr {
 27 |       TLocalTee(idx, TLocalGet(src)) if idx == src => count += 1
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), instr)
    |   })
    |   ignore(walker.walk_texpr((), body))
    |   count
    | }
    …

103 uncovered line(s) in src/passes/merge_similar_functions.mbt:

     | fn msf_extract_comp_type(sub_type : SubType) -> CompType {
     |   match sub_type {
  77 |     SubType(_, _, comp) => comp
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CompTypeSubType(comp) => comp
     |   }
     | }
     …

     | fn msf_resolve_func_type(
     |   comp_types : Array[CompType],
     |   idx : TypeIdx,
     | ) -> FuncType? {
     |   let i = match idx {
     |     TypeIdx(n) => n
  89 |     RecIdx(n) => n
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let j = i.reinterpret_as_int()
     |   if j < 0 || j >= comp_types.length() {
  93 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match comp_types[j] {
     |     FuncCompType(params, results) => Some(FuncType::new(params, results))
  97 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn msf_count_imported_funcs(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 106 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(_) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn msf_collect_comp_types(mod : Module) -> Array[CompType] {
     |   let comp_types : Array[CompType] = []
     |   match mod.type_sec {
     |     Some(TypeSec(rec_types)) =>
     |       for rec_type in rec_types {
     |         match rec_type {
     |           SingleRecType(sub_type) =>
     |             comp_types.push(msf_extract_comp_type(sub_type))
     |           GroupRecType(sub_types) =>
 128 |             for sub_type in sub_types {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               comp_types.push(msf_extract_comp_type(sub_type))
     |             }
     |         }
     |       }
 133 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   comp_types
     | }
     …

     | fn msf_collect_func_type_indices(mod : Module) -> Array[TypeIdx] {
     |   let out : Array[TypeIdx] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 143 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(type_idx) => out.push(type_idx)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out.push(type_idx)
     |       }
 157 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn msf_collect_func_types(mod : Module) -> Array[FuncType] {
     |   let comp_types = msf_collect_comp_types(mod)
     |   let type_idxs = msf_collect_func_type_indices(mod)
     |   let out : Array[FuncType] = []
     |   for type_idx in type_idxs {
     |     match msf_resolve_func_type(comp_types, type_idx) {
     |       Some(ft) => out.push(ft)
 170 |       None => out.push(FuncType::new([], []))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn msf_zero_const_like(instr : TInstr) -> TInstr {
     |   match instr {
     |     TI32Const(_) => TInstr::i32_const(I32(0))
     |     TI64Const(_) => TInstr::i64_const(I64(0L))
 203 |     TF32Const(_) => TInstr::f32_const(F32(0.0))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF64Const(_) => TInstr::f64_const(F64(0.0))
     |     TRefNull(ht) => TInstr::ref_null(ht)
     |     TRefFunc(_) => TInstr::ref_func(FuncIdx::new(0))
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 208 |       TInstr::v128_const(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |         (0).to_byte(),
     |       )
 226 |     _ => instr
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn msf_const_type(instr : TInstr) -> ValType? {
     |   match instr {
     |     TI32Const(_) => Some(ValType::i32())
 234 |     TI64Const(_) => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => Some(ValType::f32())
     |     TF64Const(_) => Some(ValType::f64())
     |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
     |     TRefFunc(_) =>
 239 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         ValType::ref_type(
     |           RefType::new(false, HeapType::abs(AbsHeapType::func())),
     |         ),
     |       )
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 245 |       Some(ValType::v128())
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn msf_tag_hash(instr : TInstr) -> UInt64 {
     |   let tag : UInt64 = match instr {
     |     TI32Const(_) => 1UL
     |     TI64Const(_) => 2UL
 255 |     TF32Const(_) => 3UL
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF64Const(_) => 4UL
     |     TRefNull(_) => 5UL
     |     TRefFunc(_) => 6UL
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => 7UL
     |     TUnreachable => 8UL
     |     TNop => 9UL
     |     TLocalGet(_) => 10UL
 263 |     TGlobalGet(_) => 11UL
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemorySize(_) => 12UL
     |     TTableSize(_) => 13UL
     |     TUnary(_, _) => 14UL
     |     TDrop(_) => 15UL
     |     TLocalSet(_, _) => 16UL
 269 |     TLocalTee(_, _) => 17UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TGlobalSet(_, _) => 18UL
     |     TRefIsNull(_) => 19UL
     |     TRefAsNonNull(_) => 20UL
     |     TI31GetS(_) => 21UL
     |     TI31GetU(_) => 22UL
     |     TRefI31(_) => 23UL
     |     TArrayLen(_) => 24UL
     |     TAnyConvertExtern(_) => 25UL
     |     TExternConvertAny(_) => 26UL
     |     TThrowRef(_) => 27UL
     |     TBinary(_, _, _) => 28UL
 281 |     TRefEq(_, _) => 29UL
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStore(_, _, _, _) => 30UL
     |     TLoad(_, _, _) => 31UL
     |     TMemoryGrow(_, _) => 32UL
     |     TMemoryAtomicNotify(_, _, _) => 200UL
     |     TMemoryAtomicWait32(_, _, _, _) => 201UL
     |     TMemoryAtomicWait64(_, _, _, _) => 202UL
     |     TAtomicFence => 203UL
     |     TAtomicRmw(_, _, _, _) => 204UL
     |     TAtomicCmpxchg(_, _, _, _, _) => 205UL
     |     TMemoryFill(_, _, _, _) => 33UL
     |     TMemoryCopy(_, _, _, _, _) => 34UL
     |     TMemoryInit(_, _, _, _, _) => 35UL
     |     TDataDrop(_) => 36UL
     |     TTableGet(_, _) => 37UL
     |     TTableSet(_, _, _) => 38UL
     |     TTableGrow(_, _, _) => 39UL
     |     TTableFill(_, _, _, _) => 40UL
     |     TTableCopy(_, _, _, _, _) => 41UL
     |     TTableInit(_, _, _, _, _) => 42UL
     |     TElemDrop(_) => 43UL
     |     TCall(_, _) => 44UL
 303 |     TCallIndirect(_, _, _, _) => 45UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TCallRef(_, _, _) => 46UL
     |     TReturnCall(_, _) => 47UL
     |     TReturnCallIndirect(_, _, _, _) => 48UL
     |     TReturnCallRef(_, _, _) => 49UL
     |     TBlock(_, _) => 50UL
     |     TLoop(_, _) => 51UL
     |     TIf(_, _, _, _) => 52UL
     |     TTryTable(_, _, _) => 53UL
     |     TThrow(_, _) => 54UL
     |     TBr(_, _) => 55UL
     |     TBrIf(_, _, _) => 56UL
     |     TBrTable(_, _, _, _) => 57UL
     |     TBrOnNull(_, _, _) => 58UL
     |     TBrOnNonNull(_, _, _) => 59UL
     |     TBrOnCast(_, _, _, _, _, _) => 60UL
     |     TBrOnCastFail(_, _, _, _, _, _) => 61UL
     |     TReturn(_) => 62UL
 321 |     TSelect(_, _, _, _) => 63UL
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructNew(_, _) => 64UL
     |     TStructNewDefault(_) => 65UL
     |     TStructGet(_, _, _) => 66UL
     |     TStructGetS(_, _, _) => 67UL
     |     TStructGetU(_, _, _) => 68UL
     |     TStructSet(_, _, _, _) => 69UL
     |     TArrayNew(_, _, _) => 70UL
     |     TArrayNewDefault(_, _) => 71UL
     |     TArrayNewFixed(_, _) => 72UL
     |     TArrayNewData(_, _, _, _) => 73UL
     |     TArrayNewElem(_, _, _, _) => 74UL
     |     TArrayGet(_, _, _) => 75UL
     |     TArrayGetS(_, _, _) => 76UL
     |     TArrayGetU(_, _, _) => 77UL
     |     TArraySet(_, _, _, _) => 78UL
     |     TArrayFill(_, _, _, _, _) => 79UL
     |     TArrayCopy(_, _, _, _, _, _, _) => 80UL
     |     TArrayInitData(_, _, _, _, _, _) => 81UL
     |     TArrayInitElem(_, _, _, _, _, _) => 82UL
     |     TRefTest(_, _, _) => 83UL
     |     TRefCast(_, _, _) => 84UL
     |     TRefGetDesc(_) => 85UL
     |     TRefTestDesc(_, _, _) => 86UL
     |     TRefCastDescEq(_, _, _) => 87UL
     |     TI8x16Splat(_) => 88UL
     |     TI16x8Splat(_) => 89UL
     |     TI32x4Splat(_) => 90UL
     |     TI64x2Splat(_) => 91UL
     |     TF32x4Splat(_) => 92UL
     |     TF64x2Splat(_) => 93UL
     |     TExtractLane(_, _, _) => 94UL
     |     TReplaceLane(_, _, _, _) => 95UL
     |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => 96UL
     |     TI8x16Swizzle(_, _) => 97UL
     |     TI8x16RelaxedSwizzle(_, _) => 98UL
     |     TV128Shift(_, _, _) => 99UL
     |     TV128Ternary(_, _, _, _) => 100UL
     |     TV128LoadLane(_, _, _, _, _) => 101UL
     |     TV128StoreLane(_, _, _, _, _) => 102UL
     |   }
     |   tag * 11400714819323198485UL
     | }
     …

     | fn msf_hash_function_ignoring_consts(func : Func) -> UInt64 {
     |   match func {
     |     TFunc(_, body) => {
     |       let normalized = match msf_normalize_body(body) {
     |         Ok(x) => x
 381 |         Err(_) => body
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let state = { digest: 1469598103934665603UL }
     |       let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |         self,
     |         _,
     |         instr,
     |       ) {
     |         msf_hash_tinstr(state, instr)
     |         self.walk_tinstruction_default((), instr)
     |       })
     |       ignore(walker.walk_texpr((), normalized))
     |       state.digest
     |     }
 395 |     _ => 0UL
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn msf_normalize_body(body : TExpr) -> Result[TExpr, String] {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let walked = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, next))) => next
     |       Ok(None) => instr
 410 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let rewritten = match walked {
     |       TI32Const(_)
     |       | TI64Const(_)
     |       | TF32Const(_)
     |       | TF64Const(_)
     |       | TRefNull(_)
     |       | TRefFunc(_)
     |       | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
     |         msf_zero_const_like(walked)
     |       TCall(_, args) => TInstr::call(FuncIdx::new(0), args)
 422 |       TReturnCall(_, args) => TInstr::return_call(FuncIdx::new(0), args)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => walked
     |     }
     |     if rewritten == instr {
     |       unchanged()
     |     } else {
     |       change((), rewritten)
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
     |     Ok(Some((_, out))) => Ok(out)
 433 |     Ok(None) => Ok(body)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn msf_collect_call_sites(body : TExpr) -> Array[MSFCallSite] {
     |   let out : Array[MSFCallSite] = []
     |   let mut next_id = 0
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let id = next_id
     |     next_id += 1
     |     match instr {
     |       TCall(target, args) =>
     |         out.push({
     |           node_id: id,
     |           target,
     |           arg_count: args.length(),
     |           is_return: false,
     |         })
     |       TReturnCall(target, args) =>
 454 |         out.push({
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |           node_id: id,
     |           target,
 457 |           arg_count: args.length(),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           is_return: true,
     |         })
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   out
     | }
     …

     | fn msf_collect_sites(
     |   body : TExpr,
     |   type_idxs : Array[TypeIdx],
     | ) -> Map[Int, MSFSiteValue] {
     |   let out : Map[Int, MSFSiteValue] = Map::new()
     |   let mut next_id = 0
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let id = next_id
     |     next_id += 1
     |     match instr {
     |       TI32Const(_)
     |       | TI64Const(_)
     |       | TF32Const(_)
     |       | TF64Const(_)
     |       | TRefNull(_)
     |       | TRefFunc(_)
     |       | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
     |         match msf_const_type(instr) {
     |           Some(vt) => out[id] = ConstSite(instr, vt)
 488 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       TCall(target, _) | TReturnCall(target, _) => {
     |         let is_return = match instr {
 492 |           TReturnCall(_, _) => true
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => false
     |         }
     |         let abs_idx = msf_func_idx_to_int(target)
     |         if abs_idx >= 0 && abs_idx < type_idxs.length() {
     |           out[id] = CallTargetSite(target, type_idxs[abs_idx], is_return)
     |         }
     |       }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   out
     | }
     …

     | fn msf_collect_defined_funcs(
     |   mod : Module,
     |   func_types : Array[FuncType],
     |   func_type_idxs : Array[TypeIdx],
     |   import_count : Int,
     | ) -> Array[MSFDefinedFunc] {
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items
 517 |     None => return []
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let out : Array[MSFDefinedFunc] = []
     |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
     |     let abs_idx = import_count + def_idx
     |     if abs_idx < 0 ||
     |       abs_idx >= func_types.length() ||
     |       abs_idx >= func_type_idxs.length() {
 525 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match funcs[def_idx] {
     |       TFunc(locals, body) =>
     |         out.push({
     |           def_idx,
     |           abs_idx,
     |           type_idx: func_type_idxs[abs_idx],
     |           func_type: func_types[abs_idx],
     |           locals: locals.copy(),
     |           body,
     |           hash: hash_function_ignoring_consts(funcs[def_idx]),
     |         })
 538 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn msf_same_callee_type(
     |   lhs_target : FuncIdx,
     |   rhs_target : FuncIdx,
     |   func_type_idxs : Array[TypeIdx],
     |   func_types : Array[FuncType],
     | ) -> Bool {
     |   let lhs_abs = msf_func_idx_to_int(lhs_target)
     |   let rhs_abs = msf_func_idx_to_int(rhs_target)
     |   if lhs_abs < 0 || rhs_abs < 0 {
 554 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if lhs_abs >= func_type_idxs.length() || rhs_abs >= func_type_idxs.length() {
 557 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if lhs_abs >= func_types.length() || rhs_abs >= func_types.length() {
 560 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   func_type_idxs[lhs_abs] == func_type_idxs[rhs_abs] &&
     |   func_types[lhs_abs] == func_types[rhs_abs]
     | }
     …

     | fn are_in_equivalent_class(
     |   lhs : MSFDefinedFunc,
     |   rhs : MSFDefinedFunc,
     |   mod : Module,
     | ) -> Bool {
     |   if lhs.type_idx != rhs.type_idx {
 573 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if lhs.locals.length() != rhs.locals.length() {
 576 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_type_idxs = msf_collect_func_type_indices(mod)
     |   let func_types = msf_collect_func_types(mod)
     |   let lhs_norm = match msf_normalize_body(lhs.body) {
     |     Ok(x) => x
 582 |     Err(_) => return false
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let rhs_norm = match msf_normalize_body(rhs.body) {
     |     Ok(x) => x
 586 |     Err(_) => return false
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if lhs_norm != rhs_norm {
 589 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let lhs_calls = msf_collect_call_sites(lhs.body)
     |   let rhs_calls = msf_collect_call_sites(rhs.body)
     |   if lhs_calls.length() != rhs_calls.length() {
 594 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for i = 0; i < lhs_calls.length(); i = i + 1 {
     |     let lc = lhs_calls[i]
     |     let rc = rhs_calls[i]
     |     if lc.node_id != rc.node_id ||
     |       lc.arg_count != rc.arg_count ||
     |       lc.is_return != rc.is_return {
 602 |       return false
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if !msf_same_callee_type(lc.target, rc.target, func_type_idxs, func_types) {
     |       return false
     |     }
     |   }
     |   true
     | }
     …

     | fn msf_sort_class_members(
     |   members : Array[Int],
     |   import_count : Int,
     | ) -> Array[Int] {
     |   let out = members.copy()
     |   out.sort_by(fn(a, b) {
     |     let aa = a + import_count
     |     let bb = b + import_count
     |     if aa < bb {
     |       -1
 622 |     } else if aa > bb {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       1
     |     } else {
 625 |       0
     |       ^ 	<-- UNCOVERED
     |     }
     |   })
     |   out
     | }
     …

     | fn collect_equivalent_classes(mod : Module) -> Array[EquivalentClass] {
     |   let import_count = msf_count_imported_funcs(mod)
     |   let func_types = msf_collect_func_types(mod)
     |   let func_type_idxs = msf_collect_func_type_indices(mod)
     |   let defined = msf_collect_defined_funcs(
     |     mod, func_types, func_type_idxs, import_count,
     |   )
     |   let buckets : Map[MSFHashBucketKey, Array[Int]] = Map::new()
     |   for func in defined {
     |     let key = {
     |       type_idx: func.type_idx,
     |       local_count: func.locals.length(),
     |       hash: func.hash,
     |     }
     |     let items = buckets.get(key).unwrap_or([])
     |     let next = items.copy()
     |     next.push(func.def_idx)
     |     buckets[key] = next
     |   }
     |   let by_def_idx : Map[Int, MSFDefinedFunc] = Map::new()
     |   for func in defined {
     |     by_def_idx[func.def_idx] = func
     |   }
     |   let classes : Array[EquivalentClass] = []
     |   for entry in buckets {
     |     let (key, members) = entry
     |     if members.length() < 2 {
     |       continue
     |     }
     |     let sorted_members = msf_sort_class_members(members, import_count)
     |     let partitions : Array[Array[Int]] = []
     |     for def_idx in sorted_members {
     |       let candidate = by_def_idx.get(def_idx).unwrap()
     |       let mut placed = false
     |       for part in partitions {
     |         let rep_idx = part[0]
     |         let rep = by_def_idx.get(rep_idx).unwrap()
     |         if are_in_equivalent_class(candidate, rep, mod) {
     |           part.push(def_idx)
     |           placed = true
     |           break
     |         }
     |       }
     |       if !placed {
     |         partitions.push([def_idx])
     |       }
     |     }
     |     for part in partitions {
     |       if part.length() < 2 {
     |         continue
     |       }
     |       let sorted_part = msf_sort_class_members(part, import_count)
     |       classes.push({
     |         type_idx: key.type_idx,
     |         member_def_idxs: sorted_part,
     |         primary_def_idx: sorted_part[0],
     |       })
     |     }
     |   }
     |   classes.sort_by(fn(a, b) {
     |     let aa = a.primary_def_idx + import_count
     |     let bb = b.primary_def_idx + import_count
     |     if aa < bb {
     |       -1
 696 |     } else if aa > bb {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       1
     |     } else {
 699 |       0
     |       ^ 	<-- UNCOVERED
     |     }
     |   })
     |   classes
     | }
     …

     | fn msf_same_all_consts(values : Array[TInstr]) -> Bool {
     |   if values.length() <= 1 {
 708 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let first = values[0]
     |   for i = 1; i < values.length(); i = i + 1 {
     |     if values[i] != first {
     |       return false
     |     }
     |   }
     |   true
     | }
     …

     | fn msf_same_all_targets(values : Array[FuncIdx]) -> Bool {
     |   if values.length() <= 1 {
 722 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let first = values[0]
     |   for i = 1; i < values.length(); i = i + 1 {
     |     if values[i] != first {
     |       return false
     |     }
     |   }
     |   true
     | }
     …

     | fn derive_params(clazz : EquivalentClass, mod : Module) -> Array[ParamInfo]? {
     |   let CodeSec(funcs) = match mod.code_sec {
     |     Some(sec) => sec
 737 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_count = msf_count_imported_funcs(mod)
     |   let func_type_idxs = msf_collect_func_type_indices(mod)
     |   let mut primary_body : TExpr? = None
     |   let mut primary_param_count = 0
     |   for i = 0; i < clazz.member_def_idxs.length(); i = i + 1 {
     |     let def_idx = clazz.member_def_idxs[i]
     |     if def_idx < 0 || def_idx >= funcs.length() {
 746 |       return None
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let abs_idx = import_count + def_idx
     |     if abs_idx < 0 || abs_idx >= func_type_idxs.length() {
 750 |       return None
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match funcs[def_idx] {
     |       TFunc(_, body) =>
     |         if def_idx == clazz.primary_def_idx {
     |           primary_body = Some(body)
     |           let FuncType(params, _) = match
     |             msf_collect_func_types(mod).get(abs_idx) {
     |             Some(ft) => ft
 759 |             None => return None
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           primary_param_count = params.length()
     |         }
 763 |       _ => return None
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   let primary_body = match primary_body {
     |     Some(x) => x
 768 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let site_maps : Array[Map[Int, MSFSiteValue]] = []
     |   for def_idx in clazz.member_def_idxs {
     |     match funcs[def_idx] {
     |       TFunc(_, body) => site_maps.push(msf_collect_sites(body, func_type_idxs))
 774 |       _ => return None
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   let primary_sites = msf_collect_sites(primary_body, func_type_idxs)
     |   let ordered_site_ids : Array[Int] = []
     |   for entry in primary_sites {
     |     let (node_id, _) = entry
     |     ordered_site_ids.push(node_id)
     |   }
     |   ordered_site_ids.sort_by(fn(a, b) {
     |     if a < b {
     |       -1
 786 |     } else if a > b {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       1
     |     } else {
 789 |       0
     |       ^ 	<-- UNCOVERED
     |     }
     |   })
     |   let params : Array[ParamInfo] = []
     |   let key_to_idx : Map[MSFParamKey, Int] = Map::new()
     |   for node_id in ordered_site_ids {
     |     let primary_site = match primary_sites.get(node_id) {
     |       Some(v) => v
 797 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match primary_site {
     |       ConstSite(_, vt) => {
     |         let values : Array[TInstr] = []
     |         for sites in site_maps {
     |           match sites.get(node_id) {
     |             Some(ConstSite(v, site_vt)) => {
     |               if site_vt != vt {
 806 |                 return None
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               values.push(v)
     |             }
 810 |             _ => return None
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         if msf_same_all_consts(values) {
     |           continue
     |         }
     |         let key = ConstParamKey(vt, values)
     |         match key_to_idx.get(key) {
     |           Some(idx) => params[idx].uses.push(node_id)
     |           None => {
     |             let idx = params.length()
     |             key_to_idx[key] = idx
     |             params.push({ kind: LiteralParam(vt, values), uses: [node_id] })
     |           }
     |         }
     |       }
     |       CallTargetSite(_, type_idx, is_return) => {
     |         ignore(is_return)
     |         let values : Array[FuncIdx] = []
     |         for sites in site_maps {
     |           match sites.get(node_id) {
     |             Some(CallTargetSite(target, site_type_idx, _)) => {
     |               if site_type_idx != type_idx {
 833 |                 return None
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               values.push(target)
     |             }
 837 |             _ => return None
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         if msf_same_all_targets(values) {
 841 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let key = CallParamKey(type_idx, values)
     |         match key_to_idx.get(key) {
 845 |           Some(idx) => params[idx].uses.push(node_id)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => {
     |             let idx = params.length()
     |             key_to_idx[key] = idx
     |             params.push({
     |               kind: CallTargetParam(type_idx, values),
     |               uses: [node_id],
     |             })
     |           }
     |         }
     |       }
     |     }
     |   }
     |   if primary_param_count + params.length() > MSF_MAX_SYNTHETIC_FUNCTION_PARAMS {
     |     return None
     |   }
     |   Some(params)
     | }
     …

     | fn has_merge_benefit(
     |   clazz : EquivalentClass,
     |   mod : Module,
     |   params : Array[ParamInfo],
     | ) -> Bool {
     |   let CodeSec(funcs) = match mod.code_sec {
     |     Some(sec) => sec
 883 |     None => return false
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if clazz.member_def_idxs.length() < 2 {
 886 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_count = msf_count_imported_funcs(mod)
     |   let func_types = msf_collect_func_types(mod)
     |   let primary_def = clazz.primary_def_idx
     |   if primary_def < 0 || primary_def >= funcs.length() {
 892 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let primary_abs = import_count + primary_def
     |   if primary_abs < 0 || primary_abs >= func_types.length() {
 896 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FuncType(primary_params, _) = func_types[primary_abs]
     |   let primary_body = match funcs[primary_def] {
     |     TFunc(_, body) => body
 901 |     _ => return false
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let removed = (clazz.member_def_idxs.length() - 1) *
     |     msf_measure_body(primary_body)
     |   let added_per_thunk = 1 + primary_params.length() + params.length()
     |   let added = (clazz.member_def_idxs.length() - 1) * added_per_thunk +
     |     params.length()
     |   removed > added
     | }
     …

     | fn msf_rewrite_shared_body(
     |   body : TExpr,
     |   primary_param_count : Int,
     |   params : Array[ParamInfo],
     | ) -> Result[TExpr, String] {
     |   let node_to_param : Map[Int, Int] = Map::new()
     |   for param_idx = 0; param_idx < params.length(); param_idx = param_idx + 1 {
     |     for use_id in params[param_idx].uses {
     |       node_to_param[use_id] = param_idx
     |     }
     |   }
     |   let mut next_id = 0
     |   let shift = params.length()
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let node_id = next_id
     |     next_id += 1
     |     let walked = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, next))) => next
     |       Ok(None) => instr
 939 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let shifted = match walked {
     |       TLocalGet(idx) => {
     |         let raw = msf_local_idx_to_int(idx)
     |         if raw >= primary_param_count {
     |           TInstr::local_get(msf_local_idx_from_int(raw + shift))
     |         } else {
     |           walked
     |         }
     |       }
     |       TLocalSet(idx, value) => {
     |         let raw = msf_local_idx_to_int(idx)
     |         if raw >= primary_param_count {
     |           TInstr::local_set(msf_local_idx_from_int(raw + shift), value)
     |         } else {
 955 |           walked
     |           ^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 958 |       TLocalTee(idx, value) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let raw = msf_local_idx_to_int(idx)
     |         if raw >= primary_param_count {
 961 |           TInstr::local_tee(msf_local_idx_from_int(raw + shift), value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
 963 |           walked
     |           ^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => walked
     |     }
     |     let replaced = match node_to_param.get(node_id) {
     |       Some(param_idx) => {
     |         let replacement_local = msf_param_local_index(
     |           primary_param_count, param_idx,
     |         )
     |         match (shifted, params[param_idx].kind) {
     |           (TI32Const(_), LiteralParam(_, _))
     |           | (TI64Const(_), LiteralParam(_, _))
     |           | (TF32Const(_), LiteralParam(_, _))
     |           | (TF64Const(_), LiteralParam(_, _))
     |           | (TRefNull(_), LiteralParam(_, _))
     |           | (TRefFunc(_), LiteralParam(_, _))
     |           | (
     |             TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _),
     |             LiteralParam(_, _),
     |           ) => TInstr::local_get(replacement_local)
     |           (TCall(_, args), CallTargetParam(type_idx, _)) => {
     |             let casted = TInstr::ref_cast(
     |               true,
     |               HeapType::new(type_idx),
     |               TInstr::local_get(replacement_local),
     |             )
     |             TInstr::call_ref(type_idx, args, casted)
     |           }
 992 |           (TReturnCall(_, args), CallTargetParam(type_idx, _)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let casted = TInstr::ref_cast(
     |               true,
 995 |               HeapType::new(type_idx),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::local_get(replacement_local),
     |             )
 998 |             TInstr::return_call_ref(type_idx, args, casted)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1000 |           _ => shifted
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       None => shifted
     |     }
     |     if replaced == instr {
     |       unchanged()
     |     } else {
     |       change((), replaced)
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
     |     Ok(Some((_, out))) => Ok(out)
1013 |     Ok(None) => Ok(body)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn msf_append_func_type(
     |   mod : Module,
     |   params : Array[ValType],
     |   results : Array[ValType],
     | ) -> (Module, TypeIdx) {
     |   let recs = match mod.type_sec {
     |     Some(TypeSec(items)) => items.copy()
1038 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   recs.push(msf_make_func_type(params, results))
     |   let new_idx = TypeIdx::new((recs.length() - 1).reinterpret_as_uint())
     |   (mod.with_type_sec(TypeSec::new(recs)), new_idx)
     | }
     …

     | fn create_shared(
     |   clazz : EquivalentClass,
     |   mod : Module,
     |   params : Array[ParamInfo],
     | ) -> Result[(Module, FuncIdx), String] {
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items.copy()
1053 |     None => return Err("merge_similar_functions: missing code section")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let type_idxs = match mod.func_sec {
     |     Some(FuncSec(items)) => items.copy()
1057 |     None => return Err("merge_similar_functions: missing func section")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_count = msf_count_imported_funcs(mod)
     |   let func_types = msf_collect_func_types(mod)
     |   let primary_def = clazz.primary_def_idx
     |   if primary_def < 0 || primary_def >= funcs.length() {
1063 |     return Err("merge_similar_functions: primary function out of range")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let primary_abs = import_count + primary_def
     |   if primary_abs < 0 || primary_abs >= func_types.length() {
1067 |     return Err("merge_similar_functions: primary abs function out of range")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (primary_locals, primary_body) = match funcs[primary_def] {
     |     TFunc(locals, body) => (locals.copy(), body)
1071 |     _ => return Err("merge_similar_functions: primary function is not TFunc")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FuncType(primary_params, primary_results) = func_types[primary_abs]
     |   let rewritten_body = match
     |     msf_rewrite_shared_body(primary_body, primary_params.length(), params) {
     |     Ok(x) => x
1077 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let added_param_types = msf_collect_param_types(params)
     |   let shared_param_types = primary_params.copy()
     |   for vt in added_param_types {
     |     shared_param_types.push(vt)
     |   }
     |   let (with_type, shared_type_idx) = msf_append_func_type(
     |     mod, shared_param_types, primary_results,
     |   )
     |   let next_type_idxs = type_idxs
     |   let next_funcs = funcs
     |   next_type_idxs.push(shared_type_idx)
     |   let shared_func = Func::t_func(primary_locals, rewritten_body)
     |   next_funcs.push(shared_func)
     |   let next_mod = with_type
     |     .with_func_sec(FuncSec::new(next_type_idxs))
     |     .with_code_sec(CodeSec::new(next_funcs))
     |   let shared_abs = import_count + (next_funcs.length() - 1)
     |   Ok((next_mod, msf_func_idx_from_int(shared_abs)))
     | }
     …

     | fn msf_param_value_for_member(param : ParamInfo, member_idx : Int) -> TInstr? {
     |   match param.kind {
     |     LiteralParam(_, values) => values.get(member_idx)
     |     CallTargetParam(_, targets) =>
     |       match targets.get(member_idx) {
     |         Some(target) => Some(TInstr::ref_func(target))
1106 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn replace_with_thunk(
     |   target : Func,
     |   shared : FuncIdx,
     |   params : Array[ParamInfo],
     |   values_for_target : Array[TInstr],
     | ) -> Func {
     |   match target {
     |     TFunc(_, _) => {
     |       let param_count = values_for_target.length() - params.length()
     |       let args : Array[TInstr] = []
     |       for i = 0; i < param_count; i = i + 1 {
     |         args.push(values_for_target[i])
     |       }
     |       for i = 0; i < params.length(); i = i + 1 {
     |         args.push(values_for_target[param_count + i])
     |       }
     |       let body = TExpr::new([TInstr::return_call(shared, args)])
     |       Func::t_func([], body)
     |     }
1131 |     _ => target
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn msf_build_thunk_values(
     |   param_count : Int,
     |   params : Array[ParamInfo],
     |   member_idx : Int,
     | ) -> Array[TInstr]? {
     |   let out : Array[TInstr] = []
     |   for i = 0; i < param_count; i = i + 1 {
     |     out.push(TInstr::local_get(msf_local_idx_from_int(i)))
     |   }
     |   for param in params {
     |     match msf_param_value_for_member(param, member_idx) {
     |       Some(v) => out.push(v)
1148 |       None => return None
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Some(out)
     | }
     …

     | fn msf_apply_class(
     |   mod : Module,
     |   clazz : EquivalentClass,
     |   params : Array[ParamInfo],
     | ) -> Result[Module, String] {
     |   let import_count = msf_count_imported_funcs(mod)
     |   let func_types = msf_collect_func_types(mod)
     |   let primary_abs = import_count + clazz.primary_def_idx
     |   if primary_abs < 0 || primary_abs >= func_types.length() {
1164 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let FuncType(primary_params, _) = func_types[primary_abs]
     |   let (mod, shared_idx) = match create_shared(clazz, mod, params) {
     |     Ok(v) => v
1169 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let next_funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items.copy()
1173 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for member_idx = 0
     |       member_idx < clazz.member_def_idxs.length()
     |       member_idx = member_idx + 1 {
     |     let def_idx = clazz.member_def_idxs[member_idx]
     |     if def_idx < 0 || def_idx >= next_funcs.length() {
1180 |       return Err("merge_similar_functions: class member out of range")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let values = match
     |       msf_build_thunk_values(primary_params.length(), params, member_idx) {
     |       Some(v) => v
1185 |       None => return Err("merge_similar_functions: missing thunk values")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let thunk = replace_with_thunk(
     |       next_funcs[def_idx],
     |       shared_idx,
     |       params,
     |       values,
     |     )
     |     next_funcs[def_idx] = thunk
     |   }
     |   Ok(mod.with_code_sec(CodeSec::new(next_funcs)))
     | }
     …

     | fn run(mod : Module) -> Result[Module, String] {
     |   let classes = collect_equivalent_classes(mod)
     |   if classes.is_empty() {
     |     return Ok(mod)
     |   }
     |   let mut mod = mod
     |   for clazz in classes {
     |     let params = match derive_params(clazz, mod) {
     |       Some(p) => p
     |       None => continue
     |     }
     |     if params.is_empty() {
1211 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let func_types = msf_collect_func_types(mod)
     |     let import_count = msf_count_imported_funcs(mod)
     |     let primary_abs = import_count + clazz.primary_def_idx
     |     if primary_abs < 0 || primary_abs >= func_types.length() {
1217 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let FuncType(primary_params, _) = func_types[primary_abs]
     |     if primary_params.length() + params.length() >
     |       MSF_MAX_SYNTHETIC_FUNCTION_PARAMS {
1222 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if !has_merge_benefit(clazz, mod, params) {
     |       continue
     |     }
     |     mod = match msf_apply_class(mod, clazz, params) {
     |       Ok(next) => next
1229 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(mod)
     | }
     …

     | fn msf_run(mod : Module) -> Module {
     |   match merge_similar_functions(mod) {
     |     Ok(out) => out
1244 |     Err(_) => mod
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn msf_shared_abs_index(mod : Module) -> Int {
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(items)) => items
1283 |     None => return -1
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_count = msf_count_imported_funcs(mod)
     |   import_count + funcs.length() - 1
     | }
     …

     | fn msf_is_forwarder(func : Func, target_abs : Int, arg_count : Int) -> Bool {
     |   match func {
     |     TFunc(locals, TExpr([TReturnCall(FuncIdx(raw), args)])) =>
     |       locals.length() == 0 &&
     |       raw.reinterpret_as_int() == target_abs &&
     |       args.length() == arg_count
1296 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

194 uncovered line(s) in src/passes/minimize_rec_groups.mbt:

     | fn mrg_collect_valtype_refs(
     |   out : Array[Int],
     |   vt : ValType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Unit {
     |   match vt {
     |     RefTypeValType(rt) =>
     |       match rt {
     |         HeapTypeRefType(_, ht) =>
     |           match ht {
     |             HeapType(type_idx) =>
     |               match mrg_resolve_type_idx(type_idx, group_start, total) {
     |                 Some(idx) => out.push(idx)
     |                 None => ()
     |               }
 150 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn mrg_collect_subtype_refs(
     |   subtype : SubType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Array[Int] {
     |   let out : Array[Int] = []
     |   for super_idx in subtype.super_types() {
     |     match mrg_resolve_type_idx(super_idx, group_start, total) {
     |       Some(idx) => out.push(idx)
     |       None => ()
     |     }
     |   }
     |   match subtype.get_comptype() {
     |     FuncCompType(params, results) => {
     |       for p in params {
 188 |         mrg_collect_valtype_refs(out, p, group_start, total)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for r in results {
 191 |         mrg_collect_valtype_refs(out, r, group_start, total)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructCompType(fields) =>
     |       for field in fields {
     |         let FieldType(st, _) = field
     |         mrg_collect_storage_type_refs(out, st, group_start, total)
     |       }
     |     ArrayCompType(field) => {
     |       let FieldType(st, _) = field
     |       mrg_collect_storage_type_refs(out, st, group_start, total)
     |     }
     |   }
     |   out
     | }
     …

     | fn mrg_collect_func_type_idx_by_func(mod : Module) -> Map[FuncIdx, TypeIdx] {
     |   let out : Map[FuncIdx, TypeIdx] = Map::new()
     |   let mut next : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) => {
     |             out[FuncIdx::new(next)] = type_idx
     |             next += 1
     |           }
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out[FuncIdx::new(next)] = type_idx
     |         next += 1
     |       }
 279 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn mrg_mark_public_reftype(
     |   public_types : Set[Int],
     |   flat : MRGFlatTypes,
     |   rt : RefType,
     | ) -> Unit {
     |   match rt {
     |     HeapTypeRefType(_, ht) =>
     |       match ht {
     |         HeapType(type_idx) =>
     |           match mrg_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             Some(idx) => mrg_mark_public_type(public_types, flat, idx)
 367 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 369 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn mrg_mark_public_type(
     |   public_types : Set[Int],
     |   flat : MRGFlatTypes,
     |   start_idx : Int,
     | ) -> Unit {
     |   let stack : Array[Int] = [start_idx]
     |   while stack.length() > 0 {
     |     let curr = stack.pop().unwrap()
     |     if curr < 0 || curr >= flat.subtypes.length() || public_types.contains(curr) {
 397 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     public_types.add(curr)
     |     let subtype = flat.subtypes[curr]
     |     for super_idx in subtype.super_types() {
 402 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         mrg_resolve_type_idx(
     |           super_idx,
     |           flat.group_starts[curr],
 406 |           flat.subtypes.length(),
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ) {
 408 |         Some(next_idx) => stack.push(next_idx)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => ()
     |       }
     |     }
     |     match subtype.get_comptype() {
 413 |       FuncCompType(params, results) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for p in params {
 415 |           match p {
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             RefTypeValType(rt) =>
 417 |               match rt {
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |                 HeapTypeRefType(_, ht) =>
 419 |                   match ht {
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                     HeapType(type_idx) =>
 421 |                       match
     |                       ^^^^^ 	<-- UNCOVERED
     |                         mrg_resolve_type_idx(
     |                           type_idx,
     |                           flat.group_starts[curr],
 425 |                           flat.subtypes.length(),
     |                           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         ) {
 427 |                         Some(next_idx) => stack.push(next_idx)
     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         None => ()
     |                       }
 430 |                     _ => ()
     |                     ^^^^^^^ 	<-- UNCOVERED
     |                   }
 432 |                 _ => ()
     |                 ^^^^^^^ 	<-- UNCOVERED
     |               }
 434 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         for r in results {
 438 |           match r {
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |             RefTypeValType(rt) =>
 440 |               match rt {
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |                 HeapTypeRefType(_, ht) =>
 442 |                   match ht {
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                     HeapType(type_idx) =>
 444 |                       match
     |                       ^^^^^ 	<-- UNCOVERED
     |                         mrg_resolve_type_idx(
     |                           type_idx,
     |                           flat.group_starts[curr],
 448 |                           flat.subtypes.length(),
     |                           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         ) {
 450 |                         Some(next_idx) => stack.push(next_idx)
     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         None => ()
     |                       }
 453 |                     _ => ()
     |                     ^^^^^^^ 	<-- UNCOVERED
     |                   }
 455 |                 _ => ()
     |                 ^^^^^^^ 	<-- UNCOVERED
     |               }
 457 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |       StructCompType(fields) =>
     |         for field in fields {
     |           let FieldType(st, _) = field
     |           match st {
     |             ValTypeStorageType(vt) =>
     |               match vt {
     |                 RefTypeValType(rt) =>
 468 |                   match rt {
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                     HeapTypeRefType(_, ht) =>
 470 |                       match ht {
     |                       ^^^^^^^^^^ 	<-- UNCOVERED
     |                         HeapType(type_idx) =>
 472 |                           match
     |                           ^^^^^ 	<-- UNCOVERED
     |                             mrg_resolve_type_idx(
     |                               type_idx,
     |                               flat.group_starts[curr],
 476 |                               flat.subtypes.length(),
     |                               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                             ) {
 478 |                             Some(next_idx) => stack.push(next_idx)
     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                             None => ()
     |                           }
 481 |                         _ => ()
     |                         ^^^^^^^ 	<-- UNCOVERED
     |                       }
 483 |                     _ => ()
     |                     ^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 _ => ()
     |               }
 487 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
 490 |       ArrayCompType(field) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let FieldType(st, _) = field
 492 |         match st {
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |           ValTypeStorageType(vt) =>
 494 |             match vt {
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |               RefTypeValType(rt) =>
 496 |                 match rt {
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |                   HeapTypeRefType(_, ht) =>
 498 |                     match ht {
     |                     ^^^^^^^^^^ 	<-- UNCOVERED
     |                       HeapType(type_idx) =>
 500 |                         match
     |                         ^^^^^ 	<-- UNCOVERED
     |                           mrg_resolve_type_idx(
     |                             type_idx,
     |                             flat.group_starts[curr],
 504 |                             flat.subtypes.length(),
     |                             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           ) {
 506 |                           Some(next_idx) => stack.push(next_idx)
     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           None => ()
     |                         }
 509 |                       _ => ()
     |                       ^^^^^^^ 	<-- UNCOVERED
     |                     }
 511 |                   _ => ()
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                 }
 513 |               _ => ()
     |               ^^^^^^^ 	<-- UNCOVERED
     |             }
 515 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn collect_heap_type_info(mod : Module) -> MRGHeapTypeInfo {
     |   let type_sec = match mod.type_sec {
     |     Some(type_sec) => type_sec
 526 |     None => {
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |       let flat : MRGFlatTypes = {
     |         subtypes: [],
     |         group_starts: [],
     |         groups: [],
     |         type_to_group: [],
     |       }
     |       return {
     |         flat,
     |         private_types: [],
 536 |         public_types: Set::new(),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         public_groups: [],
 538 |         visibility_map: Map::new(),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   let flat = mrg_flatten_types(type_sec)
     |   let public_types : Set[Int] = Set::new()
     |   let func_types = mrg_collect_func_type_idx_by_func(mod)
     |   let global_types = mrg_collect_all_global_types(mod)
     |   let table_types = mrg_collect_all_table_types(mod)
     |   let tag_types = mrg_collect_all_tag_types(mod)
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 550 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) =>
 553 |             match mrg_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(idx) => mrg_mark_public_type(public_types, flat, idx)
     |               None => ()
     |             }
     |           Import(_, _, TagExternType(TagType(type_idx))) =>
 558 |             match mrg_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(idx) => mrg_mark_public_type(public_types, flat, idx)
     |               None => ()
     |             }
     |           Import(_, _, GlobalExternType(GlobalType(vt, _))) =>
 563 |             mrg_mark_public_valtype(public_types, flat, vt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Import(_, _, TableExternType(TableType(rt, _))) =>
 565 |             mrg_mark_public_reftype(public_types, flat, rt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         let Export(_, extern_idx) = export_
     |         match extern_idx {
     |           FuncExternIdx(func_idx) =>
 577 |             match func_types.get(func_idx) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(type_idx) =>
 579 |                 match
     |                 ^^^^^ 	<-- UNCOVERED
     |                   mrg_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |                   Some(idx) => mrg_mark_public_type(public_types, flat, idx)
     |                   None => ()
     |                 }
 584 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           GlobalExternIdx(GlobalIdx(raw)) => {
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < global_types.length() {
     |               let GlobalType(vt, _) = global_types[idx]
     |               mrg_mark_public_valtype(public_types, flat, vt)
     |             }
     |           }
 593 |           TableExternIdx(TableIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < table_types.length() {
 596 |               let TableType(rt, _) = table_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               mrg_mark_public_reftype(public_types, flat, rt)
     |             }
     |           }
 600 |           TagExternIdx(TagIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < tag_types.length() {
 603 |               let TagType(type_idx) = tag_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match mrg_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |                 Some(type_i) => mrg_mark_public_type(public_types, flat, type_i)
     |                 None => ()
     |               }
     |             }
     |           }
 610 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   // If a group is public-facing, keep every type in it immutable to preserve group shape.
     |   let initially_public : Array[Int] = []
     |   for idx in public_types {
     |     initially_public.push(idx)
     |   }
     |   for idx in initially_public {
     |     let g = flat.type_to_group[idx]
     |     for t in flat.groups[g] {
     |       public_types.add(t)
     |     }
     |   }
     |   let visibility_map : Map[Int, Bool] = Map::new()
     |   let private_types : Array[Int] = []
     |   for i in 0..<flat.subtypes.length() {
     |     let private = !public_types.contains(i)
     |     visibility_map[i] = private
     |     if private {
     |       private_types.push(i)
     |     }
     |   }
     |   let public_groups : Array[Int] = []
     |   for gi in 0..<flat.groups.length() {
     |     let mut is_public_group = false
     |     for idx in flat.groups[gi] {
     |       if public_types.contains(idx) {
     |         is_public_group = true
     |         break
     |       }
     |     }
     |     if is_public_group {
     |       public_groups.push(gi)
     |     }
     |   }
     |   {
     |     flat,
     |     private_types: mrg_unique_sorted(private_types),
     |     public_types,
     |     public_groups,
     |     visibility_map,
     |   }
     | }
     …

     | fn compute_sccs(
     |   private_types : Array[Int],
     |   adjacency : Map[Int, Array[Int]],
     | ) -> Array[Array[Int]] {
     |   if private_types.is_empty() {
 700 |     return []
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let nodes = mrg_unique_sorted(private_types)
     |   let visited : Set[Int] = Set::new()
     |   let order : Array[Int] = []
     |   for start in nodes {
     |     if visited.contains(start) {
     |       continue
     |     }
     |     let stack : Array[(Int, Bool)] = [(start, false)]
     |     while stack.length() > 0 {
     |       let (node, expanded) = stack.pop().unwrap()
     |       if expanded {
     |         order.push(node)
     |         continue
     |       }
     |       if visited.contains(node) {
 717 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       visited.add(node)
     |       stack.push((node, true))
     |       let nexts = adjacency.get(node).unwrap_or([])
     |       for i in 0..<nexts.length() {
     |         let next = nexts[nexts.length() - 1 - i]
     |         if !visited.contains(next) {
     |           stack.push((next, false))
     |         }
     |       }
     |     }
     |   }
     |   let rev : Map[Int, Array[Int]] = Map::new()
     |   for n in nodes {
     |     rev[n] = []
     |   }
     |   for n in nodes {
     |     for m in adjacency.get(n).unwrap_or([]) {
     |       match rev.get(m) {
     |         Some(list) => list.push(n)
 738 |         None => rev[m] = [n]
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   for n in nodes {
     |     let list = rev.get(n).unwrap_or([])
     |     rev[n] = mrg_unique_sorted(list)
     |   }
     |   let assigned : Set[Int] = Set::new()
     |   let sccs : Array[Array[Int]] = []
     |   for i in 0..<order.length() {
     |     let node = order[order.length() - 1 - i]
     |     if assigned.contains(node) {
     |       continue
     |     }
     |     let component : Array[Int] = []
     |     let stack : Array[Int] = [node]
     |     assigned.add(node)
     |     while stack.length() > 0 {
     |       let curr = stack.pop().unwrap()
     |       component.push(curr)
     |       for prev in rev.get(curr).unwrap_or([]) {
     |         if !assigned.contains(prev) {
     |           assigned.add(prev)
     |           stack.push(prev)
     |         }
     |       }
     |     }
     |     sccs.push(mrg_unique_sorted(component))
     |   }
     |   sccs
     | }
     …

     | fn mrg_add_edge_unique(
     |   adjacency : Array[Array[Int]],
     |   from : Int,
     |   to : Int,
     | ) -> Unit {
     |   if from < 0 ||
     |     from >= adjacency.length() ||
     |     to < 0 ||
     |     to >= adjacency.length() {
 781 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   for existing in adjacency[from] {
 784 |     if existing == to {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       return
     |     }
     |   }
     |   adjacency[from].push(to)
     | }
     …

     | fn create_type_order_graph(
     |   types_in_group : Array[Int],
     |   flat : MRGFlatTypes,
     | ) -> Array[Array[Int]] {
     |   let adjacency : Array[Array[Int]] = []
     |   let pos_by_type : Map[Int, Int] = Map::new()
     |   for i in 0..<types_in_group.length() {
     |     adjacency.push([])
     |     pos_by_type[types_in_group[i]] = i
     |   }
     |   for i in 0..<types_in_group.length() {
     |     let t = types_in_group[i]
     |     let subtype = flat.subtypes[t]
     |     for super_idx in subtype.super_types() {
     |       match
     |         mrg_resolve_type_idx(
     |           super_idx,
     |           flat.group_starts[t],
     |           flat.subtypes.length(),
     |         ) {
     |         Some(super_abs) =>
     |           match pos_by_type.get(super_abs) {
     |             Some(super_pos) => mrg_add_edge_unique(adjacency, super_pos, i)
 815 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 817 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   for row in adjacency {
     |     row.sort()
     |   }
     |   adjacency
     | }
     …

     | fn mrg_all_topological_orders(
     |   types_in_group : Array[Int],
     |   adjacency : Array[Array[Int]],
     | ) -> Array[Array[Int]] {
     |   let n = types_in_group.length()
     |   if n == 0 {
 834 |     return []
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let indegree = Array::make(n, 0)
     |   for i in 0..<n {
     |     for to in adjacency[i] {
     |       indegree[to] = indegree[to] + 1
     |     }
     |   }
     |   let used = Array::make(n, false)
     |   let current : Array[Int] = []
     |   let out : Array[Array[Int]] = []
     |   fn dfs(
     |     types_in_group : Array[Int],
     |     adjacency : Array[Array[Int]],
     |     indegree : Array[Int],
     |     used : Array[Bool],
     |     current : Array[Int],
     |     out : Array[Array[Int]],
     |   ) -> Unit {
     |     if out.length() >= mrg_max_topo_orders {
 854 |       return
     |       ^^^^^^ 	<-- UNCOVERED
     |     }
     |     let n = types_in_group.length()
     |     if current.length() == n {
     |       let order : Array[Int] = []
     |       for pos in current {
     |         order.push(types_in_group[pos])
     |       }
     |       out.push(order)
     |       return
     |     }
     |     let candidates : Array[Int] = []
     |     for i in 0..<n {
     |       if !used[i] && indegree[i] == 0 {
     |         candidates.push(i)
     |       }
     |     }
     |     candidates.sort_by(fn(a, b) { types_in_group[a].compare(types_in_group[b]) })
     |     for c in candidates {
     |       used[c] = true
     |       current.push(c)
     |       for to in adjacency[c] {
 876 |         indegree[to] = indegree[to] - 1
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       dfs(types_in_group, adjacency, indegree, used, current, out)
     |       for to in adjacency[c] {
 880 |         indegree[to] = indegree[to] + 1
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       ignore(current.pop())
     |       used[c] = false
     |       if out.length() >= mrg_max_topo_orders {
 885 |         return
     |         ^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | 
     |   dfs(types_in_group, adjacency, indegree, used, current, out)
     |   if out.is_empty() {
     |     return [types_in_group.copy()]
     |   }
     |   out
     | }
     …

     | fn topo_sort_group(
     |   types_in_group : Array[Int],
     |   adjacency : Array[Array[Int]],
     | ) -> Array[Int] {
     |   let orders = mrg_all_topological_orders(types_in_group, adjacency)
     |   if orders.is_empty() {
 904 |     let out = types_in_group.copy()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     out.sort()
     |     return out
     |   }
     |   orders[0]
     | }
     …

     | fn mrg_abs_heap_type_code(abs : AbsHeapType) -> String {
 913 |   match abs {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     ExnAbsHeapType => "exn"
     |     ArrayAbsHeapType => "array"
     |     StructAbsHeapType => "struct"
     |     I31AbsHeapType => "i31"
     |     EqAbsHeapType => "eq"
     |     AnyAbsHeapType => "any"
     |     ExternAbsHeapType => "extern"
     |     FuncAbsHeapType => "func"
     |     NoneAbsHeapType => "none"
     |     NoExternAbsHeapType => "noextern"
     |     NoFuncAbsHeapType => "nofunc"
     |     NoExnAbsHeapType => "noexn"
     |   }
     | }
     …

     | fn mrg_shape_typeidx(type_idx : TypeIdx, type_indices : Array[Int]) -> String {
     |   match type_idx {
 932 |     TypeIdx(i) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let raw = i.reinterpret_as_int()
     |       if raw >= 0 && raw < type_indices.length() {
 935 |         "T" + type_indices[raw].to_string()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 937 |         "T" + raw.to_string()
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     RecIdx(i) => "R" + i.reinterpret_as_int().to_string()
     |   }
     | }
     …

     | fn mrg_shape_heaptype(ht : HeapType, type_indices : Array[Int]) -> String {
     |   match ht {
 947 |     AbsHeapTypeHeapType(abs) => "A(" + mrg_abs_heap_type_code(abs) + ")"
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     HeapType(type_idx) => "H(" + mrg_shape_typeidx(type_idx, type_indices) + ")"
 949 |     DefTypeHeapType(dt) => "D(" + dt.to_string() + ")"
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_shape_reftype(rt : RefType, type_indices : Array[Int]) -> String {
     |   match rt {
     |     HeapTypeRefType(nullable, ht) =>
     |       "ref(" +
     |       nullable.to_string() +
     |       "," +
     |       mrg_shape_heaptype(ht, type_indices) +
     |       ")"
 962 |     AbsHeapTypeRefType(abs) => "absref(" + mrg_abs_heap_type_code(abs) + ")"
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_shape_valtype(vt : ValType, type_indices : Array[Int]) -> String {
     |   match vt {
     |     NumTypeValType(nt) => "num(" + nt.to_string() + ")"
 970 |     VecTypeValType => "vec"
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) => mrg_shape_reftype(rt, type_indices)
 972 |     BotValType => "bot"
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_shape_storage_type(
     |   st : StorageType,
     |   type_indices : Array[Int],
     | ) -> String {
     |   match st {
     |     ValTypeStorageType(vt) => "val(" + mrg_shape_valtype(vt, type_indices) + ")"
 983 |     PackTypeStorageType(pt) => "pack(" + pt.to_string() + ")"
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_shape_subtype(st : SubType, type_indices : Array[Int]) -> String {
     |   let mut out = ""
     |   match st {
     |     SubType(final_, supers, ct) => {
     |       out = out + "sub(final=" + final_.to_string() + ";supers=["
     |       for i in 0..<supers.length() {
     |         if i > 0 {
 995 |           out = out + ","
     |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         out = out + mrg_shape_typeidx(supers[i], type_indices)
     |       }
     |       out = out + "];"
     |       match ct {
1001 |         FuncCompType(params, results) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           out = out + "func("
     |           for i in 0..<params.length() {
1004 |             if i > 0 {
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |               out = out + ","
     |             }
1007 |             out = out + mrg_shape_valtype(params[i], type_indices)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           out = out + "->"
     |           for i in 0..<results.length() {
1011 |             if i > 0 {
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |               out = out + ","
     |             }
1014 |             out = out + mrg_shape_valtype(results[i], type_indices)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           out = out + ")"
     |         }
     |         StructCompType(fields) => {
     |           out = out + "struct("
     |           for i in 0..<fields.length() {
     |             if i > 0 {
1022 |               out = out + ","
     |               ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let FieldType(storage, mut_) = fields[i]
     |             out = out +
     |               "field(" +
     |               mrg_shape_storage_type(storage, type_indices) +
     |               "," +
     |               mut_.to_string() +
     |               ")"
     |           }
     |           out = out + ")"
     |         }
1034 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
     |           out = out +
     |             "array(" +
1038 |             mrg_shape_storage_type(storage, type_indices) +
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             "," +
1040 |             mut_.to_string() +
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ")"
     |         }
     |       }
     |       out = out + ")"
     |     }
     |     CompTypeSubType(ct) => {
     |       out = out + "comp("
     |       match ct {
     |         FuncCompType(params, results) => {
     |           out = out + "func("
     |           for i in 0..<params.length() {
1052 |             if i > 0 {
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |               out = out + ","
     |             }
1055 |             out = out + mrg_shape_valtype(params[i], type_indices)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           out = out + "->"
     |           for i in 0..<results.length() {
1059 |             if i > 0 {
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |               out = out + ","
     |             }
1062 |             out = out + mrg_shape_valtype(results[i], type_indices)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           out = out + ")"
     |         }
     |         StructCompType(fields) => {
     |           out = out + "struct("
     |           for i in 0..<fields.length() {
     |             if i > 0 {
     |               out = out + ","
     |             }
     |             let FieldType(storage, mut_) = fields[i]
     |             out = out +
     |               "field(" +
     |               mrg_shape_storage_type(storage, type_indices) +
     |               "," +
     |               mut_.to_string() +
     |               ")"
     |           }
     |           out = out + ")"
     |         }
1082 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
     |           out = out +
     |             "array(" +
1086 |             mrg_shape_storage_type(storage, type_indices) +
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             "," +
1088 |             mut_.to_string() +
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ")"
     |         }
     |       }
     |       out = out + ")"
     |     }
     |   }
     |   out
     | }
     …

     | fn mrg_rewrite_typeidx_for_shape(
     |   type_idx : TypeIdx,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   type_indices : Array[Int],
     | ) -> TypeIdx {
     |   match mrg_resolve_type_idx(type_idx, group_start, total) {
     |     Some(abs_idx) =>
     |       match local_pos_by_old.get(abs_idx) {
     |         Some(pos) => TypeIdx::rec(pos.reinterpret_as_uint())
     |         None =>
1144 |           if abs_idx >= 0 && abs_idx < type_indices.length() {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TypeIdx::new(type_indices[abs_idx].reinterpret_as_uint())
     |           } else {
1147 |             TypeIdx::new(abs_idx.reinterpret_as_uint())
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
1150 |     None => type_idx
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_heaptype_for_shape(
     |   ht : HeapType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   type_indices : Array[Int],
     | ) -> HeapType {
     |   match ht {
     |     HeapType(type_idx) =>
     |       HeapType::new(
     |         mrg_rewrite_typeidx_for_shape(
     |           type_idx, group_start, total, local_pos_by_old, type_indices,
     |         ),
     |       )
1169 |     _ => ht
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_reftype_for_shape(
     |   rt : RefType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   type_indices : Array[Int],
     | ) -> RefType {
     |   match rt {
     |     HeapTypeRefType(nullable, ht) =>
     |       RefType::new(
     |         nullable,
     |         mrg_rewrite_heaptype_for_shape(
     |           ht, group_start, total, local_pos_by_old, type_indices,
     |         ),
     |       )
1189 |     _ => rt
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_storage_for_shape(
     |   st : StorageType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   type_indices : Array[Int],
     | ) -> StorageType {
     |   match st {
     |     ValTypeStorageType(vt) =>
     |       StorageType::val_type(
     |         mrg_rewrite_valtype_for_shape(
     |           vt, group_start, total, local_pos_by_old, type_indices,
     |         ),
     |       )
1227 |     _ => st
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_subtype_for_shape(
     |   subtype : SubType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   type_indices : Array[Int],
     | ) -> SubType {
     |   match subtype {
     |     SubType(is_final, supers, ct) => {
     |       let next_supers : Array[TypeIdx] = []
     |       for super_idx in supers {
     |         next_supers.push(
     |           mrg_rewrite_typeidx_for_shape(
     |             super_idx, group_start, total, local_pos_by_old, type_indices,
     |           ),
     |         )
     |       }
     |       let next_ct = match ct {
1250 |         FuncCompType(params, results) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let next_params : Array[ValType] = []
     |           let next_results : Array[ValType] = []
     |           for p in params {
1254 |             next_params.push(
     |             ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_shape(
     |                 p, group_start, total, local_pos_by_old, type_indices,
     |               ),
     |             )
     |           }
     |           for r in results {
1261 |             next_results.push(
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_shape(
     |                 r, group_start, total, local_pos_by_old, type_indices,
     |               ),
     |             )
     |           }
1267 |           CompType::func(next_params, next_results)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         StructCompType(fields) => {
     |           let next_fields : Array[FieldType] = []
     |           for field in fields {
     |             let FieldType(storage, mut_) = field
     |             next_fields.push(
     |               FieldType::new(
     |                 mrg_rewrite_storage_for_shape(
     |                   storage, group_start, total, local_pos_by_old, type_indices,
     |                 ),
     |                 mut_,
     |               ),
     |             )
     |           }
     |           CompType::struct_(next_fields)
     |         }
1284 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
1286 |           CompType::array(
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             FieldType::new(
     |               mrg_rewrite_storage_for_shape(
     |                 storage, group_start, total, local_pos_by_old, type_indices,
     |               ),
     |               mut_,
     |             ),
     |           )
     |         }
     |       }
     |       SubType::new(is_final, next_supers, next_ct)
     |     }
     |     CompTypeSubType(ct) => {
     |       let next_ct = match ct {
     |         FuncCompType(params, results) => {
     |           let next_params : Array[ValType] = []
     |           let next_results : Array[ValType] = []
     |           for p in params {
1304 |             next_params.push(
     |             ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_shape(
     |                 p, group_start, total, local_pos_by_old, type_indices,
     |               ),
     |             )
     |           }
     |           for r in results {
1311 |             next_results.push(
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_shape(
     |                 r, group_start, total, local_pos_by_old, type_indices,
     |               ),
     |             )
     |           }
     |           CompType::func(next_params, next_results)
     |         }
     |         StructCompType(fields) => {
     |           let next_fields : Array[FieldType] = []
     |           for field in fields {
     |             let FieldType(storage, mut_) = field
     |             next_fields.push(
     |               FieldType::new(
     |                 mrg_rewrite_storage_for_shape(
     |                   storage, group_start, total, local_pos_by_old, type_indices,
     |                 ),
     |                 mut_,
     |               ),
     |             )
     |           }
     |           CompType::struct_(next_fields)
     |         }
1334 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
1336 |           CompType::array(
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             FieldType::new(
     |               mrg_rewrite_storage_for_shape(
     |                 storage, group_start, total, local_pos_by_old, type_indices,
     |               ),
     |               mut_,
     |             ),
     |           )
     |         }
     |       }
     |       SubType::comp_type(next_ct)
     |     }
     |   }
     | }
     …

     | fn mrg_dfs_order(
     |   start : Int,
     |   nodes : Array[Int],
     |   adjacency : Map[Int, Array[Int]],
     | ) -> Array[Int] {
     |   let visited : Set[Int] = Set::new()
     |   let order : Array[Int] = []
     |   let stack : Array[(Int, Bool)] = [(start, false)]
     |   while stack.length() > 0 {
     |     let (node, expanded) = stack.pop().unwrap()
     |     if expanded {
1429 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if visited.contains(node) {
1432 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     visited.add(node)
     |     order.push(node)
     |     let nexts = adjacency.get(node).unwrap_or([])
     |     for i in 0..<nexts.length() {
     |       let next = nexts[nexts.length() - 1 - i]
     |       if !visited.contains(next) {
     |         stack.push((next, false))
     |       }
     |     }
     |   }
     |   let remaining = nodes.copy()
     |   remaining.sort()
     |   for node in remaining {
     |     if !visited.contains(node) {
1448 |       order.push(node)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   order
     | }
     …

     | fn mrg_order_to_perm(
     |   types_in_scc : Array[Int],
     |   order : Array[Int],
     | ) -> Array[Int] {
     |   let pos : Map[Int, Int] = Map::new()
     |   for i in 0..<types_in_scc.length() {
     |     pos[types_in_scc[i]] = i
     |   }
     |   let perm : Array[Int] = []
     |   for t in order {
     |     match pos.get(t) {
     |       Some(p) => perm.push(p)
1467 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   perm
     | }
     …

     | fn get_canonical_permutation(
     |   types_in_scc : Array[Int],
     |   flat : MRGFlatTypes,
     |   type_indices : Array[Int],
     | ) -> Array[Int] {
     |   if types_in_scc.length() <= 1 {
     |     return [0]
     |   }
     |   let nodes = types_in_scc.copy()
     |   let adjacency = mrg_internal_ref_adjacency(nodes, flat)
     |   let starts = nodes.copy()
     |   starts.sort()
     |   let perms : Array[Array[Int]] = []
     |   for start in starts {
     |     let order = mrg_dfs_order(start, nodes, adjacency)
     |     perms.push(mrg_order_to_perm(nodes, order))
     |   }
     |   let dedup_perm : Array[Array[Int]] = []
     |   for p in perms {
     |     let mut exists = false
     |     for q in dedup_perm {
     |       if q == p {
1507 |         exists = true
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         break
     |       }
     |     }
     |     if !exists {
     |       dedup_perm.push(p)
     |     }
     |   }
     |   let classes : Map[String, Array[Array[Int]]] = Map::new()
     |   for p in dedup_perm {
     |     let ordered = mrg_apply_perm(nodes, p)
     |     let local_pos : Map[Int, Int] = Map::new()
     |     for i in 0..<ordered.length() {
     |       local_pos[ordered[i]] = i
     |     }
     |     let normalized : Array[SubType] = []
     |     for old_idx in ordered {
     |       normalized.push(
     |         mrg_rewrite_subtype_for_shape(
     |           flat.subtypes[old_idx],
     |           flat.group_starts[old_idx],
     |           flat.subtypes.length(),
     |           local_pos,
     |           type_indices,
     |         ),
     |       )
     |     }
     |     let key = comparable_shape(normalized, MRGFeatures::new(), type_indices).key
     |     match classes.get(key) {
     |       Some(v) => v.push(p)
     |       None => classes[key] = [p]
     |     }
     |   }
     |   let class_keys : Array[String] = []
     |   for k in classes {
     |     class_keys.push(k.0)
     |   }
     |   class_keys.sort()
     |   if class_keys.is_empty() {
1546 |     return [0]
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Stripe permutations across shape-equivalence classes.
     |   let striped : Array[Array[Int]] = []
     |   let mut layer = 0
     |   let mut progress = true
     |   while progress {
     |     progress = false
     |     for key in class_keys {
     |       let arr = classes.get(key).unwrap_or([])
     |       if layer < arr.length() {
     |         striped.push(arr[layer])
     |         progress = true
     |       }
     |     }
     |     layer += 1
     |   }
     |   if striped.is_empty() {
1565 |     return classes.get(class_keys[0]).unwrap()[0]
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   striped[0]
     | }
     …

     | fn mrg_make_brand_subtype(seed : Int) -> SubType {
     |   match seed % 8 {
     |     0 =>
     |       SubType::comp_type(
     |         CompType::struct_([
     |           FieldType::new(StorageType::val_type(ValType::i32()), Const),
     |         ]),
     |       )
     |     1 =>
     |       SubType::comp_type(
     |         CompType::struct_([
     |           FieldType::new(StorageType::val_type(ValType::i64()), Const),
     |         ]),
     |       )
     |     2 =>
     |       SubType::comp_type(
     |         CompType::struct_([
     |           FieldType::new(StorageType::val_type(ValType::f32()), Const),
     |         ]),
     |       )
     |     3 =>
1592 |       SubType::comp_type(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         CompType::struct_([
     |           FieldType::new(StorageType::val_type(ValType::f64()), Const),
     |         ]),
     |       )
     |     4 =>
1598 |       SubType::comp_type(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         CompType::array(
     |           FieldType::new(StorageType::val_type(ValType::i32()), Const),
     |         ),
     |       )
     |     5 =>
1604 |       SubType::comp_type(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         CompType::array(
     |           FieldType::new(StorageType::val_type(ValType::i64()), Const),
     |         ),
     |       )
1609 |     6 => SubType::comp_type(CompType::func([], []))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => SubType::comp_type(CompType::func([ValType::i32()], []))
     |   }
     | }
     …

     | fn mrg_reset_iteration(
     |   group : RecGroupInfo,
     |   flat : MRGFlatTypes,
     |   type_indices : Array[Int],
     | ) -> RecGroupInfo {
     |   let out = group
     |   if out.perm_orders.is_empty() {
1633 |     return out
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out.next_perm = 0
     |   out.current_order = out.perm_orders[0]
     |   out.seen_shapes = Set::new()
     |   out.seen_shapes.add(mrg_group_shape_key(out, flat, type_indices))
     |   out
     | }
     …

     | fn mrg_compute_perm_orders(
     |   old_types : Array[Int],
     |   flat : MRGFlatTypes,
     |   type_indices : Array[Int],
     | ) -> Array[Array[Int]] {
     |   let graph = create_type_order_graph(old_types, flat)
     |   let mut orders = mrg_all_topological_orders(old_types, graph)
     |   if orders.is_empty() {
1712 |     orders = [old_types.copy()]
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let canonical_perm = get_canonical_permutation(old_types, flat, type_indices)
     |   let canonical_order = mrg_apply_perm(old_types, canonical_perm)
     |   let dedup : Array[Array[Int]] = []
     |   for order in orders {
     |     let mut seen = false
     |     for existing in dedup {
     |       if existing == order {
1721 |         seen = true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |         break
     |       }
     |     }
     |     if !seen {
     |       dedup.push(order)
     |     }
     |   }
     |   dedup.sort_by(fn(a, b) {
     |     let key_a = comparable_shape(
     |         mrg_shape_subtypes_from_order(a, flat, type_indices),
     |         MRGFeatures::new(),
     |         type_indices,
     |       ).key
     |     let key_b = comparable_shape(
     |         mrg_shape_subtypes_from_order(b, flat, type_indices),
     |         MRGFeatures::new(),
     |         type_indices,
     |       ).key
     |     let cmp = key_a.compare(key_b)
     |     if cmp != 0 {
     |       cmp
     |     } else {
     |       a.to_string().compare(b.to_string())
     |     }
     |   })
     |   for i in 0..<dedup.length() {
     |     if dedup[i] == canonical_order {
     |       if i != 0 {
1750 |         let tmp = dedup[0]
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         dedup[0] = dedup[i]
     |         dedup[i] = tmp
     |       }
     |       break
     |     }
     |   }
     |   dedup
     | }
     …

     | fn mrg_ensure_canonicalized(
     |   groups : Array[RecGroupInfo],
     |   idx : Int,
     |   flat : MRGFlatTypes,
     |   type_indices : Array[Int],
     | ) -> Unit {
     |   let info = groups[idx]
     |   if info.canonicalized || info.old_types.is_empty() {
     |     return
     |   }
     |   let canonical_perm = get_canonical_permutation(
     |     info.old_types,
     |     flat,
     |     type_indices,
     |   )
     |   let canonical_order = mrg_apply_perm(info.old_types, canonical_perm)
     |   let out = info
     |   if !out.perm_orders.is_empty() {
     |     let reordered = out.perm_orders.copy()
     |     for i in 0..<reordered.length() {
     |       if reordered[i] == canonical_order {
     |         if i != 0 {
1836 |           let tmp = reordered[0]
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           reordered[0] = reordered[i]
     |           reordered[i] = tmp
     |         }
     |         break
     |       }
     |     }
     |     out.current_order = reordered[0]
     |   } else {
1845 |     out.current_order = canonical_order
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out.canonicalized = true
     |   groups[idx] = mrg_reset_iteration(out, flat, type_indices)
     | }
     …

     | fn update_shape(
     |   group_idx : Int,
     |   owner : Int,
     |   groups : Array[RecGroupInfo],
     |   dsu : DSU,
     |   flat : MRGFlatTypes,
     |   type_indices : Array[Int],
     |   stack : Array[Int],
     |   shape_owner : Map[String, Int],
     | ) -> Unit {
     |   if owner == mrg_public_shape_owner {
     |     let root = dsu.find(group_idx)
     |     let nontrivial = dsu.class_size(root) > 1
     |     if !nontrivial {
     |       mrg_ensure_canonicalized(groups, group_idx, flat, type_indices)
     |     }
     |     GroupClassInfo::{ group_idx, }.advance(groups, flat, type_indices)
     |     stack.push(group_idx)
     |     return
     |   }
     |   let a_root = dsu.find(group_idx)
     |   let b_root = dsu.find(owner)
     |   let a_nontrivial = dsu.class_size(a_root) > 1
     |   let b_nontrivial = dsu.class_size(b_root) > 1
     |   if a_root == b_root {
     |     groups[group_idx] = advance_brand(groups[group_idx], flat, type_indices)
     |     groups[group_idx] = permute(groups[group_idx], flat, type_indices)
     |     stack.push(group_idx)
     |     stack.push(owner)
     |     return
     |   }
     |   if a_nontrivial && b_nontrivial {
1884 |     GroupClassInfo::{ group_idx, }.advance(groups, flat, type_indices)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     stack.push(group_idx)
     |     return
     |   }
     |   if a_nontrivial && !b_nontrivial {
1889 |     ignore(dsu.union(a_root, b_root))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     mrg_ensure_canonicalized(groups, group_idx, flat, type_indices)
     |     mrg_ensure_canonicalized(groups, owner, flat, type_indices)
     |     GroupClassInfo::{ group_idx, }.advance(groups, flat, type_indices)
     |     stack.push(group_idx)
     |     stack.push(owner)
     |     return
     |   }
     |   if !a_nontrivial && b_nontrivial {
     |     ignore(dsu.union(a_root, b_root))
     |     mrg_ensure_canonicalized(groups, group_idx, flat, type_indices)
     |     mrg_ensure_canonicalized(groups, owner, flat, type_indices)
     |     GroupClassInfo::{ group_idx, }.advance(groups, flat, type_indices)
     |     stack.push(group_idx)
     |     stack.push(owner)
     |     return
     |   }
     | 
     |   // Two unaffiliated singleton groups.
     |   mrg_ensure_canonicalized(groups, group_idx, flat, type_indices)
     |   mrg_ensure_canonicalized(groups, owner, flat, type_indices)
     |   ignore(dsu.union(group_idx, owner))
     |   GroupClassInfo::{ group_idx, }.advance(groups, flat, type_indices)
     |   mrg_remove_owner(shape_owner, group_idx)
     |   mrg_remove_owner(shape_owner, owner)
     |   stack.push(group_idx)
     |   stack.push(owner)
     | }
     …

     | fn update_shapes(
     |   groups : Array[RecGroupInfo],
     |   flat : MRGFlatTypes,
     |   type_indices : Array[Int],
     | ) -> Unit {
     |   let shape_owner : Map[String, Int] = Map::new()
     |   let dsu = DSU::new(groups.length())
     |   let stack : Array[Int] = []
     |   for i in 0..<groups.length() {
     |     if groups[i].is_public {
     |       let key = mrg_group_shape_key(groups[i], flat, type_indices)
     |       shape_owner[key] = mrg_public_shape_owner
     |     }
     |   }
     |   for i in 0..<groups.length() {
     |     if !groups[i].is_public {
     |       stack.push(i)
     |     }
     |   }
     |   while stack.length() > 0 {
     |     let group_idx = stack.pop().unwrap()
     |     if groups[group_idx].is_public {
1941 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     mrg_remove_owner(shape_owner, group_idx)
     |     let key = mrg_group_shape_key(groups[group_idx], flat, type_indices)
     |     match shape_owner.get(key) {
     |       None => shape_owner[key] = group_idx
     |       Some(owner) =>
     |         if owner == group_idx {
1949 |           shape_owner[key] = group_idx
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           if owner >= 0 {
     |             mrg_remove_owner(shape_owner, owner)
     |           }
     |           update_shape(
     |             group_idx, owner, groups, dsu, flat, type_indices, stack, shape_owner,
     |           )
     |         }
     |     }
     |   }
     | }
     …

     | fn mrg_group_dependencies(
     |   groups : Array[RecGroupInfo],
     |   old_to_group : Array[Int],
     |   flat : MRGFlatTypes,
     | ) -> Array[Array[Int]] {
     |   let deps : Array[Array[Int]] = []
     |   for _ in 0..<groups.length() {
     |     deps.push([])
     |   }
     |   for gi in 0..<groups.length() {
     |     for old_idx in groups[gi].old_types {
     |       let refs = mrg_collect_subtype_refs(
     |         flat.subtypes[old_idx],
     |         flat.group_starts[old_idx],
     |         flat.subtypes.length(),
     |       )
     |       for r in refs {
     |         if r >= 0 && r < old_to_group.length() {
     |           let gj = old_to_group[r]
     |           if gj >= 0 && gj != gi {
1983 |             mrg_add_edge_unique(deps, gj, gi)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |     }
     |   }
     |   for row in deps {
     |     row.sort()
     |   }
     |   deps
     | }
     …

     | fn mrg_group_topo_order(
     |   groups : Array[RecGroupInfo],
     |   deps : Array[Array[Int]],
     | ) -> Array[Int] {
     |   let n = groups.length()
     |   let indegree = Array::make(n, 0)
     |   for from in 0..<n {
     |     for to in deps[from] {
2004 |       indegree[to] = indegree[to] + 1
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   let available : Array[Int] = []
     |   for i in 0..<n {
     |     if indegree[i] == 0 {
     |       available.push(i)
     |     }
     |   }
     |   available.sort_by(fn(a, b) {
     |     let sa = groups[a].sort_key
     |     let sb = groups[b].sort_key
     |     let cmp = sa.compare(sb)
     |     if cmp != 0 {
     |       cmp
     |     } else {
     |       groups[a].id.compare(groups[b].id)
     |     }
     |   })
     |   let out : Array[Int] = []
     |   while available.length() > 0 {
     |     let curr = available.pop().unwrap()
     |     out.push(curr)
     |     for to in deps[curr] {
2028 |       indegree[to] = indegree[to] - 1
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if indegree[to] == 0 {
2030 |         available.push(to)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     available.sort_by(fn(a, b) {
     |       let sa = groups[a].sort_key
     |       let sb = groups[b].sort_key
     |       let cmp = sa.compare(sb)
     |       if cmp != 0 {
     |         cmp
     |       } else {
     |         groups[a].id.compare(groups[b].id)
     |       }
     |     })
     |   }
     |   if out.length() < n {
2045 |     for i in 0..<n {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let mut seen = false
     |       for v in out {
2048 |         if v == i {
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |           seen = true
     |           break
     |         }
     |       }
     |       if !seen {
2054 |         out.push(i)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn mrg_rewrite_typeidx_for_output(
     |   type_idx : TypeIdx,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[TypeIdx, String] {
     |   match mrg_resolve_type_idx(type_idx, group_start, total) {
     |     Some(abs_idx) =>
     |       match local_pos_by_old.get(abs_idx) {
     |         Some(pos) => Ok(TypeIdx::rec(pos.reinterpret_as_uint()))
     |         None =>
2074 |           match old_to_new.get(abs_idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(next_idx) => Ok(next_idx)
     |             None => Err("minimize_rec_groups: missing remap for external type")
     |           }
     |       }
2079 |     None => Ok(type_idx)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_heaptype_for_output(
     |   ht : HeapType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[HeapType, String] {
     |   match ht {
     |     HeapType(type_idx) =>
     |       match
     |         mrg_rewrite_typeidx_for_output(
     |           type_idx, group_start, total, local_pos_by_old, old_to_new,
     |         ) {
     |         Ok(next_idx) => Ok(HeapType::new(next_idx))
2098 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
2100 |     _ => Ok(ht)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_reftype_for_output(
     |   rt : RefType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[RefType, String] {
     |   match rt {
     |     HeapTypeRefType(nullable, ht) =>
     |       match
     |         mrg_rewrite_heaptype_for_output(
     |           ht, group_start, total, local_pos_by_old, old_to_new,
     |         ) {
     |         Ok(next_ht) => Ok(RefType::new(nullable, next_ht))
2119 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
2121 |     _ => Ok(rt)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_valtype_for_output(
     |   vt : ValType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[ValType, String] {
     |   match vt {
     |     RefTypeValType(rt) =>
     |       match
     |         mrg_rewrite_reftype_for_output(
     |           rt, group_start, total, local_pos_by_old, old_to_new,
     |         ) {
     |         Ok(next_rt) => Ok(ValType::ref_type(next_rt))
2140 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => Ok(vt)
     |   }
     | }
     …

     | fn mrg_rewrite_storage_for_output(
     |   st : StorageType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[StorageType, String] {
     |   match st {
     |     ValTypeStorageType(vt) =>
     |       match
     |         mrg_rewrite_valtype_for_output(
     |           vt, group_start, total, local_pos_by_old, old_to_new,
     |         ) {
     |         Ok(next_vt) => Ok(StorageType::val_type(next_vt))
2161 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
2163 |     _ => Ok(st)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_rewrite_subtype_for_output(
     |   subtype : SubType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[SubType, String] {
     |   match subtype {
     |     SubType(is_final, supers, ct) => {
     |       let next_supers : Array[TypeIdx] = []
     |       for super_idx in supers {
     |         match
     |           mrg_rewrite_typeidx_for_output(
     |             super_idx, group_start, total, local_pos_by_old, old_to_new,
     |           ) {
     |           Ok(next_idx) => next_supers.push(next_idx)
2184 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       let next_ct = match ct {
2188 |         FuncCompType(params, results) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let next_params : Array[ValType] = []
     |           let next_results : Array[ValType] = []
     |           for p in params {
2192 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_output(
     |                 p, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
2196 |               Ok(v) => next_params.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
     |           for r in results {
2201 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_output(
     |                 r, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
2205 |               Ok(v) => next_results.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
2209 |           CompType::func(next_params, next_results)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         StructCompType(fields) => {
     |           let next_fields : Array[FieldType] = []
     |           for field in fields {
     |             let FieldType(storage, mut_) = field
     |             match
     |               mrg_rewrite_storage_for_output(
     |                 storage, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
     |               Ok(next_storage) =>
     |                 next_fields.push(FieldType::new(next_storage, mut_))
2221 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           CompType::struct_(next_fields)
     |         }
2226 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
     |           let next_storage = match
2229 |             mrg_rewrite_storage_for_output(
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               storage, group_start, total, local_pos_by_old, old_to_new,
     |             ) {
2232 |             Ok(v) => v
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => return Err(e)
     |           }
2235 |           CompType::array(FieldType::new(next_storage, mut_))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       Ok(SubType::new(is_final, next_supers, next_ct))
     |     }
     |     CompTypeSubType(ct) => {
     |       let next_ct = match ct {
     |         FuncCompType(params, results) => {
     |           let next_params : Array[ValType] = []
     |           let next_results : Array[ValType] = []
     |           for p in params {
2246 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_output(
     |                 p, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
2250 |               Ok(v) => next_params.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
     |           for r in results {
2255 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               mrg_rewrite_valtype_for_output(
     |                 r, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
2259 |               Ok(v) => next_results.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
     |           CompType::func(next_params, next_results)
     |         }
     |         StructCompType(fields) => {
     |           let next_fields : Array[FieldType] = []
     |           for field in fields {
     |             let FieldType(storage, mut_) = field
     |             match
     |               mrg_rewrite_storage_for_output(
     |                 storage, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
     |               Ok(next_storage) =>
     |                 next_fields.push(FieldType::new(next_storage, mut_))
2275 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           CompType::struct_(next_fields)
     |         }
2280 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
     |           let next_storage = match
2283 |             mrg_rewrite_storage_for_output(
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               storage, group_start, total, local_pos_by_old, old_to_new,
     |             ) {
2286 |             Ok(v) => v
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => return Err(e)
     |           }
2289 |           CompType::array(FieldType::new(next_storage, mut_))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       Ok(SubType::comp_type(next_ct))
     |     }
     |   }
     | }
     …

     | fn rewrite_types(
     |   mod : Module,
     |   groups : Array[RecGroupInfo],
     |   flat : MRGFlatTypes,
     | ) -> Result[Module, String] {
     |   if flat.subtypes.is_empty() {
2304 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let old_to_group = Array::make(flat.subtypes.length(), -1)
     |   for gi in 0..<groups.length() {
     |     for old_idx in groups[gi].old_types {
     |       old_to_group[old_idx] = gi
     |     }
     |   }
     |   let deps = mrg_group_dependencies(groups, old_to_group, flat)
     |   let group_order = mrg_group_topo_order(groups, deps)
     |   let old_to_new : Map[Int, TypeIdx] = Map::new()
     |   let mut next_index = 0
     |   for gi in group_order {
     |     let group = groups[gi]
     |     let brand_offset = if group.brand is Some(_) { 1 } else { 0 }
     |     for i in 0..<group.current_order.length() {
     |       old_to_new[group.current_order[i]] = TypeIdx::new(
     |         (next_index + brand_offset + i).reinterpret_as_uint(),
     |       )
     |     }
     |     next_index += brand_offset + group.current_order.length()
     |   }
     |   let new_recs : Array[RecType] = []
     |   for gi in group_order {
     |     let group = groups[gi]
     |     let local_pos_by_old : Map[Int, Int] = Map::new()
     |     let brand_offset = if group.brand is Some(_) { 1 } else { 0 }
     |     for i in 0..<group.current_order.length() {
     |       local_pos_by_old[group.current_order[i]] = brand_offset + i
     |     }
     |     let out_subtypes : Array[SubType] = []
     |     if group.brand is Some(brand) {
     |       out_subtypes.push(brand)
     |     }
     |     for old_idx in group.current_order {
     |       match
     |         mrg_rewrite_subtype_for_output(
     |           flat.subtypes[old_idx],
     |           flat.group_starts[old_idx],
     |           flat.subtypes.length(),
     |           local_pos_by_old,
     |           old_to_new,
     |         ) {
     |         Ok(subtype) => out_subtypes.push(subtype)
2348 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if out_subtypes.length() == 1 {
     |       new_recs.push(RecType::new(out_subtypes[0]))
     |     } else {
     |       new_recs.push(RecType::group(out_subtypes))
     |     }
     |   }
     |   let new_type_sec = TypeSec::new(new_recs)
     |   let remapper = ModuleTransformer::new()
     |     .on_typeidx_evt(fn(_t, _, tidx : TypeIdx) {
     |       match tidx {
     |         TypeIdx(i) => {
     |           let raw = i.reinterpret_as_int()
     |           match old_to_new.get(raw) {
     |             Some(next_idx) => change((), next_idx)
2365 |             None => unchanged()
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
2368 |         RecIdx(_) => unchanged()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     .on_heaptype_evt(fn(_t, _, ht : HeapType) {
     |       match ht {
     |         HeapType(type_idx) => {
     |           let next_type = match type_idx {
     |             TypeIdx(i) => {
     |               let raw = i.reinterpret_as_int()
     |               match old_to_new.get(raw) {
     |                 Some(next_idx) => next_idx
2379 |                 None => type_idx
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
2382 |             RecIdx(_) => type_idx
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           change((), HeapType::new(next_type))
     |         }
2386 |         _ => unchanged()
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     .on_typesec_evt(fn(_t, _, _ts : TypeSec) { change((), new_type_sec) })
     |   match remapper.walk_module((), mod) {
     |     Ok(Some((_, next_mod))) => Ok(next_mod)
2392 |     Ok(None) => Ok(mod.with_type_sec(new_type_sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn mrg_run(mod : Module) -> Result[Module, String] {
     |   let type_sec = match mod.type_sec {
     |     Some(type_sec) => type_sec
2471 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let TypeSec(recs) = type_sec
     |   if recs.is_empty() {
2475 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let info = collect_heap_type_info(mod)
     |   ignore(info.public_types.length())
     |   ignore(info.visibility_map.length())
     |   let flat = info.flat
     |   if flat.subtypes.is_empty() {
2482 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let type_indices = compute_type_indices_for_shape_ordering(flat)
     |   let adjacency = mrg_private_adjacency(info.private_types, flat)
     |   let sccs = compute_sccs(info.private_types, adjacency)
     |   let (public_groups, next_id) = mrg_build_public_groups(info, type_indices, 0)
     |   let (private_groups, _next_id) = mrg_build_private_groups(
     |     sccs, flat, type_indices, next_id,
     |   )
     |   let groups = public_groups.copy()
     |   for g in private_groups {
     |     groups.push(g)
     |   }
     |   update_shapes(groups, flat, type_indices)
     |   rewrite_types(mod, groups, flat)
     | }
     …

     | fn mrg_count_types(mod : Module) -> Int {
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) => {
     |       let mut n = 0
     |       for rec in recs {
     |         match rec {
     |           SingleRecType(_) => n += 1
     |           GroupRecType(sts) => n += sts.length()
     |         }
     |       }
     |       n
     |     }
2517 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mrg_group_sizes(mod : Module) -> Array[Int] {
     |   let out : Array[Int] = []
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) =>
     |       for rec in recs {
     |         match rec {
     |           SingleRecType(_) => out.push(1)
     |           GroupRecType(sts) => out.push(sts.length())
     |         }
     |       }
2532 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn mrg_group_shape_keys(mod : Module) -> Array[String] {
     |   let out : Array[String] = []
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) => {
     |       let flat = mrg_flatten_types(TypeSec::new(recs))
     |       let type_indices = compute_type_indices_for_shape_ordering(flat)
     |       for group in flat.groups {
     |         let order = group.copy()
     |         let local_pos : Map[Int, Int] = Map::new()
     |         for i in 0..<order.length() {
     |           local_pos[order[i]] = i
     |         }
     |         let subtypes : Array[SubType] = []
     |         for idx in order {
     |           subtypes.push(
     |             mrg_rewrite_subtype_for_shape(
     |               flat.subtypes[idx],
     |               flat.group_starts[idx],
     |               flat.subtypes.length(),
     |               local_pos,
     |               type_indices,
     |             ),
     |           )
     |         }
     |         out.push(
     |           comparable_shape(subtypes, MRGFeatures::new(), type_indices).key,
     |         )
     |       }
     |     }
2567 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn mrg_has_unique_group_shapes(mod : Module) -> Bool {
     |   let seen : Set[String] = Set::new()
     |   for key in mrg_group_shape_keys(mod) {
     |     if seen.contains(key) {
2577 |       return false
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     seen.add(key)
     |   }
     |   true
     | }
     …

135 uncovered line(s) in src/passes/monomorphize.mbt:

     | fn MonoEffects::merge(self : MonoEffects, other : MonoEffects) -> Unit {
     |   for local_idx in other.locals_read {
     |     self.locals_read.add(local_idx)
     |   }
     |   for local_idx in other.locals_written {
  42 |     self.locals_written.add(local_idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.reads_memory = self.reads_memory || other.reads_memory
     |   self.writes_memory = self.writes_memory || other.writes_memory
     |   self.reads_globals = self.reads_globals || other.reads_globals
     |   self.writes_globals = self.writes_globals || other.writes_globals
     |   self.calls = self.calls || other.calls
     |   self.branches = self.branches || other.branches
     |   self.traps = self.traps || other.traps
     |   self.throws = self.throws || other.throws
     | }
     …

     | fn MonoEffects::invalidates(self : MonoEffects, other : MonoEffects) -> Bool {
     |   for local_idx in self.locals_written {
  73 |     if other.locals_read.contains(local_idx) ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       other.locals_written.contains(local_idx) {
  75 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   for local_idx in self.locals_read {
     |     if other.locals_written.contains(local_idx) {
  80 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if (self.reads_memory && other.writes_memory) ||
     |     (self.writes_memory && other.reads_memory) ||
     |     (self.writes_memory && other.writes_memory) {
  86 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.reads_globals && other.writes_globals) ||
     |     (self.writes_globals && other.reads_globals) ||
     |     (self.writes_globals && other.writes_globals) {
  91 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if self.calls || other.calls {
  94 |     if self.reads_memory ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.writes_memory ||
     |       other.reads_memory ||
     |       other.writes_memory ||
     |       self.reads_globals ||
     |       self.writes_globals ||
     |       other.reads_globals ||
     |       other.writes_globals {
 102 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if self.transfers_control_flow() || other.transfers_control_flow() {
 106 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.traps && other.has_unremovable_side_effects()) ||
     |     (other.traps && self.has_unremovable_side_effects()) {
 110 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   false
     | }
     …

     | fn mn_collect_shallow_effects_into(
     |   instr : TInstr,
     |   effects : MonoEffects,
     | ) -> Unit {
     |   match instr {
     |     TLocalGet(idx) => effects.locals_read.add(idx)
 122 |     TLocalSet(idx, _) => effects.locals_written.add(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalTee(idx, _) => {
     |       effects.locals_read.add(idx)
     |       effects.locals_written.add(idx)
     |     }
 127 |     TGlobalGet(_) => effects.reads_globals = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TGlobalSet(_, _) => effects.writes_globals = true
     |     TLoad(_, _, _) => {
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
 133 |     TStore(_, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
 137 |     TMemoryGrow(_, _) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemorySize(_) => effects.reads_memory = true
     |     TMemoryCopy(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
 143 |     TMemoryFill(_, _, _, _) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryInit(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
 148 |     TDataDrop(_) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableSet(_, _, _) | TTableGrow(_, _, _) | TTableFill(_, _, _, _) =>
 150 |       effects.writes_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableGet(_, _) | TTableSize(_) => effects.reads_memory = true
     |     TTableCopy(_, _, _, _, _) | TTableInit(_, _, _, _, _) | TElemDrop(_) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
     |     TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
 157 |       effects.calls = true
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
 160 |     | TReturnCallRef(_, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
     |       effects.branches = true
     |     }
     |     TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
 171 |     | TReturn(_) => effects.branches = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TThrow(_, _) => {
     |       effects.throws = true
     |       effects.branches = true
     |     }
 176 |     TThrowRef(_) => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.throws = true
     |       effects.branches = true
     |     }
 180 |     TUnreachable => effects.traps = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefAsNonNull(_) | TRefCast(_, _, _) => effects.traps = true
     |     TStructGet(_, _, _) | TStructGetS(_, _, _) | TStructGetU(_, _, _) => {
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
 186 |     TStructSet(_, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TArrayNew(_, _, _)
     |     | TArrayNewDefault(_, _)
     |     | TArrayNewFixed(_, _)
     |     | TArrayNewData(_, _, _, _)
 194 |     | TArrayNewElem(_, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TArrayGet(_, _, _)
     |     | TArrayGetS(_, _, _)
     |     | TArrayGetU(_, _, _)
 201 |     | TArrayLen(_) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
     |     TArraySet(_, _, _, _)
     |     | TArrayFill(_, _, _, _, _)
     |     | TArrayCopy(_, _, _, _, _, _, _)
     |     | TArrayInitData(_, _, _, _, _, _)
 209 |     | TArrayInitElem(_, _, _, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
     |     TBinary(op, _, _) =>
     |       match op {
     |         I32DivSOp
     |         | I32DivUOp
     |         | I32RemSOp
     |         | I32RemUOp
     |         | I64DivSOp
     |         | I64DivUOp
     |         | I64RemSOp
     |         | I64RemUOp => effects.traps = true
     |         _ => ()
     |       }
     |     TUnary(op, _) =>
 227 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I32TruncF32SOp
     |         | I32TruncF32UOp
     |         | I32TruncF64SOp
     |         | I32TruncF64UOp
     |         | I64TruncF32SOp
     |         | I64TruncF32UOp
     |         | I64TruncF64SOp
 235 |         | I64TruncF64UOp => effects.traps = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn mn_flattened_type_count(rec_types : Array[RecType]) -> Int {
     |   let mut n = 0
     |   for rec_type in rec_types {
     |     match rec_type {
     |       SingleRecType(_) => n += 1
 364 |       GroupRecType(sub_types) => n += sub_types.length()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   n
     | }
     …

     | fn mn_count_imported_funcs(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(_) => n += 1
 379 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn mn_get_func(mod : Module, abs_idx : Int) -> Func? {
     |   let imported = mn_count_imported_funcs(mod)
     |   let def_idx = abs_idx - imported
     |   if def_idx < 0 {
 392 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) if def_idx < funcs.length() => Some(funcs[def_idx])
 396 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mn_set_defined_func(mod : Module, def_idx : Int, func : Func) -> Module {
     |   let mut out_mod = mod
     |   match out_mod.code_sec {
     |     Some(CodeSec(funcs)) if def_idx >= 0 && def_idx < funcs.length() => {
     |       let next_funcs = funcs.copy()
     |       next_funcs[def_idx] = func
     |       out_mod = out_mod.with_code_sec(CodeSec::new(next_funcs))
     |       out_mod
     |     }
 410 |     _ => out_mod
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mn_has_unreachable_operand(args : Array[TInstr]) -> Bool {
     |   for arg in args {
     |     if is_unreachable_instr(arg) {
 418 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   false
     | }
     …

     | fn mn_call_result_unreachable(target : FuncIdx, env : Env) -> Bool {
     |   match env.get_functype_by_funcidx(target) {
 427 |     Some(FuncType(_, [BotValType])) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn mn_instr_result_arity(instr : TInstr, env : Env) -> Int {
     |   match instr {
     |     TCall(target, _) =>
 436 |       match env.get_functype_by_funcidx(target) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, results)) => results.length()
     |         None => 0
     |       }
     |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
 441 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, results)) => results.length()
     |         None => 0
     |       }
     |     TBlock(bt, _) | TLoop(bt, _) | TIf(bt, _, _, _) | TTryTable(bt, _, _) =>
 446 |       match env.expand_blocktype(bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok((_, results)) => results.length()
     |         Err(_) => 0
     |       }
     |     _ =>
     |       match lcs_infer_tinstr_type(instr, env) {
     |         Some(_) => 1
 453 |         None => 0
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn MonoCallContext::can_be_moved_into_context(
     |   expr : TInstr,
     |   shallow_effects : MonoEffects,
     |   has_tuple_child : Bool,
     | ) -> Bool {
     |   if has_tuple_child {
 465 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if shallow_effects.locals_read.length() > 0 ||
     |     shallow_effects.locals_written.length() > 0 {
     |     return false
     |   }
     |   if shallow_effects.calls ||
     |     shallow_effects.transfers_control_flow() ||
     |     shallow_effects.throws {
 474 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if shallow_effects.reads_memory ||
     |     shallow_effects.writes_memory ||
     |     shallow_effects.reads_globals ||
     |     shallow_effects.writes_globals ||
     |     shallow_effects.traps {
     |     return false
     |   }
     |   match expr {
 484 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => false
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => true
     |   }
     | }
     …

     | fn mn_collect_operand_node(state : MonoCollectState, instr : TInstr) -> Int {
     |   let id = state.next_id
     |   state.next_id += 1
     |   let child_ids : Array[Int] = []
     |   for child in eval_children(instr) {
     |     child_ids.push(mn_collect_operand_node(state, child))
     |   }
     |   let mut has_tuple_child = false
     |   for child_id in child_ids {
     |     match state.node_infos.get(child_id) {
     |       Some(node) if mn_instr_result_arity(node.instr, state.env) > 1 =>
 501 |         has_tuple_child = true
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |   }
     |   let shallow = mn_collect_shallow_effects(instr)
     |   let full = mn_collect_effects(instr)
     |   let can_move = MonoCallContext::can_be_moved_into_context(
     |     instr, shallow, has_tuple_child,
     |   )
     |   state.node_infos[id] = { instr, shallow, full, can_move }
     |   state.post_order.push(id)
     |   id
     | }
     …

     | fn mn_copy_operand_with_context(
     |   state : MonoCopyState,
     |   instr : TInstr,
     | ) -> TInstr {
     |   let id = state.next_id
     |   state.next_id += 1
     |   if state.immovable.contains(id) {
     |     match lcs_infer_tinstr_type(instr, state.env) {
     |       Some(vt) => {
     |         let param_idx = state.new_operand_types.length()
     |         state.new_operands.push(instr)
     |         state.new_operand_types.push(vt)
     |         return TInstr::local_get(LocalIdx::new(param_idx.reinterpret_as_uint()))
     |       }
 530 |       None => {
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |         state.type_failed = true
     |         return instr
     |       }
     |     }
     |   }
     |   match instr {
 537 |     TBlock(_, _) | TLoop(_, _) | TIf(_, _, _, _) | TTryTable(_, _, _) => instr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => {
     |       let rewritten_children : Array[TInstr] = []
     |       for child in eval_children(instr) {
     |         rewritten_children.push(mn_copy_operand_with_context(state, child))
     |       }
     |       lcs_rebuild_non_control(instr, rewritten_children)
     |     }
     |   }
     | }
     …

     | fn MonoCallContext::build_from_call(
     |   call_info : MonoCallInfo,
     |   caller_env : Env,
     |   allow_dropped : Bool,
     | ) -> MonoContextBuild? {
     |   let collect_state = MonoCollectState::new(caller_env)
     |   for arg in call_info.args {
     |     ignore(mn_collect_operand_node(collect_state, arg))
     |   }
     |   let immovable : Set[Int] = Set::new()
     |   let non_moving_effects = MonoEffects::new()
     |   for i = collect_state.post_order.length() - 1; i >= 0; i = i - 1 {
     |     let id = collect_state.post_order[i]
     |     match collect_state.node_infos.get(id) {
 563 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(info) =>
     |         if !info.can_move {
     |           immovable.add(id)
     |           non_moving_effects.merge(info.full)
     |         } else if info.shallow.invalidates(non_moving_effects) ||
     |           non_moving_effects.invalidates(info.shallow) {
 570 |           immovable.add(id)
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           non_moving_effects.merge(info.full)
     |         }
     |     }
     |   }
     |   let copy_state = MonoCopyState::new(caller_env, immovable)
     |   let operands : Array[TInstr] = []
     |   for arg in call_info.args {
     |     operands.push(mn_copy_operand_with_context(copy_state, arg))
     |   }
     |   if copy_state.type_failed {
 581 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let context = { operands, dropped: call_info.dropped && allow_dropped }
     |   Some({
     |     context,
     |     new_operands: copy_state.new_operands,
     |     new_operand_types: copy_state.new_operand_types,
     |   })
     | }
     …

     | fn MonoCallContext::is_trivial(
     |   self : MonoCallContext,
     |   call_info : MonoCallInfo,
     |   callee_params : Array[ValType],
     |   caller_env : Env,
     |   new_operands : Array[TInstr],
     | ) -> Bool {
     |   if self.dropped {
     |     return false
     |   }
     |   if self.operands.length() != callee_params.length() {
 603 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for i = 0; i < self.operands.length(); i = i + 1 {
     |     match self.operands[i] {
     |       TLocalGet(LocalIdx(raw)) =>
     |         if raw.reinterpret_as_int() != i {
 609 |           return false
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => return false
     |     }
     |   }
     |   if new_operands.length() != callee_params.length() {
 615 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for i = 0; i < new_operands.length(); i = i + 1 {
     |     match new_operands[i] {
     |       TLocalGet(local_idx) =>
     |         match caller_env.get_local_type(local_idx) {
     |           Some(vt) if vt == callee_params[i] => ()
 622 |           _ => return false
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => return false
     |     }
     |   }
     |   call_info.args.length() == callee_params.length()
     | }
     …

     | fn mn_parse_nonneg_int_from(s : String, start : Int) -> Int? {
     |   if start >= s.length() {
 633 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut value = 0
     |   for i = start; i < s.length(); i = i + 1 {
     |     let c = s[i].to_int()
     |     if c < 0x30 || c > 0x39 {
 639 |       return None
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     value = value * 10 + (c - 0x30)
     |   }
     |   Some(value)
     | }
     …

     | fn monomorphize_apply_arguments(
     |   options : OptimizeOptions,
     |   args : Array[String],
     | ) -> OptimizeOptions {
     |   let mut min_benefit = options.monomorphize_min_benefit
     |   let prefix = "monomorphize-min-benefit@"
     |   for arg in args {
     |     if arg.length() < prefix.length() {
 655 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let mut matched = true
     |     for i = 0; i < prefix.length(); i = i + 1 {
     |       if arg[i] != prefix[i] {
 660 |         matched = false
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         break
     |       }
     |     }
     |     if !matched {
 665 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match mn_parse_nonneg_int_from(arg, prefix.length()) {
     |       Some(v) => min_benefit = v
 669 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   OptimizeOptions::new(
     |     optimize_level=options.optimize_level,
     |     shrink_level=options.shrink_level,
     |     inlining=options.inlining,
     |     monomorphize_min_benefit=min_benefit,
     |   )
     | }
     …

     | fn find_return_callers(mod : Module) -> Array[Bool] {
     |   let env = Env::new().with_module(mod)
     |   let total = env.funcs.length()
     |   let return_callers : Array[Bool] = Array::make(total, false)
     |   let imported = mn_count_imported_funcs(mod)
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for i = 0; i < funcs.length(); i = i + 1 {
     |         let abs_idx = imported + i
     |         if abs_idx < 0 || abs_idx >= total {
 691 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match funcs[i] {
     |           TFunc(_, body) => {
     |             let mut has_return_call = false
     |             let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |               self,
     |               _,
     |               instr,
     |             ) {
     |               match instr {
     |                 TReturnCall(_, _)
     |                 | TReturnCallIndirect(_, _, _, _)
     |                 | TReturnCallRef(_, _, _) => has_return_call = true
     |                 _ => ()
     |               }
     |               self.walk_tinstruction_default((), instr)
     |             })
     |             ignore(walker.walk_texpr((), body))
     |             return_callers[abs_idx] = has_return_call
     |           }
 712 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 715 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   return_callers
     | }
     …

     | fn mn_record_call(
     |   collector : MonoCallCollector,
     |   target : FuncIdx,
     |   args : Array[TInstr],
     |   dropped : Bool,
     |   reachable : Bool,
     | ) -> Unit {
     |   let call_id = collector.next_call_id
     |   collector.next_call_id += 1
     |   if !reachable || mn_call_result_unreachable(target, collector.env) {
 743 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   collector.calls.push({ call_id, target, args, dropped })
     | }
     …

     | fn mn_collect_calls_in_instr(
     |   collector : MonoCallCollector,
     |   instr : TInstr,
     |   reachable : Bool,
     | ) -> Unit {
     |   match instr {
     |     TDrop(TCall(target, args)) => {
     |       for arg in args {
     |         mn_collect_calls_in_instr(collector, arg, reachable)
     |       }
     |       mn_record_call(collector, target, args, true, reachable)
     |     }
     |     TCall(target, args) => {
     |       for arg in args {
     |         mn_collect_calls_in_instr(collector, arg, reachable)
     |       }
     |       mn_record_call(collector, target, args, false, reachable)
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 768 |       mn_collect_calls_in_texpr(collector, body, true)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       mn_collect_calls_in_instr(collector, cond, true)
     |       mn_collect_calls_in_texpr(collector, then_body, true)
     |       match else_body {
     |         Some(other) => mn_collect_calls_in_texpr(collector, other, true)
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         mn_collect_calls_in_instr(collector, child, reachable)
     |       }
     |   }
     | }
     …

     | fn mn_collect_calls_in_texpr(
     |   collector : MonoCallCollector,
     |   body : TExpr,
     |   reachable : Bool,
     | ) -> Unit {
     |   let mut reachable = reachable
     |   for instr in body.0 {
     |     if !reachable {
 793 |       break
     |       ^^^^^ 	<-- UNCOVERED
     |     }
     |     mn_collect_calls_in_instr(collector, instr, reachable)
     |     if is_unreachable_instr(instr) {
     |       reachable = false
     |     }
     |   }
     | }
     …

     | fn find_calls_and_drops(
     |   func : Func,
     |   caller_abs_idx : Int,
     |   env : Env,
     | ) -> Array[MonoCallInfo] {
     |   ignore(caller_abs_idx)
     |   match func {
     |     TFunc(_, body) => {
     |       let collector = MonoCallCollector::new(env)
     |       mn_collect_calls_in_texpr(collector, body, true)
     |       collector.calls
     |     }
 815 |     _ => []
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mn_shift_local_indices(body : TExpr, shift : Int) -> TExpr {
     |   if shift == 0 {
     |     return body
     |   }
     |   let walker = ModuleTransformer::new().on_localidx_evt(fn(_, _, idx) {
     |     let LocalIdx(raw) = idx
     |     let next_idx = raw.reinterpret_as_int() + shift
     |     change((), LocalIdx::new(next_idx.reinterpret_as_uint()))
     |   })
     |   match walker.walk_texpr((), body) {
     |     Ok(Some((_, out))) => out
 831 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mn_remove_returns_for_dropped(body : TExpr) -> TExpr {
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let processed = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, i))) => i
 840 |       Ok(None) => instr
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Err(e) => return Err(e)
     |     }
     |     match processed {
     |       TReturn(values) if values.length() > 0 => {
     |         let seq : Array[TInstr] = []
     |         for value in values {
     |           seq.push(TInstr::drop(value))
     |         }
     |         seq.push(TInstr::return_([]))
     |         change((), TInstr::block(BlockType::void_(), TExpr::new(seq)))
     |       }
     |       TReturnCall(target, args) =>
 853 |         change(
     |         ^^^^^^^ 	<-- UNCOVERED
     |           (),
 855 |           TInstr::block(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             BlockType::void_(),
     |             TExpr::new([
     |               TInstr::drop(TInstr::call(target, args)),
     |               TInstr::return_([]),
     |             ]),
     |           ),
     |         )
     |       TReturnCallIndirect(type_idx, table_idx, args, index) =>
 864 |         change(
     |         ^^^^^^^ 	<-- UNCOVERED
     |           (),
 866 |           TInstr::block(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             BlockType::void_(),
     |             TExpr::new([
     |               TInstr::drop(
     |                 TInstr::call_indirect(type_idx, table_idx, args, index),
     |               ),
 872 |               TInstr::return_([]),
     |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ]),
     |           ),
     |         )
     |       TReturnCallRef(type_idx, args, ref_) =>
 877 |         change(
     |         ^^^^^^^ 	<-- UNCOVERED
     |           (),
 879 |           TInstr::block(
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             BlockType::void_(),
     |             TExpr::new([
     |               TInstr::drop(TInstr::call_ref(type_idx, args, ref_)),
     |               TInstr::return_([]),
     |             ]),
     |           ),
     |         )
     |       _ => if processed != instr { change((), processed) } else { unchanged() }
     |     }
     |   })
     |   let rewritten = match walker.walk_texpr((), body) {
     |     Ok(Some((_, out))) => out
 892 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let out_instrs = rewritten.0.copy()
     |   out_instrs.push(TInstr::return_([]))
     |   TExpr::new(out_instrs)
     | }
     …

     | fn make_mono_function_with_context(
     |   func : Func,
     |   func_type : FuncType,
     |   context : MonoCallContext,
     |   new_operand_types : Array[ValType],
     | ) -> Func? {
     |   match func {
     |     TFunc(extra_locals, body) => {
     |       let FuncType(old_params, _) = func_type
     |       if context.operands.length() != old_params.length() {
 910 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let new_param_count = new_operand_types.length()
     |       let shifted_body = mn_shift_local_indices(body, new_param_count)
     |       let rewritten_body = if context.dropped {
     |         mn_remove_returns_for_dropped(shifted_body)
     |       } else {
     |         shifted_body
     |       }
     |       let prologue : Array[TInstr] = []
     |       for i = 0; i < old_params.length(); i = i + 1 {
     |         let mapped = new_param_count + i
     |         prologue.push(
     |           TInstr::local_set(
     |             LocalIdx::new(mapped.reinterpret_as_uint()),
     |             context.operands[i],
     |           ),
     |         )
     |       }
     |       let combined : Array[TInstr] = []
     |       for instr in prologue {
     |         combined.push(instr)
     |       }
     |       for instr in rewritten_body.0 {
     |         combined.push(instr)
     |       }
     |       let locals = old_params.copy()
     |       for local_ in extra_locals {
 938 |         locals.push(local_)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Some(Func::t_func(locals, TExpr::new(combined)))
     |     }
 942 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mn_append_specialized_function(
     |   mod : Module,
     |   params : Array[ValType],
     |   results : Array[ValType],
     |   func : Func,
     | ) -> (Module, FuncIdx) {
     |   let imported = mn_count_imported_funcs(mod)
     |   let mut out_mod = mod
     |   let recs = match out_mod.type_sec {
     |     Some(TypeSec(xs)) => xs.copy()
 957 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let type_idx = TypeIdx::new(
     |     mn_flattened_type_count(recs).reinterpret_as_uint(),
     |   )
     |   recs.push(mn_make_func_type(params, results))
     |   out_mod = out_mod.with_type_sec(TypeSec::new(recs))
     |   let func_types = match out_mod.func_sec {
     |     Some(FuncSec(xs)) => xs.copy()
 966 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   func_types.push(type_idx)
     |   out_mod = out_mod.with_func_sec(FuncSec::new(func_types))
     |   let funcs = match out_mod.code_sec {
     |     Some(CodeSec(xs)) => xs.copy()
 972 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let abs_idx = imported + funcs.length()
     |   funcs.push(func)
     |   out_mod = out_mod.with_code_sec(CodeSec::new(funcs))
     |   (out_mod, FuncIdx::new(abs_idx.reinterpret_as_uint()))
     | }
     …

     | fn mn_cost_instr(instr : TInstr) -> Int {
     |   let base = match instr {
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TLocalGet(_)
     |     | TGlobalGet(_)
     |     | TNop => 0
 993 |     TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) => 4
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
 996 |     | TReturnCallRef(_, _, _) => 5
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => 1
     |   }
     |   let mut total = base
     |   match instr {
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
1002 |       for item in body.0 {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         total += mn_cost_instr(item)
     |       }
1005 |     TIf(_, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       total += mn_cost_instr(cond)
     |       for item in then_.0 {
1008 |         total += mn_cost_instr(item)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1010 |       match else_ {
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) =>
1012 |           for item in other.0 {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             total += mn_cost_instr(item)
     |           }
1015 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         total += mn_cost_instr(child)
     |       }
     |   }
     |   total
     | }
     …

     | fn mn_cleanup_body(body : TExpr) -> TExpr {
     |   let reads = mn_collect_read_locals(body)
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let processed = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, i))) => i
     |       Ok(None) => instr
1056 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match processed {
1059 |       TDrop(value) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let effects = mn_collect_effects(value)
     |         if effects.has_unremovable_side_effects() {
1062 |           if processed != instr {
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             change((), processed)
     |           } else {
1065 |             unchanged()
     |             ^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         } else {
1068 |           change((), TInstr::nop())
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1071 |       TLocalSet(idx, value) if !reads.contains(idx) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let effects = mn_collect_effects(value)
     |         if effects.has_unremovable_side_effects() {
1074 |           change((), TInstr::drop(value))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1076 |           change((), TInstr::nop())
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1079 |       TLocalTee(idx, value) if !reads.contains(idx) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let effects = mn_collect_effects(value)
     |         if effects.has_unremovable_side_effects() {
1082 |           change((), value)
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1084 |           change((), TInstr::nop())
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => if processed != instr { change((), processed) } else { unchanged() }
     |     }
     |   })
     |   match walker.walk_texpr((), body) {
     |     Ok(Some((_, out))) => out
1092 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn do_opts(func : Func, mod : Module, params? : Array[ValType] = []) -> Func {
     |   match func {
     |     TFunc(locals, body) => {
     |       let all_locals = params + locals
     |       let ctx = IRContext::new()
     |       ctx.set_mod(mod)
     |       ctx.set_locals(all_locals)
     |       ctx.set_body(body)
     |       let body = match ctx.optimize_body_with_ssa() {
     |         Some(out) => out
1107 |         None => body
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let folded = match
     |         code_folding_pass().walk_func(
     |           CodeFoldingState::new(),
     |           Func::t_func(locals, body),
     |         ) {
     |         Ok(Some((_, out))) => out
1115 |         _ => Func::t_func(locals, body)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match folded {
     |         TFunc(next_locals, next_body) =>
     |           Func::t_func(
     |             next_locals,
     |             mn_cleanup_body(mn_cleanup_body(run_dce_on_texpr(next_body))),
     |           )
1123 |         _ => folded
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1126 |     _ => func
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn eq_call_context(a : MonoCallContext, b : MonoCallContext) -> Bool {
1146 |   a == b
     |   ^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn mn_rewrite_instr(state : MonoRewriteState, instr : TInstr) -> TInstr {
     |   match instr {
     |     TDrop(TCall(target, args)) => {
     |       let rewritten_args : Array[TInstr] = []
     |       for arg in args {
     |         rewritten_args.push(mn_rewrite_instr(state, arg))
     |       }
     |       let call_id = state.next_call_id
     |       state.next_call_id += 1
     |       match state.actions.get(call_id) {
     |         Some(action) =>
     |           if action.dropped {
     |             TInstr::call(action.new_target, action.new_operands)
     |           } else {
     |             TInstr::drop(TInstr::call(action.new_target, action.new_operands))
     |           }
1166 |         None => TInstr::drop(TInstr::call(target, rewritten_args))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TCall(target, args) => {
     |       let rewritten_args : Array[TInstr] = []
     |       for arg in args {
     |         rewritten_args.push(mn_rewrite_instr(state, arg))
     |       }
     |       let call_id = state.next_call_id
     |       state.next_call_id += 1
     |       match state.actions.get(call_id) {
     |         Some(action) => TInstr::call(action.new_target, action.new_operands)
1178 |         None => TInstr::call(target, rewritten_args)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1181 |     TBlock(bt, body) => TInstr::block(bt, mn_rewrite_texpr(state, body))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoop(bt, body) => TInstr::loop_(bt, mn_rewrite_texpr(state, body))
     |     TTryTable(bt, catches, body) =>
1184 |       TInstr::try_table(bt, catches, mn_rewrite_texpr(state, body))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(bt, cond, then_, else_) =>
1186 |       TInstr::if_(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         bt,
1188 |         mn_rewrite_instr(state, cond),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         mn_rewrite_texpr(state, then_),
     |         match else_ {
     |           Some(other) => Some(mn_rewrite_texpr(state, other))
     |           None => None
     |         },
     |       )
     |     _ => {
     |       let rewritten_children : Array[TInstr] = []
     |       for child in eval_children(instr) {
     |         rewritten_children.push(mn_rewrite_instr(state, child))
     |       }
     |       lcs_rebuild_non_control(instr, rewritten_children)
     |     }
     |   }
     | }
     …

     | fn update_call(func : Func, actions : Map[Int, MonoRewriteAction]) -> Func {
     |   if actions.is_empty() {
1217 |     return func
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match func {
     |     TFunc(locals, body) => {
     |       let state = MonoRewriteState::new(actions)
     |       Func::t_func(locals, mn_rewrite_texpr(state, body))
     |     }
1224 |     _ => func
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mn_build_caller_env(mod : Module, caller_abs_idx : Int) -> Env {
     |   let base = Env::new().with_module(mod)
     |   let params = match
     |     base.get_functype_by_funcidx(
     |       FuncIdx::new(caller_abs_idx.reinterpret_as_uint()),
     |     ) {
     |     Some(FuncType(ps, _)) => ps
1236 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let locals = params.copy()
     |   match mn_get_func(mod, caller_abs_idx) {
     |     Some(TFunc(extra, _)) =>
     |       for vt in extra {
1242 |         locals.push(vt)
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1244 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     |   base.with_locals(locals)
     | }
     …

     | fn monomorphize_run(
     |   mod : Module,
     |   options : OptimizeOptions,
     |   always : Bool,
     | ) -> Result[Module, String] {
     |   let mut mod = mod
     |   let imported = mn_count_imported_funcs(mod)
     |   let original_defined_count = match mod.code_sec {
     |     Some(CodeSec(funcs)) => funcs.length()
1259 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if original_defined_count == 0 {
1262 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let return_callers = find_return_callers(mod)
     |   let memo : Map[MonoMemoKey, FuncIdx] = Map::new()
     |   let optimized_original : Set[Int] = Set::new()
     |   for def_idx = 0; def_idx < original_defined_count; def_idx = def_idx + 1 {
     |     let caller_abs_idx = imported + def_idx
     |     let env = Env::new().with_module(mod)
     |     let caller_func = match mn_get_func(mod, caller_abs_idx) {
     |       Some(func) => func
1272 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let calls = find_calls_and_drops(caller_func, caller_abs_idx, env)
     |     if calls.is_empty() {
     |       continue
     |     }
     |     let caller_env = mn_build_caller_env(mod, caller_abs_idx)
     |     let actions : Map[Int, MonoRewriteAction] = Map::new()
     |     for call_info in calls {
     |       if mn_has_unreachable_operand(call_info.args) {
1282 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let FuncIdx(raw_target) = call_info.target
     |       let target_abs_idx = raw_target.reinterpret_as_int()
     |       if target_abs_idx < imported {
     |         continue
     |       }
     |       if target_abs_idx == caller_abs_idx {
     |         continue
     |       }
     |       let target_def_idx = target_abs_idx - imported
     |       let callee_func = match mn_get_func(mod, target_abs_idx) {
     |         Some(func) => func
1295 |         None => continue
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let callee_type = match env.get_functype_by_funcidx(call_info.target) {
     |         Some(ft) => ft
1299 |         None => continue
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let FuncType(callee_params, callee_results) = callee_type
     |       if callee_params.length() != call_info.args.length() {
1303 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let allow_dropped = call_info.dropped &&
     |         !(target_abs_idx >= 0 &&
     |         target_abs_idx < return_callers.length() &&
     |         return_callers[target_abs_idx])
     |       let ctx_build = match
     |         MonoCallContext::build_from_call(call_info, caller_env, allow_dropped) {
     |         Some(build) => build
1312 |         None => continue
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if ctx_build.new_operand_types.length() > MONO_MAX_PARAMS {
     |         continue
     |       }
     |       if ctx_build.context.dropped && callee_results.length() != 1 {
1318 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let key = { target: call_info.target, context: ctx_build.context }
     |       let context_hash = hash_call_context(ctx_build.context)
     |       if context_hash == 0UL &&
     |         !eq_call_context(ctx_build.context, ctx_build.context) {
1324 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if MonoCallContext::is_trivial(
     |           ctx_build.context,
     |           call_info,
     |           callee_params,
     |           caller_env,
     |           ctx_build.new_operands,
     |         ) {
     |         memo[key] = call_info.target
     |         continue
     |       }
     |       match memo.get(key) {
     |         Some(chosen_target) => {
     |           if chosen_target != call_info.target {
     |             actions[call_info.call_id] = {
     |               new_target: chosen_target,
     |               new_operands: ctx_build.new_operands,
     |               dropped: ctx_build.context.dropped,
     |             }
     |           }
     |           continue
     |         }
     |         None => ()
     |       }
     |       if !always && !optimized_original.contains(target_abs_idx) {
     |         let optimized = do_opts(callee_func, mod, params=callee_params)
     |         mod = mn_set_defined_func(mod, target_def_idx, optimized)
     |         optimized_original.add(target_abs_idx)
     |       }
     |       let env_after_opt = Env::new().with_module(mod)
     |       let callee_after_opt = match mn_get_func(mod, target_abs_idx) {
     |         Some(func) => func
1357 |         None => continue
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let callee_type_after_opt = match
     |         env_after_opt.get_functype_by_funcidx(call_info.target) {
     |         Some(ft) => ft
1362 |         None => continue
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mono_func = match
     |         make_mono_function_with_context(
     |           callee_after_opt,
     |           callee_type_after_opt,
     |           ctx_build.context,
     |           ctx_build.new_operand_types,
     |         ) {
     |         Some(func) => func
1372 |         None => {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           memo[key] = call_info.target
     |           continue
     |         }
     |       }
     |       let optimized_mono = if always {
     |         mono_func
     |       } else {
     |         do_opts(mono_func, mod, params=ctx_build.new_operand_types)
     |       }
     |       let should_accept = if always {
     |         true
     |       } else {
     |         let before_body_cost = match
     |           do_opts(callee_after_opt, mod, params=callee_params) {
     |           TFunc(_, body) => cost(body)
1388 |           _ => 0
     |           ^^^^^^ 	<-- UNCOVERED
     |         }
     |         let mut context_cost = 0
     |         for operand in ctx_build.context.operands {
     |           context_cost += mn_cost_instr(operand)
     |         }
     |         let cost_before = before_body_cost + context_cost
     |         let cost_after = match optimized_mono {
     |           TFunc(_, body) => cost(body)
1397 |           _ => cost_before
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if cost_before == 0 {
1400 |           false
     |           ^^^^^ 	<-- UNCOVERED
     |         } else {
     |           let benefit = 100 - 100 * cost_after / cost_before
     |           benefit > options.monomorphize_min_benefit
     |         }
     |       }
     |       if !should_accept {
     |         memo[key] = call_info.target
     |         continue
     |       }
     |       let FuncType(_, callee_results_after_opt) = callee_type_after_opt
     |       let mono_results = if ctx_build.context.dropped {
     |         []
     |       } else {
     |         callee_results_after_opt
     |       }
     |       let (next_mod, mono_target) = mn_append_specialized_function(
     |         mod,
     |         ctx_build.new_operand_types,
     |         mono_results,
     |         optimized_mono,
     |       )
     |       mod = next_mod
     |       memo[key] = mono_target
     |       actions[call_info.call_id] = {
     |         new_target: mono_target,
     |         new_operands: ctx_build.new_operands,
     |         dropped: ctx_build.context.dropped,
     |       }
     |     }
     |     if !actions.is_empty() {
     |       let updated = update_call(caller_func, actions)
     |       mod = mn_set_defined_func(mod, def_idx, updated)
     |     }
     |   }
     |   Ok(mod)
     | }
     …

     | fn mono_run_pass(
     |   mod : Module,
     |   always : Bool,
     |   min_benefit : Int,
     | ) -> Module raise {
     |   let options = OptimizeOptions::new(monomorphize_min_benefit=min_benefit)
     |   let passes = if always {
     |     [ModulePass::MonomorphizeAlways]
     |   } else {
     |     [ModulePass::Monomorphize]
     |   }
     |   match optimize_module_with_options(mod, passes, options) {
     |     Ok(out) => out
1466 |     Err(e) => fail("unexpected monomorphize error: \{e}")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mono_call_targets_in_body(body : TExpr) -> Array[FuncIdx] {
     |   let out : Array[FuncIdx] = []
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     match instr {
     |       TCall(target, _) => out.push(target)
1476 |       TDrop(TCall(target, _)) => out.push(target)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   out
     | }
     …

39 uncovered line(s) in src/passes/once_reduction.mbt:

     | fn or_is_integer_type(t : ValType) -> Bool {
     |   match t {
     |     NumTypeValType(I32NumType) | NumTypeValType(I64NumType) => true
  71 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_is_nonzero_int_const(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(I32(v)) => v > 0
  79 |     TI64Const(I64(v)) => v > 0L
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn or_is_integer_tinstr(instr : TInstr, env : Env) -> Bool {
     |   match lcs_infer_tinstr_type(instr, env) {
     |     Some(t) => or_is_integer_type(t)
  88 |     None => false
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_count_imported_funcs(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
  99 |           Import(_, _, FuncExternType(_)) => n += 1
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn or_count_imported_globals(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, GlobalExternType(_)) => n += 1
 116 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn or_collect_exported_globals(mod : Module) -> Set[GlobalIdx] {
     |   let out : Set[GlobalIdx] = Set::new()
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for ex in exports {
     |         match ex {
     |           Export(_, GlobalExternIdx(idx)) => out.add(idx)
 138 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn or_collect_global_types(mod : Module) -> Array[GlobalType] {
     |   let out : Array[GlobalType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, GlobalExternType(gt)) => out.push(gt)
 154 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for g in globals {
     |         match g {
     |           Global(gt, _) => out.push(gt)
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn or_get_defined_func(mod : Module, abs_func_idx : Int) -> Func? {
     |   let imported = or_count_imported_funcs(mod)
     |   let def_idx = abs_func_idx - imported
     |   if def_idx < 0 {
 176 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) if def_idx < funcs.length() => Some(funcs[def_idx])
 180 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_set_defined_func(mod : Module, def_idx : Int, func : Func) -> Module {
     |   let mut out_mod = mod
     |   match out_mod.code_sec {
     |     Some(CodeSec(funcs)) if def_idx >= 0 && def_idx < funcs.length() => {
     |       let next_funcs = funcs.copy()
     |       next_funcs[def_idx] = func
     |       out_mod = out_mod.with_code_sec(CodeSec::new(next_funcs))
     |       out_mod
     |     }
 194 |     _ => out_mod
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_get_once_global(body : TExpr) -> GlobalIdx? {
     |   match body {
     |     TExpr([TBlock(_, TExpr(items))]) if items.length() >= 2 =>
     |       match items[0] {
     |         TIf(_, TGlobalGet(g0), TExpr([TReturn(ret_vals)]), None) if ret_vals.length() ==
     |           0 =>
     |           match items[1] {
     |             TGlobalSet(g1, value) =>
     |               if g0 == g1 &&
     |                 !is_unreachable_instr(value) &&
     |                 or_is_nonzero_int_const(value) {
     |                 Some(g0)
     |               } else {
 212 |                 None
     |                 ^^^^ 	<-- UNCOVERED
     |               }
 214 |             _ => None
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         _ => None
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn or_scan_instr(
     |   instr : TInstr,
     |   reachable : Bool,
     |   state : ORScanState,
     |   info : OROptInfo,
     | ) -> Unit {
     |   if !reachable {
 235 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   match instr {
     |     TGlobalGet(idx) => or_add_read(state.read_globals, idx)
     |     TGlobalSet(idx, value) => {
     |       if info.once_globals.get(idx).unwrap_or(false) &&
     |         !is_unreachable_instr(value) &&
     |         or_is_integer_tinstr(value, state.env) &&
     |         !or_is_nonzero_int_const(value) {
     |         info.once_globals[idx] = false
     |       }
     |       for child in eval_children(instr) {
     |         or_scan_instr(child, true, state, info)
     |       }
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       or_scan_texpr(body, true, state, info)
     |     TIf(_, cond, then_body, else_body) => {
     |       or_scan_instr(cond, true, state, info)
     |       or_scan_texpr(then_body, true, state, info)
     |       match else_body {
     |         Some(other) => or_scan_texpr(other, true, state, info)
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         or_scan_instr(child, true, state, info)
     |       }
     |   }
     | }
     …

     | fn or_build_func_env(mod : Module, abs_func_idx : Int) -> Env {
     |   let base_env = Env::new().with_module(mod)
     |   let params = match
     |     base_env.get_functype_by_funcidx(
     |       FuncIdx::new(abs_func_idx.reinterpret_as_uint()),
     |     ) {
     |     Some(FuncType(ps, _)) => ps
 294 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let locals = params.copy()
     |   match or_get_defined_func(mod, abs_func_idx) {
     |     Some(TFunc(extra_locals, _)) =>
     |       for t in extra_locals {
 300 |         locals.push(t)
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 302 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     |   base_env.with_locals(locals)
     | }
     …

     | fn or_scan_function(mod : Module, abs_func_idx : Int, info : OROptInfo) -> Unit {
     |   let func_idx = FuncIdx::new(abs_func_idx.reinterpret_as_uint())
     |   let func_type = match
     |     Env::new().with_module(mod).get_functype_by_funcidx(func_idx) {
     |     Some(ft) => ft
 313 |     None => {
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |       info.once_funcs[func_idx] = None
     |       return
     |     }
     |   }
     |   let once_global = match or_get_defined_func(mod, abs_func_idx) {
     |     Some(TFunc(_, body)) =>
     |       match func_type {
     |         FuncType(params, results) if params.length() == 0 &&
     |           results.length() == 0 => or_get_once_global(body)
     |         _ => None
     |       }
 325 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   info.once_funcs[func_idx] = once_global
     |   match or_get_defined_func(mod, abs_func_idx) {
     |     Some(TFunc(_, body)) => {
     |       let state = {
     |         env: or_build_func_env(mod, abs_func_idx),
     |         read_globals: Map::new(),
     |       }
     |       or_scan_texpr(body, true, state, info)
     |       match once_global {
     |         Some(g) => {
     |           let count = state.read_globals.get(g).unwrap_or(0)
     |           if count > 0 {
     |             state.read_globals[g] = count - 1
     |           }
     |         }
     |         None => ()
     |       }
     |       for entry in state.read_globals {
     |         let (g, count) = entry
     |         if count > 0 {
     |           info.once_globals[g] = false
     |         }
     |       }
     |     }
 351 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_lower_texpr(
     |   body : TExpr,
     |   start : ORBlockId,
     |   state : ORBuildState,
     | ) -> ORBlockId {
     |   let mut current = start
     |   for instr in body.0 {
     |     match instr {
     |       TIf(_, _, then_body, else_body) => {
     |         let then_block = or_make_block(state)
     |         let else_block = or_make_block(state)
     |         let merge_block = or_make_block(state)
     |         or_add_edge(state, current, then_block)
     |         or_add_edge(state, current, else_block)
     |         let then_end = or_lower_texpr(then_body, then_block, state)
     |         or_add_edge(state, then_end, merge_block)
     |         match else_body {
     |           Some(other) => {
     |             let else_end = or_lower_texpr(other, else_block, state)
     |             or_add_edge(state, else_end, merge_block)
     |           }
 434 |           None => or_add_edge(state, else_block, merge_block)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         current = merge_block
     |       }
 438 |       TReturn(_) => return current
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => or_record_side_effect_event(state, current, instr)
     |     }
     |   }
     |   current
     | }
     …

     | fn or_compute_dominators(cfg : ORCFG) -> Map[ORBlockId, ORBlockId] {
     |   let rpo = or_compute_rpo(cfg)
     |   let idom : Map[ORBlockId, ORBlockId?] = Map::new()
     |   for entry in cfg.blocks {
     |     let (block_id, _) = entry
     |     idom[block_id] = None
     |   }
     |   idom[cfg.entry] = Some(cfg.entry)
     |   let mut changed = true
     |   while changed {
     |     changed = false
     |     for block_id in rpo {
     |       if block_id == cfg.entry {
     |         continue
     |       }
     |       let preds = cfg.preds
     |         .get(block_id)
     |         .unwrap_or([])
     |         .filter(p => idom[p] is Some(_))
     |       if preds.is_empty() {
 543 |         continue
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut new_idom = preds[0]
     |       for pred in preds.op_as_view(start=1, end=preds.length()) {
     |         new_idom = or_intersect(idom, pred, new_idom)
     |       }
     |       if idom[block_id] != Some(new_idom) {
     |         idom[block_id] = Some(new_idom)
     |         changed = true
     |       }
     |     }
     |   }
     |   let out : Map[ORBlockId, ORBlockId] = Map::new()
     |   for entry in idom {
     |     let (block_id, dom) = entry
     |     match dom {
     |       Some(d) => out[block_id] = d
 560 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn or_rewrite_instr(state : ORRewriteState, instr : TInstr) -> TInstr {
     |   match instr {
     |     TGlobalSet(_, _) | TCall(_, _) => {
     |       let event_id = state.next_event
     |       state.next_event += 1
     |       if state.nops.contains(event_id) {
     |         TInstr::nop()
     |       } else {
     |         instr
     |       }
     |     }
 578 |     TBlock(bt, body) => TInstr::block(bt, or_rewrite_texpr(state, body))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoop(bt, body) => TInstr::loop_(bt, or_rewrite_texpr(state, body))
     |     TTryTable(bt, catches, body) =>
 581 |       TInstr::try_table(bt, catches, or_rewrite_texpr(state, body))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(bt, cond, then_body, else_body) =>
 583 |       TInstr::if_(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         bt,
     |         cond,
 586 |         or_rewrite_texpr(state, then_body),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         else_body.map(e => or_rewrite_texpr(state, e)),
     |       )
     |     _ => instr
     |   }
     | }
     …

     | fn or_optimize_function(
     |   func_idx : FuncIdx,
     |   func : Func,
     |   info : OROptInfo,
     | ) -> OROptimizeResult {
     |   let original_summary = or_copy_global_set(
     |     info.once_globals_set_in_funcs.get(func_idx).unwrap_or(Set::new()),
     |   )
     |   match func {
     |     TFunc(locals, body) => {
     |       let cfg = or_build_cfg(body)
     |       let idom = or_compute_dominators(cfg)
     |       let rpo = or_compute_rpo(cfg)
     |       let end_written : Map[ORBlockId, Set[GlobalIdx]] = Map::new()
     |       let nops : Set[Int] = Set::new()
     |       for block_id in rpo {
     |         let current = if block_id == cfg.entry {
     |           Set::new()
     |         } else {
     |           match idom.get(block_id) {
     |             Some(dom) =>
     |               or_copy_global_set(end_written.get(dom).unwrap_or(Set::new()))
 625 |             None => Set::new()
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         let block = cfg.blocks[block_id]
     |         for event_id in block.events {
     |           match cfg.events[event_id] {
     |             GlobalSet(g, writes_nonzero_const) =>
     |               if writes_nonzero_const &&
     |                 info.once_globals.get(g).unwrap_or(false) {
     |                 if current.contains(g) {
     |                   nops.add(event_id)
     |                 } else {
     |                   current.add(g)
     |                 }
     |               }
     |             Call(callee, arg_count) => {
     |               if arg_count == 0 {
     |                 match info.once_funcs.get(callee).unwrap_or(None) {
     |                   Some(g) =>
     |                     if current.contains(g) {
     |                       nops.add(event_id)
     |                     } else {
     |                       current.add(g)
     |                     }
     |                   None => ()
     |                 }
     |               }
     |               for
     |                 g in info.once_globals_set_in_funcs
     |                 .get(callee)
     |                 .unwrap_or(Set::new()) {
     |                 current.add(g)
     |               }
     |             }
     |           }
     |         }
     |         end_written[block_id] = current
     |       }
     |       let summary = or_copy_global_set(
     |         end_written.get(cfg.entry).unwrap_or(Set::new()),
     |       )
     |       match info.once_funcs.get(func_idx).unwrap_or(None) {
     |         Some(g) => summary.add(g)
     |         None => ()
     |       }
     |       let merged_summary = original_summary
     |       for g in summary {
     |         merged_summary.add(g)
     |       }
     |       let rewritten = if nops.is_empty() {
     |         Func::t_func(locals, body)
     |       } else {
     |         Func::t_func(locals, or_rewrite_texpr(ORRewriteState::new(nops), body))
     |       }
     |       { func: rewritten, summary: merged_summary }
     |     }
 681 |     _ => { func, summary: original_summary }
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_match_guard_if(instr : TInstr) -> GlobalIdx? {
     |   match instr {
     |     TIf(_, TGlobalGet(g), TExpr([TReturn(values)]), None) if values.length() ==
     |       0 => Some(g)
 690 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_match_once_set(instr : TInstr, g : GlobalIdx) -> Bool {
     |   match instr {
     |     TGlobalSet(g2, value) =>
     |       g2 == g && !is_unreachable_instr(value) && or_is_nonzero_int_const(value)
 699 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn or_cleanup_once_bodies(mod : Module, info : OROptInfo) -> Module {
     |   let mut mod = mod
     |   let removed_exit_logic : Set[FuncIdx] = Set::new()
     |   let imported = or_count_imported_funcs(mod)
     |   let defined_count = match mod.code_sec {
     |     Some(CodeSec(funcs)) => funcs.length()
 710 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for def_idx = 0; def_idx < defined_count; def_idx = def_idx + 1 {
     |     let abs_idx = imported + def_idx
     |     let curr_idx = FuncIdx::new(abs_idx.reinterpret_as_uint())
     |     let once_global = info.once_funcs.get(curr_idx).unwrap_or(None)
     |     if once_global is None {
     |       continue
     |     }
     |     let g = match once_global {
     |       Some(g) => g
 721 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let func = match or_get_defined_func(mod, abs_idx) {
     |       Some(f) => f
 725 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match func {
     |       TFunc(locals, TExpr([TBlock(bt, TExpr(items))])) =>
     |         if items.length() == 2 &&
     |           or_match_guard_if(items[0]) == Some(g) &&
     |           or_match_once_set(items[1], g) {
     |           mod = or_set_defined_func(
     |             mod,
     |             def_idx,
     |             Func::t_func(locals, TExpr::new([TInstr::nop()])),
     |           )
     |         } else if items.length() == 3 &&
     |           or_match_guard_if(items[0]) == Some(g) &&
     |           or_match_once_set(items[1], g) {
     |           match items[2] {
     |             TCall(callee, args) =>
     |               if args.length() == 0 &&
     |                 callee != curr_idx &&
     |                 info.once_funcs.get(callee).unwrap_or(None) is Some(_) &&
     |                 !removed_exit_logic.contains(callee) {
     |                 let next_items = items.copy()
     |                 next_items[0] = TInstr::nop()
     |                 next_items[1] = TInstr::nop()
     |                 mod = or_set_defined_func(
     |                   mod,
     |                   def_idx,
     |                   Func::t_func(
     |                     locals,
     |                     TExpr::new([TInstr::block(bt, TExpr::new(next_items))]),
     |                   ),
     |                 )
     |                 removed_exit_logic.add(curr_idx)
     |               }
     |             _ => ()
     |           }
     |         }
 762 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   mod
     | }
     …

     | fn once_reduction(mod : Module) -> Result[Module, String] {
     |   let mut mod = mod
     |   let info = {
     |     once_globals: Map::new(),
     |     once_funcs: Map::new(),
     |     once_globals_set_in_funcs: Map::new(),
     |   }
     |   let total_funcs = or_total_funcs(mod)
     |   for i = 0; i < total_funcs; i = i + 1 {
     |     let func_idx = FuncIdx::new(i.reinterpret_as_uint())
     |     info.once_funcs[func_idx] = None
     |     info.once_globals_set_in_funcs[func_idx] = Set::new()
     |   }
     |   let exported_globals = or_collect_exported_globals(mod)
     |   let global_types = or_collect_global_types(mod)
     |   let imported_globals = or_count_imported_globals(mod)
     |   for i = 0; i < global_types.length(); i = i + 1 {
     |     let GlobalType(val_type, mutable) = global_types[i]
     |     let idx = GlobalIdx::new(i.reinterpret_as_uint())
     |     let imported = i < imported_globals
     |     let exported = exported_globals.contains(idx)
     |     info.once_globals[idx] = mutable &&
     |       or_is_integer_type(val_type) &&
     |       !imported &&
     |       !exported
     |   }
     |   let imported_funcs = or_count_imported_funcs(mod)
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
     |         or_scan_function(mod, imported_funcs + def_idx, info)
     |       }
 801 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for entry in info.once_funcs {
     |     let (func_idx, once_global) = entry
     |     match once_global {
     |       Some(g) =>
     |         if !info.once_globals.get(g).unwrap_or(false) {
     |           info.once_funcs[func_idx] = None
     |         } else {
     |           info.once_globals_set_in_funcs[func_idx].add(g)
     |         }
     |       None => ()
     |     }
     |   }
     |   let mut has_once_func = false
     |   for entry in info.once_funcs {
     |     let (_, once_global) = entry
     |     if once_global is Some(_) {
     |       has_once_func = true
     |       break
     |     }
     |   }
     |   if !has_once_func {
     |     return Ok(mod)
     |   }
     |   let mut prev_total = -1
     |   while true {
     |     let new_sets : Map[FuncIdx, Set[GlobalIdx]] = Map::new()
     |     for i = 0; i < total_funcs; i = i + 1 {
     |       let func_idx = FuncIdx::new(i.reinterpret_as_uint())
     |       new_sets[func_idx] = or_copy_global_set(
     |         info.once_globals_set_in_funcs.get(func_idx).unwrap_or(Set::new()),
     |       )
     |     }
     |     let defined_count = match mod.code_sec {
     |       Some(CodeSec(funcs)) => funcs.length()
 837 |       None => 0
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     for def_idx = 0; def_idx < defined_count; def_idx = def_idx + 1 {
     |       let abs_idx = imported_funcs + def_idx
     |       let func_idx = FuncIdx::new(abs_idx.reinterpret_as_uint())
     |       let func = match or_get_defined_func(mod, abs_idx) {
     |         Some(f) => f
 844 |         None => continue
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let result = or_optimize_function(func_idx, func, info)
     |       mod = or_set_defined_func(mod, def_idx, result.func)
     |       new_sets[func_idx] = result.summary
     |     }
     |     info.once_globals_set_in_funcs = new_sets
     |     let mut total = 0
     |     for entry in info.once_globals_set_in_funcs {
     |       let (_, set_) = entry
     |       total += set_.length()
     |     }
     |     if total <= prev_total {
     |       break
     |     }
     |     prev_total = total
     |   }
     |   Ok(or_cleanup_once_bodies(mod, info))
     | }
     …

     | fn or_run(mod : Module) -> Module raise {
     |   match optimize_module(mod, [ModulePass::OnceReduction]) {
     |     Ok(out) => out
 873 |     Err(e) => fail("unexpected once_reduction error: \{e}")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

41 uncovered line(s) in src/passes/optimize.mbt:

     | fn[T] apply_transformer_pass(
     |   state : T,
     |   mod : Module,
     |   pass : ModuleTransformer[T],
     | ) -> Result[Module, String] {
     |   match pass.walk_module(state, mod) {
     |     Ok(Some((_, new_mod))) => Ok(new_mod)
 158 |     Ok(None) => Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn run_ir_context_transformer_scheduler_pass(
     |   ctx : IRContext,
     |   mod : Module,
     |   pass : ModulePass,
     |   options : OptimizeOptions,
     | ) -> Result[Module, String] {
     |   match pass {
     |     AbstractTypeRefining(props) =>
 234 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 237 |         abstract_type_refining(mod, props.traps_never_happen),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     AlignmentLowering =>
 240 |       apply_ir_transformer_pass(ctx, mod, alignment_lowering_pass(mod))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AvoidReinterprets =>
     |       apply_ir_transformer_pass(ctx, mod, avoid_reinterprets_pass(mod))
     |     CoalesceLocals =>
 244 |       apply_ir_transformer_pass(ctx, mod, coalesce_locals_pass(mod))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CodeFolding =>
 246 |       apply_ir_transformer_pass(ctx, mod, code_folding_ir_pass(mod))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CodePushing =>
 248 |       apply_ir_transformer_pass(ctx, mod, code_pushing_ir_pass(mod))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ConstHoisting =>
 250 |       apply_ir_transformer_pass(ctx, mod, const_hoisting_ir_pass(mod))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ConstantFieldPropagation =>
 252 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 255 |         constant_field_propagation_ir_pass(mod),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     DataflowOptimization =>
     |       apply_ir_transformer_pass(ctx, mod, dataflow_optimization_pass(mod))
     |     DeadArgumentElimination =>
     |       apply_ir_transformer_pass(ctx, mod, dead_argument_elim_pass(mod))
     |     SignaturePruning =>
     |       apply_ir_transformer_pass(ctx, mod, signature_pruning_ir_pass(mod))
     |     SimplifyGlobals =>
     |       apply_ir_transformer_pass(ctx, mod, simplify_globals_ir_pass(mod, false))
     |     SimplifyGlobalsOptimizing =>
 266 |       apply_ir_transformer_pass(ctx, mod, simplify_globals_ir_pass(mod, true))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PropagateGlobalsGlobally =>
 268 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 271 |         propagate_globals_globally_ir_pass(mod),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     Heap2Local => apply_ir_transformer_pass(ctx, mod, heap2local_ir_pass(mod))
     |     HeapStoreOptimization =>
     |       apply_ir_transformer_pass(ctx, mod, heap_store_optimization_ir_pass(mod))
     |     LocalCSE =>
     |       apply_ir_transformer_pass(ctx, mod, local_cse_ir_pass(mod, options))
     |     LoopInvariantCodeMotion =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         loop_invariant_code_motion_ir_pass(mod),
     |       )
     |     MergeLocals =>
     |       apply_ir_transformer_pass(ctx, mod, merge_locals_ir_pass(mod, options~))
     |     MergeBlocks =>
     |       apply_ir_transformer_pass(ctx, mod, merge_blocks_ir_pass(mod, options~))
     |     OptimizeAddedConstants =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         optimize_added_constants_ir_pass(mod, options, false),
     |       )
     |     OptimizeAddedConstantsPropagate =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         optimize_added_constants_ir_pass(mod, options, true),
     |       )
     |     OptimizeInstructions =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         optimize_instructions_ir_pass(mod, options),
     |       )
     |     Precompute =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         precompute_ir_pass(mod, options, false),
     |       )
     |     PrecomputePropagate =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         precompute_ir_pass(mod, options, true),
     |       )
     |     RedundantSetElimination =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         redundant_set_elimination_ir_pass(mod),
     |       )
     |     PickLoadSigns =>
     |       apply_ir_transformer_pass(ctx, mod, pick_load_signs_ir_pass(mod))
     |     GUFA => apply_ir_transformer_pass(ctx, mod, gufa_ir_pass(mod, false))
     |     GUFAOptimizing =>
     |       match apply_ir_transformer_pass(ctx, mod, gufa_ir_pass(mod, false)) {
     |         Ok(gufa_mod) => {
     |           let after_dce = match
     |             apply_unit_transformer_pass(gufa_mod, dead_code_elimination_pass()) {
     |             Ok(new_mod) => new_mod
 333 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           ctx.set_mod(after_dce)
     |           apply_ir_transformer_pass(
     |             ctx,
     |             after_dce,
     |             code_folding_ir_pass(after_dce),
     |           )
     |         }
 342 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     GUFACastAll => apply_ir_transformer_pass(ctx, mod, gufa_ir_pass(mod, true))
     |     Directize(initial_immutable) =>
 346 |       match directize_ir_pass(mod, initial_immutable) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(ir_pass) => apply_ir_transformer_pass(ctx, mod, ir_pass)
     |         Err(e) => Err(e)
     |       }
     |     OptimizeCasts =>
 351 |       apply_ir_transformer_pass(ctx, mod, optimize_casts_ir_pass(mod))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RemoveUnusedNames =>
     |       apply_ir_transformer_pass(ctx, mod, remove_unused_names_ir_pass(mod))
     |     SimplifyLocals =>
     |       apply_ir_transformer_pass(
     |         ctx,
     |         mod,
     |         simplify_locals_ir_pass(mod, true, true, true),
     |       )
     |     SimplifyLocalsNoTee =>
 361 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 364 |         simplify_locals_ir_pass(mod, false, true, true),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     SimplifyLocalsNoStructure =>
 367 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 370 |         simplify_locals_ir_pass(mod, true, false, true),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     SimplifyLocalsNoTeeNoStructure =>
 373 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 376 |         simplify_locals_ir_pass(mod, false, false, true),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     SimplifyLocalsNoNesting =>
 379 |       apply_ir_transformer_pass(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ctx,
     |         mod,
 382 |         simplify_locals_ir_pass(mod, false, false, false),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     Untee => apply_ir_transformer_pass(ctx, mod, untee_ir_pass(mod))
     |     Vacuum => apply_ir_transformer_pass(ctx, mod, vacuum_ir_pass(mod))
     |     ReorderLocals =>
     |       apply_ir_transformer_pass(ctx, mod, reorder_locals_ir_pass(mod))
     |     ReorderGlobals =>
 389 |       apply_ir_transformer_pass(ctx, mod, reorder_globals_ir_pass(mod, false))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ReorderGlobalsAlways =>
     |       apply_ir_transformer_pass(ctx, mod, reorder_globals_ir_pass(mod, true))
 392 |     _ => Err("optimize scheduler bug: expected IRContext transformer pass")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn run_unit_transformer_scheduler_pass(
     |   mod : Module,
     |   pass : ModulePass,
     | ) -> Result[Module, String] {
     |   match pass {
     |     DeadCodeElimination =>
     |       apply_unit_transformer_pass(mod, dead_code_elimination_pass())
 404 |     _ => Err("optimize scheduler bug: expected Unit transformer pass")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn run_module_runner_scheduler_pass(
     |   mod : Module,
     |   pass : ModulePass,
     |   options : OptimizeOptions,
     | ) -> Result[Module, String] {
     |   match pass {
     |     SignatureRefining =>
     |       apply_module_runner_pass(mod, fn(mod) { signature_refining(mod) })
     |     DuplicateImportElimination =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         duplicate_import_elimination(mod)
     |       })
     |     GlobalRefining =>
     |       apply_module_runner_pass(mod, fn(mod) { global_refining(mod) })
     |     GlobalStructInference =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         run_global_struct_inference(mod, false)
     |       })
     |     GlobalStructInferenceDescCast =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         run_global_struct_inference(mod, true)
     |       })
     |     GlobalTypeOptimization =>
     |       apply_module_runner_pass(mod, fn(mod) { global_type_optimization(mod) })
     |     TypeRefining =>
     |       apply_module_runner_pass(mod, fn(mod) { type_refining(mod) })
     |     Inlining =>
     |       apply_module_runner_pass(mod, fn(mod) { inlining(mod, options, false) })
     |     InliningOptimizing =>
 438 |       apply_module_runner_pass(mod, fn(mod) { inlining(mod, options, true) })
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     InlineMain =>
     |       apply_module_runner_pass(mod, fn(mod) { inline_main(mod, options) })
     |     LocalSubtyping =>
     |       apply_module_runner_pass(mod, fn(mod) { local_subtyping(mod) })
     |     MergeSimilarFunctions =>
     |       apply_module_runner_pass(mod, fn(mod) { merge_similar_functions(mod) })
     |     OnceReduction =>
     |       apply_module_runner_pass(mod, fn(mod) { once_reduction(mod) })
     |     Asyncify(props) =>
 448 |       apply_module_runner_pass(mod, fn(mod) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         asyncify(mod, props~, optimize_level=options.optimize_level)
     |       })
     |     MinimizeRecGroups =>
     |       apply_module_runner_pass(mod, fn(mod) { minimize_rec_groups(mod) })
     |     Monomorphize =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         monomorphize(mod, options~, always=false)
     |       })
     |     MonomorphizeAlways =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         monomorphize(mod, options~, always=true)
     |       })
     |     MemoryPacking(props) =>
     |       apply_module_runner_pass(mod, fn(mod) { memory_packing(mod, props) })
     |     I64ToI32Lowering =>
     |       apply_module_runner_pass(mod, fn(mod) { i64_to_i32_lowering(mod) })
     |     DuplicateFunctionElimination =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         duplicate_function_elimination(mod, options)
     |       })
     |     DeNaN => apply_module_runner_pass(mod, fn(mod) { run_denam(mod) })
     |     RemoveUnusedBrs =>
     |       apply_module_runner_pass(mod, fn(mod) { remove_unused_brs(mod, options~) })
     |     ReorderTypes =>
     |       apply_module_runner_pass(mod, fn(mod) { reorder_types(mod) })
     |     ReorderFunctions =>
     |       apply_module_runner_pass(mod, fn(mod) { reorder_functions(mod) })
     |     ReorderFunctionsByName =>
 477 |       apply_module_runner_pass(mod, fn(mod) { reorder_functions_by_name(mod) })
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RemoveUnusedTypes =>
     |       apply_module_runner_pass(mod, fn(mod) { remove_unused_types(mod) })
     |     RemoveUnused =>
     |       apply_module_runner_pass(mod, fn(mod) { remove_unused(mod) })
     |     RemoveUnusedModuleElements =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         remove_unused_non_function_elements(mod)
     |       })
     |     RemoveUnusedNonFunctionElements =>
     |       apply_module_runner_pass(mod, fn(mod) {
     |         remove_unused_non_function_elements(mod)
     |       })
 490 |     _ => Err("optimize scheduler bug: expected module-runner pass")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn optimize_module_with_options(
     |   mod : Module,
     |   passes : Array[ModulePass],
     |   options : OptimizeOptions,
     | ) -> Result[Module, String] {
     |   let mut mod = mod
     |   let ctx = IRContext::new()
     |   ctx.set_mod(mod)
     |   mod = match apply_unit_transformer_pass(mod, lift_to_texpr_pass()) {
     |     Ok(new_mod) => new_mod
 513 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   ctx.set_mod(mod)
     |   for pass in passes {
     |     ctx.set_mod(mod)
     |     mod = match module_pass_context_kind(pass) {
     |       IRContextTransformerPass =>
     |         match
     |           run_ir_context_transformer_scheduler_pass(ctx, mod, pass, options) {
     |           Ok(new_mod) => new_mod
     |           Err(e) => return Err(e)
     |         }
     |       UnitTransformerPass =>
     |         match run_unit_transformer_scheduler_pass(mod, pass) {
     |           Ok(new_mod) => new_mod
 528 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       ModuleRunnerPass =>
     |         match run_module_runner_scheduler_pass(mod, pass, options) {
     |           Ok(new_mod) => new_mod
 533 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |     }
     |     ctx.set_mod(mod)
     |   }
     |   Ok(mod)
     | }
     …

     | fn default_opts_has_gc_aggregates(mod : Module) -> Bool {
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) => {
     |       for rec in recs {
     |         match rec {
     |           SingleRecType(st) =>
     |             match st.get_comptype() {
     |               StructCompType(_) | ArrayCompType(_) => return true
     |               _ => ()
     |             }
     |           GroupRecType(sts) =>
 553 |             for st in sts {
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match st.get_comptype() {
     |                 StructCompType(_) | ArrayCompType(_) => return true
     |                 _ => ()
     |               }
     |             }
     |         }
     |       }
     |       false
     |     }
     |     None => false
     |   }
     | }
     …

     | fn default_opts_has_multivalue(mod : Module) -> Bool {
     |   match mod.type_sec {
     |     Some(TypeSec(recs)) => {
     |       for rec in recs {
     |         match rec {
     |           SingleRecType(st) =>
     |             match st.get_comptype() {
     |               FuncCompType(_, results) if results.length() > 1 => return true
     |               _ => ()
     |             }
     |           GroupRecType(sts) =>
 579 |             for st in sts {
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match st.get_comptype() {
     |                 FuncCompType(_, results) if results.length() > 1 => return true
     |                 _ => ()
     |               }
     |             }
     |         }
     |       }
     |       false
     |     }
     |     None => false
     |   }
     | }
     …

     | pub fn default_function_optimization_passes(
     |   mod : Module,
     |   options : OptimizeOptions,
     | ) -> Array[ModulePass] {
     |   // Intentionally mirrors Binaryen's no-DWARF path.
     |   let has_gc = default_opts_has_gc_aggregates(mod)
     |   let has_multivalue = default_opts_has_multivalue(mod)
     |   let passes : Array[ModulePass] = []
     | 
     |   if options.optimize_level >= 3 || options.shrink_level >= 1 {
     |     // Binaryen parity mode: ssa-nomerge.
     |     // Fallback to SSA dataflow simplification in this IR pipeline.
     |     passes.push(DataflowOptimization)
     |   }
     |   if options.optimize_level >= 4 {
     |     // Binaryen parity mode: flatten.
     |     passes.push(SimplifyLocalsNoTeeNoStructure)
     |     passes.push(LocalCSE)
     |     // Binaryen parity mode: rereloop.
     |     // Run an early structural merge step to re-canonicalize control flow.
     |     passes.push(MergeBlocks)
     |   }
     | 
     |   passes.push(DeadCodeElimination)
     |   passes.push(RemoveUnusedNames)
     |   passes.push(RemoveUnusedBrs)
     |   passes.push(RemoveUnusedNames)
     |   passes.push(OptimizeInstructions)
     |   if has_gc {
     |     passes.push(HeapStoreOptimization)
     |   }
     |   if options.optimize_level >= 2 || options.shrink_level >= 2 {
     |     passes.push(PickLoadSigns)
     |   }
     |   if options.optimize_level >= 3 || options.shrink_level >= 2 {
     |     passes.push(PrecomputePropagate)
     |   } else {
     |     passes.push(Precompute)
     |   }
     |   if options.low_memory_unused {
     |     if options.optimize_level >= 3 || options.shrink_level >= 1 {
     |       passes.push(OptimizeAddedConstantsPropagate)
     |     } else {
 637 |       passes.push(OptimizeAddedConstants)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if options.optimize_level >= 2 || options.shrink_level >= 2 {
     |     passes.push(CodePushing)
     |   }
     |   if has_multivalue {
     |     // Binaryen parity mode: tuple-optimization.
     |     // Reuse SSA dataflow simplification as the current tuple-aware fallback.
     |     passes.push(DataflowOptimization)
     |   }
     |   passes.push(SimplifyLocalsNoStructure)
     |   passes.push(Vacuum)
     |   passes.push(ReorderLocals)
     |   passes.push(RemoveUnusedBrs)
     |   if options.optimize_level > 1 && has_gc {
     |     passes.push(Heap2Local)
     |   }
     |   if options.optimize_level >= 3 || options.shrink_level >= 2 {
     |     passes.push(MergeLocals)
     |   }
     |   if options.optimize_level > 1 && has_gc {
     |     passes.push(OptimizeCasts)
     |     passes.push(LocalSubtyping)
     |   }
     |   passes.push(CoalesceLocals)
     |   if options.optimize_level >= 3 || options.shrink_level >= 1 {
     |     passes.push(LocalCSE)
     |   }
     |   passes.push(SimplifyLocals)
     |   passes.push(Vacuum)
     |   passes.push(ReorderLocals)
     |   passes.push(CoalesceLocals)
     |   passes.push(ReorderLocals)
     |   passes.push(Vacuum)
     |   if options.optimize_level >= 3 || options.shrink_level >= 1 {
     |     passes.push(CodeFolding)
     |   }
     |   passes.push(MergeBlocks)
     |   passes.push(RemoveUnusedBrs)
     |   passes.push(RemoveUnusedNames)
     |   passes.push(MergeBlocks)
     |   if options.optimize_level >= 3 || options.shrink_level >= 2 {
     |     passes.push(PrecomputePropagate)
     |   } else {
     |     passes.push(Precompute)
     |   }
     |   passes.push(OptimizeInstructions)
     |   if has_gc {
     |     passes.push(HeapStoreOptimization)
     |   }
     |   if options.optimize_level >= 2 || options.shrink_level >= 1 {
     |     passes.push(RedundantSetElimination)
     |   }
     |   passes.push(Vacuum)
     |   passes
     | }
     …

     | fn opt_scheduler_func_count(mod : Module) -> Int {
     |   match mod.func_sec {
     |     Some(FuncSec(funcs)) => funcs.length()
 821 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn opt_scheduler_global_count(mod : Module) -> Int {
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) => globals.length()
 829 |     None => 0
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn assert_pass_context_kind(
     |   pass : ModulePass,
     |   expected : SchedulerPassContextKind,
     | ) -> Bool {
     |   match (module_pass_context_kind(pass), expected) {
     |     (IRContextTransformerPass, IRContextTransformerPass)
     |     | (UnitTransformerPass, UnitTransformerPass)
     |     | (ModuleRunnerPass, ModuleRunnerPass) => true
 842 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

60 uncovered line(s) in src/passes/optimize_added_constants.mbt:

     | fn GetParents::new(body : TExpr) -> GetParents {
     |   let parent_map = Map::new()
     |   let parent_stack : Array[TInstr] = []
     |   let next_get_id = Ref::new(0)
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
     |       TLocalGet(_) =>
     |         match parent_stack.last() {
     |           Some(parent) => {
     |             parent_map[next_get_id.val] = parent
     |             next_get_id.update(fn(n) { n + 1 })
     |           }
  22 |           None => abort("GetParents expected local.get to have a parent")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |     parent_stack.push(curr)
     |     let out = self.walk_tinstruction_default((), curr)
     |     ignore(parent_stack.pop())
     |     out
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   GetParents::{ parent_map, }
     | }
     …

     | fn GetParents::get_parent(self : GetParents, get_id : Int) -> TInstr {
     |   match self.parent_map.get(get_id) {
     |     Some(parent) => parent
  39 |     None => abort("GetParents missing parent mapping for local.get")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oac_build_set_influences(
     |   graph : LocalGraph,
     |   get_count : Int,
     | ) -> Map[OACSetKey, Array[Int]] {
     |   let out : Map[OACSetKey, Array[Int]] = Map::new()
     |   for get_id in 0..<get_count {
     |     let sets = graph.get_sets(get_id)
     |     for set_ in sets {
     |       match set_ {
     |         LocalSet::Set(local_idx, root) => {
     |           let key : OACSetKey = { local_idx, root }
     |           let influences = out.get(key).unwrap_or([])
     |           influences.push(get_id)
     |           out[key] = influences
     |         }
 133 |         LocalSet::InitValue => ()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn oac_collect_tee_locals(body : TExpr) -> Set[LocalIdx] {
     |   let out = Set::new()
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
 158 |       TLocalTee(local_idx, _) => out.add(local_idx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), curr)
     |   })
     |   ignore(walker.walk_texpr((), body))
     |   out
     | }
     …

     | fn oac_is_add(op : BinaryOp) -> Bool {
     |   match op {
     |     I32AddOp | I64AddOp => true
 216 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oac_is_i32_add(op : BinaryOp) -> Bool {
     |   match op {
     |     I32AddOp => true
 224 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oac_const_to_u64(instr : TInstr) -> UInt64? {
     |   match instr {
     |     TI32Const(I32(v)) => Some(v.reinterpret_as_uint().to_uint64())
 232 |     TI64Const(I64(v)) => Some(v.reinterpret_as_uint64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn oac_default_memory64(mod : Module) -> Bool {
     |   match mod.mem_sec {
     |     Some(MemSec(memories)) =>
     |       match memories.get(0) {
     |         Some(MemType(I64Limits(_))) => true
     |         _ => false
     |       }
 257 |     None => false
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oac_memory_is_64(mod : Module, memarg : MemArg) -> Bool {
     |   let MemArg(_, mem_idx, _) = memarg
     |   match mem_idx {
     |     Some(MemIdx(raw)) =>
 266 |       match mod.mem_sec {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(MemSec(memories)) =>
 268 |           match memories.get(raw.reinterpret_as_int()) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(MemType(I64Limits(_))) => true
     |             _ => false
     |           }
 272 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => oac_default_memory64(mod)
     |   }
     | }
     …

     | fn oac_get_helper_index(
     |   state : OACIterationState,
     |   set_ : OACSetKey,
     | ) -> LocalIdx {
     |   match state.helper_indexes.get(set_) {
 316 |     Some(idx) => idx
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => {
     |       let next_idx = LocalIdx::new(state.locals.length().reinterpret_as_uint())
     |       state.locals.push(ValType::i32())
     |       state.helper_indexes[set_] = next_idx
     |       next_idx
     |     }
     |   }
     | }
     …

     | fn oac_local_is_ssa(state : OACIterationState, local_idx : LocalIdx) -> Bool {
     |   match state.ssa_cache.get(local_idx) {
 329 |     Some(cached) => cached
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => {
     |       let computed = match (state.local_graph, state.ssa_info) {
     |         (Some(graph), Some(info)) =>
     |           if info.tee_locals.contains(local_idx) {
 334 |             false
     |             ^^^^^ 	<-- UNCOVERED
     |           } else if info.set_counts.get(local_idx).unwrap_or(0) > 1 {
     |             false
     |           } else {
     |             let get_ids = info.local_get_ids.get(local_idx).unwrap_or([])
     |             if get_ids.is_empty() {
 340 |               false
     |               ^^^^^ 	<-- UNCOVERED
     |             } else {
     |               let seen = Set::new()
     |               let mut ok = true
     |               for get_id in get_ids {
     |                 let sets = graph.get_sets(get_id)
     |                 if sets.length() != 1 {
 347 |                   ok = false
     |                   ^^^^^^^^^^ 	<-- UNCOVERED
     |                   break
     |                 }
     |                 let set_key = sets.to_array()[0]
     |                 match set_key {
     |                   LocalSet::Set(set_local, _) => {
     |                     if set_local != local_idx {
 354 |                       ok = false
     |                       ^^^^^^^^^^ 	<-- UNCOVERED
     |                       break
     |                     }
     |                     seen.add(set_key)
     |                     if seen.length() > 1 {
 359 |                       ok = false
     |                       ^^^^^^^^^^ 	<-- UNCOVERED
     |                       break
     |                     }
     |                   }
 363 |                   LocalSet::InitValue => {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     ok = false
     |                     break
     |                   }
     |                 }
     |               }
     |               ok
     |             }
     |           }
 372 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       state.ssa_cache[local_idx] = computed
     |       computed
     |     }
     |   }
     | }
     …

     | fn MemoryAccessOptimizer::can_optimize_constant(
     |   self : MemoryAccessOptimizer,
     |   value : UInt64,
     | ) -> UInt64? {
     |   let bound = self.state.options.low_memory_bound
     |   let current = oac_memarg_offset(self.memarg)
     |   if value >= bound {
     |     return None
     |   }
     |   let total = current + value
     |   if total < current {
 408 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if total >= bound {
     |     return None
     |   }
     |   Some(total)
     | }
     …

     | fn MemoryAccessOptimizer::optimize_constant_pointer(
     |   self : MemoryAccessOptimizer,
     | ) -> Unit {
     |   let offset = oac_memarg_offset(self.memarg)
     |   if offset == 0UL {
 422 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   if self.memory64 {
     |     match self.ptr {
     |       TI64Const(I64(base)) => {
     |         let base_u = base.reinterpret_as_uint64()
     |         let total = base_u + offset
     |         if total >= base_u {
     |           self.ptr = TInstr::i64_const(I64(total.reinterpret_as_int64()))
     |           self.memarg = oac_memarg_with_offset(self.memarg, 0UL)
     |         }
     |       }
 434 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   } else {
     |     match self.ptr {
     |       TI32Const(I32(base)) => {
     |         if offset > 4294967295UL {
 440 |           return
     |           ^^^^^^ 	<-- UNCOVERED
     |         }
     |         let base_u = base.reinterpret_as_uint().to_uint64()
     |         let total = base_u + offset
     |         if total < 4294967296UL {
     |           self.ptr = TInstr::i32_const(
     |             I32(total.to_uint().reinterpret_as_int()),
     |           )
     |           self.memarg = oac_memarg_with_offset(self.memarg, 0UL)
     |         }
     |       }
 451 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn MemoryAccessOptimizer::try_to_optimize_constant(
     |   self : MemoryAccessOptimizer,
     |   one_side : TInstr,
     |   other_side : TInstr,
     | ) -> Bool {
     |   match oac_const_to_u64(one_side) {
     |     Some(value) =>
     |       match self.can_optimize_constant(value) {
     |         Some(total) => {
     |           self.memarg = oac_memarg_with_offset(self.memarg, total)
     |           self.ptr = other_side
     |           match self.ptr {
 469 |             TI32Const(_) | TI64Const(_) => self.optimize_constant_pointer()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ => ()
     |           }
     |           true
     |         }
     |         None => false
     |       }
     |     None => false
     |   }
     | }
     …

     | fn MemoryAccessOptimizer::try_to_optimize_propagated_add(
     |   self : MemoryAccessOptimizer,
     |   one_side : TInstr,
     |   other_side : TInstr,
     |   ptr_local_idx : LocalIdx,
     |   set_ : OACSetKey,
     | ) -> Bool {
     |   if oac_is_const(one_side) && oac_is_const(other_side) {
 489 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let value = match oac_const_to_u64(one_side) {
     |     Some(v) => v
 493 |     None => return false
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let total = match self.can_optimize_constant(value) {
     |     Some(v) => v
 497 |     None => return false
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let base_local = match other_side {
     |     TLocalGet(other_idx) =>
     |       if oac_local_is_ssa(self.state, other_idx) &&
     |         oac_local_is_ssa(self.state, ptr_local_idx) {
     |         other_idx
     |       } else {
     |         oac_get_helper_index(self.state, set_)
     |       }
 507 |     _ => oac_get_helper_index(self.state, set_)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.memarg = oac_memarg_with_offset(self.memarg, total)
     |   self.ptr = TInstr::local_get(base_local)
     |   true
     | }
     …

     | fn MemoryAccessOptimizer::optimize(self : MemoryAccessOptimizer) -> Bool {
     |   match self.ptr {
     |     TI32Const(_) | TI64Const(_) => {
     |       self.optimize_constant_pointer()
     |       return false
     |     }
     |     _ => ()
     |   }
     |   match self.ptr {
     |     TBinary(op, left, right) if oac_is_add(op) =>
     |       if self.try_to_optimize_constant(right, left) ||
     |         self.try_to_optimize_constant(left, right) {
     |         return false
     |       }
     |     _ => ()
     |   }
     |   match (self.state.local_graph, self.ptr_get_id, self.ptr) {
     |     (Some(graph), Some(get_id), TLocalGet(ptr_local_idx)) => {
     |       let sets = graph.get_sets(get_id)
     |       if sets.length() != 1 {
 535 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let set_src = sets.to_array()[0]
     |       match set_src {
 539 |         LocalSet::InitValue => false
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         LocalSet::Set(set_local_idx, set_root) =>
     |           match set_root {
     |             TLocalSet(_, TBinary(op, left, right)) =>
     |               if !oac_is_i32_add(op) {
 544 |                 false
     |                 ^^^^^ 	<-- UNCOVERED
     |               } else {
     |                 let set_key : OACSetKey = {
     |                   local_idx: set_local_idx,
     |                   root: set_root,
     |                 }
     |                 if !self.state.propagatable.contains(set_key) {
     |                   false
     |                 } else if self.try_to_optimize_propagated_add(
     |                     right, left, ptr_local_idx, set_key,
     |                   ) ||
     |                   self.try_to_optimize_propagated_add(
     |                     left, right, ptr_local_idx, set_key,
     |                   ) {
     |                   true
     |                 } else {
 560 |                   false
     |                   ^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
     |             _ => false
     |           }
     |       }
     |     }
     |     _ => false
     |   }
     | }
     …

     | fn oac_insert_helper_indexes(
     |   body : TExpr,
     |   helper_indexes : Map[OACSetKey, LocalIdx],
     | ) -> TExpr {
     |   if helper_indexes.is_empty() {
 577 |     return body
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let pass = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
     |       TLocalSet(local_idx, TBinary(op, left, right)) if oac_is_i32_add(op) =>
     |         match
     |           helper_indexes.get(OACSetKey::{
     |             local_idx,
     |             root: TInstr::local_set(local_idx, TInstr::binary(op, left, right)),
     |           }) {
     |           Some(helper_idx) => {
     |             let maybe_target = match (left, right) {
     |               (a, b) if oac_is_const(a) && !oac_is_const(b) =>
 590 |                 Some((b, TInstr::binary(op, a, TInstr::local_get(helper_idx))))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               (a, b) if !oac_is_const(a) && oac_is_const(b) =>
     |                 Some((a, TInstr::binary(op, TInstr::local_get(helper_idx), b)))
 593 |               _ => None
     |               ^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             match maybe_target {
     |               Some((target, rewritten_add)) =>
     |                 change(
     |                   (),
     |                   TInstr::block(
     |                     BlockType::void_(),
     |                     TExpr::new([
     |                       TInstr::local_set(helper_idx, target),
     |                       TInstr::local_set(local_idx, rewritten_add),
     |                     ]),
     |                   ),
     |                 )
 607 |               None => self.walk_tinstruction_default((), curr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
 610 |           None => self.walk_tinstruction_default((), curr)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => self.walk_tinstruction_default((), curr)
     |     }
     |   })
     |   match pass.walk_texpr((), body) {
     |     Ok(Some((_, updated))) => updated
 617 |     Ok(None) => body
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(_) => body
     |   }
     | }
     …

     | fn oac_binary_traps(op : BinaryOp) -> Bool {
     |   match op {
     |     I32DivSOp
     |     | I32DivUOp
     |     | I32RemSOp
     |     | I32RemUOp
     |     | I64DivSOp
     |     | I64DivUOp
     |     | I64RemSOp
 632 |     | I64RemUOp => true
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => false
     |   }
     | }
     …

     | fn oac_has_side_effects(instr : TInstr) -> Bool {
     |   match instr {
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TLocalGet(_)
     |     | TGlobalGet(_)
     |     | TMemorySize(_)
     |     | TTableSize(_) => false
     |     TBinary(op, left, right) =>
     |       if oac_binary_traps(op) {
 653 |         true
     |         ^^^^ 	<-- UNCOVERED
     |       } else {
     |         oac_has_side_effects(left) || oac_has_side_effects(right)
     |       }
     |     TRefEq(left, right) =>
 658 |       oac_has_side_effects(left) || oac_has_side_effects(right)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => true
     |   }
     | }
     …

     | fn oac_cleanup_unneeded_sets(body : TExpr) -> TExpr {
     |   let mut curr_body = body
     |   while true {
     |     let used = oac_collect_used_locals(curr_body)
     |     let changed = Ref::new(false)
     |     let remover = ModuleTransformer::new().on_tinstruction_evt(fn(
     |       self,
     |       _,
     |       curr,
     |     ) {
     |       match curr {
     |         TLocalSet(local_idx, value) => {
     |           let next_value = match self.walk_tinstruction((), value) {
     |             Ok(Some((_, updated))) => updated
     |             Ok(None) => value
 693 |             Err(_) => value
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if !used.contains(local_idx) {
     |             changed.update(fn(_) { true })
     |             if oac_has_side_effects(next_value) {
 698 |               change((), TInstr::drop(next_value))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else {
     |               change((), TInstr::nop())
     |             }
     |           } else if next_value == value {
     |             unchanged()
     |           } else {
 705 |             change((), TInstr::local_set(local_idx, next_value))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         _ => self.walk_tinstruction_default((), curr)
     |       }
     |     })
     |     curr_body = match remover.walk_texpr((), curr_body) {
     |       Ok(Some((_, updated))) => updated
 713 |       Ok(None) => curr_body
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Err(_) => curr_body
     |     }
     |     if !changed.val {
     |       break
     |     }
     |   }
     |   curr_body
     | }
     …

     | fn oac_rewrite_body(
     |   body : TExpr,
     |   state : OACIterationState,
     | ) -> Result[TExpr, String] {
     |   let next_get_id = Ref::new(0)
     |   let pass = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
     |       TLocalGet(_) => {
     |         next_get_id.update(fn(n) { n + 1 })
     |         unchanged()
     |       }
     |       TLoad(_, _, ptr) => {
     |         let ptr_get_id = match ptr {
     |           TLocalGet(_) => Some(next_get_id.val)
     |           _ => None
     |         }
     |         let walked = match self.walk_tinstruction_default((), curr) {
     |           Ok(Some((_, updated))) => updated
 742 |           Ok(None) => curr
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |         match walked {
     |           TLoad(next_op, next_memarg, next_ptr) => {
     |             let optimizer = MemoryAccessOptimizer::new(
     |               state, next_memarg, next_ptr, ptr_get_id,
     |             )
     |             if optimizer.optimize() {
     |               state.propagated = true
     |             }
     |             change((), TInstr::load(next_op, optimizer.memarg, optimizer.ptr))
     |           }
 755 |           _ => change((), walked)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TStore(_, _, ptr, _) => {
     |         let ptr_get_id = match ptr {
 760 |           TLocalGet(_) => Some(next_get_id.val)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => None
     |         }
     |         let walked = match self.walk_tinstruction_default((), curr) {
     |           Ok(Some((_, updated))) => updated
 765 |           Ok(None) => curr
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |         match walked {
     |           TStore(next_op, next_memarg, next_ptr, next_value) => {
     |             let optimizer = MemoryAccessOptimizer::new(
     |               state, next_memarg, next_ptr, ptr_get_id,
     |             )
     |             if optimizer.optimize() {
 774 |               state.propagated = true
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             change(
     |               (),
     |               TInstr::store(
     |                 next_op,
     |                 optimizer.memarg,
     |                 optimizer.ptr,
     |                 next_value,
     |               ),
     |             )
     |           }
 786 |           _ => change((), walked)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => self.walk_tinstruction_default((), curr)
     |     }
     |   })
     |   match pass.walk_texpr((), body) {
     |     Ok(Some((_, updated))) => Ok(updated)
 794 |     Ok(None) => Ok(body)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn optimize_added_constants_on_func(
     |   func : Func,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   propagate : Bool,
     | ) -> Result[Func, String] {
     |   if !options.low_memory_unused {
     |     return Err(oac_fatal_message)
     |   }
     |   if mod.mem_sec is None {
 810 |     return Ok(func)
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match func {
 813 |     Func(_) => Err("Expected TFunc")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(initial_locals, initial_body) => {
     |       let mut locals = initial_locals
     |       let mut body = initial_body
     |       while true {
     |         let infos = if propagate {
     |           oac_collect_local_get_infos(body)
     |         } else {
     |           []
     |         }
     |         let local_graph = if propagate {
     |           Some(LocalGraph::new(body.0))
     |         } else {
     |           None
     |         }
     |         let propagatable = match local_graph {
     |           Some(graph) => oac_find_propagatable(body, graph, infos)
     |           None => Set::new()
     |         }
     |         let state : OACIterationState = {
     |           options,
     |           mod,
     |           local_graph,
     |           propagatable,
     |           helper_indexes: Map::new(),
     |           ssa_info: if propagate {
     |             Some(oac_make_ssa_info(body, infos))
     |           } else {
     |             None
     |           },
     |           ssa_cache: Map::new(),
     |           locals,
     |           propagated: false,
     |         }
     |         body = match oac_rewrite_body(body, state) {
     |           Ok(next_body) => next_body
 849 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if !state.helper_indexes.is_empty() {
     |           body = oac_insert_helper_indexes(body, state.helper_indexes)
     |         }
     |         locals = state.locals
     |         if state.propagated {
     |           body = oac_cleanup_unneeded_sets(body)
     |           continue
     |         }
     |         break
     |       }
     |       Ok(Func::t_func(locals, body))
     |     }
     |   }
     | }
     …

     | fn optimize_added_constants_ir_pass(
     |   mod : Module,
     |   options : OptimizeOptions,
     |   propagate : Bool,
     | ) -> ModuleTransformer[IRContext] {
     |   ModuleTransformer::new().on_func_evt(fn(_self, t : IRContext, func) {
     |     match optimize_added_constants_on_func(func, mod, options, propagate) {
     |       Ok(next_func) =>
     |         match (func, next_func) {
     |           (TFunc(orig_locals, orig_body), TFunc(next_locals, next_body)) => {
     |             t.set_body(next_body)
     |             if orig_locals == next_locals && orig_body == next_body {
     |               unchanged()
     |             } else {
     |               change(t, Func::t_func(next_locals, next_body))
     |             }
     |           }
 884 |           _ => change(t, next_func)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       Err(e) => Err(e)
     |     }
     |   })
     | }
     …

     | fn oac_run_func(
     |   body : Array[TInstr],
     |   locals? : Array[ValType] = [],
     |   options? : OptimizeOptions = OptimizeOptions::new(
     |     low_memory_unused=true,
     |     low_memory_bound=1024UL,
     |   ),
     |   propagate? : Bool = false,
     |   memory64? : Bool = false,
     | ) -> Result[(Array[ValType], TExpr), String] {
     |   let memory = if memory64 {
     |     MemType::new(Limits::i64(1UL, None))
     |   } else {
     |     MemType::new(Limits::i32(1, None))
     |   }
     |   let mod_ = Module::new()
     |     .with_mem_sec(MemSec::new([memory]))
     |     .with_code_sec(CodeSec::new([Func::t_func(locals, TExpr::new(body))]))
     |   let passes = if propagate {
     |     [ModulePass::OptimizeAddedConstantsPropagate]
     |   } else {
     |     [ModulePass::OptimizeAddedConstants]
     |   }
     |   match optimize_module_with_options(mod_, passes, options) {
     |     Ok(out) =>
     |       match out.code_sec {
     |         Some(CodeSec([TFunc(new_locals, new_body)])) =>
     |           Ok((new_locals, new_body))
 920 |         _ => Err("expected one transformed TFunc")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 922 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

77 uncovered line(s) in src/passes/optimize_casts.mbt:

     | fn OCCastEffects::invalidates(
     |   self : OCCastEffects,
     |   other : OCCastEffects,
     | ) -> Bool {
     |   for local_idx in self.locals_written {
  53 |     if other.locals_read.contains(local_idx) ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       other.locals_written.contains(local_idx) {
  55 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   for local_idx in self.locals_read {
  59 |     if other.locals_written.contains(local_idx) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       return true
     |     }
     |   }
     |   if (self.reads_memory && other.writes_memory) ||
     |     (self.writes_memory && other.reads_memory) ||
     |     (self.writes_memory && other.writes_memory) {
  66 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.reads_globals && other.writes_globals) ||
     |     (self.writes_globals && other.reads_globals) ||
     |     (self.writes_globals && other.writes_globals) {
  71 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if self.calls || other.calls {
  74 |     if self.reads_memory ||
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.writes_memory ||
     |       other.reads_memory ||
     |       other.writes_memory ||
     |       self.reads_globals ||
     |       self.writes_globals ||
     |       other.reads_globals ||
     |       other.writes_globals {
  82 |       return true
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if self.transfers_control_flow() || other.transfers_control_flow() {
  86 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if (self.traps && other.has_unremovable_side_effects()) ||
     |     (other.traps && self.has_unremovable_side_effects()) {
     |     return true
     |   }
     |   false
     | }
     …

     | fn oc_collect_shallow_effects_into(
     |   instr : TInstr,
     |   effects : OCCastEffects,
     | ) -> Unit {
     |   match instr {
     |     TLocalGet(idx) => effects.locals_read.add(idx)
 102 |     TLocalSet(idx, _) => effects.locals_written.add(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalTee(idx, _) => {
     |       effects.locals_read.add(idx)
     |       effects.locals_written.add(idx)
     |     }
 107 |     TGlobalGet(_) => effects.reads_globals = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TGlobalSet(_, _) => effects.writes_globals = true
     |     TLoad(_, _, _) => {
     |       effects.reads_memory = true
     |       effects.traps = true
     |     }
 113 |     TStore(_, _, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.writes_memory = true
     |       effects.traps = true
     |     }
 117 |     TMemoryGrow(_, _) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemorySize(_) => effects.reads_memory = true
     |     TMemoryCopy(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
 123 |     TMemoryFill(_, _, _, _) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryInit(_, _, _, _, _) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
 128 |     TDataDrop(_) => effects.writes_memory = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableSet(_, _, _) | TTableGrow(_, _, _) | TTableFill(_, _, _, _) =>
 130 |       effects.writes_memory = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableGet(_, _) | TTableSize(_) => effects.reads_memory = true
     |     TTableCopy(_, _, _, _, _) | TTableInit(_, _, _, _, _) | TElemDrop(_) => {
     |       effects.reads_memory = true
     |       effects.writes_memory = true
     |     }
     |     TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) =>
 137 |       effects.calls = true
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
 140 |     | TReturnCallRef(_, _, _) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       effects.calls = true
     |       effects.branches = true
     |     }
     |     TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
 151 |     | TReturn(_) => effects.branches = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TThrow(_, _) | TThrowRef(_) => {
     |       effects.throws = true
     |       effects.branches = true
     |     }
 156 |     TUnreachable => effects.traps = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefAsNonNull(_) | TRefCast(_, _, _) | TRefCastDescEq(_, _, _) =>
     |       effects.traps = true
     |     _ => ()
     |   }
     | }
     …

     | fn EarlyCastFinder::flush_ref_cast_result(
     |   self : EarlyCastFinder,
     |   index : Int,
     | ) -> Unit {
     |   let info = self.curr_ref_cast_move[index]
     |   match (info.target_get_id, info.best_cast) {
 269 |     (Some(target), Some(best)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let can_apply = match info.best_fallthrough {
     |         Some(fallthrough) => fallthrough != target
     |         None => true
     |       }
     |       if can_apply {
 275 |         self.ref_cast_to_apply[target] = best
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => ()
     |   }
     |   self.curr_ref_cast_move[index].target_get_id = None
     |   self.curr_ref_cast_move[index].best_cast = None
     |   self.curr_ref_cast_move[index].best_fallthrough = None
     | }
     …

     | fn EarlyCastFinder::flush_ref_as_result(
     |   self : EarlyCastFinder,
     |   index : Int,
     | ) -> Unit {
     |   let info = self.curr_ref_as_move[index]
     |   match info.target_get_id {
 292 |     Some(target) if info.has_best_cast => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let can_apply = match info.best_fallthrough {
     |         Some(fallthrough) => fallthrough != target
     |         None => true
     |       }
     |       if can_apply {
 298 |         self.ref_as_to_apply.add(target)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => ()
     |   }
     |   self.curr_ref_as_move[index].target_get_id = None
     |   self.curr_ref_as_move[index].has_best_cast = false
     |   self.curr_ref_as_move[index].best_fallthrough = None
     | }
     …

     | fn EarlyCastFinder::visit_local_get(
     |   self : EarlyCastFinder,
     |   curr : LocalIdx,
     | ) -> Int {
     |   let get_id = self.next_get_id
     |   self.next_get_id = self.next_get_id + 1
     |   let index = oc_local_index_int(curr)
     |   if self.curr_ref_cast_move[index].target_get_id is None {
     |     self.curr_ref_cast_move[index].target_get_id = Some(get_id)
     |     self.curr_ref_cast_move[index].target_type = match
     |       self.env.get_local_type(curr) {
     |       Some(RefTypeValType(rt)) => Some(rt)
 362 |       _ => None
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if self.curr_ref_as_move[index].target_get_id is None {
     |     let can_target = match self.env.get_local_type(curr) {
     |       Some(RefTypeValType(rt)) => rt.is_nullable()
 368 |       _ => false
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if can_target {
     |       self.curr_ref_as_move[index].target_get_id = Some(get_id)
     |     }
     |   }
     |   get_id
     | }
     …

     | fn EarlyCastFinder::visit_ref_as(
     |   self : EarlyCastFinder,
     |   op : Bool,
     |   fallthrough : (LocalIdx, Int)?,
     | ) -> Unit {
     |   if !op {
 384 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   match fallthrough {
     |     Some((idx, fallthrough_get_id)) => {
     |       let i = oc_local_index_int(idx)
     |       if self.curr_ref_as_move[i].target_get_id is Some(_) &&
     |         !self.curr_ref_as_move[i].has_best_cast {
 391 |         self.curr_ref_as_move[i].has_best_cast = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.curr_ref_as_move[i].best_fallthrough = Some(fallthrough_get_id)
     |       }
     |     }
 395 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn EarlyCastFinder::visit_ref_cast(
     |   self : EarlyCastFinder,
     |   nullable : Bool,
     |   ht : HeapType,
     |   fallthrough : (LocalIdx, Int)?,
     | ) -> Unit {
     |   match fallthrough {
     |     Some((idx, fallthrough_get_id)) => {
     |       let i = oc_local_index_int(idx)
     |       let target = self.curr_ref_cast_move[i]
     |       let cast_type = RefType::new(nullable, ht)
     |       match (target.target_get_id, target.target_type) {
     |         (Some(_), Some(target_ty)) =>
 413 |           if target_ty != cast_type &&
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             oc_is_subtype(cast_type, target_ty, self.env) {
 415 |             match target.best_cast {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               None => {
     |                 self.curr_ref_cast_move[i].best_cast = Some(cast_type)
     |                 self.curr_ref_cast_move[i].best_fallthrough = Some(
     |                   fallthrough_get_id,
     |                 )
     |               }
     |               Some(best) =>
 423 |                 if best != cast_type && oc_is_subtype(cast_type, best, self.env) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   self.curr_ref_cast_move[i].best_cast = Some(cast_type)
     |                   self.curr_ref_cast_move[i].best_fallthrough = Some(
     |                     fallthrough_get_id,
     |                   )
     |                 }
     |             }
     |           }
     |         _ => ()
     |       }
     |     }
 434 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oc_walk_early_cast_finder_instr(
     |   finder : EarlyCastFinder,
     |   instr : TInstr,
     | ) -> (LocalIdx, Int)? {
     |   finder.note_non_linear(instr)
     |   let fallthrough = match instr {
     |     TLocalGet(idx) => {
     |       finder.visit_expression(instr)
     |       let get_id = finder.visit_local_get(idx)
     |       Some((idx, get_id))
     |     }
 450 |     TLocalSet(idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ignore(oc_walk_early_cast_finder_instr(finder, value))
     |       finder.visit_expression(instr)
     |       let i = oc_local_index_int(idx)
     |       finder.flush_ref_cast_result(i)
     |       finder.flush_ref_as_result(i)
     |       None
     |     }
 458 |     TLocalTee(idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ignore(oc_walk_early_cast_finder_instr(finder, value))
     |       finder.visit_expression(instr)
     |       let i = oc_local_index_int(idx)
     |       finder.flush_ref_cast_result(i)
     |       finder.flush_ref_as_result(i)
     |       None
     |     }
     |     TRefAsNonNull(value) => {
     |       let ft = oc_walk_early_cast_finder_instr(finder, value)
     |       finder.visit_expression(instr)
     |       finder.visit_ref_as(true, ft)
     |       ft
     |     }
     |     TRefCast(nullable, ht, value) => {
     |       let ft = oc_walk_early_cast_finder_instr(finder, value)
     |       finder.visit_expression(instr)
     |       finder.visit_ref_cast(nullable, ht, ft)
     |       ft
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) => {
     |       oc_walk_early_cast_finder_expr(finder, body)
     |       finder.flush_all()
     |       finder.visit_expression(instr)
     |       None
     |     }
 484 |     TIf(_, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ignore(oc_walk_early_cast_finder_instr(finder, cond))
     |       finder.flush_all()
     |       oc_walk_early_cast_finder_expr(finder, then_)
     |       finder.flush_all()
     |       match else_ {
     |         Some(other) => oc_walk_early_cast_finder_expr(finder, other)
     |         None => ()
     |       }
 493 |       finder.flush_all()
     |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       finder.visit_expression(instr)
     |       None
     |     }
     |     _ => {
     |       for child in eval_children(instr) {
     |         ignore(oc_walk_early_cast_finder_instr(finder, child))
     |       }
     |       finder.visit_expression(instr)
     |       None
     |     }
     |   }
     |   fallthrough
     | }
     …

     | fn oc_apply_early_casts(body : TExpr, finder : EarlyCastFinder) -> TExpr {
 531 |   let get_id = Ref::new(0)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let pass = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     match curr {
     |       TLocalGet(_) => {
     |         let this_id = get_id.val
 536 |         get_id.update(fn(i) { i + 1 })
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let casted : TInstr = match finder.ref_cast_to_apply.get(this_id) {
     |           Some(rt) =>
 539 |             TInstr::ref_cast(rt.is_nullable(), rt.get_heap_type(), curr)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => curr
     |         }
     |         if finder.ref_as_to_apply.contains(this_id) {
 543 |           change((), TInstr::ref_as_non_null(casted))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else if casted == curr {
     |           unchanged()
     |         } else {
 547 |           change((), casted)
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 550 |       _ => self.walk_tinstruction_default((), curr)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
 553 |   match pass.walk_texpr((), body) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(Some((_, updated))) => updated
     |     _ => body
     |   }
     | }
     …

     | fn BestCastFinder::visit_local_set(
     |   self : BestCastFinder,
     |   idx : LocalIdx,
     | ) -> Unit {
 596 |   self.most_casted_gets.remove(idx)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn BestCastFinder::visit_local_get(
     |   self : BestCastFinder,
     |   idx : LocalIdx,
     | ) -> Int {
     |   let get_id = self.next_get_id
     |   self.next_get_id = self.next_get_id + 1
     |   self.get_local_map[get_id] = idx
     |   match self.most_casted_gets.get(idx) {
     |     Some(best_cast) =>
     |       match self.env.get_local_type(idx) {
     |         Some(RefTypeValType(local_ty)) =>
     |           if local_ty != best_cast &&
     |             oc_is_subtype(best_cast, local_ty, self.env) {
     |             let wants = self.less_casted_gets
     |               .get(self.next_refinement_id - 1)
     |               .unwrap_or([])
     |             wants.push(get_id)
     |             self.less_casted_gets[self.next_refinement_id - 1] = wants
     |           }
 619 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => ()
     |   }
     |   get_id
     | }
     …

     | fn BestCastFinder::update_best_cast(
     |   self : BestCastFinder,
     |   refinement_id : Int,
     |   idx : LocalIdx,
     |   ty : RefType,
     | ) -> Unit {
     |   ignore(refinement_id)
     |   match self.most_casted_gets.get(idx) {
     |     None => self.most_casted_gets[idx] = ty
     |     Some(best) =>
     |       if ty != best && oc_is_subtype(ty, best, self.env) {
 638 |         self.most_casted_gets[idx] = ty
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn oc_refinement_target(instr : TInstr) -> LocalIdx? {
     |   match instr {
     |     TLocalGet(idx) => Some(idx)
 647 |     TLocalTee(idx, _) => Some(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefCast(_, _, child) | TRefAsNonNull(child) => oc_refinement_target(child)
 649 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn BestCastFinder::visit_refinement(
     |   self : BestCastFinder,
     |   refinement_id : Int,
     |   ty : RefType?,
     |   root : TInstr,
     | ) -> Unit {
     |   match (oc_refinement_target(root), ty) {
     |     (Some(idx), Some(rt)) => self.update_best_cast(refinement_id, idx, rt)
 662 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oc_walk_best_cast_finder_instr(
     |   finder : BestCastFinder,
     |   instr : TInstr,
     |   active_refinement_id : Int?,
     | ) -> Unit {
     |   finder.note_non_linear(instr)
     |   match instr {
 674 |     TLocalSet(idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       oc_walk_best_cast_finder_instr(finder, value, active_refinement_id)
     |       finder.visit_local_set(idx)
     |     }
 678 |     TLocalTee(idx, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       oc_walk_best_cast_finder_instr(finder, value, active_refinement_id)
     |       finder.visit_local_set(idx)
     |       let get_id = finder.visit_local_get(idx)
     |       match active_refinement_id {
     |         Some(rid) => {
     |           let wants = finder.less_casted_gets.get(rid).unwrap_or([])
     |           wants.push(get_id)
     |           finder.less_casted_gets[rid] = wants
     |         }
 688 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TLocalGet(idx) => {
     |       let get_id = finder.visit_local_get(idx)
     |       match active_refinement_id {
     |         Some(rid) => {
     |           let wants = finder.less_casted_gets.get(rid).unwrap_or([])
     |           wants.push(get_id)
     |           finder.less_casted_gets[rid] = wants
     |         }
     |         None => ()
     |       }
     |       ignore(get_id)
     |     }
     |     TRefCast(nullable, ht, value) => {
     |       let rid = finder.next_refinement_id
     |       finder.next_refinement_id = rid + 1
     |       oc_walk_best_cast_finder_instr(finder, value, Some(rid))
     |       finder.visit_refinement(rid, Some(RefType::new(nullable, ht)), instr)
     |     }
     |     TRefAsNonNull(value) => {
     |       let rid = finder.next_refinement_id
     |       finder.next_refinement_id = rid + 1
     |       oc_walk_best_cast_finder_instr(finder, value, Some(rid))
     |       let ty = match oc_refinement_target(value) {
     |         Some(idx) =>
     |           match finder.env.get_local_type(idx) {
     |             Some(RefTypeValType(rt)) =>
     |               Some(RefType::new(false, rt.get_heap_type()))
 718 |             _ => None
     |             ^^^^^^^^^ 	<-- UNCOVERED
     |           }
 720 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       finder.visit_refinement(rid, ty, instr)
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       oc_walk_best_cast_finder_expr(finder, body)
 726 |     TIf(_, cond, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       oc_walk_best_cast_finder_instr(finder, cond, None)
     |       finder.most_casted_gets.clear()
     |       oc_walk_best_cast_finder_expr(finder, then_)
     |       finder.most_casted_gets.clear()
     |       match else_ {
     |         Some(other) => oc_walk_best_cast_finder_expr(finder, other)
     |         None => ()
     |       }
 735 |       finder.most_casted_gets.clear()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         oc_walk_best_cast_finder_instr(finder, child, None)
     |       }
     |   }
     | }
     …

     | fn oc_apply_best_casts(
     |   func : Func,
     |   body : TExpr,
     |   finder : BestCastFinder,
     | ) -> (Func, Bool) {
     |   if finder.less_casted_gets.is_empty() {
 763 |     return (func, false)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let match_get_to_refinement : Map[Int, Int] = Map::new()
     |   for entry in finder.less_casted_gets {
     |     let (refinement_id, gets) = entry
     |     for get_id in gets {
     |       match_get_to_refinement[get_id] = refinement_id
     |     }
     |   }
     |   let refinement_temps : Map[Int, LocalIdx] = Map::new()
     |   let new_locals = match func {
     |     TFunc(locals, _) => locals.copy()
 775 |     _ => []
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let next_local = Ref::new(new_locals.length())
     |   let next_refinement_id = Ref::new(0)
     |   let pass_refinement = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     _,
     |     curr,
     |   ) {
     |     match curr {
     |       TRefCast(nullable, ht, _) => {
     |         let rid = next_refinement_id.val
     |         next_refinement_id.update(fn(i) { i + 1 })
     |         let walked = match self.walk_tinstruction_default((), curr) {
     |           Ok(Some((_, updated))) => updated
 790 |           _ => curr
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match finder.less_casted_gets.get(rid) {
     |           Some(gets) if gets.length() > 0 => {
     |             let temp = LocalIdx::new(next_local.val.reinterpret_as_uint())
     |             next_local.update(fn(i) { i + 1 })
     |             new_locals.push(ValType::ref_type(RefType::new(nullable, ht)))
     |             refinement_temps[rid] = temp
     |             change((), TInstr::local_tee(temp, walked))
     |           }
     |           _ => change((), walked)
     |         }
     |       }
     |       TRefAsNonNull(_) => {
     |         let rid = next_refinement_id.val
     |         next_refinement_id.update(fn(i) { i + 1 })
     |         let walked = match self.walk_tinstruction_default((), curr) {
     |           Ok(Some((_, updated))) => updated
 808 |           _ => curr
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         match finder.less_casted_gets.get(rid) {
     |           Some(gets) if gets.length() > 0 => {
     |             let temp = LocalIdx::new(next_local.val.reinterpret_as_uint())
     |             next_local.update(fn(i) { i + 1 })
     |             // Non-nullable by construction of ref.as_non_null.
     |             let temp_ty = match walked {
     |               TRefAsNonNull(inner) =>
     |                 match oc_refinement_target(inner) {
     |                   Some(idx) =>
     |                     match finder.env.get_local_type(idx) {
     |                       Some(RefTypeValType(rt)) =>
     |                         ValType::ref_type(
     |                           RefType::new(false, rt.get_heap_type()),
     |                         )
 824 |                       _ => ValType::anyref()
     |                       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     }
 826 |                   None => ValType::anyref()
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
 828 |               _ => ValType::anyref()
     |               ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             new_locals.push(temp_ty)
     |             refinement_temps[rid] = temp
     |             change((), TInstr::local_tee(temp, walked))
     |           }
 834 |           _ => change((), walked)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => self.walk_tinstruction_default((), curr)
     |     }
     |   })
     |   let body_with_tees = match pass_refinement.walk_texpr((), body) {
     |     Ok(Some((_, updated))) => updated
 842 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let get_id = Ref::new(0)
     |   let pass_gets = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     _,
     |     curr,
     |   ) {
     |     match curr {
     |       TLocalGet(_) => {
     |         let id = get_id.val
     |         get_id.update(fn(i) { i + 1 })
     |         match match_get_to_refinement.get(id) {
     |           Some(rid) =>
     |             match refinement_temps.get(rid) {
     |               Some(temp) => change((), TInstr::local_get(temp))
 858 |               None => unchanged()
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           None => unchanged()
     |         }
     |       }
     |       _ => self.walk_tinstruction_default((), curr)
     |     }
     |   })
     |   let final_body = match pass_gets.walk_texpr((), body_with_tees) {
     |     Ok(Some((_, updated))) => updated
 868 |     _ => body_with_tees
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let original_local_count = match func {
     |     TFunc(locals, _) => locals.length()
 872 |     _ => 0
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   let changed = final_body != body || next_local.val != original_local_count
     |   let next_func = match func {
     |     TFunc(_, _) => Func::t_func(new_locals, final_body)
 877 |     _ => func
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   (next_func, changed)
     | }
     …

     | fn optimize_casts_on_func(func : Func, mod : Module) -> Result[Func, String] {
     |   match func {
 885 |     Func(_, _) => Ok(func)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(locals, body) => {
     |       let env = Env::new().with_module(mod).with_locals(locals)
     |       let early_finder = EarlyCastFinder::new(env, locals.length())
     |       early_finder.run(body)
     |       let after_early = if early_finder.has_casts_to_move() {
 891 |         oc_apply_early_casts(body, early_finder)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         body
     |       }
     |       let best_finder = BestCastFinder::new(env)
     |       best_finder.run(after_early)
     |       let (next_func, _) = oc_apply_best_casts(
     |         Func::t_func(locals, after_early),
     |         after_early,
     |         best_finder,
     |       )
     |       Ok(next_func)
     |     }
     |   }
     | }
     …

     | fn optimize_casts_ir_pass(mod : Module) -> ModuleTransformer[IRContext] {
     |   ModuleTransformer::new().on_func_evt(fn(_self, t : IRContext, func) {
     |     match optimize_casts_on_func(func, mod) {
     |       Ok(next_func) =>
     |         match (func, next_func) {
     |           (TFunc(orig_locals, orig_body), TFunc(next_locals, next_body)) => {
     |             t.set_body(next_body)
     |             if orig_locals == next_locals && orig_body == next_body {
 916 |               unchanged()
     |               ^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else {
     |               change(t, Func::t_func(next_locals, next_body))
     |             }
     |           }
 921 |           _ => unchanged()
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
 923 |       Err(e) => Err(e)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

     | fn optimize_casts(mod : Module) -> Module {
     |   let pass = optimize_casts_ir_pass(mod)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
 933 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oc_add_func(mod : Module, func : Func) -> Module {
     |   let func_type = FuncType::new([], [])
     |   let type_sec = match mod.type_sec {
     |     Some(TypeSec(recs)) => {
     |       let next = recs.copy()
     |       next.push(
     |         RecType::new(
     |           SubType::new(true, [], CompType::func(func_type.0, func_type.1)),
     |         ),
     |       )
     |       TypeSec::new(next)
     |     }
     |     None =>
 951 |       TypeSec::new([
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         RecType::new(
     |           SubType::new(true, [], CompType::func(func_type.0, func_type.1)),
     |         ),
     |       ])
     |   }
     |   let type_idx = TypeIdx::new(type_sec.0.length().reinterpret_as_uint() - 1)
     |   mod
     |   .with_type_sec(type_sec)
     |   .with_func_sec(FuncSec::new([type_idx]))
     |   .with_code_sec(CodeSec::new([func]))
     | }
     …

     | fn oc_get_func(mod : Module) -> Func? {
     |   match mod.code_sec {
     |     Some(CodeSec([f])) => Some(f)
 968 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

170 uncovered line(s) in src/passes/optimize_instructions.mbt:

     | fn oi_reverse_relational(op : BinaryOp) -> BinaryOp? {
     |   match op {
 154 |     I32EqOp => Some(BinaryOp::i32_eq())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32NeOp => Some(BinaryOp::i32_ne())
     |     I32LtSOp => Some(BinaryOp::i32_gt_s())
 157 |     I32LtUOp => Some(BinaryOp::i32_gt_u())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32LeSOp => Some(BinaryOp::i32_ge_s())
     |     I32LeUOp => Some(BinaryOp::i32_ge_u())
     |     I32GtSOp => Some(BinaryOp::i32_lt_s())
     |     I32GtUOp => Some(BinaryOp::i32_lt_u())
     |     I32GeSOp => Some(BinaryOp::i32_le_s())
     |     I32GeUOp => Some(BinaryOp::i32_le_u())
     |     I64EqOp => Some(BinaryOp::i64_eq())
     |     I64NeOp => Some(BinaryOp::i64_ne())
     |     I64LtSOp => Some(BinaryOp::i64_gt_s())
     |     I64LtUOp => Some(BinaryOp::i64_gt_u())
     |     I64LeSOp => Some(BinaryOp::i64_ge_s())
     |     I64LeUOp => Some(BinaryOp::i64_ge_u())
     |     I64GtSOp => Some(BinaryOp::i64_lt_s())
     |     I64GtUOp => Some(BinaryOp::i64_lt_u())
     |     I64GeSOp => Some(BinaryOp::i64_le_s())
     |     I64GeUOp => Some(BinaryOp::i64_le_u())
     |     F32EqOp => Some(BinaryOp::f32_eq())
     |     F32NeOp => Some(BinaryOp::f32_ne())
     |     F32LtOp => Some(BinaryOp::f32_gt())
     |     F32LeOp => Some(BinaryOp::f32_ge())
     |     F32GtOp => Some(BinaryOp::f32_lt())
     |     F32GeOp => Some(BinaryOp::f32_le())
     |     F64EqOp => Some(BinaryOp::f64_eq())
     |     F64NeOp => Some(BinaryOp::f64_ne())
     |     F64LtOp => Some(BinaryOp::f64_gt())
     |     F64LeOp => Some(BinaryOp::f64_ge())
     |     F64GtOp => Some(BinaryOp::f64_lt())
     |     F64GeOp => Some(BinaryOp::f64_le())
     |     _ => None
     |   }
     | }
     …

     | fn oi_invert_relational(op : BinaryOp) -> BinaryOp? {
     |   match op {
     |     I32EqOp => Some(BinaryOp::i32_ne())
 194 |     I32NeOp => Some(BinaryOp::i32_eq())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32LtSOp => Some(BinaryOp::i32_ge_s())
     |     I32LtUOp => Some(BinaryOp::i32_ge_u())
     |     I32LeSOp => Some(BinaryOp::i32_gt_s())
     |     I32LeUOp => Some(BinaryOp::i32_gt_u())
     |     I32GtSOp => Some(BinaryOp::i32_le_s())
     |     I32GtUOp => Some(BinaryOp::i32_le_u())
     |     I32GeSOp => Some(BinaryOp::i32_lt_s())
     |     I32GeUOp => Some(BinaryOp::i32_lt_u())
     |     I64EqOp => Some(BinaryOp::i64_ne())
     |     I64NeOp => Some(BinaryOp::i64_eq())
     |     I64LtSOp => Some(BinaryOp::i64_ge_s())
     |     I64LtUOp => Some(BinaryOp::i64_ge_u())
     |     I64LeSOp => Some(BinaryOp::i64_gt_s())
     |     I64LeUOp => Some(BinaryOp::i64_gt_u())
     |     I64GtSOp => Some(BinaryOp::i64_le_s())
     |     I64GtUOp => Some(BinaryOp::i64_le_u())
     |     I64GeSOp => Some(BinaryOp::i64_lt_s())
     |     I64GeUOp => Some(BinaryOp::i64_lt_u())
     |     F32EqOp => Some(BinaryOp::f32_ne())
     |     F32NeOp => Some(BinaryOp::f32_eq())
     |     F64EqOp => Some(BinaryOp::f64_ne())
     |     F64NeOp => Some(BinaryOp::f64_eq())
     |     _ => None
     |   }
     | }
     …

     | fn oi_is_i64_shift(op : BinaryOp) -> Bool {
     |   match op {
     |     I64ShlOp | I64ShrSOp | I64ShrUOp | I64RotlOp | I64RotrOp => true
 250 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oi_negate_const(instr : TInstr) -> TInstr? {
     |   match instr {
 257 |     TI32Const(I32(v)) => Some(TInstr::i32_const(I32(oi_wrap_i32(-v))))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TI64Const(I64(v)) => Some(TInstr::i64_const(I64(oi_wrap_i64(-v))))
 259 |     TF32Const(F32(v)) => Some(TInstr::f32_const(F32(-v)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF64Const(F64(v)) => Some(TInstr::f64_const(F64(-v)))
     |     _ => None
     |   }
     | }
     …

     | fn oi_optimize_boolean(
     |   cond : TInstr,
     |   _env : Env,
     |   _options : OptimizeOptions,
     | ) -> TInstr {
     |   match cond {
     |     TUnary(I32EqzOp, TUnary(I32EqzOp, value)) => value
     |     TUnary(I32EqzOp, TBinary(op, left, right)) =>
 279 |       match oi_invert_relational(op) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(inv) => TInstr::binary(inv, left, right)
     |         None => cond
     |       }
     |     TUnary(I32EqzOp, value) =>
     |       match value {
     |         TI32Const(I32(v)) => TInstr::i32_const(I32(if v == 0 { 1 } else { 0 }))
     |         _ => cond
     |       }
 288 |     TBinary(I32NeOp, value, TI32Const(I32(0))) => value
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBinary(I32SubOp, TI32Const(I32(0)), value) => value
     |     _ => cond
     |   }
     | }
     …

     | fn oi_optimize_with_const_right(
     |   op : BinaryOp,
     |   left : TInstr,
     |   right : TInstr,
     |   env : Env,
     |   options : OptimizeOptions,
     | ) -> TInstr? {
     |   match (op, right) {
     |     (I32ShlOp, TI32Const(I32(0)))
     |     | (I32ShrSOp, TI32Const(I32(0)))
     |     | (I32ShrUOp, TI32Const(I32(0)))
     |     | (I32RotlOp, TI32Const(I32(0)))
     |     | (I32RotrOp, TI32Const(I32(0)))
     |     | (I64ShlOp, TI64Const(I64(0L)))
     |     | (I64ShrSOp, TI64Const(I64(0L)))
     |     | (I64ShrUOp, TI64Const(I64(0L)))
     |     | (I64RotlOp, TI64Const(I64(0L)))
     |     | (I64RotrOp, TI64Const(I64(0L)))
     |     | (I32OrOp, TI32Const(I32(0)))
     |     | (I32XorOp, TI32Const(I32(0)))
     |     | (I64OrOp, TI64Const(I64(0L)))
     |     | (I64XorOp, TI64Const(I64(0L)))
     |     | (I32AddOp, TI32Const(I32(0)))
     |     | (I64AddOp, TI64Const(I64(0L)))
     |     | (I32SubOp, TI32Const(I32(0)))
 320 |     | (I64SubOp, TI64Const(I64(0L))) => Some(left)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32AndOp, TI32Const(I32(-1))) | (I64AndOp, TI64Const(I64(-1L))) =>
     |       Some(left)
     |     (I32AndOp, TI32Const(I32(0))) =>
 324 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64AndOp, TI64Const(I64(0L))) =>
 326 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i64_const(I64(0L)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32OrOp, TI32Const(I32(-1))) =>
     |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(-1)), env))
     |     (I64OrOp, TI64Const(I64(-1L))) =>
 330 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i64_const(I64(-1L)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32EqOp, TI32Const(I32(0))) =>
     |       Some(TInstr::unary(UnaryOp::i32_eqz(), left))
     |     (I64EqOp, TI64Const(I64(0L))) =>
 334 |       Some(TInstr::unary(UnaryOp::i64_eqz(), left))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32MulOp, TI32Const(I32(1)))
     |     | (I64MulOp, TI64Const(I64(1L)))
     |     | (I32DivSOp, TI32Const(I32(1)))
     |     | (I32DivUOp, TI32Const(I32(1)))
     |     | (I64DivSOp, TI64Const(I64(1L)))
 340 |     | (I64DivUOp, TI64Const(I64(1L))) => Some(left)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32MulOp, TI32Const(I32(0))) =>
 342 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64MulOp, TI64Const(I64(0L))) =>
 344 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i64_const(I64(0L)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32RemSOp, TI32Const(I32(1)))
     |     | (I32RemUOp, TI32Const(I32(1)))
     |     | (I32RemSOp, TI32Const(I32(-1))) =>
 348 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64RemSOp, TI64Const(I64(1L)))
     |     | (I64RemUOp, TI64Const(I64(1L)))
     |     | (I64RemSOp, TI64Const(I64(-1L))) =>
 352 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i64_const(I64(0L)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32GeUOp, TI32Const(I32(0))) =>
     |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(1)), env))
     |     (I64GeUOp, TI64Const(I64(0L))) =>
     |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(1)), env))
     |     (I32LtUOp, TI32Const(I32(0))) =>
     |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |     (I64LtUOp, TI64Const(I64(0L))) =>
 360 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32LeUOp, TI32Const(I32(-1))) =>
 362 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(1)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64LeUOp, TI64Const(I64(-1L))) =>
 364 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(1)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32GtUOp, TI32Const(I32(-1))) =>
 366 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64GtUOp, TI64Const(I64(-1L))) =>
 368 |       Some(oi_seq([oi_instr_stmt(left, env)], TInstr::i32_const(I32(0)), env))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32LtUOp, TI32Const(I32(-1))) =>
 370 |       Some(TInstr::binary(BinaryOp::i32_ne(), left, TInstr::i32_const(I32(-1))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64LtUOp, TI64Const(I64(-1L))) =>
     |       Some(
     |         TInstr::binary(BinaryOp::i64_ne(), left, TInstr::i64_const(I64(-1L))),
     |       )
     |     (I32LeUOp, TI32Const(I32(0))) =>
 376 |       Some(TInstr::binary(BinaryOp::i32_eq(), left, TInstr::i32_const(I32(0))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64LeUOp, TI64Const(I64(0L))) =>
 378 |       Some(TInstr::binary(BinaryOp::i64_eq(), left, TInstr::i64_const(I64(0L))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32GtUOp, TI32Const(I32(0))) =>
 380 |       Some(TInstr::binary(BinaryOp::i32_ne(), left, TInstr::i32_const(I32(0))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64GtUOp, TI64Const(I64(0L))) =>
 382 |       Some(TInstr::binary(BinaryOp::i64_ne(), left, TInstr::i64_const(I64(0L))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32GeUOp, TI32Const(I32(-1))) =>
 384 |       Some(TInstr::binary(BinaryOp::i32_eq(), left, TInstr::i32_const(I32(-1))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64GeUOp, TI64Const(I64(-1L))) =>
 386 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         TInstr::binary(BinaryOp::i64_eq(), left, TInstr::i64_const(I64(-1L))),
     |       )
     |     (I32MulOp, TI32Const(I32(-1))) =>
     |       Some(TInstr::binary(BinaryOp::i32_sub(), TInstr::i32_const(I32(0)), left))
     |     (I64MulOp, TI64Const(I64(-1L))) =>
     |       Some(
     |         TInstr::binary(BinaryOp::i64_sub(), TInstr::i64_const(I64(0L)), left),
     |       )
     |     (I32DivUOp, TI32Const(I32(c))) =>
     |       if oi_is_power_of_2_i32(c) {
     |         Some(
     |           TInstr::binary(
     |             BinaryOp::i32_shr_u(),
     |             left,
     |             TInstr::i32_const(I32(oi_log2_i32(c))),
     |           ),
     |         )
     |       } else {
 405 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I64DivUOp, TI64Const(I64(c))) =>
     |       if oi_is_power_of_2_i64(c) {
     |         Some(
     |           TInstr::binary(
     |             BinaryOp::i64_shr_u(),
     |             left,
     |             TInstr::i64_const(I64(oi_log2_i64(c))),
     |           ),
     |         )
     |       } else {
 417 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I32RemUOp, TI32Const(I32(c))) =>
     |       if oi_is_power_of_2_i32(c) {
     |         Some(
     |           TInstr::binary(
     |             BinaryOp::i32_and(),
     |             left,
     |             TInstr::i32_const(I32(oi_wrap_i32(c - 1))),
     |           ),
     |         )
     |       } else {
 429 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I64RemUOp, TI64Const(I64(c))) =>
     |       if oi_is_power_of_2_i64(c) {
     |         Some(
     |           TInstr::binary(
     |             BinaryOp::i64_and(),
     |             left,
     |             TInstr::i64_const(I64(oi_wrap_i64(c - 1L))),
     |           ),
     |         )
     |       } else {
 441 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I32MulOp, TI32Const(I32(c))) =>
     |       if oi_is_power_of_2_i32(c) {
     |         Some(
     |           TInstr::binary(
     |             BinaryOp::i32_shl(),
     |             left,
     |             TInstr::i32_const(I32(oi_log2_i32(c))),
     |           ),
     |         )
     |       } else {
 453 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I64MulOp, TI64Const(I64(c))) =>
 456 |       if oi_is_power_of_2_i64(c) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(
     |           TInstr::binary(
     |             BinaryOp::i64_shl(),
     |             left,
 461 |             TInstr::i64_const(I64(oi_log2_i64(c))),
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ),
     |         )
     |       } else {
 465 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (F32MulOp, TF32Const(F32(-1.0))) =>
 468 |       Some(TInstr::unary(UnaryOp::f32_neg(), left))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64MulOp, TF64Const(F64(-1.0))) =>
 470 |       Some(TInstr::unary(UnaryOp::f64_neg(), left))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32AddOp, TF32Const(F32(v))) =>
 472 |       if options.optimize_level > 0 && v == 0.0 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(left)
     |       } else {
 475 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (F64AddOp, TF64Const(F64(v))) =>
 478 |       if options.optimize_level > 0 && v == 0.0 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(left)
     |       } else {
 481 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn oi_optimize_with_const_left(
     |   op : BinaryOp,
     |   left : TInstr,
     |   right : TInstr,
     |   _env : Env,
     | ) -> TInstr? {
     |   match (op, left) {
     |     (I32ShlOp, TI32Const(I32(0)))
     |     | (I32ShrSOp, TI32Const(I32(0)))
     |     | (I32ShrUOp, TI32Const(I32(0)))
     |     | (I64ShlOp, TI64Const(I64(0L)))
     |     | (I64ShrSOp, TI64Const(I64(0L)))
     |     | (I64ShrUOp, TI64Const(I64(0L))) =>
 501 |       if !oi_has_side_effects(right) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(left)
     |       } else {
 504 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I32ShrSOp, TI32Const(I32(-1)))
     |     | (I32RotlOp, TI32Const(I32(-1)))
     |     | (I32RotrOp, TI32Const(I32(-1)))
     |     | (I64ShrSOp, TI64Const(I64(-1L)))
     |     | (I64RotlOp, TI64Const(I64(-1L)))
     |     | (I64RotrOp, TI64Const(I64(-1L))) =>
 512 |       if !oi_has_side_effects(right) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(left)
     |       } else {
 515 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I32SubOp, TI32Const(I32(c1))) =>
     |       match right {
     |         TBinary(I32AddOp, x, TI32Const(I32(c2))) =>
     |           Some(
     |             TInstr::binary(
     |               BinaryOp::i32_sub(),
     |               TInstr::i32_const(I32(oi_wrap_i32(c1 - c2))),
     |               x,
     |             ),
     |           )
     |         TBinary(I32SubOp, TI32Const(I32(c2)), x) =>
 528 |           Some(
     |           ^^^^^ 	<-- UNCOVERED
     |             TInstr::binary(
     |               BinaryOp::i32_add(),
     |               x,
 532 |               TInstr::i32_const(I32(oi_wrap_i32(c1 - c2))),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         _ => None
     |       }
     |     (I64SubOp, TI64Const(I64(c1))) =>
     |       match right {
     |         TBinary(I64AddOp, x, TI64Const(I64(c2))) =>
 540 |           Some(
     |           ^^^^^ 	<-- UNCOVERED
     |             TInstr::binary(
     |               BinaryOp::i64_sub(),
     |               TInstr::i64_const(I64(oi_wrap_i64(c1 - c2))),
     |               x,
     |             ),
     |           )
     |         TBinary(I64SubOp, TI64Const(I64(c2)), x) =>
 548 |           Some(
     |           ^^^^^ 	<-- UNCOVERED
     |             TInstr::binary(
     |               BinaryOp::i64_add(),
     |               x,
 552 |               TInstr::i64_const(I64(oi_wrap_i64(c1 - c2))),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         _ => None
     |       }
 557 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oi_optimize_binary(
     |   op0 : BinaryOp,
     |   left0 : TInstr,
     |   right0 : TInstr,
     |   env : Env,
     |   options : OptimizeOptions,
     | ) -> TInstr? {
     |   let mut op = op0
     |   let mut left = left0
     |   let mut right = right0
     |   let mut changed = false
     |   if oi_is_symmetric(op) &&
     |     oi_is_const(left) &&
     |     !oi_is_const(right) &&
     |     oi_can_reorder(left, right) {
 577 |     let tmp = left
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     left = right
     |     right = tmp
     |     changed = true
     |   }
     |   if oi_is_relational(op) &&
     |     oi_is_const(left) &&
     |     !oi_is_const(right) &&
     |     oi_can_reorder(left, right) {
 586 |     match oi_reverse_relational(op) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(next) => {
     |         op = next
     |         let tmp = left
     |         left = right
     |         right = tmp
     |         changed = true
     |       }
 594 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if (
     |       op == BinaryOp::i32_sub() ||
     |       op == BinaryOp::i64_sub() ||
     |       op == BinaryOp::f32_sub() ||
     |       op == BinaryOp::f64_sub()
     |     ) &&
     |     oi_is_const(right) {
 604 |     match oi_negate_const(right) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(neg_right) => {
     |         right = neg_right
 607 |         op = match op {
     |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           I32SubOp => BinaryOp::i32_add()
     |           I64SubOp => BinaryOp::i64_add()
     |           F32SubOp => BinaryOp::f32_add()
     |           F64SubOp => BinaryOp::f64_add()
     |           _ => op
     |         }
     |         changed = true
     |       }
 616 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   if oi_is_shift(op) {
     |     match (op, right) {
     |       (op, TI32Const(I32(v))) if oi_is_i32_shift(op) => {
     |         let eff = v & 31
     |         if eff != v {
     |           right = TInstr::i32_const(I32(eff))
     |           changed = true
     |         }
     |         if eff == 0 {
     |           return Some(left)
     |         }
     |       }
     |       (op, TI64Const(I64(v))) if oi_is_i64_shift(op) => {
     |         let eff = v & 63L
     |         if eff != v {
 634 |           right = TInstr::i64_const(I64(eff))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           changed = true
     |         }
     |         if eff == 0L {
 638 |           return Some(left)
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       (_, TBinary(I32AndOp, y, TI32Const(I32(mask)))) if oi_is_i32_shift(op) =>
     |         if (mask & 31) == 31 {
     |           right = y
     |           changed = true
     |         }
     |       (_, TBinary(I64AndOp, y, TI64Const(I64(mask)))) if oi_is_i64_shift(op) =>
 647 |         if (mask & 63L) == 63L {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           right = y
     |           changed = true
     |         }
     |       _ => ()
     |     }
     |   }
     |   if op == BinaryOp::i32_and() {
     |     match (left, right) {
     |       (TUnary(I32EqzOp, x), TUnary(I32EqzOp, y)) =>
     |         return Some(
     |           TInstr::unary(
     |             UnaryOp::i32_eqz(),
     |             TInstr::binary(BinaryOp::i32_or(), x, y),
     |           ),
     |         )
     |       _ => ()
     |     }
     |   }
     |   match (op, left, right) {
     |     (F32AddOp, TUnary(F32NegOp, x), y) =>
 668 |       if oi_can_reorder(x, y) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return Some(TInstr::binary(BinaryOp::f32_sub(), y, x))
     |       }
     |     (F64AddOp, TUnary(F64NegOp, x), y) =>
 672 |       if oi_can_reorder(x, y) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return Some(TInstr::binary(BinaryOp::f64_sub(), y, x))
     |       }
     |     (F32AddOp, x, TUnary(F32NegOp, y)) =>
     |       return Some(TInstr::binary(BinaryOp::f32_sub(), x, y))
     |     (F64AddOp, x, TUnary(F64NegOp, y)) =>
 678 |       return Some(TInstr::binary(BinaryOp::f64_sub(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32SubOp, x, TUnary(F32NegOp, y)) =>
 680 |       return Some(TInstr::binary(BinaryOp::f32_add(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64SubOp, x, TUnary(F64NegOp, y)) =>
 682 |       return Some(TInstr::binary(BinaryOp::f64_add(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (
     |       I32MulOp,
     |       TBinary(I32SubOp, TI32Const(I32(0)), x),
     |       TBinary(I32SubOp, TI32Const(I32(0)), y),
     |     ) => return Some(TInstr::binary(BinaryOp::i32_mul(), x, y))
     |     (
     |       I64MulOp,
     |       TBinary(I64SubOp, TI64Const(I64(0L)), x),
     |       TBinary(I64SubOp, TI64Const(I64(0L)), y),
 692 |     ) => return Some(TInstr::binary(BinaryOp::i64_mul(), x, y))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32MulOp, TBinary(I32SubOp, TI32Const(I32(0)), x), y) =>
 694 |       if !oi_is_const(x) && !oi_is_const(y) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return Some(
     |           TInstr::binary(
     |             BinaryOp::i32_sub(),
     |             TInstr::i32_const(I32(0)),
     |             TInstr::binary(BinaryOp::i32_mul(), x, y),
     |           ),
     |         )
     |       }
     |     (I32MulOp, x, TBinary(I32SubOp, TI32Const(I32(0)), y)) =>
 704 |       if !oi_is_const(x) && !oi_is_const(y) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return Some(
     |           TInstr::binary(
     |             BinaryOp::i32_sub(),
     |             TInstr::i32_const(I32(0)),
     |             TInstr::binary(BinaryOp::i32_mul(), x, y),
     |           ),
     |         )
     |       }
     |     (I64MulOp, TBinary(I64SubOp, TI64Const(I64(0L)), x), y) =>
 714 |       if !oi_is_const(x) && !oi_is_const(y) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return Some(
     |           TInstr::binary(
     |             BinaryOp::i64_sub(),
     |             TInstr::i64_const(I64(0L)),
     |             TInstr::binary(BinaryOp::i64_mul(), x, y),
     |           ),
     |         )
     |       }
     |     (I64MulOp, x, TBinary(I64SubOp, TI64Const(I64(0L)), y)) =>
 724 |       if !oi_is_const(x) && !oi_is_const(y) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return Some(
     |           TInstr::binary(
     |             BinaryOp::i64_sub(),
     |             TInstr::i64_const(I64(0L)),
     |             TInstr::binary(BinaryOp::i64_mul(), x, y),
     |           ),
     |         )
     |       }
     |     (F32MulOp, TUnary(F32AbsOp, x), TUnary(F32AbsOp, y)) =>
 734 |       return Some(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::unary(
     |           UnaryOp::f32_abs(),
     |           TInstr::binary(BinaryOp::f32_mul(), x, y),
     |         ),
     |       )
     |     (F64MulOp, TUnary(F64AbsOp, x), TUnary(F64AbsOp, y)) =>
 741 |       return Some(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::unary(
     |           UnaryOp::f64_abs(),
     |           TInstr::binary(BinaryOp::f64_mul(), x, y),
     |         ),
     |       )
     |     (F32DivOp, TUnary(F32AbsOp, x), TUnary(F32AbsOp, y)) =>
 748 |       return Some(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::unary(
     |           UnaryOp::f32_abs(),
     |           TInstr::binary(BinaryOp::f32_div(), x, y),
     |         ),
     |       )
     |     (F64DivOp, TUnary(F64AbsOp, x), TUnary(F64AbsOp, y)) =>
 755 |       return Some(
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::unary(
     |           UnaryOp::f64_abs(),
     |           TInstr::binary(BinaryOp::f64_div(), x, y),
     |         ),
     |       )
     |     _ => ()
     |   }
     |   if oi_is_const(right) {
     |     match oi_optimize_with_const_right(op, left, right, env, options) {
     |       Some(rep) => return Some(rep)
     |       None => ()
     |     }
     |   }
     |   if oi_is_const(left) {
     |     match oi_optimize_with_const_left(op, left, right, env) {
     |       Some(rep) => return Some(rep)
     |       None => ()
     |     }
     |   }
     |   match (op, left, right) {
     |     (I32EqOp, TBinary(I32SubOp, x, y), TI32Const(I32(0)))
     |     | (I32NeOp, TBinary(I32SubOp, x, y), TI32Const(I32(0)))
     |     | (I32GtUOp, TBinary(I32SubOp, x, y), TI32Const(I32(0)))
 779 |     | (I32LeUOp, TBinary(I32SubOp, x, y), TI32Const(I32(0))) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let new_op = match op {
     |         I32GtUOp => BinaryOp::i32_ne()
     |         I32LeUOp => BinaryOp::i32_eq()
     |         _ => op
     |       }
 785 |       return Some(TInstr::binary(new_op, x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     (I64EqOp, TBinary(I64SubOp, x, y), TI64Const(I64(0L)))
     |     | (I64NeOp, TBinary(I64SubOp, x, y), TI64Const(I64(0L)))
     |     | (I64GtUOp, TBinary(I64SubOp, x, y), TI64Const(I64(0L)))
 790 |     | (I64LeUOp, TBinary(I64SubOp, x, y), TI64Const(I64(0L))) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let new_op = match op {
     |         I64GtUOp => BinaryOp::i64_ne()
     |         I64LeUOp => BinaryOp::i64_eq()
     |         _ => op
     |       }
 796 |       return Some(TInstr::binary(new_op, x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => ()
     |   }
     |   if left == right && !oi_has_side_effects(left) {
     |     match op {
     |       I32SubOp | I32XorOp => return Some(TInstr::i32_const(I32(0)))
 803 |       I64SubOp | I64XorOp => return Some(TInstr::i64_const(I64(0L)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       I32AndOp | I32OrOp | I64AndOp | I64OrOp => return Some(left)
     |       I32EqOp
     |       | I32LeSOp
     |       | I32LeUOp
     |       | I32GeSOp
     |       | I32GeUOp
     |       | I64EqOp
     |       | I64LeSOp
     |       | I64LeUOp
     |       | I64GeSOp
     |       | I64GeUOp => return Some(TInstr::i32_const(I32(1)))
     |       I32NeOp
     |       | I32LtSOp
     |       | I32LtUOp
     |       | I32GtSOp
     |       | I32GtUOp
     |       | I64NeOp
     |       | I64LtSOp
     |       | I64LtUOp
     |       | I64GtSOp
 824 |       | I64GtUOp => return Some(TInstr::i32_const(I32(0)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       _ => ()
     |     }
     |   }
     |   if changed {
     |     Some(oi_make_binary(op, left, right))
     |   } else {
     |     None
     |   }
     | }
     …

     | fn oi_optimize_unary(
     |   op : UnaryOp,
     |   value : TInstr,
     |   _env : Env,
     |   options : OptimizeOptions,
     | ) -> TInstr? {
     |   match (op, value) {
     |     (I32EqzOp, TBinary(I32SubOp, x, y)) =>
     |       Some(TInstr::binary(BinaryOp::i32_eq(), x, y))
     |     (I64EqzOp, TBinary(I64SubOp, x, y)) =>
 846 |       Some(TInstr::binary(BinaryOp::i64_eq(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32EqzOp, TBinary(I32AddOp, x, TI32Const(I32(c)))) =>
     |       Some(
     |         TInstr::binary(
     |           BinaryOp::i32_eq(),
     |           x,
     |           TInstr::i32_const(I32(oi_wrap_i32(-c))),
     |         ),
     |       )
     |     (I64EqzOp, TBinary(I64AddOp, x, TI64Const(I64(c)))) =>
 856 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         TInstr::binary(
     |           BinaryOp::i64_eq(),
     |           x,
 860 |           TInstr::i64_const(I64(oi_wrap_i64(-c))),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ),
     |       )
     |     (I32EqzOp, TUnary(I32EqzOp, x)) =>
 864 |       if options.shrink_level == 0 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(TInstr::binary(BinaryOp::i32_ne(), x, TInstr::i32_const(I32(0))))
     |       } else {
 867 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I32WrapI64Op, TUnary(I64ExtendI32SOp, x))
 870 |     | (I32WrapI64Op, TUnary(I64ExtendI32UOp, x)) => Some(x)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64ExtendI32SOp, TUnary(I32WrapI64Op, x)) =>
 872 |       Some(TInstr::unary(UnaryOp::i64_extend32s(), x))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32ReinterpretF32Op, TUnary(F32ReinterpretI32Op, x))
     |     | (I64ReinterpretF64Op, TUnary(F64ReinterpretI64Op, x))
     |     | (F32ReinterpretI32Op, TUnary(I32ReinterpretF32Op, x))
     |     | (F64ReinterpretI64Op, TUnary(I64ReinterpretF64Op, x)) => Some(x)
     |     (I32ReinterpretF32Op, TLoad(F32LoadOp, memarg, ptr)) =>
     |       Some(TInstr::load(LoadOp::i32_load(), memarg, ptr))
     |     (F32ReinterpretI32Op, TLoad(I32LoadOp, memarg, ptr)) =>
 880 |       Some(TInstr::load(LoadOp::f32_load(), memarg, ptr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64ReinterpretF64Op, TLoad(F64LoadOp, memarg, ptr)) =>
 882 |       Some(TInstr::load(LoadOp::i64_load(), memarg, ptr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64ReinterpretI64Op, TLoad(I64LoadOp, memarg, ptr)) =>
 884 |       Some(TInstr::load(LoadOp::f64_load(), memarg, ptr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32AbsOp, TUnary(F32NegOp, x)) =>
 886 |       Some(TInstr::unary(UnaryOp::f32_abs(), x))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64AbsOp, TUnary(F64NegOp, x)) =>
 888 |       Some(TInstr::unary(UnaryOp::f64_abs(), x))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32AbsOp, TBinary(F32MulOp, x, y)) if x == y =>
 890 |       Some(TInstr::binary(BinaryOp::f32_mul(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64AbsOp, TBinary(F64MulOp, x, y)) if x == y =>
 892 |       Some(TInstr::binary(BinaryOp::f64_mul(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32AbsOp, TBinary(F32DivOp, x, y)) if x == y =>
 894 |       Some(TInstr::binary(BinaryOp::f32_div(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64AbsOp, TBinary(F64DivOp, x, y)) if x == y =>
 896 |       Some(TInstr::binary(BinaryOp::f64_div(), x, y))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (_, TUnary(inner_op, x)) =>
 898 |       if inner_op == op {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match op {
     |           F32AbsOp
     |           | F32CeilOp
     |           | F32FloorOp
     |           | F32TruncOp
     |           | F32NearestOp
     |           | F64AbsOp
     |           | F64CeilOp
     |           | F64FloorOp
     |           | F64TruncOp
     |           | F64NearestOp
     |           | I32Extend8SOp
     |           | I32Extend16SOp
     |           | I64Extend8SOp
     |           | I64Extend16SOp
 914 |           | I64Extend32SOp => Some(TInstr::unary(op, x))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           F32NegOp | F64NegOp => Some(x)
     |           _ => None
     |         }
     |       } else {
 919 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     (I32EqzOp, TBinary(bin_op, x, y)) =>
     |       match oi_invert_relational(bin_op) {
 923 |         Some(inv) => Some(TInstr::binary(inv, x, y))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => None
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn oi_memory_is_64(mod : Module, memarg : MemArg) -> Bool {
     |   let MemArg(_, mem_idx, _) = memarg
     |   match mem_idx {
     |     Some(MemIdx(raw)) =>
 935 |       match mod.mem_sec {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(MemSec(memories)) =>
 937 |           match memories.get(raw.reinterpret_as_int()) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(MemType(I64Limits(_, _))) => true
     |             _ => false
     |           }
 941 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None =>
     |       match mod.mem_sec {
     |         Some(MemSec(memories)) =>
     |           match memories.get(0) {
 947 |             Some(MemType(I64Limits(_, _))) => true
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ => false
     |           }
 950 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn oi_fold_const_ptr_offset(
     |   ptr : TInstr,
     |   memarg : MemArg,
     |   mod : Module,
     | ) -> (TInstr, MemArg) {
     |   let MemArg(align, mem, U64(offset)) = memarg
     |   if offset == 0UL {
     |     return (ptr, memarg)
     |   }
     |   match ptr {
     |     TI32Const(I32(v)) if !oi_memory_is_64(mod, memarg) => {
     |       let value64 = v.reinterpret_as_uint().to_uint64()
     |       let max32 = 0x7fffffffUL
     |       if value64 <= max32 && offset <= max32 && value64 + offset <= max32 {
     |         let total = value64 + offset
     |         let out = total.to_uint().reinterpret_as_int()
     |         (TInstr::i32_const(I32(out)), MemArg::new(align, mem, U64(0UL)))
     |       } else {
 974 |         (ptr, memarg)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 977 |     TI64Const(I64(v)) if oi_memory_is_64(mod, memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value64 = v.reinterpret_as_uint64()
     |       let total = value64 + offset
     |       if total >= value64 {
 981 |         (
     |         ^ 	<-- UNCOVERED
     |           TInstr::i64_const(I64(total.reinterpret_as_int64())),
     |           MemArg::new(align, mem, U64(0UL)),
     |         )
     |       } else {
 986 |         (ptr, memarg)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 989 |     _ => (ptr, memarg)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oi_store_bytes(op : StoreOp) -> Int {
     |   match op {
     |     I32Store8Op | I64Store8Op | I32AtomicStore8Op | I64AtomicStore8Op => 1
 997 |     I32Store16Op | I64Store16Op | I32AtomicStore16Op | I64AtomicStore16Op => 2
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32StoreOp
     |     | F32StoreOp
     |     | I64Store32Op
     |     | I32AtomicStoreOp
     |     | I64AtomicStore32Op => 4
1003 |     I64StoreOp | F64StoreOp | I64AtomicStoreOp => 8
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128StoreOp => 16
     |   }
     | }
     …

     | fn oi_store_wrap_upgrade(op : StoreOp) -> StoreOp? {
     |   match op {
     |     I32StoreOp => Some(StoreOp::i64_store32())
1012 |     I32Store16Op => Some(StoreOp::i64_store16())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32Store8Op => Some(StoreOp::i64_store8())
     |     _ => None
     |   }
     | }
     …

     | fn oi_reinterpret_store(op : StoreOp, value : TInstr) -> (StoreOp, TInstr)? {
     |   match (op, value) {
     |     (F32StoreOp, TUnary(F32ReinterpretI32Op, x)) =>
     |       Some((StoreOp::i32_store(), x))
     |     (I32StoreOp, TUnary(I32ReinterpretF32Op, x)) =>
1024 |       Some((StoreOp::f32_store(), x))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64StoreOp, TUnary(F64ReinterpretI64Op, x)) =>
1026 |       Some((StoreOp::i64_store(), x))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64StoreOp, TUnary(I64ReinterpretF64Op, x)) =>
1028 |       Some((StoreOp::f64_store(), x))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => None
     |   }
     | }
     …

     | fn oi_optimize_store_value(op : StoreOp, value : TInstr) -> TInstr {
     |   let bytes = oi_store_bytes(op)
     |   let value = match value {
     |     TI32Const(I32(v)) if bytes < 4 => {
     |       let mask = match bytes {
     |         1 => 0xff
1040 |         2 => 0xffff
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => 0xffffffff
     |       }
     |       TInstr::i32_const(I32(oi_wrap_i32(v & mask)))
     |     }
1045 |     TI64Const(I64(v)) if bytes < 8 => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let mask = match bytes {
     |         1 => 0xffL
     |         2 => 0xffffL
     |         4 => 0xffffffffL
     |         _ => -1L
     |       }
1052 |       TInstr::i64_const(I64(oi_wrap_i64(v & mask)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     other => other
     |   }
     |   match value {
     |     TBinary(I32AndOp, x, TI32Const(I32(mask))) =>
1058 |       if (bytes == 1 && mask == 0xff) || (bytes == 2 && mask == 0xffff) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         x
     |       } else {
1061 |         value
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     TBinary(I64AndOp, x, TI64Const(I64(mask))) =>
1064 |       if (bytes == 1 && mask == 0xffL) ||
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (bytes == 2 && mask == 0xffffL) ||
     |         (bytes == 4 && mask == 0xffffffffL) {
1067 |         x
     |         ^ 	<-- UNCOVERED
     |       } else {
1069 |         value
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => value
     |   }
     | }
     …

     | fn oi_optimize_memory_copy(
     |   dst_mem : MemIdx,
     |   src_mem : MemIdx,
     |   dest : TInstr,
     |   source : TInstr,
     |   size : TInstr,
     |   env : Env,
     | ) -> TInstr? {
     |   match size {
     |     TI32Const(I32(0)) =>
     |       Some(
     |         TInstr::block(
     |           BlockType::void_(),
     |           TExpr::new([oi_instr_stmt(dest, env), oi_instr_stmt(source, env)]),
     |         ),
     |       )
     |     TI32Const(I32(bytes)) =>
     |       match bytes {
1094 |         1 => {
     |         ^^^^^^ 	<-- UNCOVERED
     |           let load_memarg = MemArg::new(U32(1), Some(src_mem), U64(0UL))
     |           let store_memarg = MemArg::new(U32(1), Some(dst_mem), U64(0UL))
     |           Some(
1098 |             TInstr::store(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               StoreOp::i32_store8(),
     |               store_memarg,
     |               dest,
1102 |               TInstr::load(LoadOp::i32_load8u(), load_memarg, source),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
1106 |         2 => {
     |         ^^^^^^ 	<-- UNCOVERED
     |           let load_memarg = MemArg::new(U32(2), Some(src_mem), U64(0UL))
     |           let store_memarg = MemArg::new(U32(2), Some(dst_mem), U64(0UL))
     |           Some(
1110 |             TInstr::store(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               StoreOp::i32_store16(),
     |               store_memarg,
     |               dest,
1114 |               TInstr::load(LoadOp::i32_load16u(), load_memarg, source),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
     |         4 => {
     |           let load_memarg = MemArg::new(U32(4), Some(src_mem), U64(0UL))
     |           let store_memarg = MemArg::new(U32(4), Some(dst_mem), U64(0UL))
     |           Some(
     |             TInstr::store(
     |               StoreOp::i32_store(),
     |               store_memarg,
     |               dest,
     |               TInstr::load(LoadOp::i32_load(), load_memarg, source),
     |             ),
     |           )
     |         }
1130 |         8 => {
     |         ^^^^^^ 	<-- UNCOVERED
     |           let load_memarg = MemArg::new(U32(8), Some(src_mem), U64(0UL))
     |           let store_memarg = MemArg::new(U32(8), Some(dst_mem), U64(0UL))
     |           Some(
1134 |             TInstr::store(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               StoreOp::i64_store(),
     |               store_memarg,
     |               dest,
1138 |               TInstr::load(LoadOp::i64_load(), load_memarg, source),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
1142 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
1144 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oi_optimize_memory_fill(
     |   mem_idx : MemIdx,
     |   dest : TInstr,
     |   value : TInstr,
     |   size : TInstr,
     |   env : Env,
     | ) -> TInstr? {
     |   match size {
     |     TI32Const(I32(0)) =>
     |       Some(
     |         TInstr::block(
     |           BlockType::void_(),
     |           TExpr::new([oi_instr_stmt(dest, env), oi_instr_stmt(value, env)]),
     |         ),
     |       )
     |     TI32Const(I32(1)) =>
     |       Some(
     |         TInstr::store(
     |           StoreOp::i32_store8(),
     |           MemArg::new(U32(1), Some(mem_idx), U64(0UL)),
     |           dest,
     |           value,
     |         ),
     |       )
     |     TI32Const(I32(bytes)) =>
     |       match (bytes, value) {
     |         (1, TI32Const(I32(v))) =>
1176 |           Some(
     |           ^^^^^ 	<-- UNCOVERED
     |             TInstr::store(
     |               StoreOp::i32_store8(),
     |               MemArg::new(U32(1), Some(mem_idx), U64(0UL)),
     |               dest,
1181 |               TInstr::i32_const(I32(v & 0xff)),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
1184 |         (2, TI32Const(I32(v))) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let x = v & 0xff
     |           Some(
1187 |             TInstr::store(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               StoreOp::i32_store16(),
     |               MemArg::new(U32(2), Some(mem_idx), U64(0UL)),
     |               dest,
1191 |               TInstr::i32_const(I32(oi_wrap_i32(x * 0x0101))),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
     |         (4, TI32Const(I32(v))) => {
     |           let x = v & 0xff
     |           Some(
     |             TInstr::store(
     |               StoreOp::i32_store(),
     |               MemArg::new(U32(4), Some(mem_idx), U64(0UL)),
     |               dest,
     |               TInstr::i32_const(I32(oi_wrap_i32(x * 0x01010101))),
     |             ),
     |           )
     |         }
1206 |         (8, TI32Const(I32(v))) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let x = (v & 0xff).to_int64()
     |           Some(
1209 |             TInstr::store(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               StoreOp::i64_store(),
     |               MemArg::new(U32(8), Some(mem_idx), U64(0UL)),
     |               dest,
1213 |               TInstr::i64_const(I64(oi_wrap_i64(x * 0x0101010101010101L))),
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ),
     |           )
     |         }
1217 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
1219 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn oi_optimize_select(
     |   _types : Array[ValType]?,
     |   cond : TInstr,
     |   if_true : TInstr,
     |   if_false : TInstr,
     |   env : Env,
     |   options : OptimizeOptions,
     | ) -> TInstr? {
     |   let cond = oi_optimize_boolean(cond, env, options)
     |   match cond {
     |     TI32Const(I32(v)) =>
     |       if v == 0 {
     |         Some(oi_seq([oi_instr_stmt(if_true, env)], if_false, env))
     |       } else {
1238 |         Some(oi_seq([oi_instr_stmt(if_false, env)], if_true, env))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ =>
     |       if if_true == if_false {
     |         if oi_has_side_effects(cond) {
1243 |           Some(oi_seq([oi_instr_stmt(cond, env)], if_true, env))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           Some(if_true)
     |         }
     |       } else {
1248 |         let max_bits = match (oi_const_i32(if_true), oi_const_i32(if_false)) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           (Some(1), Some(0)) => true
     |           _ => false
     |         }
     |         if max_bits {
1253 |           Some(cond)
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
1255 |           None
     |           ^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |   }
     | }
     …

     | fn oi_optimize_if(
     |   bt : BlockType,
     |   cond : TInstr,
     |   then_ : TExpr,
     |   else_ : TExpr?,
     |   env : Env,
     |   options : OptimizeOptions,
     | ) -> TInstr? {
     |   let cond = oi_optimize_boolean(cond, env, options)
     |   match else_ {
     |     Some(else_expr) =>
     |       match cond {
     |         TUnary(I32EqzOp, value) =>
     |           Some(TInstr::if_(bt, value, else_expr, Some(then_)))
     |         _ =>
     |           if then_ == else_expr {
     |             if oi_has_side_effects(cond) {
1279 |               let list = [oi_instr_stmt(cond, env)]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               for instr in then_.0 {
1281 |                 list.push(instr)
     |                 ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1283 |               Some(TInstr::block(bt, TExpr::new(list)))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else {
     |               Some(TInstr::block(bt, then_))
     |             }
     |           } else {
     |             Some(TInstr::if_(bt, cond, then_, Some(else_expr)))
     |           }
     |       }
     |     None =>
1292 |       if cond == oi_optimize_boolean(cond, env, options) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None
     |       } else {
1295 |         Some(TInstr::if_(bt, cond, then_, None))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn oi_optimize_once(
     |   instr : TInstr,
     |   env : Env,
     |   options : OptimizeOptions,
     |   mod : Module,
     | ) -> TInstr {
     |   match instr {
     |     TBinary(op, left, right) =>
     |       match oi_optimize_binary(op, left, right, env, options) {
     |         Some(rep) => rep
     |         None => instr
     |       }
     |     TUnary(op, value) =>
     |       match oi_optimize_unary(op, value, env, options) {
     |         Some(rep) => rep
     |         None => instr
     |       }
     |     TSelect(types, cond, if_true, if_false) =>
     |       match oi_optimize_select(types, cond, if_true, if_false, env, options) {
     |         Some(rep) => rep
1321 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TIf(bt, cond, then_, else_) =>
     |       match oi_optimize_if(bt, cond, then_, else_, env, options) {
     |         Some(rep) => rep
1326 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TGlobalSet(idx, TGlobalGet(get_idx)) if idx == get_idx => TInstr::nop()
     |     TBrIf(label, cond, values) =>
1330 |       TInstr::br_if(label, oi_optimize_boolean(cond, env, options), values)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoad(op, memarg, ptr) => {
     |       let (next_ptr, next_memarg) = oi_fold_const_ptr_offset(ptr, memarg, mod)
     |       TInstr::load(op, next_memarg, next_ptr)
     |     }
     |     TStore(op, memarg, ptr, value) => {
     |       let (next_ptr, next_memarg) = oi_fold_const_ptr_offset(ptr, memarg, mod)
     |       let mut next_op = op
     |       let mut next_value = oi_optimize_store_value(op, value)
     |       match next_value {
     |         TUnary(I32WrapI64Op, inner) =>
     |           match oi_store_wrap_upgrade(next_op) {
     |             Some(upgraded) => {
     |               next_op = upgraded
     |               next_value = inner
     |             }
1346 |             None => ()
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         _ => ()
     |       }
     |       match oi_reinterpret_store(next_op, next_value) {
     |         Some((rewritten_op, rewritten_value)) => {
     |           next_op = rewritten_op
     |           next_value = rewritten_value
     |         }
     |         None => ()
     |       }
     |       TInstr::store(next_op, next_memarg, next_ptr, next_value)
     |     }
     |     TMemoryCopy(dst_mem, src_mem, dest, source, size) =>
     |       match oi_optimize_memory_copy(dst_mem, src_mem, dest, source, size, env) {
     |         Some(rep) => rep
1362 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TMemoryFill(mem_idx, dest, value, size) =>
     |       match oi_optimize_memory_fill(mem_idx, dest, value, size, env) {
     |         Some(rep) => rep
1367 |         None => instr
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TCallRef(type_idx, args, target) =>
     |       match target {
     |         TRefFunc(func_idx) => TInstr::call(func_idx, args)
     |         TTableGet(table_idx, index) =>
1373 |           TInstr::call_indirect(type_idx, table_idx, args, index)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => instr
     |       }
     |     _ => instr
     |   }
     | }
     …

     | fn optimize_instructions_on_func(
     |   func : Func,
     |   mod : Module,
     |   options : OptimizeOptions,
     | ) -> Func {
     |   match func {
     |     TFunc(locals, body) => {
     |       let env = Env::new().with_module(mod).with_locals(locals)
     |       let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |         self,
     |         _,
     |         curr,
     |       ) {
     |         let walked = match self.walk_tinstruction_default((), curr) {
     |           Ok(Some((_, updated))) => updated
     |           Ok(None) => curr
1417 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let rewritten = oi_optimize_fixpoint(walked, env, options, mod)
     |         if rewritten == walked {
     |           unchanged()
     |         } else {
     |           change((), rewritten)
     |         }
     |       })
     |       let new_body = match walker.walk_texpr((), body) {
     |         Ok(Some((_, out))) => out
1428 |         Ok(None) => body
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(_) => body
     |       }
     |       Func::t_func(locals, new_body)
     |     }
1433 |     _ => func
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn optimize_instructions_ir_pass(
     |   mod : Module,
     |   options : OptimizeOptions,
     | ) -> ModuleTransformer[IRContext] {
     |   ModuleTransformer::new().on_func_evt(fn(_, ctx, func) {
     |     let next = optimize_instructions_on_func(func, mod, options)
     |     if next == func {
1445 |       unchanged()
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     } else {
     |       change(ctx, next)
     |     }
     |   })
     | }
     …

     | fn oi_run_func(
     |   body : Array[TInstr],
     |   locals? : Array[ValType] = [],
     |   options? : OptimizeOptions = OptimizeOptions::new(),
     |   with_memory? : Bool = false,
     | ) -> TExpr {
     |   let mut mod_ = Module::new().with_code_sec(
     |     CodeSec::new([Func::t_func(locals, TExpr::new(body))]),
     |   )
     |   if with_memory {
     |     mod_ = mod_.with_mem_sec(MemSec::new([MemType::new(Limits::i32(1, None))]))
     |   }
     |   let out = optimize_module_with_options(
     |     mod_,
     |     [ModulePass::OptimizeInstructions],
     |     options,
     |   ).unwrap()
     |   match out.code_sec {
     |     Some(CodeSec([TFunc(_, out_body)])) => out_body
1472 |     _ => abort("expected one transformed function")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

47 uncovered line(s) in src/passes/pick_load_signs.mbt:

    | fn pls_record_unsigned_usage(
    |   usages : Map[Int, PLSUsage],
    |   local_idx : Int,
    |   bits : Int,
    | ) -> Unit {
    |   let usage = pls_get_usage(usages, local_idx)
    |   if usage.unsigned_usages == 0 {
    |     usage.unsigned_bits = bits
    |   } else if usage.unsigned_bits != bits {
 71 |     usage.unsigned_bits = 0
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   usage.unsigned_usages += 1
    |   usages[local_idx] = usage
    | }
    …

    | fn pls_sign_relevant_load_info(op : LoadOp) -> (Bool, Int)? {
    |   match op {
    |     I32Load8SOp => Some((true, 8))
    |     I32Load8UOp => Some((false, 8))
    |     I32Load16SOp => Some((true, 16))
    |     I32Load16UOp => Some((false, 16))
 84 |     I64Load8SOp => Some((true, 8))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I64Load8UOp => Some((false, 8))
    |     I64Load16SOp => Some((true, 16))
    |     I64Load16UOp => Some((false, 16))
    |     I64Load32SOp => Some((true, 32))
    |     I64Load32UOp => Some((false, 32))
 90 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_load_with_signedness(op : LoadOp, signed : Bool) -> LoadOp? {
    |   match op {
    |     I32Load8SOp | I32Load8UOp =>
    |       if signed {
    |         Some(LoadOp::i32_load8s())
    |       } else {
    |         Some(LoadOp::i32_load8u())
    |       }
    |     I32Load16SOp | I32Load16UOp =>
    |       if signed {
105 |         Some(LoadOp::i32_load16s())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         Some(LoadOp::i32_load16u())
    |       }
    |     I64Load8SOp | I64Load8UOp =>
110 |       if signed {
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(LoadOp::i64_load8s())
    |       } else {
113 |         Some(LoadOp::i64_load8u())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     I64Load16SOp | I64Load16UOp =>
116 |       if signed {
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(LoadOp::i64_load16s())
    |       } else {
119 |         Some(LoadOp::i64_load16u())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     I64Load32SOp | I64Load32UOp =>
    |       if signed {
    |         Some(LoadOp::i64_load32s())
    |       } else {
    |         Some(LoadOp::i64_load32u())
    |       }
127 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_i32_const(instr : TInstr) -> Int? {
    |   match instr {
    |     TI32Const(I32(v)) => Some(v)
135 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_i64_const(instr : TInstr) -> Int64? {
    |   match instr {
    |     TI64Const(I64(v)) => Some(v)
143 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_i32_low_mask_bits(mask : Int) -> Int? {
    |   let mut bits = 0
    |   let mut value = mask.reinterpret_as_uint()
    |   while bits < 32 && (value & 1U) == 1U {
    |     bits += 1
    |     value = value >> 1
    |   }
    |   if bits > 0 && value == 0U {
    |     Some(bits)
    |   } else {
158 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_i64_low_mask_bits(mask : Int64) -> Int? {
    |   let mut bits = 0
    |   let mut value = mask.reinterpret_as_uint64()
    |   while bits < 64 && (value & 1UL) == 1UL {
    |     bits += 1
    |     value = value >> 1
    |   }
    |   if bits > 0 && value == 0UL {
    |     Some(bits)
    |   } else {
173 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_i64_shift_ext_bits(shift : Int64) -> Int {
185 |   let effective = shift.reinterpret_as_uint64() & 63UL
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   64 - effective.reinterpret_as_int64().to_int()
    | }
    …

    | fn pls_sign_ext_bits(parent : TInstr, value : TInstr) -> Int? {
    |   match parent {
    |     TUnary(I32Extend8SOp, child) if child == value => Some(8)
    |     TUnary(I32Extend16SOp, child) if child == value => Some(16)
194 |     TUnary(I64Extend8SOp, child) if child == value => Some(8)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TUnary(I64Extend16SOp, child) if child == value => Some(16)
    |     TUnary(I64Extend32SOp, child) if child == value => Some(32)
197 |     TUnary(I64ExtendI32SOp, child) if child == value => Some(32)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TBinary(I32ShrSOp, lhs, rhs_shift) =>
199 |       match lhs {
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |         TBinary(I32ShlOp, inner, lhs_shift) =>
201 |           if inner == value {
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             match (pls_i32_const(lhs_shift), pls_i32_const(rhs_shift)) {
    |               (Some(a), Some(b)) if a == b => Some(pls_i32_shift_ext_bits(a))
    |               _ => None
    |             }
    |           } else {
207 |             None
    |             ^^^^ 	<-- UNCOVERED
    |           }
209 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TBinary(I64ShrSOp, lhs, rhs_shift) =>
212 |       match lhs {
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |         TBinary(I64ShlOp, inner, lhs_shift) =>
214 |           if inner == value {
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             match (pls_i64_const(lhs_shift), pls_i64_const(rhs_shift)) {
    |               (Some(a), Some(b)) if a == b => Some(pls_i64_shift_ext_bits(a))
    |               _ => None
    |             }
    |           } else {
220 |             None
    |             ^^^^ 	<-- UNCOVERED
    |           }
222 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     _ => None
    |   }
    | }
    …

    | fn pls_zero_ext_bits(parent : TInstr, value : TInstr) -> Int? {
    |   match parent {
231 |     TUnary(I64ExtendI32UOp, child) if child == value => Some(32)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TBinary(I32AndOp, left, right) if left == value =>
    |       match pls_i32_const(right) {
    |         Some(mask) => pls_i32_low_mask_bits(mask)
235 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TBinary(I32AndOp, left, right) if right == value =>
238 |       match pls_i32_const(left) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(mask) => pls_i32_low_mask_bits(mask)
    |         None => None
    |       }
    |     TBinary(I64AndOp, left, right) if left == value =>
    |       match pls_i64_const(right) {
    |         Some(mask) => pls_i64_low_mask_bits(mask)
245 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TBinary(I64AndOp, left, right) if right == value =>
248 |       match pls_i64_const(left) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(mask) => pls_i64_low_mask_bits(mask)
    |         None => None
    |       }
    |     TBinary(I32ShrUOp, lhs, rhs_shift) =>
    |       match lhs {
    |         TBinary(I32ShlOp, inner, lhs_shift) =>
    |           if inner == value {
    |             match (pls_i32_const(lhs_shift), pls_i32_const(rhs_shift)) {
    |               (Some(a), Some(b)) if a == b => Some(pls_i32_shift_ext_bits(a))
258 |               _ => None
    |               ^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |           } else {
261 |             None
    |             ^^^^ 	<-- UNCOVERED
    |           }
263 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TBinary(I64ShrUOp, lhs, rhs_shift) =>
266 |       match lhs {
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |         TBinary(I64ShlOp, inner, lhs_shift) =>
268 |           if inner == value {
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             match (pls_i64_const(lhs_shift), pls_i64_const(rhs_shift)) {
    |               (Some(a), Some(b)) if a == b => Some(pls_i64_shift_ext_bits(a))
    |               _ => None
    |             }
    |           } else {
274 |             None
    |             ^^^^ 	<-- UNCOVERED
    |           }
276 |         _ => None
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     _ => None
    |   }
    | }
    …

    | fn pls_candidate_load(
    |   curr : TInstr,
    |   parent_stack : Array[TInstr],
    | ) -> PLSCandidateLoad? {
    |   match curr {
    |     TLoad(op, _, _) =>
    |       match pls_sign_relevant_load_info(op) {
    |         Some((current_signed, load_bits)) =>
    |           match parent_stack.last() {
    |             Some(TLocalSet(local_idx, _)) =>
    |               Some({
    |                 local_idx: pls_local_idx_to_int(local_idx),
    |                 load_bits,
    |                 current_signed,
    |               })
    |             _ => None
    |           }
312 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     _ => None
    |   }
    | }
    …

    | fn pls_analyze_body(body : TExpr) -> Result[PLSAnalysis, String] {
    |   let usage_by_local : Map[Int, PLSUsage] = Map::new()
    |   let candidates : Array[PLSCandidateLoad] = []
    |   let parent_stack : Array[TInstr] = []
    |   let scanner = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
    |     match pls_candidate_load(curr, parent_stack) {
    |       Some(candidate) => candidates.push(candidate)
    |       None => ()
    |     }
    |     match curr {
    |       TLocalGet(local_idx) => {
    |         let local_int = pls_local_idx_to_int(local_idx)
    |         let usage = pls_get_usage(usage_by_local, local_int)
    |         usage.total_usages += 1
    |         usage_by_local[local_int] = usage
    |         for depth in [1, 2] {
    |           match pls_get_parent_from_end(parent_stack, depth) {
    |             Some(parent) =>
    |               match pls_zero_ext_bits(parent, curr) {
    |                 Some(bits) =>
    |                   pls_record_unsigned_usage(usage_by_local, local_int, bits)
    |                 None =>
    |                   match pls_sign_ext_bits(parent, curr) {
    |                     Some(bits) =>
    |                       pls_record_signed_usage(usage_by_local, local_int, bits)
    |                     None => ()
    |                   }
    |               }
    |             None => ()
    |           }
    |         }
    |       }
    |       _ => ()
    |     }
    |     parent_stack.push(curr)
    |     let out = self.walk_tinstruction_default((), curr)
    |     ignore(parent_stack.pop())
    |     out
    |   })
    |   match scanner.walk_texpr((), body) {
    |     Ok(_) => Ok({ usage_by_local, candidates })
360 |     Err(e) => Err(e)
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn pls_rewrite_body(
    |   body : TExpr,
    |   decisions : Array[Bool],
    | ) -> Result[TExpr, String] {
    |   if decisions.is_empty() {
    |     return Ok(body)
    |   }
    |   let parent_stack : Array[TInstr] = []
    |   let next_candidate = Ref::new(0)
    |   let rewriter = ModuleTransformer::new().on_tinstruction_evt(fn(
    |     self,
    |     _,
    |     curr,
    |   ) {
    |     let candidate = pls_candidate_load(curr, parent_stack)
    |     parent_stack.push(curr)
    |     let walked = match self.walk_tinstruction_default((), curr) {
    |       Ok(Some((_, out))) => out
    |       Ok(None) => curr
403 |       Err(e) => return Err(e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     ignore(parent_stack.pop())
    |     let output = match candidate {
    |       Some(_) => {
    |         let target_signed = decisions[next_candidate.val]
    |         next_candidate.update(fn(n) { n + 1 })
    |         match walked {
    |           TLoad(op, memarg, ptr) =>
    |             match pls_load_with_signedness(op, target_signed) {
    |               Some(new_op) => TInstr::load(new_op, memarg, ptr)
414 |               None => walked
    |               ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
416 |           _ => walked
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       None => walked
    |     }
    |     if output == curr {
    |       unchanged()
    |     } else {
    |       change((), output)
    |     }
    |   })
    |   match rewriter.walk_texpr((), body) {
    |     Ok(Some((_, rewritten))) => Ok(rewritten)
429 |     Ok(None) => Ok(body)
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn pick_load_signs_on_func(func : Func) -> Result[Func, String] {
    |   match func {
437 |     Func(_) => Ok(func)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TFunc(locals, body) => {
    |       let analysis = match pls_analyze_body(body) {
    |         Ok(a) => a
441 |         Err(e) => return Err(e)
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let decisions = pls_plan_rewrites(analysis)
    |       let rewritten = match pls_rewrite_body(body, decisions) {
    |         Ok(out) => out
446 |         Err(e) => return Err(e)
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       Ok(Func::t_func(locals, rewritten))
    |     }
    |   }
    | }
    …

    | fn pick_load_signs_ir_pass(_mod : Module) -> ModuleTransformer[IRContext] {
    |   ModuleTransformer::new().on_func_evt(fn(_, state, func) {
    |     match pick_load_signs_on_func(func) {
    |       Ok(updated) =>
    |         if updated == func {
    |           unchanged()
    |         } else {
    |           change(state, updated)
    |         }
463 |       Err(e) => Err(e)
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn pls_run_func(func : Func) -> Func {
    |   let pass = pick_load_signs_ir_pass(Module::new())
    |   let state = IRContext::new()
    |   match pass.walk_func(state, func) {
    |     Ok(Some((_, out))) => out
474 |     Ok(None) => func
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => abort("pick_load_signs pass error: \{e}")
    |   }
    | }
    …

161 uncovered line(s) in src/passes/precompute.mbt:

     | fn pc_round_half_to_even_f64(x : Double) -> Double {
     |   if x.is_nan() || x.is_inf() {
  44 |     return x
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let t = x.trunc()
     |   let frac = (x - t).abs()
     |   if frac < 0.5 {
  49 |     t
     |     ^ 	<-- UNCOVERED
     |   } else if frac > 0.5 {
  51 |     t + (if x >= 0.0 { 1.0 } else { -1.0 })
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     let ti = t.to_int64()
     |     if (ti & 1L) == 0L {
     |       t
     |     } else {
     |       t + (if x >= 0.0 { 1.0 } else { -1.0 })
     |     }
     |   }
     | }
     …

     | fn pc_literal_from_instr(instr : TInstr) -> PCLiteral? {
     |   match instr {
     |     TI32Const(I32(v)) => Some(PCI32(v))
     |     TI64Const(I64(v)) => Some(PCI64(v))
  67 |     TF32Const(F32(v)) => Some(PCF32(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF64Const(F64(v)) => Some(PCF64(v))
     |     TRefNull(ht) => Some(PCRefNull(ht))
     |     TRefFunc(fi) => Some(PCRefFunc(fi))
     |     _ => None
     |   }
     | }
     …

     | fn pc_instr_from_literal(value : PCLiteral) -> TInstr {
     |   match value {
     |     PCI32(v) => TInstr::i32_const(I32(v))
     |     PCI64(v) => TInstr::i64_const(I64(v))
  80 |     PCF32(v) => TInstr::f32_const(F32(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     PCF64(v) => TInstr::f64_const(F64(v))
     |     PCRefNull(ht) => TInstr::ref_null(ht)
     |     PCRefFunc(fi) => TInstr::ref_func(fi)
     |   }
     | }
     …

     | fn pc_collect_immutable_globals(mod : Module) -> Map[GlobalIdx, PCLiteral] {
     |   let out : Map[GlobalIdx, PCLiteral] = Map::new()
     |   let imported = pc_imported_global_count(mod)
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for i = 0; i < globals.length(); i = i + 1 {
     |         match globals[i] {
     |           Global(GlobalType(_, is_mut), Expr(init_instrs)) =>
     |             if !is_mut {
     |               match init_instrs {
     |                 [I32Const(I32(v))] =>
     |                   out[GlobalIdx::new(imported + i.reinterpret_as_uint())] = PCI32(
     |                     v,
     |                   )
     |                 [I64Const(I64(v))] =>
     |                   out[GlobalIdx::new(imported + i.reinterpret_as_uint())] = PCI64(
     |                     v,
     |                   )
     |                 [F32Const(F32(v))] =>
     |                   out[GlobalIdx::new(imported + i.reinterpret_as_uint())] = PCF32(
     |                     v,
     |                   )
     |                 [F64Const(F64(v))] =>
     |                   out[GlobalIdx::new(imported + i.reinterpret_as_uint())] = PCF64(
     |                     v,
     |                   )
     |                 [RefNull(ht)] =>
     |                   out[GlobalIdx::new(imported + i.reinterpret_as_uint())] = PCRefNull(
     |                     ht,
     |                   )
     |                 [RefFunc(fi)] =>
     |                   out[GlobalIdx::new(imported + i.reinterpret_as_uint())] = PCRefFunc(
     |                     fi,
     |                   )
 138 |                 _ => ()
     |                 ^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn pc_eval_unary(op : UnaryOp, value : PCLiteral) -> PCLiteral? {
     |   match (op, value) {
     |     (I32EqzOp, PCI32(x)) => Some(PCI32(if x == 0 { 1 } else { 0 }))
     |     (I32ClzOp, PCI32(x)) => Some(PCI32(x.clz()))
 153 |     (I32CtzOp, PCI32(x)) => Some(PCI32(x.ctz()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32PopcntOp, PCI32(x)) => Some(PCI32(x.popcnt()))
     |     (I32WrapI64Op, PCI64(x)) => Some(PCI32(x.to_int()))
     |     (I32Extend8SOp, PCI32(x)) => Some(PCI32(x << 24 >> 24))
     |     (I32Extend16SOp, PCI32(x)) => Some(PCI32(x << 16 >> 16))
     |     (I64EqzOp, PCI64(x)) => Some(PCI32(if x == 0L { 1 } else { 0 }))
     |     (I64ClzOp, PCI64(x)) => Some(PCI64(x.clz().to_int64()))
     |     (I64CtzOp, PCI64(x)) => Some(PCI64(x.ctz().to_int64()))
     |     (I64PopcntOp, PCI64(x)) => Some(PCI64(x.popcnt().to_int64()))
     |     (I64ExtendI32SOp, PCI32(x)) => Some(PCI64(x.to_int64()))
     |     (I64ExtendI32UOp, PCI32(x)) =>
     |       Some(PCI64(x.reinterpret_as_uint().to_uint64().reinterpret_as_int64()))
 165 |     (I64Extend8SOp, PCI64(x)) => Some(PCI64(x << 56 >> 56))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64Extend16SOp, PCI64(x)) => Some(PCI64(x << 48 >> 48))
     |     (I64Extend32SOp, PCI64(x)) => Some(PCI64(x << 32 >> 32))
     |     (F32AbsOp, PCF32(x)) => Some(PCF32(x.abs()))
     |     (F32NegOp, PCF32(x)) => Some(PCF32(-x))
     |     (F32CeilOp, PCF32(x)) =>
 171 |       Some(PCF32(Float::from_double(x.to_double().ceil())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32FloorOp, PCF32(x)) =>
 173 |       Some(PCF32(Float::from_double(x.to_double().floor())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32TruncOp, PCF32(x)) =>
 175 |       Some(PCF32(Float::from_double(x.to_double().trunc())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32NearestOp, PCF32(x)) => Some(PCF32(pc_round_half_to_even_f32(x)))
     |     (F32SqrtOp, PCF32(x)) => Some(PCF32(x.sqrt()))
     |     (F64AbsOp, PCF64(x)) => Some(PCF64(x.abs()))
     |     (F64NegOp, PCF64(x)) => Some(PCF64(-x))
     |     (F64CeilOp, PCF64(x)) => Some(PCF64(x.ceil()))
     |     (F64FloorOp, PCF64(x)) => Some(PCF64(x.floor()))
     |     (F64TruncOp, PCF64(x)) => Some(PCF64(x.trunc()))
     |     (F64NearestOp, PCF64(x)) => Some(PCF64(pc_round_half_to_even_f64(x)))
     |     (F64SqrtOp, PCF64(x)) => Some(PCF64(x.sqrt()))
     |     (F32ReinterpretI32Op, PCI32(x)) =>
     |       Some(PCF32(Float::reinterpret_from_int(x)))
 187 |     (I32ReinterpretF32Op, PCF32(x)) => Some(PCI32(x.reinterpret_as_int()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64ReinterpretI64Op, PCI64(x)) => Some(PCF64(x.reinterpret_as_double()))
     |     (I64ReinterpretF64Op, PCF64(x)) => Some(PCI64(x.reinterpret_as_int64()))
     |     (F32ConvertI32SOp, PCI32(x)) =>
 191 |       Some(PCF32(Float::from_double(x.to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32ConvertI32UOp, PCI32(x)) =>
 193 |       Some(PCF32(Float::from_double(x.reinterpret_as_uint().to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32ConvertI64SOp, PCI64(x)) =>
 195 |       Some(PCF32(Float::from_double(x.to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32ConvertI64UOp, PCI64(x)) =>
 197 |       Some(PCF32(Float::from_double(x.reinterpret_as_uint64().to_double())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32DemoteF64Op, PCF64(x)) => Some(PCF32(Float::from_double(x)))
     |     (F64ConvertI32SOp, PCI32(x)) => Some(PCF64(x.to_double()))
     |     (F64ConvertI32UOp, PCI32(x)) =>
     |       Some(PCF64(x.reinterpret_as_uint().to_double()))
 202 |     (F64ConvertI64SOp, PCI64(x)) => Some(PCF64(x.to_double()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64ConvertI64UOp, PCI64(x)) =>
 204 |       Some(PCF64(x.reinterpret_as_uint64().to_double()))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64PromoteF32Op, PCF32(x)) => Some(PCF64(x.to_double()))
     |     _ => None
     |   }
     | }
     …

     | fn pc_eval_binary(
     |   op : BinaryOp,
     |   left : PCLiteral,
     |   right : PCLiteral,
     | ) -> PCLiteral? {
     |   match (op, left, right) {
     |     (I32AddOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x + y)))
     |     (I32SubOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x - y)))
     |     (I32MulOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x * y)))
     |     (I32DivSOp, PCI32(x), PCI32(y)) =>
     |       if y == 0 || (x == -2147483648 && y == -1) {
     |         None
     |       } else {
     |         Some(PCI32(pc_wrap_i32(x / y)))
     |       }
     |     (I32DivUOp, PCI32(x), PCI32(y)) =>
     |       if y == 0 {
     |         None
     |       } else {
 230 |         let xu = x.reinterpret_as_uint()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let yu = y.reinterpret_as_uint()
     |         Some(PCI32((xu / yu).reinterpret_as_int()))
     |       }
     |     (I32RemSOp, PCI32(x), PCI32(y)) =>
     |       if y == 0 {
     |         None
     |       } else {
 238 |         Some(PCI32(pc_wrap_i32(x % y)))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     (I32RemUOp, PCI32(x), PCI32(y)) =>
     |       if y == 0 {
     |         None
     |       } else {
 244 |         let xu = x.reinterpret_as_uint()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let yu = y.reinterpret_as_uint()
     |         Some(PCI32((xu % yu).reinterpret_as_int()))
     |       }
     |     (I32AndOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x & y)))
 249 |     (I32OrOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x | y)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32XorOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x ^ y)))
     |     (I32ShlOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x << (y & 31))))
     |     (I32ShrSOp, PCI32(x), PCI32(y)) => Some(PCI32(pc_wrap_i32(x >> (y & 31))))
     |     (I32ShrUOp, PCI32(x), PCI32(y)) =>
     |       Some(PCI32((x.reinterpret_as_uint() >> (y & 31)).reinterpret_as_int()))
 255 |     (I32RotlOp, PCI32(x), PCI32(y)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let k = y & 31
     |       if k == 0 {
 258 |         Some(PCI32(x))
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 260 |         let xu = x.reinterpret_as_uint()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCI32(((xu << k) | (xu >> (32 - k))).reinterpret_as_int()))
     |       }
     |     }
     |     (I32RotrOp, PCI32(x), PCI32(y)) => {
     |       let k = y & 31
     |       if k == 0 {
     |         Some(PCI32(x))
     |       } else {
 269 |         let xu = x.reinterpret_as_uint()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCI32(((xu >> k) | (xu << (32 - k))).reinterpret_as_int()))
     |       }
     |     }
     |     (I32EqOp, PCI32(x), PCI32(y)) => Some(PCI32(if x == y { 1 } else { 0 }))
 274 |     (I32NeOp, PCI32(x), PCI32(y)) => Some(PCI32(if x != y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32LtSOp, PCI32(x), PCI32(y)) => Some(PCI32(if x < y { 1 } else { 0 }))
     |     (I32LtUOp, PCI32(x), PCI32(y)) =>
 277 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint() < y.reinterpret_as_uint() {
 280 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 282 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 286 |     (I32GtSOp, PCI32(x), PCI32(y)) => Some(PCI32(if x > y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32GtUOp, PCI32(x), PCI32(y)) =>
 288 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint() > y.reinterpret_as_uint() {
 291 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 293 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 297 |     (I32LeSOp, PCI32(x), PCI32(y)) => Some(PCI32(if x <= y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32LeUOp, PCI32(x), PCI32(y)) =>
 299 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint() <= y.reinterpret_as_uint() {
 302 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 304 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 308 |     (I32GeSOp, PCI32(x), PCI32(y)) => Some(PCI32(if x >= y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I32GeUOp, PCI32(x), PCI32(y)) =>
 310 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint() >= y.reinterpret_as_uint() {
 313 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 315 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 319 |     (I64AddOp, PCI64(x), PCI64(y)) => Some(PCI64(pc_wrap_i64(x + y)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64SubOp, PCI64(x), PCI64(y)) => Some(PCI64(pc_wrap_i64(x - y)))
     |     (I64MulOp, PCI64(x), PCI64(y)) => Some(PCI64(pc_wrap_i64(x * y)))
     |     (I64DivSOp, PCI64(x), PCI64(y)) =>
 323 |       if y == 0L || (x == -9223372036854775808L && y == -1L) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None
     |       } else {
 326 |         Some(PCI64(pc_wrap_i64(x / y)))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     (I64DivUOp, PCI64(x), PCI64(y)) =>
 329 |       if y == 0L {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None
     |       } else {
 332 |         let xu = x.reinterpret_as_uint64()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let yu = y.reinterpret_as_uint64()
     |         Some(PCI64((xu / yu).reinterpret_as_int64()))
     |       }
     |     (I64RemSOp, PCI64(x), PCI64(y)) =>
 337 |       if y == 0L {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None
     |       } else {
 340 |         Some(PCI64(pc_wrap_i64(x % y)))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     (I64RemUOp, PCI64(x), PCI64(y)) =>
 343 |       if y == 0L {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None
     |       } else {
 346 |         let xu = x.reinterpret_as_uint64()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let yu = y.reinterpret_as_uint64()
     |         Some(PCI64((xu % yu).reinterpret_as_int64()))
     |       }
 350 |     (I64AndOp, PCI64(x), PCI64(y)) => Some(PCI64(pc_wrap_i64(x & y)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64OrOp, PCI64(x), PCI64(y)) => Some(PCI64(pc_wrap_i64(x | y)))
     |     (I64XorOp, PCI64(x), PCI64(y)) => Some(PCI64(pc_wrap_i64(x ^ y)))
     |     (I64ShlOp, PCI64(x), PCI64(y)) =>
 354 |       Some(PCI64(pc_wrap_i64(x << (y & 63L).to_int())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64ShrSOp, PCI64(x), PCI64(y)) =>
 356 |       Some(PCI64(pc_wrap_i64(x >> (y & 63L).to_int())))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64ShrUOp, PCI64(x), PCI64(y)) =>
 358 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI64(
 360 |           (x.reinterpret_as_uint64() >> (y & 63L).to_int()).reinterpret_as_int64(),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ),
     |       )
 363 |     (I64RotlOp, PCI64(x), PCI64(y)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let k = (y & 63L).to_int()
     |       if k == 0 {
 366 |         Some(PCI64(x))
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 368 |         let xu = x.reinterpret_as_uint64()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCI64(((xu << k) | (xu >> (64 - k))).reinterpret_as_int64()))
     |       }
     |     }
 372 |     (I64RotrOp, PCI64(x), PCI64(y)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let k = (y & 63L).to_int()
     |       if k == 0 {
 375 |         Some(PCI64(x))
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 377 |         let xu = x.reinterpret_as_uint64()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCI64(((xu >> k) | (xu << (64 - k))).reinterpret_as_int64()))
     |       }
     |     }
 381 |     (I64EqOp, PCI64(x), PCI64(y)) => Some(PCI32(if x == y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64NeOp, PCI64(x), PCI64(y)) => Some(PCI32(if x != y { 1 } else { 0 }))
     |     (I64LtSOp, PCI64(x), PCI64(y)) => Some(PCI32(if x < y { 1 } else { 0 }))
     |     (I64LtUOp, PCI64(x), PCI64(y)) =>
 385 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint64() < y.reinterpret_as_uint64() {
 388 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 390 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 394 |     (I64GtSOp, PCI64(x), PCI64(y)) => Some(PCI32(if x > y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64GtUOp, PCI64(x), PCI64(y)) =>
 396 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint64() > y.reinterpret_as_uint64() {
 399 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 401 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 405 |     (I64LeSOp, PCI64(x), PCI64(y)) => Some(PCI32(if x <= y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64LeUOp, PCI64(x), PCI64(y)) =>
 407 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint64() <= y.reinterpret_as_uint64() {
 410 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 412 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 416 |     (I64GeSOp, PCI64(x), PCI64(y)) => Some(PCI32(if x >= y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I64GeUOp, PCI64(x), PCI64(y)) =>
 418 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCI32(
     |           if x.reinterpret_as_uint64() >= y.reinterpret_as_uint64() {
 421 |             1
     |             ^ 	<-- UNCOVERED
     |           } else {
 423 |             0
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 427 |     (F32AddOp, PCF32(x), PCF32(y)) => Some(PCF32(x + y))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32SubOp, PCF32(x), PCF32(y)) => Some(PCF32(x - y))
     |     (F32MulOp, PCF32(x), PCF32(y)) => Some(PCF32(x * y))
     |     (F32DivOp, PCF32(x), PCF32(y)) => Some(PCF32(x / y))
     |     (F32MinOp, PCF32(x), PCF32(y)) =>
 432 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCF32(
     |           if x.is_nan() || y.is_nan() {
 435 |             @float.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x < y {
     |             x
     |           } else {
 439 |             y
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (F32MaxOp, PCF32(x), PCF32(y)) =>
 444 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCF32(
     |           if x.is_nan() || y.is_nan() {
 447 |             @float.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x > y {
     |             x
     |           } else {
 451 |             y
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 455 |     (F32CopysignOp, PCF32(x), PCF32(y)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let x_abs = x.abs()
     |       Some(PCF32(if y.reinterpret_as_int() < 0 { -x_abs } else { x_abs }))
     |     }
 459 |     (F32EqOp, PCF32(x), PCF32(y)) => Some(PCI32(if x == y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F32NeOp, PCF32(x), PCF32(y)) => Some(PCI32(if x != y { 1 } else { 0 }))
     |     (F32LtOp, PCF32(x), PCF32(y)) => Some(PCI32(if x < y { 1 } else { 0 }))
     |     (F32GtOp, PCF32(x), PCF32(y)) => Some(PCI32(if x > y { 1 } else { 0 }))
     |     (F32LeOp, PCF32(x), PCF32(y)) => Some(PCI32(if x <= y { 1 } else { 0 }))
     |     (F32GeOp, PCF32(x), PCF32(y)) => Some(PCI32(if x >= y { 1 } else { 0 }))
     |     (F64AddOp, PCF64(x), PCF64(y)) => Some(PCF64(x + y))
     |     (F64SubOp, PCF64(x), PCF64(y)) => Some(PCF64(x - y))
     |     (F64MulOp, PCF64(x), PCF64(y)) => Some(PCF64(x * y))
     |     (F64DivOp, PCF64(x), PCF64(y)) => Some(PCF64(x / y))
     |     (F64MinOp, PCF64(x), PCF64(y)) =>
 470 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCF64(
     |           if x.is_nan() || y.is_nan() {
 473 |             @double.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x < y {
     |             x
     |           } else {
 477 |             y
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
     |     (F64MaxOp, PCF64(x), PCF64(y)) =>
 482 |       Some(
     |       ^^^^^ 	<-- UNCOVERED
     |         PCF64(
     |           if x.is_nan() || y.is_nan() {
 485 |             @double.not_a_number
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else if x > y {
     |             x
     |           } else {
 489 |             y
     |             ^ 	<-- UNCOVERED
     |           },
     |         ),
     |       )
 493 |     (F64CopysignOp, PCF64(x), PCF64(y)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let x_abs = x.abs()
     |       Some(PCF64(if y.reinterpret_as_int64() < 0L { -x_abs } else { x_abs }))
     |     }
 497 |     (F64EqOp, PCF64(x), PCF64(y)) => Some(PCI32(if x == y { 1 } else { 0 }))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (F64NeOp, PCF64(x), PCF64(y)) => Some(PCI32(if x != y { 1 } else { 0 }))
     |     (F64LtOp, PCF64(x), PCF64(y)) => Some(PCI32(if x < y { 1 } else { 0 }))
     |     (F64GtOp, PCF64(x), PCF64(y)) => Some(PCI32(if x > y { 1 } else { 0 }))
     |     (F64LeOp, PCF64(x), PCF64(y)) => Some(PCI32(if x <= y { 1 } else { 0 }))
     |     (F64GeOp, PCF64(x), PCF64(y)) => Some(PCI32(if x >= y { 1 } else { 0 }))
     |     _ => None
     |   }
     | }
     …

     | fn pc_eval_texpr_const(
     |   expr : TExpr,
     |   imm_globals : Map[GlobalIdx, PCLiteral],
     | ) -> PCLiteral? {
 512 |   let TExpr(instrs) = expr
     |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if instrs.is_empty() {
 514 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut last : PCLiteral? = None
     |   for instr in instrs {
 518 |     match pc_eval_const_expr(instr, imm_globals) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(v) => last = Some(v)
     |       None => return None
     |     }
     |   }
     |   last
     | }
     …

     | fn pc_eval_const_expr(
     |   instr : TInstr,
     |   imm_globals : Map[GlobalIdx, PCLiteral],
     | ) -> PCLiteral? {
     |   match pc_literal_from_instr(instr) {
     |     Some(lit) => return Some(lit)
     |     None => ()
     |   }
     |   match instr {
 536 |     TGlobalGet(idx) => imm_globals.get(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TUnary(op, child) =>
     |       match pc_eval_const_expr(child, imm_globals) {
     |         Some(v) => pc_eval_unary(op, v)
 540 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TBinary(op, left, right) =>
     |       match
     |         (
     |           pc_eval_const_expr(left, imm_globals),
     |           pc_eval_const_expr(right, imm_globals),
     |         ) {
     |         (Some(a), Some(b)) => pc_eval_binary(op, a, b)
     |         _ => None
     |       }
     |     TRefEq(left, right) =>
 552 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         (
     |           pc_eval_const_expr(left, imm_globals),
     |           pc_eval_const_expr(right, imm_globals),
     |         ) {
 557 |         (Some(PCRefNull(_)), Some(PCRefNull(_))) => Some(PCI32(1))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(PCRefFunc(a)), Some(PCRefFunc(b))) =>
 559 |           Some(PCI32(if a == b { 1 } else { 0 }))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(PCRefNull(_)), Some(PCRefFunc(_)))
 561 |         | (Some(PCRefFunc(_)), Some(PCRefNull(_))) => Some(PCI32(0))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TRefIsNull(value) =>
 565 |       match pc_eval_const_expr(value, imm_globals) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCRefNull(_)) => Some(PCI32(1))
     |         Some(PCRefFunc(_)) => Some(PCI32(0))
     |         _ => None
     |       }
     |     TSelect(_, cond, if_true, if_false) =>
     |       match
     |         (
     |           pc_eval_const_expr(cond, imm_globals),
     |           pc_eval_const_expr(if_true, imm_globals),
     |           pc_eval_const_expr(if_false, imm_globals),
     |         ) {
     |         (Some(PCI32(c)), Some(t), Some(f)) =>
 578 |           if c == 0 {
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(f)
     |           } else {
 581 |             Some(t)
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         _ => None
     |       }
 585 |     TBlock(_, body) => pc_eval_texpr_const(body, imm_globals)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) =>
 587 |       match pc_eval_const_expr(cond, imm_globals) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCI32(v)) =>
 589 |           if v == 0 {
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             match else_body {
     |               Some(body) => pc_eval_texpr_const(body, imm_globals)
     |               None => None
     |             }
     |           } else {
 595 |             pc_eval_texpr_const(then_body, imm_globals)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 597 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn pc_literal_maps_equal(
     |   a : Map[Int, PCLiteral],
     |   b : Map[Int, PCLiteral],
     | ) -> Bool {
     |   if a.length() != b.length() {
 609 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   for k, v in a {
     |     match b.get(k) {
     |       Some(other) if other == v => ()
 614 |       _ => return false
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   true
     | }
     …

     | fn pc_set_literal_maps_equal(
     |   a : Map[PCSetKey, PCLiteral],
     |   b : Map[PCSetKey, PCLiteral],
     | ) -> Bool {
     |   if a.length() != b.length() {
     |     return false
     |   }
     |   for k, v in a {
     |     match b.get(k) {
     |       Some(other) if other == v => ()
 631 |       _ => return false
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   true
     | }
     …

     | fn pc_advance_get_ids(instr : TInstr, get_id : Ref[Int]) -> Unit {
 639 |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     match curr {
     |       TLocalGet(_) => get_id.update(fn(n) { n + 1 })
     |       _ => ()
     |     }
 644 |     self.walk_tinstruction_default((), curr)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   })
 646 |   ignore(walker.walk_tinstruction((), instr))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn pc_get_constant_for_get_id(
     |   graph : LocalGraph,
     |   get_id : Int,
     |   set_values : Map[PCSetKey, PCLiteral],
     |   branchy_locals : Set[LocalIdx],
     | ) -> PCLiteral? {
     |   let sets = graph.get_sets(get_id)
     |   if sets.is_empty() {
 658 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut value : PCLiteral? = None
     |   for set_ in sets {
     |     let current = match set_ {
     |       LocalSet::InitValue => return None
     |       LocalSet::Set(local_idx, root) =>
     |         if branchy_locals.contains(local_idx) {
     |           return None
     |         } else {
     |           match set_values.get({ local_idx, root }) {
     |             Some(v) => v
     |             None => return None
     |           }
     |         }
     |     }
     |     match value {
 675 |       Some(existing) if existing != current => return None
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => value = Some(current)
 677 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   value
     | }
     …

     | fn pc_mark_branchy_locals_instr(
     |   instr : TInstr,
     |   in_if : Bool,
     |   branchy_locals : Set[LocalIdx],
     | ) -> Unit {
     |   match instr {
     |     TIf(_, cond, then_body, else_body) => {
     |       pc_mark_branchy_locals_instr(cond, in_if, branchy_locals)
     |       for item in then_body.0 {
     |         pc_mark_branchy_locals_instr(item, true, branchy_locals)
     |       }
     |       match else_body {
     |         Some(other) =>
     |           for item in other.0 {
     |             pc_mark_branchy_locals_instr(item, true, branchy_locals)
     |           }
 700 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 704 |       for item in body.0 {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         pc_mark_branchy_locals_instr(item, in_if, branchy_locals)
     |       }
     |     TLocalSet(local_idx, value) => {
     |       if in_if {
     |         branchy_locals.add(local_idx)
     |       }
     |       pc_mark_branchy_locals_instr(value, in_if, branchy_locals)
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         pc_mark_branchy_locals_instr(child, in_if, branchy_locals)
     |       }
     |   }
     | }
     …

     | fn pc_eval_expr_for_prop(
     |   instr : TInstr,
     |   graph : LocalGraph,
     |   set_values : Map[PCSetKey, PCLiteral],
     |   imm_globals : Map[GlobalIdx, PCLiteral],
     |   branchy_locals : Set[LocalIdx],
     |   get_id : Ref[Int],
     | ) -> PCLiteral? {
     |   match pc_literal_from_instr(instr) {
     |     Some(v) => return Some(v)
     |     None => ()
     |   }
     |   match instr {
     |     TLocalGet(_) => {
     |       let id = get_id.val
     |       get_id.update(fn(n) { n + 1 })
     |       pc_get_constant_for_get_id(graph, id, set_values, branchy_locals)
     |     }
 748 |     TGlobalGet(idx) => imm_globals.get(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TUnary(op, child) =>
 750 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         pc_eval_expr_for_prop(
     |           child, graph, set_values, imm_globals, branchy_locals, get_id,
     |         ) {
 754 |         Some(v) => pc_eval_unary(op, v)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => None
     |       }
     |     TBinary(op, left, right) =>
     |       match
     |         (
     |           pc_eval_expr_for_prop(
     |             left, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
     |           pc_eval_expr_for_prop(
     |             right, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
     |         ) {
     |         (Some(a), Some(b)) => pc_eval_binary(op, a, b)
     |         _ => None
     |       }
     |     TRefEq(left, right) =>
 771 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         (
     |           pc_eval_expr_for_prop(
     |             left, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
 776 |           pc_eval_expr_for_prop(
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             right, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
     |         ) {
 780 |         (Some(PCRefNull(_)), Some(PCRefNull(_))) => Some(PCI32(1))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(PCRefFunc(a)), Some(PCRefFunc(b))) =>
 782 |           Some(PCI32(if a == b { 1 } else { 0 }))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(PCRefNull(_)), Some(PCRefFunc(_)))
 784 |         | (Some(PCRefFunc(_)), Some(PCRefNull(_))) => Some(PCI32(0))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |     TRefIsNull(value) =>
 788 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         pc_eval_expr_for_prop(
     |           value, graph, set_values, imm_globals, branchy_locals, get_id,
     |         ) {
 792 |         Some(PCRefNull(_)) => Some(PCI32(1))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(PCRefFunc(_)) => Some(PCI32(0))
     |         _ => None
     |       }
     |     TSelect(_, cond, if_true, if_false) =>
 797 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         (
     |           pc_eval_expr_for_prop(
     |             cond, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
 802 |           pc_eval_expr_for_prop(
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             if_true, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
 805 |           pc_eval_expr_for_prop(
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             if_false, graph, set_values, imm_globals, branchy_locals, get_id,
     |           ),
     |         ) {
     |         (Some(PCI32(c)), Some(t), Some(f)) =>
 810 |           if c == 0 {
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(f)
     |           } else {
 813 |             Some(t)
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
 815 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
 817 |     _ => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       pc_advance_get_ids(instr, get_id)
     |       None
     |     }
     |   }
     | }
     …

     | fn pc_replace_gets_with_constants(
     |   body : TExpr,
     |   get_values : Map[Int, PCLiteral],
     | ) -> TExpr {
     |   if get_values.is_empty() {
     |     return body
     |   }
     |   let next_get_id = Ref::new(0)
     |   let replacer = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     _,
     |     curr,
     |   ) {
     |     match curr {
     |       TLocalGet(_) => {
     |         let current_id = next_get_id.val
     |         next_get_id.update(fn(n) { n + 1 })
     |         match get_values.get(current_id) {
     |           Some(v) => change((), pc_instr_from_literal(v))
 911 |           None => unchanged()
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ => self.walk_tinstruction_default((), curr)
     |     }
     |   })
     |   match replacer.walk_texpr((), body) {
     |     Ok(Some((_, out))) => out
 919 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn pc_try_partial_precompute(
     |   instr : TInstr,
     |   imm_globals : Map[GlobalIdx, PCLiteral],
     | ) -> TInstr? {
     |   match instr {
     |     TUnary(op, TSelect(types, cond, if_true, if_false)) =>
     |       if pc_is_constant_like(if_true, imm_globals) &&
     |         pc_is_constant_like(if_false, imm_globals) {
     |         let true_eval = pc_eval_const_expr(
     |           TInstr::unary(op, if_true),
     |           imm_globals,
     |         )
     |         let false_eval = pc_eval_const_expr(
     |           TInstr::unary(op, if_false),
     |           imm_globals,
     |         )
     |         match (true_eval, false_eval) {
     |           (Some(t), Some(f)) =>
     |             Some(
     |               TInstr::select(
     |                 types,
     |                 cond,
     |                 pc_instr_from_literal(t),
     |                 pc_instr_from_literal(f),
     |               ),
     |             )
 972 |           _ => None
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
 975 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     TBinary(op, TSelect(types, cond, if_true, if_false), right) =>
     |       if pc_is_constant_like(if_true, imm_globals) &&
     |         pc_is_constant_like(if_false, imm_globals) &&
     |         pc_is_constant_like(right, imm_globals) {
     |         let true_eval = pc_eval_const_expr(
     |           TInstr::binary(op, if_true, right),
     |           imm_globals,
     |         )
     |         let false_eval = pc_eval_const_expr(
     |           TInstr::binary(op, if_false, right),
     |           imm_globals,
     |         )
     |         match (true_eval, false_eval) {
     |           (Some(t), Some(f)) =>
     |             Some(
     |               TInstr::select(
     |                 types,
     |                 cond,
     |                 pc_instr_from_literal(t),
     |                 pc_instr_from_literal(f),
     |               ),
     |             )
 999 |           _ => None
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
     |         None
     |       }
     |     TBinary(op, left, TSelect(types, cond, if_true, if_false)) =>
1005 |       if pc_is_constant_like(if_true, imm_globals) &&
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         pc_is_constant_like(if_false, imm_globals) &&
     |         pc_is_constant_like(left, imm_globals) {
1008 |         let true_eval = pc_eval_const_expr(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TInstr::binary(op, left, if_true),
     |           imm_globals,
     |         )
1012 |         let false_eval = pc_eval_const_expr(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TInstr::binary(op, left, if_false),
     |           imm_globals,
     |         )
1016 |         match (true_eval, false_eval) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           (Some(t), Some(f)) =>
1018 |             Some(
     |             ^^^^^ 	<-- UNCOVERED
     |               TInstr::select(
     |                 types,
     |                 cond,
1022 |                 pc_instr_from_literal(t),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 pc_instr_from_literal(f),
     |               ),
     |             )
1026 |           _ => None
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
1029 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |     _ => None
     |   }
     | }
     …

     | fn pc_fold_instr(
     |   instr : TInstr,
     |   imm_globals : Map[GlobalIdx, PCLiteral],
     |   options : OptimizeOptions,
     | ) -> TInstr {
     |   match instr {
     |     TGlobalGet(idx) =>
     |       match imm_globals.get(idx) {
     |         Some(v) => return pc_instr_from_literal(v)
1045 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => ()
     |   }
     |   match instr {
     |     TSelect(_, cond, if_true, if_false) =>
     |       match pc_eval_const_expr(cond, imm_globals) {
     |         Some(PCI32(v)) =>
1053 |           if pc_is_effectively_pure(if_true) && pc_is_effectively_pure(if_false) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             return if v == 0 { if_false } else { if_true }
     |           }
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     |   if options.optimize_level >= 2 {
     |     match pc_try_partial_precompute(instr, imm_globals) {
     |       Some(next) => return next
     |       None => ()
     |     }
     |   }
     |   if pc_is_effectively_pure(instr) {
     |     match pc_eval_const_expr(instr, imm_globals) {
     |       Some(v) => return pc_instr_from_literal(v)
     |       None => ()
     |     }
     |   }
     |   instr
     | }
     …

     | fn pc_simplify_body(
     |   body : TExpr,
     |   imm_globals : Map[GlobalIdx, PCLiteral],
     |   options : OptimizeOptions,
     | ) -> TExpr {
     |   let pass = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, curr) {
     |     let walked = match self.walk_tinstruction_default((), curr) {
     |       Ok(Some((_, out))) => out
     |       Ok(None) => curr
1085 |       Err(_) => curr
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let next = pc_fold_instr(walked, imm_globals, options)
     |     if next == walked {
     |       unchanged()
     |     } else {
     |       change((), next)
     |     }
     |   })
     |   match pass.walk_texpr((), body) {
     |     Ok(Some((_, out))) => out
1096 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn precompute_on_func(
     |   func : Func,
     |   mod : Module,
     |   options : OptimizeOptions,
     |   propagate : Bool,
     | ) -> Result[Func, String] {
     |   let imm_globals = pc_collect_immutable_globals(mod)
     |   match func {
1109 |     Func(_) => Ok(func)
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TFunc(locals, initial_body) => {
     |       let mut body = initial_body
     |       if propagate {
     |         let graph = LocalGraph::new(body.0)
     |         let get_values = pc_analyze_get_values(body, graph, imm_globals)
     |         body = pc_replace_gets_with_constants(body, get_values)
     |       }
     |       let mut rounds = 0
     |       while rounds < 12 {
     |         rounds += 1
     |         let next = pc_simplify_body(body, imm_globals, options)
     |         if next == body {
     |           break
     |         }
     |         body = next
     |       }
     |       Ok(Func::t_func(locals, body))
     |     }
     |   }
     | }
     …

     | fn precompute_ir_pass(
     |   mod : Module,
     |   options : OptimizeOptions,
     |   propagate : Bool,
     | ) -> ModuleTransformer[IRContext] {
     |   ModuleTransformer::new().on_func_evt(fn(_self, ctx : IRContext, func) {
     |     match precompute_on_func(func, mod, options, propagate) {
     |       Ok(next_func) =>
     |         match (func, next_func) {
     |           (TFunc(orig_locals, orig_body), TFunc(next_locals, next_body)) => {
     |             ctx.set_body(next_body)
     |             if orig_locals == next_locals && orig_body == next_body {
     |               unchanged()
     |             } else {
     |               change(ctx, Func::t_func(next_locals, next_body))
     |             }
     |           }
1149 |           _ => change(ctx, next_func)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1151 |       Err(e) => Err(e)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

     | fn pc_expect_literal(actual : PCLiteral?, expected : PCLiteral) -> Unit raise {
     |   match actual {
     |     Some(v) => assert_true(v == expected)
1194 |     None => fail("expected literal result")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

40 uncovered line(s) in src/passes/redundant_set_elimination.mbt:

     | fn rse_collect_instr_events(
     |   state : RSEBuildState,
     |   block_id : RSEBlockId,
     |   instr : TInstr,
     | ) -> Unit {
     |   match instr {
     |     TLocalGet(idx) =>
     |       rse_add_event(state, block_id, RSEEventKind::LocalGet(idx))
     |     TLocalSet(idx, value) => {
     |       rse_collect_instr_events(state, block_id, value)
     |       rse_add_event(state, block_id, RSEEventKind::LocalSet(idx, value))
     |     }
     |     TLocalTee(idx, value) => {
     |       rse_collect_instr_events(state, block_id, value)
     |       rse_add_event(state, block_id, RSEEventKind::LocalSet(idx, value))
     |     }
 169 |     TIf(_, cond, _, _) => rse_collect_instr_events(state, block_id, cond)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBlock(_, _) | TLoop(_, _) | TTryTable(_, _, _) => ()
     |     _ =>
     |       for child in eval_children(instr) {
     |         rse_collect_instr_events(state, block_id, child)
     |       }
     |   }
     | }
     …

     | fn rse_lower_texpr(
     |   body : TExpr,
     |   current : RSEBlockId,
     |   state : RSEBuildState,
     | ) -> RSEBlockId {
     |   let mut current = current
     |   for instr in body.0 {
     |     match instr {
     |       TIf(_, cond, then_body, else_body) => {
     |         rse_collect_instr_events(state, current, cond)
     |         let then_block = rse_make_block(state)
     |         let else_block = rse_make_block(state)
     |         let merge_block = rse_make_block(state)
     |         rse_add_edge(state, current, then_block)
     |         rse_add_edge(state, current, else_block)
     |         let then_end = rse_lower_texpr(then_body, then_block, state)
     |         rse_add_edge(state, then_end, merge_block)
     |         match else_body {
     |           Some(other) => {
     |             let else_end = rse_lower_texpr(other, else_block, state)
     |             rse_add_edge(state, else_end, merge_block)
     |           }
 201 |           None => rse_add_edge(state, else_block, merge_block)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         current = merge_block
     |       }
 205 |       TReturn(values) => {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for value in values {
 207 |           rse_collect_instr_events(state, current, value)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         return current
     |       }
     |       _ => {
     |         rse_collect_instr_events(state, current, instr)
     |         if is_unreachable_instr(instr) {
 214 |           return current
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   }
     |   current
     | }
     …

     | fn RSEValueNumbering::get_block_merge_value(
     |   self : RSEValueNumbering,
     |   block_id : RSEBlockId,
     |   local_index : Int,
     | ) -> Int {
     |   let per_block = self.block_merge_values.get_or_init(block_id, fn() {
     |     Map::new()
     |   })
     |   match per_block.get(local_index) {
 304 |     Some(value) => value
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => {
     |       let value = self.unique()
     |       per_block[local_index] = value
     |       value
     |     }
     |   }
     | }
     …

     | fn rse_zero_tinstr(vt : ValType) -> TInstr? {
     |   match vt {
     |     NumTypeValType(nt) =>
     |       match nt {
     |         I32NumType => Some(TInstr::i32_const(I32(0)))
 332 |         I64NumType => Some(TInstr::i64_const(I64(0L)))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         F32NumType => Some(TInstr::f32_const(F32(0.0)))
     |         F64NumType => Some(TInstr::f64_const(F64(0.0)))
     |       }
     |     VecTypeValType =>
 337 |       Some(TInstr::v128_const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) =>
     |       if rt.is_nullable() {
     |         Some(TInstr::ref_null(rt.get_heap_type()))
     |       } else {
 342 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
 344 |     BotValType => None
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rse_get_fallthrough(instr : TInstr) -> TInstr {
     |   match instr {
     |     TBlock(_, TExpr(instrs)) if instrs.length() > 0 =>
 352 |       rse_get_fallthrough(instrs[instrs.length() - 1])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => instr
     |   }
     | }
     …

     | fn rse_compute_initial_start(
     |   locals : Array[ValType],
     |   param_count : Int,
     |   analyzer : RSEValueNumbering,
     | ) -> RSELocalValues {
     |   let start : RSELocalValues = []
     |   for i in 0..<locals.length() {
     |     if i < param_count {
     |       start.push(analyzer.unique())
     |     } else {
     |       match rse_zero_tinstr(locals[i]) {
     |         Some(zero) => start.push(analyzer.value_for_expr(zero))
 382 |         None => start.push(analyzer.unique())
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   start
     | }
     …

     | fn rse_flow_values(
     |   cfg : RSECFG,
     |   locals : Array[ValType],
     |   param_count : Int,
     |   analyzer : RSEValueNumbering,
     | ) -> RSEFlowState {
     |   let start_values : Map[RSEBlockId, RSELocalValues] = Map::new()
     |   let end_values : Map[RSEBlockId, RSELocalValues] = Map::new()
     | 
     |   let unseen = analyzer.unseen_value
     |   let init_start = rse_compute_initial_start(locals, param_count, analyzer)
     | 
     |   for entry in cfg.blocks {
     |     let (block_id, _) = entry
     |     if block_id == cfg.entry {
     |       start_values[block_id] = init_start.copy()
     |     } else {
     |       let unseen_values : RSELocalValues = []
     |       for _ in 0..<locals.length() {
     |         unseen_values.push(unseen)
     |       }
     |       start_values[block_id] = unseen_values
     |     }
     |     let unseen_end : RSELocalValues = []
     |     for _ in 0..<locals.length() {
     |       unseen_end.push(unseen)
     |     }
     |     end_values[block_id] = unseen_end
     |   }
     | 
     |   let work = RSEWorkQueue::new()
     |   work.push(cfg.entry)
     | 
     |   while !work.is_empty() {
     |     let block_id = work.pop()
     |     let preds = cfg.preds.get(block_id).unwrap_or([])
     |     if preds.length() > 0 {
     |       if preds.length() == 1 {
     |         start_values[block_id] = end_values[preds[0]].copy()
     |       } else {
     |         let merged = start_values[block_id]
     |         for local_i in 0..<locals.length() {
     |           let old = merged[local_i]
     |           if analyzer.is_block_merge_value(block_id, local_i, old) {
 434 |             continue
     |             ^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let mut value = end_values[preds[0]][local_i]
     |           for pred in preds.op_as_view(start=1, end=preds.length()) {
     |             let other = end_values[pred][local_i]
     |             if value == unseen {
 440 |               value = other
     |               ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else if other == unseen {
 442 |               ()
     |               ^^ 	<-- UNCOVERED
     |             } else if value != other {
     |               value = analyzer.get_block_merge_value(block_id, local_i)
     |               break
     |             }
     |           }
     |           merged[local_i] = value
     |         }
     |       }
     |     }
     | 
     |     let curr = start_values[block_id].copy()
     |     for event_id in cfg.blocks[block_id].events {
     |       match cfg.events[event_id] {
     |         LocalSet(idx, value) => {
     |           let local_i = rse_local_idx_to_int(idx)
     |           let value_num = rse_value_of(
     |             analyzer,
     |             rse_get_fallthrough(value),
     |             curr,
     |           )
     |           curr[local_i] = value_num
     |         }
     |         _ => ()
     |       }
     |     }
     | 
     |     if curr != end_values[block_id] {
     |       end_values[block_id] = curr
     |       for succ in cfg.blocks[block_id].succs {
     |         work.push(succ)
     |       }
     |     }
     |   }
     | 
     |   { start_values, }
     | }
     …

     | fn rse_find_best_refinement(
     |   env : Env,
     |   locals : Array[ValType],
     |   refinable : Array[Bool],
     |   curr_values : RSELocalValues,
     |   get_idx : LocalIdx,
     | ) -> LocalIdx? {
     |   let get_i = rse_local_idx_to_int(get_idx)
     |   if !refinable[get_i] {
     |     return None
     |   }
     | 
     |   let curr_ty = locals[get_i]
     |   let target_value = curr_values[get_i]
     |   let mut best_i : Int? = None
     | 
     |   for i in 0..<locals.length() {
     |     if i == get_i || !refinable[i] || curr_values[i] != target_value {
     |       continue
     |     }
     | 
     |     let possible_ty = locals[i]
     |     if possible_ty == curr_ty || !Match::matches(possible_ty, curr_ty, env) {
 516 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     match best_i {
     |       None => best_i = Some(i)
 521 |       Some(existing) => {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let existing_ty = locals[existing]
     |         if possible_ty != existing_ty &&
     |           Match::matches(possible_ty, existing_ty, env) {
 525 |           best_i = Some(i)
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   }
     | 
     |   match best_i {
     |     Some(i) => Some(rse_int_to_local_idx(i))
     |     None => None
     |   }
     | }
     …

     | fn rse_rewrite_instr(state : RSERewriteState, instr : TInstr) -> TInstr {
     |   match instr {
     |     TLocalGet(idx) => {
     |       let event_id = state.next_event
     |       state.next_event += 1
     |       match state.replace_gets.get(event_id) {
     |         Some(new_idx) =>
     |           if new_idx != idx {
     |             state.changed = true
     |             TInstr::local_get(new_idx)
     |           } else {
 611 |             instr
     |             ^^^^^ 	<-- UNCOVERED
     |           }
     |         None => instr
     |       }
     |     }
     |     TLocalSet(idx, value) => {
     |       let next_value = rse_rewrite_instr(state, value)
     |       let event_id = state.next_event
     |       state.next_event += 1
     |       if state.remove_sets.contains(event_id) {
     |         state.changed = true
     |         TInstr::drop(next_value)
     |       } else if next_value != value {
 624 |         TInstr::local_set(idx, next_value)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         instr
     |       }
     |     }
     |     TLocalTee(idx, value) => {
     |       let next_value = rse_rewrite_instr(state, value)
     |       let event_id = state.next_event
     |       state.next_event += 1
     |       if state.remove_sets.contains(event_id) {
     |         state.changed = true
     |         next_value
     |       } else if next_value != value {
 637 |         TInstr::local_tee(idx, next_value)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         instr
     |       }
     |     }
 642 |     TIf(bt, cond, then_body, else_body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_cond = rse_rewrite_instr(state, cond)
     |       if next_cond == cond {
 645 |         instr
     |         ^^^^^ 	<-- UNCOVERED
     |       } else {
 647 |         TInstr::if_(bt, next_cond, then_body, else_body)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 650 |     TBlock(_, _) | TLoop(_, _) | TTryTable(_, _, _) => instr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => {
     |       let children = eval_children(instr)
     |       if children.is_empty() {
     |         return instr
     |       }
     |       let (next_children, changed) = rse_rewrite_children(state, children)
     |       if !changed {
     |         instr
     |       } else {
     |         mb_rebuild_non_control(instr, next_children)
     |       }
     |     }
     |   }
     | }
     …

     | fn rse_rewrite_texpr(state : RSERewriteState, body : TExpr) -> TExpr {
     |   let out : Array[TInstr] = []
     |   for instr in body.0 {
     |     match instr {
     |       TIf(bt, cond, then_body, else_body) => {
     |         let next_cond = rse_rewrite_instr(state, cond)
     |         let next_then = rse_rewrite_texpr(state, then_body)
     |         let next_else = else_body.map(fn(e) { rse_rewrite_texpr(state, e) })
     |         if next_cond != cond || next_then != then_body || next_else != else_body {
 676 |           state.changed = true
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         out.push(TInstr::if_(bt, next_cond, next_then, next_else))
     |       }
 680 |       TReturn(values) => {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let (next_values, changed) = rse_rewrite_children(state, values)
     |         if changed {
 683 |           state.changed = true
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           out.push(TInstr::return_(next_values))
     |         } else {
 686 |           out.push(instr)
     |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
 688 |         return TExpr::new(out)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       _ => {
     |         let next_instr = rse_rewrite_instr(state, instr)
     |         out.push(next_instr)
     |         if is_unreachable_instr(instr) {
 694 |           return TExpr::new(out)
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   }
     |   TExpr::new(out)
     | }
     …

     | fn rse_collect_param_counts(mod : Module) -> Array[Int] {
     |   let out : Array[Int] = []
     |   let env = Env::new().with_module(mod)
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for tidx in type_idxs {
     |         match env.resolve_functype(tidx) {
     |           Some(FuncType(params, _)) => out.push(params.length())
 711 |           None => out.push(0)
     |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn rse_optimize_function(
     |   func : Func,
     |   env_base : Env,
     |   param_count : Int,
     | ) -> (Func, Bool) {
     |   match func {
     |     TFunc(locals, body) => {
     |       if locals.length() == 0 {
 728 |         return (func, false)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       let cfg = rse_build_cfg(body)
     |       if cfg.events.length() == 0 {
 733 |         return (func, false)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       let analyzer = RSEValueNumbering::new()
     |       let bounded_param_count = if param_count < locals.length() {
     |         param_count
     |       } else {
     |         locals.length()
     |       }
     |       let flow = rse_flow_values(cfg, locals, bounded_param_count, analyzer)
     |       let env = env_base.with_locals(locals)
     |       let actions = rse_collect_actions(cfg, locals, env, flow, analyzer)
     |       if actions.remove_sets.is_empty() && actions.replace_gets.is_empty() {
     |         return (func, false)
     |       }
     | 
     |       let rewrite_state = RSERewriteState::new(actions)
     |       let next_body = rse_rewrite_texpr(rewrite_state, body)
     |       if rewrite_state.next_event != cfg.events.length() {
 752 |         return (func, false)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if !rewrite_state.changed {
 755 |         return (func, false)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       (Func::t_func(locals, next_body), true)
     |     }
 759 |     _ => (func, false)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn run_redundant_set_elimination(mod : Module) -> Module {
     |   let pass = redundant_set_elimination_ir_pass(mod)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
 790 |     _ => mod
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rse_first_body(mod : Module) -> TExpr raise {
     |   match mod.code_sec {
     |     Some(CodeSec(funcs)) =>
     |       match funcs.get(0) {
     |         Some(TFunc(_, body)) => body
 805 |         _ => fail("expected first function body")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 807 |     _ => fail("expected code section")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

185 uncovered line(s) in src/passes/remove_unused.mbt:

     | fn count_imports(mod : Module) -> ImportCounts {
     |   let mut funcs : UInt = 0
     |   let mut tables : UInt = 0
     |   let mut mems : UInt = 0
     |   let mut globals : UInt = 0
     |   let mut tags : UInt = 0
     |   match mod.import_sec {
     |     Some(sec) =>
     |       for imp in sec.0 {
     |         match imp {
     |           Import(_, _, extern_type) =>
     |             match extern_type {
     |               FuncExternType(_) => funcs += 1
 110 |               TableExternType(_) => tables += 1
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               MemExternType(_) => mems += 1
     |               GlobalExternType(_) => globals += 1
     |               TagExternType(_) => tags += 1
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     |   { funcs, tables, mems, globals, tags }
     | }
     …

     | fn collect_func_type_indices(mod : Module) -> Map[FuncIdx, TypeIdx] {
     |   let out : Map[FuncIdx, TypeIdx] = Map::new()
     |   let mut next_idx : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) => {
     |             out[FuncIdx::new(next_idx)] = type_idx
     |             next_idx += 1
     |           }
 134 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out[FuncIdx::new(next_idx)] = type_idx
     |         next_idx += 1
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn mark_called_signature(ctx : AnalysisContext, type_idx : TypeIdx) -> Unit {
     |   if not(ctx.called_ref_types.contains(type_idx)) {
     |     ctx.called_ref_types.add(type_idx)
     |   }
     |   if !ctx.props.closed_world {
 237 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   promote_uncalled_ref_funcs(ctx)
     | }
     …

     | fn note_ref_func(ctx : AnalysisContext, idx : FuncIdx) -> Unit {
     |   if !ctx.props.closed_world {
     |     mark_func(ctx, idx)
     |     return
     |   }
     |   match ctx.func_type_by_func.get(idx) {
     |     Some(type_idx) => {
     |       mark_type(ctx, type_idx)
     |       if func_type_is_callable_by(ctx, type_idx) {
     |         mark_func(ctx, idx)
     |       } else {
     |         reference_func(ctx, idx)
     |         let refs = ctx.uncalled_ref_funcs_by_type
     |           .get(type_idx)
     |           .unwrap_or(Set::new())
     |         if !refs.contains(idx) {
     |           refs.add(idx)
     |           ctx.uncalled_ref_funcs_by_type[type_idx] = refs
     |         }
     |       }
     |     }
 264 |     None => mark_func(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn mark_blocktype(ctx : AnalysisContext, bt : BlockType) -> Unit {
 315 |   match bt {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     TypeIdxBlockType(idx) => mark_type(ctx, idx)
     |     _ => ()
     |   }
     | }
     …

     | fn mark_reftype(ctx : AnalysisContext, rt : RefType) -> Unit {
     |   match rt {
     |     HeapTypeRefType(_, ht) => mark_heaptype(ctx, ht)
 337 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn analyze_roots(ctx : AnalysisContext) -> Unit {
     |   let mod = ctx.mod
     | 
     |   // Exports
     |   match mod.export_sec {
     |     Some(sec) =>
     |       for exp in sec.0 {
     |         match exp {
     |           Export(_, extern_idx) =>
     |             match extern_idx {
     |               FuncExternIdx(idx) => mark_func(ctx, idx)
 365 |               TableExternIdx(idx) => mark_table(ctx, idx)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               MemExternIdx(idx) => mark_mem(ctx, idx)
     |               GlobalExternIdx(idx) => mark_global(ctx, idx)
     |               TagExternIdx(idx) => mark_tag(ctx, idx)
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   // Start function
     |   match mod.start_sec {
     |     Some(sec) => mark_func(ctx, sec.0)
     |     None => ()
     |   }
     | 
     |   // Optional mode: keep all functions, but still trim other module elements.
     |   if ctx.props.root_all_functions {
     |     for entry in ctx.func_type_by_func {
     |       let (func_idx, type_idx) = entry
     |       mark_type(ctx, type_idx)
     |       mark_func(ctx, func_idx)
     |     }
     |   }
     | 
     |   // Active element segments (executed at instantiation)
     |   match mod.elem_sec {
     |     Some(sec) => {
     |       let elems = sec.0
     |       for i = 0; i < elems.length(); i = i + 1 {
     |         match elems[i] {
     |           Elem(Active(table_idx, _), _) => {
     |             mark_table(ctx, table_idx)
     |             mark_elem(ctx, ElemIdx::new(i.reinterpret_as_uint()))
     |           }
     |           _ => ()
     |         }
     |       }
     |     }
     |     None => ()
     |   }
     | 
     |   // Active data segments (executed at instantiation)
     |   match mod.data_sec {
     |     Some(sec) => {
     |       let datas = sec.0
     |       for i = 0; i < datas.length(); i = i + 1 {
     |         match datas[i] {
     |           Data(Active(mem_idx, _), _) => {
     |             mark_mem(ctx, mem_idx)
     |             mark_data(ctx, DataIdx::new(i.reinterpret_as_uint()))
     |           }
     |           _ => ()
     |         }
     |       }
     |     }
     |     None => ()
     |   }
     | }
     …

     | fn process_func_worklist(ctx : AnalysisContext) -> Unit {
     |   let code_sec = match ctx.mod.code_sec {
     |     Some(cs) => cs.0
 431 |     None => return
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_sec = match ctx.mod.func_sec {
     |     Some(fs) => fs.0
 435 |     None => return
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   while ctx.func_worklist.length() > 0 {
     |     let func_idx = ctx.func_worklist.pop().unwrap()
     |     let FuncIdx(idx_val) = func_idx
     |     if idx_val >= ctx.imports.funcs {
     |       // Defined function
     |       let def_idx = (idx_val - ctx.imports.funcs).reinterpret_as_int()
     |       if def_idx >= 0 && def_idx < code_sec.length() {
     |         // Mark the function's type
     |         mark_type(ctx, func_sec[def_idx])
     | 
     |         // Scan the function body
     |         match code_sec[def_idx] {
     |           TFunc(locals, texpr) => {
     |             for vt in locals {
 451 |               mark_valtype(ctx, vt)
     |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             scan_texpr(ctx, texpr)
     |           }
 455 |           Func(locals, expr) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             for l in locals {
 457 |               match l {
     |               ^^^^^^^^^ 	<-- UNCOVERED
     |                 Locals(_, vt) => mark_valtype(ctx, vt)
     |               }
     |             }
 461 |             scan_expr(ctx, expr)
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |     } else {
     |       // Imported function - mark its type from import section
     |       match ctx.mod.import_sec {
     |         Some(sec) => {
     |           let mut func_import_idx : UInt = 0
     |           for imp in sec.0 {
     |             match imp {
     |               Import(_, _, FuncExternType(type_idx)) => {
     |                 if func_import_idx == idx_val {
     |                   mark_type(ctx, type_idx)
     |                   break
     |                 }
     |                 func_import_idx += 1
     |               }
 479 |               _ => ()
     |               ^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |         }
 483 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | }
     …

     | fn process_elem_worklist(ctx : AnalysisContext) -> Unit {
     |   let elem_sec = match ctx.mod.elem_sec {
     |     Some(es) => es.0
     |     None => return
     |   }
     |   while ctx.elem_worklist.length() > 0 {
     |     let elem_idx = ctx.elem_worklist.pop().unwrap()
     |     let ElemIdx(idx_val) = elem_idx
     |     let idx = idx_val.reinterpret_as_int()
     |     if idx >= 0 && idx < elem_sec.length() {
     |       match elem_sec[idx] {
     |         Elem(mode, kind) => {
     |           // Scan offset expression for active segments
     |           match mode {
     |             Active(_, offset_expr) => scan_expr(ctx, offset_expr)
     |             _ => ()
     |           }
     | 
     |           // Mark referenced functions
     |           match kind {
     |             FuncsElemKind(funcs) =>
     |               for f in funcs {
     |                 note_ref_func(ctx, f)
     |               }
     |             FuncExprsElemKind(exprs) =>
 542 |               for expr in exprs {
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 scan_expr(ctx, expr)
     |               }
     |             TypedExprsElemKind(rt, exprs) => {
     |               mark_reftype(ctx, rt)
     |               for expr in exprs {
     |                 scan_expr(ctx, expr)
     |               }
     |             }
     |           }
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn analyze_type_dependencies(ctx : AnalysisContext) -> Unit {
     |   match ctx.mod.type_sec {
     |     Some(sec) => {
     |       // Iterate until no new types are added
     |       let mut changed = true
     |       while changed {
     |         changed = false
     |         let types = sec.0
     |         for i = 0; i < types.length(); i = i + 1 {
     |           let type_idx = TypeIdx::new(i.reinterpret_as_uint())
     |           if ctx.used.types.contains(type_idx) {
     |             match types[i] {
     |               SingleRecType(st) =>
     |                 match st {
 623 |                   SubType(_, supers, comp_type) => {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     for super_idx in supers {
 625 |                       if not(ctx.used.types.contains(super_idx)) {
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         ctx.used.types.add(super_idx)
     |                         changed = true
     |                       }
     |                     }
     |                     // Mark types in comp_type
 631 |                     scan_comptype_for_types(ctx, comp_type)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                   CompTypeSubType(ct) => scan_comptype_for_types(ctx, ct)
     |                 }
     |               GroupRecType(sts) =>
 636 |                 for st in sts {
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   match st {
     |                     SubType(_, supers, comp_type) => {
     |                       for super_idx in supers {
 640 |                         if not(ctx.used.types.contains(super_idx)) {
     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                           ctx.used.types.add(super_idx)
     |                           changed = true
     |                         }
     |                       }
 645 |                       scan_comptype_for_types(ctx, comp_type)
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     }
 647 |                     CompTypeSubType(ct) => scan_comptype_for_types(ctx, ct)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |             }
     |           }
     |         }
     |       }
     |     }
     |     None => ()
     |   }
     | }
     …

     | fn scan_comptype_for_types(ctx : AnalysisContext, ct : CompType) -> Unit {
     |   match ct {
     |     FuncCompType(params, results) => {
     |       for vt in params {
 664 |         mark_valtype(ctx, vt)
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for vt in results {
     |         mark_valtype(ctx, vt)
     |       }
     |     }
     |     StructCompType(fields) =>
     |       for field in fields {
     |         match field {
     |           FieldType(ValTypeStorageType(vt), _) => mark_valtype(ctx, vt)
 674 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 677 |     ArrayCompType(ft) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let FieldType(storage, _) = ft
 679 |       match storage {
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ValTypeStorageType(vt) => mark_valtype(ctx, vt)
     |         _ => ()
     |       }
     |     }
     |   }
     | }
     …

     | fn scan_tinstr(ctx : AnalysisContext, instr : TInstr) -> Unit {
     |   match instr {
     |     // Function references
     |     TCall(idx, args) | TReturnCall(idx, args) => {
     |       mark_func(ctx, idx)
     |       for a in args {
 705 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TRefFunc(idx) => note_ref_func(ctx, idx)
     | 
     |     // Type references
     |     TCallIndirect(type_idx, table_idx, args, idx_instr) => {
     |       mark_type(ctx, type_idx)
     |       mark_table(ctx, table_idx)
     |       mark_called_signature(ctx, type_idx)
     |       for a in args {
 716 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       scan_tinstr(ctx, idx_instr)
     |     }
 720 |     TReturnCallIndirect(type_idx, table_idx, args, idx_instr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_table(ctx, table_idx)
     |       mark_called_signature(ctx, type_idx)
     |       for a in args {
 725 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 727 |       scan_tinstr(ctx, idx_instr)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TCallRef(type_idx, args, rf) => {
     |       mark_type(ctx, type_idx)
     |       mark_called_signature(ctx, type_idx)
     |       for a in args {
 733 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       scan_tinstr(ctx, rf)
     |     }
 737 |     TReturnCallRef(type_idx, args, rf) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_called_signature(ctx, type_idx)
     |       for a in args {
 741 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 743 |       scan_tinstr(ctx, rf)
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Control flow
 747 |     TBlock(bt, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       scan_texpr(ctx, expr)
     |     }
 751 |     TLoop(bt, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       scan_texpr(ctx, expr)
     |     }
 755 |     TIf(bt, cond, then_branch, else_branch) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       scan_tinstr(ctx, cond)
     |       scan_texpr(ctx, then_branch)
     |       match else_branch {
     |         Some(e) => scan_texpr(ctx, e)
     |         None => ()
     |       }
     |     }
 764 |     TTryTable(bt, catches, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       for c in catches {
 767 |         match c {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           Catch(tag_idx, _) | CatchRef(tag_idx, _) => mark_tag(ctx, tag_idx)
     |           CatchAll(_) | CatchAllRef(_) => ()
     |         }
     |       }
 772 |       scan_texpr(ctx, expr)
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Tags
     |     TThrow(tag_idx, args) => {
     |       mark_tag(ctx, tag_idx)
     |       for a in args {
 779 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 782 |     TThrowRef(arg) => scan_tinstr(ctx, arg)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Globals
     |     TGlobalGet(idx) => mark_global(ctx, idx)
 786 |     TGlobalSet(idx, arg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_global(ctx, idx)
     |       scan_tinstr(ctx, arg)
     |     }
     | 
     |     // Tables
 792 |     TTableGet(idx, arg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_table(ctx, idx)
     |       scan_tinstr(ctx, arg)
     |     }
 796 |     TTableSet(idx, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_table(ctx, idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
 801 |     TTableGrow(idx, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_table(ctx, idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
 806 |     TTableSize(idx) => mark_table(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TTableFill(idx, a, b, c) => {
     |       mark_table(ctx, idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |     }
 813 |     TTableCopy(idx1, idx2, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_table(ctx, idx1)
     |       mark_table(ctx, idx2)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |     }
     |     TTableInit(elem_idx, table_idx, a, b, c) => {
     |       mark_elem(ctx, elem_idx)
     |       mark_table(ctx, table_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |     }
 827 |     TElemDrop(idx) => mark_elem(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Memory
 830 |     TMemorySize(idx) => mark_mem(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryGrow(idx, arg) => {
     |       mark_mem(ctx, idx)
     |       scan_tinstr(ctx, arg)
     |     }
 835 |     TMemoryFill(idx, dst, val, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_mem(ctx, idx)
     |       scan_tinstr(ctx, dst)
     |       scan_tinstr(ctx, val)
     |       scan_tinstr(ctx, len)
     |     }
 841 |     TMemoryCopy(idx1, idx2, dst, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_mem(ctx, idx1)
     |       mark_mem(ctx, idx2)
     |       scan_tinstr(ctx, dst)
     |       scan_tinstr(ctx, src)
     |       scan_tinstr(ctx, len)
     |     }
 848 |     TMemoryInit(data_idx, mem_idx, dst, src, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_data(ctx, data_idx)
     |       mark_mem(ctx, mem_idx)
     |       scan_tinstr(ctx, dst)
     |       scan_tinstr(ctx, src)
     |       scan_tinstr(ctx, len)
     |     }
 855 |     TDataDrop(idx) => mark_data(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Load/Store (use memory 0 implicitly via memarg)
     |     TLoad(_, memarg, idx) => {
     |       if memarg.1 is Some(idx) {
 860 |         mark_mem(ctx, idx)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         mark_mem(ctx, MemIdx::new(0))
     |       }
     |       scan_tinstr(ctx, idx)
     |     }
 866 |     TStore(_, memarg, idx, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if memarg.1 is Some(idx) {
 868 |         mark_mem(ctx, idx)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 870 |         mark_mem(ctx, MemIdx::new(0))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 872 |       scan_tinstr(ctx, idx)
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, val)
     |     }
     | 
     |     // GC types
     |     TStructNew(type_idx, args) => {
     |       mark_type(ctx, type_idx)
     |       for a in args {
     |         scan_tinstr(ctx, a)
     |       }
     |     }
 883 |     TStructNewDefault(type_idx) => mark_type(ctx, type_idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(type_idx, _, arg)
     |     | TStructGetS(type_idx, _, arg)
 886 |     | TStructGetU(type_idx, _, arg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, arg)
     |     }
 890 |     TStructSet(type_idx, _, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
 895 |     TArrayNew(type_idx, len, init) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, len)
     |       scan_tinstr(ctx, init)
     |     }
 900 |     TArrayNewDefault(type_idx, len) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, len)
     |     }
 904 |     TArrayNewFixed(type_idx, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       for a in args {
 907 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
 910 |     TArrayNewData(type_idx, data_idx, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_data(ctx, data_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
 916 |     TArrayNewElem(type_idx, elem_idx, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_elem(ctx, elem_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
     |     TArrayGet(type_idx, arr, idx)
     |     | TArrayGetS(type_idx, arr, idx)
 924 |     | TArrayGetU(type_idx, arr, idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, arr)
     |       scan_tinstr(ctx, idx)
     |     }
 929 |     TArraySet(type_idx, arr, idx, val) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, arr)
     |       scan_tinstr(ctx, idx)
     |       scan_tinstr(ctx, val)
     |     }
 935 |     TArrayLen(arr) => scan_tinstr(ctx, arr)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TArrayFill(type_idx, a, b, c, d) => {
     |       mark_type(ctx, type_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |       scan_tinstr(ctx, d)
     |     }
 943 |     TArrayCopy(type_idx1, type_idx2, a, b, c, d, e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx1)
     |       mark_type(ctx, type_idx2)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |       scan_tinstr(ctx, d)
     |       scan_tinstr(ctx, e)
     |     }
 952 |     TArrayInitData(type_idx, data_idx, a, b, c, d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_data(ctx, data_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |       scan_tinstr(ctx, d)
     |     }
 960 |     TArrayInitElem(type_idx, elem_idx, a, b, c, d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_elem(ctx, elem_idx)
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |       scan_tinstr(ctx, d)
     |     }
     | 
     |     // Ref types
 970 |     TRefNull(ht) => mark_heaptype(ctx, ht)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefCast(_, ht, arg) | TRefTest(_, ht, arg) => {
     |       mark_heaptype(ctx, ht)
     |       scan_tinstr(ctx, arg)
     |     }
     |     TBrOnCast(_, _, ht1, ht2, arg, args)
 976 |     | TBrOnCastFail(_, _, ht1, ht2, arg, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_heaptype(ctx, ht1)
     |       mark_heaptype(ctx, ht2)
     |       scan_tinstr(ctx, arg)
     |       for a in args {
 981 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     // Select with types
 986 |     TSelect(types, cond, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match types {
     |         Some(vts) =>
 989 |           for vt in vts {
     |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             mark_valtype(ctx, vt)
     |           }
 992 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 994 |       scan_tinstr(ctx, cond)
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
     | 
     |     // Recurse into children for remaining cases
     |     _ => scan_tinstr_children(ctx, instr)
     |   }
     | }
     …

     | fn scan_tinstr_children(ctx : AnalysisContext, instr : TInstr) -> Unit {
     |   match instr {
1007 |     TLocalSet(_, arg) | TLocalTee(_, arg) => scan_tinstr(ctx, arg)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TUnary(_, arg)
     |     | TDrop(arg)
     |     | TRefIsNull(arg)
     |     | TRefAsNonNull(arg)
     |     | TAnyConvertExtern(arg)
     |     | TExternConvertAny(arg)
     |     | TI31GetS(arg)
     |     | TI31GetU(arg)
     |     | TRefI31(arg) => scan_tinstr(ctx, arg)
1017 |     TBinary(_, a, b) | TRefEq(a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
     |     TBr(_, args) | TReturn(args) =>
     |       for a in args {
     |         scan_tinstr(ctx, a)
     |       }
1025 |     TBrIf(_, cond, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, cond)
     |       for a in args {
1028 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1031 |     TBrTable(_, _, cond, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, cond)
     |       for a in args {
1034 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1037 |     TBrOnNull(_, arg, args) | TBrOnNonNull(_, arg, args) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, arg)
     |       for a in args {
1040 |         scan_tinstr(ctx, a)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1043 |     TV128LoadLane(_, _, _, vec, addr) | TV128StoreLane(_, _, _, vec, addr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, vec)
     |       scan_tinstr(ctx, addr)
     |     }
1047 |     TV128Shift(_, a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
1051 |     TV128Ternary(_, a, b, c) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |       scan_tinstr(ctx, c)
     |     }
     |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, a, b)
     |     | TI8x16Swizzle(a, b)
1058 |     | TI8x16RelaxedSwizzle(a, b) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       scan_tinstr(ctx, a)
     |       scan_tinstr(ctx, b)
     |     }
     |     TI8x16Splat(a)
     |     | TI16x8Splat(a)
     |     | TI32x4Splat(a)
     |     | TI64x2Splat(a)
     |     | TF32x4Splat(a)
1067 |     | TF64x2Splat(a) => scan_tinstr(ctx, a)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TExtractLane(_, _, a) => scan_tinstr(ctx, a)
     |     TReplaceLane(_, _, vec, val) => {
     |       scan_tinstr(ctx, vec)
     |       scan_tinstr(ctx, val)
     |     }
     |     _ => () // Constants, nop, unreachable, local_get, etc.
     |   }
     | }
     …

     | fn scan_instr(ctx : AnalysisContext, instr : Instruction) -> Unit {
     |   match instr {
1087 |     Call(idx) | ReturnCall(idx) => mark_func(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefFunc(idx) => note_ref_func(ctx, idx)
     |     CallIndirect(type_idx, table_idx)
1090 |     | ReturnCallIndirect(type_idx, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_table(ctx, table_idx)
     |       mark_called_signature(ctx, type_idx)
     |     }
1095 |     CallRef(type_idx) | ReturnCallRef(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_called_signature(ctx, type_idx)
     |     }
1099 |     Block(bt, expr) | Loop(bt, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       scan_expr(ctx, expr)
     |     }
1103 |     If(bt, then_instrs, else_instrs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       for i in then_instrs {
1106 |         scan_instr(ctx, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1108 |       match else_instrs {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(instrs) =>
1110 |           for i in instrs {
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             scan_instr(ctx, i)
     |           }
1113 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1116 |     TryTable(bt, catches, expr) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_blocktype(ctx, bt)
     |       for c in catches {
1119 |         match c {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           Catch(tag_idx, _) | CatchRef(tag_idx, _) => mark_tag(ctx, tag_idx)
     |           _ => ()
     |         }
     |       }
1124 |       scan_expr(ctx, expr)
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1126 |     Throw(tag_idx) => mark_tag(ctx, tag_idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     GlobalGet(idx) | GlobalSet(idx) => mark_global(ctx, idx)
     |     TableGet(idx)
     |     | TableSet(idx)
     |     | TableGrow(idx)
     |     | TableSize(idx)
1132 |     | TableFill(idx) => mark_table(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TableCopy(idx1, idx2) => {
     |       mark_table(ctx, idx1)
     |       mark_table(ctx, idx2)
     |     }
1137 |     TableInit(elem_idx, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_elem(ctx, elem_idx)
     |       mark_table(ctx, table_idx)
     |     }
1141 |     ElemDrop(idx) => mark_elem(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     MemorySize(idx) | MemoryGrow(idx) | MemoryFill(idx) => mark_mem(ctx, idx)
     |     MemoryCopy(idx1, idx2) => {
     |       mark_mem(ctx, idx1)
     |       mark_mem(ctx, idx2)
     |     }
1147 |     MemoryInit(data_idx, mem_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_data(ctx, data_idx)
     |       mark_mem(ctx, mem_idx)
     |     }
1151 |     DataDrop(idx) => mark_data(ctx, idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     StructNew(type_idx) | StructNewDefault(type_idx) => mark_type(ctx, type_idx)
     |     StructGet(type_idx, _)
     |     | StructGetS(type_idx, _)
     |     | StructGetU(type_idx, _)
1156 |     | StructSet(type_idx, _) => mark_type(ctx, type_idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayNew(type_idx)
     |     | ArrayNewDefault(type_idx)
     |     | ArrayNewFixed(type_idx, _)
     |     | ArrayGet(type_idx)
     |     | ArrayGetS(type_idx)
     |     | ArrayGetU(type_idx)
     |     | ArraySet(type_idx)
1164 |     | ArrayFill(type_idx) => mark_type(ctx, type_idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ArrayNewData(type_idx, data_idx) | ArrayInitData(type_idx, data_idx) => {
     |       mark_type(ctx, type_idx)
     |       mark_data(ctx, data_idx)
     |     }
1169 |     ArrayNewElem(type_idx, elem_idx) | ArrayInitElem(type_idx, elem_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx)
     |       mark_elem(ctx, elem_idx)
     |     }
1173 |     ArrayCopy(type_idx1, type_idx2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       mark_type(ctx, type_idx1)
     |       mark_type(ctx, type_idx2)
     |     }
1177 |     RefNull(ht) => mark_heaptype(ctx, ht)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefCast(_, ht) | RefTest(_, ht) => mark_heaptype(ctx, ht)
     |     BrOnCast(_, _, ht1, ht2) | BrOnCastFail(_, _, ht1, ht2) => {
     |       mark_heaptype(ctx, ht1)
     |       mark_heaptype(ctx, ht2)
     |     }
     |     Select(types) =>
1184 |       match types {
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(vts) =>
1186 |           for vt in vts {
     |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             mark_valtype(ctx, vt)
     |           }
1189 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     I32Load(ma)
     |     | I64Load(ma)
     |     | F32Load(ma)
     |     | F64Load(ma)
     |     | I32Load8S(ma)
     |     | I32Load8U(ma)
     |     | I32Load16S(ma)
     |     | I32Load16U(ma)
     |     | I64Load8S(ma)
     |     | I64Load8U(ma)
     |     | I64Load16S(ma)
     |     | I64Load16U(ma)
     |     | I64Load32S(ma)
     |     | I64Load32U(ma)
     |     | I32Store(ma)
     |     | I64Store(ma)
     |     | F32Store(ma)
     |     | F64Store(ma)
     |     | I32Store8(ma)
     |     | I32Store16(ma)
     |     | I64Store8(ma)
     |     | I64Store16(ma)
     |     | I64Store32(ma)
     |     | V128Load(ma)
     |     | V128Load8x8S(ma)
     |     | V128Load8x8U(ma)
     |     | V128Load16x4S(ma)
     |     | V128Load16x4U(ma)
     |     | V128Load32x2S(ma)
     |     | V128Load32x2U(ma)
     |     | V128Load8Splat(ma)
     |     | V128Load16Splat(ma)
     |     | V128Load32Splat(ma)
     |     | V128Load64Splat(ma)
     |     | V128Store(ma)
     |     | V128Load8Lane(ma, _)
     |     | V128Load16Lane(ma, _)
     |     | V128Load32Lane(ma, _)
     |     | V128Load64Lane(ma, _)
     |     | V128Store8Lane(ma, _)
     |     | V128Store16Lane(ma, _)
     |     | V128Store32Lane(ma, _)
     |     | V128Store64Lane(ma, _)
     |     | V128Load32Zero(ma)
1235 |     | V128Load64Zero(ma) => if ma.1 is Some(idx) { mark_mem(ctx, idx) }
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => ()
     |   }
     | }
     …

     | fn[T : Hash + Eq] build_map(
     |   used_set : Set[T],
     |   import_count : UInt,
     |   extract : (T) -> Result[UInt, String],
     |   construct : (UInt) -> T,
     | ) -> Result[Map[T, T], String] {
     |   let map : Map[T, T] = Map::new()
     |   let imports : Array[(T, UInt)] = []
     |   let defined : Array[(T, UInt)] = []
     |   for idx in used_set {
     |     let v = match extract(idx) {
     |       Ok(v) => v
1258 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if v >= import_count {
     |       defined.push((idx, v))
     |     } else {
1263 |       imports.push((idx, v))
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
1266 |   imports.sort_by(fn(a, b) { a.1.compare(b.1) })
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   defined.sort_by(fn(a, b) { a.1.compare(b.1) })
     |   let mut next : UInt = 0
     |   for pair in imports {
1270 |     map.set(pair.0, construct(next))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     next += 1
     |   }
     |   for pair in defined {
     |     map.set(pair.0, construct(next))
     |     next += 1
     |   }
     |   Ok(map)
     | }
     …

     | fn build_remappings(
     |   used : UsedIndices,
     |   imports : ImportCounts,
     | ) -> Result[Remappings, String] {
     |   let remap = Remappings::new()
     | 
     |   // Build each remapping
     |   remap.funcs = match
     |     build_map(
     |       used.funcs,
     |       imports.funcs,
     |       fn(idx) {
     |         let FuncIdx(v) = idx
     |         Ok(v)
     |       },
     |       FuncIdx::new,
     |     ) {
     |     Ok(m) => m
1299 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   remap.tables = match
     |     build_map(
     |       used.tables,
     |       imports.tables,
     |       fn(idx) {
     |         let TableIdx(v) = idx
     |         Ok(v)
     |       },
     |       TableIdx::new,
     |     ) {
     |     Ok(m) => m
1312 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   remap.mems = match
     |     build_map(
     |       used.mems,
     |       imports.mems,
     |       fn(idx) {
     |         let MemIdx(v) = idx
     |         Ok(v)
     |       },
     |       MemIdx::new,
     |     ) {
     |     Ok(m) => m
1325 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   remap.globals = match
     |     build_map(
     |       used.globals,
     |       imports.globals,
     |       fn(idx) {
1332 |         let GlobalIdx(v) = idx
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(v)
     |       },
     |       GlobalIdx::new,
     |     ) {
     |     Ok(m) => m
1338 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   remap.tags = match
     |     build_map(
     |       used.tags,
     |       imports.tags,
     |       fn(idx) {
1345 |         let TagIdx(v) = idx
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(v)
     |       },
     |       TagIdx::new,
     |     ) {
     |     Ok(m) => m
1351 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Types, elems, datas have no imports
     |   remap.types = match
     |     build_map(
     |       used.types,
     |       0,
     |       fn(idx) {
     |         match idx {
     |           TypeIdx(v) => Ok(v)
     |           RecIdx(_) =>
1363 |             Err(
     |             ^^^^ 	<-- UNCOVERED
     |               "unexpected RecIdx in type remapping (RecIdx is only used during validation)",
     |             )
     |         }
     |       },
     |       TypeIdx::new,
     |     ) {
     |     Ok(m) => m
1371 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   remap.elems = match
     |     build_map(
     |       used.elems,
     |       0,
     |       fn(idx) {
     |         let ElemIdx(v) = idx
     |         Ok(v)
     |       },
     |       ElemIdx::new,
     |     ) {
     |     Ok(m) => m
1384 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   remap.datas = match
     |     build_map(
     |       used.datas,
     |       0,
     |       fn(idx) {
     |         let DataIdx(v) = idx
     |         Ok(v)
     |       },
     |       DataIdx::new,
     |     ) {
     |     Ok(m) => m
1397 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(remap)
     | }
     …

     | fn make_func_unreachable(func : Func) -> Func {
     |   match func {
     |     TFunc(_, _) => Func::t_func([], TExpr::new([TInstr::unreachable_()]))
1410 |     Func(_, _) => Func::new([], Expr::new([Instruction::unreachable_()]))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn remove_unused_with_props(
     |   mod : Module,
     |   props : RemoveUnusedProps,
     | ) -> Result[Module, String] {
     |   // Phase 1: Analysis
     |   let ctx = AnalysisContext::new(mod, props)
     |   analyze(ctx)
     | 
     |   let referenced_only_funcs : Set[FuncIdx] = Set::new()
     |   for func_idx in ctx.referenced_funcs {
     |     if not(ctx.used.funcs.contains(func_idx)) {
     |       referenced_only_funcs.add(func_idx)
     |       ctx.used.funcs.add(func_idx)
     |       match ctx.func_type_by_func.get(func_idx) {
     |         Some(type_idx) => mark_type(ctx, type_idx)
1430 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | 
     |   // Ensure transitive type dependencies for referenced-only functions.
     |   analyze_type_dependencies(ctx)
     | 
     |   // Check if everything is used
     |   let total_funcs = ctx.imports.funcs +
     |     (match mod.code_sec {
     |       Some(cs) => cs.0.length().reinterpret_as_uint()
     |       None => 0
     |     })
     |   let total_types = match mod.type_sec {
     |     Some(ts) => ts.0.length().reinterpret_as_uint()
     |     None => 0
     |   }
     |   let total_tables = ctx.imports.tables +
     |     (match mod.table_sec {
     |       Some(ts) => ts.0.length().reinterpret_as_uint()
     |       None => 0
     |     })
     |   let total_mems = ctx.imports.mems +
     |     (match mod.mem_sec {
     |       Some(ms) => ms.0.length().reinterpret_as_uint()
     |       None => 0
     |     })
     |   let total_globals = ctx.imports.globals +
     |     (match mod.global_sec {
     |       Some(gs) => gs.0.length().reinterpret_as_uint()
     |       None => 0
     |     })
     |   let total_elems = match mod.elem_sec {
     |     Some(es) => es.0.length().reinterpret_as_uint()
     |     None => 0
     |   }
     |   let total_datas = match mod.data_sec {
     |     Some(ds) => ds.0.length().reinterpret_as_uint()
     |     None => 0
     |   }
     |   let total_tags = ctx.imports.tags +
     |     (match mod.tag_sec {
     |       Some(ts) => ts.0.length().reinterpret_as_uint()
     |       None => 0
     |     })
     |   if ctx.used.funcs.length().reinterpret_as_uint() == total_funcs &&
     |     ctx.used.types.length().reinterpret_as_uint() == total_types &&
     |     ctx.used.tables.length().reinterpret_as_uint() == total_tables &&
     |     ctx.used.mems.length().reinterpret_as_uint() == total_mems &&
     |     ctx.used.globals.length().reinterpret_as_uint() == total_globals &&
     |     ctx.used.elems.length().reinterpret_as_uint() == total_elems &&
     |     ctx.used.datas.length().reinterpret_as_uint() == total_datas &&
     |     ctx.used.tags.length().reinterpret_as_uint() == total_tags &&
     |     referenced_only_funcs.is_empty() {
     |     // Nothing to remove
     |     return Ok(mod)
     |   }
     | 
     |   // Phase 2: Build remappings
     |   let remap = match build_remappings(ctx.used, ctx.imports) {
     |     Ok(m) => m
1492 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let state : DCEState = {
     |     used: ctx.used,
     |     remap,
     |     imports: ctx.imports,
     |     referenced_only_funcs,
     |   }
     | 
     |   // Phase 3: Transform using ModuleTransformer
     |   let transformer = ModuleTransformer::new()
     |     // Remap all index types
     |     .on_funcidx_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       idx : FuncIdx,
     |     ) {
1509 |       match s.remap.funcs.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_typeidx_evt(fn(_t, s : DCEState, idx : TypeIdx) {
1515 |       match s.remap.types.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_tableidx_evt(fn(_t, s : DCEState, idx : TableIdx) {
1521 |       match s.remap.tables.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_memidx_evt(fn(_t, s : DCEState, idx : MemIdx) {
1527 |       match s.remap.mems.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_globalidx_evt(fn(_t, s : DCEState, idx : GlobalIdx) {
1533 |       match s.remap.globals.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_elemidx_evt(fn(_t, s : DCEState, idx : ElemIdx) {
1539 |       match s.remap.elems.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_dataidx_evt(fn(_t, s : DCEState, idx : DataIdx) {
1545 |       match s.remap.datas.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     .on_tagidx_evt(fn(_t, s : DCEState, idx : TagIdx) {
1551 |       match s.remap.tags.get(idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(new_idx) => change(s, new_idx)
     |         None => unchanged()
     |       }
     |     })
     |     // Also remap heap types that reference type indices
     |     .on_heaptype_evt(fn(_t, s : DCEState, ht : HeapType) {
1558 |       match ht {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         HeapType(idx) =>
1560 |           match s.remap.types.get(idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(new_idx) => change(s, HeapType::new(new_idx))
     |             None => unchanged()
     |           }
1564 |         _ => unchanged()
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     // Filter import section
     |     .on_importsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       imp_sec : ImportSec,
     |     ) {
     |       let new_imports = []
     |       let mut func_idx : UInt = 0
     |       let mut table_idx : UInt = 0
     |       let mut mem_idx : UInt = 0
     |       let mut global_idx : UInt = 0
     |       let mut tag_idx : UInt = 0
     |       for imp in imp_sec.0 {
     |         match imp {
     |           Import(mod_name, name, extern_type) => {
     |             let keep = match extern_type {
     |               FuncExternType(_) => {
     |                 let idx = FuncIdx::new(func_idx)
     |                 func_idx += 1
     |                 s.used.funcs.contains(idx)
     |               }
1588 |               TableExternType(_) => {
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = TableIdx::new(table_idx)
     |                 table_idx += 1
1591 |                 s.used.tables.contains(idx)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1593 |               MemExternType(_) => {
     |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = MemIdx::new(mem_idx)
     |                 mem_idx += 1
1596 |                 s.used.mems.contains(idx)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1598 |               GlobalExternType(_) => {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = GlobalIdx::new(global_idx)
     |                 global_idx += 1
1601 |                 s.used.globals.contains(idx)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1603 |               TagExternType(_) => {
     |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 let idx = TagIdx::new(tag_idx)
     |                 tag_idx += 1
1606 |                 s.used.tags.contains(idx)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |             if keep {
     |               // Transform the import to remap type indices
1611 |               let new_extern = match extern_type {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 FuncExternType(type_idx) =>
1613 |                   match s.remap.types.get(type_idx) {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     Some(new_type_idx) => ExternType::func(new_type_idx)
     |                     None => extern_type
     |                   }
1617 |                 _ => extern_type // Other extern types don't need remapping here
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1619 |               new_imports.push(Import::new(mod_name, name, new_extern))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |         }
     |       }
     |       change(s, ImportSec::new(new_imports))
     |     })
     |     // Filter type section
     |     .on_typesec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       type_sec : TypeSec,
     |     ) {
     |       let new_types = []
     |       let types = type_sec.0
     |       for i = 0; i < types.length(); i = i + 1 {
     |         let type_idx = TypeIdx::new(i.reinterpret_as_uint())
     |         if s.used.types.contains(type_idx) {
     |           // Transform recursively to remap type references
     |           let rec_type = types[i]
     |           // Let the transformer handle the inner remapping
     |           new_types.push(rec_type)
     |         }
     |       }
     |       change(s, TypeSec::new(new_types))
     |     })
     |     // Filter func section (type indices for defined functions)
     |     .on_funcsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       func_sec : FuncSec,
     |     ) {
     |       let new_types = []
     |       let types = func_sec.0
     |       for i = 0; i < types.length(); i = i + 1 {
     |         let func_idx = FuncIdx::new(s.imports.funcs + i.reinterpret_as_uint())
     |         if s.used.funcs.contains(func_idx) {
     |           let type_idx = types[i]
     |           match s.remap.types.get(type_idx) {
     |             Some(new_type_idx) => new_types.push(new_type_idx)
1659 |             None => new_types.push(type_idx)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |       change(s, FuncSec::new(new_types))
     |     })
     |     // Filter code section
     |     .on_codesec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       code_sec : CodeSec,
     |     ) {
     |       let new_funcs = []
     |       let funcs = code_sec.0
     |       for i = 0; i < funcs.length(); i = i + 1 {
     |         let func_idx = FuncIdx::new(s.imports.funcs + i.reinterpret_as_uint())
     |         if s.used.funcs.contains(func_idx) {
     |           if s.referenced_only_funcs.contains(func_idx) {
     |             new_funcs.push(make_func_unreachable(funcs[i]))
     |           } else {
     |             new_funcs.push(funcs[i])
     |           }
     |         }
     |       }
     |       change(s, CodeSec::new(new_funcs))
     |     })
     |     // Filter table section
     |     .on_tablesec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       table_sec : TableSec,
     |     ) {
     |       let new_tables = []
     |       let tables = table_sec.0
     |       for i = 0; i < tables.length(); i = i + 1 {
     |         let table_idx = TableIdx::new(
     |           s.imports.tables + i.reinterpret_as_uint(),
     |         )
     |         if s.used.tables.contains(table_idx) {
     |           new_tables.push(tables[i])
     |         }
     |       }
     |       change(s, TableSec::new(new_tables))
     |     })
     |     // Filter memory section
     |     .on_memsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       mem_sec : MemSec,
     |     ) {
     |       let new_mems = []
     |       let mems = mem_sec.0
     |       for i = 0; i < mems.length(); i = i + 1 {
     |         let mem_idx = MemIdx::new(s.imports.mems + i.reinterpret_as_uint())
     |         if s.used.mems.contains(mem_idx) {
     |           new_mems.push(mems[i])
     |         }
     |       }
     |       change(s, MemSec::new(new_mems))
     |     })
     |     // Filter global section
     |     .on_globalsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       global_sec : GlobalSec,
     |     ) {
     |       let new_globals = []
     |       let globals = global_sec.0
     |       for i = 0; i < globals.length(); i = i + 1 {
     |         let global_idx = GlobalIdx::new(
     |           s.imports.globals + i.reinterpret_as_uint(),
     |         )
     |         if s.used.globals.contains(global_idx) {
1732 |           new_globals.push(globals[i])
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       change(s, GlobalSec::new(new_globals))
     |     })
     |     // Filter tag section
     |     .on_tagsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       tag_sec : TagSec,
     |     ) {
1743 |       let new_tags = []
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let tags = tag_sec.0
1745 |       for i = 0; i < tags.length(); i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let tag_idx = TagIdx::new(s.imports.tags + i.reinterpret_as_uint())
     |         if s.used.tags.contains(tag_idx) {
1748 |           new_tags.push(tags[i])
     |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1751 |       change(s, TagSec::new(new_tags))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     })
     |     // Filter element section
     |     .on_elemsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       elem_sec : ElemSec,
     |     ) {
     |       let new_elems = []
     |       let elems = elem_sec.0
     |       for i = 0; i < elems.length(); i = i + 1 {
     |         let elem_idx = ElemIdx::new(i.reinterpret_as_uint())
     |         if s.used.elems.contains(elem_idx) {
     |           new_elems.push(elems[i])
     |         }
     |       }
     |       change(s, ElemSec::new(new_elems))
     |     })
     |     // Filter data section
     |     .on_datasec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       data_sec : DataSec,
     |     ) {
     |       let new_datas = []
     |       let datas = data_sec.0
     |       for i = 0; i < datas.length(); i = i + 1 {
     |         let data_idx = DataIdx::new(i.reinterpret_as_uint())
     |         if s.used.datas.contains(data_idx) {
     |           new_datas.push(datas[i])
     |         }
     |       }
     |       change(s, DataSec::new(new_datas))
     |     })
     |     // Update data count section
     |     .on_datacntsec_evt(fn(_t : ModuleTransformer[DCEState], s : DCEState, _) {
     |       let count = s.used.datas.length().reinterpret_as_uint()
     |       change(s, DataCntSec::new(count))
     |     })
     |     // Filter exports to only include used items
     |     .on_exportsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       export_sec : ExportSec,
     |     ) {
     |       let new_exports = []
     |       for exp in export_sec.0 {
     |         match exp {
     |           Export(name, extern_idx) => {
     |             let (keep, new_extern_idx) = match extern_idx {
     |               FuncExternIdx(idx) =>
     |                 if s.used.funcs.contains(idx) {
     |                   match s.remap.funcs.get(idx) {
     |                     Some(new_idx) => (true, ExternIdx::func(new_idx))
1805 |                     None => (true, extern_idx)
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 } else {
1808 |                   (false, extern_idx)
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               TableExternIdx(idx) =>
1811 |                 if s.used.tables.contains(idx) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   match s.remap.tables.get(idx) {
     |                     Some(new_idx) => (true, ExternIdx::table(new_idx))
     |                     None => (true, extern_idx)
     |                   }
     |                 } else {
1817 |                   (false, extern_idx)
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               MemExternIdx(idx) =>
1820 |                 if s.used.mems.contains(idx) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   match s.remap.mems.get(idx) {
     |                     Some(new_idx) => (true, ExternIdx::mem(new_idx))
     |                     None => (true, extern_idx)
     |                   }
     |                 } else {
1826 |                   (false, extern_idx)
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               GlobalExternIdx(idx) =>
1829 |                 if s.used.globals.contains(idx) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   match s.remap.globals.get(idx) {
     |                     Some(new_idx) => (true, ExternIdx::global(new_idx))
     |                     None => (true, extern_idx)
     |                   }
     |                 } else {
1835 |                   (false, extern_idx)
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               TagExternIdx(idx) =>
1838 |                 if s.used.tags.contains(idx) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   match s.remap.tags.get(idx) {
     |                     Some(new_idx) => (true, ExternIdx::tag(new_idx))
     |                     None => (true, extern_idx)
     |                   }
     |                 } else {
1844 |                   (false, extern_idx)
     |                   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |             }
     |             if keep {
     |               new_exports.push(Export::new(name, new_extern_idx))
     |             }
     |           }
     |         }
     |       }
     |       change(s, ExportSec::new(new_exports))
     |     })
     |     // Update start section
     |     .on_startsec_evt(fn(
     |       _t : ModuleTransformer[DCEState],
     |       s : DCEState,
     |       start_sec : StartSec,
     |     ) {
     |       let func_idx = start_sec.0
     |       match s.remap.funcs.get(func_idx) {
     |         Some(new_idx) => change(s, StartSec::new(new_idx))
1864 |         None => unchanged()
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |   transformer
     |   .walk_module(state, mod)
     |   .map(fn(pair : (DCEState, Module)?) {
     |     match pair {
     |       Some((_, mod)) => mod
1872 |       None => mod
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

     | fn func_body_is_unreachable(func : Func) -> Bool {
     |   match func {
     |     TFunc(_, TExpr(instrs)) => instrs.length() == 1 && instrs[0] is TUnreachable
1915 |     Func(_, Expr(instrs)) => instrs.length() == 1 && instrs[0] is Unreachable
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn func_body_has_direct_call_to(func : Func, target : FuncIdx) -> Bool {
     |   match func {
     |     TFunc(_, TExpr(instrs)) =>
     |       for instr in instrs {
     |         match instr {
     |           TCall(idx, _) | TReturnCall(idx, _) if idx == target => return true
1926 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     Func(_, Expr(instrs)) =>
1930 |       for instr in instrs {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match instr {
     |           Call(idx) | ReturnCall(idx) if idx == target => return true
     |           _ => ()
     |         }
     |       }
     |   }
     |   false
     | }
     …

71 uncovered line(s) in src/passes/remove_unused_brs.mbt:

     | fn rub_is_single_tinstr(expr : TExpr) -> TInstr? {
     |   match expr.0 {
     |     [single] => Some(single)
  42 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rub_instr_has_branch(instr : TInstr) -> Bool {
     |   match instr {
     |     TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
     |     | TReturn(_)
     |     | TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
     |     | TReturnCallRef(_, _, _)
     |     | TThrow(_, _)
     |     | TThrowRef(_) => true
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
  63 |       rub_texpr_has_branch(body)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       if rub_instr_has_branch(cond) || rub_texpr_has_branch(then_body) {
  66 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
  68 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => rub_texpr_has_branch(other)
     |         None => false
     |       }
     |     }
  73 |     _ => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       for child in eval_children(instr) {
  75 |         if rub_instr_has_branch(child) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn rub_instr_cost(instr : TInstr) -> Int {
     |   match instr {
     |     TI32Const(_)
     |     | TI64Const(_)
     |     | TF32Const(_)
     |     | TF64Const(_)
     |     | TRefNull(_)
     |     | TRefFunc(_)
     |     | TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)
     |     | TLocalGet(_)
     |     | TNop => 0
 106 |     TThrow(_, _) | TThrowRef(_) => RUB_TOO_COSTLY_TO_RUN_UNCONDITIONALLY
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefCast(_, _, _) => RUB_TOO_COSTLY_TO_RUN_UNCONDITIONALLY / 2 + 1
     |     _ => {
     |       let mut total = 1
     |       for child in eval_children(instr) {
 111 |         total += rub_instr_cost(child)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       total
     |     }
     |   }
     | }
     …

     | fn rub_too_costly_to_run_unconditionally(
     |   options : OptimizeOptions,
     |   cost : Int,
     | ) -> Bool {
     |   if options.shrink_level == 0 {
     |     cost > RUB_TOO_COSTLY_TO_RUN_UNCONDITIONALLY / 2
 125 |   } else if options.shrink_level == 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     cost >= RUB_TOO_COSTLY_TO_RUN_UNCONDITIONALLY
     |   } else {
 128 |     false
     |     ^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rub_too_costly_expr(options : OptimizeOptions, instr : TInstr) -> Bool {
 134 |   if options.shrink_level >= 2 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return false
     |   }
 137 |   rub_too_costly_to_run_unconditionally(options, rub_instr_cost(instr))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn rub_too_costly_pair(
     |   options : OptimizeOptions,
     |   one : TInstr,
     |   two : TInstr,
     | ) -> Bool {
     |   if options.shrink_level >= 2 {
 147 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let cost = Int::max(rub_instr_cost(one), rub_instr_cost(two))
     |   rub_too_costly_to_run_unconditionally(options, cost)
     | }
     …

     | fn rub_can_turn_if_into_br_if(
     |   if_condition : TInstr,
     |   br_value : TInstr?,
     | ) -> Bool {
     |   if is_unreachable_instr(if_condition) {
 159 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match br_value {
 162 |     Some(v) => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value_effects = lcs_collect_effects(v)
     |       if value_effects.has_unremovable_side_effects() {
 165 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 167 |       !lcs_collect_effects(if_condition).invalidates(value_effects)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     None => true
     |   }
     | }
     …

     | fn rub_fold_condition_to_bool(instr : TInstr) -> Bool? {
     |   match rub_is_const_i32(instr) {
     |     Some(v) => Some(v != 0)
     |     None =>
     |       match instr {
     |         TUnary(I32EqzOp, inner) =>
 180 |           match rub_is_const_i32(inner) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(v) => Some(v == 0)
     |             None => None
     |           }
     |         _ => None
     |       }
     |   }
     | }
     …

     | fn rub_optimize_br_table(instr : TInstr) -> (TInstr, Bool) {
     |   match instr {
     |     TBrTable(targets, default_, cond, values) => {
     |       let mut changed = false
     |       let mut targets = targets.copy()
     |       while targets.length() > 0 && targets[targets.length() - 1] == default_ {
     |         ignore(targets.pop())
     |         changed = true
     |       }
     |       let mut removable = 0
     |       while removable < targets.length() && targets[removable] == default_ {
 223 |         removable += 1
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut cond = cond
     |       if removable > 0 {
 227 |         let shifted : Array[LabelIdx] = []
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for i in removable..<targets.length() {
 229 |           shifted.push(targets[i])
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         targets = shifted
 232 |         cond = TInstr::binary(
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           BinaryOp::i32_sub(),
     |           cond,
 235 |           TInstr::i32_const(I32(removable)),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         )
     |         changed = true
     |       }
     | 
     |       if values.length() > 0 {
 241 |         let out = TInstr::br_table(targets, default_, cond, values)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return (out, changed)
     |       }
     | 
     |       let unique : Set[LabelIdx] = Set::new()
     |       unique.add(default_)
     |       for target in targets {
     |         unique.add(target)
     |       }
     |       if unique.length() == 1 {
     |         return (rub_default_only_switch(default_, cond), true)
     |       }
     | 
     |       if targets.length() == 0 {
 255 |         return (rub_default_only_switch(default_, cond), true)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if targets.length() == 1 {
     |         return (rub_single_target_switch(targets[0], default_, cond), true)
     |       }
 260 |       (TInstr::br_table(targets, default_, cond, values), changed)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => (instr, false)
     |   }
     | }
     …

     | fn rub_optimize_if(instr : TInstr, options : OptimizeOptions) -> (TInstr, Bool) {
     |   match instr {
     |     TIf(bt, condition, then_body, else_body) =>
     |       match else_body {
     |         Some(_) => (instr, false)
     |         None =>
     |           match rub_is_single_tinstr(then_body) {
     |             Some(TBr(label, values)) => {
     |               let br_value = if values.length() == 1 {
 276 |                 Some(values[0])
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               } else {
     |                 None
     |               }
     |               if rub_can_turn_if_into_br_if(condition, br_value) {
     |                 (TInstr::br_if(label, condition, values), true)
     |               } else {
 283 |                 (instr, false)
     |                 ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |             Some(TBrIf(label, inner_cond, values)) => {
     |               if values.length() != 0 ||
     |                 rub_has_side_effects(inner_cond) ||
     |                 rub_too_costly_pair(options, inner_cond, rub_zero_i32()) {
 290 |                 return (instr, false)
     |                 ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               let next_cond = TInstr::select(
     |                 None,
     |                 inner_cond,
     |                 condition,
     |                 rub_zero_i32(),
     |               )
     |               (TInstr::br_if(label, next_cond, []), true)
     |             }
 300 |             Some(TIf(_, child_cond, child_then, None)) => {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               if rub_has_side_effects(child_cond) ||
     |                 rub_too_costly_expr(options, child_cond) {
 303 |                 return (instr, false)
     |                 ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 305 |               let next_cond = TInstr::select(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 None,
     |                 child_cond,
     |                 condition,
 309 |                 rub_zero_i32(),
     |                 ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               )
 311 |               (TInstr::if_(bt, next_cond, child_then, None), true)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
 313 |             _ => (instr, false)
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     _ => (instr, false)
     |   }
     | }
     …

     | fn rub_optimize_br_if(instr : TInstr) -> (TInstr, Bool) {
     |   match instr {
     |     TBrIf(label, cond, values) =>
     |       match rub_fold_condition_to_bool(cond) {
     |         Some(true) => (TInstr::br(label, values), true)
     |         Some(false) =>
     |           if values.length() == 0 {
     |             (TInstr::drop(cond), true)
 329 |           } else if values.length() == 1 {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             (
     |               TInstr::block(
     |                 BlockType::void_(),
     |                 TExpr::new([TInstr::drop(values[0]), TInstr::drop(cond)]),
     |               ),
     |               true,
     |             )
     |           } else {
 338 |             (instr, false)
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         None => (instr, false)
     |       }
     |     _ => (instr, false)
     |   }
     | }
     …

     | fn rub_remove_trailing_flow_break(instrs : Array[TInstr]) -> Bool {
     |   if instrs.length() == 0 {
     |     return false
     |   }
     |   let idx = instrs.length() - 1
     |   match instrs[idx] {
     |     TBr(label, values) => {
     |       if !rub_is_label_zero(label) {
     |         return false
     |       }
     |       match values {
     |         [] => {
     |           ignore(instrs.pop())
     |           true
     |         }
     |         [single] => {
     |           instrs[idx] = single
     |           true
     |         }
 381 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => false
     |   }
     | }
     …

     | fn rub_remove_trailing_return(instrs : Array[TInstr]) -> Bool {
     |   if instrs.length() == 0 {
 391 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let idx = instrs.length() - 1
     |   match instrs[idx] {
     |     TReturn(values) =>
     |       match values {
     |         [] => {
     |           ignore(instrs.pop())
     |           true
     |         }
     |         [single] => {
     |           instrs[idx] = single
     |           true
     |         }
 405 |         _ => false
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => false
     |   }
     | }
     …

     | fn rub_optimize_adjacent_breaks(
     |   instrs : Array[TInstr],
     |   options : OptimizeOptions,
     | ) -> Bool {
     |   let mut changed = false
     |   let mut i = 0
     |   while i + 1 < instrs.length() {
     |     match instrs[i] {
     |       TBrIf(label1, cond1, values1) =>
     |         if values1.length() == 0 {
     |           match instrs[i + 1] {
     |             TBr(label2, values2) =>
 424 |               if label1 == label2 && values2.length() == 0 {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 instrs[i] = TInstr::drop(cond1)
     |                 changed = true
     |               }
     |             TBrIf(label2, cond2, values2) =>
     |               if label1 == label2 &&
     |                 values2.length() == 0 &&
     |                 options.shrink_level > 0 &&
     |                 !rub_has_side_effects(cond2) {
     |                 instrs[i] = TInstr::br_if(
     |                   label1,
     |                   TInstr::binary(BinaryOp::i32_or(), cond1, cond2),
     |                   [],
     |                 )
     |                 instrs[i + 1] = TInstr::nop()
     |                 changed = true
     |               }
 441 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       _ => ()
     |     }
     |     i += 1
     |   }
     |   changed
     | }
     …

     | fn rub_optimize_if_else_block_tail(instrs : Array[TInstr]) -> Bool {
     |   let mut changed = false
     |   let mut i = 0
     |   while i < instrs.length() {
     |     match instrs[i] {
     |       TIf(_, cond, then_body, Some(else_body)) => {
     |         let mut applied = false
     |         match rub_is_single_tinstr(then_body) {
     |           Some(TBr(label, values)) =>
     |             if !rub_texpr_has_branch(else_body) &&
     |               rub_can_turn_if_into_br_if(
     |                 cond,
     |                 if values.length() == 1 {
     |                   Some(values[0])
     |                 } else {
     |                   None
     |                 },
     |               ) {
     |               instrs[i] = TInstr::br_if(label, cond, values)
     |               let next : Array[TInstr] = []
     |               for j in 0..<instrs.length() {
     |                 next.push(instrs[j])
     |                 if j == i {
     |                   for item in else_body.0 {
 476 |                     next.push(item)
     |                     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |               }
     |               instrs.clear()
     |               for item in next {
     |                 instrs.push(item)
     |               }
     |               changed = true
     |               i += else_body.0.length()
     |               applied = true
     |             }
 488 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if !applied {
     |           match rub_is_single_tinstr(else_body) {
     |             Some(TBr(label, values)) =>
     |               if !rub_texpr_has_branch(then_body) &&
     |                 rub_can_turn_if_into_br_if(
     |                   cond,
     |                   if values.length() == 1 {
     |                     Some(values[0])
     |                   } else {
     |                     None
     |                   },
     |                 ) {
 502 |                 instrs[i] = TInstr::br_if(
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   label,
 504 |                   TInstr::unary(UnaryOp::i32_eqz(), cond),
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   values,
     |                 )
     |                 let next : Array[TInstr] = []
     |                 for j in 0..<instrs.length() {
 509 |                   next.push(instrs[j])
     |                   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   if j == i {
 511 |                     for item in then_body.0 {
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       next.push(item)
     |                     }
     |                   }
     |                 }
 516 |                 instrs.clear()
     |                 ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 for item in next {
 518 |                   instrs.push(item)
     |                   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |                 changed = true
 521 |                 i += then_body.0.length()
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 applied = true
     |               }
 524 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     |       _ => ()
     |     }
     |     i += 1
     |   }
     |   changed
     | }
     …

     | fn rub_optimize_redundant_dropped_br_if_tail(instrs : Array[TInstr]) -> Bool {
     |   if instrs.length() < 2 {
     |     return false
     |   }
     |   let second_last_i = instrs.length() - 2
     |   let last_i = instrs.length() - 1
     |   match instrs[second_last_i] {
     |     TDrop(TBrIf(label, cond, [value])) =>
     |       if rub_is_label_zero(label) && value == instrs[last_i] {
     |         let value_effects = lcs_collect_effects(value)
     |         if value_effects.has_unremovable_side_effects() {
 547 |           return false
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let cond_effects = lcs_collect_effects(cond)
     |         if cond_effects.invalidates(value_effects) {
 551 |           return false
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         instrs[second_last_i] = TInstr::drop(cond)
     |         true
     |       } else {
 556 |         false
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => false
     |   }
     | }
     …

     | fn rub_optimize_entry_restructure_if(instrs : Array[TInstr]) -> Bool {
     |   if instrs.length() < 2 {
     |     return false
     |   }
     |   match instrs[0] {
 568 |     TDrop(TBrIf(label, cond, [])) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if !rub_is_label_zero(label) {
 570 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let tail : Array[TInstr] = []
     |       for i in 1..<instrs.length() {
 574 |         tail.push(instrs[i])
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 576 |       let tail_expr = TExpr::new(tail)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if has_break_to_depth_in_texpr(tail_expr, 0) ||
     |         rub_texpr_has_branch(tail_expr) {
 579 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 581 |       instrs.clear()
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       instrs.push(
     |         TInstr::if_(
     |           BlockType::void_(),
     |           TInstr::unary(UnaryOp::i32_eqz(), cond),
     |           tail_expr,
     |           None,
     |         ),
     |       )
     |       true
     |     }
     |     _ => false
     |   }
     | }
     …

     | fn rub_optimize_instr_list(
     |   instrs : Array[TInstr],
     |   options : OptimizeOptions,
     |   in_function_body : Bool,
     | ) -> Bool {
     |   let mut changed = false
     |   if rub_remove_trailing_nops(instrs) {
     |     changed = true
     |   }
     |   if rub_remove_trailing_flow_break(instrs) {
     |     changed = true
     |   }
     |   if in_function_body && rub_remove_trailing_return(instrs) {
     |     changed = true
     |   }
     |   if rub_optimize_if_else_block_tail(instrs) {
     |     changed = true
     |   }
     |   if rub_optimize_adjacent_breaks(instrs, options) {
     |     changed = true
     |   }
     |   if rub_optimize_redundant_dropped_br_if_tail(instrs) {
     |     changed = true
     |   }
     |   if rub_optimize_entry_restructure_if(instrs) {
 622 |     changed = true
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if rub_remove_trailing_nops(instrs) {
     |     changed = true
     |   }
     |   if rub_remove_trailing_flow_break(instrs) {
 628 |     changed = true
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if in_function_body && rub_remove_trailing_return(instrs) {
 631 |     changed = true
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   changed
     | }
     …

     | fn remove_unused_brs_pass(options : OptimizeOptions) -> ModuleTransformer[Bool] {
     |   ModuleTransformer::new()
     |   .on_func_evt(fn(self, _, func) {
     |     match func {
     |       TFunc(locals, body) => {
     |         let new_body = match self.walk_texpr(true, body) {
     |           Ok(Some((_, walked))) => walked
 644 |           Ok(None) => body
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |         if new_body != body {
     |           change(false, Func::t_func(locals, new_body))
     |         } else {
     |           unchanged()
     |         }
     |       }
 653 |       _ => unchanged()
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   .on_texpr_evt(fn(self, in_function_body, expr) {
     |     let out : Array[TInstr] = []
     |     let mut changed = false
     |     for instr in expr.0 {
     |       let next_instr = match self.walk_tinstruction(false, instr) {
     |         Ok(Some((_, walked))) => walked
     |         Ok(None) => instr
 663 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if next_instr != instr {
     |         changed = true
     |       }
     |       out.push(next_instr)
     |     }
     |     if rub_optimize_instr_list(out, options, in_function_body) {
     |       changed = true
     |     }
     |     if changed {
     |       change(in_function_body, TExpr::new(out))
     |     } else {
     |       unchanged()
     |     }
     |   })
     |   .on_tinstruction_evt(fn(self, _, instr) {
     |     let walked = match self.walk_tinstruction_default(false, instr) {
     |       Ok(Some((_, updated))) => updated
     |       Ok(None) => instr
 683 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let (after_if, changed_if) = rub_optimize_if(walked, options)
     |     let (after_br_table, changed_switch) = rub_optimize_br_table(after_if)
     |     let (after_br_if, changed_br_if) = rub_optimize_br_if(after_br_table)
     |     if changed_if || changed_switch || changed_br_if || after_br_if != instr {
     |       change(false, after_br_if)
     |     } else {
     |       unchanged()
     |     }
     |   })
     | }
     …

     | fn remove_unused_brs(
     |   mod : Module,
     |   options? : OptimizeOptions = OptimizeOptions::new(),
     | ) -> Result[Module, String] {
     |   let mut curr = mod
     |   let mut rounds = 0
     |   while rounds < 16 {
     |     rounds += 1
     |     let pass = remove_unused_brs_pass(options)
     |     match pass.walk_module(false, curr) {
     |       Ok(Some((_, next_mod))) => {
     |         if next_mod == curr {
     |           break
     |         }
     |         curr = next_mod
     |       }
 713 |       Ok(None) => break
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Err(e) => return Err(e)
     |     }
     |   }
     |   Ok(curr)
     | }
     …

     | fn rub_run(
     |   mod : Module,
     |   options? : OptimizeOptions = OptimizeOptions::new(),
     | ) -> Module {
     |   match remove_unused_brs(mod, options~) {
     |     Ok(next_mod) => next_mod
 727 |     Err(e) => abort("remove_unused_brs failed: \{e}")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rub_single_func(mod : Module) -> Func {
     |   match mod.code_sec {
     |     Some(CodeSec([func])) => func
 735 |     _ => abort("expected exactly one function")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

32 uncovered line(s) in src/passes/remove_unused_names.mbt:

    | fn remove_unused_names_ir_pass(_mod : Module) -> ModuleTransformer[IRContext] {
    |   ModuleTransformer::new().on_func_evt(fn(_, ctx, func) {
    |     match func {
    |       TFunc(locals, body) =>
    |         match run_remove_unused_names_once(body) {
    |           Ok((next_body, _changed)) =>
    |             if next_body == body {
    |               unchanged()
    |             } else {
    |               change(ctx, Func::t_func(locals, next_body))
    |             }
 13 |           Err(e) => Err(e)
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
 15 |       _ => unchanged()
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn run_remove_unused_names(mod : Module) -> Module {
    |   let pass = remove_unused_names_ir_pass(mod)
    |   match pass.walk_module(IRContext::new(), mod) {
    |     Ok(Some((_, out))) => out
 25 |     Ok(None) => mod
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => abort("remove_unused_names_ir_pass failed: \{e}")
    |   }
    | }
    …

    | fn run_adjust_label_for_removed_scope(
    |   label : LabelIdx,
    |   depth : Int,
    | ) -> LabelIdx {
    |   let curr = run_label_to_int(label)
    |   if curr > depth {
    |     run_label_from_int(curr - 1)
    |   } else {
 50 |     label
    |     ^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn run_walk_tinstruction_with_depth(
    |   transformer : ModuleTransformer[Int],
    |   depth : Int,
    |   instr : TInstr,
    | ) -> TransformerResult[Int, TInstr] {
    |   match instr {
 61 |     TBlock(bt, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let next_body = match transformer.walk_texpr(depth + 1, body) {
    |         Ok(Some((_, out))) => out
    |         Ok(None) => body
    |         Err(e) => return Err(e)
    |       }
    |       if next_body == body {
 68 |         unchanged()
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
 70 |         change(depth, TInstr::block(bt, next_body))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
 73 |     TLoop(bt, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let next_body = match transformer.walk_texpr(depth + 1, body) {
    |         Ok(Some((_, out))) => out
    |         Ok(None) => body
    |         Err(e) => return Err(e)
    |       }
    |       if next_body == body {
 80 |         unchanged()
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
 82 |         change(depth, TInstr::loop_(bt, next_body))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
 85 |     TIf(bt, cond, then_body, else_body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let next_cond = match transformer.walk_tinstruction(depth, cond) {
    |         Ok(Some((_, out))) => out
    |         Ok(None) => cond
    |         Err(e) => return Err(e)
    |       }
 91 |       let next_then = match transformer.walk_texpr(depth + 1, then_body) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(Some((_, out))) => out
    |         Ok(None) => then_body
    |         Err(e) => return Err(e)
    |       }
 96 |       let next_else = match else_body {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(other) =>
 98 |           match transformer.walk_texpr(depth + 1, other) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Ok(Some((_, out))) => Some(out)
    |             Ok(None) => Some(other)
    |             Err(e) => return Err(e)
    |           }
103 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
105 |       let next_instr = TInstr::if_(bt, next_cond, next_then, next_else)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       if next_instr == instr {
107 |         unchanged()
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
109 |         change(depth, next_instr)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
112 |     TTryTable(bt, catches, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let next_catches = match
114 |         transformer.walk_array(
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           depth + 1,
    |           ModuleTransformer::walk_catch,
    |           catches,
    |         ) {
119 |         Ok(Some((_, out))) => out
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(None) => catches
    |         Err(e) => return Err(e)
    |       }
123 |       let next_body = match transformer.walk_texpr(depth + 1, body) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Ok(Some((_, out))) => out
    |         Ok(None) => body
    |         Err(e) => return Err(e)
    |       }
128 |       let next_instr = TInstr::try_table(bt, next_catches, next_body)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       if next_instr == instr {
130 |         unchanged()
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
132 |         change(depth, next_instr)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     _ => transformer.walk_tinstruction_default(depth, instr)
    |   }
    | }
    …

    | fn run_shift_labels_for_removed_scope(body : TExpr) -> Result[TExpr, String] {
    |   let pass = ModuleTransformer::new()
    |     .on_labelidx_evt(fn(_, depth, label) {
    |       let next = run_adjust_label_for_removed_scope(label, depth)
    |       if next == label {
145 |         unchanged()
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         change(depth, next)
    |       }
    |     })
    |     .on_tinstruction_evt(fn(self, depth, instr) {
    |       run_walk_tinstruction_with_depth(self, depth, instr)
    |     })
    |   match pass.walk_texpr(0, body) {
    |     Ok(Some((_, out))) => Ok(out)
155 |     Ok(None) => Ok(body)
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn run_remove_unused_names_once(body : TExpr) -> Result[(TExpr, Bool), String] {
    |   let mut changed = false
    |   let pass = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     let walked = match self.walk_tinstruction_default((), instr) {
    |       Ok(Some((_, out))) => out
    |       Ok(None) => instr
184 |       Err(e) => return Err(e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let rewritten = match walked {
    |       TBlock(bt, TExpr(items)) =>
    |         match items {
    |           [TBlock(child_bt, child_body)] =>
    |             if child_bt == bt {
    |               let shifted = match
    |                 run_shift_labels_for_removed_scope(child_body) {
    |                 Ok(out) => out
194 |                 Err(e) => return Err(e)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |               changed = true
    |               TInstr::block(child_bt, shifted)
    |             } else {
199 |               walked
    |               ^^^^^^ 	<-- UNCOVERED
    |             }
    |           _ => walked
    |         }
    |       TLoop(bt, loop_body) =>
    |         if bt == BlockType::void_() &&
    |           !run_has_branch_to_current_scope(loop_body) {
    |           changed = true
    |           TInstr::block(bt, loop_body)
    |         } else {
    |           walked
    |         }
    |       _ => walked
    |     }
    |     if rewritten == instr {
    |       unchanged()
    |     } else {
    |       change((), rewritten)
    |     }
    |   })
    |   match pass.walk_texpr((), body) {
    |     Ok(Some((_, out))) => Ok((out, changed))
221 |     Ok(None) => Ok((body, changed))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn run_single_func(mod : Module) -> Func {
    |   match mod.code_sec {
    |     Some(CodeSec([func])) => func
230 |     _ => abort("expected exactly one function")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

93 uncovered line(s) in src/passes/remove_unused_types.mbt:

    | fn rut_typeidx_raw(type_idx : TypeIdx) -> Int {
    |   match type_idx {
    |     TypeIdx(i) => i.reinterpret_as_int()
 12 |     RecIdx(i) => i.reinterpret_as_int()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_resolve_type_idx(
    |   type_idx : TypeIdx,
    |   group_start : Int,
    |   total : Int,
    | ) -> Int? {
    |   let idx = match type_idx {
    |     TypeIdx(i) => i.reinterpret_as_int()
 24 |     RecIdx(i) => group_start + i.reinterpret_as_int()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if idx < 0 || idx >= total {
 27 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
    |     Some(idx)
    |   }
    | }
    …

    | fn rut_flatten_types(type_sec : TypeSec) -> RUTFlatTypes {
    |   let TypeSec(recs) = type_sec
    |   let subtypes : Array[SubType] = []
    |   let group_starts : Array[Int] = []
    |   let groups : Array[Array[Int]] = []
    |   let mut next = 0
    |   for rec in recs {
    |     match rec {
    |       SingleRecType(st) => {
    |         subtypes.push(st)
    |         group_starts.push(next)
    |         groups.push([next])
    |         next += 1
    |       }
 48 |       GroupRecType(sts) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let start = next
    |         let group : Array[Int] = []
    |         for st in sts {
 52 |           subtypes.push(st)
    |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           group_starts.push(start)
    |           group.push(next)
    |           next += 1
    |         }
 57 |         groups.push(group)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    |   { subtypes, group_starts, groups }
    | }
    …

    | fn rut_mark_heaptype(roots : Set[Int], ht : HeapType) -> Unit {
    |   match ht {
    |     HeapType(type_idx) => rut_mark_typeidx(roots, type_idx)
 76 |     _ => ()
    |     ^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_mark_module_roots(mod : Module) -> Set[Int] {
    |   let roots : Set[Int] = Set::new()
    |   let walker = ModuleTransformer::new()
    |     .on_typeidx_evt(fn(_, _, tidx) {
    |       rut_mark_typeidx(roots, tidx)
    |       unchanged()
    |     })
    |     .on_heaptype_evt(fn(_, _, ht) {
    |       rut_mark_heaptype(roots, ht)
    |       unchanged()
    |     })
    |   match mod.import_sec {
 93 |     Some(sec) => ignore(walker.walk_importsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(sec) => ignore(walker.walk_funcsec((), sec))
 98 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match mod.table_sec {
101 |     Some(sec) => ignore(walker.walk_tablesec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.mem_sec {
105 |     Some(sec) => ignore(walker.walk_memsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.tag_sec {
109 |     Some(sec) => ignore(walker.walk_tagsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.global_sec {
113 |     Some(sec) => ignore(walker.walk_globalsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.export_sec {
117 |     Some(sec) => ignore(walker.walk_exportsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.start_sec {
121 |     Some(sec) => ignore(walker.walk_startsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.elem_sec {
125 |     Some(sec) => ignore(walker.walk_elemsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.data_cnt_sec {
129 |     Some(sec) => ignore(walker.walk_datacntsec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match mod.code_sec {
    |     Some(sec) => ignore(walker.walk_codesec((), sec))
134 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match mod.data_sec {
137 |     Some(sec) => ignore(walker.walk_datasec((), sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   roots
    | }
    …

    | fn rut_collect_valtype_refs(
    |   out : Array[Int],
    |   vt : ValType,
    |   group_start : Int,
    |   total : Int,
    | ) -> Unit {
    |   match vt {
    |     RefTypeValType(rt) =>
    |       match rt {
    |         HeapTypeRefType(_, ht) =>
    |           match ht {
    |             HeapType(type_idx) =>
    |               match rut_resolve_type_idx(type_idx, group_start, total) {
    |                 Some(idx) => out.push(idx)
158 |                 None => ()
    |                 ^^^^^^^^^^ 	<-- UNCOVERED
    |               }
160 |             _ => ()
    |             ^^^^^^^ 	<-- UNCOVERED
    |           }
162 |         _ => ()
    |         ^^^^^^^ 	<-- UNCOVERED
    |       }
164 |     _ => ()
    |     ^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_collect_storage_refs(
    |   out : Array[Int],
    |   st : StorageType,
    |   group_start : Int,
    |   total : Int,
    | ) -> Unit {
    |   match st {
    |     ValTypeStorageType(vt) =>
    |       rut_collect_valtype_refs(out, vt, group_start, total)
178 |     _ => ()
    |     ^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_collect_subtype_refs(
    |   subtype : SubType,
    |   group_start : Int,
    |   total : Int,
    | ) -> Array[Int] {
    |   let out : Array[Int] = []
    |   for super_idx in subtype.super_types() {
190 |     match rut_resolve_type_idx(super_idx, group_start, total) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(idx) => out.push(idx)
    |       None => ()
    |     }
    |   }
    |   match subtype.get_comptype() {
    |     FuncCompType(params, results) => {
    |       for p in params {
198 |         rut_collect_valtype_refs(out, p, group_start, total)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       for r in results {
201 |         rut_collect_valtype_refs(out, r, group_start, total)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     StructCompType(fields) =>
    |       for field in fields {
    |         let FieldType(st, _) = field
    |         rut_collect_storage_refs(out, st, group_start, total)
    |       }
209 |     ArrayCompType(field) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let FieldType(st, _) = field
211 |       rut_collect_storage_refs(out, st, group_start, total)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   out
    | }
    …

    | fn rut_collect_used_types(flat : RUTFlatTypes, roots : Set[Int]) -> Set[Int] {
    |   let total = flat.subtypes.length()
    |   let used : Set[Int] = Set::new()
    |   let stack : Array[Int] = []
    |   for root in roots {
    |     if root >= 0 && root < total {
    |       stack.push(root)
    |     }
    |   }
    |   while !stack.is_empty() {
    |     let curr = stack.pop().unwrap()
    |     if used.contains(curr) {
230 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     used.add(curr)
    |     let refs = rut_collect_subtype_refs(
    |       flat.subtypes[curr],
    |       flat.group_starts[curr],
    |       total,
    |     )
    |     for ref_ in refs {
    |       if !used.contains(ref_) {
240 |         stack.push(ref_)
    |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    |   used
    | }
    …

    | fn rut_rewrite_typeidx(
    |   type_idx : TypeIdx,
    |   group_start : Int,
    |   total : Int,
    |   local_pos_by_old : Map[Int, Int],
    |   old_to_new : Map[Int, TypeIdx],
    | ) -> Result[TypeIdx, String] {
255 |   match rut_resolve_type_idx(type_idx, group_start, total) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(abs_idx) =>
257 |       match local_pos_by_old.get(abs_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(pos) => Ok(TypeIdx::rec(pos.reinterpret_as_uint()))
    |         None =>
260 |           match old_to_new.get(abs_idx) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(next_idx) => Ok(next_idx)
    |             None => Err("remove_unused_types: missing remap")
    |           }
    |       }
265 |     None => Ok(type_idx)
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_rewrite_heaptype(
    |   ht : HeapType,
    |   group_start : Int,
    |   total : Int,
    |   local_pos_by_old : Map[Int, Int],
    |   old_to_new : Map[Int, TypeIdx],
    | ) -> Result[HeapType, String] {
277 |   match ht {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     HeapType(type_idx) =>
279 |       match
    |       ^^^^^ 	<-- UNCOVERED
    |         rut_rewrite_typeidx(
    |           type_idx, group_start, total, local_pos_by_old, old_to_new,
    |         ) {
283 |         Ok(next_idx) => Ok(HeapType::new(next_idx))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Err(e) => Err(e)
    |       }
286 |     _ => Ok(ht)
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_rewrite_reftype(
    |   rt : RefType,
    |   group_start : Int,
    |   total : Int,
    |   local_pos_by_old : Map[Int, Int],
    |   old_to_new : Map[Int, TypeIdx],
    | ) -> Result[RefType, String] {
298 |   match rt {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     HeapTypeRefType(nullable, ht) =>
300 |       match
    |       ^^^^^ 	<-- UNCOVERED
    |         rut_rewrite_heaptype(
    |           ht, group_start, total, local_pos_by_old, old_to_new,
    |         ) {
304 |         Ok(next_ht) => Ok(RefType::new(nullable, next_ht))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Err(e) => Err(e)
    |       }
307 |     _ => Ok(rt)
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_rewrite_valtype(
    |   vt : ValType,
    |   group_start : Int,
    |   total : Int,
    |   local_pos_by_old : Map[Int, Int],
    |   old_to_new : Map[Int, TypeIdx],
    | ) -> Result[ValType, String] {
319 |   match vt {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     RefTypeValType(rt) =>
321 |       match
    |       ^^^^^ 	<-- UNCOVERED
    |         rut_rewrite_reftype(
    |           rt, group_start, total, local_pos_by_old, old_to_new,
    |         ) {
325 |         Ok(next_rt) => Ok(ValType::ref_type(next_rt))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Err(e) => Err(e)
    |       }
328 |     _ => Ok(vt)
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_rewrite_storage(
    |   st : StorageType,
    |   group_start : Int,
    |   total : Int,
    |   local_pos_by_old : Map[Int, Int],
    |   old_to_new : Map[Int, TypeIdx],
    | ) -> Result[StorageType, String] {
340 |   match st {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     ValTypeStorageType(vt) =>
342 |       match
    |       ^^^^^ 	<-- UNCOVERED
    |         rut_rewrite_valtype(
    |           vt, group_start, total, local_pos_by_old, old_to_new,
    |         ) {
346 |         Ok(next_vt) => Ok(StorageType::val_type(next_vt))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Err(e) => Err(e)
    |       }
349 |     _ => Ok(st)
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rut_rewrite_subtype(
    |   subtype : SubType,
    |   group_start : Int,
    |   total : Int,
    |   local_pos_by_old : Map[Int, Int],
    |   old_to_new : Map[Int, TypeIdx],
    | ) -> Result[SubType, String] {
    |   match subtype {
362 |     SubType(is_final, supers, ct) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let next_supers : Array[TypeIdx] = []
    |       for super_idx in supers {
365 |         match
    |         ^^^^^ 	<-- UNCOVERED
    |           rut_rewrite_typeidx(
    |             super_idx, group_start, total, local_pos_by_old, old_to_new,
    |           ) {
369 |           Ok(next_idx) => next_supers.push(next_idx)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Err(e) => return Err(e)
    |         }
    |       }
373 |       let next_ct = match ct {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         FuncCompType(params, results) => {
    |           let next_params : Array[ValType] = []
    |           let next_results : Array[ValType] = []
    |           for p in params {
378 |             match
    |             ^^^^^ 	<-- UNCOVERED
    |               rut_rewrite_valtype(
    |                 p, group_start, total, local_pos_by_old, old_to_new,
    |               ) {
382 |               Ok(v) => next_params.push(v)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Err(e) => return Err(e)
    |             }
    |           }
    |           for r in results {
387 |             match
    |             ^^^^^ 	<-- UNCOVERED
    |               rut_rewrite_valtype(
    |                 r, group_start, total, local_pos_by_old, old_to_new,
    |               ) {
391 |               Ok(v) => next_results.push(v)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Err(e) => return Err(e)
    |             }
    |           }
395 |           CompType::func(next_params, next_results)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
397 |         StructCompType(fields) => {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let next_fields : Array[FieldType] = []
    |           for field in fields {
400 |             let FieldType(storage, mut_) = field
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             match
402 |               rut_rewrite_storage(
    |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 storage, group_start, total, local_pos_by_old, old_to_new,
    |               ) {
    |               Ok(next_storage) =>
406 |                 next_fields.push(FieldType::new(next_storage, mut_))
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Err(e) => return Err(e)
    |             }
    |           }
410 |           CompType::struct_(next_fields)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
412 |         ArrayCompType(field) => {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let FieldType(storage, mut_) = field
    |           let next_storage = match
415 |             rut_rewrite_storage(
    |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               storage, group_start, total, local_pos_by_old, old_to_new,
    |             ) {
418 |             Ok(v) => v
    |             ^^^^^^^^^^ 	<-- UNCOVERED
    |             Err(e) => return Err(e)
    |           }
421 |           CompType::array(FieldType::new(next_storage, mut_))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
424 |       Ok(SubType::new(is_final, next_supers, next_ct))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     CompTypeSubType(ct) => {
    |       let next_ct = match ct {
    |         FuncCompType(params, results) => {
    |           let next_params : Array[ValType] = []
    |           let next_results : Array[ValType] = []
    |           for p in params {
432 |             match
    |             ^^^^^ 	<-- UNCOVERED
    |               rut_rewrite_valtype(
    |                 p, group_start, total, local_pos_by_old, old_to_new,
    |               ) {
436 |               Ok(v) => next_params.push(v)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Err(e) => return Err(e)
    |             }
    |           }
    |           for r in results {
441 |             match
    |             ^^^^^ 	<-- UNCOVERED
    |               rut_rewrite_valtype(
    |                 r, group_start, total, local_pos_by_old, old_to_new,
    |               ) {
445 |               Ok(v) => next_results.push(v)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Err(e) => return Err(e)
    |             }
    |           }
    |           CompType::func(next_params, next_results)
    |         }
    |         StructCompType(fields) => {
    |           let next_fields : Array[FieldType] = []
    |           for field in fields {
454 |             let FieldType(storage, mut_) = field
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             match
456 |               rut_rewrite_storage(
    |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 storage, group_start, total, local_pos_by_old, old_to_new,
    |               ) {
    |               Ok(next_storage) =>
460 |                 next_fields.push(FieldType::new(next_storage, mut_))
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Err(e) => return Err(e)
    |             }
    |           }
    |           CompType::struct_(next_fields)
    |         }
466 |         ArrayCompType(field) => {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let FieldType(storage, mut_) = field
    |           let next_storage = match
469 |             rut_rewrite_storage(
    |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               storage, group_start, total, local_pos_by_old, old_to_new,
    |             ) {
472 |             Ok(v) => v
    |             ^^^^^^^^^^ 	<-- UNCOVERED
    |             Err(e) => return Err(e)
    |           }
475 |           CompType::array(FieldType::new(next_storage, mut_))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       Ok(SubType::comp_type(next_ct))
    |     }
    |   }
    | }
    …

    | fn remove_unused_types(mod : Module) -> Result[Module, String] {
    |   let type_sec = match mod.type_sec {
    |     Some(type_sec) => type_sec
498 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let flat = rut_flatten_types(type_sec)
    |   if flat.subtypes.is_empty() || !rut_has_gc_types(flat) {
502 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   let roots = rut_mark_module_roots(mod)
    |   let used = rut_collect_used_types(flat, roots)
    |   if used.length() == flat.subtypes.length() {
    |     return Ok(mod)
    |   }
    | 
    |   let old_to_new : Map[Int, TypeIdx] = Map::new()
    |   let mut next_idx = 0
    |   let kept_groups : Array[Array[Int]] = []
    |   for group in flat.groups {
    |     let kept : Array[Int] = []
    |     for old_idx in group {
    |       if used.contains(old_idx) {
    |         old_to_new[old_idx] = TypeIdx::new(next_idx.reinterpret_as_uint())
    |         next_idx += 1
    |         kept.push(old_idx)
    |       }
    |     }
    |     if !kept.is_empty() {
    |       kept_groups.push(kept)
    |     }
    |   }
    | 
    |   let new_recs : Array[RecType] = []
    |   for kept in kept_groups {
    |     let local_pos_by_old : Map[Int, Int] = Map::new()
    |     for i = 0; i < kept.length(); i = i + 1 {
    |       local_pos_by_old[kept[i]] = i
    |     }
    |     let next_subtypes : Array[SubType] = []
    |     for old_idx in kept {
    |       match
    |         rut_rewrite_subtype(
    |           flat.subtypes[old_idx],
    |           flat.group_starts[old_idx],
    |           flat.subtypes.length(),
    |           local_pos_by_old,
    |           old_to_new,
    |         ) {
    |         Ok(next_subtype) => next_subtypes.push(next_subtype)
545 |         Err(e) => return Err(e)
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     if next_subtypes.length() == 1 {
    |       new_recs.push(RecType::new(next_subtypes[0]))
    |     } else {
551 |       new_recs.push(RecType::group(next_subtypes))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   let new_type_sec = TypeSec::new(new_recs)
    |   let remapper = ModuleTransformer::new()
    |     .on_typeidx_evt(fn(_, _, tidx : TypeIdx) {
    |       match tidx {
    |         TypeIdx(i) => {
    |           let raw = i.reinterpret_as_int()
    |           match old_to_new.get(raw) {
    |             Some(next) => change((), next)
563 |             None => unchanged()
    |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
566 |         RecIdx(_) => unchanged()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     })
    |     .on_heaptype_evt(fn(_, _, ht : HeapType) {
570 |       match ht {
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |         HeapType(type_idx) => {
    |           let next_type = match type_idx {
    |             TypeIdx(i) => {
    |               let raw = i.reinterpret_as_int()
    |               match old_to_new.get(raw) {
    |                 Some(next) => next
    |                 None => type_idx
    |               }
    |             }
580 |             RecIdx(_) => type_idx
    |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
582 |           change((), HeapType::new(next_type))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
584 |         _ => unchanged()
    |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     })
    |     .on_typesec_evt(fn(_, _, _) { change((), new_type_sec) })
    | 
    |   match remapper.walk_module((), mod) {
    |     Ok(Some((_, out))) => Ok(out)
591 |     Ok(None) => Ok(mod.with_type_sec(new_type_sec))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn run_remove_unused_types(mod : Module) -> Module {
    |   match remove_unused_types(mod) {
    |     Ok(out) => out
600 |     Err(_) => mod
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

21 uncovered line(s) in src/passes/reorder_functions.mbt:

    | fn rf_count_imported_funcs(mod : Module) -> Int {
    |   let mut n = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
    |       for import_ in imports {
    |         match import_ {
    |           Import(_, _, FuncExternType(_)) => n += 1
  9 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
 12 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   n
    | }
    …

    | fn rf_defined_index(imported : Int, defined_count : Int, idx : FuncIdx) -> Int? {
    |   let abs = rf_funcidx_to_abs(idx)
    |   let def = abs - imported
    |   if def >= 0 && def < defined_count {
    |     Some(def)
    |   } else {
 35 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rf_bump_defined_count(
    |   counts : Array[Int],
    |   imported : Int,
    |   idx : FuncIdx,
    | ) -> Unit {
    |   match rf_defined_index(imported, counts.length(), idx) {
    |     Some(def_idx) => counts[def_idx] = counts[def_idx] + 1
 47 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rf_scan_call_counts(
    |   funcs : Array[Func],
    |   imported : Int,
    |   counts : Array[Int],
    | ) -> Result[Unit, String] {
    |   let tscanner = ModuleTransformer::new().on_tinstruction_evt(fn(
    |     self,
    |     _,
    |     instr,
    |   ) {
    |     match instr {
    |       TCall(target, _) => rf_bump_defined_count(counts, imported, target)
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), instr)
    |   })
    |   let scanner = ModuleTransformer::new().on_instruction_evt(fn(self, _, instr) {
 69 |     match instr {
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Call(target) => rf_bump_defined_count(counts, imported, target)
    |       _ => ()
    |     }
 73 |     self.walk_instruction_default((), instr)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    |   for func in funcs {
    |     match func {
    |       TFunc(_, body) =>
    |         match tscanner.walk_texpr((), body) {
    |           Ok(_) => ()
 80 |           Err(e) => return Err(e)
    |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       Func(_, body) =>
 83 |         match scanner.walk_expr((), body) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Ok(_) => ()
    |           Err(e) => return Err(e)
    |         }
    |     }
    |   }
    |   Ok(())
    | }
    …

    | fn rf_remap_func_indices(
    |   mod : Module,
    |   remap : Map[FuncIdx, FuncIdx],
    | ) -> Result[Module, String] {
    |   let transformer = ModuleTransformer::new().on_funcidx_evt(fn(_, _, idx) {
    |     match remap.get(idx) {
    |       Some(new_idx) =>
    |         if new_idx == idx {
    |           unchanged()
    |         } else {
    |           change((), new_idx)
    |         }
105 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   match transformer.walk_module((), mod) {
    |     Ok(Some((_, out))) => Ok(out)
110 |     Ok(None) => Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn reorder_functions(mod : Module) -> Result[Module, String] {
    |   let imported = rf_count_imported_funcs(mod)
    |   let type_idxs = match mod.func_sec {
    |     Some(FuncSec(items)) => items
120 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let funcs = match mod.code_sec {
    |     Some(CodeSec(items)) => items
124 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if type_idxs.length() != funcs.length() {
127 |     return Err("reorder_functions: func_sec/code_sec length mismatch")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if funcs.length() <= 1 {
130 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let counts = Array::make(funcs.length(), 0)
    |   match rf_scan_call_counts(funcs, imported, counts) {
    |     Ok(_) => ()
135 |     Err(e) => return Err(e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match mod.start_sec {
    |     Some(StartSec(idx)) => rf_bump_defined_count(counts, imported, idx)
139 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match mod.export_sec {
    |     Some(ExportSec(exports)) =>
    |       for export_ in exports {
    |         match export_ {
    |           Export(_, FuncExternIdx(idx)) =>
    |             rf_bump_defined_count(counts, imported, idx)
147 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.elem_sec {
    |     Some(ElemSec(elems)) =>
    |       for elem in elems {
    |         match elem {
    |           Elem(_, FuncsElemKind(funcs)) =>
    |             for idx in funcs {
    |               rf_bump_defined_count(counts, imported, idx)
    |             }
160 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   let order : Array[Int] = []
    |   for i = 0; i < funcs.length(); i = i + 1 {
    |     order.push(i)
    |   }
    |   order.sort_by(fn(a, b) {
    |     let ca = counts[a]
    |     let cb = counts[b]
    |     if ca == cb {
    |       b - a
    |     } else {
    |       cb - ca
    |     }
    |   })
    |   let mut changed = false
    |   for i = 0; i < order.length(); i = i + 1 {
    |     if order[i] != i {
    |       changed = true
    |       break
    |     }
    |   }
    |   if !changed {
186 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let old_def_to_new_def = Array::make(funcs.length(), 0)
    |   let reordered_types : Array[TypeIdx] = []
    |   let reordered_funcs : Array[Func] = []
    |   for new_def = 0; new_def < order.length(); new_def = new_def + 1 {
    |     let old_def = order[new_def]
    |     old_def_to_new_def[old_def] = new_def
    |     reordered_types.push(type_idxs[old_def])
    |     reordered_funcs.push(funcs[old_def])
    |   }
    |   let remap : Map[FuncIdx, FuncIdx] = Map::new()
    |   for abs = 0; abs < imported; abs = abs + 1 {
    |     let idx = rf_funcidx_from_abs(abs)
    |     remap[idx] = idx
    |   }
    |   for old_def = 0; old_def < funcs.length(); old_def = old_def + 1 {
    |     let old_abs = imported + old_def
    |     let new_abs = imported + old_def_to_new_def[old_def]
    |     remap[rf_funcidx_from_abs(old_abs)] = rf_funcidx_from_abs(new_abs)
    |   }
    |   let reordered_mod = mod
    |     .with_func_sec(FuncSec::new(reordered_types))
    |     .with_code_sec(CodeSec::new(reordered_funcs))
    |   rf_remap_func_indices(reordered_mod, remap)
    | }
    …

    | fn rf_run_reorder_functions(mod : Module) -> Module {
    |   match reorder_functions(mod) {
    |     Ok(out) => out
224 |     Err(e) => abort("reorder_functions failed: \{e}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rf_run_reorder_functions_by_name(mod : Module) -> Module {
    |   match reorder_functions_by_name(mod) {
    |     Ok(out) => out
232 |     Err(e) => abort("reorder_functions_by_name failed: \{e}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

27 uncovered line(s) in src/passes/reorder_globals.mbt:

    | fn rg_count_imported_globals(mod : Module) -> Int {
    |   let mut n = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
    |       for import_ in imports {
    |         match import_ {
    |           Import(_, _, GlobalExternType(_)) => n += 1
  9 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
 12 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   n
    | }
    …

    | fn rg_defined_index(
    |   imported_globals : Int,
    |   defined_count : Int,
    |   idx : GlobalIdx,
    | ) -> Int? {
    |   let abs = rg_globalidx_to_int(idx)
    |   let def = abs - imported_globals
    |   if def >= 0 && def < defined_count {
    |     Some(def)
    |   } else {
 39 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rg_bump_count(
    |   counts : Array[Double],
    |   imported_globals : Int,
    |   idx : GlobalIdx,
    | ) -> Unit {
    |   match rg_defined_index(imported_globals, counts.length(), idx) {
    |     Some(def_idx) => counts[def_idx] = counts[def_idx] + 1.0
 51 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rg_collect_use_counts(
    |   mod : Module,
    |   imported_globals : Int,
    |   defined_count : Int,
    | ) -> Result[Array[Double], String] {
    |   let counts = Array::make(defined_count, 0.0)
    |   let walker = ModuleTransformer::new()
    |     .on_tinstruction_evt(fn(self, _, instr) {
    |       match instr {
    |         TGlobalGet(idx) => rg_bump_count(counts, imported_globals, idx)
    |         TGlobalSet(idx, _) => rg_bump_count(counts, imported_globals, idx)
    |         _ => ()
    |       }
    |       self.walk_tinstruction_default((), instr)
    |     })
    |     .on_instruction_evt(fn(self, _, instr) {
    |       match instr {
    |         GlobalGet(idx) => rg_bump_count(counts, imported_globals, idx)
 74 |         GlobalSet(idx) => rg_bump_count(counts, imported_globals, idx)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ => ()
    |       }
    |       self.walk_instruction_default((), instr)
    |     })
    |   match walker.walk_module((), mod) {
    |     Ok(_) => Ok(counts)
 81 |     Err(e) => Err(e)
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rg_collect_dependencies(
    |   globals : Array[Global],
    |   imported_globals : Int,
    | ) -> Result[Array[Array[Int]], String] {
    |   let dep_sets : Array[Set[Int]] = []
    |   for _ in globals {
    |     dep_sets.push(Set::new())
    |   }
    |   for i = 0; i < globals.length(); i = i + 1 {
    |     let Global(_, init) = globals[i]
    |     let walker = ModuleTransformer::new().on_instruction_evt(fn(
    |       self,
    |       _,
    |       instr,
    |     ) {
    |       match instr {
    |         GlobalGet(idx) =>
    |           match rg_defined_index(imported_globals, globals.length(), idx) {
    |             Some(dep_idx) => dep_sets[dep_idx].add(i)
105 |             None => ()
    |             ^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         _ => ()
    |       }
    |       self.walk_instruction_default((), instr)
    |     })
    |     match walker.walk_expr((), init) {
    |       Ok(_) => ()
113 |       Err(e) => return Err(e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   let deps : Array[Array[Int]] = []
    |   for dep_set in dep_sets {
    |     let items : Array[Int] = []
    |     for item in dep_set {
    |       items.push(item)
    |     }
    |     items.sort()
    |     deps.push(items)
    |   }
    |   Ok(deps)
    | }
    …

    | fn rg_topological_sort(deps : Array[Array[Int]]) -> Array[Int] {
    |   let n = deps.length()
    |   let indegree = Array::make(n, 0)
    |   for src = 0; src < n; src = src + 1 {
    |     for dst in deps[src] {
    |       indegree[dst] = indegree[dst] + 1
    |     }
    |   }
    |   let queue : Array[Int] = []
    |   for i = 0; i < n; i = i + 1 {
    |     if indegree[i] == 0 {
    |       queue.push(i)
    |     }
    |   }
    |   let out : Array[Int] = []
    |   let mut qi = 0
    |   while qi < queue.length() {
    |     let curr = queue[qi]
    |     qi = qi + 1
    |     out.push(curr)
    |     for dep in deps[curr] {
    |       indegree[dep] = indegree[dep] - 1
    |       if indegree[dep] == 0 {
    |         queue.push(dep)
    |       }
    |     }
    |   }
    |   if out.length() == n {
    |     return out
    |   }
159 |   let seen = Array::make(n, false)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for idx in out {
161 |     seen[idx] = true
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
163 |   for i = 0; i < n; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     if !seen[i] {
    |       out.push(i)
    |     }
    |   }
    |   out
    | }
    …

    | fn rg_min_topological_sort(
    |   deps : Array[Array[Int]],
    |   prefer_before : (Int, Int) -> Bool,
    | ) -> Array[Int] {
    |   let n = deps.length()
    |   let indegree = Array::make(n, 0)
    |   for src = 0; src < n; src = src + 1 {
    |     for dst in deps[src] {
    |       indegree[dst] = indegree[dst] + 1
    |     }
    |   }
    |   let emitted = Array::make(n, false)
    |   let available : Array[Int] = []
    |   for i = 0; i < n; i = i + 1 {
    |     if indegree[i] == 0 {
    |       available.push(i)
    |     }
    |   }
    |   let out : Array[Int] = []
    |   while out.length() < n {
    |     if available.is_empty() {
193 |       for i = 0; i < n; i = i + 1 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         if !emitted[i] {
    |           available.push(i)
    |           break
    |         }
    |       }
    |     }
    |     let mut best_pos = 0
    |     let mut best = available[0]
    |     for pos = 1; pos < available.length(); pos = pos + 1 {
    |       let candidate = available[pos]
    |       if prefer_before(candidate, best) {
    |         best = candidate
    |         best_pos = pos
    |       }
    |     }
    |     let last = available.pop().unwrap()
    |     if best_pos < available.length() {
    |       available[best_pos] = last
    |     }
    |     if emitted[best] {
214 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     emitted[best] = true
    |     out.push(best)
    |     for dep in deps[best] {
    |       indegree[dep] = indegree[dep] - 1
    |       if indegree[dep] == 0 && !emitted[dep] {
    |         available.push(dep)
    |       }
    |     }
    |   }
    |   out
    | }
    …

    | fn rg_uleb_bytes(v : Int) -> Int {
243 |   let mut bytes = 1
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut x = v.to_uint64()
    |   while x >= 128UL {
246 |     bytes += 1
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |     x = x >> 7
    |   }
    |   bytes
    | }
    …

    | fn rg_compute_size(
    |   indices : Array[Int],
    |   counts : Array[Double],
    |   always : Bool,
    | ) -> Double {
    |   if always {
    |     let mut total = 0.0
    |     for i = 0; i < indices.length(); i = i + 1 {
    |       total = total + counts[indices[i]] * (1.0 + i.to_double() / 128.0)
    |     }
    |     return total
    |   }
    |   let mut total = 0.0
266 |   for i = 0; i < indices.length(); i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     total = total + counts[indices[i]] * rg_uleb_bytes(i).to_double()
    |   }
    |   total
    | }
    …

    | fn rg_remap_global_indices(
    |   mod : Module,
    |   remap : Map[GlobalIdx, GlobalIdx],
    | ) -> Result[Module, String] {
    |   if remap.is_empty() {
278 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let pass = ModuleTransformer::new().on_globalidx_evt(fn(_, _, idx) {
    |     match remap.get(idx) {
    |       Some(next) => if next == idx { unchanged() } else { change((), next) }
283 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   match pass.walk_module((), mod) {
    |     Ok(Some((_, out))) => Ok(out)
288 |     Ok(None) => Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn reorder_globals_impl(mod : Module, always : Bool) -> Result[Module, String] {
    |   let globals = match mod.global_sec {
    |     Some(GlobalSec(items)) => items
297 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if globals.length() <= 1 {
300 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if globals.length() < 128 && !always {
    |     return Ok(mod)
    |   }
    |   let imported_globals = rg_count_imported_globals(mod)
    |   let counts = match
    |     rg_collect_use_counts(mod, imported_globals, globals.length()) {
    |     Ok(out) => out
309 |     Err(e) => return Err(e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let deps = match rg_collect_dependencies(globals, imported_globals) {
    |     Ok(out) => out
313 |     Err(e) => return Err(e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let options : Array[(Array[Int], Double)] = []
    |   let add_option = fn(custom_counts : Array[Double]) {
    |     let order = rg_do_sort(custom_counts, deps)
    |     let size = rg_compute_size(order, counts, always)
    |     options.push((order, size))
    |   }
    |   add_option(Array::make(globals.length(), 0.0))
    |   add_option(counts)
    |   let topo = rg_topological_sort(deps)
    |   let sum_counts = Array::make(globals.length(), 0.0)
    |   let exp_counts = Array::make(globals.length(), 0.0)
    |   let exp_factor = 0.095
    |   for rev = topo.length() - 1; rev >= 0; rev = rev - 1 {
    |     let g = topo[rev]
    |     sum_counts[g] = counts[g]
    |     exp_counts[g] = counts[g]
    |     for dep in deps[g] {
    |       sum_counts[g] = sum_counts[g] + sum_counts[dep]
    |       exp_counts[g] = exp_counts[g] + exp_factor * exp_counts[dep]
    |     }
    |     if rev == 0 {
    |       break
    |     }
    |   }
    |   add_option(sum_counts)
    |   add_option(exp_counts)
    |   if options.is_empty() {
342 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let mut best_order = options[0].0
    |   let mut best_size = options[0].1
    |   for i = 1; i < options.length(); i = i + 1 {
    |     let candidate = options[i]
    |     if candidate.1 < best_size {
    |       best_order = candidate.0
    |       best_size = candidate.1
    |     }
    |   }
    |   let mut changed = false
    |   for i = 0; i < best_order.length(); i = i + 1 {
    |     if best_order[i] != i {
    |       changed = true
    |       break
    |     }
    |   }
    |   if !changed {
361 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let reordered_globals : Array[Global] = []
    |   let old_to_new = Array::make(globals.length(), 0)
    |   for new_idx = 0; new_idx < best_order.length(); new_idx = new_idx + 1 {
    |     let old_idx = best_order[new_idx]
    |     reordered_globals.push(globals[old_idx])
    |     old_to_new[old_idx] = new_idx
    |   }
    |   let remap : Map[GlobalIdx, GlobalIdx] = Map::new()
    |   for i = 0; i < imported_globals; i = i + 1 {
    |     let idx = rg_globalidx_from_int(i)
    |     remap[idx] = idx
    |   }
    |   for old_idx = 0; old_idx < globals.length(); old_idx = old_idx + 1 {
    |     let old_abs = imported_globals + old_idx
    |     let new_abs = imported_globals + old_to_new[old_idx]
    |     remap[rg_globalidx_from_int(old_abs)] = rg_globalidx_from_int(new_abs)
    |   }
    |   let reordered_mod = mod.with_global_sec(GlobalSec::new(reordered_globals))
    |   rg_remap_global_indices(reordered_mod, remap)
    | }
    …

    | fn reorder_globals_ir_pass(
    |   _mod : Module,
    |   always : Bool,
    | ) -> ModuleTransformer[IRContext] {
    |   ModuleTransformer::new().on_module_evt(fn(_, ctx, mod) {
    |     match reorder_globals_impl(mod, always) {
    |       Ok(next) => if next == mod { unchanged() } else { change(ctx, next) }
392 |       Err(e) => Err(e)
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn rg_run_reorder_globals(mod : Module, always : Bool) -> Module {
    |   let pass = reorder_globals_ir_pass(mod, always)
    |   match pass.walk_module(IRContext::new(), mod) {
    |     Ok(Some((_, out))) => out
402 |     Ok(None) => mod
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => abort("reorder_globals pass failed: \{e}")
    |   }
    | }
    …

14 uncovered line(s) in src/passes/reorder_locals.mbt:

    | fn rl_collect_param_counts(mod : Module) -> Array[Int] {
    |   let out : Array[Int] = []
    |   let env = Env::new().with_module(mod)
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for tidx in type_idxs {
    |         match env.resolve_functype(tidx) {
    |           Some(FuncType(params, _)) => out.push(params.length())
 21 |           None => out.push(0)
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   out
    | }
    …

    | fn rl_scan_local_uses(
    |   body : TExpr,
    |   counts : Array[Int],
    |   first_uses : Array[Int],
    | ) -> Result[Unit, String] {
    |   let first_use_index = Ref::new(1)
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     let bump = fn(idx : LocalIdx) {
    |       let raw = rl_localidx_to_int(idx)
    |       if raw >= 0 && raw < counts.length() {
    |         counts[raw] = counts[raw] + 1
    |         if first_uses[raw] == 0 {
    |           first_uses[raw] = first_use_index.val
    |           first_use_index.update(fn(i) { i + 1 })
    |         }
    |       }
    |     }
    |     match instr {
    |       TLocalGet(idx) => bump(idx)
    |       TLocalSet(idx, _) => bump(idx)
 50 |       TLocalTee(idx, _) => bump(idx)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), instr)
    |   })
    |   match walker.walk_texpr((), body) {
    |     Ok(_) => Ok(())
 57 |     Err(e) => Err(e)
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn rl_remap_local_indices(
    |   body : TExpr,
    |   old_to_new : Array[Int],
    | ) -> Result[TExpr, String] {
    |   let rewriter = ModuleTransformer::new().on_localidx_evt(fn(_, _, idx) {
    |     let raw = rl_localidx_to_int(idx)
    |     if raw < 0 || raw >= old_to_new.length() {
 69 |       return unchanged()
    |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let mapped = old_to_new[raw]
    |     if mapped == raw || mapped < 0 {
    |       unchanged()
    |     } else {
    |       change((), rl_localidx_from_int(mapped))
    |     }
    |   })
    |   match rewriter.walk_texpr((), body) {
    |     Ok(Some((_, out))) => Ok(out)
 80 |     Ok(None) => Ok(body)
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => Err(e)
    |   }
    | }
    …

    | fn rl_reorder_function(func : Func, param_count : Int) -> (Func, Bool) {
    |   match func {
    |     TFunc(locals, body) => {
    |       if locals.is_empty() {
 90 |         return (func, false)
    |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let num = param_count + locals.length()
    |       let counts = Array::make(num, 0)
    |       let first_uses = Array::make(num, 0)
    |       match rl_scan_local_uses(body, counts, first_uses) {
    |         Ok(_) => ()
 97 |         Err(_) => return (func, false)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let new_to_old : Array[Int] = []
    |       for i = 0; i < num; i = i + 1 {
    |         new_to_old.push(i)
    |       }
    |       new_to_old.sort_by(fn(a, b) {
    |         let a_is_param = a < param_count
    |         let b_is_param = b < param_count
    |         if a_is_param && !b_is_param {
    |           -1
    |         } else if b_is_param && !a_is_param {
109 |           1
    |           ^ 	<-- UNCOVERED
    |         } else if a_is_param && b_is_param {
    |           a - b
    |         } else {
    |           let ca = counts[a]
    |           let cb = counts[b]
    |           if ca == cb {
    |             if ca == 0 {
117 |               a - b
    |               ^^^^^ 	<-- UNCOVERED
    |             } else {
    |               first_uses[a] - first_uses[b]
    |             }
    |           } else {
    |             cb - ca
    |           }
    |         }
    |       })
    |       for i = 0; i < param_count && i < new_to_old.length(); i = i + 1 {
    |         new_to_old[i] = i
    |       }
    |       let kept_new_to_old : Array[Int] = []
    |       for i = 0; i < param_count; i = i + 1 {
    |         kept_new_to_old.push(i)
    |       }
    |       let reordered_locals : Array[ValType] = []
    |       let mut i = param_count
    |       while i < new_to_old.length() {
    |         let old_idx = new_to_old[i]
    |         if counts[old_idx] > 0 {
    |           kept_new_to_old.push(old_idx)
    |           reordered_locals.push(locals[old_idx - param_count])
    |         } else {
    |           break
    |         }
    |         i = i + 1
    |       }
    |       let old_to_new = Array::make(num, -1)
    |       for i = 0; i < kept_new_to_old.length(); i = i + 1 {
    |         if i < param_count {
    |           old_to_new[i] = i
    |         } else {
    |           old_to_new[kept_new_to_old[i]] = i
    |         }
    |       }
    |       let next_body = match rl_remap_local_indices(body, old_to_new) {
    |         Ok(out) => out
155 |         Err(_) => body
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let next_func = Func::t_func(reordered_locals, next_body)
    |       if next_func == func {
159 |         (func, false)
    |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         (next_func, true)
    |       }
    |     }
164 |     _ => (func, false)
    |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn reorder_locals_ir_pass(mod : Module) -> ModuleTransformer[IRContext] {
    |   let param_counts = rl_collect_param_counts(mod)
    |   let next_def_idx = Ref::new(0)
    |   ModuleTransformer::new().on_func_evt(fn(_, ctx, func) {
    |     let def_idx = next_def_idx.val
    |     next_def_idx.update(fn(i) { i + 1 })
    |     let param_count = param_counts.get(def_idx).unwrap_or(0)
    |     let (next_func, changed) = rl_reorder_function(func, param_count)
    |     if changed {
    |       change(ctx, next_func)
    |     } else {
180 |       unchanged()
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn run_reorder_locals(mod : Module) -> Module {
    |   let pass = reorder_locals_ir_pass(mod)
    |   match pass.walk_module(IRContext::new(), mod) {
    |     Ok(Some((_, out))) => out
190 |     Ok(None) => mod
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => abort("reorder_locals_ir_pass failed: \{e}")
    |   }
    | }
    …

110 uncovered line(s) in src/passes/reorder_types.mbt:

     | fn rt_resolve_type_idx(
     |   type_idx : TypeIdx,
     |   group_start : Int,
     |   total : Int,
     | ) -> Int? {
     |   let idx = match type_idx {
     |     TypeIdx(i) => i.reinterpret_as_int()
     |     RecIdx(i) => group_start + i.reinterpret_as_int()
     |   }
     |   if idx < 0 || idx >= total {
  70 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   } else {
     |     Some(idx)
     |   }
     | }
     …

     | fn rt_collect_valtype_refs(
     |   out : Array[Int],
     |   vt : ValType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Unit {
     |   match vt {
     |     RefTypeValType(rt) =>
     |       match rt {
     |         HeapTypeRefType(_, ht) =>
     |           match ht {
     |             HeapType(type_idx) =>
     |               match rt_resolve_type_idx(type_idx, group_start, total) {
     |                 Some(idx) => out.push(idx)
  91 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
  93 |             _ => ()
     |             ^^^^^^^ 	<-- UNCOVERED
     |           }
  95 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
  97 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_collect_storage_refs(
     |   out : Array[Int],
     |   st : StorageType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Unit {
     |   match st {
     |     ValTypeStorageType(vt) =>
     |       rt_collect_valtype_refs(out, vt, group_start, total)
 111 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_collect_subtype_refs(
     |   subtype : SubType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Array[Int] {
     |   let out : Array[Int] = []
     |   for super_idx in subtype.super_types() {
 123 |     match rt_resolve_type_idx(super_idx, group_start, total) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(idx) => out.push(idx)
     |       None => ()
     |     }
     |   }
     |   match subtype.get_comptype() {
     |     FuncCompType(params, results) => {
     |       for p in params {
 131 |         rt_collect_valtype_refs(out, p, group_start, total)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for r in results {
 134 |         rt_collect_valtype_refs(out, r, group_start, total)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructCompType(fields) =>
     |       for field in fields {
     |         let FieldType(st, _) = field
     |         rt_collect_storage_refs(out, st, group_start, total)
     |       }
 142 |     ArrayCompType(field) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let FieldType(st, _) = field
 144 |       rt_collect_storage_refs(out, st, group_start, total)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn rt_collect_func_type_idx_by_func(mod : Module) -> Map[FuncIdx, TypeIdx] {
     |   let out : Map[FuncIdx, TypeIdx] = Map::new()
     |   let mut next : UInt = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 169 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) => {
     |             out[FuncIdx::new(next)] = type_idx
     |             next += 1
     |           }
 175 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out[FuncIdx::new(next)] = type_idx
     |         next += 1
     |       }
 186 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn rt_collect_all_global_types(mod : Module) -> Array[GlobalType] {
     |   let out : Array[GlobalType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 196 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(global_type)) => out.push(global_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for global in globals {
     |         let Global(global_type, _) = global
     |         out.push(global_type)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn rt_collect_all_table_types(mod : Module) -> Array[TableType] {
     |   let out : Array[TableType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 220 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, TableExternType(table_type)) => out.push(table_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.table_sec {
     |     Some(TableSec(tables)) =>
 230 |       for table in tables {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Table(table_type, _) = table
     |         out.push(table_type)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn rt_collect_all_tag_types(mod : Module) -> Array[TagType] {
     |   let out : Array[TagType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 244 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, TagExternType(tag_type)) => out.push(tag_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.tag_sec {
     |     Some(TagSec(tags)) =>
 254 |       for tag in tags {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         out.push(tag)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn rt_mark_public_type(
     |   public_types : Set[Int],
     |   flat : RTFlatTypes,
     |   idx : Int,
     | ) -> Unit {
     |   let stack : Array[Int] = [idx]
     |   while !stack.is_empty() {
     |     let curr = stack.pop().unwrap()
     |     if curr < 0 || curr >= flat.subtypes.length() || public_types.contains(curr) {
 272 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     public_types.add(curr)
     |     for
     |       ref_ in rt_collect_subtype_refs(
     |         flat.subtypes[curr],
     |         flat.group_starts[curr],
     |         flat.subtypes.length(),
     |       ) {
 281 |       stack.push(ref_)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn rt_mark_public_valtype(
     |   public_types : Set[Int],
     |   flat : RTFlatTypes,
     |   vt : ValType,
     | ) -> Unit {
     |   match vt {
     |     RefTypeValType(HeapTypeRefType(_, HeapType(type_idx))) =>
     |       match rt_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |         Some(idx) => rt_mark_public_type(public_types, flat, idx)
 296 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 298 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_mark_public_reftype(
     |   public_types : Set[Int],
     |   flat : RTFlatTypes,
     |   rt : RefType,
     | ) -> Unit {
 308 |   match rt {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     HeapTypeRefType(_, HeapType(type_idx)) =>
 310 |       match rt_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(idx) => rt_mark_public_type(public_types, flat, idx)
     |         None => ()
     |       }
 314 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_collect_public_types(mod : Module, flat : RTFlatTypes) -> Set[Int] {
     |   let public_types : Set[Int] = Set::new()
     |   let func_types = rt_collect_func_type_idx_by_func(mod)
     |   let global_types = rt_collect_all_global_types(mod)
     |   let table_types = rt_collect_all_table_types(mod)
     |   let tag_types = rt_collect_all_tag_types(mod)
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
 327 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) =>
 330 |             match rt_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(idx) => rt_mark_public_type(public_types, flat, idx)
     |               None => ()
     |             }
     |           Import(_, _, TagExternType(TagType(type_idx))) =>
 335 |             match rt_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(idx) => rt_mark_public_type(public_types, flat, idx)
     |               None => ()
     |             }
     |           Import(_, _, GlobalExternType(GlobalType(vt, _))) =>
 340 |             rt_mark_public_valtype(public_types, flat, vt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Import(_, _, TableExternType(TableType(rt, _))) =>
 342 |             rt_mark_public_reftype(public_types, flat, rt)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         let Export(_, extern_idx) = export_
     |         match extern_idx {
     |           FuncExternIdx(func_idx) =>
 354 |             match func_types.get(func_idx) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(type_idx) =>
 356 |                 match rt_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   Some(idx) => rt_mark_public_type(public_types, flat, idx)
     |                   None => ()
     |                 }
 360 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           GlobalExternIdx(GlobalIdx(raw)) => {
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < global_types.length() {
     |               let GlobalType(vt, _) = global_types[idx]
     |               rt_mark_public_valtype(public_types, flat, vt)
     |             }
     |           }
 369 |           TableExternIdx(TableIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < table_types.length() {
 372 |               let TableType(rt, _) = table_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               rt_mark_public_reftype(public_types, flat, rt)
     |             }
     |           }
 376 |           TagExternIdx(TagIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < tag_types.length() {
 379 |               let TagType(type_idx) = tag_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match rt_resolve_type_idx(type_idx, 0, flat.subtypes.length()) {
     |                 Some(type_i) => rt_mark_public_type(public_types, flat, type_i)
     |                 None => ()
     |               }
     |             }
     |           }
 386 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     |   let initially_public : Array[Int] = []
     |   for idx in public_types {
     |     initially_public.push(idx)
     |   }
     |   for idx in initially_public {
     |     let g = flat.type_to_group[idx]
     |     for t in flat.groups[g] {
     |       public_types.add(t)
     |     }
     |   }
     |   public_types
     | }
     …

     | fn rt_has_gc_types(flat : RTFlatTypes) -> Bool {
     |   for subtype in flat.subtypes {
     |     match subtype.get_comptype() {
     |       StructCompType(_) | ArrayCompType(_) => return true
 409 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   false
     | }
     …

     | fn rt_collect_non_type_use_counts(mod : Module, counts : Array[Int]) -> Unit {
     |   let walker = ModuleTransformer::new().on_typeidx_evt(fn(_, _, tidx) {
     |     match tidx {
     |       TypeIdx(i) => {
     |         let raw = i.reinterpret_as_int()
     |         if raw >= 0 && raw < counts.length() {
     |           counts[raw] = counts[raw] + 1
     |         }
     |       }
 425 |       RecIdx(_) => ()
     |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     unchanged()
     |   })
     |   match mod.import_sec {
 430 |     Some(sec) => ignore(walker.walk_importsec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(sec) => ignore(walker.walk_funcsec((), sec))
 435 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.table_sec {
 438 |     Some(sec) => ignore(walker.walk_tablesec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.mem_sec {
 442 |     Some(sec) => ignore(walker.walk_memsec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.tag_sec {
 446 |     Some(sec) => ignore(walker.walk_tagsec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.global_sec {
     |     Some(sec) => ignore(walker.walk_globalsec((), sec))
     |     None => ()
     |   }
     |   match mod.export_sec {
     |     Some(sec) => ignore(walker.walk_exportsec((), sec))
     |     None => ()
     |   }
     |   match mod.start_sec {
 458 |     Some(sec) => ignore(walker.walk_startsec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.elem_sec {
 462 |     Some(sec) => ignore(walker.walk_elemsec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.data_cnt_sec {
 466 |     Some(sec) => ignore(walker.walk_datacntsec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     |   match mod.code_sec {
     |     Some(sec) => ignore(walker.walk_codesec((), sec))
 471 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.data_sec {
 474 |     Some(sec) => ignore(walker.walk_datasec((), sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => ()
     |   }
     | }
     …

     | fn rt_topological_sort(succs : Array[Array[Int]]) -> Array[Int] {
     |   let n = succs.length()
     |   let indegree = Array::make(n, 0)
     |   for src = 0; src < n; src = src + 1 {
     |     for dst in succs[src] {
     |       indegree[dst] = indegree[dst] + 1
     |     }
     |   }
     |   let queue : Array[Int] = []
     |   for i = 0; i < n; i = i + 1 {
     |     if indegree[i] == 0 {
     |       queue.push(i)
     |     }
     |   }
     |   let out : Array[Int] = []
     |   let mut qi = 0
     |   while qi < queue.length() {
     |     let curr = queue[qi]
     |     qi = qi + 1
     |     out.push(curr)
     |     for dep in succs[curr] {
     |       indegree[dep] = indegree[dep] - 1
     |       if indegree[dep] == 0 {
     |         queue.push(dep)
     |       }
     |     }
     |   }
     |   if out.length() < n {
 525 |     let seen = Array::make(n, false)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     for idx in out {
 527 |       seen[idx] = true
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 529 |     for i = 0; i < n; i = i + 1 {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if !seen[i] {
     |         out.push(i)
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn rt_min_topological_sort(
     |   succs : Array[Array[Int]],
     |   prefer_before : (Int, Int) -> Bool,
     | ) -> Array[Int] {
     |   let n = succs.length()
     |   let indegree = Array::make(n, 0)
     |   for src = 0; src < n; src = src + 1 {
     |     for dst in succs[src] {
     |       indegree[dst] = indegree[dst] + 1
     |     }
     |   }
     |   let emitted = Array::make(n, false)
     |   let available : Array[Int] = []
     |   for i = 0; i < n; i = i + 1 {
     |     if indegree[i] == 0 {
     |       available.push(i)
     |     }
     |   }
     |   let out : Array[Int] = []
     |   while out.length() < n {
     |     if available.is_empty() {
 560 |       for i = 0; i < n; i = i + 1 {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if !emitted[i] {
     |           available.push(i)
     |           break
     |         }
     |       }
     |     }
     |     let mut best_pos = 0
     |     let mut best = available[0]
     |     for pos = 1; pos < available.length(); pos = pos + 1 {
     |       let candidate = available[pos]
     |       if prefer_before(candidate, best) {
     |         best = candidate
     |         best_pos = pos
     |       }
     |     }
     |     let last = available.pop().unwrap()
     |     if best_pos < available.length() {
     |       available[best_pos] = last
     |     }
     |     if emitted[best] {
 581 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     emitted[best] = true
     |     out.push(best)
     |     for dep in succs[best] {
     |       indegree[dep] = indegree[dep] - 1
     |       if indegree[dep] == 0 && !emitted[dep] {
     |         available.push(dep)
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn rt_sort_group(
     |   group : Array[Int],
     |   flat : RTFlatTypes,
     |   all_counts : Array[Int],
     |   for_testing : Bool,
     | ) -> Array[Int] {
     |   if group.length() <= 1 {
 632 |     return group.copy()
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let local_of_abs : Map[Int, Int] = Map::new()
     |   for i = 0; i < group.length(); i = i + 1 {
     |     local_of_abs[group[i]] = i
     |   }
     |   let succs : Array[Array[Int]] = Array::make(group.length(), [])
     |   let local_counts : Array[Int] = []
     |   for abs_idx in group {
     |     local_counts.push(all_counts[abs_idx])
     |   }
     |   for src = 0; src < group.length(); src = src + 1 {
     |     let abs_idx = group[src]
     |     let refs = rt_collect_subtype_refs(
     |       flat.subtypes[abs_idx],
     |       flat.group_starts[abs_idx],
     |       flat.subtypes.length(),
     |     )
     |     let nexts : Array[Int] = []
     |     for ref_ in refs {
     |       match local_of_abs.get(ref_) {
     |         Some(dst) => nexts.push(dst)
 654 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     succs[src] = rt_unique_sorted(nexts)
     |   }
     |   let succs_first_forward = rt_topological_sort(succs)
     |   let succs_first : Array[Int] = []
     |   for i = 0; i < succs_first_forward.length(); i = i + 1 {
     |     succs_first.push(succs_first_forward[succs_first_forward.length() - 1 - i])
     |   }
     |   let mut best_sort : Array[Int] = []
     |   let mut best_cost = 0
     |   for factor_index = 0
     |       factor_index < rt_num_factors
     |       factor_index = factor_index + 1 {
     |     let factor = rt_get_factor(factor_index)
     |     let weights : Array[Double] = []
     |     for c in local_counts {
     |       weights.push(c.to_double())
     |     }
     |     for pred in succs_first {
     |       for succ in succs[pred] {
     |         weights[pred] = weights[pred] + weights[succ] * factor
     |       }
     |     }
     |     let sort = rt_min_topological_sort(succs, fn(a, b) {
     |       if weights[a] == weights[b] {
     |         a < b
     |       } else {
     |         weights[a] > weights[b]
     |       }
     |     })
     |     let cost = rt_get_cost(sort, local_counts, for_testing)
     |     if factor_index == 0 || cost < best_cost {
     |       best_sort = sort
     |       best_cost = cost
     |     }
     |   }
     |   let out : Array[Int] = []
     |   for i in best_sort {
     |     out.push(group[i])
     |   }
     |   out
     | }
     …

     | fn rt_rewrite_typeidx(
     |   type_idx : TypeIdx,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[TypeIdx, String] {
     |   match rt_resolve_type_idx(type_idx, group_start, total) {
     |     Some(abs_idx) =>
     |       match local_pos_by_old.get(abs_idx) {
     |         Some(pos) => Ok(TypeIdx::rec(pos.reinterpret_as_uint()))
     |         None =>
 712 |           match old_to_new.get(abs_idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(next_idx) => Ok(next_idx)
     |             None => Err("reorder_types: missing remap")
     |           }
     |       }
 717 |     None => Ok(type_idx)
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_rewrite_heaptype(
     |   ht : HeapType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[HeapType, String] {
     |   match ht {
     |     HeapType(type_idx) =>
     |       match
     |         rt_rewrite_typeidx(
     |           type_idx, group_start, total, local_pos_by_old, old_to_new,
     |         ) {
     |         Ok(next_idx) => Ok(HeapType::new(next_idx))
 736 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 738 |     _ => Ok(ht)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_rewrite_reftype(
     |   rt : RefType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[RefType, String] {
     |   match rt {
     |     HeapTypeRefType(nullable, ht) =>
     |       match
     |         rt_rewrite_heaptype(
     |           ht, group_start, total, local_pos_by_old, old_to_new,
     |         ) {
     |         Ok(next_ht) => Ok(RefType::new(nullable, next_ht))
 757 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 759 |     _ => Ok(rt)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_rewrite_valtype(
     |   vt : ValType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[ValType, String] {
     |   match vt {
     |     RefTypeValType(rt) =>
     |       match
     |         rt_rewrite_reftype(rt, group_start, total, local_pos_by_old, old_to_new) {
     |         Ok(next_rt) => Ok(ValType::ref_type(next_rt))
 776 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 778 |     _ => Ok(vt)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_rewrite_storage(
     |   st : StorageType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[StorageType, String] {
     |   match st {
     |     ValTypeStorageType(vt) =>
     |       match
     |         rt_rewrite_valtype(vt, group_start, total, local_pos_by_old, old_to_new) {
     |         Ok(next_vt) => Ok(StorageType::val_type(next_vt))
 795 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 797 |     _ => Ok(st)
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn rt_rewrite_subtype(
     |   subtype : SubType,
     |   group_start : Int,
     |   total : Int,
     |   local_pos_by_old : Map[Int, Int],
     |   old_to_new : Map[Int, TypeIdx],
     | ) -> Result[SubType, String] {
     |   match subtype {
 810 |     SubType(is_final, supers, ct) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_supers : Array[TypeIdx] = []
     |       for super_idx in supers {
 813 |         match
     |         ^^^^^ 	<-- UNCOVERED
     |           rt_rewrite_typeidx(
     |             super_idx, group_start, total, local_pos_by_old, old_to_new,
     |           ) {
 817 |           Ok(next_idx) => next_supers.push(next_idx)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(e) => return Err(e)
     |         }
     |       }
 821 |       let next_ct = match ct {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         FuncCompType(params, results) => {
     |           let next_params : Array[ValType] = []
     |           let next_results : Array[ValType] = []
     |           for p in params {
 826 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               rt_rewrite_valtype(
     |                 p, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
 830 |               Ok(v) => next_params.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
     |           for r in results {
 835 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               rt_rewrite_valtype(
     |                 r, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
 839 |               Ok(v) => next_results.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
 843 |           CompType::func(next_params, next_results)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
 845 |         StructCompType(fields) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let next_fields : Array[FieldType] = []
     |           for field in fields {
 848 |             let FieldType(storage, mut_) = field
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             match
 850 |               rt_rewrite_storage(
     |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 storage, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
     |               Ok(next_storage) =>
 854 |                 next_fields.push(FieldType::new(next_storage, mut_))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
 858 |           CompType::struct_(next_fields)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
 860 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
     |           let next_storage = match
 863 |             rt_rewrite_storage(
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               storage, group_start, total, local_pos_by_old, old_to_new,
     |             ) {
 866 |             Ok(v) => v
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => return Err(e)
     |           }
 869 |           CompType::array(FieldType::new(next_storage, mut_))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 872 |       Ok(SubType::new(is_final, next_supers, next_ct))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     CompTypeSubType(ct) => {
     |       let next_ct = match ct {
     |         FuncCompType(params, results) => {
     |           let next_params : Array[ValType] = []
     |           let next_results : Array[ValType] = []
     |           for p in params {
 880 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               rt_rewrite_valtype(
     |                 p, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
 884 |               Ok(v) => next_params.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
     |           for r in results {
 889 |             match
     |             ^^^^^ 	<-- UNCOVERED
     |               rt_rewrite_valtype(
     |                 r, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
 893 |               Ok(v) => next_results.push(v)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Err(e) => return Err(e)
     |             }
     |           }
     |           CompType::func(next_params, next_results)
     |         }
     |         StructCompType(fields) => {
     |           let next_fields : Array[FieldType] = []
     |           for field in fields {
     |             let FieldType(storage, mut_) = field
     |             match
     |               rt_rewrite_storage(
     |                 storage, group_start, total, local_pos_by_old, old_to_new,
     |               ) {
     |               Ok(next_storage) =>
     |                 next_fields.push(FieldType::new(next_storage, mut_))
 909 |               Err(e) => return Err(e)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           CompType::struct_(next_fields)
     |         }
 914 |         ArrayCompType(field) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let FieldType(storage, mut_) = field
     |           let next_storage = match
 917 |             rt_rewrite_storage(
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               storage, group_start, total, local_pos_by_old, old_to_new,
     |             ) {
 920 |             Ok(v) => v
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => return Err(e)
     |           }
 923 |           CompType::array(FieldType::new(next_storage, mut_))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       Ok(SubType::comp_type(next_ct))
     |     }
     |   }
     | }
     …

     | fn reorder_types(
     |   mod : Module,
     |   for_testing? : Bool = false,
     | ) -> Result[Module, String] {
     |   let type_sec = match mod.type_sec {
     |     Some(type_sec) => type_sec
 938 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let flat = rt_flatten_types(type_sec)
     |   if flat.subtypes.is_empty() || !rt_has_gc_types(flat) {
 942 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let public_types = rt_collect_public_types(mod, flat)
     |   let counts = Array::make(flat.subtypes.length(), 0)
     |   rt_collect_non_type_use_counts(mod, counts)
     |   rt_collect_type_def_use_counts(flat, counts)
     |   let group_orders : Array[Array[Int]] = []
     |   let mut changed = false
     |   for group in flat.groups {
     |     let mut is_private = true
     |     for idx in group {
     |       if public_types.contains(idx) {
     |         is_private = false
     |         break
     |       }
     |     }
     |     if is_private && group.length() > 1 {
     |       let sorted = rt_sort_group(group, flat, counts, for_testing)
     |       if sorted != group {
     |         changed = true
     |       }
     |       group_orders.push(sorted)
     |     } else {
     |       group_orders.push(group.copy())
     |     }
     |   }
     |   if !changed {
     |     return Ok(mod)
     |   }
     |   let old_to_new : Map[Int, TypeIdx] = Map::new()
     |   for gi = 0; gi < flat.groups.length(); gi = gi + 1 {
     |     let group = flat.groups[gi]
     |     let order = group_orders[gi]
     |     let start = group[0]
     |     for pos = 0; pos < order.length(); pos = pos + 1 {
     |       old_to_new[order[pos]] = TypeIdx::new((start + pos).reinterpret_as_uint())
     |     }
     |   }
     |   let new_recs : Array[RecType] = []
     |   for gi = 0; gi < flat.groups.length(); gi = gi + 1 {
     |     let order = group_orders[gi]
     |     let local_pos_by_old : Map[Int, Int] = Map::new()
     |     for i = 0; i < order.length(); i = i + 1 {
     |       local_pos_by_old[order[i]] = i
     |     }
     |     let next_subtypes : Array[SubType] = []
     |     for old_idx in order {
     |       match
     |         rt_rewrite_subtype(
     |           flat.subtypes[old_idx],
     |           flat.group_starts[old_idx],
     |           flat.subtypes.length(),
     |           local_pos_by_old,
     |           old_to_new,
     |         ) {
     |         Ok(next_subtype) => next_subtypes.push(next_subtype)
 998 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if next_subtypes.length() == 1 {
     |       new_recs.push(RecType::new(next_subtypes[0]))
     |     } else {
     |       new_recs.push(RecType::group(next_subtypes))
     |     }
     |   }
     |   let new_type_sec = TypeSec::new(new_recs)
     |   let remapper = ModuleTransformer::new()
     |     .on_typeidx_evt(fn(_, _, tidx : TypeIdx) {
     |       match tidx {
     |         TypeIdx(i) => {
     |           let raw = i.reinterpret_as_int()
     |           match old_to_new.get(raw) {
     |             Some(next) =>
     |               if next == tidx {
     |                 unchanged()
     |               } else {
     |                 change((), next)
     |               }
1020 |             None => unchanged()
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
1023 |         RecIdx(_) => unchanged()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     .on_heaptype_evt(fn(_, _, ht : HeapType) {
1027 |       match ht {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         HeapType(type_idx) =>
1029 |           match type_idx {
     |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TypeIdx(i) => {
     |               let raw = i.reinterpret_as_int()
     |               match old_to_new.get(raw) {
     |                 Some(next) =>
1034 |                   if next == type_idx {
     |                   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     unchanged()
     |                   } else {
1037 |                     change((), HeapType::new(next))
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
1039 |                 None => unchanged()
     |                 ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
1042 |             RecIdx(_) => unchanged()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
1044 |         _ => unchanged()
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     .on_typesec_evt(fn(_, _, _) { change((), new_type_sec) })
     |   match remapper.walk_module((), mod) {
     |     Ok(Some((_, out))) => Ok(out)
1050 |     Ok(None) => Ok(mod.with_type_sec(new_type_sec))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn run_reorder_types(mod : Module, for_testing? : Bool = false) -> Module {
     |   match reorder_types(mod, for_testing~) {
     |     Ok(out) => out
1059 |     Err(_) => mod
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

91 uncovered line(s) in src/passes/signature_pruning.mbt:

    | fn sp_extract_comp_type(sub_type : SubType) -> CompType {
    |   match sub_type {
 12 |     SubType(_, _, comp) => comp
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     CompTypeSubType(comp) => comp
    |   }
    | }
    …

    | fn sp_flattened_type_count(rec_types : Array[RecType]) -> Int {
    |   let mut n = 0
    |   for rec_type in rec_types {
    |     match rec_type {
    |       SingleRecType(_) => n += 1
 23 |       GroupRecType(sub_types) => n += sub_types.length()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   n
    | }
    …

    | fn sp_resolve_type_idx(
    |   type_idx : TypeIdx,
    |   group_start : Int,
    |   total : Int,
    | ) -> Int? {
 35 |   let idx = match type_idx {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TypeIdx(i) => i.reinterpret_as_int()
    |     RecIdx(i) => group_start + i.reinterpret_as_int()
    |   }
    |   if idx < 0 || idx >= total {
 40 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
 42 |     Some(idx)
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn sp_typeidx_raw(type_idx : TypeIdx) -> Int {
    |   match type_idx {
    |     TypeIdx(i) => i.reinterpret_as_int()
 50 |     RecIdx(i) => i.reinterpret_as_int()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn sp_resolve_func_type(
    |   comp_types : Array[CompType],
    |   idx : TypeIdx,
    | ) -> FuncType? {
    |   let j = sp_typeidx_raw(idx)
    |   if j < 0 || j >= comp_types.length() {
 61 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match comp_types[j] {
    |     FuncCompType(params, results) => Some(FuncType::new(params, results))
 65 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn sp_collect_func_types(mod : Module) -> Array[FuncType] {
    |   let comp_types : Array[CompType] = []
    |   match mod.type_sec {
    |     Some(TypeSec(rec_types)) =>
    |       for rec_type in rec_types {
    |         match rec_type {
    |           SingleRecType(sub_type) =>
    |             comp_types.push(sp_extract_comp_type(sub_type))
    |           GroupRecType(sub_types) =>
 79 |             for sub_type in sub_types {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               comp_types.push(sp_extract_comp_type(sub_type))
    |             }
    |         }
    |       }
 84 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_types : Array[FuncType] = []
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 89 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(type_idx) =>
 93 |             match sp_resolve_func_type(comp_types, type_idx) {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Some(ft) => func_types.push(ft)
    |               None => func_types.push(FuncType::new([], []))
    |             }
 97 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for type_idx in type_idxs {
    |         match sp_resolve_func_type(comp_types, type_idx) {
    |           Some(ft) => func_types.push(ft)
107 |           None => func_types.push(FuncType::new([], []))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
110 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   func_types
    | }
    …

    | fn sp_count_imported_funcs(mod : Module) -> Int {
    |   let mut n = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
120 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(_) => n += 1
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   n
    | }
    …

    | fn sp_collect_func_type_idxs(mod : Module) -> Array[TypeIdx] {
    |   let out : Array[TypeIdx] = []
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
137 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(type_idx) => out.push(type_idx)
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for type_idx in type_idxs {
    |         out.push(type_idx)
    |       }
151 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   out
    | }
    …

    | fn sp_is_literal_const(instr : TInstr) -> Bool {
    |   match instr {
    |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => true
170 |     TRefNull(_) | TRefFunc(_) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
    |     _ => false
    |   }
    | }
    …

    | fn sp_is_trivially_pure_arg(instr : TInstr) -> Bool {
    |   match instr {
    |     TI32Const(_) | TI64Const(_) | TF32Const(_) | TF64Const(_) => true
180 |     TRefNull(_) | TRefFunc(_) => true
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
    |     TLocalGet(_) | TGlobalGet(_) => true
    |     _ => false
    |   }
    | }
    …

    | fn sp_all_calls_arg_pure(calls : Array[SPCallSite], param_idx : Int) -> Bool {
    |   for callsite in calls {
    |     let args = callsite.args
    |     if param_idx >= args.length() {
192 |       return false
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     if !sp_is_trivially_pure_arg(args[param_idx]) {
195 |       return false
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   true
    | }
    …

    | fn sp_filter_call_args(
    |   args : Array[TInstr],
    |   removed : Set[Int],
    | ) -> Array[TInstr] {
    |   if removed.is_empty() {
207 |     return args
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let out : Array[TInstr] = []
    |   for i = 0; i < args.length(); i = i + 1 {
    |     if !removed.contains(i) {
212 |       out.push(args[i])
    |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   out
    | }
    …

    | fn sp_rewrite_calls(
    |   body : TExpr,
    |   func_type_idxs : Array[TypeIdx],
    |   removed_by_type_abs : Map[Int, Set[Int]],
    |   new_type_idx_by_old_abs : Map[Int, TypeIdx],
    | ) -> TExpr {
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     let processed = match self.walk_tinstruction_default((), instr) {
    |       Ok(Some((_, i))) => i
    |       Ok(None) => instr
229 |       Err(e) => return Err(e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     match processed {
    |       TCall(target, args) => {
    |         let FuncIdx(raw) = target
    |         let abs_idx = raw.reinterpret_as_int()
    |         if abs_idx < 0 || abs_idx >= func_type_idxs.length() {
236 |           return if processed != instr {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             change((), processed)
    |           } else {
239 |             unchanged()
    |             ^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |         let old_type_abs = sp_typeidx_raw(func_type_idxs[abs_idx])
    |         match removed_by_type_abs.get(old_type_abs) {
    |           Some(removed) =>
    |             if removed.is_empty() {
246 |               if processed != instr {
    |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 change((), processed)
    |               } else {
249 |                 unchanged()
    |                 ^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             } else {
    |               let new_args = sp_filter_call_args(args, removed)
    |               if new_args != args || processed != instr {
    |                 change((), TInstr::call(target, new_args))
    |               } else {
256 |                 unchanged()
    |                 ^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             }
    |           None =>
260 |             if processed != instr {
    |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               change((), processed)
    |             } else {
263 |               unchanged()
    |               ^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |         }
    |       }
267 |       TReturnCall(target, args) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let FuncIdx(raw) = target
269 |         let abs_idx = raw.reinterpret_as_int()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         if abs_idx < 0 || abs_idx >= func_type_idxs.length() {
271 |           return if processed != instr {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             change((), processed)
    |           } else {
274 |             unchanged()
    |             ^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
277 |         let old_type_abs = sp_typeidx_raw(func_type_idxs[abs_idx])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         match removed_by_type_abs.get(old_type_abs) {
    |           Some(removed) =>
280 |             if removed.is_empty() {
    |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               if processed != instr {
    |                 change((), processed)
    |               } else {
284 |                 unchanged()
    |                 ^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             } else {
287 |               let new_args = sp_filter_call_args(args, removed)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               if new_args != args || processed != instr {
289 |                 change((), TInstr::return_call(target, new_args))
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               } else {
291 |                 unchanged()
    |                 ^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             }
    |           None =>
295 |             if processed != instr {
    |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               change((), processed)
    |             } else {
298 |               unchanged()
    |               ^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |         }
    |       }
    |       TCallRef(type_idx, args, ref_) => {
    |         let old_type_abs = sp_typeidx_raw(type_idx)
    |         let removed = match removed_by_type_abs.get(old_type_abs) {
    |           Some(v) => v
    |           None =>
307 |             return if processed != instr {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               change((), processed)
    |             } else {
310 |               unchanged()
    |               ^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |         }
    |         let new_args = sp_filter_call_args(args, removed)
    |         let new_type_idx = match new_type_idx_by_old_abs.get(old_type_abs) {
    |           Some(v) => v
316 |           None => type_idx
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         if new_args != args || new_type_idx != type_idx || processed != instr {
    |           change((), TInstr::call_ref(new_type_idx, new_args, ref_))
    |         } else {
321 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
324 |       TReturnCallRef(type_idx, args, ref_) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let old_type_abs = sp_typeidx_raw(type_idx)
    |         let removed = match removed_by_type_abs.get(old_type_abs) {
    |           Some(v) => v
    |           None =>
329 |             return if processed != instr {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               change((), processed)
    |             } else {
332 |               unchanged()
    |               ^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |         }
335 |         let new_args = sp_filter_call_args(args, removed)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let new_type_idx = match new_type_idx_by_old_abs.get(old_type_abs) {
    |           Some(v) => v
    |           None => type_idx
    |         }
    |         if new_args != args || new_type_idx != type_idx || processed != instr {
341 |           change((), TInstr::return_call_ref(new_type_idx, new_args, ref_))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         } else {
343 |           unchanged()
    |           ^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       _ => if processed != instr { change((), processed) } else { unchanged() }
    |     }
    |   })
    |   match walker.walk_texpr((), body) {
    |     Ok(Some((_, new_body))) => new_body
351 |     _ => body
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn sp_collect_subtypes(
    |   rec_types : Array[RecType],
    | ) -> (Array[SubType], Array[Int], Array[Array[Int]], Array[Bool]) {
    |   let subtypes : Array[SubType] = []
    |   let group_starts : Array[Int] = []
    |   let mut next = 0
    |   for rec in rec_types {
    |     match rec {
    |       SingleRecType(st) => {
    |         subtypes.push(st)
    |         group_starts.push(next)
    |         next += 1
    |       }
369 |       GroupRecType(sts) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let start = next
    |         for st in sts {
372 |           subtypes.push(st)
    |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           group_starts.push(start)
    |           next += 1
    |         }
    |       }
    |     }
    |   }
    |   let immediate_subs : Array[Array[Int]] = []
    |   let has_sig_super : Array[Bool] = []
    |   for _ in 0..<subtypes.length() {
    |     immediate_subs.push([])
    |     has_sig_super.push(false)
    |   }
    |   for i = 0; i < subtypes.length(); i = i + 1 {
    |     for super_idx in subtypes[i].super_types() {
387 |       match sp_resolve_type_idx(super_idx, group_starts[i], subtypes.length()) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(super_abs) => {
    |           immediate_subs[super_abs].push(i)
    |           match subtypes[super_abs].get_comptype() {
    |             FuncCompType(_, _) => has_sig_super[i] = true
    |             _ => ()
    |           }
    |         }
395 |         None => ()
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    |   (subtypes, group_starts, immediate_subs, has_sig_super)
    | }
    …

    | fn sp_run_iteration(mod : Module) -> (Module, Bool) {
    |   if mod.table_sec is Some(_) {
    |     return (mod, false)
    |   }
    |   let funcs = match mod.code_sec {
    |     Some(CodeSec(fs)) => fs
409 |     None => return (mod, false)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_sec = match mod.func_sec {
    |     Some(FuncSec(type_idxs)) => type_idxs
413 |     None => return (mod, false)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let type_recs = match mod.type_sec {
    |     Some(TypeSec(recs)) => recs.copy()
417 |     None => return (mod, false)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if funcs.is_empty() || func_sec.is_empty() {
420 |     return (mod, false)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_types = sp_collect_func_types(mod)
    |   let func_type_idxs = sp_collect_func_type_idxs(mod)
    |   let total_func_count = func_types.length()
    |   if total_func_count == 0 || func_type_idxs.length() != total_func_count {
426 |     return (mod, false)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let import_func_count = sp_count_imported_funcs(mod)
    |   let total_types = sp_flattened_type_count(type_recs)
    |   if total_types == 0 {
431 |     return (mod, false)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   let funcs_by_type : Array[Array[Int]] = []
    |   let used_params_by_type : Array[Set[Int]] = []
    |   let calls_by_type : Array[Array[SPCallSite]] = []
    |   let optimizable_by_type : Array[Bool] = []
    |   for _ in 0..<total_types {
    |     funcs_by_type.push([])
    |     used_params_by_type.push(Set::new())
    |     calls_by_type.push([])
    |     optimizable_by_type.push(true)
    |   }
    | 
    |   let has_unseen_calls : Array[Bool] = Array::make(total_func_count, false)
    |   mark_exports_unseen(mod, has_unseen_calls)
    |   mark_start_unseen(mod, has_unseen_calls)
    |   mark_elem_unseen(mod, has_unseen_calls)
    | 
    |   for abs_idx = 0; abs_idx < total_func_count; abs_idx = abs_idx + 1 {
    |     let type_abs = sp_typeidx_raw(func_type_idxs[abs_idx])
    |     if type_abs < 0 || type_abs >= total_types {
453 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     funcs_by_type[type_abs].push(abs_idx)
    |     if abs_idx < import_func_count {
457 |       optimizable_by_type[type_abs] = false
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       continue
    |     }
    |     let def_idx = abs_idx - import_func_count
    |     if def_idx < 0 || def_idx >= funcs.length() {
462 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let FuncType(params, _) = func_types[abs_idx]
    |     let param_count = params.length()
    |     let used = used_params_by_type[type_abs]
    |     match funcs[def_idx] {
    |       TFunc(_, body) => {
    |         let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
    |           self,
    |           _,
    |           instr,
    |         ) {
    |           match instr {
475 |             TLocalGet(LocalIdx(raw)) => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               let idx = raw.reinterpret_as_int()
    |               if idx >= 0 && idx < param_count {
478 |                 used.add(idx)
    |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             }
    |             TCall(target, args) | TReturnCall(target, args) => {
    |               let FuncIdx(raw) = target
    |               let target_abs = raw.reinterpret_as_int()
    |               if target_abs >= 0 && target_abs < total_func_count {
    |                 let callee_type_abs = sp_typeidx_raw(func_type_idxs[target_abs])
    |                 if callee_type_abs >= 0 && callee_type_abs < total_types {
    |                   calls_by_type[callee_type_abs].push(sp_callsite(args.copy()))
    |                 }
    |               }
    |             }
    |             TCallRef(type_idx, args, _) | TReturnCallRef(type_idx, args, _) => {
    |               let called_type_abs = sp_typeidx_raw(type_idx)
    |               if called_type_abs >= 0 && called_type_abs < total_types {
    |                 calls_by_type[called_type_abs].push(sp_callsite(args.copy()))
    |               }
    |             }
    |             _ => ()
    |           }
    |           self.walk_tinstruction_default((), instr)
    |         })
    |         ignore(walker.walk_texpr((), body))
    |       }
503 |       _ => ()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   for abs_idx = 0; abs_idx < total_func_count; abs_idx = abs_idx + 1 {
    |     if !has_unseen_calls[abs_idx] {
    |       continue
    |     }
511 |     let type_abs = sp_typeidx_raw(func_type_idxs[abs_idx])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     if type_abs >= 0 && type_abs < total_types {
513 |       optimizable_by_type[type_abs] = false
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   match mod.tag_sec {
    |     Some(TagSec(tags)) =>
519 |       for tag in tags {
    |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let TagType(type_idx) = tag
    |         let type_abs = sp_typeidx_raw(type_idx)
    |         if type_abs >= 0 && type_abs < total_types {
523 |           optimizable_by_type[type_abs] = false
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    | 
    |   let (flat_subtypes, _, immediate_subs, has_sig_super) = sp_collect_subtypes(
    |     type_recs,
    |   )
    | 
    |   let removed_by_type_abs : Map[Int, Set[Int]] = Map::new()
    |   let removed_unused_by_type_abs : Map[Int, Set[Int]] = Map::new()
    |   let removed_const_by_type_abs : Map[Int, Map[Int, TInstr]] = Map::new()
    |   let new_type_idx_by_old_abs : Map[Int, TypeIdx] = Map::new()
    |   let new_type_recs = type_recs.copy()
    |   let mut flat_type_count = total_types
    | 
    |   for type_abs = 0; type_abs < total_types; type_abs = type_abs + 1 {
    |     if !optimizable_by_type[type_abs] {
542 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     if funcs_by_type[type_abs].is_empty() {
    |       continue
    |     }
    |     if !immediate_subs[type_abs].is_empty() || has_sig_super[type_abs] {
548 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let old_sig = match flat_subtypes[type_abs].get_comptype() {
    |       FuncCompType(params, results) => FuncType::new(params, results)
552 |       _ => continue
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let FuncType(old_params, old_results) = old_sig
    |     let num_params = old_params.length()
    |     let calls = calls_by_type[type_abs]
    |     let used_params = used_params_by_type[type_abs]
    |     let removed_const : Map[Int, TInstr] = Map::new()
    |     for p = 0; p < num_params; p = p + 1 {
    |       if calls.is_empty() {
561 |         continue
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let mut candidate : TInstr? = None
    |       let mut all_const = true
    |       for callsite in calls {
    |         let args = callsite.args
    |         if p >= args.length() || !sp_is_literal_const(args[p]) {
568 |           all_const = false
    |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           break
    |         }
    |         match candidate {
    |           None => candidate = Some(args[p])
    |           Some(prev) =>
    |             if prev != args[p] {
    |               all_const = false
    |               break
    |             }
    |         }
    |       }
    |       if all_const {
    |         match candidate {
    |           Some(c) => removed_const.set(p, c)
583 |           None => ()
    |           ^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     }
    |     let removed_unused : Set[Int] = Set::new()
    |     for p = 0; p < num_params; p = p + 1 {
    |       if removed_const.contains(p) {
    |         continue
    |       }
    |       if used_params.contains(p) {
593 |         continue
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       if calls.is_empty() || sp_all_calls_arg_pure(calls, p) {
    |         removed_unused.add(p)
    |       }
    |     }
    |     let removed_all : Set[Int] = Set::new()
    |     for p = 0; p < num_params; p = p + 1 {
    |       if removed_unused.contains(p) || removed_const.contains(p) {
    |         removed_all.add(p)
    |       }
    |     }
    |     if removed_all.is_empty() {
    |       continue
    |     }
    |     let new_params : Array[ValType] = []
    |     for p = 0; p < num_params; p = p + 1 {
    |       if !removed_all.contains(p) {
611 |         new_params.push(old_params[p])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     let new_type_idx = TypeIdx::new(flat_type_count.reinterpret_as_uint())
    |     flat_type_count += 1
    |     new_type_recs.push(sp_make_func_type(new_params, old_results))
    |     removed_by_type_abs.set(type_abs, removed_all)
    |     removed_unused_by_type_abs.set(type_abs, removed_unused)
    |     removed_const_by_type_abs.set(type_abs, removed_const)
    |     new_type_idx_by_old_abs.set(type_abs, new_type_idx)
    |   }
    | 
    |   if new_type_idx_by_old_abs.is_empty() {
    |     return (mod, false)
    |   }
    | 
    |   let new_func_type_idxs = func_sec.copy()
    |   for i = 0; i < new_func_type_idxs.length(); i = i + 1 {
    |     let abs_idx = import_func_count + i
    |     if abs_idx < 0 || abs_idx >= total_func_count {
631 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let old_type_abs = sp_typeidx_raw(func_type_idxs[abs_idx])
    |     match new_type_idx_by_old_abs.get(old_type_abs) {
    |       Some(new_idx) => new_func_type_idxs[i] = new_idx
    |       None => ()
    |     }
    |   }
    | 
    |   let new_funcs : Array[Func] = []
    |   for i = 0; i < funcs.length(); i = i + 1 {
    |     let abs_idx = import_func_count + i
    |     if abs_idx < 0 || abs_idx >= total_func_count {
644 |       new_funcs.push(funcs[i])
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       continue
    |     }
    |     let old_type_abs = sp_typeidx_raw(func_type_idxs[abs_idx])
    |     let rewritten_func = match funcs[i] {
    |       TFunc(locals, body) => {
    |         let body_after_sig = match removed_by_type_abs.get(old_type_abs) {
    |           Some(_) => {
    |             let FuncType(old_params, _) = func_types[abs_idx]
    |             let removed_unused = match
    |               removed_unused_by_type_abs.get(old_type_abs) {
    |               Some(v) => v
656 |               None => Set::new()
    |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |             let removed_const = match
    |               removed_const_by_type_abs.get(old_type_abs) {
    |               Some(v) => v
661 |               None => Map::new()
    |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |             let (new_locals, prologue, removed_total, const_local_slots) = build_local_plan(
    |               locals, old_params, removed_unused, removed_const,
    |             )
    |             let body1 = rewrite_locals_and_returns(
    |               body,
    |               old_params.length(),
    |               removed_unused,
    |               removed_const,
    |               const_local_slots,
    |               removed_total,
    |               false,
    |             )
    |             let body2 = sp_rewrite_calls(
    |               body1, func_type_idxs, removed_by_type_abs, new_type_idx_by_old_abs,
    |             )
    |             let final_body = if prologue.is_empty() {
    |               body2
    |             } else {
    |               TExpr::new([..prologue, ..body2.0])
    |             }
    |             Func::t_func(new_locals, final_body)
    |           }
    |           None => {
    |             let body2 = sp_rewrite_calls(
    |               body, func_type_idxs, removed_by_type_abs, new_type_idx_by_old_abs,
    |             )
    |             Func::t_func(locals, body2)
    |           }
    |         }
    |         body_after_sig
    |       }
694 |       _ => funcs[i]
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     new_funcs.push(rewritten_func)
    |   }
    | 
    |   let out_mod = mod
    |     .with_type_sec(TypeSec::new(new_type_recs))
    |     .with_func_sec(FuncSec::new(new_func_type_idxs))
    |     .with_code_sec(CodeSec::new(new_funcs))
    |   (out_mod, true)
    | }
    …

    | fn signature_pruning_ir_pass(mod : Module) -> ModuleTransformer[IRContext] {
    |   let rewritten = run_signature_pruning(mod)
    |   let rewritten_code = rewritten.code_sec
    |   let rewritten_types = rewritten.type_sec
    |   let rewritten_funcs = rewritten.func_sec
    |   ModuleTransformer::new()
    |   .on_typesec_evt(fn(_, ctx : IRContext, type_sec : TypeSec) {
    |     match rewritten_types {
    |       Some(new_type_sec) =>
    |         if new_type_sec == type_sec {
    |           unchanged()
    |         } else {
    |           change(ctx, new_type_sec)
    |         }
731 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   .on_funcsec_evt(fn(_, ctx : IRContext, func_sec : FuncSec) {
    |     match rewritten_funcs {
    |       Some(new_func_sec) =>
    |         if new_func_sec == func_sec {
    |           unchanged()
    |         } else {
    |           change(ctx, new_func_sec)
    |         }
742 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   .on_codesec_evt(fn(_, ctx : IRContext, code_sec : CodeSec) {
    |     match rewritten_code {
    |       Some(new_code) =>
    |         if new_code == code_sec {
    |           unchanged()
    |         } else {
    |           change(ctx, new_code)
    |         }
753 |       None => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

156 uncovered line(s) in src/passes/signature_refining.mbt:

     | fn sr_collect_func_type_idxs(mod : Module) -> Array[TypeIdx] {
     |   let out : Array[TypeIdx] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         let Import(_, _, ex) = import_
     |         match ex {
     |           FuncExternType(type_idx) => out.push(type_idx)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
     |       for type_idx in type_idxs {
     |         out.push(type_idx)
     |       }
  77 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn sr_typeidx_raw(type_idx : TypeIdx) -> Int {
     |   match type_idx {
     |     TypeIdx(i) => i.reinterpret_as_int()
  86 |     RecIdx(i) => i.reinterpret_as_int()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sr_resolve_type_idx(
     |   type_idx : TypeIdx,
     |   group_start : Int,
     |   total : Int,
     | ) -> Int? {
     |   let idx = match type_idx {
     |     TypeIdx(i) => i.reinterpret_as_int()
  98 |     RecIdx(i) => group_start + i.reinterpret_as_int()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if idx < 0 || idx >= total {
 101 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   } else {
     |     Some(idx)
     |   }
     | }
     …

     | fn sr_flattened_type_count(rec_types : Array[RecType]) -> Int {
     |   let mut n = 0
     |   for rec_type in rec_types {
     |     match rec_type {
     |       SingleRecType(_) => n += 1
 113 |       GroupRecType(sub_types) => n += sub_types.length()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   n
     | }
     …

     | fn sr_collect_valtype_refs(
     |   out : Array[Int],
     |   vt : ValType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Unit {
     |   match vt {
     |     RefTypeValType(rt) =>
     |       match rt {
     |         HeapTypeRefType(_, ht) =>
     |           match ht {
     |             HeapType(type_idx) =>
 132 |               match sr_resolve_type_idx(type_idx, group_start, total) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(idx) => out.push(idx)
     |                 None => ()
     |               }
     |             _ => ()
     |           }
     |         _ => ()
     |       }
 140 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sr_collect_storage_refs(
     |   out : Array[Int],
     |   st : StorageType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Unit {
 151 |   match st {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     ValTypeStorageType(vt) =>
 153 |       sr_collect_valtype_refs(out, vt, group_start, total)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => ()
     |   }
     | }
     …

     | fn sr_collect_subtype_refs(
     |   subtype : SubType,
     |   group_start : Int,
     |   total : Int,
     | ) -> Array[Int] {
     |   let out : Array[Int] = []
     |   for super_idx in subtype.super_types() {
 166 |     match sr_resolve_type_idx(super_idx, group_start, total) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(idx) => out.push(idx)
     |       None => ()
     |     }
     |   }
     |   match subtype.get_comptype() {
     |     FuncCompType(params, results) => {
     |       for p in params {
     |         sr_collect_valtype_refs(out, p, group_start, total)
     |       }
     |       for r in results {
 177 |         sr_collect_valtype_refs(out, r, group_start, total)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     StructCompType(fields) =>
 181 |       for field in fields {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let FieldType(st, _) = field
     |         sr_collect_storage_refs(out, st, group_start, total)
     |       }
 185 |     ArrayCompType(field) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let FieldType(st, _) = field
 187 |       sr_collect_storage_refs(out, st, group_start, total)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn sr_collect_all_table_types(mod : Module) -> Array[TableType] {
     |   let out : Array[TableType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, TableExternType(table_type)) => out.push(table_type)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.table_sec {
     |     Some(TableSec(tables)) =>
 232 |       for table in tables {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let Table(table_type, _) = table
     |         out.push(table_type)
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn sr_mark_public_type(
     |   public_types : Set[Int],
     |   subtypes : Array[SubType],
     |   group_starts : Array[Int],
     |   total : Int,
     |   idx : Int,
     | ) -> Unit {
     |   let stack : Array[Int] = [idx]
     |   while !stack.is_empty() {
     |     let curr = stack.pop().unwrap()
     |     if curr < 0 || curr >= subtypes.length() || public_types.contains(curr) {
 276 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     public_types.add(curr)
     |     for
     |       ref_ in sr_collect_subtype_refs(subtypes[curr], group_starts[curr], total) {
 281 |       stack.push(ref_)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | }
     …

     | fn sr_mark_public_valtype(
     |   public_types : Set[Int],
     |   subtypes : Array[SubType],
     |   group_starts : Array[Int],
     |   total : Int,
     |   vt : ValType,
     | ) -> Unit {
     |   match vt {
     |     RefTypeValType(HeapTypeRefType(_, HeapType(type_idx))) =>
     |       match sr_resolve_type_idx(type_idx, 0, total) {
     |         Some(idx) =>
     |           sr_mark_public_type(public_types, subtypes, group_starts, total, idx)
 299 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn sr_mark_public_reftype(
     |   public_types : Set[Int],
     |   subtypes : Array[SubType],
     |   group_starts : Array[Int],
     |   total : Int,
     |   rt : RefType,
     | ) -> Unit {
     |   match rt {
     |     HeapTypeRefType(_, HeapType(type_idx)) =>
     |       match sr_resolve_type_idx(type_idx, 0, total) {
     |         Some(idx) =>
     |           sr_mark_public_type(public_types, subtypes, group_starts, total, idx)
 318 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 320 |     _ => ()
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sr_collect_public_types(
     |   mod : Module,
     |   subtypes : Array[SubType],
     |   group_starts : Array[Int],
     |   total : Int,
     |   func_type_idxs : Array[TypeIdx],
     | ) -> Set[Int] {
     |   let public_types : Set[Int] = Set::new()
     |   let global_types = sr_collect_all_global_types(mod)
     |   let table_types = sr_collect_all_table_types(mod)
     |   let tag_types = sr_collect_all_tag_types(mod)
     | 
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
     |       for import_ in imports {
     |         match import_ {
     |           Import(_, _, FuncExternType(type_idx)) =>
     |             match sr_resolve_type_idx(type_idx, 0, total) {
     |               Some(idx) =>
     |                 sr_mark_public_type(
     |                   public_types, subtypes, group_starts, total, idx,
     |                 )
 347 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           Import(_, _, TagExternType(TagType(type_idx))) =>
     |             match sr_resolve_type_idx(type_idx, 0, total) {
     |               Some(idx) =>
     |                 sr_mark_public_type(
     |                   public_types, subtypes, group_starts, total, idx,
     |                 )
 355 |               None => ()
     |               ^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           Import(_, _, GlobalExternType(GlobalType(vt, _))) =>
     |             sr_mark_public_valtype(
     |               public_types, subtypes, group_starts, total, vt,
     |             )
     |           Import(_, _, TableExternType(TableType(rt, _))) =>
     |             sr_mark_public_reftype(
     |               public_types, subtypes, group_starts, total, rt,
     |             )
 365 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         let Export(_, extern_idx) = export_
     |         match extern_idx {
 376 |           FuncExternIdx(FuncIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < func_type_idxs.length() {
 379 |               match sr_resolve_type_idx(func_type_idxs[idx], 0, total) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Some(type_abs) =>
 381 |                   sr_mark_public_type(
     |                   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     public_types, subtypes, group_starts, total, type_abs,
     |                   )
 384 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |           }
     |           GlobalExternIdx(GlobalIdx(raw)) => {
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < global_types.length() {
     |               let GlobalType(vt, _) = global_types[idx]
     |               sr_mark_public_valtype(
     |                 public_types, subtypes, group_starts, total, vt,
     |               )
     |             }
     |           }
 397 |           TableExternIdx(TableIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < table_types.length() {
 400 |               let TableType(rt, _) = table_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               sr_mark_public_reftype(
     |                 public_types, subtypes, group_starts, total, rt,
     |               )
     |             }
     |           }
 406 |           TagExternIdx(TagIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < tag_types.length() {
 409 |               let TagType(type_idx) = tag_types[idx]
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               match sr_resolve_type_idx(type_idx, 0, total) {
     |                 Some(type_abs) =>
 412 |                   sr_mark_public_type(
     |                   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     public_types, subtypes, group_starts, total, type_abs,
     |                   )
 415 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |           }
 419 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   let initially_public : Array[Int] = []
     |   for idx in public_types {
     |     initially_public.push(idx)
     |   }
     |   for idx in initially_public {
     |     let group_start = group_starts[idx]
     |     for i = 0; i < group_starts.length(); i = i + 1 {
     |       if group_starts[i] == group_start {
     |         public_types.add(i)
     |       }
     |     }
     |   }
     |   public_types
     | }
     …

     | fn sr_collect_subtypes(
     |   rec_types : Array[RecType],
     | ) -> (Array[SubType], Array[Int], Array[Array[Int]], Array[Bool]) {
     |   let subtypes : Array[SubType] = []
     |   let group_starts : Array[Int] = []
     |   let mut next = 0
     |   for rec in rec_types {
     |     match rec {
     |       SingleRecType(st) => {
     |         subtypes.push(st)
     |         group_starts.push(next)
     |         next += 1
     |       }
 454 |       GroupRecType(sts) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let start = next
     |         for st in sts {
 457 |           subtypes.push(st)
     |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           group_starts.push(start)
     |           next += 1
     |         }
     |       }
     |     }
     |   }
     | 
     |   let immediate_subs : Array[Array[Int]] = []
     |   let has_declared_super : Array[Bool] = []
     |   for _ in 0..<subtypes.length() {
     |     immediate_subs.push([])
     |     has_declared_super.push(false)
     |   }
     | 
     |   for i = 0; i < subtypes.length(); i = i + 1 {
     |     let supers = subtypes[i].super_types()
     |     if !supers.is_empty() {
     |       has_declared_super[i] = true
     |     }
     |     for super_idx in supers {
     |       match sr_resolve_type_idx(super_idx, group_starts[i], subtypes.length()) {
     |         Some(super_abs) => immediate_subs[super_abs].push(i)
 480 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | 
     |   (subtypes, group_starts, immediate_subs, has_declared_super)
     | }
     …

     | fn sr_mark_exports_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
     |       for export_ in exports {
     |         let Export(_, extern_idx) = export_
     |         match extern_idx {
 495 |           FuncExternIdx(FuncIdx(raw)) => {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let idx = raw.reinterpret_as_int()
     |             if idx >= 0 && idx < has_unseen.length() {
 498 |               has_unseen[idx] = true
     |               ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     | }
     …

     | fn sr_mark_elem_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
     |   match mod.elem_sec {
     |     Some(ElemSec(elems)) =>
     |       for elem in elems {
     |         let Elem(_, kind) = elem
     |         match kind {
     |           FuncsElemKind(funcs) =>
     |             for func_idx in funcs {
     |               let FuncIdx(raw) = func_idx
     |               let idx = raw.reinterpret_as_int()
     |               if idx >= 0 && idx < has_unseen.length() {
     |                 has_unseen[idx] = true
     |               }
     |             }
     |           FuncExprsElemKind(exprs) | TypedExprsElemKind(_, exprs) =>
     |             for expr in exprs {
     |               for instr in expr.0 {
     |                 match instr {
     |                   RefFunc(FuncIdx(raw)) => {
     |                     let idx = raw.reinterpret_as_int()
     |                     if idx >= 0 && idx < has_unseen.length() {
     |                       has_unseen[idx] = true
     |                     }
     |                   }
 546 |                   _ => ()
     |                   ^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               }
     |             }
     |         }
     |       }
     |     None => ()
     |   }
     | }
     …

     | fn sr_collect_func_types(env : Env, total : Int) -> Array[FuncType] {
     |   let out : Array[FuncType] = []
     |   for i = 0; i < total; i = i + 1 {
     |     let idx = FuncIdx::new(i.reinterpret_as_uint())
     |     match env.get_functype_by_funcidx(idx) {
     |       Some(ft) => out.push(ft)
 573 |       None => out.push(FuncType::new([], []))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   out
     | }
     …

     | fn sr_build_local_types_by_abs(
     |   func_types : Array[FuncType],
     |   funcs : Array[Func],
     |   import_func_count : Int,
     | ) -> Array[Array[ValType]] {
     |   let out : Array[Array[ValType]] = []
     |   for abs_idx = 0; abs_idx < func_types.length(); abs_idx = abs_idx + 1 {
     |     let FuncType(params, _) = func_types[abs_idx]
     |     let locals = params.copy()
     |     let def_idx = abs_idx - import_func_count
     |     if def_idx >= 0 && def_idx < funcs.length() {
     |       match funcs[def_idx] {
     |         TFunc(extra_locals, _) =>
     |           for vt in extra_locals {
 594 |             locals.push(vt)
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 596 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     out.push(locals)
     |   }
     |   out
     | }
     …

     | fn sr_is_func_heap(ht : HeapType, env : Env) -> Bool {
 606 |   match ht {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     AbsHeapTypeHeapType(FuncAbsHeapType) => true
     |     HeapType(tidx) =>
 609 |       match env.resolve_comptype(tidx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncCompType(_, _)) => true
     |         _ => false
     |       }
 613 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sr_common_ref_heap_supertype(
     |   a : HeapType,
     |   b : HeapType,
     |   env : Env,
     | ) -> HeapType? {
 623 |   if Match::matches(a, b, env) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return Some(b)
     |   }
     |   if Match::matches(b, a, env) {
 627 |     return Some(a)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let candidates = [
 631 |     AbsHeapType::i31(),
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AbsHeapType::struct_(),
     |     AbsHeapType::array(),
     |     AbsHeapType::eq(),
     |     AbsHeapType::func(),
     |     AbsHeapType::extern_(),
     |     AbsHeapType::exn(),
     |     AbsHeapType::any(),
     |   ]
     |   for abs in candidates {
 641 |     let super_ht = HeapType::abs(abs)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     if Match::matches(a, super_ht, env) && Match::matches(b, super_ht, env) {
 643 |       return Some(super_ht)
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   if sr_is_func_heap(a, env) && sr_is_func_heap(b, env) {
 648 |     return Some(HeapType::abs(AbsHeapType::func()))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   None
     | }
     …

     | fn sr_common_ref_type_supertype(
     |   a : RefType,
     |   b : RefType,
     |   env : Env,
     | ) -> RefType? {
 660 |   if Match::matches(a, b, env) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return Some(b)
     |   }
     |   if Match::matches(b, a, env) {
 664 |     return Some(a)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match
 667 |     sr_common_ref_heap_supertype(a.get_heap_type(), b.get_heap_type(), env) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(ht) => Some(RefType::new(a.is_nullable() || b.is_nullable(), ht))
     |     None => None
     |   }
     | }
     …

     | fn sr_common_val_supertype(a : ValType, b : ValType, env : Env) -> ValType? {
     |   if Match::matches(a, b, env) {
     |     return Some(b)
     |   }
     |   if Match::matches(b, a, env) {
 679 |     return Some(a)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 681 |   match (a, b) {
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (RefTypeValType(r0), RefTypeValType(r1)) =>
 683 |       match sr_common_ref_type_supertype(r0, r1, env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(rt) => Some(ValType::ref_type(rt))
     |         None => None
     |       }
 687 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sr_single_result_of_blocktype(bt : BlockType, env : Env) -> ValType? {
 693 |   match env.expand_blocktype(bt) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok((_, [vt])) => Some(vt)
     |     _ => None
     |   }
     | }
     …

     | fn sr_known_instr_type(
     |   instr : TInstr,
     |   caller_abs_idx : Int,
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     |   func_type_idxs : Array[TypeIdx],
     | ) -> ValType? {
     |   fn infer_texpr_type(texpr : TExpr) -> ValType? {
 709 |     let TExpr(instrs) = texpr
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     if instrs.is_empty() {
 711 |       None
     |       ^^^^ 	<-- UNCOVERED
     |     } else {
 713 |       sr_known_instr_type(
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         instrs[instrs.length() - 1],
     |         caller_abs_idx,
     |         local_types_by_abs,
     |         global_types,
     |         env,
     |         func_type_idxs,
     |       )
     |     }
     |   }
     | 
     |   match instr {
     |     TI32Const(_) => Some(ValType::i32())
 726 |     TI64Const(_) => Some(ValType::i64())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(_) => Some(ValType::f32())
     |     TF64Const(_) => Some(ValType::f64())
     |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 730 |       Some(ValType::v128())
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
 732 |     TRefFunc(_) => Some(ValType::funcref())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalGet(LocalIdx(raw)) => {
     |       let idx = raw.reinterpret_as_int()
     |       if caller_abs_idx < 0 || caller_abs_idx >= local_types_by_abs.length() {
 736 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let locals = local_types_by_abs[caller_abs_idx]
     |       if idx < 0 || idx >= locals.length() {
 740 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Some(locals[idx])
     |     }
     |     TGlobalGet(GlobalIdx(raw)) => {
     |       let idx = raw.reinterpret_as_int()
     |       if idx < 0 || idx >= global_types.length() {
 747 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Some(global_types[idx])
     |     }
     |     TLocalTee(_, value) =>
 752 |       sr_known_instr_type(
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         value, caller_abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |       )
     |     TRefAsNonNull(value) =>
     |       match
     |         sr_known_instr_type(
     |           value, caller_abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |         ) {
     |         Some(RefTypeValType(rt)) =>
     |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
 762 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TRefCast(nullable, ht, _) =>
 765 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TCall(target, _) | TReturnCall(target, _) =>
 767 |       match env.get_functype_by_funcidx(target) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
     |     TCallIndirect(type_idx, _, _, _)
     |     | TCallRef(type_idx, _, _)
     |     | TReturnCallIndirect(type_idx, _, _, _)
     |     | TReturnCallRef(type_idx, _, _) =>
 775 |       match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(_, [r])) => Some(r)
     |         _ => None
     |       }
 779 |     TBlock(bt, body) | TLoop(bt, body) | TTryTable(bt, _, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let from_body = infer_texpr_type(body)
     |       let from_bt = sr_single_result_of_blocktype(bt, env)
     |       match (from_body, from_bt) {
     |         (Some(t), Some(vt)) =>
 784 |           if Match::matches(t, vt, env) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(t)
     |           } else {
 787 |             Some(vt)
     |             ^^^^^^^^ 	<-- UNCOVERED
     |           }
 789 |         (Some(t), None) => Some(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (None, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
 794 |     TIf(bt, _, then_, else_) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let from_bt = sr_single_result_of_blocktype(bt, env)
     |       let from_branches = match else_ {
     |         Some(else_expr) =>
 798 |           match (infer_texpr_type(then_), infer_texpr_type(else_expr)) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             (Some(t), Some(e)) => sr_common_val_supertype(t, e, env)
     |             _ => None
     |           }
 802 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 804 |       match (from_branches, from_bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(t), Some(vt)) =>
 806 |           if Match::matches(t, vt, env) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(t)
     |           } else {
 809 |             Some(vt)
     |             ^^^^^^^^ 	<-- UNCOVERED
     |           }
 811 |         (Some(t), None) => Some(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (None, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
 816 |     TSelect(types, _, if_true, if_false) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let declared = match types {
     |         Some([vt]) => Some(vt)
     |         _ => None
     |       }
     |       let merged = match
 822 |         (
     |         ^ 	<-- UNCOVERED
     |           sr_known_instr_type(
     |             if_true, caller_abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |           ),
 826 |           sr_known_instr_type(
     |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             if_false, caller_abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |           ),
     |         ) {
 830 |         (Some(t), Some(f)) => sr_common_val_supertype(t, f, env)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
 833 |       match (merged, declared) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (Some(t), Some(vt)) =>
 835 |           if Match::matches(t, vt, env) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(t)
     |           } else {
 838 |             Some(vt)
     |             ^^^^^^^^ 	<-- UNCOVERED
     |           }
 840 |         (Some(t), None) => Some(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         (None, Some(vt)) => Some(vt)
     |         _ => None
     |       }
     |     }
 845 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sr_note_result_observation(
     |   type_abs : Int,
     |   observed : ValType,
     |   old_result : ValType,
     |   result_candidate : Array[ValType?],
     |   result_noted : Array[Bool],
     |   result_unknown : Array[Bool],
     |   env : Env,
     | ) -> Unit {
     |   if type_abs < 0 || type_abs >= result_candidate.length() {
 860 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   if !Match::matches(observed, old_result, env) {
 863 |     result_unknown[type_abs] = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return
     |   }
     |   match result_candidate[type_abs] {
     |     None => {
     |       result_candidate[type_abs] = Some(observed)
     |       result_noted[type_abs] = true
     |     }
     |     Some(prev) =>
     |       match sr_common_val_supertype(prev, observed, env) {
     |         Some(merged) =>
     |           if Match::matches(merged, old_result, env) {
     |             result_candidate[type_abs] = Some(merged)
     |             result_noted[type_abs] = true
     |           } else {
 878 |             result_unknown[type_abs] = true
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 880 |         None => result_unknown[type_abs] = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | fn sr_record_callsite(
     |   type_abs : Int,
     |   caller_abs_idx : Int,
     |   args : Array[TInstr],
     |   calls_by_type : Array[Array[SRCallSite]],
     | ) -> Unit {
     |   if type_abs < 0 || type_abs >= calls_by_type.length() {
 904 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   calls_by_type[type_abs].push(sr_callsite(caller_abs_idx, args.copy()))
     | }
     …

     | fn sr_update_param_types(
     |   body : TExpr,
     |   old_param_types : Array[ValType],
     |   new_param_types : Array[ValType],
     |   locals : Array[ValType],
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     |   abs_idx : Int,
     |   func_type_idxs : Array[TypeIdx],
     | ) -> (Array[ValType], TExpr) {
     |   let param_fixups : Map[Int, Int] = Map::new()
     |   let next_local = [old_param_types.length() + locals.length()]
     | 
     |   let scan_sets = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     _,
     |     instr,
     |   ) {
     |     match instr {
     |       TLocalSet(idx, value) | TLocalTee(idx, value) => {
     |         let local_i = sr_local_idx_to_int(idx)
     |         if local_i >= 0 &&
     |           local_i < old_param_types.length() &&
     |           !param_fixups.contains(local_i) {
     |           let compatible = match
     |             sr_known_instr_type(
     |               value, abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |             ) {
     |             Some(vt) => Match::matches(vt, new_param_types[local_i], env)
 951 |             None => false
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if !compatible {
     |             let fixup = next_local[0]
     |             next_local[0] = fixup + 1
     |             param_fixups[local_i] = fixup
     |           }
     |         }
     |       }
     |       _ => ()
     |     }
     |     self.walk_tinstruction_default((), instr)
     |   })
     |   ignore(scan_sets.walk_texpr((), body))
     | 
     |   let next_locals = locals.copy()
     |   let param_count = old_param_types.length()
     |   for i = 0; i < param_count; i = i + 1 {
     |     match param_fixups.get(i) {
     |       Some(_) => next_locals.push(old_param_types[i])
     |       None => ()
     |     }
     |   }
     | 
     |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
     |     let walked = match self.walk_tinstruction_default((), instr) {
     |       Ok(Some((_, out))) => out
     |       Ok(None) => instr
 979 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     match walked {
     |       TLocalGet(idx) => {
     |         let local_i = sr_local_idx_to_int(idx)
     |         match param_fixups.get(local_i) {
     |           Some(fixup) =>
     |             change((), TInstr::local_get(sr_local_idx_from_int(fixup)))
 987 |           None => if walked == instr { unchanged() } else { change((), walked) }
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       TLocalSet(idx, value) => {
     |         let local_i = sr_local_idx_to_int(idx)
     |         match param_fixups.get(local_i) {
     |           Some(fixup) =>
     |             change((), TInstr::local_set(sr_local_idx_from_int(fixup), value))
 995 |           None => if walked == instr { unchanged() } else { change((), walked) }
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
 998 |       TLocalTee(idx, value) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let local_i = sr_local_idx_to_int(idx)
     |         match param_fixups.get(local_i) {
     |           Some(fixup) =>
1002 |             change((), TInstr::local_tee(sr_local_idx_from_int(fixup), value))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => if walked == instr { unchanged() } else { change((), walked) }
     |         }
     |       }
     |       _ => if walked == instr { unchanged() } else { change((), walked) }
     |     }
     |   })
     | 
     |   let rewritten = match walker.walk_texpr((), body) {
     |     Ok(Some((_, out))) => out
1012 |     _ => body
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   if param_fixups.is_empty() {
     |     return (next_locals, rewritten)
     |   }
     | 
     |   let prologue : Array[TInstr] = []
     |   for i = 0; i < param_count; i = i + 1 {
     |     match param_fixups.get(i) {
     |       Some(fixup) =>
     |         prologue.push(
     |           TInstr::local_set(
     |             sr_local_idx_from_int(fixup),
     |             TInstr::local_get(sr_local_idx_from_int(i)),
     |           ),
     |         )
1029 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   let next_body = TExpr::new([..prologue, ..rewritten.0])
     |   (next_locals, next_body)
     | }
     …

     | fn sr_extract_signature_type_abs_from_instr(
     |   instr : TInstr,
     |   caller_abs_idx : Int,
     |   local_types_by_abs : Array[Array[ValType]],
     |   global_types : Array[ValType],
     |   env : Env,
     |   func_type_idxs : Array[TypeIdx],
     | ) -> Int? {
     |   match instr {
     |     TRefFunc(FuncIdx(raw)) => {
     |       let idx = raw.reinterpret_as_int()
     |       if idx < 0 || idx >= func_type_idxs.length() {
1050 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       } else {
     |         Some(sr_typeidx_raw(func_type_idxs[idx]))
     |       }
     |     }
     |     TRefAsNonNull(value) =>
1056 |       sr_extract_signature_type_abs_from_instr(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         value, caller_abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |       )
     |     _ =>
1060 |       match
     |       ^^^^^ 	<-- UNCOVERED
     |         sr_known_instr_type(
     |           instr, caller_abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |         ) {
     |         Some(RefTypeValType(HeapTypeRefType(_, HeapType(type_idx)))) =>
1065 |           Some(sr_typeidx_raw(type_idx))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => None
     |       }
     |   }
     | }
     …

     | fn sr_subtype_with_new_comptype(st : SubType, new_ct : CompType) -> SubType {
     |   match st {
1074 |     SubType(is_final, supers, _) => SubType::new(is_final, supers, new_ct)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     CompTypeSubType(_) => SubType::comp_type(new_ct)
     |   }
     | }
     …

     | fn sr_apply_new_signatures(
     |   type_recs : Array[RecType],
     |   new_sigs : Array[FuncType?],
     | ) -> Array[RecType] {
     |   let out : Array[RecType] = []
     |   let mut abs_idx = 0
     |   for rec in type_recs {
     |     match rec {
     |       SingleRecType(st) => {
     |         let next_st = match new_sigs[abs_idx] {
     |           Some(FuncType(params, results)) =>
     |             sr_subtype_with_new_comptype(st, CompType::func(params, results))
     |           None => st
     |         }
     |         out.push(RecType::new(next_st))
     |         abs_idx += 1
     |       }
1097 |       GroupRecType(sts) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         let next_group : Array[SubType] = []
     |         for st in sts {
1100 |           let next_st = match new_sigs[abs_idx] {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(FuncType(params, results)) =>
1102 |               sr_subtype_with_new_comptype(st, CompType::func(params, results))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             None => st
     |           }
1105 |           next_group.push(next_st)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           abs_idx += 1
     |         }
1108 |         out.push(RecType::group(next_group))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   out
     | }
     …

     | fn sr_refinalize_changed_functions(
     |   mod : Module,
     |   changed_type_abs : Array[Bool],
     |   func_type_idxs : Array[TypeIdx],
     | ) -> Result[Module, String] {
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(fs)) => fs
1123 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let import_func_count = sr_count_imported_funcs(mod)
     |   let env = Env::new().with_module(mod)
     |   let next_funcs = funcs.copy()
     |   let mut changed = false
     | 
     |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
     |     let abs_idx = import_func_count + def_idx
     |     if abs_idx < 0 || abs_idx >= func_type_idxs.length() {
1133 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let type_abs = sr_typeidx_raw(func_type_idxs[abs_idx])
     |     if type_abs < 0 ||
     |       type_abs >= changed_type_abs.length() ||
     |       !changed_type_abs[type_abs] {
     |       continue
     |     }
     |     match next_funcs[def_idx] {
     |       TFunc(locals, body) => {
     |         let params = match
     |           env.get_functype_by_funcidx(
     |             FuncIdx::new(abs_idx.reinterpret_as_uint()),
     |           ) {
     |           Some(FuncType(ps, _)) => ps
1148 |           None => []
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let all_locals = params.copy()
     |         all_locals.append(locals)
     |         let local_env = env.with_locals(all_locals)
     |         let lowered = body.to_expr()
     |         match to_texpr(lowered, local_env) {
     |           Ok(new_body) =>
     |             if new_body != body {
1157 |               next_funcs[def_idx] = Func::t_func(locals, new_body)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               changed = true
     |             }
1160 |           Err(_) => ()
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
1163 |       _ => return Err("signature_refining: expected TFunc")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   if changed {
1168 |     Ok(mod.with_code_sec(CodeSec::new(next_funcs)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
     |     Ok(mod)
     |   }
     | }
     …

     | fn signature_refining(mod : Module) -> Result[Module, String] {
     |   match mod.table_sec {
     |     Some(TableSec(tables)) if !tables.is_empty() => return Ok(mod)
     |     _ => ()
     |   }
     | 
     |   let type_recs = match mod.type_sec {
     |     Some(TypeSec(recs)) => recs.copy()
1183 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let funcs = match mod.code_sec {
     |     Some(CodeSec(fs)) => fs
1188 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let func_sec = match mod.func_sec {
     |     Some(FuncSec(type_idxs)) => type_idxs
1192 |     None => return Ok(mod)
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if funcs.is_empty() || func_sec.is_empty() {
1195 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let env = Env::new().with_module(mod)
     |   let func_type_idxs = sr_collect_func_type_idxs(mod)
     |   let total_func_count = func_type_idxs.length()
     |   if total_func_count == 0 {
1202 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let func_types = sr_collect_func_types(env, total_func_count)
     |   if func_types.length() != total_func_count {
1207 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let total_types = sr_flattened_type_count(type_recs)
     |   if total_types == 0 {
1212 |     return Ok(mod)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let import_func_count = sr_count_imported_funcs(mod)
     |   let import_call_without_effects = sr_collect_import_call_without_effects(mod)
     |   let global_types = sr_collect_global_types(mod)
     |   let local_types_by_abs = sr_build_local_types_by_abs(
     |     func_types, funcs, import_func_count,
     |   )
     | 
     |   let (subtypes, group_starts, immediate_subs, has_declared_super) = sr_collect_subtypes(
     |     type_recs,
     |   )
     | 
     |   let calls_by_type : Array[Array[SRCallSite]] = []
     |   let can_modify : Array[Bool] = Array::make(total_types, true)
     |   let can_modify_params : Array[Bool] = Array::make(total_types, true)
     |   let result_candidate : Array[ValType?] = Array::make(total_types, None)
     |   let result_noted : Array[Bool] = Array::make(total_types, false)
     |   let result_unknown : Array[Bool] = Array::make(total_types, false)
     | 
     |   for _ in 0..<total_types {
     |     calls_by_type.push([])
     |   }
     | 
     |   let has_unseen_calls : Array[Bool] = Array::make(total_func_count, false)
     |   sr_mark_exports_unseen(mod, has_unseen_calls)
     |   sr_mark_start_unseen(mod, has_unseen_calls)
     |   sr_mark_elem_unseen(mod, has_unseen_calls)
     |   let public_types = sr_collect_public_types(
     |     mod, subtypes, group_starts, total_types, func_type_idxs,
     |   )
     | 
     |   for abs_idx = 0; abs_idx < total_func_count; abs_idx = abs_idx + 1 {
     |     let type_abs = sr_typeidx_raw(func_type_idxs[abs_idx])
     |     if type_abs < 0 || type_abs >= total_types {
1248 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     if abs_idx < import_func_count {
     |       can_modify[type_abs] = false
     |       continue
     |     }
     | 
     |     let def_idx = abs_idx - import_func_count
     |     if def_idx < 0 || def_idx >= funcs.length() {
1258 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     let FuncType(_, old_results) = func_types[abs_idx]
     |     match funcs[def_idx] {
     |       TFunc(_, body) => {
     |         let walker = ModuleTransformer::new().on_tinstruction_evt(fn(
     |           self,
     |           _,
     |           instr,
     |         ) {
     |           match instr {
     |             TCall(target, args) | TReturnCall(target, args) => {
     |               let FuncIdx(raw) = target
     |               let callee_abs_idx = raw.reinterpret_as_int()
     |               if callee_abs_idx >= 0 && callee_abs_idx < total_func_count {
     |                 let callee_type_abs = sr_typeidx_raw(
     |                   func_type_idxs[callee_abs_idx],
     |                 )
     |                 sr_record_callsite(
     |                   callee_type_abs, abs_idx, args, calls_by_type,
     |                 )
     |                 if callee_abs_idx >= 0 &&
     |                   callee_abs_idx < import_call_without_effects.length() &&
     |                   import_call_without_effects[callee_abs_idx] &&
     |                   !args.is_empty() {
     |                   match
     |                     sr_extract_signature_type_abs_from_instr(
     |                       args[args.length() - 1],
     |                       abs_idx,
     |                       local_types_by_abs,
     |                       global_types,
     |                       env,
     |                       func_type_idxs,
     |                     ) {
     |                     Some(extra_type_abs) =>
     |                       sr_record_callsite(
     |                         extra_type_abs, abs_idx, args, calls_by_type,
     |                       )
1297 |                     None => ()
     |                     ^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |               }
     |             }
     |             TCallRef(type_idx, args, _) | TReturnCallRef(type_idx, args, _) => {
     |               let called_type_abs = sr_typeidx_raw(type_idx)
     |               sr_record_callsite(called_type_abs, abs_idx, args, calls_by_type)
     |             }
     |             TReturn(values) =>
1307 |               if old_results.length() == 1 {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 if values.length() != 1 {
     |                   result_unknown[type_abs] = true
     |                 } else {
1311 |                   match
     |                   ^^^^^ 	<-- UNCOVERED
     |                     sr_known_instr_type(
     |                       values[0],
     |                       abs_idx,
     |                       local_types_by_abs,
     |                       global_types,
     |                       env,
     |                       func_type_idxs,
     |                     ) {
     |                     Some(vt) =>
1321 |                       sr_note_result_observation(
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         type_abs,
     |                         vt,
     |                         old_results[0],
     |                         result_candidate,
     |                         result_noted,
     |                         result_unknown,
     |                         env,
     |                       )
1330 |                     None => result_unknown[type_abs] = true
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
     |               }
     |             _ => ()
     |           }
     |           self.walk_tinstruction_default((), instr)
     |         })
     |         ignore(walker.walk_texpr((), body))
     | 
     |         if old_results.length() == 1 && !body.0.is_empty() {
     |           let tail = body.0[body.0.length() - 1]
     |           match tail {
1343 |             TReturn(_) => ()
     |             ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             _ =>
     |               match
     |                 sr_known_instr_type(
     |                   tail, abs_idx, local_types_by_abs, global_types, env, func_type_idxs,
     |                 ) {
     |                 Some(vt) =>
     |                   sr_note_result_observation(
     |                     type_abs,
     |                     vt,
     |                     old_results[0],
     |                     result_candidate,
     |                     result_noted,
     |                     result_unknown,
     |                     env,
     |                   )
1359 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         }
     |       }
1364 |       _ => return Err("signature_refining: expected TFunc")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   for abs_idx = 0; abs_idx < total_func_count; abs_idx = abs_idx + 1 {
     |     if !has_unseen_calls[abs_idx] {
     |       continue
     |     }
     |     let type_abs = sr_typeidx_raw(func_type_idxs[abs_idx])
     |     if type_abs >= 0 && type_abs < total_types {
     |       can_modify_params[type_abs] = false
     |     }
     |   }
     | 
     |   for type_abs in public_types {
     |     if type_abs < 0 || type_abs >= total_types {
1380 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if env.resolve_functype(TypeIdx::new(type_abs.reinterpret_as_uint()))
     |       is Some(_) {
     |       can_modify[type_abs] = false
     |     }
     |   }
     | 
     |   match mod.tag_sec {
     |     Some(TagSec(tags)) =>
     |       for tag in tags {
     |         let TagType(type_idx) = tag
     |         let type_abs = sr_typeidx_raw(type_idx)
     |         if type_abs >= 0 && type_abs < total_types {
     |           can_modify[type_abs] = false
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   for type_abs = 0; type_abs < total_types; type_abs = type_abs + 1 {
     |     if !immediate_subs[type_abs].is_empty() || has_declared_super[type_abs] {
     |       can_modify[type_abs] = false
     |     }
     |   }
     | 
     |   let new_sigs : Array[FuncType?] = Array::make(total_types, None)
     |   let changed_type_abs : Array[Bool] = Array::make(total_types, false)
     |   let mut any_sig_change = false
     | 
     |   for type_abs = 0; type_abs < total_types; type_abs = type_abs + 1 {
     |     if !can_modify[type_abs] {
     |       continue
     |     }
     | 
     |     let old_sig = match
     |       env.resolve_functype(TypeIdx::new(type_abs.reinterpret_as_uint())) {
     |       Some(ft) => ft
1418 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let FuncType(old_params, old_results) = old_sig
     | 
     |     let mut new_params = old_params
     |     if can_modify_params[type_abs] && old_params.length() > 0 {
     |       let calls = calls_by_type[type_abs]
     |       if !calls.is_empty() {
     |         let candidate_params : Array[ValType] = []
     |         let all_known = [true]
     |         for p = 0; p < old_params.length(); p = p + 1 {
     |           let old_param = old_params[p]
     |           let candidate : Array[ValType?] = [None]
     |           for callsite in calls {
     |             if p >= callsite.args.length() {
1433 |               all_known[0] = false
     |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               break
     |             }
     |             match
     |               sr_known_instr_type(
     |                 callsite.args[p],
     |                 callsite.caller_abs_idx,
     |                 local_types_by_abs,
     |                 global_types,
     |                 env,
     |                 func_type_idxs,
     |               ) {
     |               Some(arg_ty) => {
     |                 if !Match::matches(arg_ty, old_param, env) {
1447 |                   all_known[0] = false
     |                   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   break
     |                 }
     |                 candidate[0] = match candidate[0] {
     |                   None => Some(arg_ty)
     |                   Some(prev) => sr_common_val_supertype(prev, arg_ty, env)
     |                 }
     |                 if candidate[0] is None {
1455 |                   all_known[0] = false
     |                   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   break
     |                 }
     |               }
1459 |               None => {
     |               ^^^^^^^^^ 	<-- UNCOVERED
     |                 all_known[0] = false
     |                 break
     |               }
     |             }
     |           }
     |           if !all_known[0] {
1466 |             break
     |             ^^^^^ 	<-- UNCOVERED
     |           }
     |           match candidate[0] {
     |             Some(vt) =>
     |               if Match::matches(vt, old_param, env) {
     |                 candidate_params.push(vt)
     |               } else {
1473 |                 all_known[0] = false
     |                 ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1475 |             None => all_known[0] = false
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if !all_known[0] {
1478 |             break
     |             ^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     | 
     |         if all_known[0] && candidate_params.length() == old_params.length() {
     |           new_params = candidate_params
     |         }
     |       }
     |     }
     | 
     |     let mut new_results = old_results
     |     if old_results.length() == 1 &&
     |       result_noted[type_abs] &&
     |       !result_unknown[type_abs] {
     |       match result_candidate[type_abs] {
     |         Some(vt) if Match::matches(vt, old_results[0], env) =>
     |           new_results = [vt]
1495 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     if new_params != old_params || new_results != old_results {
     |       new_sigs[type_abs] = Some(FuncType::new(new_params, new_results))
     |       changed_type_abs[type_abs] = true
     |       any_sig_change = true
     |     }
     |   }
     | 
     |   if !any_sig_change {
     |     return Ok(mod)
     |   }
     | 
     |   let next_type_recs = sr_apply_new_signatures(type_recs, new_sigs)
     | 
     |   let next_funcs = funcs.copy()
     |   let mut changed_code = false
     |   for def_idx = 0; def_idx < funcs.length(); def_idx = def_idx + 1 {
     |     let abs_idx = import_func_count + def_idx
     |     if abs_idx < 0 || abs_idx >= total_func_count {
1517 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let type_abs = sr_typeidx_raw(func_type_idxs[abs_idx])
     |     if type_abs < 0 || type_abs >= total_types {
1521 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let new_sig = match new_sigs[type_abs] {
     |       Some(sig) => sig
     |       None => continue
     |     }
     |     let FuncType(old_params, _) = func_types[abs_idx]
     |     let FuncType(new_params, _) = new_sig
     |     if old_params == new_params {
     |       continue
     |     }
     | 
     |     match funcs[def_idx] {
     |       TFunc(locals, body) => {
     |         let (new_locals, new_body) = sr_update_param_types(
     |           body, old_params, new_params, locals, local_types_by_abs, global_types,
     |           env, abs_idx, func_type_idxs,
     |         )
     |         if new_locals != locals || new_body != body {
     |           next_funcs[def_idx] = Func::t_func(new_locals, new_body)
     |           changed_code = true
     |         }
     |       }
1544 |       _ => return Err("signature_refining: expected TFunc")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   let out = mod.with_type_sec(TypeSec::new(next_type_recs))
     |   let out = if changed_code {
     |     out.with_code_sec(CodeSec::new(next_funcs))
     |   } else {
     |     out
     |   }
     | 
     |   sr_refinalize_changed_functions(out, changed_type_abs, func_type_idxs)
     | }
     …

     | fn run_signature_refining(mod : Module) -> Module {
     |   match signature_refining(mod) {
     |     Ok(out) => out
1816 |     Err(_) => mod
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

115 uncovered line(s) in src/passes/simplify_globals.mbt:

     | fn sg_count_imported_globals(mod : Module) -> Int {
     |   let mut n = 0
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  74 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(_)) => n += 1
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   n
     | }
     …

     | fn sg_collect_global_types(mod : Module) -> Array[GlobalType] {
     |   let out : Array[GlobalType] = []
     |   match mod.import_sec {
     |     Some(ImportSec(imports)) =>
  90 |       for import_ in imports {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match import_ {
     |           Import(_, _, GlobalExternType(gt)) => out.push(gt)
     |           _ => ()
     |         }
     |       }
     |     None => ()
     |   }
     |   match mod.global_sec {
     |     Some(GlobalSec(globals)) =>
     |       for global in globals {
     |         let Global(gt, _) = global
     |         out.push(gt)
     |       }
 104 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   out
     | }
     …

     | fn sg_defined_index(
     |   imported_globals : Int,
     |   defined_count : Int,
     |   idx : GlobalIdx,
     | ) -> Int? {
     |   let raw = sg_globalidx_to_int(idx)
     |   let def = raw - imported_globals
     |   if def >= 0 && def < defined_count {
     |     Some(def)
     |   } else {
 120 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sg_const_value_from_instruction(instr : Instruction) -> SGConstValue? {
     |   match instr {
     |     I32Const(v) => Some(SGConstValue::SGI32(v))
 128 |     I64Const(v) => Some(SGConstValue::SGI64(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F32Const(v) => Some(SGConstValue::SGF32(v))
     |     F64Const(v) => Some(SGConstValue::SGF64(v))
     |     RefNull(ht) => Some(SGConstValue::SGRefNull(ht))
     |     RefFunc(idx) => Some(SGConstValue::SGRefFunc(idx))
     |     _ => None
     |   }
     | }
     …

     | fn sg_const_value_from_tinstr(instr : TInstr) -> SGConstValue? {
     |   match instr {
     |     TI32Const(v) => Some(SGConstValue::SGI32(v))
 141 |     TI64Const(v) => Some(SGConstValue::SGI64(v))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TF32Const(v) => Some(SGConstValue::SGF32(v))
     |     TF64Const(v) => Some(SGConstValue::SGF64(v))
     |     TRefNull(ht) => Some(SGConstValue::SGRefNull(ht))
     |     TRefFunc(idx) => Some(SGConstValue::SGRefFunc(idx))
     |     _ => None
     |   }
     | }
     …

     | fn sg_const_value_from_expr(expr : Expr) -> SGConstValue? {
     |   match expr {
     |     Expr([instr]) => sg_const_value_from_instruction(instr)
 154 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sg_const_value_to_instruction(value : SGConstValue) -> Instruction {
     |   match value {
     |     SGI32(v) => Instruction::i32_const(v)
 162 |     SGI64(v) => Instruction::i64_const(v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     SGF32(v) => Instruction::f32_const(v)
     |     SGF64(v) => Instruction::f64_const(v)
     |     SGRefNull(ht) => Instruction::ref_null(ht)
     |     SGRefFunc(idx) => Instruction::ref_func(idx)
     |   }
     | }
     …

     | fn sg_const_value_to_tinstr(value : SGConstValue) -> TInstr {
     |   match value {
     |     SGI32(v) => TInstr::i32_const(v)
 174 |     SGI64(v) => TInstr::i64_const(v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     SGF32(v) => TInstr::f32_const(v)
     |     SGF64(v) => TInstr::f64_const(v)
     |     SGRefNull(ht) => TInstr::ref_null(ht)
     |     SGRefFunc(idx) => TInstr::ref_func(idx)
     |   }
     | }
     …

     | fn sg_mark_shallow_effects(instr : TInstr, effects : SGEffects) -> Unit {
     |   match instr {
     |     TGlobalGet(idx) => effects.globals_read.add(idx)
     |     TGlobalSet(idx, _) => effects.globals_written.add(idx)
     |     TLocalSet(_, _) | TLocalTee(_, _) =>
 188 |       effects.has_non_global_side_effects = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLoad(_, _, _) | TStore(_, _, _, _) =>
 190 |       effects.has_non_global_side_effects = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TMemoryGrow(_, _)
     |     | TMemorySize(_)
     |     | TMemoryCopy(_, _, _, _, _)
     |     | TMemoryFill(_, _, _, _)
     |     | TMemoryInit(_, _, _, _, _)
     |     | TDataDrop(_)
     |     | TTableGet(_, _)
     |     | TTableSet(_, _, _)
     |     | TTableGrow(_, _, _)
     |     | TTableSize(_)
     |     | TTableFill(_, _, _, _)
     |     | TTableCopy(_, _, _, _, _)
     |     | TTableInit(_, _, _, _, _)
 204 |     | TElemDrop(_) => effects.has_non_global_side_effects = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TCall(_, _) | TCallIndirect(_, _, _, _) | TCallRef(_, _, _) => {
     |       effects.calls = true
     |       effects.has_non_global_side_effects = true
     |     }
     |     TReturnCall(_, _)
     |     | TReturnCallIndirect(_, _, _, _)
     |     | TReturnCallRef(_, _, _)
     |     | TBr(_, _)
     |     | TBrIf(_, _, _)
     |     | TBrTable(_, _, _, _)
     |     | TBrOnNull(_, _, _)
     |     | TBrOnNonNull(_, _, _)
     |     | TBrOnCast(_, _, _, _, _, _)
     |     | TBrOnCastFail(_, _, _, _, _, _)
     |     | TReturn(_)
     |     | TThrow(_, _)
 221 |     | TThrowRef(_) => effects.has_non_global_side_effects = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TUnreachable | TRefAsNonNull(_) | TRefCast(_, _, _) =>
 223 |       effects.has_non_global_side_effects = true
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TStructGet(_, _, _)
     |     | TStructGetS(_, _, _)
     |     | TStructGetU(_, _, _)
     |     | TStructSet(_, _, _, _)
     |     | TStructNew(_, _)
     |     | TStructNewDefault(_)
     |     | TArrayNew(_, _, _)
     |     | TArrayNewDefault(_, _)
     |     | TArrayNewFixed(_, _)
     |     | TArrayNewData(_, _, _, _)
     |     | TArrayNewElem(_, _, _, _)
     |     | TArrayGet(_, _, _)
     |     | TArrayGetS(_, _, _)
     |     | TArrayGetU(_, _, _)
     |     | TArraySet(_, _, _, _)
     |     | TArrayLen(_)
     |     | TArrayFill(_, _, _, _, _)
     |     | TArrayCopy(_, _, _, _, _, _, _)
     |     | TArrayInitData(_, _, _, _, _, _)
     |     | TArrayInitElem(_, _, _, _, _, _)
     |     | TI31GetS(_)
     |     | TI31GetU(_)
 246 |     | TRefI31(_) => effects.has_non_global_side_effects = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TBinary(op, _, _) =>
 248 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I32DivSOp
     |         | I32DivUOp
     |         | I32RemSOp
     |         | I32RemUOp
     |         | I64DivSOp
     |         | I64DivUOp
     |         | I64RemSOp
 256 |         | I64RemUOp => effects.has_non_global_side_effects = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |     TUnary(op, _) =>
 260 |       match op {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         I32TruncF32SOp
     |         | I32TruncF32UOp
     |         | I32TruncF64SOp
     |         | I32TruncF64UOp
     |         | I64TruncF32SOp
     |         | I64TruncF32UOp
     |         | I64TruncF64SOp
 268 |         | I64TruncF64UOp => effects.has_non_global_side_effects = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     | }
     …

     | fn sg_collect_effects_instr(instr : TInstr, effects : SGEffects) -> Unit {
     |   sg_mark_shallow_effects(instr, effects)
     |   match instr {
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 280 |       for item in body.0 {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         sg_collect_effects_instr(item, effects)
     |       }
 283 |     TIf(_, cond, then_body, else_body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       sg_collect_effects_instr(cond, effects)
     |       for item in then_body.0 {
 286 |         sg_collect_effects_instr(item, effects)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 288 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) =>
 290 |           for item in other.0 {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             sg_collect_effects_instr(item, effects)
     |           }
 293 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         sg_collect_effects_instr(child, effects)
     |       }
     |   }
     | }
     …

     | fn sg_reads_global_only_to_write_it(
     |   condition : TInstr,
     |   code : TExpr,
     | ) -> GlobalIdx? {
     |   let code_effects = sg_collect_effects_texpr(code)
     |   if code_effects.globals_written.length() != 1 {
     |     return None
     |   }
     |   if code_effects.has_non_global_side_effects || code_effects.calls {
 322 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut written : GlobalIdx? = None
     |   for idx in code_effects.globals_written {
     |     written = Some(idx)
     |   }
     |   let written = match written {
     |     Some(idx) => idx
 330 |     None => return None
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let cond_effects = SGEffects::new()
     |   sg_collect_effects_instr(condition, cond_effects)
     |   if !cond_effects.globals_read.contains(written) {
 335 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if cond_effects.has_unremovable_side_effects() {
 338 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Some(written)
     | }
     …

     | fn sg_analyze(mod : Module) -> Result[(SGInfo, Module, Bool), String] {
     |   let imported_globals = sg_count_imported_globals(mod)
     |   let defined_globals = match mod.global_sec {
     |     Some(GlobalSec(globals)) => globals
 348 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let total_globals = imported_globals + defined_globals.length()
     |   let info = SGInfo::new(total_globals)
     | 
     |   for i = 0; i < imported_globals; i = i + 1 {
 354 |     info.imported[i] = true
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match mod.export_sec {
     |     Some(ExportSec(exports)) =>
 358 |       for ex in exports {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match ex {
     |           Export(_, GlobalExternIdx(idx)) => {
     |             let raw = sg_globalidx_to_int(idx)
     |             if raw >= 0 && raw < total_globals {
 363 |               info.exported[raw] = true
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           }
 366 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     None => ()
     |   }
     | 
     |   let scanner = ModuleTransformer::new()
     |     .on_tinstruction_evt(fn(self, _, instr) {
     |       match instr {
     |         TGlobalSet(idx, value) => {
     |           let raw = sg_globalidx_to_int(idx)
     |           if raw >= 0 && raw < total_globals {
     |             info.written[raw] = info.written[raw] + 1
     |             if info.imported[raw] {
 380 |               info.non_init_written[raw] = true
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             } else {
     |               match
     |                 sg_defined_index(
     |                   imported_globals,
     |                   defined_globals.length(),
     |                   idx,
     |                 ) {
     |                 Some(def_idx) => {
     |                   let Global(_, init) = defined_globals[def_idx]
     |                   match
     |                     (
     |                       sg_const_value_from_tinstr(value),
     |                       sg_const_value_from_expr(init),
     |                     ) {
     |                     (Some(written_v), Some(init_v)) =>
     |                       if written_v != init_v {
     |                         info.non_init_written[raw] = true
     |                       }
 399 |                     _ => info.non_init_written[raw] = true
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 }
 402 |                 None => info.non_init_written[raw] = true
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |           }
     |         }
     |         TGlobalGet(idx) => {
     |           let raw = sg_globalidx_to_int(idx)
     |           if raw >= 0 && raw < total_globals {
     |             info.read[raw] = info.read[raw] + 1
     |           }
     |         }
     |         TIf(_, cond, then_body, None) =>
     |           match sg_reads_global_only_to_write_it(cond, then_body) {
     |             Some(idx) => {
     |               let raw = sg_globalidx_to_int(idx)
     |               if raw >= 0 && raw < total_globals {
     |                 info.read_only_to_write[raw] = info.read_only_to_write[raw] + 1
     |               }
     |             }
     |             None => ()
     |           }
     |         _ => ()
     |       }
     |       self.walk_tinstruction_default((), instr)
     |     })
     |     .on_instruction_evt(fn(self, _, instr) {
     |       match instr {
     |         GlobalGet(idx) => {
     |           let raw = sg_globalidx_to_int(idx)
     |           if raw >= 0 && raw < total_globals {
     |             info.read[raw] = info.read[raw] + 1
     |           }
     |         }
 435 |         GlobalSet(idx) => {
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let raw = sg_globalidx_to_int(idx)
     |           if raw >= 0 && raw < total_globals {
 438 |             info.written[raw] = info.written[raw] + 1
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             info.non_init_written[raw] = true
     |           }
     |         }
     |         _ => ()
     |       }
     |       self.walk_instruction_default((), instr)
     |     })
     |     .on_func_evt(fn(self, _, func) {
     |       match func {
     |         TFunc(_, TExpr(instrs)) if instrs.length() == 2 =>
     |           match instrs[0] {
     |             TIf(_, cond, TExpr([TReturn(values)]), None) if values.length() == 0 =>
 451 |               match
     |               ^^^^^ 	<-- UNCOVERED
     |                 sg_reads_global_only_to_write_it(cond, TExpr::new([instrs[1]])) {
     |                 Some(idx) => {
     |                   let raw = sg_globalidx_to_int(idx)
     |                   if raw >= 0 && raw < total_globals {
 456 |                     info.read_only_to_write[raw] = info.read_only_to_write[raw] +
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       1
     |                   }
     |                 }
 460 |                 None => ()
     |                 ^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ => ()
     |           }
     |         _ => ()
     |       }
     |       self.walk_func_default((), func)
     |     })
     |   match scanner.walk_module((), mod) {
     |     Ok(_) => ()
 470 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let mut changed = false
     |   let next_mod = match mod.global_sec {
     |     Some(GlobalSec(globals)) => {
     |       let rewritten = globals.copy()
     |       for i = 0; i < rewritten.length(); i = i + 1 {
     |         let abs = imported_globals + i
     |         let Global(GlobalType(vt, is_mut), init) = rewritten[i]
     |         if is_mut &&
     |           !info.imported[abs] &&
     |           !info.exported[abs] &&
     |           info.written[abs] == 0 {
 484 |           rewritten[i] = Global::new(GlobalType::new(vt, false), init)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           changed = true
     |         }
     |       }
     |       if changed {
 489 |         mod.with_global_sec(GlobalSec::new(rewritten))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
     |         mod
     |       }
     |     }
 494 |     None => mod
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   Ok((info, next_mod, changed))
     | }
     …

     | fn sg_init_single_instruction(
     |   globals : Array[Global],
     |   imported_globals : Int,
     |   idx : GlobalIdx,
     | ) -> Instruction? {
     |   match sg_defined_index(imported_globals, globals.length(), idx) {
     |     Some(def_idx) =>
     |       match globals[def_idx] {
     |         Global(_, Expr([instr])) => Some(instr)
 510 |         _ => None
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
 512 |     None => None
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sg_fold_single_uses(mod : Module, info : SGInfo) -> (Module, Bool) {
     |   let globals = match mod.global_sec {
     |     Some(GlobalSec(globals)) => globals
 520 |     None => return (mod, false)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let imported_globals = sg_count_imported_globals(mod)
     |   let rewritten = globals.copy()
     |   let mut changed = false
     |   for i = 0; i < rewritten.length(); i = i + 1 {
     |     let Global(gt, Expr(instrs)) = rewritten[i]
     |     let next_instrs : Array[Instruction] = []
     |     let mut local_changed = false
     |     for instr in instrs {
     |       match instr {
     |         GlobalGet(idx) => {
     |           let raw = sg_globalidx_to_int(idx)
     |           if raw >= 0 &&
     |             raw < info.read.length() &&
     |             info.written[raw] == 0 &&
     |             info.read[raw] == 1 &&
     |             !info.exported[raw] {
     |             match sg_init_single_instruction(globals, imported_globals, idx) {
     |               Some(rep) => {
     |                 next_instrs.push(rep)
     |                 local_changed = true
     |               }
 543 |               None => next_instrs.push(instr)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           } else {
 546 |             next_instrs.push(instr)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         _ => next_instrs.push(instr)
     |       }
     |     }
     |     if local_changed {
     |       rewritten[i] = Global::new(gt, Expr::new(next_instrs))
     |       changed = true
     |     }
     |   }
     |   if changed {
     |     (mod.with_global_sec(GlobalSec::new(rewritten)), true)
     |   } else {
     |     (mod, false)
     |   }
     | }
     …

     | fn sg_remove_unneeded_writes(
     |   mod : Module,
     |   info : SGInfo,
     | ) -> Result[(Module, Bool, Bool), String] {
     |   let globals = match mod.global_sec {
     |     Some(GlobalSec(globals)) => globals
 571 |     None => return Ok((mod, false, false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let imported_globals = sg_count_imported_globals(mod)
     |   let to_remove : Set[GlobalIdx] = Set::new()
     |   let rewritten_globals = globals.copy()
     |   let mut changed_globals = false
     |   let mut more = false
     | 
     |   for i = 0; i < rewritten_globals.length(); i = i + 1 {
     |     let abs = imported_globals + i
     |     if abs < 0 || abs >= info.written.length() {
 582 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if info.written[abs] == 0 {
     |       continue
     |     }
     |     if info.imported[abs] || info.exported[abs] {
 588 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let only_read_only = info.read[abs] == info.read_only_to_write[abs]
     |     if info.read[abs] == 0 || !info.non_init_written[abs] || only_read_only {
     |       to_remove.add(sg_globalidx_from_int(abs))
     |       if only_read_only {
     |         more = true
     |       }
     |       let Global(GlobalType(vt, is_mut), init) = rewritten_globals[i]
     |       if is_mut {
     |         rewritten_globals[i] = Global::new(GlobalType::new(vt, false), init)
     |         changed_globals = true
     |       }
     |     }
     |   }
     | 
     |   let mut next_mod = if changed_globals {
     |     mod.with_global_sec(GlobalSec::new(rewritten_globals))
     |   } else {
     |     mod
     |   }
     |   if to_remove.is_empty() {
     |     return Ok((next_mod, changed_globals, more))
     |   }
     | 
     |   let remover = ModuleTransformer::new().on_tinstruction_evt(fn(
     |     self,
     |     _,
     |     instr,
     |   ) {
     |     match instr {
     |       TGlobalSet(idx, value) =>
     |         if to_remove.contains(idx) {
     |           change((), TInstr::drop(value))
     |         } else {
 623 |           self.walk_tinstruction_default((), instr)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => self.walk_tinstruction_default((), instr)
     |     }
     |   })
     |   match remover.walk_module((), next_mod) {
     |     Ok(Some((_, out))) => {
     |       next_mod = out
     |       Ok((next_mod, true, more))
     |     }
 633 |     Ok(None) => Ok((next_mod, changed_globals, more))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn sg_global_is_mutable(
     |   global_types : Array[GlobalType],
     |   idx : GlobalIdx,
     | ) -> Bool {
 643 |   let raw = sg_globalidx_to_int(idx)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   if raw < 0 || raw >= global_types.length() {
 645 |     return true
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let GlobalType(_, is_mut) = global_types[raw]
     |   is_mut
     | }
     …

     | fn sg_same_global_val_type(
     |   global_types : Array[GlobalType],
     |   a : GlobalIdx,
     |   b : GlobalIdx,
     | ) -> Bool {
 657 |   let ia = sg_globalidx_to_int(a)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let ib = sg_globalidx_to_int(b)
     |   if ia < 0 ||
     |     ib < 0 ||
     |     ia >= global_types.length() ||
     |     ib >= global_types.length() {
 663 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let GlobalType(va, _) = global_types[ia]
     |   let GlobalType(vb, _) = global_types[ib]
     |   va == vb
     | }
     …

     | fn sg_prefer_earlier_imports(mod : Module) -> Result[(Module, Bool), String] {
     |   let globals = match mod.global_sec {
     |     Some(GlobalSec(globals)) => globals
 674 |     None => return Ok((mod, false))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let imported_globals = sg_count_imported_globals(mod)
     |   let global_types = sg_collect_global_types(mod)
     |   let copied_parent_map : Map[GlobalIdx, GlobalIdx] = Map::new()
     | 
     |   for i = 0; i < globals.length(); i = i + 1 {
     |     let child = sg_globalidx_from_int(imported_globals + i)
     |     let Global(GlobalType(_, is_mut), init) = globals[i]
     |     if is_mut {
     |       continue
     |     }
     |     match init {
     |       Expr([GlobalGet(parent)]) =>
 688 |         if !sg_global_is_mutable(global_types, parent) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           copied_parent_map[child] = parent
     |         }
     |       _ => ()
     |     }
     |   }
     |   if copied_parent_map.is_empty() {
     |     return Ok((mod, false))
     |   }
     | 
     |   let keys : Array[GlobalIdx] = []
     |   for entry in copied_parent_map {
 700 |     let (child, _) = entry
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     keys.push(child)
     |   }
     |   for child in keys {
 704 |     let mut curr = copied_parent_map.get(child).unwrap_or(child)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     while true {
 706 |       match copied_parent_map.get(curr) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(next) => curr = next
     |         None => break
     |       }
     |     }
     |     copied_parent_map[child] = curr
     |   }
     | 
 714 |   let rewriter = ModuleTransformer::new()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     .on_tinstruction_evt(fn(self, _, instr) {
     |       match instr {
     |         TGlobalGet(idx) =>
 718 |           match copied_parent_map.get(idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(parent) =>
 720 |               if sg_same_global_val_type(global_types, idx, parent) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change((), TInstr::global_get(parent))
     |               } else {
 723 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 725 |             None => unchanged()
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 727 |         _ => self.walk_tinstruction_default((), instr)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
 730 |     .on_instruction_evt(fn(self, _, instr) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match instr {
     |         GlobalGet(idx) =>
 733 |           match copied_parent_map.get(idx) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(parent) =>
 735 |               if sg_same_global_val_type(global_types, idx, parent) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 change((), Instruction::global_get(parent))
     |               } else {
 738 |                 unchanged()
     |                 ^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
 740 |             None => unchanged()
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 742 |         _ => self.walk_instruction_default((), instr)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
 745 |   match rewriter.walk_module((), mod) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(Some((_, out))) => Ok((out, true))
     |     Ok(None) => Ok((mod, false))
     |     Err(e) => Err(e)
     |   }
     | }
     …

     | fn sg_apply_const_globals_in_expr(
     |   expr : Expr,
     |   constants : Map[GlobalIdx, SGConstValue],
     | ) -> (Expr, Bool) {
     |   let Expr(instrs) = expr
     |   let out : Array[Instruction] = []
     |   let mut changed = false
     |   for instr in instrs {
     |     match instr {
     |       GlobalGet(idx) =>
     |         match constants.get(idx) {
     |           Some(value) => {
     |             out.push(sg_const_value_to_instruction(value))
     |             changed = true
     |           }
 768 |           None => out.push(instr)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => out.push(instr)
     |     }
     |   }
     |   (Expr::new(out), changed)
     | }
     …

     | fn sg_propagate_constants_to_globals(mod : Module) -> (Module, Bool) {
     |   let imported_globals = sg_count_imported_globals(mod)
     |   let constants : Map[GlobalIdx, SGConstValue] = Map::new()
     |   let mut changed = false
     |   let mut out_mod = mod
     | 
     |   match out_mod.global_sec {
     |     Some(GlobalSec(globals)) => {
     |       let rewritten = globals.copy()
     |       for i = 0; i < rewritten.length(); i = i + 1 {
     |         let idx = sg_globalidx_from_int(imported_globals + i)
     |         let Global(gt, init) = rewritten[i]
     |         let (next_init, init_changed) = sg_apply_const_globals_in_expr(
     |           init, constants,
     |         )
     |         if init_changed {
     |           changed = true
     |         }
     |         rewritten[i] = Global::new(gt, next_init)
     |         match sg_const_value_from_expr(next_init) {
     |           Some(value) => constants[idx] = value
 798 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       out_mod = out_mod.with_global_sec(GlobalSec::new(rewritten))
     |     }
 803 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   match out_mod.elem_sec {
 807 |     Some(ElemSec(elems)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rewritten : Array[Elem] = []
     |       let mut local_changed = false
     |       for elem in elems {
 811 |         match elem {
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Elem(Active(table_idx, offset), kind) => {
     |             let (next_offset, offset_changed) = sg_apply_const_globals_in_expr(
     |               offset, constants,
     |             )
     |             if offset_changed {
 817 |               local_changed = true
     |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
 819 |             rewritten.push(
     |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Elem::new(ElemMode::active(table_idx, next_offset), kind),
     |             )
     |           }
 823 |           _ => rewritten.push(elem)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       if local_changed {
 827 |         changed = true
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         out_mod = out_mod.with_elem_sec(ElemSec::new(rewritten))
     |       }
     |     }
     |     None => ()
     |   }
     | 
     |   match out_mod.data_sec {
     |     Some(DataSec(datas)) => {
     |       let rewritten : Array[Data] = []
     |       let mut local_changed = false
     |       for data in datas {
     |         match data {
     |           Data(Active(mem_idx, offset), bytes) => {
     |             let (next_offset, offset_changed) = sg_apply_const_globals_in_expr(
     |               offset, constants,
     |             )
     |             if offset_changed {
     |               local_changed = true
     |             }
     |             rewritten.push(
     |               Data::new(DataMode::active(mem_idx, next_offset), bytes),
     |             )
     |           }
 851 |           _ => rewritten.push(data)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       if local_changed {
     |         changed = true
     |         out_mod = out_mod.with_data_sec(DataSec::new(rewritten))
     |       }
     |     }
     |     None => ()
     |   }
     | 
     |   (out_mod, changed)
     | }
     …

     | fn sg_replace_gets_in_tinstr(
     |   instr : TInstr,
     |   trace_constants : Map[GlobalIdx, SGConstValue],
     |   constant_globals : Map[GlobalIdx, SGConstValue],
     | ) -> (TInstr, Bool) {
     |   match instr {
     |     TGlobalGet(idx) =>
     |       match constant_globals.get(idx) {
     |         Some(value) => (sg_const_value_to_tinstr(value), true)
     |         None =>
     |           match trace_constants.get(idx) {
     |             Some(value) => (sg_const_value_to_tinstr(value), true)
 878 |             None => (instr, false)
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
 881 |     TBlock(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_body, changed) = sg_replace_gets_in_texpr(
     |         body, trace_constants, constant_globals,
     |       )
 885 |       (TInstr::block(bt, next_body), changed)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 887 |     TLoop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_body, changed) = sg_replace_gets_in_texpr(
     |         body, trace_constants, constant_globals,
     |       )
 891 |       (TInstr::loop_(bt, next_body), changed)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TIf(bt, cond, then_body, else_body) => {
     |       let (next_cond, cond_changed) = sg_replace_gets_in_tinstr(
     |         cond, trace_constants, constant_globals,
     |       )
     |       let (next_then, then_changed) = sg_replace_gets_in_texpr(
     |         then_body, trace_constants, constant_globals,
     |       )
     |       let (next_else, else_changed) = match else_body {
 901 |         Some(other) => {
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let (rewritten, changed) = sg_replace_gets_in_texpr(
     |             other, trace_constants, constant_globals,
     |           )
     |           (Some(rewritten), changed)
     |         }
     |         None => (None, false)
     |       }
     |       (
     |         TInstr::if_(bt, next_cond, next_then, next_else),
     |         cond_changed || then_changed || else_changed,
     |       )
     |     }
 914 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_body, changed) = sg_replace_gets_in_texpr(
     |         body, trace_constants, constant_globals,
     |       )
 918 |       (TInstr::try_table(bt, catches, next_body), changed)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => {
     |       let children = eval_children(instr)
     |       if children.is_empty() {
     |         (instr, false)
     |       } else {
     |         let rewritten_children : Array[TInstr] = []
     |         let mut changed = false
     |         for child in children {
     |           let (next_child, child_changed) = sg_replace_gets_in_tinstr(
     |             child, trace_constants, constant_globals,
     |           )
     |           rewritten_children.push(next_child)
     |           if child_changed {
     |             changed = true
     |           }
     |         }
     |         if changed {
     |           (lcs_rebuild_non_control(instr, rewritten_children), true)
     |         } else {
     |           (instr, false)
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn sg_replace_gets_in_texpr(
     |   body : TExpr,
     |   trace_constants : Map[GlobalIdx, SGConstValue],
     |   constant_globals : Map[GlobalIdx, SGConstValue],
     | ) -> (TExpr, Bool) {
     |   let out : Array[TInstr] = []
     |   let mut changed = false
     |   for instr in body.0 {
     |     let (next_instr, instr_changed) = sg_replace_gets_in_tinstr(
     |       instr, trace_constants, constant_globals,
     |     )
     |     out.push(next_instr)
     |     if instr_changed {
 960 |       changed = true
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   (TExpr::new(out), changed)
     | }
     …

     | fn sg_apply_constants_in_body(
     |   body : TExpr,
     |   constant_globals : Map[GlobalIdx, SGConstValue],
     | ) -> (TExpr, Bool) {
     |   let curr_constants : Map[GlobalIdx, SGConstValue] = Map::new()
     |   let out : Array[TInstr] = []
     |   let mut changed = false
     |   for instr in body.0 {
     |     if lcs_is_non_linear_boundary(instr) {
     |       curr_constants.clear()
     |     }
     |     let (rewritten, replaced) = sg_replace_gets_in_tinstr(
     |       instr, curr_constants, constant_globals,
     |     )
     |     out.push(rewritten)
     |     if replaced {
     |       changed = true
     |     }
     | 
     |     if lcs_is_non_linear_boundary(rewritten) {
     |       curr_constants.clear()
     |       continue
     |     }
     | 
     |     let effects = SGEffects::new()
     |     sg_collect_effects_instr(rewritten, effects)
     |     if effects.calls {
 994 |       curr_constants.clear()
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       continue
     |     }
     |     for idx in effects.globals_written {
     |       curr_constants.remove(idx)
     |     }
     |     match rewritten {
     |       TGlobalSet(idx, value) =>
     |         match sg_const_value_from_tinstr(value) {
     |           Some(constant) => curr_constants[idx] = constant
1004 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |   }
     |   (TExpr::new(out), changed)
     | }
     …

     | fn sg_propagate_constants_to_code(
     |   mod : Module,
     |   optimize : Bool,
     | ) -> Result[(Module, Bool), String] {
     |   let imported_globals = sg_count_imported_globals(mod)
     |   let globals = match mod.global_sec {
     |     Some(GlobalSec(globals)) => globals
1020 |     None => []
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let constant_globals : Map[GlobalIdx, SGConstValue] = Map::new()
     |   for i = 0; i < globals.length(); i = i + 1 {
     |     let idx = sg_globalidx_from_int(imported_globals + i)
     |     let Global(GlobalType(_, is_mut), init) = globals[i]
     |     if !is_mut {
     |       match sg_const_value_from_expr(init) {
     |         Some(value) => constant_globals[idx] = value
1029 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     |   let mut changed = false
     |   let mut out_mod = mod
     |   match out_mod.code_sec {
     |     Some(CodeSec(funcs)) => {
     |       let rewritten : Array[Func] = []
     |       for func in funcs {
     |         match func {
     |           TFunc(locals, body) => {
     |             let (next_body, body_changed) = sg_apply_constants_in_body(
     |               body, constant_globals,
     |             )
     |             if body_changed {
     |               changed = true
     |             }
     |             rewritten.push(Func::t_func(locals, next_body))
     |           }
1049 |           _ => rewritten.push(func)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       if changed {
     |         out_mod = out_mod.with_code_sec(CodeSec::new(rewritten))
     |       }
     |     }
1056 |     None => ()
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   if optimize && changed {
1060 |     match
     |     ^^^^^ 	<-- UNCOVERED
     |       optimize_module(out_mod, [
     |         OptimizeInstructions,
     |         DeadCodeElimination,
     |         CodeFolding,
     |       ]) {
1066 |       Ok(next) => Ok((next, true))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Err(e) => Err(e)
     |     }
     |   } else {
     |     Ok((out_mod, changed))
     |   }
     | }
     …

     | fn sg_simplify_globals_impl(
     |   mod : Module,
     |   optimize : Bool,
     | ) -> Result[(Module, Bool), String] {
     |   let mut curr = mod
     |   let mut changed = false
     |   let mut rerun = true
     |   while rerun {
     |     rerun = false
     | 
     |     let (info0, analyzed0, analyze_changed0) = match sg_analyze(curr) {
     |       Ok(res) => res
1087 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     curr = analyzed0
     |     changed = changed || analyze_changed0
     | 
     |     let (folded, fold_changed) = sg_fold_single_uses(curr, info0)
     |     curr = folded
     |     changed = changed || fold_changed
     | 
     |     let (info1, analyzed1, analyze_changed1) = match sg_analyze(curr) {
     |       Ok(res) => res
1098 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     curr = analyzed1
     |     changed = changed || analyze_changed1
     | 
     |     let (removed, remove_changed, need_more) = match
     |       sg_remove_unneeded_writes(curr, info1) {
     |       Ok(res) => res
1106 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     curr = removed
     |     changed = changed || remove_changed
     |     if need_more {
     |       rerun = true
     |     }
     | 
     |     let (preferred, prefer_changed) = match sg_prefer_earlier_imports(curr) {
     |       Ok(res) => res
1116 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     curr = preferred
     |     changed = changed || prefer_changed
     | 
     |     let (globals_propagated, globals_changed) = sg_propagate_constants_to_globals(
     |       curr,
     |     )
     |     curr = globals_propagated
     |     changed = changed || globals_changed
     | 
     |     let (code_propagated, code_changed) = match
     |       sg_propagate_constants_to_code(curr, optimize) {
     |       Ok(res) => res
1130 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     curr = code_propagated
     |     changed = changed || code_changed
     |   }
     | 
     |   Ok((curr, changed))
     | }
     …

     | fn simplify_globals_ir_pass(
     |   _mod : Module,
     |   optimize : Bool,
     | ) -> ModuleTransformer[IRContext] {
     |   ModuleTransformer::new().on_module_evt(fn(_, ctx, curr) {
     |     match sg_simplify_globals_impl(curr, optimize) {
     |       Ok((next, _)) =>
     |         if next == curr {
1148 |           unchanged()
     |           ^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
     |           change(ctx, next)
     |         }
1152 |       Err(e) => Err(e)
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     | }
     …

     | fn propagate_globals_globally_ir_pass(
     |   _mod : Module,
     | ) -> ModuleTransformer[IRContext] {
     |   ModuleTransformer::new().on_module_evt(fn(_, ctx, curr) {
     |     let (next, _) = sg_propagate_constants_to_globals(curr)
     |     if next == curr {
1164 |       unchanged()
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     } else {
     |       change(ctx, next)
     |     }
     |   })
     | }
     …

     | fn sg_run_simplify_globals(mod : Module, optimize : Bool) -> Module {
     |   let pass = simplify_globals_ir_pass(mod, optimize)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
1176 |     Ok(None) => mod
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => abort("simplify_globals pass failed: \{e}")
     |   }
     | }
     …

     | fn sg_run_propagate_globals_globally(mod : Module) -> Module {
     |   let pass = propagate_globals_globally_ir_pass(mod)
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
1186 |     Ok(None) => mod
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => abort("propagate_globals_globally pass failed: \{e}")
     |   }
     | }
     …

136 uncovered line(s) in src/passes/simplify_locals.mbt:

     | fn sl_collect_local_stats_instr(instr : TInstr, stats : SLLocalStats) -> Unit {
     |   match instr {
     |     TLocalSet(_, value) => {
     |       stats.sets += 1
     |       sl_collect_local_stats_instr(value, stats)
     |     }
  20 |     TLocalTee(_, value) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       stats.tees += 1
  22 |       sl_collect_local_stats_instr(value, stats)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TLocalGet(_) => stats.gets += 1
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
  26 |       sl_collect_local_stats_texpr(body, stats)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       sl_collect_local_stats_instr(cond, stats)
     |       sl_collect_local_stats_texpr(then_body, stats)
     |       match else_body {
     |         Some(other) => sl_collect_local_stats_texpr(other, stats)
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         sl_collect_local_stats_instr(child, stats)
     |       }
     |   }
     | }
     …

     | fn sl_has_result_if_instr(instr : TInstr) -> Bool {
     |   match instr {
     |     TIf(ValTypeBlockType(_), _, _, _) => true
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
  54 |       sl_has_result_if_texpr(body)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       if sl_has_result_if_instr(cond) || sl_has_result_if_texpr(then_body) {
  57 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
  59 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => sl_has_result_if_texpr(other)
     |         None => false
     |       }
     |     }
     |     _ => {
     |       for child in eval_children(instr) {
     |         if sl_has_result_if_instr(child) {
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn sl_count_local_gets_for_idx_instr(instr : TInstr, idx : Int) -> Int {
     |   let mut total = 0
     |   match instr {
     |     TLocalGet(local_idx) =>
     |       if sl_localidx_to_int(local_idx) == idx {
     |         total += 1
     |       }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       total += sl_count_local_gets_for_idx_texpr(body, idx)
     |     TIf(_, cond, then_body, else_body) => {
     |       total += sl_count_local_gets_for_idx_instr(cond, idx)
     |       total += sl_count_local_gets_for_idx_texpr(then_body, idx)
     |       match else_body {
     |         Some(other) => total += sl_count_local_gets_for_idx_texpr(other, idx)
 100 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         total += sl_count_local_gets_for_idx_instr(child, idx)
     |       }
     |   }
     |   total
     | }
     …

     | fn sl_has_local_set_for_idx_instr(instr : TInstr, idx : Int) -> Bool {
     |   match instr {
     |     TLocalSet(local_idx, value) | TLocalTee(local_idx, value) => {
     |       if sl_localidx_to_int(local_idx) == idx {
     |         return true
     |       }
 127 |       sl_has_local_set_for_idx_instr(value, idx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 130 |       sl_has_local_set_for_idx_texpr(body, idx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       if sl_has_local_set_for_idx_instr(cond, idx) ||
     |         sl_has_local_set_for_idx_texpr(then_body, idx) {
 134 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 136 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => sl_has_local_set_for_idx_texpr(other, idx)
     |         None => false
     |       }
     |     }
 141 |     _ => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       for child in eval_children(instr) {
 143 |         if sl_has_local_set_for_idx_instr(child, idx) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn sl_count_local_sets_for_idx_instr(instr : TInstr, idx : Int) -> Int {
     |   let mut total = 0
     |   match instr {
     |     TLocalSet(local_idx, value) | TLocalTee(local_idx, value) => {
     |       if sl_localidx_to_int(local_idx) == idx {
     |         total += 1
     |       }
     |       total += sl_count_local_sets_for_idx_instr(value, idx)
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 173 |       total += sl_count_local_sets_for_idx_texpr(body, idx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       total += sl_count_local_sets_for_idx_instr(cond, idx)
     |       total += sl_count_local_sets_for_idx_texpr(then_body, idx)
     |       match else_body {
     |         Some(other) => total += sl_count_local_sets_for_idx_texpr(other, idx)
     |         None => ()
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         total += sl_count_local_sets_for_idx_instr(child, idx)
     |       }
     |   }
     |   total
     | }
     …

     | fn sl_has_result_block_instr(instr : TInstr) -> Bool {
     |   match instr {
     |     TBlock(ValTypeBlockType(_), _) => true
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       sl_has_result_block_texpr(body)
     |     TIf(_, cond, then_body, else_body) => {
     |       if sl_has_result_block_instr(cond) || sl_has_result_block_texpr(then_body) {
 207 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match else_body {
     |         Some(other) => sl_has_result_block_texpr(other)
 211 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => {
     |       for child in eval_children(instr) {
     |         if sl_has_result_block_instr(child) {
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn sl_has_result_loop_instr(instr : TInstr) -> Bool {
     |   match instr {
     |     TLoop(ValTypeBlockType(_), _) => true
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 240 |       sl_has_result_loop_texpr(body)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       if sl_has_result_loop_instr(cond) || sl_has_result_loop_texpr(then_body) {
 243 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 245 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => sl_has_result_loop_texpr(other)
     |         None => false
     |       }
     |     }
     |     _ => {
     |       for child in eval_children(instr) {
     |         if sl_has_result_loop_instr(child) {
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn sl_has_br_if_with_tee_value_instr(instr : TInstr, idx : Int) -> Bool {
     |   match instr {
     |     TBrIf(_, _, [TLocalTee(local_idx, _)]) =>
     |       sl_localidx_to_int(local_idx) == idx
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
 277 |       sl_has_br_if_with_tee_value_texpr(body, idx)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TIf(_, cond, then_body, else_body) => {
     |       if sl_has_br_if_with_tee_value_instr(cond, idx) ||
     |         sl_has_br_if_with_tee_value_texpr(then_body, idx) {
 281 |         return true
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 283 |       match else_body {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(other) => sl_has_br_if_with_tee_value_texpr(other, idx)
     |         None => false
     |       }
     |     }
     |     _ => {
     |       for child in eval_children(instr) {
 290 |         if sl_has_br_if_with_tee_value_instr(child, idx) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return true
     |         }
     |       }
     |       false
     |     }
     |   }
     | }
     …

     | fn sl_collect_param_types(mod : Module) -> Array[Array[ValType]] {
     |   let out : Array[Array[ValType]] = []
     |   let env = Env::new().with_module(mod)
     |   match mod.func_sec {
     |     Some(FuncSec(type_idxs)) =>
 346 |       for tidx in type_idxs {
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         match env.resolve_functype(tidx) {
     |           Some(FuncType(params, _)) => out.push(params)
     |           None => out.push([])
     |         }
     |       }
     |     None => ()
     |   }
     |   out
     | }
     …

     | fn sl_is_defaultable(vt : ValType) -> Bool {
 359 |   match vt {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) => rt.is_defaultable()
     |     _ => true
     |   }
     | }
     …

     | fn sl_collect_get_counts_instr(instr : TInstr, counts : Array[Int]) -> Unit {
     |   match instr {
     |     TLocalGet(idx) => {
     |       let i = sl_localidx_to_int(idx)
     |       if i >= 0 && i < counts.length() {
     |         counts[i] += 1
     |       }
     |     }
     |     TBlock(_, body) | TLoop(_, body) | TTryTable(_, _, body) =>
     |       sl_collect_get_counts_texpr(body, counts)
     |     TIf(_, cond, then_body, else_body) => {
     |       sl_collect_get_counts_instr(cond, counts)
     |       sl_collect_get_counts_texpr(then_body, counts)
     |       match else_body {
     |         Some(other) => sl_collect_get_counts_texpr(other, counts)
 381 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ =>
     |       for child in eval_children(instr) {
     |         sl_collect_get_counts_instr(child, counts)
     |       }
     |   }
     | }
     …

     | fn sl_try_sink_local_get(
     |   idx : LocalIdx,
     |   sinkables : Map[Int, SLSinkableInfo],
     |   out : Array[TInstr],
     |   get_counts : Array[Int],
     |   options : SLSimplifyOptions,
     |   parent_is_set_value : Bool,
     |   changed : Ref[Bool],
     | ) -> TInstr {
     |   let key = sl_localidx_to_int(idx)
     |   if key < 0 || key >= get_counts.length() {
 410 |     return TInstr::local_get(idx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match sinkables.get(key) {
     |     None => TInstr::local_get(idx)
     |     Some(info) => {
     |       let one_use = get_counts[key] == 1
     |       let sink_value = info.value
     |       let sink_is_get = match sink_value {
 418 |         TLocalGet(_) => true
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => false
     |       }
     |       if !options.allow_nesting && !sink_is_get && !parent_is_set_value {
     |         return TInstr::local_get(idx)
     |       }
     |       if !one_use && !options.allow_tee {
 425 |         match sink_value {
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           TLocalGet(other) =>
 427 |             if options.allow_nesting {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::local_get(idx)
     |             } else {
 430 |               changed.val = true
     |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::local_get(other)
     |             }
 433 |           _ => TInstr::local_get(idx)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else if one_use {
     |         if info.out_index >= 0 && info.out_index < out.length() {
     |           out[info.out_index] = TInstr::nop()
     |         }
     |         sinkables.remove(key)
     |         changed.val = true
     |         sink_value
     |       } else {
     |         if info.out_index >= 0 && info.out_index < out.length() {
     |           out[info.out_index] = TInstr::nop()
     |         }
     |         sinkables.remove(key)
     |         changed.val = true
     |         TInstr::local_tee(idx, sink_value)
     |       }
     |     }
     |   }
     | }
     …

     | fn sl_branch_value_candidate_idx(values : Array[TInstr]) -> Int? {
     |   if values.length() != 1 {
     |     return None
     |   }
 516 |   match values[0] {
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TLocalSet(idx, _) | TLocalTee(idx, _) => Some(sl_localidx_to_int(idx))
     |     _ => None
     |   }
     | }
     …

     | fn sl_collect_block_exit_candidates_texpr(
     |   body : TExpr,
     |   target_depth : Int,
     |   state : SLBlockCollectState,
     | ) -> Unit {
     |   for i = 0; i < body.0.length(); i = i + 1 {
     |     let curr = body.0[i]
     |     let prev = if i > 0 { Some(body.0[i - 1]) } else { None }
     |     match curr {
     |       TBr(label, values) =>
     |         if sl_labelidx_to_int(label) == target_depth {
     |           state.saw_exit = true
     |           match sl_branch_value_candidate_idx(values) {
 536 |             Some(idx) => sl_collect_shared_idx(state, idx)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             None =>
     |               match prev {
     |                 Some(TLocalSet(prev_idx, _)) if values.length() == 0 =>
     |                   sl_collect_shared_idx(state, sl_localidx_to_int(prev_idx))
 541 |                 _ => state.unoptimizable = true
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         }
     |       TBrIf(label, cond, values) => {
     |         sl_collect_block_exit_candidates_texpr(
     |           TExpr::new([cond]),
     |           target_depth,
     |           state,
     |         )
     |         if sl_labelidx_to_int(label) == target_depth {
     |           state.saw_exit = true
     |           match sl_branch_value_candidate_idx(values) {
 554 |             Some(idx) => sl_collect_shared_idx(state, idx)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             None =>
     |               match prev {
     |                 Some(TLocalSet(prev_idx, _)) if values.length() == 0 =>
     |                   sl_collect_shared_idx(state, sl_localidx_to_int(prev_idx))
 559 |                 _ => state.unoptimizable = true
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         }
     |       }
 564 |       TBrTable(labels, default_, idx, values) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         sl_collect_block_exit_candidates_texpr(
     |           TExpr::new([idx]),
     |           target_depth,
     |           state,
     |         )
     |         for value in values {
 571 |           sl_collect_block_exit_candidates_texpr(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TExpr::new([value]),
     |             target_depth,
     |             state,
     |           )
     |         }
 577 |         let mut hits_target = sl_labelidx_to_int(default_) == target_depth
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for label in labels {
 579 |           if sl_labelidx_to_int(label) == target_depth {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             hits_target = true
     |           }
     |         }
     |         if hits_target {
 584 |           state.saw_exit = true
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           state.unoptimizable = true
     |         }
     |       }
 588 |       TBrOnNull(label, ref_, values) | TBrOnNonNull(label, ref_, values) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         sl_collect_block_exit_candidates_texpr(
     |           TExpr::new([ref_]),
     |           target_depth,
     |           state,
     |         )
     |         for value in values {
 595 |           sl_collect_block_exit_candidates_texpr(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TExpr::new([value]),
     |             target_depth,
     |             state,
     |           )
     |         }
     |         if sl_labelidx_to_int(label) == target_depth {
 602 |           state.saw_exit = true
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           state.unoptimizable = true
     |         }
     |       }
     |       TBrOnCast(label, _, _, _, ref_, values)
 607 |       | TBrOnCastFail(label, _, _, _, ref_, values) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         sl_collect_block_exit_candidates_texpr(
     |           TExpr::new([ref_]),
     |           target_depth,
     |           state,
     |         )
     |         for value in values {
 614 |           sl_collect_block_exit_candidates_texpr(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TExpr::new([value]),
     |             target_depth,
     |             state,
     |           )
     |         }
     |         if sl_labelidx_to_int(label) == target_depth {
 621 |           state.saw_exit = true
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           state.unoptimizable = true
     |         }
     |       }
     |       TBlock(_, nested) | TLoop(_, nested) | TTryTable(_, _, nested) =>
 626 |         sl_collect_block_exit_candidates_texpr(nested, target_depth + 1, state)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TIf(_, cond, then_body, else_body) => {
     |         sl_collect_block_exit_candidates_texpr(
     |           TExpr::new([cond]),
     |           target_depth,
     |           state,
     |         )
     |         sl_collect_block_exit_candidates_texpr(
     |           then_body,
     |           target_depth + 1,
     |           state,
     |         )
     |         match else_body {
     |           Some(other) =>
     |             sl_collect_block_exit_candidates_texpr(
     |               other,
     |               target_depth + 1,
     |               state,
     |             )
 645 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       _ =>
     |         for child in eval_children(curr) {
     |           sl_collect_block_exit_candidates_texpr(
     |             TExpr::new([child]),
     |             target_depth,
     |             state,
     |           )
     |         }
     |     }
     |   }
     | }
     …

     | fn sl_rewrite_block_exits_texpr(
     |   body : TExpr,
     |   target_depth : Int,
     |   shared_idx : Int,
     |   changed : Ref[Bool],
     | ) -> TExpr {
     |   let out : Array[TInstr] = []
     |   let shared_local = sl_localidx_from_int(shared_idx)
     |   for i = 0; i < body.0.length(); i = i + 1 {
     |     let curr = body.0[i]
     |     let next = match curr {
     |       TBr(label, values) =>
     |         if sl_labelidx_to_int(label) == target_depth {
     |           match sl_branch_value_candidate_idx(values) {
     |             Some(idx) if idx == shared_idx =>
 676 |               match values[0] {
     |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TLocalSet(_, value) | TLocalTee(_, value) => {
     |                   changed.val = true
 679 |                   TInstr::br(label, [value])
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
 681 |                 _ => curr
     |                 ^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
     |               if values.length() == 0 &&
     |                 out.length() > 0 &&
     |                 sl_has_local_set_for_idx_instr(
     |                   out[out.length() - 1],
     |                   shared_idx,
     |                 ) {
     |                 match out[out.length() - 1] {
     |                   TLocalSet(_, value) => {
     |                     out[out.length() - 1] = TInstr::nop()
     |                     changed.val = true
     |                     TInstr::br(label, [value])
     |                   }
 696 |                   _ => curr
     |                   ^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               } else {
 699 |                 curr
     |                 ^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         } else {
 703 |           curr
     |           ^^^^ 	<-- UNCOVERED
     |         }
     |       TBrIf(label, cond, values) =>
     |         if sl_labelidx_to_int(label) == target_depth {
     |           match sl_branch_value_candidate_idx(values) {
     |             Some(idx) if idx == shared_idx =>
 709 |               match values[0] {
     |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 TLocalSet(_, value) => {
     |                   changed.val = true
 712 |                   TInstr::br_if(label, cond, [
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     TInstr::local_tee(shared_local, value),
     |                   ])
     |                 }
 716 |                 TLocalTee(_, value) => {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   changed.val = true
 718 |                   TInstr::br_if(label, cond, [
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     TInstr::local_tee(shared_local, value),
     |                   ])
     |                 }
 722 |                 _ => curr
     |                 ^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             _ =>
     |               if values.length() == 0 &&
     |                 out.length() > 0 &&
     |                 sl_has_local_set_for_idx_instr(
     |                   out[out.length() - 1],
     |                   shared_idx,
     |                 ) {
     |                 match out[out.length() - 1] {
     |                   TLocalSet(_, value) => {
     |                     out[out.length() - 1] = TInstr::nop()
     |                     changed.val = true
     |                     TInstr::br_if(label, cond, [
     |                       TInstr::local_tee(shared_local, value),
     |                     ])
     |                   }
 739 |                   _ => curr
     |                   ^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               } else {
 742 |                 curr
     |                 ^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         } else {
 746 |           curr
     |           ^^^^ 	<-- UNCOVERED
     |         }
     |       TBlock(bt, nested) =>
 749 |         TInstr::block(
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           bt,
 751 |           sl_rewrite_block_exits_texpr(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             nested,
     |             target_depth + 1,
     |             shared_idx,
     |             changed,
     |           ),
     |         )
     |       TLoop(bt, nested) =>
 759 |         TInstr::loop_(
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           bt,
 761 |           sl_rewrite_block_exits_texpr(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             nested,
     |             target_depth + 1,
     |             shared_idx,
     |             changed,
     |           ),
     |         )
     |       TTryTable(bt, catches, nested) =>
 769 |         TInstr::try_table(
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           bt,
     |           catches,
 772 |           sl_rewrite_block_exits_texpr(
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             nested,
     |             target_depth + 1,
     |             shared_idx,
     |             changed,
     |           ),
     |         )
     |       TIf(bt, cond, then_body, else_body) =>
     |         TInstr::if_(
     |           bt,
     |           sl_rewrite_block_exits_texpr(
     |             TExpr::new([cond]),
     |             target_depth,
     |             shared_idx,
     |             changed,
     |           ).0[0],
     |           sl_rewrite_block_exits_texpr(
     |             then_body,
     |             target_depth + 1,
     |             shared_idx,
     |             changed,
     |           ),
     |           else_body.map(fn(other) {
     |             sl_rewrite_block_exits_texpr(
     |               other,
     |               target_depth + 1,
     |               shared_idx,
     |               changed,
     |             )
     |           }),
     |         )
     |       _ => curr
     |     }
     |     out.push(next)
     |   }
     |   TExpr::new(out)
     | }
     …

     | fn sl_try_structure_block(
     |   instr : TInstr,
     |   local_types : Array[ValType],
     |   options : SLSimplifyOptions,
     |   changed : Ref[Bool],
     | ) -> TInstr {
     |   if !options.allow_structure {
 818 |     return instr
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match instr {
     |     TBlock(VoidBlockType, body) =>
     |       match sl_take_terminal_local_set(body) {
     |         Some((_, fall_idx, _)) => {
     |           let fall_raw = sl_localidx_to_int(fall_idx)
     |           let collect = SLBlockCollectState::new()
     |           sl_collect_block_exit_candidates_texpr(body, 0, collect)
     |           if collect.unoptimizable || !collect.saw_exit {
 828 |             return instr
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let shared_raw = match collect.shared_idx {
     |             Some(i) => i
 832 |             None => return instr
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if shared_raw != fall_raw {
 835 |             return instr
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let local_type = match local_types.get(shared_raw) {
     |             Some(vt) => vt
 839 |             None => return instr
     |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           let next_body = sl_rewrite_block_exits_texpr(
     |             body, 0, shared_raw, changed,
     |           )
     |           match sl_take_terminal_local_set(next_body) {
     |             Some((prefix, shared_idx, value)) =>
     |               if sl_localidx_to_int(shared_idx) == shared_raw {
     |                 let body_result = prefix.copy()
     |                 body_result.push(value)
     |                 changed.val = true
     |                 TInstr::local_set(
     |                   shared_idx,
     |                   TInstr::block(
     |                     BlockType::val_type(local_type),
     |                     TExpr::new(body_result),
     |                   ),
     |                 )
     |               } else {
 858 |                 instr
     |                 ^^^^^ 	<-- UNCOVERED
     |               }
 860 |             None => instr
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |         None => instr
     |       }
     |     _ => instr
     |   }
     | }
     …

     | fn sl_try_structure_loop_sink(
     |   instr : TInstr,
     |   sinkables : Map[Int, SLSinkableInfo],
     |   out : Array[TInstr],
     |   local_types : Array[ValType],
     |   options : SLSimplifyOptions,
     |   changed : Ref[Bool],
     | ) -> TInstr {
     |   if !options.allow_structure {
     |     return instr
     |   }
     |   match instr {
     |     TLoop(VoidBlockType, body) => {
     |       if sinkables.is_empty() {
     |         return instr
     |       }
     |       let mut picked_idx = -1
     |       let mut picked_info : SLSinkableInfo? = None
     |       for entry in sinkables {
     |         let (idx, info) = entry
     |         picked_idx = idx
     |         picked_info = Some(info)
     |         break
     |       }
     |       if picked_idx < 0 {
 895 |         return instr
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let info = match picked_info {
     |         Some(i) => i
 899 |         None => return instr
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let local_type = match local_types.get(picked_idx) {
     |         Some(vt) => vt
 903 |         None => return instr
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let body_instrs = body.0.copy()
     |       if body_instrs.is_empty() ||
     |         body_instrs[body_instrs.length() - 1] != TInstr::nop() {
     |         body_instrs.push(TInstr::nop())
     |       }
     |       body_instrs[body_instrs.length() - 1] = info.value
     |       if info.out_index >= 0 && info.out_index < out.length() {
     |         out[info.out_index] = TInstr::nop()
     |       }
     |       sinkables.clear()
     |       changed.val = true
     |       TInstr::local_set(
     |         sl_localidx_from_int(picked_idx),
     |         TInstr::loop_(BlockType::val_type(local_type), TExpr::new(body_instrs)),
     |       )
     |     }
     |     _ => instr
     |   }
     | }
     …

     | fn sl_try_structure_if(
     |   instr : TInstr,
     |   local_types : Array[ValType],
     |   options : SLSimplifyOptions,
     |   changed : Ref[Bool],
     | ) -> TInstr {
     |   if !options.allow_structure {
 933 |     return instr
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match instr {
     |     TIf(VoidBlockType, cond, then_body, else_body) =>
     |       match else_body {
     |         Some(other) => {
     |           let then_set = sl_take_terminal_local_set(then_body)
     |           let else_set = sl_take_terminal_local_set(other)
     |           match (then_set, else_set) {
     |             (
     |               Some((then_prefix, then_idx, then_value)),
     |               Some((else_prefix, else_idx, else_value)),
     |             ) =>
     |               if then_idx == else_idx {
     |                 let idx_i = sl_localidx_to_int(then_idx)
     |                 match local_types.get(idx_i) {
     |                   Some(local_type) => {
     |                     let next_then = then_prefix.copy()
     |                     next_then.push(then_value)
     |                     let next_else = else_prefix.copy()
     |                     next_else.push(else_value)
     |                     changed.val = true
     |                     TInstr::local_set(
     |                       then_idx,
     |                       TInstr::if_(
     |                         BlockType::val_type(local_type),
     |                         cond,
     |                         TExpr::new(next_then),
     |                         Some(TExpr::new(next_else)),
     |                       ),
     |                     )
     |                   }
 965 |                   None => instr
     |                   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |               } else {
 968 |                 instr
     |                 ^^^^^ 	<-- UNCOVERED
     |               }
     |             _ => instr
     |           }
     |         }
     |         None =>
 974 |           match sl_take_terminal_local_set(then_body) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some((then_prefix, then_idx, then_value)) => {
     |               let idx_i = sl_localidx_to_int(then_idx)
     |               match local_types.get(idx_i) {
     |                 Some(local_type) =>
 979 |                   if sl_is_defaultable(local_type) {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                     let next_then = then_prefix.copy()
     |                     next_then.push(then_value)
     |                     changed.val = true
 983 |                     TInstr::local_set(
     |                     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                       then_idx,
 985 |                       TInstr::if_(
     |                       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         BlockType::val_type(local_type),
     |                         cond,
 988 |                         TExpr::new(next_then),
     |                         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         Some(TExpr::new([TInstr::local_get(then_idx)])),
     |                       ),
     |                     )
     |                   } else {
 993 |                     instr
     |                     ^^^^^ 	<-- UNCOVERED
     |                   }
 995 |                 None => instr
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
 998 |             _ => instr
     |             ^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     _ => instr
     |   }
     | }
     …

     | fn sl_rewrite_instr_main(
     |   instr : TInstr,
     |   sinkables : Map[Int, SLSinkableInfo],
     |   out : Array[TInstr],
     |   local_types : Array[ValType],
     |   get_counts : Array[Int],
     |   options : SLSimplifyOptions,
     |   parent_is_set_value : Bool,
     |   changed : Ref[Bool],
     | ) -> TInstr {
     |   match instr {
     |     TLocalGet(idx) =>
     |       sl_try_sink_local_get(
     |         idx, sinkables, out, get_counts, options, parent_is_set_value, changed,
     |       )
     |     TBlock(bt, body) => {
     |       let (next_body, body_changed) = sl_simplify_texpr_main(
     |         body, local_types, get_counts, options,
     |       )
     |       if body_changed {
1026 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       sl_try_structure_block(
     |         TInstr::block(bt, next_body),
     |         local_types,
     |         options,
     |         changed,
     |       )
     |     }
     |     TLoop(bt, body) => {
     |       let (next_body, body_changed) = sl_simplify_texpr_main(
     |         body, local_types, get_counts, options,
     |       )
     |       if body_changed {
1040 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       TInstr::loop_(bt, next_body)
     |     }
1044 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (next_body, body_changed) = sl_simplify_texpr_main(
     |         body, local_types, get_counts, options,
     |       )
     |       if body_changed {
1049 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1051 |       TInstr::try_table(bt, catches, next_body)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TIf(bt, cond, then_body, else_body) => {
     |       let next_cond = sl_rewrite_instr_main(
     |         cond, sinkables, out, local_types, get_counts, options, false, changed,
     |       )
     |       let (next_then, then_changed) = sl_simplify_texpr_main(
     |         then_body, local_types, get_counts, options,
     |       )
     |       let mut branch_changed = then_changed
     |       let next_else = match else_body {
     |         Some(other) => {
     |           let (rewritten, else_changed) = sl_simplify_texpr_main(
     |             other, local_types, get_counts, options,
     |           )
     |           branch_changed = branch_changed || else_changed
     |           Some(rewritten)
     |         }
1069 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let rebuilt = TInstr::if_(bt, next_cond, next_then, next_else)
     |       if branch_changed || next_cond != cond {
1073 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       sl_try_structure_if(rebuilt, local_types, options, changed)
     |     }
     |     _ => {
     |       let children = eval_children(instr)
     |       if children.is_empty() {
     |         return instr
     |       }
     |       let next_children : Array[TInstr] = []
     |       let mut any = false
     |       for i = 0; i < children.length(); i = i + 1 {
     |         let child = children[i]
     |         let child_parent_is_set = match instr {
     |           TLocalSet(_, _) | TLocalTee(_, _) => i == 0
     |           _ => false
     |         }
     |         let next_child = sl_rewrite_instr_main(
     |           child, sinkables, out, local_types, get_counts, options, child_parent_is_set,
     |           changed,
     |         )
     |         next_children.push(next_child)
     |         if next_child != child {
     |           any = true
     |         }
     |         sl_invalidate_sinkables(sinkables, lcs_collect_effects(next_child))
     |       }
     |       if any {
     |         changed.val = true
     |         mb_rebuild_non_control(instr, next_children)
     |       } else {
     |         instr
     |       }
     |     }
     |   }
     | }
     …

     | fn sl_simplify_texpr_main(
     |   expr : TExpr,
     |   local_types : Array[ValType],
     |   get_counts : Array[Int],
     |   options : SLSimplifyOptions,
     | ) -> (TExpr, Bool) {
     |   let out : Array[TInstr] = []
     |   let sinkables : Map[Int, SLSinkableInfo] = Map::new()
     |   let changed = Ref::new(false)
     | 
     |   for instr in expr.0 {
     |     let rewritten = sl_rewrite_instr_main(
     |       instr, sinkables, out, local_types, get_counts, options, false, changed,
     |     )
     |     let curr = match rewritten {
     |       TDrop(TLocalTee(idx, value)) => {
     |         changed.val = true
     |         TInstr::local_set(idx, value)
     |       }
     |       _ => rewritten
     |     }
     |     let curr = sl_try_structure_loop_sink(
     |       curr, sinkables, out, local_types, options, changed,
     |     )
     |     let curr_effects = lcs_collect_effects(curr)
     |     sl_invalidate_sinkables(sinkables, curr_effects)
     |     match curr {
     |       TLocalSet(idx, value) => {
     |         let key = sl_localidx_to_int(idx)
     |         if key >= 0 && key < get_counts.length() {
     |           match sinkables.get(key) {
1142 |             Some(previous) => {
     |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               if previous.out_index >= 0 && previous.out_index < out.length() {
1144 |                 out[previous.out_index] = TInstr::drop(previous.value)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
1146 |               sinkables.remove(key)
     |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               changed.val = true
     |             }
     |             None => ()
     |           }
     |           let uses = get_counts[key]
     |           if uses > 0 && (options.allow_tee || uses == 1) {
     |             sinkables[key] = {
     |               out_index: out.length(),
     |               value,
     |               effects: lcs_collect_effects(curr),
     |             }
     |           }
     |         }
     |       }
     |       _ => ()
     |     }
     |     out.push(curr)
     |     if lcs_is_non_linear_boundary(curr) || is_unreachable_instr(curr) {
     |       sinkables.clear()
     |     }
     |     if is_unreachable_instr(curr) {
     |       break
     |     }
     |   }
     |   (TExpr::new(out), changed.val)
     | }
     …

     | fn sl_remove_unneeded_sets_instr(
     |   instr : TInstr,
     |   get_counts : Array[Int],
     |   changed : Ref[Bool],
     | ) -> TInstr {
     |   match instr {
     |     TLocalSet(idx, value) => {
     |       let next_value = sl_remove_unneeded_sets_instr(value, get_counts, changed)
     |       let key = sl_localidx_to_int(idx)
     |       if key >= 0 && key < get_counts.length() && get_counts[key] == 0 {
     |         changed.val = true
     |         TInstr::drop(next_value)
     |       } else if next_value != value {
1188 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::local_set(idx, next_value)
     |       } else {
     |         instr
     |       }
     |     }
     |     TLocalTee(idx, value) => {
     |       let next_value = sl_remove_unneeded_sets_instr(value, get_counts, changed)
     |       let key = sl_localidx_to_int(idx)
     |       if key >= 0 && key < get_counts.length() && get_counts[key] == 0 {
     |         changed.val = true
     |         next_value
     |       } else if next_value != value {
1201 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::local_tee(idx, next_value)
     |       } else {
     |         instr
     |       }
     |     }
     |     TBlock(bt, body) => {
     |       let next_body = sl_remove_unneeded_sets_texpr(body, get_counts, changed)
     |       if next_body != body {
     |         changed.val = true
     |         TInstr::block(bt, next_body)
     |       } else {
     |         instr
     |       }
     |     }
     |     TLoop(bt, body) => {
     |       let next_body = sl_remove_unneeded_sets_texpr(body, get_counts, changed)
     |       if next_body != body {
1219 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::loop_(bt, next_body)
     |       } else {
     |         instr
     |       }
     |     }
1225 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_body = sl_remove_unneeded_sets_texpr(body, get_counts, changed)
     |       if next_body != body {
1228 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::try_table(bt, catches, next_body)
     |       } else {
1231 |         instr
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TIf(bt, cond, then_body, else_body) => {
     |       let next_cond = sl_remove_unneeded_sets_instr(cond, get_counts, changed)
     |       let next_then = sl_remove_unneeded_sets_texpr(
     |         then_body, get_counts, changed,
     |       )
     |       let next_else = else_body.map(fn(e) {
     |         sl_remove_unneeded_sets_texpr(e, get_counts, changed)
     |       })
     |       if next_cond != cond || next_then != then_body || next_else != else_body {
     |         changed.val = true
     |         TInstr::if_(bt, next_cond, next_then, next_else)
     |       } else {
     |         instr
     |       }
     |     }
     |     _ => {
     |       let children = eval_children(instr)
     |       if children.is_empty() {
     |         return instr
     |       }
     |       let next_children : Array[TInstr] = []
     |       let mut any = false
     |       for child in children {
     |         let next_child = sl_remove_unneeded_sets_instr(
     |           child, get_counts, changed,
     |         )
     |         if next_child != child {
     |           any = true
     |         }
     |         next_children.push(next_child)
     |       }
     |       if any {
     |         changed.val = true
     |         mb_rebuild_non_control(instr, next_children)
     |       } else {
     |         instr
     |       }
     |     }
     |   }
     | }
     …

     | fn sl_strip_nops_instr(instr : TInstr, changed : Ref[Bool]) -> TInstr {
     |   match instr {
     |     TBlock(bt, body) => {
     |       let next_body = sl_strip_nops_texpr(body, changed)
     |       if next_body != body {
     |         changed.val = true
     |         TInstr::block(bt, next_body)
     |       } else {
     |         instr
     |       }
     |     }
     |     TLoop(bt, body) => {
     |       let next_body = sl_strip_nops_texpr(body, changed)
     |       if next_body != body {
     |         changed.val = true
     |         TInstr::loop_(bt, next_body)
     |       } else {
     |         instr
     |       }
     |     }
1309 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let next_body = sl_strip_nops_texpr(body, changed)
     |       if next_body != body {
1312 |         changed.val = true
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::try_table(bt, catches, next_body)
     |       } else {
1315 |         instr
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TIf(bt, cond, then_body, else_body) => {
     |       let next_cond = sl_strip_nops_instr(cond, changed)
     |       let next_then = sl_strip_nops_texpr(then_body, changed)
     |       let next_else = else_body.map(fn(e) { sl_strip_nops_texpr(e, changed) })
     |       if next_cond != cond || next_then != then_body || next_else != else_body {
     |         changed.val = true
     |         TInstr::if_(bt, next_cond, next_then, next_else)
     |       } else {
     |         instr
     |       }
     |     }
     |     _ => {
     |       let children = eval_children(instr)
     |       if children.is_empty() {
     |         return instr
     |       }
     |       let next_children : Array[TInstr] = []
     |       let mut any = false
     |       for child in children {
     |         let next_child = sl_strip_nops_instr(child, changed)
     |         if next_child != child {
     |           any = true
     |         }
     |         next_children.push(next_child)
     |       }
     |       if any {
     |         changed.val = true
     |         mb_rebuild_non_control(instr, next_children)
     |       } else {
     |         instr
     |       }
     |     }
     |   }
     | }
     …

     | fn sl_late_is_equivalent(state : SLLateState, a : Int, b : Int) -> Bool {
     |   if a == b {
     |     return true
     |   }
     |   if a < 0 || b < 0 || a >= state.equivs.length() || b >= state.equivs.length() {
1405 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   state.equivs[a].contains(b)
     | }
     …

     | fn sl_late_reset_local(state : SLLateState, idx : Int) -> Unit {
     |   if idx < 0 || idx >= state.equivs.length() {
1413 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   for i = 0; i < state.equivs.length(); i = i + 1 {
     |     if i != idx {
     |       state.equivs[i].remove(idx)
     |     }
     |   }
     |   let own : Set[Int] = Set::new()
     |   own.add(idx)
     |   state.equivs[idx] = own
     | }
     …

     | fn sl_late_add_equivalence(state : SLLateState, a : Int, b : Int) -> Unit {
     |   if a < 0 || b < 0 || a >= state.equivs.length() || b >= state.equivs.length() {
1428 |     return
     |     ^^^^^^ 	<-- UNCOVERED
     |   }
     |   let merged = state.equivs[a].copy()
     |   for idx in state.equivs[b] {
     |     merged.add(idx)
     |   }
     |   for idx in merged {
     |     state.equivs[idx] = merged.copy()
     |   }
     | }
     …

     | fn sl_late_get_count_ignoring_curr(
     |   state : SLLateState,
     |   idx : Int,
     |   curr : Int,
     | ) -> Int {
     |   if idx < 0 || idx >= state.get_counts.length() {
1455 |     return 0
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let mut out = state.get_counts[idx]
     |   if idx == curr && out > 0 {
     |     out -= 1
     |   }
     |   out
     | }
     …

     | fn sl_late_rewrite_instr(instr : TInstr, state : SLLateState) -> TInstr {
     |   match instr {
     |     TLocalSet(idx, value) => {
     |       let next_value = sl_late_rewrite_instr(value, state)
     |       let idx_i = sl_localidx_to_int(idx)
     |       match sl_get_fallthrough(next_value) {
     |         TLocalGet(src_idx) => {
     |           let src_i = sl_localidx_to_int(src_idx)
     |           if sl_late_is_equivalent(state, idx_i, src_i) {
     |             if state.remove_equivalent_sets {
     |               state.changed.val = true
     |               TInstr::drop(next_value)
     |             } else if next_value != value {
     |               state.changed.val = true
     |               TInstr::local_set(idx, next_value)
     |             } else {
1481 |               instr
     |               ^^^^^ 	<-- UNCOVERED
     |             }
     |           } else {
     |             sl_late_reset_local(state, idx_i)
     |             sl_late_add_equivalence(state, idx_i, src_i)
     |             if next_value != value {
1487 |               state.changed.val = true
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::local_set(idx, next_value)
     |             } else {
     |               instr
     |             }
     |           }
     |         }
     |         _ => {
     |           sl_late_reset_local(state, idx_i)
     |           if next_value != value {
1497 |             state.changed.val = true
     |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TInstr::local_set(idx, next_value)
     |           } else {
     |             instr
     |           }
     |         }
     |       }
     |     }
     |     TLocalTee(idx, value) => {
     |       let next_value = sl_late_rewrite_instr(value, state)
     |       let idx_i = sl_localidx_to_int(idx)
     |       match sl_get_fallthrough(next_value) {
1509 |         TLocalGet(src_idx) => {
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let src_i = sl_localidx_to_int(src_idx)
     |           if sl_late_is_equivalent(state, idx_i, src_i) {
1512 |             if state.remove_equivalent_sets {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               state.changed.val = true
     |               next_value
1515 |             } else if next_value != value {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               state.changed.val = true
     |               TInstr::local_tee(idx, next_value)
     |             } else {
1519 |               instr
     |               ^^^^^ 	<-- UNCOVERED
     |             }
     |           } else {
1522 |             sl_late_reset_local(state, idx_i)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             sl_late_add_equivalence(state, idx_i, src_i)
     |             if next_value != value {
1525 |               state.changed.val = true
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               TInstr::local_tee(idx, next_value)
     |             } else {
1528 |               instr
     |               ^^^^^ 	<-- UNCOVERED
     |             }
     |           }
     |         }
     |         _ => {
     |           sl_late_reset_local(state, idx_i)
     |           if next_value != value {
1535 |             state.changed.val = true
     |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             TInstr::local_tee(idx, next_value)
     |           } else {
     |             instr
     |           }
     |         }
     |       }
     |     }
     |     TLocalGet(idx) => {
     |       let idx_i = sl_localidx_to_int(idx)
     |       if idx_i < 0 || idx_i >= state.equivs.length() {
1546 |         return instr
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut best = idx_i
     |       for candidate in state.equivs[idx_i] {
     |         if candidate == best {
     |           continue
     |         }
     |         let cand_count = sl_late_get_count_ignoring_curr(
     |           state, candidate, idx_i,
     |         )
     |         let best_count = sl_late_get_count_ignoring_curr(state, best, idx_i)
     |         if cand_count > best_count {
     |           best = candidate
     |         }
     |       }
     |       if best != idx_i &&
     |         sl_late_get_count_ignoring_curr(state, best, idx_i) >
     |         sl_late_get_count_ignoring_curr(state, idx_i, idx_i) {
     |         state.get_counts[best] = state.get_counts[best] + 1
     |         if state.get_counts[idx_i] > 0 {
     |           state.get_counts[idx_i] = state.get_counts[idx_i] - 1
     |         }
     |         state.changed.val = true
     |         TInstr::local_get(sl_localidx_from_int(best))
     |       } else {
     |         instr
     |       }
     |     }
     |     TBlock(bt, body) => {
     |       let child = sl_late_state_new(
     |         state.equivs.length(),
     |         state.get_counts,
     |         state.remove_equivalent_sets,
     |         state.changed,
     |       )
     |       let next_body = sl_late_rewrite_texpr(body, child)
     |       if next_body != body {
1583 |         state.changed.val = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::block(bt, next_body)
     |       } else {
     |         instr
     |       }
     |     }
     |     TLoop(bt, body) => {
     |       let child = sl_late_state_new(
     |         state.equivs.length(),
     |         state.get_counts,
     |         state.remove_equivalent_sets,
     |         state.changed,
     |       )
     |       let next_body = sl_late_rewrite_texpr(body, child)
     |       if next_body != body {
1598 |         state.changed.val = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::loop_(bt, next_body)
     |       } else {
     |         instr
     |       }
     |     }
1604 |     TTryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let child = sl_late_state_new(
     |         state.equivs.length(),
     |         state.get_counts,
     |         state.remove_equivalent_sets,
     |         state.changed,
     |       )
1611 |       let next_body = sl_late_rewrite_texpr(body, child)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if next_body != body {
1613 |         state.changed.val = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::try_table(bt, catches, next_body)
     |       } else {
1616 |         instr
     |         ^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     TIf(bt, cond, then_body, else_body) => {
     |       let next_cond = sl_late_rewrite_instr(cond, state)
     |       let then_state = sl_late_state_new(
     |         state.equivs.length(),
     |         state.get_counts,
     |         state.remove_equivalent_sets,
     |         state.changed,
     |       )
     |       let next_then = sl_late_rewrite_texpr(then_body, then_state)
     |       let next_else = else_body.map(fn(other) {
     |         let else_state = sl_late_state_new(
     |           state.equivs.length(),
     |           state.get_counts,
     |           state.remove_equivalent_sets,
     |           state.changed,
     |         )
     |         sl_late_rewrite_texpr(other, else_state)
     |       })
     |       if next_cond != cond || next_then != then_body || next_else != else_body {
1638 |         state.changed.val = true
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::if_(bt, next_cond, next_then, next_else)
     |       } else {
     |         instr
     |       }
     |     }
     |     _ => {
     |       let children = eval_children(instr)
     |       if children.is_empty() {
     |         return instr
     |       }
     |       let next_children : Array[TInstr] = []
     |       let mut changed_children = false
     |       for child in children {
     |         let next_child = sl_late_rewrite_instr(child, state)
     |         if next_child != child {
     |           changed_children = true
     |         }
     |         next_children.push(next_child)
     |       }
     |       if changed_children {
     |         state.changed.val = true
     |         mb_rebuild_non_control(instr, next_children)
     |       } else {
     |         instr
     |       }
     |     }
     |   }
     | }
     …

     | fn sl_simplify_function(
     |   func : Func,
     |   param_types : Array[ValType],
     |   options : SLSimplifyOptions,
     | ) -> (Func, Bool) {
     |   match func {
     |     TFunc(locals, body) => {
     |       let local_types = param_types.copy()
     |       for local_ in locals {
     |         local_types.push(local_)
     |       }
     |       if local_types.length() == 0 {
1710 |         return (func, false)
     |         ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let mut body = body
     |       let mut changed_any = false
     |       let mut first_cycle = true
     |       let mut cycles = 0
     |       while cycles < 12 {
     |         let get_counts = Array::make(local_types.length(), 0)
     |         sl_collect_get_counts_texpr(body, get_counts)
     |         let cycle_options = {
     |           allow_tee: options.allow_tee && !first_cycle,
     |           allow_structure: options.allow_structure,
     |           allow_nesting: options.allow_nesting,
     |         }
     |         let (after_main, changed_main) = sl_simplify_texpr_main(
     |           body, local_types, get_counts, cycle_options,
     |         )
     | 
     |         let after_counts = Array::make(local_types.length(), 0)
     |         sl_collect_get_counts_texpr(after_main, after_counts)
     |         let removed_changed = Ref::new(false)
     |         let after_removed = sl_remove_unneeded_sets_texpr(
     |           after_main, after_counts, removed_changed,
     |         )
     |         let strip_changed = Ref::new(false)
     |         let after_strip = sl_strip_nops_texpr(after_removed, strip_changed)
     | 
     |         let mut cycle_changed = changed_main ||
     |           removed_changed.val ||
     |           strip_changed.val
     |         let (after_late, late_changed) = sl_run_late_optimizations(
     |           after_strip,
     |           local_types.length(),
     |           options.allow_structure,
     |         )
     |         if late_changed {
     |           cycle_changed = true
     |           body = after_late
     |         } else {
     |           body = after_strip
     |         }
     |         if cycle_changed {
     |           changed_any = true
     |         }
     | 
     |         if first_cycle {
     |           first_cycle = false
     |           cycles += 1
     |           continue
     |         }
     |         if !cycle_changed {
     |           break
     |         }
     |         cycles += 1
     |       }
     |       if changed_any {
     |         (Func::t_func(locals, body), true)
     |       } else {
     |         (func, false)
     |       }
     |     }
1771 |     _ => (func, false)
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn sl_run_simplify_locals(
     |   mod : Module,
     |   allow_tee? : Bool = true,
     |   allow_structure? : Bool = true,
     |   allow_nesting? : Bool = true,
     | ) -> Module {
     |   let pass = simplify_locals_ir_pass(
     |     mod, allow_tee, allow_structure, allow_nesting,
     |   )
     |   match pass.walk_module(IRContext::new(), mod) {
     |     Ok(Some((_, out))) => out
1810 |     Ok(None) => mod
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Err(e) => abort("simplify_locals pass failed: \{e}")
     |   }
     | }
     …

71 uncovered line(s) in src/passes/type_refining.mbt:

    | fn tr_extract_comp_type(sub_type : SubType) -> CompType {
    |   match sub_type {
 12 |     SubType(_, _, comp) => comp
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     CompTypeSubType(comp) => comp
    |   }
    | }
    …

    | fn tr_resolve_func_type(
    |   comp_types : Array[CompType],
    |   idx : TypeIdx,
    | ) -> FuncType? {
    |   let i = match idx {
    |     TypeIdx(n) => n
 24 |     RecIdx(n) => n
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let j = i.reinterpret_as_int()
    |   if j < 0 || j >= comp_types.length() {
 28 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match comp_types[j] {
    |     FuncCompType(params, results) => Some(FuncType::new(params, results))
 32 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn tr_count_imported_funcs(mod : Module) -> Int {
    |   let mut n = 0
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 41 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(_) => n += 1
    |           _ => ()
    |         }
    |       }
    |     None => ()
    |   }
    |   n
    | }
    …

    | fn tr_collect_func_types(mod : Module) -> Array[FuncType] {
    |   let comp_types : Array[CompType] = []
    |   match mod.type_sec {
    |     Some(TypeSec(rec_types)) =>
    |       for rec_type in rec_types {
    |         match rec_type {
    |           SingleRecType(sub_type) =>
    |             comp_types.push(tr_extract_comp_type(sub_type))
    |           GroupRecType(sub_types) =>
 63 |             for sub_type in sub_types {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               comp_types.push(tr_extract_comp_type(sub_type))
    |             }
    |         }
    |       }
 68 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_types : Array[FuncType] = []
    |   match mod.import_sec {
    |     Some(ImportSec(imports)) =>
 73 |       for import_ in imports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Import(_, _, ex) = import_
    |         match ex {
    |           FuncExternType(type_idx) =>
 77 |             match tr_resolve_func_type(comp_types, type_idx) {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               Some(ft) => func_types.push(ft)
    |               None => func_types.push(FuncType::new([], []))
    |             }
 81 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for type_idx in type_idxs {
    |         match tr_resolve_func_type(comp_types, type_idx) {
    |           Some(ft) => func_types.push(ft)
 91 |           None => func_types.push(FuncType::new([], []))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
 94 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   func_types
    | }
    …

    | fn tr_flattened_type_count(rec_types : Array[RecType]) -> Int {
    |   let mut n = 0
    |   for rec_type in rec_types {
    |     match rec_type {
    |       SingleRecType(_) => n += 1
105 |       GroupRecType(sub_types) => n += sub_types.length()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   n
    | }
    …

    | fn tr_mark_exports_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
    |   match mod.export_sec {
    |     Some(ExportSec(exports)) =>
115 |       for export_ in exports {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Export(_, extern_idx) = export_
    |         match extern_idx {
    |           FuncExternIdx(FuncIdx(raw)) => {
    |             let idx = raw.reinterpret_as_int()
    |             if idx >= 0 && idx < has_unseen.length() {
121 |               has_unseen[idx] = true
    |               ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |           }
124 |           _ => ()
    |           ^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    | }
    …

    | fn tr_mark_start_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
    |   match mod.start_sec {
134 |     Some(StartSec(FuncIdx(raw))) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let idx = raw.reinterpret_as_int()
    |       if idx >= 0 && idx < has_unseen.length() {
137 |         has_unseen[idx] = true
    |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     None => ()
    |   }
    | }
    …

    | fn tr_mark_elem_unseen(mod : Module, has_unseen : Array[Bool]) -> Unit {
    |   match mod.elem_sec {
    |     Some(ElemSec(elems)) =>
148 |       for elem in elems {
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Elem(_, kind) = elem
    |         match kind {
    |           FuncsElemKind(funcs) =>
152 |             for func_idx in funcs {
    |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               let FuncIdx(raw) = func_idx
    |               let idx = raw.reinterpret_as_int()
    |               if idx >= 0 && idx < has_unseen.length() {
156 |                 has_unseen[idx] = true
    |                 ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
    |             }
    |           FuncExprsElemKind(exprs) | TypedExprsElemKind(_, exprs) =>
160 |             for expr in exprs {
    |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               for instr in expr.0 {
    |                 match instr {
    |                   RefFunc(FuncIdx(raw)) => {
    |                     let idx = raw.reinterpret_as_int()
    |                     if idx >= 0 && idx < has_unseen.length() {
166 |                       has_unseen[idx] = true
    |                       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                     }
    |                   }
169 |                   _ => ()
    |                   ^^^^^^^ 	<-- UNCOVERED
    |                 }
    |               }
    |             }
    |         }
    |       }
    |     None => ()
    |   }
    | }
    …

    | fn tr_record_call(
    |   caller_abs_idx : Int,
    |   target : FuncIdx,
    |   args : Array[TInstr],
    |   calls_by_target : Array[Array[TRCallSite]],
    | ) -> Unit {
    |   let FuncIdx(raw) = target
    |   let idx = raw.reinterpret_as_int()
    |   if idx < 0 || idx >= calls_by_target.length() {
200 |     return
    |     ^^^^^^ 	<-- UNCOVERED
    |   }
    |   calls_by_target[idx].push(tr_callsite(caller_abs_idx, args.copy()))
    | }
    …

    | fn tr_analyze_function_body(
    |   abs_func_idx : Int,
    |   body : TExpr,
    |   calls_by_target : Array[Array[TRCallSite]],
    |   has_unseen_calls : Array[Bool],
    | ) -> Unit {
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     match instr {
    |       TCall(target, args) =>
    |         tr_record_call(abs_func_idx, target, args, calls_by_target)
216 |       TRefFunc(FuncIdx(raw)) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let idx = raw.reinterpret_as_int()
    |         if idx >= 0 && idx < has_unseen_calls.length() {
219 |           has_unseen_calls[idx] = true
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), instr)
    |   })
    |   ignore(walker.walk_texpr((), body))
    | }
    …

    | fn tr_collect_global_types(mod : Module) -> Array[ValType] {
    |   let out : Array[ValType] = []
    |   match mod.global_sec {
    |     Some(GlobalSec(globals)) =>
234 |       for global in globals {
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let Global(GlobalType(vt, _), _) = global
    |         out.push(vt)
    |       }
    |     None => ()
    |   }
    |   out
    | }
    …

    | fn tr_build_local_types_by_abs(
    |   func_types : Array[FuncType],
    |   funcs : Array[Func],
    |   import_func_count : Int,
    | ) -> Array[Array[ValType]] {
    |   let out : Array[Array[ValType]] = []
    |   for abs_idx = 0; abs_idx < func_types.length(); abs_idx = abs_idx + 1 {
    |     let FuncType(params, _) = func_types[abs_idx]
    |     let locals = params.copy()
    |     let def_idx = abs_idx - import_func_count
    |     if def_idx >= 0 && def_idx < funcs.length() {
    |       match funcs[def_idx] {
    |         TFunc(extra_locals, _) =>
    |           for vt in extra_locals {
258 |             locals.push(vt)
    |             ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
260 |         _ => ()
    |         ^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     out.push(locals)
    |   }
    |   out
    | }
    …

    | fn tr_known_instr_type(
    |   instr : TInstr,
    |   caller_abs_idx : Int,
    |   local_types_by_abs : Array[Array[ValType]],
    |   global_types : Array[ValType],
    |   env : Env,
    | ) -> ValType? {
    |   match instr {
277 |     TI32Const(_) => Some(ValType::i32())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TI64Const(_) => Some(ValType::i64())
    |     TF32Const(_) => Some(ValType::f32())
    |     TF64Const(_) => Some(ValType::f64())
    |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
282 |       Some(ValType::v128())
    |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TRefNull(ht) => Some(ValType::ref_type(RefType::new(true, ht)))
    |     TRefFunc(_) =>
285 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         ValType::ref_type(
    |           RefType::new(false, HeapType::abs(AbsHeapType::func())),
    |         ),
    |       )
    |     TLocalGet(LocalIdx(raw)) => {
    |       let idx = raw.reinterpret_as_int()
    |       if caller_abs_idx < 0 || caller_abs_idx >= local_types_by_abs.length() {
293 |         return None
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let locals = local_types_by_abs[caller_abs_idx]
    |       if idx < 0 || idx >= locals.length() {
297 |         return None
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       Some(locals[idx])
    |     }
301 |     TGlobalGet(GlobalIdx(raw)) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let idx = raw.reinterpret_as_int()
    |       if idx < 0 || idx >= global_types.length() {
304 |         return None
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       Some(global_types[idx])
    |     }
    |     TRefAsNonNull(value) =>
309 |       match
    |       ^^^^^ 	<-- UNCOVERED
    |         tr_known_instr_type(
    |           value, caller_abs_idx, local_types_by_abs, global_types, env,
    |         ) {
    |         Some(RefTypeValType(rt)) =>
314 |           Some(ValType::ref_type(RefType::new(false, rt.get_heap_type())))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ => None
    |       }
    |     TRefCast(nullable, ht, _) =>
318 |       Some(ValType::ref_type(RefType::new(nullable, ht)))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TCall(target, _) =>
320 |       match env.get_functype_by_funcidx(target) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(FuncType(_, [r])) => Some(r)
    |         _ => None
    |       }
    |     TCallIndirect(type_idx, _, _, _) | TCallRef(type_idx, _, _) =>
325 |       match env.resolve_functype(type_idx) {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(FuncType(_, [r])) => Some(r)
    |         _ => None
    |       }
329 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn tr_common_supertype(a : ValType, b : ValType, env : Env) -> ValType? {
335 |   if Match::matches(a, b, env) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return Some(b)
    |   }
    |   if Match::matches(b, a, env) {
339 |     return Some(a)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   None
    | }
    …

    | fn tr_refine_param_types(
    |   old_params : Array[ValType],
    |   calls : Array[TRCallSite],
    |   local_types_by_abs : Array[Array[ValType]],
    |   global_types : Array[ValType],
    |   env : Env,
    | ) -> Array[ValType] {
    |   let new_params = old_params.copy()
    |   if calls.is_empty() {
    |     return new_params
    |   }
    |   for p = 0; p < old_params.length(); p = p + 1 {
    |     let old_param = old_params[p]
    |     match old_param {
    |       RefTypeValType(_) => ()
360 |       _ => continue
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let mut candidate : ValType? = None
    |     let mut can_refine = true
    |     for callsite in calls {
    |       let args = callsite.args
    |       if p >= args.length() {
367 |         can_refine = false
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         break
    |       }
    |       let arg = args[p]
    |       match
    |         tr_known_instr_type(
    |           arg,
    |           callsite.caller_abs_idx,
    |           local_types_by_abs,
    |           global_types,
    |           env,
    |         ) {
    |         Some(arg_ty) => {
    |           if not(Match::matches(arg_ty, old_param, env)) {
381 |             can_refine = false
    |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             break
    |           }
    |           candidate = match candidate {
    |             None => Some(arg_ty)
386 |             Some(prev) => tr_common_supertype(prev, arg_ty, env)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |           if candidate is None {
389 |             can_refine = false
    |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             break
    |           }
    |         }
393 |         None => {
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |           can_refine = false
    |           break
    |         }
    |       }
    |     }
    |     if not(can_refine) {
400 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     match candidate {
    |       Some(new_ty) if new_ty != old_param &&
    |         Match::matches(new_ty, old_param, env) => new_params[p] = new_ty
405 |       _ => ()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   new_params
    | }
    …

    | fn tr_update_param_types(
    |   body : TExpr,
    |   old_param_types : Array[ValType],
    |   new_param_types : Array[ValType],
    |   locals : Array[ValType],
    |   local_types_by_abs : Array[Array[ValType]],
    |   global_types : Array[ValType],
    |   env : Env,
    |   abs_idx : Int,
    | ) -> (Array[ValType], TExpr) {
    |   let param_fixups : Map[Int, Int] = Map::new()
    |   let next_local = [old_param_types.length() + locals.length()]
    | 
    |   let scan_sets = ModuleTransformer::new().on_tinstruction_evt(fn(
    |     self,
    |     _,
    |     instr,
    |   ) {
    |     match instr {
    |       TLocalSet(idx, value) | TLocalTee(idx, value) => {
    |         let local_i = tr_local_idx_to_int(idx)
    |         if local_i >= 0 &&
    |           local_i < old_param_types.length() &&
    |           !param_fixups.contains(local_i) {
    |           let compatible = match
    |             tr_known_instr_type(
    |               value, abs_idx, local_types_by_abs, global_types, env,
    |             ) {
    |             Some(vt) => Match::matches(vt, new_param_types[local_i], env)
452 |             None => false
    |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |           if !compatible {
    |             let fixup = next_local[0]
    |             next_local[0] = fixup + 1
    |             param_fixups[local_i] = fixup
    |           }
    |         }
    |       }
    |       _ => ()
    |     }
    |     self.walk_tinstruction_default((), instr)
    |   })
    |   ignore(scan_sets.walk_texpr((), body))
    | 
    |   let next_locals = locals.copy()
    |   let param_count = old_param_types.length()
    |   for i = 0; i < param_count; i = i + 1 {
    |     match param_fixups.get(i) {
    |       Some(_) => next_locals.push(old_param_types[i])
    |       None => ()
    |     }
    |   }
    | 
    |   let walker = ModuleTransformer::new().on_tinstruction_evt(fn(self, _, instr) {
    |     let walked = match self.walk_tinstruction_default((), instr) {
    |       Ok(Some((_, out))) => out
479 |       Ok(None) => instr
    |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(e) => return Err(e)
    |     }
    |     match walked {
    |       TLocalGet(idx) => {
    |         let local_i = tr_local_idx_to_int(idx)
    |         match param_fixups.get(local_i) {
    |           Some(fixup) =>
    |             change((), TInstr::local_get(tr_local_idx_from_int(fixup)))
488 |           None => if walked == instr { unchanged() } else { change((), walked) }
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       TLocalSet(idx, value) => {
    |         let local_i = tr_local_idx_to_int(idx)
    |         match param_fixups.get(local_i) {
    |           Some(fixup) =>
    |             change((), TInstr::local_set(tr_local_idx_from_int(fixup), value))
496 |           None => if walked == instr { unchanged() } else { change((), walked) }
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
499 |       TLocalTee(idx, value) => {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let local_i = tr_local_idx_to_int(idx)
    |         match param_fixups.get(local_i) {
    |           Some(fixup) =>
503 |             change((), TInstr::local_tee(tr_local_idx_from_int(fixup), value))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           None => if walked == instr { unchanged() } else { change((), walked) }
    |         }
    |       }
    |       _ => if walked == instr { unchanged() } else { change((), walked) }
    |     }
    |   })
    | 
    |   let rewritten = match walker.walk_texpr((), body) {
    |     Ok(Some((_, out))) => out
513 |     _ => body
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   if param_fixups.is_empty() {
    |     return (next_locals, rewritten)
    |   }
    | 
    |   let prologue : Array[TInstr] = []
    |   for i = 0; i < param_count; i = i + 1 {
    |     match param_fixups.get(i) {
    |       Some(fixup) =>
    |         prologue.push(
    |           TInstr::local_set(
    |             tr_local_idx_from_int(fixup),
    |             TInstr::local_get(tr_local_idx_from_int(i)),
    |           ),
    |         )
530 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   let next_body = TExpr::new([..prologue, ..rewritten.0])
    |   (next_locals, next_body)
    | }
    …

    | fn type_refining(mod : Module) -> Result[Module, String] {
    |   let funcs = match mod.code_sec {
    |     Some(CodeSec(funcs)) => funcs
542 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_sec = match mod.func_sec {
    |     Some(FuncSec(type_idxs)) => type_idxs
546 |     None => return Ok(mod)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let func_types = tr_collect_func_types(mod)
    |   let total_func_count = func_types.length()
    |   if funcs.is_empty() || total_func_count == 0 {
551 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   let import_func_count = tr_count_imported_funcs(mod)
    |   let calls_by_target : Array[Array[TRCallSite]] = []
    |   for _ in 0..<total_func_count {
    |     calls_by_target.push([])
    |   }
    | 
    |   let has_unseen_calls : Array[Bool] = Array::make(total_func_count, false)
    |   tr_mark_exports_unseen(mod, has_unseen_calls)
    |   tr_mark_start_unseen(mod, has_unseen_calls)
    |   tr_mark_elem_unseen(mod, has_unseen_calls)
    | 
    |   for i = 0; i < funcs.length(); i = i + 1 {
    |     let abs_idx = import_func_count + i
    |     match funcs[i] {
    |       TFunc(_, body) =>
    |         tr_analyze_function_body(
    |           abs_idx, body, calls_by_target, has_unseen_calls,
    |         )
572 |       _ => ()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | 
    |   let env = Env::new().with_module(mod)
    |   let global_types = tr_collect_global_types(mod)
    |   let local_types_by_abs = tr_build_local_types_by_abs(
    |     func_types, funcs, import_func_count,
    |   )
    | 
    |   let refined_params_by_defined : Array[Array[ValType]?] = Array::make(
    |     funcs.length(),
    |     None,
    |   )
    | 
    |   for i = 0; i < funcs.length(); i = i + 1 {
    |     let abs_idx = import_func_count + i
    |     if abs_idx < 0 || abs_idx >= total_func_count || has_unseen_calls[abs_idx] {
590 |       continue
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     let FuncType(params, _) = func_types[abs_idx]
    |     let refined = tr_refine_param_types(
    |       params,
    |       calls_by_target[abs_idx],
    |       local_types_by_abs,
    |       global_types,
    |       env,
    |     )
    |     if refined != params {
    |       refined_params_by_defined[i] = Some(refined)
    |     }
    |   }
    | 
    |   let mut has_change = false
    |   let type_recs = match mod.type_sec {
    |     Some(TypeSec(rs)) => rs.copy()
608 |     None => []
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let next_func_sec = func_sec.copy()
    |   let mut flat_type_count = tr_flattened_type_count(type_recs)
    | 
    |   for i = 0; i < funcs.length() && i < next_func_sec.length(); i = i + 1 {
    |     match refined_params_by_defined[i] {
    |       Some(new_params) => {
    |         let abs_idx = import_func_count + i
    |         if abs_idx < 0 || abs_idx >= func_types.length() {
618 |           continue
    |           ^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         let FuncType(_, old_results) = func_types[abs_idx]
    |         type_recs.push(tr_make_func_type(new_params, old_results))
    |         next_func_sec[i] = TypeIdx::new(flat_type_count.reinterpret_as_uint())
    |         flat_type_count += 1
    |         has_change = true
    |       }
    |       None => ()
    |     }
    |   }
    | 
    |   if !has_change {
631 |     return Ok(mod)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | 
    |   let next_funcs = funcs.copy()
    |   for i = 0; i < funcs.length(); i = i + 1 {
    |     match (funcs[i], refined_params_by_defined[i]) {
    |       (TFunc(locals, body), Some(new_params)) => {
    |         let abs_idx = import_func_count + i
    |         if abs_idx < 0 || abs_idx >= func_types.length() {
640 |           continue
    |           ^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         let FuncType(old_params, _) = func_types[abs_idx]
    |         let (next_locals, next_body) = tr_update_param_types(
    |           body, old_params, new_params, locals, local_types_by_abs, global_types,
    |           env, abs_idx,
    |         )
    |         next_funcs[i] = Func::t_func(next_locals, next_body)
    |       }
    |       _ => ()
    |     }
    |   }
    | 
    |   Ok(
    |     mod
    |     .with_type_sec(TypeSec::new(type_recs))
    |     .with_func_sec(FuncSec::new(next_func_sec))
    |     .with_code_sec(CodeSec::new(next_funcs)),
    |   )
    | }
    …

    | fn run_type_refining(mod : Module) -> Module {
    |   match type_refining(mod) {
    |     Ok(out) => out
665 |     Err(_) => mod
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

23 uncovered line(s) in src/passes/untee.mbt:

    | fn ut_collect_param_types(mod : Module) -> Array[Array[ValType]] {
    |   let out : Array[Array[ValType]] = []
    |   let env = Env::new().with_module(mod)
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for tidx in type_idxs {
    |         match env.resolve_functype(tidx) {
    |           Some(FuncType(params, _)) => out.push(params)
 16 |           None => out.push([])
    |           ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   out
    | }
    …

    | fn ut_rewrite_texpr(
    |   expr : TExpr,
    |   local_types : Array[ValType],
    | ) -> (TExpr, Bool) {
    |   let out : Array[TInstr] = []
    |   let mut changed = false
    |   for instr in expr.0 {
    |     let (next_instr, instr_changed) = ut_rewrite_tinstr(instr, local_types)
    |     out.push(next_instr)
    |     if instr_changed {
    |       changed = true
    |     }
    |   }
    |   if changed {
    |     (TExpr::new(out), true)
    |   } else {
 41 |     (expr, false)
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn ut_rewrite_tinstr(
    |   instr : TInstr,
    |   local_types : Array[ValType],
    | ) -> (TInstr, Bool) {
    |   match instr {
    |     TLocalTee(idx, value) => {
    |       let (next_value, value_changed) = ut_rewrite_tinstr(value, local_types)
    |       if is_unreachable_instr(next_value) {
    |         (next_value, true)
    |       } else {
    |         let local_i = ut_localidx_to_int(idx)
    |         match local_types.get(local_i) {
    |           Some(local_type) => {
    |             let lowered = TInstr::block(
    |               BlockType::val_type(local_type),
    |               TExpr::new([
    |                 TInstr::local_set(idx, next_value),
    |                 TInstr::local_get(idx),
    |               ]),
    |             )
    |             (lowered, true)
    |           }
 68 |           None => {
    |           ^^^^^^^^^ 	<-- UNCOVERED
    |             let rebuilt = TInstr::local_tee(idx, next_value)
    |             if value_changed {
 71 |               (rebuilt, true)
    |               ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             } else {
 73 |               (instr, false)
    |               ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             }
    |           }
    |         }
    |       }
    |     }
 79 |     TBlock(bt, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let (next_body, changed) = ut_rewrite_texpr(body, local_types)
    |       if changed {
 82 |         (TInstr::block(bt, next_body), true)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
 84 |         (instr, false)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
 87 |     TLoop(bt, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let (next_body, changed) = ut_rewrite_texpr(body, local_types)
    |       if changed {
 90 |         (TInstr::loop_(bt, next_body), true)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
 92 |         (instr, false)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
 95 |     TIf(bt, cond, then_body, else_body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let (next_cond, cond_changed) = ut_rewrite_tinstr(cond, local_types)
    |       let (next_then, then_changed) = ut_rewrite_texpr(then_body, local_types)
    |       let (next_else, else_changed) = match else_body {
    |         Some(other) => {
    |           let (rewritten, changed) = ut_rewrite_texpr(other, local_types)
    |           (Some(rewritten), changed)
    |         }
103 |         None => (None, false)
    |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       if cond_changed || then_changed || else_changed {
106 |         (TInstr::if_(bt, next_cond, next_then, next_else), true)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
108 |         (instr, false)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
111 |     TTryTable(bt, catches, body) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let (next_body, changed) = ut_rewrite_texpr(body, local_types)
    |       if changed {
114 |         (TInstr::try_table(bt, catches, next_body), true)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
116 |         (instr, false)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     _ => {
    |       let children = eval_children(instr)
    |       if children.is_empty() {
    |         return (instr, false)
    |       }
    |       let rewritten : Array[TInstr] = []
    |       let mut changed = false
    |       for child in children {
    |         let (next_child, child_changed) = ut_rewrite_tinstr(child, local_types)
    |         rewritten.push(next_child)
    |         if child_changed {
    |           changed = true
    |         }
    |       }
    |       if changed {
    |         (mb_rebuild_non_control(instr, rewritten), true)
    |       } else {
136 |         (instr, false)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |   }
    | }
    …

    | fn untee_pass(func : Func, params : Array[ValType]) -> (Func, Bool) {
    |   match func {
    |     TFunc(locals, body) => {
    |       let local_types = params.copy()
    |       for local_ in locals {
    |         local_types.push(local_)
    |       }
    |       let (next_body, changed) = ut_rewrite_texpr(body, local_types)
    |       if changed {
    |         (Func::t_func(locals, next_body), true)
    |       } else {
154 |         (func, false)
    |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
157 |     _ => (func, false)
    |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn untee_ir_pass(mod : Module) -> ModuleTransformer[IRContext] {
    |   let param_types = ut_collect_param_types(mod)
    |   let next_def_idx = Ref::new(0)
    |   ModuleTransformer::new().on_func_evt(fn(_, ctx, func) {
    |     let def_idx = next_def_idx.val
    |     next_def_idx.update(fn(i) { i + 1 })
    |     let params = param_types.get(def_idx).unwrap_or([])
    |     let (next_func, changed) = untee_pass(func, params)
    |     if changed {
    |       change(ctx, next_func)
    |     } else {
173 |       unchanged()
    |       ^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn run_untee(mod : Module) -> Module {
    |   let pass = untee_ir_pass(mod)
    |   match pass.walk_module(IRContext::new(), mod) {
    |     Ok(Some((_, out))) => out
183 |     Ok(None) => mod
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => abort("untee pass failed: \{e}")
    |   }
    | }
    …

4 uncovered line(s) in src/passes/util.mbt:

    | fn[T] SquareMatrix::get_or(
    |   self : SquareMatrix[T],
    |   or : T,
    |   x : UInt,
    |   y : UInt,
    | ) -> Result[T, String] {
    |   let n = self.n
    |   if x >= n || y >= n {
    |     return Err("Index out of bounds")
    |   }
 26 |   let index = x.to_uint64() * n.to_uint64() + y.to_uint64()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if self.storage.get(index) is Some(t) {
 28 |     Ok(t)
    |     ^^^^^ 	<-- UNCOVERED
    |   } else {
 30 |     Ok(or)
    |     ^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn wrap_unit_func_pass(
    |   pass : ModuleTransformer[Unit],
    | ) -> ModuleTransformer[IRContext] {
    |   ModuleTransformer::new().on_func_evt(fn(_, ctx : IRContext, func : Func) {
    |     match pass.walk_func((), func) {
    |       Ok(Some((_, new_func))) => change(ctx, new_func)
 65 |       Ok(None) => unchanged()
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(e) => Err(e)
    |     }
    |   })
    | }
    …

61 uncovered line(s) in src/passes/vacuum.mbt:

    | fn vq_collect_func_sigs(mod : Module) -> Array[VQFuncSig] {
    |   let out : Array[VQFuncSig] = []
    |   let env = Env::new().with_module(mod)
    |   match mod.func_sec {
    |     Some(FuncSec(type_idxs)) =>
    |       for tidx in type_idxs {
    |         match env.resolve_functype(tidx) {
    |           Some(FuncType(params, results)) =>
    |             out.push(VQFuncSig::new(params, results))
 25 |           None => out.push(VQFuncSig::new([], []))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |     None => ()
    |   }
    |   out
    | }
    …

    | fn vq_same_type(a : ValType?, b : ValType?) -> Bool {
    |   match (a, b) {
    |     (Some(x), Some(y)) => x == y
    |     (None, None) => true
 43 |     _ => false
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn vq_texpr_result_type(expr : TExpr, env : Env) -> ValType? {
 57 |   let TExpr(items) = expr
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if items.is_empty() {
 59 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
 61 |     vq_type_of(items[items.length() - 1], env)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn vq_is_nop_texpr(expr : TExpr) -> Bool {
    |   let TExpr(items) = expr
    |   if items.is_empty() {
    |     return true
    |   }
    |   for item in items {
    |     match item {
 73 |       TNop => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => return false
    |     }
    |   }
    |   true
    | }
    …

    | fn vq_texpr_is_unreachable(expr : TExpr) -> Bool {
 82 |   let TExpr(items) = expr
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for item in items {
 84 |     if is_unreachable_instr(item) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       return true
    |     }
    |   }
    |   false
    | }
    …

    | fn vq_wrap_texpr(expr : TExpr, env : Env) -> TInstr {
    |   let TExpr(items) = expr
    |   if items.length() == 0 {
 95 |     return TInstr::nop()
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if items.length() == 1 {
    |     return items[0]
    |   }
100 |   match vq_texpr_result_type(expr, env) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(vt) => TInstr::block(BlockType::val_type(vt), expr)
    |     None => TInstr::block(BlockType::void_(), expr)
    |   }
    | }
    …

    | fn vq_drop_texpr_value(expr : TExpr, env : Env) -> TExpr {
108 |   let wrapped = vq_wrap_texpr(expr, env)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match vq_type_of(wrapped, env) {
    |     Some(_) => TExpr::new([TInstr::drop(wrapped)])
    |     None => TExpr::new([wrapped])
    |   }
    | }
    …

    | fn vq_get_dropped_children_and_append(
    |   curr : TInstr,
    |   env : Env,
    |   dummy : TInstr,
    | ) -> TInstr {
137 |   let items : Array[TInstr] = []
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for child in vq_children_with_effects(curr) {
139 |     match vq_type_of(child, env) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(_) => items.push(TInstr::drop(child))
    |       None => items.push(child)
    |     }
    |   }
144 |   items.push(dummy)
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match vq_type_of(dummy, env) {
    |     Some(vt) => TInstr::block(BlockType::val_type(vt), TExpr::new(items))
    |     None => TInstr::block(BlockType::void_(), TExpr::new(items))
    |   }
    | }
    …

    | fn vq_optimize(
    |   instr : TInstr,
    |   result_used : Bool,
    |   type_matters : Bool,
    |   env : Env,
    | ) -> TInstr? {
    |   let initial_type = vq_type_of(instr, env)
    |   let mut type_matters = type_matters
    |   if initial_type is None {
    |     type_matters = true
    |   }
    |   if is_unreachable_instr(instr) {
    |     return Some(instr)
    |   }
    |   if result_used {
    |     return Some(instr)
    |   }
    | 
    |   let mut prev = instr
    |   let mut curr = instr
    |   for _ in 0..<64 {
    |     let curr_type = vq_type_of(curr, env)
    |     if type_matters && !vq_same_type(curr_type, initial_type) {
175 |       return Some(prev)
    |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     prev = curr
    |     match curr {
    |       TDrop(_)
    |       | TBlock(_, _)
    |       | TIf(_, _, _, _)
    |       | TLoop(_, _)
183 |       | TTryTable(_, _, _) => return Some(curr)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => ()
    |     }
    |     if vq_must_keep_unused_parent(curr) {
    |       return Some(curr)
    |     }
    |     let children = vq_children_with_effects(curr)
    |     if children.is_empty() {
    |       return None
    |     }
    |     if children.length() == 1 {
    |       curr = children[0]
    |       if is_unreachable_instr(curr) {
196 |         return Some(curr)
    |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       continue
    |     }
200 |     match curr_type {
    |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(vt) =>
202 |         match af_make_zero(vt) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(dummy) =>
204 |             return Some(vq_get_dropped_children_and_append(curr, env, dummy))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           None => return Some(curr)
    |         }
207 |       None => return Some(curr)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   Some(curr)
    | }
    …

    | fn vq_optimize_sequence(
    |   items : Array[TInstr],
    |   env : Env,
    |   result_type : ValType?,
    |   result_used : Bool,
    | ) -> Array[TInstr] {
    |   let out : Array[TInstr] = []
    |   let size = items.length()
    |   for i = 0; i < size; i = i + 1 {
    |     let child = items[i]
    |     let used = i == size - 1 && result_type is Some(_) && result_used
    |     let mut optimized = vq_process_instr(child, env, used, true)
    |     if optimized is None {
    |       match vq_type_of(child, env) {
    |         Some(vt) =>
    |           match af_make_zero(vt) {
    |             Some(zero) => optimized = Some(zero)
231 |             None => optimized = Some(child)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         None => if is_unreachable_instr(child) { optimized = Some(child) }
    |       }
    |     }
    |     match optimized {
    |       None => ()
    |       Some(next) => {
    |         out.push(next)
    |         if is_unreachable_instr(next) {
    |           break
    |         }
    |       }
    |     }
    |   }
    |   out
    | }
    …

    | fn vq_simplify_block_to_contents(
    |   bt : BlockType,
    |   body : TExpr,
    |   env : Env,
    | ) -> TInstr {
    |   if has_break_to_depth_in_texpr(body, 0) {
267 |     return TInstr::block(bt, body)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let TExpr(items) = body
    |   if items.length() == 0 {
271 |     if vq_block_result_type(bt, env) is Some(_) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       return TInstr::block(bt, body)
    |     }
274 |     return TInstr::nop()
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if items.length() == 1 {
277 |     let only = items[0]
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match vq_block_result_type(bt, env) {
    |       Some(vt) =>
280 |         match vq_type_of(only, env) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(t) if t == vt => return only
    |           _ => ()
    |         }
    |       None =>
285 |         if vq_type_of(only, env) is None || is_unreachable_instr(only) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           return only
    |         }
    |     }
    |   }
    |   TInstr::block(bt, body)
    | }
    …

    | fn vq_process_instr(
    |   instr : TInstr,
    |   env : Env,
    |   result_used : Bool,
    |   type_matters : Bool,
    | ) -> TInstr? {
    |   match instr {
    |     TBlock(bt, body) => {
    |       let result_type = vq_block_result_type(bt, env)
    |       let next_body = vq_optimize_texpr(body, env, result_type, result_used)
    |       Some(vq_simplify_block_to_contents(bt, next_body, env))
    |     }
    |     TIf(bt, condition, then_body, else_body) => {
    |       let next_condition = match vq_process_instr(condition, env, true, true) {
    |         Some(v) => v
341 |         None => condition
    |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       let arm_result_type = vq_block_result_type(bt, env)
    |       let next_then = vq_optimize_texpr(
    |         then_body,
    |         env,
    |         arm_result_type,
    |         arm_result_type is Some(_),
    |       )
    |       let next_else = match else_body {
    |         Some(other) =>
    |           Some(
    |             vq_optimize_texpr(
    |               other,
    |               env,
    |               arm_result_type,
    |               arm_result_type is Some(_),
    |             ),
    |           )
    |         None => None
    |       }
    | 
    |       match next_condition {
    |         TI32Const(I32(v)) =>
    |           if v != 0 {
    |             return Some(vq_wrap_texpr(next_then, env))
    |           } else {
368 |             return Some(
    |             ^^^^^^^^^^^^ 	<-- UNCOVERED
    |               match next_else {
    |                 Some(other) => vq_wrap_texpr(other, env)
    |                 None => TInstr::nop()
    |               },
    |             )
    |           }
    |         TI64Const(I64(v)) =>
376 |           if v != 0L {
    |           ^^^^^^^^^^^^ 	<-- UNCOVERED
    |             return Some(vq_wrap_texpr(next_then, env))
    |           } else {
379 |             return Some(
    |             ^^^^^^^^^^^^ 	<-- UNCOVERED
    |               match next_else {
    |                 Some(other) => vq_wrap_texpr(other, env)
    |                 None => TInstr::nop()
    |               },
    |             )
    |           }
    |         _ => ()
    |       }
    | 
    |       if is_unreachable_instr(next_condition) {
    |         return Some(next_condition)
    |       }
    | 
    |       match next_else {
    |         Some(other) => {
    |           if vq_is_nop_texpr(other) {
396 |             return Some(TInstr::if_(bt, next_condition, next_then, None))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |           if vq_is_nop_texpr(next_then) {
399 |             return Some(
    |             ^^^^^^^^^^^^ 	<-- UNCOVERED
    |               TInstr::if_(
    |                 bt,
402 |                 TInstr::unary(UnaryOp::i32_eqz(), next_condition),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 other,
    |                 None,
    |               ),
    |             )
    |           }
    |           match (next_then.0, other.0) {
    |             ([TDrop(left)], [TDrop(right)]) =>
    |               match (vq_type_of(left, env), vq_type_of(right, env)) {
    |                 (Some(lt), Some(rt)) if lt == rt =>
    |                   Some(
    |                     TInstr::drop(
    |                       TInstr::if_(
    |                         BlockType::val_type(lt),
    |                         next_condition,
    |                         TExpr::new([left]),
    |                         Some(TExpr::new([right])),
    |                       ),
    |                     ),
    |                   )
    |                 _ =>
423 |                   Some(TInstr::if_(bt, next_condition, next_then, Some(other)))
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               }
425 |             _ => Some(TInstr::if_(bt, next_condition, next_then, Some(other)))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |         None =>
    |           if vq_is_nop_texpr(next_then) {
    |             Some(TInstr::drop(next_condition))
    |           } else {
432 |             Some(TInstr::if_(bt, next_condition, next_then, None))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |       }
    |     }
    |     TLoop(bt, body) => {
    |       let result_type = vq_block_result_type(bt, env)
    |       let next_body = vq_optimize_texpr(
    |         body,
    |         env,
    |         result_type,
    |         result_type is Some(_),
    |       )
    |       if vq_is_nop_texpr(next_body) {
    |         Some(TInstr::nop())
    |       } else {
447 |         Some(TInstr::loop_(bt, next_body))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     }
    |     TDrop(value) => {
    |       let next_value = match vq_process_instr(value, env, false, false) {
    |         Some(v) => v
    |         None => return Some(TInstr::nop())
    |       }
    |       match next_value {
    |         TDrop(inner) => return Some(TInstr::drop(inner))
    |         TLocalTee(idx, inner) => return Some(TInstr::local_set(idx, inner))
    |         _ => ()
    |       }
    | 
    |       let dropped = TInstr::drop(next_value)
    |       if !lcs_collect_effects(dropped).has_unremovable_side_effects() {
463 |         return Some(TInstr::nop())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    | 
    |       match next_value {
467 |         TBlock(bt, body) => {
    |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let TExpr(items) = body
    |           if items.length() > 0 {
470 |             let last = items[items.length() - 1]
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             match (vq_block_result_type(bt, env), vq_type_of(last, env)) {
    |               (Some(block_vt), Some(last_vt)) if block_vt == last_vt =>
473 |                 match vq_optimize(last, false, false, env) {
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                   None =>
475 |                     if !has_break_to_depth_in_texpr(body, 0) {
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                       let next_items = items.copy()
    |                       ignore(next_items.pop())
    |                       if next_items.length() > 1 {
479 |                         return Some(
    |                         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |                           TInstr::block(
    |                             BlockType::void_(),
    |                             TExpr::new(next_items),
    |                           ),
    |                         )
    |                       }
    |                       if next_items.length() == 1 {
487 |                         return Some(next_items[0])
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                       }
489 |                       return Some(TInstr::nop())
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                     }
491 |                   Some(_) => ()
    |                   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 }
493 |               _ => ()
    |               ^^^^^^^ 	<-- UNCOVERED
    |             }
    |           }
    |         }
    |         _ => ()
    |       }
    | 
    |       match next_value {
501 |         TIf(bt, cond, then_body, Some(other_body)) => {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           let if_type = vq_block_result_type(bt, env)
    |           match if_type {
    |             Some(_) =>
505 |               if vq_texpr_is_unreachable(then_body) &&
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 vq_texpr_result_type(other_body, env) is Some(_) {
507 |                 return Some(
    |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
    |                   TInstr::if_(
    |                     BlockType::void_(),
    |                     cond,
    |                     then_body,
512 |                     Some(vq_drop_texpr_value(other_body, env)),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                   ),
    |                 )
515 |               } else if vq_texpr_is_unreachable(other_body) &&
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 vq_texpr_result_type(then_body, env) is Some(_) {
517 |                 return Some(
    |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
    |                   TInstr::if_(
    |                     BlockType::void_(),
    |                     cond,
521 |                     vq_drop_texpr_value(then_body, env),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                     Some(other_body),
    |                   ),
    |                 )
    |               }
526 |             None => ()
    |             ^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |         _ => ()
    |       }
    |       Some(dropped)
    |     }
    |     TTryTable(bt, catches, body) => {
    |       let result_type = vq_block_result_type(bt, env)
    |       let next_body = vq_optimize_texpr(
    |         body,
    |         env,
    |         result_type,
    |         result_type is Some(_),
    |       )
    |       if !vq_texpr_throws(next_body) {
    |         Some(vq_wrap_texpr(next_body, env))
    |       } else {
    |         Some(TInstr::try_table(bt, catches, next_body))
    |       }
    |     }
    |     _ => {
    |       let children = eval_children(instr)
    |       if children.is_empty() {
    |         return vq_optimize(instr, result_used, type_matters, env)
    |       }
    |       let next_children : Array[TInstr] = []
    |       for child in children {
    |         match vq_process_instr(child, env, true, true) {
    |           Some(next_child) => next_children.push(next_child)
556 |           None => next_children.push(child)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       }
    |       let rebuilt = mb_rebuild_non_control(instr, next_children)
    |       vq_optimize(rebuilt, result_used, type_matters, env)
    |     }
    |   }
    | }
    …

    | fn vq_optimize_function(
    |   mod : Module,
    |   func : Func,
    |   sig : VQFuncSig,
    | ) -> (Func, Bool) {
    |   match func {
    |     TFunc(locals, body) => {
    |       let all_locals = sig.params.copy()
    |       for local_ in locals {
    |         all_locals.push(local_)
    |       }
    |       let env = Env::new().with_module(mod).with_locals(all_locals)
    |       let result_type = match sig.results {
    |         [vt] => Some(vt)
    |         _ => None
    |       }
    |       let next_items = vq_optimize_sequence(
    |         body.0,
    |         env,
    |         result_type,
    |         sig.results.length() > 0,
    |       )
    |       if next_items.is_empty() {
    |         next_items.push(TInstr::nop())
    |       }
    |       let next_body = TExpr::new(next_items)
    |       if sig.results.length() == 0 &&
    |         !vq_texpr_has_unremovable_side_effects(next_body) {
    |         let nopped = Func::t_func(locals, TExpr::new([TInstr::nop()]))
    |         (nopped, nopped != func)
    |       } else {
    |         let next_func = Func::t_func(locals, next_body)
    |         (next_func, next_func != func)
    |       }
    |     }
601 |     _ => (func, false)
    |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn run_vacuum(mod : Module) -> Module {
    |   let pass = vacuum_ir_pass(mod)
    |   match pass.walk_module(IRContext::new(), mod) {
    |     Ok(Some((_, out))) => out
627 |     Ok(None) => mod
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => abort("vacuum pass failed: \{e}")
    |   }
    | }
    …

    | fn vq_first_func_body(mod : Module) -> TExpr {
    |   match mod.code_sec {
    |     Some(CodeSec([TFunc(_, body), ..])) => body
636 |     _ => abort("expected first typed function body")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

624 uncovered line(s) in src/transformer/transformer.mbt:

     | pub fn[T] ModuleTransformer::walk_tinstruction_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   tinstr : TInstr,
     | ) -> TransformerResult[T, TInstr] {
     |   match tinstr {
     |     // === Constants (0 children, 1 result) ===
     | 
     |     TRefNull(ht) => {
     |       let (t, ht) = match self.walk_heaptype(t, ht) {
     |         Ok(None) => (t, ht)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::ref_null(ht))))
     |     }
     |     TRefFunc(fi) => {
     |       let (t, fi) = match self.walk_funcidx(t, fi) {
     |         Ok(None) => (t, fi)
     |         Ok(Some(t)) => t
 989 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_func(fi))))
     |     }
     |     // === Nullary (0 children) ===
     | 
     |     TLocalGet(li) => {
     |       let (t, li) = match self.walk_localidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::local_get(li))))
     |     }
     |     TGlobalGet(gi) => {
     |       let (t, gi) = match self.walk_globalidx(t, gi) {
     |         Ok(None) => (t, gi)
     |         Ok(Some(t)) => t
1007 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::global_get(gi))))
     |     }
     |     TMemorySize(mi) => {
     |       let (t, mi) = match self.walk_memidx(t, mi) {
     |         Ok(None) => (t, mi)
     |         Ok(Some(t)) => t
1015 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::memory_size(mi))))
     |     }
     |     TTableSize(ti) => {
     |       let (t, ti) = match self.walk_tableidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
1023 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::table_size(ti))))
     |     }
     | 
     |     // === Unary (1 child) ===
     |     TUnary(op, i) => {
     |       let (t, op) = match self.walk_unaryop(t, op) {
     |         Ok(None) => (t, op)
1032 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::unary(op, i))))
     |     }
     |     TDrop(i) => {
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1046 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::drop(i))))
     |     }
     |     TLocalSet(li, i) => {
     |       let (t, li) = match self.walk_localidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
1054 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1059 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::local_set(li, i))))
     |     }
     |     TLocalTee(li, i) => {
     |       let (t, li) = match self.walk_localidx(t, li) {
     |         Ok(None) => (t, li)
1066 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1072 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::local_tee(li, i))))
     |     }
     |     TGlobalSet(gi, i) => {
     |       let (t, gi) = match self.walk_globalidx(t, gi) {
     |         Ok(None) => (t, gi)
     |         Ok(Some(t)) => t
1080 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1085 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::global_set(gi, i))))
     |     }
     |     TRefIsNull(i) => {
     |       let (t, i) = match self.walk_tinstruction(t, i) {
1091 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1093 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_is_null(i))))
     |     }
     |     TRefAsNonNull(i) => {
     |       let (t, i) = match self.walk_tinstruction(t, i) {
1099 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1101 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_as_non_null(i))))
     |     }
1105 |     TI31GetS(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1111 |       Ok(Some((t, TInstr::i31_get_s(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1113 |     TI31GetU(i) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1119 |       Ok(Some((t, TInstr::i31_get_u(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1121 |     TRefI31(i) => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1127 |       Ok(Some((t, TInstr::ref_i31(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TArrayLen(i) => {
     |       let (t, i) = match self.walk_tinstruction(t, i) {
1131 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1133 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::array_len(i))))
     |     }
1137 |     TAnyConvertExtern(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1143 |       Ok(Some((t, TInstr::any_convert_extern(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1145 |     TExternConvertAny(i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1151 |       Ok(Some((t, TInstr::extern_convert_any(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TThrowRef(i) => {
     |       let (t, i) = match self.walk_tinstruction(t, i) {
1155 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1157 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::throw_ref(i))))
     |     }
     | 
     |     // === Binary (2 children) ===
     |     TBinary(op, i1, i2) => {
     |       let (t, op) = match self.walk_binaryop(t, op) {
     |         Ok(None) => (t, op)
1166 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1172 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
1177 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::binary(op, i1, i2))))
     |     }
     |     TRefEq(i1, i2) => {
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
1183 |         Ok(None) => (t, i1)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1185 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
1188 |         Ok(None) => (t, i2)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1190 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_eq(i1, i2))))
     |     }
     |     TStore(op, ma, i1, i2) => {
     |       let (t, op) = match self.walk_storeop(t, op) {
     |         Ok(None) => (t, op)
1197 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1202 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1208 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
1213 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::store(op, ma, i1, i2))))
     |     }
     |     TMemoryAtomicNotify(ma, i1, i2) => {
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1220 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1225 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1230 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::memory_atomic_notify(ma, i1, i2))))
     |     }
     |     TAtomicRmw(op, ma, i1, i2) => {
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1238 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1243 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1248 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::atomic_rmw(op, ma, i1, i2))))
     |     }
     | 
     |     // === Load (1 child - address) ===
     |     TLoad(op, ma, i) => {
     |       let (t, op) = match self.walk_loadop(t, op) {
     |         Ok(None) => (t, op)
1258 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1263 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1269 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::load(op, ma, i))))
     |     }
     |     TAtomicFence => Ok(Some((t, TInstr::atomic_fence())))
     | 
     |     // === Memory operations ===
     |     TMemoryGrow(mi, i) => {
     |       let (t, mi) = match self.walk_memidx(t, mi) {
     |         Ok(None) => (t, mi)
     |         Ok(Some(t)) => t
1280 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1285 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::memory_grow(mi, i))))
     |     }
     |     TMemoryFill(mi, i1, i2, i3) => {
     |       let (t, mi) = match self.walk_memidx(t, mi) {
     |         Ok(None) => (t, mi)
     |         Ok(Some(t)) => t
1293 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1298 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
1303 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1307 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::memory_fill(mi, i1, i2, i3))))
     |     }
     |     TMemoryCopy(mi1, mi2, i1, i2, i3) => {
     |       let (t, mi1) = match self.walk_memidx(t, mi1) {
     |         Ok(None) => (t, mi1)
     |         Ok(Some(t)) => t
1316 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, mi2) = match self.walk_memidx(t, mi2) {
     |         Ok(None) => (t, mi2)
     |         Ok(Some(t)) => t
1321 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1326 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
1331 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1335 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::memory_copy(mi1, mi2, i1, i2, i3))))
     |     }
     |     TMemoryInit(di, mi, i1, i2, i3) => {
     |       let (t, di) = match self.walk_dataidx(t, di) {
     |         Ok(None) => (t, di)
     |         Ok(Some(t)) => t
1344 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, mi) = match self.walk_memidx(t, mi) {
     |         Ok(None) => (t, mi)
     |         Ok(Some(t)) => t
1349 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1354 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1358 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
     |         Ok(Some(t)) => t
1364 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::memory_init(di, mi, i1, i2, i3))))
     |     }
     |     TMemoryAtomicWait32(ma, i1, i2, i3) => {
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1371 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1376 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1381 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1386 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::memory_atomic_wait32(ma, i1, i2, i3))))
     |     }
     |     TMemoryAtomicWait64(ma, i1, i2, i3) => {
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1394 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1399 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1404 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1409 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::memory_atomic_wait64(ma, i1, i2, i3))))
     |     }
     |     TAtomicCmpxchg(op, ma, i1, i2, i3) => {
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
1417 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1422 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1427 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1432 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::atomic_cmpxchg(op, ma, i1, i2, i3))))
     |     }
     |     TDataDrop(di) => {
     |       let (t, di) = match self.walk_dataidx(t, di) {
     |         Ok(None) => (t, di)
     |         Ok(Some(t)) => t
1441 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::data_drop(di))))
     |     }
     | 
     |     // === Table operations ===
     |     TTableGet(ti, i) => {
     |       let (t, ti) = match self.walk_tableidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
1451 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1456 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::table_get(ti, i))))
     |     }
     |     TTableSet(ti, i1, i2) => {
     |       let (t, ti) = match self.walk_tableidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
1464 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1469 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
1472 |         Ok(None) => (t, i2)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1474 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::table_set(ti, i1, i2))))
     |     }
     |     TTableGrow(ti, i1, i2) => {
     |       let (t, ti) = match self.walk_tableidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
1482 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
1485 |         Ok(None) => (t, i1)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1487 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1491 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::table_grow(ti, i1, i2))))
     |     }
     |     TTableFill(ti, i1, i2, i3) => {
     |       let (t, ti) = match self.walk_tableidx(t, ti) {
     |         Ok(None) => (t, ti)
1499 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1504 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
1508 |         Ok(None) => (t, i2)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1510 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1514 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::table_fill(ti, i1, i2, i3))))
     |     }
     |     TTableCopy(ti1, ti2, i1, i2, i3) => {
     |       let (t, ti1) = match self.walk_tableidx(t, ti1) {
     |         Ok(None) => (t, ti1)
1522 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ti2) = match self.walk_tableidx(t, ti2) {
     |         Ok(None) => (t, ti2)
1527 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1532 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1537 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1542 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::table_copy(ti1, ti2, i1, i2, i3))))
     |     }
     |     TTableInit(ei, ti, i1, i2, i3) => {
     |       let (t, ei) = match self.walk_elemidx(t, ei) {
     |         Ok(None) => (t, ei)
1550 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ti) = match self.walk_tableidx(t, ti) {
     |         Ok(None) => (t, ti)
1555 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
1560 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
1565 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
1570 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::table_init(ei, ti, i1, i2, i3))))
     |     }
     |     TElemDrop(ei) => {
     |       let (t, ei) = match self.walk_elemidx(t, ei) {
     |         Ok(None) => (t, ei)
     |         Ok(Some(t)) => t
1579 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::elem_drop(ei))))
     |     }
     | 
     |     // === Calls (N children based on function type) ===
     |     TCall(fi, i) => {
     |       let (t, fi) = match self.walk_funcidx(t, fi) {
     |         Ok(None) => (t, fi)
     |         Ok(Some(t)) => t
1589 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1595 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::call(fi, i))))
     |     }
     |     TCallIndirect(tyi, tai, i0, i) => {
     |       let (t, tyi) = match self.walk_typeidx(t, tyi) {
     |         Ok(None) => (t, tyi)
     |         Ok(Some(t)) => t
1603 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, tai) = match self.walk_tableidx(t, tai) {
     |         Ok(None) => (t, tai)
     |         Ok(Some(t)) => t
1608 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
1614 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1619 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::call_indirect(tyi, tai, i0, i))))
     |     }
     |     TCallRef(tyi, i0, i) => {
     |       let (t, tyi) = match self.walk_typeidx(t, tyi) {
     |         Ok(None) => (t, tyi)
1626 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
1633 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
1636 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1638 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::call_ref(tyi, i0, i))))
     |     }
     |     TReturnCall(fi, i) => {
     |       let (t, fi) = match self.walk_funcidx(t, fi) {
     |         Ok(None) => (t, fi)
1645 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1652 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::return_call(fi, i))))
     |     }
     |     TReturnCallIndirect(tyi, tai, i0, i) => {
     |       let (t, tyi) = match self.walk_typeidx(t, tyi) {
     |         Ok(None) => (t, tyi)
1659 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, tai) = match self.walk_tableidx(t, tai) {
     |         Ok(None) => (t, tai)
1664 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {
     |         Ok(None) => (t, i0)
1670 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1676 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::return_call_indirect(tyi, tai, i0, i))))
     |     }
     |     TReturnCallRef(tyi, i0, i) => {
     |       let (t, tyi) = match self.walk_typeidx(t, tyi) {
     |         Ok(None) => (t, tyi)
1683 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {
     |         Ok(None) => (t, i0)
1689 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
1693 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1695 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::return_call_ref(tyi, i0, i))))
     |     }
     | 
     |     // === Control flow ===
     |     TBlock(bt, e) => {
     |       let (t, bt) = match self.walk_blocktype(t, bt) {
     |         Ok(None) => (t, bt)
1704 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, e) = match self.walk_texpr(t, e) {
1708 |         Ok(None) => (t, e)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1710 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::block(bt, e))))
     |     }
     |     TLoop(bt, e) => {
     |       let (t, bt) = match self.walk_blocktype(t, bt) {
     |         Ok(None) => (t, bt)
1717 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, e) = match self.walk_texpr(t, e) {
1721 |         Ok(None) => (t, e)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1723 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::loop_(bt, e))))
     |     }
     |     TIf(bt, i_if, e_then, e_else_option) => {
     |       let (t, bt) = match self.walk_blocktype(t, bt) {
     |         Ok(None) => (t, bt)
1730 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i_if) = match self.walk_tinstruction(t, i_if) {
     |         Ok(None) => (t, i_if)
     |         Ok(Some(t)) => t
1736 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, e_then) = match self.walk_texpr(t, e_then) {
1739 |         Ok(None) => (t, e_then)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1741 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, e_else_option) = if e_else_option is Some(e_else) {
     |         match self.walk_texpr(t, e_else) {
1745 |           Ok(None) => (t, e_else_option)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(Some((t, e_else))) => (t, Some(e_else))
1747 |           Err(t) => return Err(t)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
     |         (t, e_else_option)
     |       }
     |       Ok(Some((t, TInstr::if_(bt, i_if, e_then, e_else_option))))
     |     }
     |     TTryTable(bt, c, e) => {
     |       let (t, bt) = match self.walk_blocktype(t, bt) {
     |         Ok(None) => (t, bt)
1757 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, c) = match self.walk_array(t, ModuleTransformer::walk_catch, c) {
     |         Ok(None) => (t, c)
     |         Ok(Some(t)) => t
1763 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, e) = match self.walk_texpr(t, e) {
1766 |         Ok(None) => (t, e)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1768 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::try_table(bt, c, e))))
     |     }
     |     TThrow(ti, i) => {
     |       let (t, ti) = match self.walk_tagidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
1776 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1782 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::throw_(ti, i))))
     |     }
     | 
     |     // === Branches ===
     |     TBr(li, i) => {
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
1792 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1798 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::br(li, i))))
     |     }
     |     TBrIf(li, i0, i) => {
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
1806 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
1811 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1817 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::br_if(li, i0, i))))
     |     }
     |     TBrTable(ls, li, i0, i) => {
     |       let (t, ls) = match
     |         self.walk_array(t, ModuleTransformer::walk_labelidx, ls) {
     |         Ok(None) => (t, ls)
     |         Ok(Some(t)) => t
1826 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
1831 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
1836 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1842 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::br_table(ls, li, i0, i))))
     |     }
1846 |     TBrOnNull(li, i0, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1852 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match
1858 |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1863 |       Ok(Some((t, TInstr::br_on_null(li, i0, i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1865 |     TBrOnNonNull(li, i0, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1871 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match
1877 |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1882 |       Ok(Some((t, TInstr::br_on_non_null(li, i0, i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1884 |     TBrOnCast(li, co, ht0, ht1, i0, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1890 |       let (t, ht0) = match self.walk_heaptype(t, ht0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, ht0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1895 |       let (t, ht1) = match self.walk_heaptype(t, ht1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, ht1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1900 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match
1906 |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
1911 |       Ok(Some((t, TInstr::br_on_cast(li, co.0, ht0, co.1, ht1, i0, i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TBrOnCastFail(li, co, ht0, ht1, i0, i) => {
     |       let (t, li) = match self.walk_labelidx(t, li) {
     |         Ok(None) => (t, li)
1916 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ht0) = match self.walk_heaptype(t, ht0) {
     |         Ok(None) => (t, ht0)
1921 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ht1) = match self.walk_heaptype(t, ht1) {
     |         Ok(None) => (t, ht1)
1926 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
1930 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
1932 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
1937 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::br_on_cast_fail(li, co.0, ht0, co.1, ht1, i0, i))))
     |     }
     |     TReturn(i) => {
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1947 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::return_(i))))
     |     }
     | 
     |     // === Select ===
     |     TSelect(vts_option, i0, i1, i2) => {
     |       let (t, vts_option) = if vts_option is Some(vts) {
     |         match self.walk_array(t, ModuleTransformer::walk_valtype, vts) {
     |           Ok(None) => (t, vts_option)
1957 |           Ok(Some((t, vts))) => (t, Some(vts))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Err(t) => return Err(t)
     |         }
     |       } else {
     |         (t, vts_option)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
1966 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
1971 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
1976 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::select(vts_option, i0, i1, i2))))
     |     }
     | 
     |     // === GC: Structs ===
     |     TStructNew(ti, i) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
1986 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
1992 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::struct_new(ti, i))))
     |     }
     |     TStructNewDefault(ti) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
1999 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::struct_new_default(ti))))
     |     }
     |     TStructGet(ti, f, i) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2008 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2011 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2013 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::struct_get(ti, f, i))))
     |     }
     |     TStructGetS(ti, f, i) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2021 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2024 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2026 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::struct_get_s(ti, f, i))))
     |     }
     |     TStructGetU(ti, f, i) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
2033 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2037 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2039 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::struct_get_u(ti, f, i))))
     |     }
     |     TStructSet(ti, f, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2047 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
2050 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2052 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
2057 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::struct_set(ti, f, i0, i1))))
     |     }
     | 
     |     // === GC: Arrays ===
     |     TArrayNew(ti, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2067 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
2072 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2076 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_new(ti, i0, i1))))
     |     }
     |     TArrayNewDefault(ti, i) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2085 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
2089 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_new_default(ti, i))))
     |     }
     |     TArrayNewFixed(ti, i) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2098 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match
     |         self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
2104 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::array_new_fixed(ti, i))))
     |     }
     |     TArrayNewData(ti, di, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
2111 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, di) = match self.walk_dataidx(t, di) {
     |         Ok(None) => (t, di)
2116 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
2121 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2126 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_new_data(ti, di, i0, i1))))
     |     }
     |     TArrayNewElem(ti, ei, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
2134 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ei) = match self.walk_elemidx(t, ei) {
     |         Ok(None) => (t, ei)
2139 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
2144 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2149 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_new_elem(ti, ei, i0, i1))))
     |     }
     |     TArrayGet(ti, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2158 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
2161 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2163 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
2168 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::array_get(ti, i0, i1))))
     |     }
     |     TArrayGetS(ti, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2176 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
2179 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2181 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2185 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_get_s(ti, i0, i1))))
     |     }
     |     TArrayGetU(ti, i0, i1) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
2193 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
2197 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2199 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2203 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_get_u(ti, i0, i1))))
     |     }
     |     TArraySet(ti, i0, i1, i2) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2212 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
2215 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2217 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2221 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
2227 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::array_set(ti, i0, i1, i2))))
     |     }
     |     TArrayFill(ti, i0, i1, i2, i3) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
2235 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
2238 |         Ok(None) => (t, i0)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2240 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2244 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
2250 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
2254 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_fill(ti, i0, i1, i2, i3))))
     |     }
     |     TArrayCopy(ti0, ti1, i0, i1, i2, i3, i4) => {
     |       let (t, ti0) = match self.walk_typeidx(t, ti0) {
     |         Ok(None) => (t, ti0)
     |         Ok(Some(t)) => t
2263 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, ti1) = match self.walk_typeidx(t, ti1) {
     |         Ok(None) => (t, ti1)
     |         Ok(Some(t)) => t
2268 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
2273 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2277 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
2283 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
2287 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i4) = match self.walk_tinstruction(t, i4) {
     |         Ok(None) => (t, i4)
2292 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_copy(ti0, ti1, i0, i1, i2, i3, i4))))
     |     }
2297 |     TArrayInitData(ti, di, i0, i1, i2, i3) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2303 |       let (t, di) = match self.walk_dataidx(t, di) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, di)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2308 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2313 |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2318 |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2323 |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i3)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2328 |       Ok(Some((t, TInstr::array_init_data(ti, di, i0, i1, i2, i3))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TArrayInitElem(ti, ei, i0, i1, i2, i3) => {
     |       let (t, ti) = match self.walk_typeidx(t, ti) {
     |         Ok(None) => (t, ti)
2333 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ei) = match self.walk_elemidx(t, ei) {
     |         Ok(None) => (t, ei)
2338 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
2343 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2348 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |         Ok(None) => (t, i2)
2353 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i3) = match self.walk_tinstruction(t, i3) {
     |         Ok(None) => (t, i3)
2358 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::array_init_elem(ti, ei, i0, i1, i2, i3))))
     |     }
     | 
     |     // === GC: Casts ===
     |     TRefGetDesc(i) => {
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2367 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2369 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_get_desc(i))))
     |     }
     |     TRefTest(b, ht, i) => {
     |       let (t, ht) = match self.walk_heaptype(t, ht) {
     |         Ok(None) => (t, ht)
     |         Ok(Some(t)) => t
2377 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2380 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2382 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_test(b, ht, i))))
     |     }
     |     TRefCast(b, ht, i) => {
     |       let (t, ht) = match self.walk_heaptype(t, ht) {
     |         Ok(None) => (t, ht)
2389 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2393 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2395 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_cast(b, ht, i))))
     |     }
     |     TRefTestDesc(b, ht, i) => {
     |       let (t, ht) = match self.walk_heaptype(t, ht) {
     |         Ok(None) => (t, ht)
2402 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
2406 |         Ok(None) => (t, i)
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
2408 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_test_desc(b, ht, i))))
     |     }
     |     TRefCastDescEq(b, ht, i) => {
     |       let (t, ht) = match self.walk_heaptype(t, ht) {
     |         Ok(None) => (t, ht)
2415 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
2421 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, TInstr::ref_cast_desc_eq(b, ht, i))))
     |     }
     | 
     |     // === SIMD: Splat (scalar -> v128) ===
2427 |     TI8x16Splat(i) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2433 |       Ok(Some((t, TInstr::i8x16_splat(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2435 |     TI16x8Splat(i) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2441 |       Ok(Some((t, TInstr::i16x8_splat(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2443 |     TI32x4Splat(i) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2449 |       Ok(Some((t, TInstr::i32x4_splat(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2451 |     TI64x2Splat(i) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2457 |       Ok(Some((t, TInstr::i64x2_splat(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2459 |     TF32x4Splat(i) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2465 |       Ok(Some((t, TInstr::f32x4_splat(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2467 |     TF64x2Splat(i) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i) = match self.walk_tinstruction(t, i) {
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2473 |       Ok(Some((t, TInstr::f64x2_splat(i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Extract lane (v128 -> scalar) ===
2477 |     TExtractLane(op, li, i) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, op) = match self.walk_extractlaneop(t, op) {
     |         Ok(None) => (t, op)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2483 |       let (t, li) = match self.walk_laneidx(t, li) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2488 |       let (t, i) = match self.walk_tinstruction(t, i) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2493 |       Ok(Some((t, TInstr::extract_lane(op, li, i))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Replace lane (v128, scalar -> v128) ===
2497 |     TReplaceLane(op, li, i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, op) = match self.walk_replacelaneop(t, op) {
     |         Ok(None) => (t, op)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2503 |       let (t, li) = match self.walk_laneidx(t, li) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, li)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2508 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2513 |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2518 |       Ok(Some((t, TInstr::replace_lane(op, li, i0, i1))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Shuffle (v128, v128 -> v128 with 16 lane indices) ===
     |     TI8x16Shuffle(
     |       li0,
     |       li1,
     |       li2,
     |       li3,
     |       li4,
     |       li5,
     |       li6,
     |       li7,
     |       li8,
     |       li9,
     |       li10,
     |       li11,
     |       li12,
     |       li13,
     |       li14,
     |       li15,
     |       i0,
     |       i1
     |     ) => {
     |       let (t, li0) = match self.walk_laneidx(t, li0) {
     |         Ok(None) => (t, li0)
2544 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li1) = match self.walk_laneidx(t, li1) {
     |         Ok(None) => (t, li1)
2549 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li2) = match self.walk_laneidx(t, li2) {
     |         Ok(None) => (t, li2)
2554 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li3) = match self.walk_laneidx(t, li3) {
     |         Ok(None) => (t, li3)
2559 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li4) = match self.walk_laneidx(t, li4) {
     |         Ok(None) => (t, li4)
2564 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li5) = match self.walk_laneidx(t, li5) {
     |         Ok(None) => (t, li5)
2569 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li6) = match self.walk_laneidx(t, li6) {
     |         Ok(None) => (t, li6)
2574 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li7) = match self.walk_laneidx(t, li7) {
     |         Ok(None) => (t, li7)
2579 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li8) = match self.walk_laneidx(t, li8) {
     |         Ok(None) => (t, li8)
2584 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li9) = match self.walk_laneidx(t, li9) {
     |         Ok(None) => (t, li9)
2589 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li10) = match self.walk_laneidx(t, li10) {
     |         Ok(None) => (t, li10)
2594 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li11) = match self.walk_laneidx(t, li11) {
     |         Ok(None) => (t, li11)
2599 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li12) = match self.walk_laneidx(t, li12) {
     |         Ok(None) => (t, li12)
2604 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li13) = match self.walk_laneidx(t, li13) {
     |         Ok(None) => (t, li13)
2609 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li14) = match self.walk_laneidx(t, li14) {
     |         Ok(None) => (t, li14)
2614 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li15) = match self.walk_laneidx(t, li15) {
     |         Ok(None) => (t, li15)
2619 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
2624 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2629 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(
     |         Some(
     |           (
     |             t,
     |             TInstr::i8x16_shuffle(
     |               li0, li1, li2, li3, li4, li5, li6, li7, li8, li9, li10, li11, li12,
     |               li13, li14, li15, i0, i1,
     |             ),
     |           ),
     |         ),
     |       )
     |     }
     | 
     |     // === SIMD: Swizzle (v128, v128 -> v128) ===
2646 |     TI8x16Swizzle(i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2652 |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2657 |       Ok(Some((t, TInstr::i8x16_swizzle(i0, i1))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2659 |     TI8x16RelaxedSwizzle(i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2665 |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2670 |       Ok(Some((t, TInstr::i8x16_relaxed_swizzle(i0, i1))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Shift (v128, i32 -> v128) ===
2674 |     TV128Shift(op, i0, i1) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, op) = match self.walk_v128shiftop(t, op) {
     |         Ok(None) => (t, op)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2680 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2685 |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2690 |       Ok(Some((t, TInstr::v128_shift(op, i0, i1))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Ternary (v128, v128, v128 -> v128) ===
2694 |     TV128Ternary(op, i0, i1, i2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, op) = match self.walk_v128ternaryop(t, op) {
     |         Ok(None) => (t, op)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2700 |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i0)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2705 |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i1)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2710 |       let (t, i2) = match self.walk_tinstruction(t, i2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, i2)
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
2715 |       Ok(Some((t, TInstr::v128_ternary(op, i0, i1, i2))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Lane load (v128, addr -> v128) ===
     |     TV128LoadLane(op, ma, li, i0, i1) => {
     |       let (t, op) = match self.walk_v128loadlaneop(t, op) {
     |         Ok(None) => (t, op)
2722 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
2727 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li) = match self.walk_laneidx(t, li) {
     |         Ok(None) => (t, li)
2732 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
2737 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2742 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::v128_load_lane(op, ma, li, i0, i1))))
     |     }
     | 
     |     // === SIMD: Lane store (v128, addr -> void) ===
     |     TV128StoreLane(op, ma, li, i0, i1) => {
     |       let (t, op) = match self.walk_v128storelaneop(t, op) {
     |         Ok(None) => (t, op)
2752 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, ma) = match self.walk_memarg(t, ma) {
     |         Ok(None) => (t, ma)
2757 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, li) = match self.walk_laneidx(t, li) {
     |         Ok(None) => (t, li)
2762 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i0) = match self.walk_tinstruction(t, i0) {
     |         Ok(None) => (t, i0)
2767 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       let (t, i1) = match self.walk_tinstruction(t, i1) {
     |         Ok(None) => (t, i1)
2772 |         Ok(Some(t)) => t
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, TInstr::v128_store_lane(op, ma, li, i0, i1))))
     |     }
     |     _ => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_instruction_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   instr : Instruction,
     | ) -> TransformerResult[T, Instruction] {
     |   match instr {
     |     // Control instructions
     |     Block(bt, body) =>
2807 |       match self.walk_blocktype(t, bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) =>
2810 |           match self.walk_expr(t, body) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(None)
     |             Ok(Some((t, body))) => Ok(Some((t, Instruction::block(bt, body))))
     |           }
     |         Ok(Some((t, bt))) =>
2816 |           match self.walk_expr(t, body) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(Some((t, Instruction::block(bt, body))))
     |             Ok(Some((t, body))) => Ok(Some((t, Instruction::block(bt, body))))
     |           }
     |       }
     |     Loop(bt, body) =>
2823 |       match self.walk_blocktype(t, bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) =>
2826 |           match self.walk_expr(t, body) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(None)
     |             Ok(Some((t, body))) => Ok(Some((t, Instruction::loop_(bt, body))))
     |           }
     |         Ok(Some((t, bt))) =>
2832 |           match self.walk_expr(t, body) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(Some((t, Instruction::loop_(bt, body))))
     |             Ok(Some((t, body))) => Ok(Some((t, Instruction::loop_(bt, body))))
     |           }
     |       }
2838 |     If(bt, then_body, else_body_opt) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, bt) = match self.walk_blocktype(t, bt) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, bt)
     |         Ok(Some((t, bt))) => (t, bt)
     |       }
     |       let (t, then_body) = match
2845 |         self.walk_array(t, ModuleTransformer::walk_instruction, then_body) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, then_body)
     |         Ok(Some((t, arr))) => (t, arr)
     |       }
2850 |       let (t, else_body_opt) = match else_body_opt {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => (t, None)
     |         Some(else_body) =>
2853 |           match
     |           ^^^^^ 	<-- UNCOVERED
     |             self.walk_array(t, ModuleTransformer::walk_instruction, else_body) {
     |             Err(e) => return Err(e)
     |             Ok(None) => (t, Some(else_body))
     |             Ok(Some((t, arr))) => (t, Some(arr))
     |           }
     |       }
2860 |       Ok(Some((t, Instruction::if_(bt, then_body, else_body_opt))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     TryTable(bt, catches, body) =>
2863 |       match self.walk_blocktype(t, bt) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) =>
2866 |           match self.walk_array(t, ModuleTransformer::walk_catch, catches) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) =>
2869 |               match self.walk_expr(t, body) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Err(e) => Err(e)
     |                 Ok(None) => Ok(None)
     |                 Ok(Some((t, body))) =>
2873 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             Ok(Some((t, catches))) =>
2876 |               match self.walk_expr(t, body) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Err(e) => Err(e)
     |                 Ok(None) =>
2879 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Ok(Some((t, body))) =>
2881 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |         Ok(Some((t, bt))) =>
2885 |           match self.walk_array(t, ModuleTransformer::walk_catch, catches) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) =>
2888 |               match self.walk_expr(t, body) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Err(e) => Err(e)
     |                 Ok(None) =>
2891 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Ok(Some((t, body))) =>
2893 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             Ok(Some((t, catches))) =>
2896 |               match self.walk_expr(t, body) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Err(e) => Err(e)
     |                 Ok(None) =>
2899 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Ok(Some((t, body))) =>
2901 |                   Ok(Some((t, Instruction::try_table(bt, catches, body))))
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |           }
     |       }
     | 
     |     // Branch instructions
     |     Br(l) =>
2908 |       match self.walk_labelidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::br(l))))
     |       }
     |     BrIf(l) =>
2914 |       match self.walk_labelidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::br_if(l))))
     |       }
     |     BrTable(labels, default) =>
2920 |       match self.walk_array(t, ModuleTransformer::walk_labelidx, labels) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) =>
2923 |           match self.walk_labelidx(t, default) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(None)
     |             Ok(Some((t, default))) =>
2927 |               Ok(Some((t, Instruction::br_table(labels, default))))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         Ok(Some((t, labels))) =>
2930 |           match self.walk_labelidx(t, default) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(Some((t, Instruction::br_table(labels, default))))
     |             Ok(Some((t, default))) =>
2934 |               Ok(Some((t, Instruction::br_table(labels, default))))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     |     BrOnNull(l) =>
2938 |       match self.walk_labelidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::br_on_null(l))))
     |       }
     |     BrOnNonNull(l) =>
2944 |       match self.walk_labelidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::br_on_non_null(l))))
     |       }
2949 |     BrOnCast(l, op, ht1, ht2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, l) = match self.walk_labelidx(t, l) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, l)
     |         Ok(Some((t, l))) => (t, l)
     |       }
2955 |       let (t, ht1) = match self.walk_heaptype(t, ht1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ht1)
     |         Ok(Some((t, ht1))) => (t, ht1)
     |       }
2960 |       let (t, ht2) = match self.walk_heaptype(t, ht2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ht2)
     |         Ok(Some((t, ht2))) => (t, ht2)
     |       }
2965 |       Ok(Some((t, Instruction::br_on_cast(l, op.0, ht1, op.1, ht2))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2967 |     BrOnCastFail(l, op, ht1, ht2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, l) = match self.walk_labelidx(t, l) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, l)
     |         Ok(Some((t, l))) => (t, l)
     |       }
2973 |       let (t, ht1) = match self.walk_heaptype(t, ht1) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ht1)
     |         Ok(Some((t, ht1))) => (t, ht1)
     |       }
2978 |       let (t, ht2) = match self.walk_heaptype(t, ht2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ht2)
     |         Ok(Some((t, ht2))) => (t, ht2)
     |       }
2983 |       Ok(Some((t, Instruction::br_on_cast_fail(l, op.0, ht1, op.1, ht2))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Call instructions
     |     Call(f) =>
2988 |       match self.walk_funcidx(t, f) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, f))) => Ok(Some((t, Instruction::call(f))))
     |       }
2993 |     CallIndirect(ty, tbl) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, ty) = match self.walk_typeidx(t, ty) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ty)
     |         Ok(Some((t, ty))) => (t, ty)
     |       }
2999 |       let (t, tbl) = match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, tbl)
     |         Ok(Some((t, tbl))) => (t, tbl)
     |       }
3004 |       Ok(Some((t, Instruction::call_indirect(ty, tbl))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     ReturnCall(f) =>
3007 |       match self.walk_funcidx(t, f) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, f))) => Ok(Some((t, Instruction::return_call(f))))
     |       }
3012 |     ReturnCallIndirect(ty, tbl) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, ty) = match self.walk_typeidx(t, ty) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ty)
     |         Ok(Some((t, ty))) => (t, ty)
     |       }
3018 |       let (t, tbl) = match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, tbl)
     |         Ok(Some((t, tbl))) => (t, tbl)
     |       }
3023 |       Ok(Some((t, Instruction::return_call_indirect(ty, tbl))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     CallRef(ty) =>
3026 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::call_ref(ty))))
     |       }
     |     ReturnCallRef(ty) =>
3032 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::return_call_ref(ty))))
     |       }
     | 
     |     // Variable instructions
     |     LocalGet(l) =>
3040 |       match self.walk_localidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::local_get(l))))
     |       }
     |     LocalSet(l) =>
3046 |       match self.walk_localidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::local_set(l))))
     |       }
     |     LocalTee(l) =>
3052 |       match self.walk_localidx(t, l) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, l))) => Ok(Some((t, Instruction::local_tee(l))))
     |       }
     |     GlobalGet(g) =>
     |       match self.walk_globalidx(t, g) {
3059 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, g))) => Ok(Some((t, Instruction::global_get(g))))
     |       }
     |     GlobalSet(g) =>
3064 |       match self.walk_globalidx(t, g) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, g))) => Ok(Some((t, Instruction::global_set(g))))
     |       }
     | 
     |     // Table instructions
     |     TableGet(tbl) =>
3072 |       match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, tbl))) => Ok(Some((t, Instruction::table_get(tbl))))
     |       }
     |     TableSet(tbl) =>
3078 |       match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, tbl))) => Ok(Some((t, Instruction::table_set(tbl))))
     |       }
     |     TableGrow(tbl) =>
3084 |       match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, tbl))) => Ok(Some((t, Instruction::table_grow(tbl))))
     |       }
     |     TableSize(tbl) =>
3090 |       match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, tbl))) => Ok(Some((t, Instruction::table_size(tbl))))
     |       }
     |     TableFill(tbl) =>
3096 |       match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, tbl))) => Ok(Some((t, Instruction::table_fill(tbl))))
     |       }
3101 |     TableCopy(t1, t2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, t1) = match self.walk_tableidx(t, t1) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, t1)
     |         Ok(Some((t, t1))) => (t, t1)
     |       }
3107 |       let (t, t2) = match self.walk_tableidx(t, t2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, t2)
     |         Ok(Some((t, t2))) => (t, t2)
     |       }
3112 |       Ok(Some((t, Instruction::table_copy(t1, t2))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3114 |     TableInit(e, tbl) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, e) = match self.walk_elemidx(t, e) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, e)
     |         Ok(Some((t, e))) => (t, e)
     |       }
3120 |       let (t, tbl) = match self.walk_tableidx(t, tbl) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, tbl)
     |         Ok(Some((t, tbl))) => (t, tbl)
     |       }
3125 |       Ok(Some((t, Instruction::table_init(e, tbl))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     ElemDrop(e) =>
3128 |       match self.walk_elemidx(t, e) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, e))) => Ok(Some((t, Instruction::elem_drop(e))))
     |       }
     | 
     |     // Reference instructions
     |     RefNull(ht) =>
     |       match self.walk_heaptype(t, ht) {
3137 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ht))) => Ok(Some((t, Instruction::ref_null(ht))))
     |       }
     |     RefFunc(f) =>
     |       match self.walk_funcidx(t, f) {
3143 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, f))) => Ok(Some((t, Instruction::ref_func(f))))
     |       }
     |     RefTest(nullable, ht) =>
3148 |       match self.walk_heaptype(t, ht) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ht))) => Ok(Some((t, Instruction::ref_test(nullable, ht))))
     |       }
     |     RefCast(nullable, ht) =>
3154 |       match self.walk_heaptype(t, ht) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ht))) => Ok(Some((t, Instruction::ref_cast(nullable, ht))))
     |       }
3159 |     RefGetDesc => Ok(Some((t, Instruction::ref_get_desc())))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTestDesc(nullable, ht) =>
3161 |       match self.walk_heaptype(t, ht) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ht))) =>
3165 |           Ok(Some((t, Instruction::ref_test_desc(nullable, ht))))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     RefCastDescEq(nullable, ht) =>
3168 |       match self.walk_heaptype(t, ht) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ht))) =>
3172 |           Ok(Some((t, Instruction::ref_cast_desc_eq(nullable, ht))))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |     // Struct/Array instructions
     |     StructNew(ty) =>
     |       match self.walk_typeidx(t, ty) {
3178 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::struct_new(ty))))
     |       }
     |     StructNewDefault(ty) =>
     |       match self.walk_typeidx(t, ty) {
3184 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
3186 |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::struct_new_default(ty))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     StructGet(ty, f) =>
3189 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::struct_get(ty, f))))
     |       }
     |     StructGetS(ty, f) =>
3195 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::struct_get_s(ty, f))))
     |       }
     |     StructGetU(ty, f) =>
3201 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::struct_get_u(ty, f))))
     |       }
     |     StructSet(ty, f) =>
3207 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::struct_set(ty, f))))
     |       }
     |     ArrayNew(ty) =>
3213 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_new(ty))))
     |       }
     |     ArrayNewDefault(ty) =>
3219 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_new_default(ty))))
     |       }
     |     ArrayNewFixed(ty, n) =>
3225 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_new_fixed(ty, n))))
     |       }
     |     ArrayNewData(ty, n) =>
3231 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_new_data(ty, n))))
     |       }
3236 |     ArrayNewElem(ty, e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, ty) = match self.walk_typeidx(t, ty) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ty)
     |         Ok(Some((t, ty))) => (t, ty)
     |       }
3242 |       let (t, e) = match self.walk_elemidx(t, e) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, e)
     |         Ok(Some((t, e))) => (t, e)
     |       }
3247 |       Ok(Some((t, Instruction::array_new_elem(ty, e))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     ArrayGet(ty) =>
3250 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_get(ty))))
     |       }
     |     ArrayGetS(ty) =>
3256 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_get_s(ty))))
     |       }
     |     ArrayGetU(ty) =>
3262 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_get_u(ty))))
     |       }
     |     ArraySet(ty) =>
3268 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_set(ty))))
     |       }
     |     ArrayFill(ty) =>
3274 |       match self.walk_typeidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::array_fill(ty))))
     |       }
3279 |     ArrayCopy(t1, t2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, t1) = match self.walk_typeidx(t, t1) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, t1)
     |         Ok(Some((t, t1))) => (t, t1)
     |       }
3285 |       let (t, t2) = match self.walk_typeidx(t, t2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, t2)
     |         Ok(Some((t, t2))) => (t, t2)
     |       }
3290 |       Ok(Some((t, Instruction::array_copy(t1, t2))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3292 |     ArrayInitData(ty, d) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, ty) = match self.walk_typeidx(t, ty) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ty)
     |         Ok(Some((t, ty))) => (t, ty)
     |       }
3298 |       let (t, d) = match self.walk_dataidx(t, d) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, d)
     |         Ok(Some((t, d))) => (t, d)
     |       }
3303 |       Ok(Some((t, Instruction::array_init_data(ty, d))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3305 |     ArrayInitElem(ty, e) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, ty) = match self.walk_typeidx(t, ty) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, ty)
     |         Ok(Some((t, ty))) => (t, ty)
     |       }
3311 |       let (t, e) = match self.walk_elemidx(t, e) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, e)
     |         Ok(Some((t, e))) => (t, e)
     |       }
3316 |       Ok(Some((t, Instruction::array_init_elem(ty, e))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // Memory instructions
     |     MemoryAtomicNotify(ma) =>
3321 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) =>
3325 |           Ok(Some((t, Instruction::memory_atomic_notify(ma))))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     MemoryAtomicWait32(ma) =>
3328 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) =>
3332 |           Ok(Some((t, Instruction::memory_atomic_wait32(ma))))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     MemoryAtomicWait64(ma) =>
3335 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) =>
3339 |           Ok(Some((t, Instruction::memory_atomic_wait64(ma))))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
3341 |     AtomicFence => Ok(Some((t, Instruction::atomic_fence())))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I32AtomicLoad(ma) =>
3343 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i32_atomic_load(ma))))
     |       }
     |     I64AtomicLoad(ma) =>
3349 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_load(ma))))
     |       }
     |     I32AtomicLoad8U(ma) =>
3355 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i32_atomic_load8_u(ma))))
     |       }
     |     I32AtomicLoad16U(ma) =>
3361 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i32_atomic_load16_u(ma))))
     |       }
     |     I64AtomicLoad8U(ma) =>
3367 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_load8_u(ma))))
     |       }
     |     I64AtomicLoad16U(ma) =>
3373 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_load16_u(ma))))
     |       }
     |     I64AtomicLoad32U(ma) =>
3379 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_load32_u(ma))))
     |       }
     |     I32AtomicStore(ma) =>
3385 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i32_atomic_store(ma))))
     |       }
     |     I64AtomicStore(ma) =>
3391 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_store(ma))))
     |       }
     |     I32AtomicStore8(ma) =>
3397 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i32_atomic_store8(ma))))
     |       }
     |     I32AtomicStore16(ma) =>
3403 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i32_atomic_store16(ma))))
     |       }
     |     I64AtomicStore8(ma) =>
3409 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_store8(ma))))
     |       }
     |     I64AtomicStore16(ma) =>
3415 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_store16(ma))))
     |       }
     |     I64AtomicStore32(ma) =>
3421 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::i64_atomic_store32(ma))))
     |       }
     |     AtomicRmw(op, ma) =>
3427 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::atomic_rmw(op, ma))))
     |       }
     |     AtomicCmpxchg(op, ma) =>
3433 |       match self.walk_memarg(t, ma) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ma))) => Ok(Some((t, Instruction::atomic_cmpxchg(op, ma))))
     |       }
     |     MemorySize(m) =>
3439 |       match self.walk_memidx(t, m) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, m))) => Ok(Some((t, Instruction::memory_size(m))))
     |       }
     |     MemoryGrow(m) =>
3445 |       match self.walk_memidx(t, m) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, m))) => Ok(Some((t, Instruction::memory_grow(m))))
     |       }
     |     MemoryFill(m) =>
3451 |       match self.walk_memidx(t, m) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, m))) => Ok(Some((t, Instruction::memory_fill(m))))
     |       }
3456 |     MemoryCopy(m1, m2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, m1) = match self.walk_memidx(t, m1) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, m1)
     |         Ok(Some((t, m1))) => (t, m1)
     |       }
3462 |       let (t, m2) = match self.walk_memidx(t, m2) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, m2)
     |         Ok(Some((t, m2))) => (t, m2)
     |       }
3467 |       Ok(Some((t, Instruction::memory_copy(m1, m2))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3469 |     MemoryInit(d, m) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let (t, d) = match self.walk_dataidx(t, d) {
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, d)
     |         Ok(Some((t, d))) => (t, d)
     |       }
3475 |       let (t, m) = match self.walk_memidx(t, m) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => (t, m)
     |         Ok(Some((t, m))) => (t, m)
     |       }
3480 |       Ok(Some((t, Instruction::memory_init(d, m))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     DataDrop(d) =>
3483 |       match self.walk_dataidx(t, d) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, d))) => Ok(Some((t, Instruction::data_drop(d))))
     |       }
     | 
     |     // Exception instructions
     |     Throw(ty) =>
3491 |       match self.walk_tagidx(t, ty) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ty))) => Ok(Some((t, Instruction::throw_(ty))))
     |       }
     | 
     |     // Select with types
     |     Select(types) =>
3499 |       match types {
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => Ok(None)
     |         Some(types) =>
3502 |           match self.walk_array(t, ModuleTransformer::walk_valtype, types) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(e) => Err(e)
     |             Ok(None) => Ok(None)
     |             Ok(Some((t, types))) =>
3506 |               Ok(Some((t, Instruction::select(types=Some(types)))))
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |       }
     | 
     |     // All other instructions pass through unchanged
     |     _ => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_blocktype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   bt : BlockType,
     | ) -> TransformerResult[T, BlockType] {
     |   match self.on_blocktype {
     |     Some(f) =>
     |       match f(self, t, bt) {
3524 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_blocktype_default(t, bt)
3526 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_blocktype_default(t, bt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_blocktype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   bt : BlockType,
     | ) -> TransformerResult[T, BlockType] {
     |   match bt {
     |     ValTypeBlockType(vt) =>
     |       match self.walk_valtype(t, vt) {
3541 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
3543 |         Ok(Some((t, vt))) => Ok(Some((t, BlockType::val_type(vt))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TypeIdxBlockType(ty) =>
     |       match self.walk_typeidx(t, ty) {
3547 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
3549 |         Ok(Some((t, ty))) => Ok(Some((t, BlockType::type_idx(ty))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_catch(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   c : Catch,
     | ) -> TransformerResult[T, Catch] {
     |   match c {
     |     Catch(tag, label) => {
     |       let (t, tag) = match self.walk_tagidx(t, tag) {
3564 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, tag)
     |         Ok(Some((t, tag))) => (t, tag)
     |       }
     |       let (t, label) = match self.walk_labelidx(t, label) {
3569 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, label)
     |         Ok(Some((t, label))) => (t, label)
     |       }
     |       Ok(Some((t, Catch::new(tag, label))))
     |     }
     |     CatchRef(tag, label) => {
     |       let (t, tag) = match self.walk_tagidx(t, tag) {
3577 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, tag)
3579 |         Ok(Some((t, tag))) => (t, tag)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, label) = match self.walk_labelidx(t, label) {
3582 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, label)
3584 |         Ok(Some((t, label))) => (t, label)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, Catch::ref_(tag, label))))
     |     }
     |     CatchAll(label) =>
     |       match self.walk_labelidx(t, label) {
3590 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
3592 |         Ok(Some((t, label))) => Ok(Some((t, Catch::all(label))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     CatchAllRef(label) =>
3595 |       match self.walk_labelidx(t, label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, label))) => Ok(Some((t, Catch::all_ref(label))))
     |       }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_laneidx(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   idx : LaneIdx,
     | ) -> TransformerResult[T, LaneIdx] {
     |   match self.on_laneidx {
     |     Some(f) => f(self, t, idx)
3697 |     None => Ok(None)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_valtype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   vt : ValType,
     | ) -> TransformerResult[T, ValType] {
     |   match self.on_valtype {
     |     Some(f) =>
     |       match f(self, t, vt) {
3746 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_valtype_default(t, vt)
     |         ok => ok
     |       }
     |     None => self.walk_valtype_default(t, vt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_valtype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   vt : ValType,
     | ) -> TransformerResult[T, ValType] {
     |   match vt {
     |     RefTypeValType(rt) =>
     |       match self.walk_reftype(t, rt) {
3763 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, rt))) => Ok(Some((t, ValType::ref_type(rt))))
     |       }
     |     NumTypeValType(nt) =>
     |       match self.walk_numtype(t, nt) {
3769 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
3771 |         Ok(Some((t, nt))) => Ok(Some((t, ValType::num_type(nt))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
3773 |     _ => Ok(None)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_reftype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   rt : RefType,
     | ) -> TransformerResult[T, RefType] {
     |   match self.on_reftype {
     |     Some(f) =>
     |       match f(self, t, rt) {
3798 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_reftype_default(t, rt)
     |         ok => ok
     |       }
     |     None => self.walk_reftype_default(t, rt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_reftype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   rt : RefType,
     | ) -> TransformerResult[T, RefType] {
     |   match rt {
     |     HeapTypeRefType(nullable, ht) =>
     |       match self.walk_heaptype(t, ht) {
3815 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ht))) => Ok(Some((t, RefType::new(nullable, ht))))
     |       }
     |     _ => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_heaptype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ht : HeapType,
     | ) -> TransformerResult[T, HeapType] {
     |   match ht {
     |     HeapType(ty) =>
     |       match self.walk_typeidx(t, ty) {
3849 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
3851 |         Ok(Some((t, ty))) => Ok(Some((t, HeapType::new(ty))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     _ => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_customsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   sec : CustomSec,
     | ) -> TransformerResult[T, CustomSec] {
3865 |   let CustomSec(n, d) = sec
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match self.walk_name(t, n) {
     |     Err(e) => Err(e)
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, n))) => Ok(Some((t, CustomSec::new(n, d))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_module_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   mod : Module,
     | ) -> TransformerResult[T, Module] {
     |   let {
     |     custom_secs,
     |     type_sec,
     |     import_sec,
     |     func_sec,
     |     table_sec,
     |     mem_sec,
     |     tag_sec,
     |     global_sec,
     |     export_sec,
     |     start_sec,
     |     elem_sec,
     |     data_cnt_sec,
     |     code_sec,
     |     data_sec,
     |   } = mod
     |   let (t, custom_secs) = match self.walk_customsecs(t, custom_secs) {
3922 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, custom_secs)
3924 |     Ok(Some(v)) => v
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (t, type_sec) = match type_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_typesec(t, sec) {
3930 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, import_sec) = match import_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_importsec(t, sec) {
3939 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, func_sec) = match func_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_funcsec(t, sec) {
3948 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, table_sec) = match table_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_tablesec(t, sec) {
3957 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, mem_sec) = match mem_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_memsec(t, sec) {
3966 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, tag_sec) = match tag_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_tagsec(t, sec) {
3975 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, global_sec) = match global_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_globalsec(t, sec) {
3984 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, export_sec) = match export_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_exportsec(t, sec) {
3993 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, start_sec) = match start_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_startsec(t, sec) {
4002 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, elem_sec) = match elem_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_elemsec(t, sec) {
4011 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, data_cnt_sec) = match data_cnt_sec {
     |     None => (t, None)
     |     Some(data_cnt_sec) =>
     |       match self.walk_datacntsec(t, data_cnt_sec) {
4020 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(data_cnt_sec))
     |         Ok(Some((t, data_cnt_sec))) => (t, Some(data_cnt_sec))
     |       }
     |   }
     |   let (t, code_sec) = match code_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_codesec(t, sec) {
     |         Err(e) => return Err(e)
4030 |         Ok(None) => (t, Some(sec))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   let (t, data_sec) = match data_sec {
     |     None => (t, None)
     |     Some(sec) =>
     |       match self.walk_datasec(t, sec) {
4038 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(sec))
     |         Ok(Some((t, sec))) => (t, Some(sec))
     |       }
     |   }
     |   Ok(
     |     Some(
     |       (
     |         t,
     |         Module::new(
     |           custom_secs~,
     |           type_sec~,
     |           import_sec~,
     |           func_sec~,
     |           table_sec~,
     |           mem_sec~,
     |           tag_sec~,
     |           global_sec~,
     |           export_sec~,
     |           start_sec~,
     |           elem_sec~,
     |           data_cnt_sec~,
     |           code_sec~,
     |           data_sec~,
     |         ),
     |       ),
     |     ),
     |   )
     | }
     …

     | pub fn[T] ModuleTransformer::walk_datasec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ds : DataSec,
     | ) -> TransformerResult[T, DataSec] {
     |   match self.on_datasec {
     |     Some(f) =>
     |       match f(self, t, ds) {
4077 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_datasec_default(t, ds)
     |         ok => ok
     |       }
     |     None => self.walk_datasec_default(t, ds)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_datasec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ds : DataSec,
     | ) -> TransformerResult[T, DataSec] {
     |   let DataSec(ds) = ds
     |   match self.walk_array(t, ModuleTransformer::walk_data, ds) {
4093 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, ds))) => Ok(Some((t, DataSec::new(ds))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_codesec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   cs : CodeSec,
     | ) -> TransformerResult[T, CodeSec] {
     |   match self.on_codesec {
     |     Some(f) =>
     |       match f(self, t, cs) {
4108 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_codesec_default(t, cs)
     |         ok => ok
     |       }
     |     None => self.walk_codesec_default(t, cs)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_elemsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   es : ElemSec,
     | ) -> TransformerResult[T, ElemSec] {
     |   match self.on_elemsec {
     |     Some(f) =>
     |       match f(self, t, es) {
4151 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_elemsec_default(t, es)
     |         ok => ok
     |       }
     |     None => self.walk_elemsec_default(t, es)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_elemsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   es : ElemSec,
     | ) -> TransformerResult[T, ElemSec] {
     |   let ElemSec(es) = es
     |   match self.walk_array(t, ModuleTransformer::walk_elem, es) {
4167 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, es))) => Ok(Some((t, ElemSec::new(es))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_startsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ss : StartSec,
     | ) -> TransformerResult[T, StartSec] {
     |   match self.on_startsec {
     |     Some(f) =>
     |       match f(self, t, ss) {
4182 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_startsec_default(t, ss)
     |         ok => ok
     |       }
     |     None => self.walk_startsec_default(t, ss)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_startsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ss : StartSec,
     | ) -> TransformerResult[T, StartSec] {
     |   let StartSec(fidx) = ss
     |   match self.walk_funcidx(t, fidx) {
4198 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, fidx))) => Ok(Some((t, StartSec::new(fidx))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_exportsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   es : ExportSec,
     | ) -> TransformerResult[T, ExportSec] {
     |   match self.on_exportsec {
     |     Some(f) =>
     |       match f(self, t, es) {
4213 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_exportsec_default(t, es)
     |         ok => ok
     |       }
     |     None => self.walk_exportsec_default(t, es)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_importsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   es : ImportSec,
     | ) -> TransformerResult[T, ImportSec] {
     |   let ImportSec(ims) = es
     |   match self.walk_array(t, ModuleTransformer::walk_import, ims) {
4229 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, ims))) => Ok(Some((t, ImportSec::new(ims))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_exportsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   es : ExportSec,
     | ) -> TransformerResult[T, ExportSec] {
     |   let ExportSec(es) = es
     |   match self.walk_array(t, ModuleTransformer::walk_export, es) {
4243 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, es))) => Ok(Some((t, ExportSec::new(es))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tagsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ts : TagSec,
     | ) -> TransformerResult[T, TagSec] {
     |   match self.on_tagsec {
     |     Some(f) =>
     |       match f(self, t, ts) {
4258 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_tagsec_default(t, ts)
4260 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_tagsec_default(t, ts)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tagsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ts : TagSec,
     | ) -> TransformerResult[T, TagSec] {
     |   let TagSec(tags) = ts
     |   match self.walk_array(t, ModuleTransformer::walk_tagtype, tags) {
4274 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, tags))) => Ok(Some((t, TagSec::new(tags))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_memsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ms : MemSec,
     | ) -> TransformerResult[T, MemSec] {
     |   match self.on_memsec {
     |     Some(f) =>
     |       match f(self, t, ms) {
4289 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_memsec_default(t, ms)
     |         ok => ok
     |       }
     |     None => self.walk_memsec_default(t, ms)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_memsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ms : MemSec,
     | ) -> TransformerResult[T, MemSec] {
     |   let MemSec(m) = ms
     |   match self.walk_array(t, ModuleTransformer::walk_memtype, m) {
4305 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
4307 |     Ok(Some((t, m))) => Ok(Some((t, MemSec::new(m))))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tablesec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ts : TableSec,
     | ) -> TransformerResult[T, TableSec] {
     |   match self.on_tablesec {
     |     Some(f) =>
     |       match f(self, t, ts) {
4320 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_tablesec_default(t, ts)
     |         ok => ok
     |       }
     |     None => self.walk_tablesec_default(t, ts)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tablesec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ts : TableSec,
     | ) -> TransformerResult[T, TableSec] {
     |   let TableSec(tts) = ts
     |   match self.walk_array(t, ModuleTransformer::walk_table, tts) {
4336 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, tts))) => Ok(Some((t, TableSec::new(tts))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_func_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   f : Func,
     | ) -> TransformerResult[T, Func] {
     |   match f {
4366 |     Func(locals, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let mut locals = locals
4368 |       let t = match self.walk_locals(t, locals) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |         Ok(None) => t
     |         Ok(Some((t, ls))) => {
     |           locals = ls
     |           t
     |         }
     |       }
4376 |       match self.walk_expr(t, body) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, body))) => Ok(Some((t, Func::new(locals, body))))
     |       }
     |     }
     |     TFunc(locals, tbody) => {
     |       let (t, locals) = match
     |         self.walk_array(t, ModuleTransformer::walk_valtype, locals) {
     |         Ok(None) => (t, locals)
     |         Ok(Some((t, locals))) => (t, locals)
4387 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, tbody) = match self.walk_texpr(t, tbody) {
4390 |         Ok(None) => (t, tbody)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(Some(t)) => t
     |         Err(t) => return Err(t)
     |       }
     |       Ok(Some((t, Func::t_func(locals, tbody))))
     |     }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_locals(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   l : Array[Locals],
     | ) -> TransformerResult[T, Array[Locals]] {
     |   match self.on_locals {
     |     Some(f) => f(self, t, l)
4407 |     None => self.walk_locals_default(t, l)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_locals_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ls : Array[Locals],
     | ) -> TransformerResult[T, Array[Locals]] {
4417 |   self.walk_array(t, ModuleTransformer::walk_single_local, ls)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn[T] ModuleTransformer::walk_single_local(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   l : Locals,
     | ) -> TransformerResult[T, Locals] {
4426 |   let Locals(count, vt) = l
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match self.walk_valtype(t, vt) {
     |     Err(e) => Err(e)
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, vt))) => Ok(Some((t, Locals::new(count, vt))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_importsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ims : ImportSec,
     | ) -> TransformerResult[T, ImportSec] {
     |   match self.on_importsec {
     |     Some(f) =>
     |       match f(self, t, ims) {
4443 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_importsec_default(t, ims)
     |         ok => ok
     |       }
     |     None => self.walk_importsec_default(t, ims)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_export(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   expt : Export,
     | ) -> TransformerResult[T, Export] {
     |   match self.on_export {
     |     Some(f) =>
     |       match f(self, t, expt) {
4460 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_export_default(t, expt)
4462 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_export_default(t, expt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_export_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ex : Export,
     | ) -> TransformerResult[T, Export] {
     |   let Export(n, ei) = ex
     |   let (t, n) = match self.walk_name(t, n) {
4476 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, n)
4478 |     Ok(Some((t, n))) => (t, n)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (t, ei) = match self.walk_externidx(t, ei) {
4481 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, ei)
     |     Ok(Some((t, ei))) => (t, ei)
     |   }
     |   Ok(Some((t, Export::new(n, ei))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_externidx(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ex : ExternIdx,
     | ) -> TransformerResult[T, ExternIdx] {
     |   match self.on_externidx {
     |     Some(f) =>
     |       match f(self, t, ex) {
4497 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_externidx_default(t, ex)
4499 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_externidx_default(t, ex)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_externidx_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ex : ExternIdx,
     | ) -> TransformerResult[T, ExternIdx] {
     |   match ex {
     |     FuncExternIdx(fi) =>
     |       match self.walk_funcidx(t, fi) {
4514 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, fi))) => Ok(Some((t, ExternIdx::func(fi))))
     |       }
     |     TableExternIdx(ti) =>
4519 |       match self.walk_tableidx(t, ti) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ti))) => Ok(Some((t, ExternIdx::table(ti))))
     |       }
     |     MemExternIdx(mi) =>
4525 |       match self.walk_memidx(t, mi) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, mi))) => Ok(Some((t, ExternIdx::mem(mi))))
     |       }
     |     GlobalExternIdx(gi) =>
     |       match self.walk_globalidx(t, gi) {
4532 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, gi))) => Ok(Some((t, ExternIdx::global(gi))))
     |       }
     |     TagExternIdx(ti) =>
4537 |       match self.walk_tagidx(t, ti) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => Err(e)
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ti))) => Ok(Some((t, ExternIdx::tag(ti))))
     |       }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_table(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   tbl : Table,
     | ) -> TransformerResult[T, Table] {
     |   match self.on_table {
     |     Some(f) =>
     |       match f(self, t, tbl) {
4554 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_table_default(t, tbl)
     |         ok => ok
     |       }
     |     None => self.walk_table_default(t, tbl)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_table_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   tbl : Table,
     | ) -> TransformerResult[T, Table] {
     |   let Table(tt, e_option) = tbl
     |   let (t, tt) = match self.walk_tabletype(t, tt) {
4570 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, tt)
     |     Ok(Some((t, tt))) => (t, tt)
     |   }
     |   let (t, e_option) = match e_option {
     |     None => (t, None)
     |     Some(e) =>
     |       match self.walk_expr(t, e) {
4578 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, Some(e))
     |         Ok(Some((t, e))) => (t, Some(e))
     |       }
     |   }
     |   Ok(Some((t, Table::new(tt, e_option))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_import(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   im : Import,
     | ) -> TransformerResult[T, Import] {
     |   let Import(n1, n2, ty) = im
     |   let (t, n1) = match self.walk_name(t, n1) {
4594 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, n1)
4596 |     Ok(Some((t, n1))) => (t, n1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (t, n2) = match self.walk_name(t, n2) {
4599 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, n2)
4601 |     Ok(Some((t, n2))) => (t, n2)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (t, ty) = match self.walk_externtype(t, ty) {
4604 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, ty)
4606 |     Ok(Some((t, ty))) => (t, ty)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(Some((t, Import::new(n1, n2, ty))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tagtype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   tt : TagType,
     | ) -> TransformerResult[T, TagType] {
     |   match self.on_tagtype {
     |     Some(f) =>
     |       match f(self, t, tt) {
4632 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_tagtype_default(t, tt)
4634 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_tagtype_default(t, tt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tagtype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   tt : TagType,
     | ) -> TransformerResult[T, TagType] {
     |   let TagType(ti) = tt
     |   match self.walk_typeidx(t, ti) {
4648 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, ti))) => Ok(Some((t, TagType::new(ti))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_memtype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   mt : MemType,
     | ) -> TransformerResult[T, MemType] {
     |   match self.on_memtype {
     |     Some(f) =>
     |       match f(self, t, mt) {
4663 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_memtype_default(t, mt)
4665 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_memtype_default(t, mt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_memtype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   mt : MemType,
     | ) -> TransformerResult[T, MemType] {
     |   let MemType(l) = mt
     |   match self.walk_limits(t, l) {
4679 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
4681 |     Ok(Some((t, l))) => Ok(Some((t, MemType::new(l))))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_tabletype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   tt : TableType,
     | ) -> TransformerResult[T, TableType] {
     |   let TableType(rt, l) = tt
     |   let (t, rt) = match self.walk_reftype(t, rt) {
4693 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, rt)
     |     Ok(Some((t, rt))) => (t, rt)
     |   }
     |   let (t, l) = match self.walk_limits(t, l) {
4698 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, l)
4700 |     Ok(Some((t, l))) => (t, l)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(Some((t, TableType::new(rt, l))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_typesec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ts : TypeSec,
     | ) -> TransformerResult[T, TypeSec] {
     |   match self.on_typesec {
     |     Some(f) =>
     |       match f(self, t, ts) {
4726 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_typesec_default(t, ts)
     |         ok => ok
     |       }
     |     None => self.walk_typesec_default(t, ts)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_typesec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ts : TypeSec,
     | ) -> TransformerResult[T, TypeSec] {
     |   let TypeSec(rectypes) = ts
     |   match self.walk_array(t, ModuleTransformer::walk_rectype, rectypes) {
4742 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, rectypes))) => Ok(Some((t, TypeSec::new(rectypes))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_rectype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   rt : RecType,
     | ) -> TransformerResult[T, RecType] {
     |   match self.on_rectype {
     |     Some(f) =>
     |       match f(self, t, rt) {
4757 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_rectype_default(t, rt)
4759 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_rectype_default(t, rt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_rectype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   rt : RecType,
     | ) -> TransformerResult[T, RecType] {
     |   match rt {
     |     SingleRecType(st) =>
     |       match self.walk_subtype(t, st) {
4774 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, st))) => Ok(Some((t, RecType::new(st))))
     |       }
     |     GroupRecType(sts) =>
     |       match self.walk_array(t, ModuleTransformer::walk_subtype, sts) {
4780 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
4782 |         Ok(Some((t, sts))) => Ok(Some((t, RecType::group(sts))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_subtype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   st : SubType,
     | ) -> TransformerResult[T, SubType] {
     |   match self.on_subtype {
     |     Some(f) =>
     |       match f(self, t, st) {
4796 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_subtype_default(t, st)
4798 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_subtype_default(t, st)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_subtype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   st : SubType,
     | ) -> TransformerResult[T, SubType] {
     |   match st {
     |     SubType(f, supers, ct) => {
     |       let (t, supers) = match
     |         self.walk_array(t, ModuleTransformer::walk_typeidx, supers) {
4814 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, supers)
4816 |         Ok(Some((t, supers))) => (t, supers)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (t, ct) = match self.walk_comptype(t, ct) {
4819 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, ct)
     |         Ok(Some((t, ct))) => (t, ct)
     |       }
     |       Ok(Some((t, SubType::new(f, supers, ct))))
     |     }
     |     CompTypeSubType(ct) =>
     |       match self.walk_comptype(t, ct) {
4827 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ct))) => Ok(Some((t, SubType::comp_type(ct))))
     |       }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_comptype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ct : CompType,
     | ) -> TransformerResult[T, CompType] {
     |   match self.on_comptype {
     |     Some(f) =>
     |       match f(self, t, ct) {
4843 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_comptype_default(t, ct)
     |         ok => ok
     |       }
     |     None => self.walk_comptype_default(t, ct)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_comptype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ct : CompType,
     | ) -> TransformerResult[T, CompType] {
     |   match ct {
     |     FuncCompType(params, results) => {
     |       let (t, params) = match
     |         self.walk_array(t, ModuleTransformer::walk_valtype, params) {
4861 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, params)
     |         Ok(Some((t, params))) => (t, params)
     |       }
     |       let (t, results) = match
     |         self.walk_array(t, ModuleTransformer::walk_valtype, results) {
4867 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, results)
     |         Ok(Some((t, results))) => (t, results)
     |       }
     |       Ok(Some((t, CompType::func(params, results))))
     |     }
     |     StructCompType(fields) =>
     |       match self.walk_array(t, ModuleTransformer::walk_fieldtype, fields) {
4875 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, fields))) => Ok(Some((t, CompType::struct_(fields))))
     |       }
     |     ArrayCompType(ft) =>
     |       match self.walk_fieldtype(t, ft) {
4881 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, ft))) => Ok(Some((t, CompType::array(ft))))
     |       }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_fieldtype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ft : FieldType,
     | ) -> TransformerResult[T, FieldType] {
     |   match self.on_fieldtype {
     |     Some(f) =>
     |       match f(self, t, ft) {
4897 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_fieldtype_default(t, ft)
4899 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_fieldtype_default(t, ft)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_fieldtype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ft : FieldType,
     | ) -> TransformerResult[T, FieldType] {
     |   let FieldType(st, mut_) = ft
     |   match self.walk_storagetype(t, st) {
4913 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, st))) => Ok(Some((t, FieldType::new(st, mut_))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_storagetype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   st : StorageType,
     | ) -> TransformerResult[T, StorageType] {
     |   match self.on_storagetype {
     |     Some(f) =>
     |       match f(self, t, st) {
4928 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_storagetype_default(t, st)
4930 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_storagetype_default(t, st)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_storagetype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   st : StorageType,
     | ) -> TransformerResult[T, StorageType] {
     |   match st {
     |     ValTypeStorageType(vt) =>
     |       match self.walk_valtype(t, vt) {
4945 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, vt))) => Ok(Some((t, StorageType::val_type(vt))))
     |       }
     |     PackTypeStorageType(_) => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_globalsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   gs : GlobalSec,
     | ) -> TransformerResult[T, GlobalSec] {
     |   match self.on_globalsec {
     |     Some(f) =>
     |       match f(self, t, gs) {
4962 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_globalsec_default(t, gs)
     |         ok => ok
     |       }
     |     None => self.walk_globalsec_default(t, gs)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_globalsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   gs : GlobalSec,
     | ) -> TransformerResult[T, GlobalSec] {
     |   let GlobalSec(gs) = gs
     |   match self.walk_array(t, ModuleTransformer::walk_global, gs) {
4978 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, gs))) => Ok(Some((t, GlobalSec::new(gs))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_global(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   g : Global,
     | ) -> TransformerResult[T, Global] {
     |   match self.on_global {
     |     Some(f) =>
     |       match f(self, t, g) {
4993 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_global_default(t, g)
     |         ok => ok
     |       }
     |     None => self.walk_global_default(t, g)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_global_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   g : Global,
     | ) -> TransformerResult[T, Global] {
     |   let Global(gt, init) = g
     |   let (t, gt) = match self.walk_globaltype(t, gt) {
5009 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, gt)
     |     Ok(Some((t, gt))) => (t, gt)
     |   }
     |   let (t, init) = match self.walk_expr(t, init) {
5014 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, init)
     |     Ok(Some((t, init))) => (t, init)
     |   }
     |   Ok(Some((t, Global::new(gt, init))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_globaltype(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   gt : GlobalType,
     | ) -> TransformerResult[T, GlobalType] {
     |   match self.on_globaltype {
     |     Some(f) =>
     |       match f(self, t, gt) {
5030 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_globaltype_default(t, gt)
5032 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_globaltype_default(t, gt)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_globaltype_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   gt : GlobalType,
     | ) -> TransformerResult[T, GlobalType] {
     |   let GlobalType(vt, mutable) = gt
     |   match self.walk_valtype(t, vt) {
5046 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, vt))) => Ok(Some((t, GlobalType::new(vt, mutable))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_elem(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   e : Elem,
     | ) -> TransformerResult[T, Elem] {
     |   let Elem(mode, kind) = e
     |   let (t, mode) = match self.walk_elemmode(t, mode) {
5060 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, mode)
     |     Ok(Some((t, mode))) => (t, mode)
     |   }
     |   let (t, kind) = match self.walk_elemkind(t, kind) {
5065 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, kind)
     |     Ok(Some((t, kind))) => (t, kind)
     |   }
     |   Ok(Some((t, Elem::new(mode, kind))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_elemmode(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   mode : ElemMode,
     | ) -> TransformerResult[T, ElemMode] {
     |   match mode {
     |     Active(tidx, offset) => {
     |       let (t, tidx) = match self.walk_tableidx(t, tidx) {
5081 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, tidx)
     |         Ok(Some((t, tidx))) => (t, tidx)
     |       }
     |       let (t, offset) = match self.walk_expr(t, offset) {
5086 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, offset)
5088 |         Ok(Some((t, offset))) => (t, offset)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, ElemMode::active(tidx, offset))))
     |     }
     |     _ => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_elemkind(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   ek : ElemKind,
     | ) -> TransformerResult[T, ElemKind] {
     |   match self.on_elemkind {
     |     Some(f) =>
     |       match f(self, t, ek) {
5105 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_elemkind_default(t, ek)
5107 |         ok => ok
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     None => self.walk_elemkind_default(t, ek)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_elemkind_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   kind : ElemKind,
     | ) -> TransformerResult[T, ElemKind] {
     |   match kind {
     |     FuncsElemKind(idxs) =>
     |       match self.walk_array(t, ModuleTransformer::walk_funcidx, idxs) {
5122 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
     |         Ok(Some((t, idxs))) => Ok(Some((t, ElemKind::funcs(idxs))))
     |       }
     |     FuncExprsElemKind(exprs) =>
     |       match self.walk_array(t, ModuleTransformer::walk_expr, exprs) {
5128 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => Ok(None)
5130 |         Ok(Some((t, exprs))) => Ok(Some((t, ElemKind::func_exprs(exprs))))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     TypedExprsElemKind(rt, exprs) => {
     |       let (t, rt) = match self.walk_reftype(t, rt) {
5134 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, rt)
     |         Ok(Some((t, rt))) => (t, rt)
     |       }
     |       let (t, exprs) = match
     |         self.walk_array(t, ModuleTransformer::walk_expr, exprs) {
5140 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, exprs)
     |         Ok(Some((t, exprs))) => (t, exprs)
     |       }
     |       Ok(Some((t, ElemKind::typed_exprs(rt, exprs))))
     |     }
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_data(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   d : Data,
     | ) -> TransformerResult[T, Data] {
     |   let Data(mode, bytes) = d
     |   let (t, mode) = match self.walk_datamode(t, mode) {
5157 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => (t, mode)
     |     Ok(Some((t, mode))) => (t, mode)
     |   }
     |   Ok(Some((t, Data::new(mode, bytes))))
     | }
     …

     | pub fn[T] ModuleTransformer::walk_datamode(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   mode : DataMode,
     | ) -> TransformerResult[T, DataMode] {
     |   match mode {
     |     Active(midx, offset) => {
     |       let (t, midx) = match self.walk_memidx(t, midx) {
5173 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, midx)
     |         Ok(Some((t, midx))) => (t, midx)
     |       }
     |       let (t, offset) = match self.walk_expr(t, offset) {
5178 |         Err(e) => return Err(e)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => (t, offset)
5180 |         Ok(Some((t, offset))) => (t, offset)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(Some((t, DataMode::active(midx, offset))))
     |     }
     |     Passive => Ok(None)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_funcsec(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   fs : FuncSec,
     | ) -> TransformerResult[T, FuncSec] {
     |   match self.on_funcsec {
     |     Some(f) =>
     |       match f(self, t, fs) {
5197 |         Err(e) => Err(e)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(None) => self.walk_funcsec_default(t, fs)
     |         ok => ok
     |       }
     |     None => self.walk_funcsec_default(t, fs)
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_funcsec_default(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   fs : FuncSec,
     | ) -> TransformerResult[T, FuncSec] {
     |   let FuncSec(idxs) = fs
     |   match self.walk_array(t, ModuleTransformer::walk_typeidx, idxs) {
5213 |     Err(e) => Err(e)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(None) => Ok(None)
     |     Ok(Some((t, idxs))) => Ok(Some((t, FuncSec::new(idxs))))
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_extractlaneop(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   op : ExtractLaneOp,
     | ) -> TransformerResult[T, ExtractLaneOp] {
     |   match self.on_extractlaneop {
     |     Some(f) => f(self, t, op)
5287 |     None => Ok(None)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_replacelaneop(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   op : ReplaceLaneOp,
     | ) -> TransformerResult[T, ReplaceLaneOp] {
     |   match self.on_replacelaneop {
     |     Some(f) => f(self, t, op)
5299 |     None => Ok(None)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_v128shiftop(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   op : V128ShiftOp,
     | ) -> TransformerResult[T, V128ShiftOp] {
     |   match self.on_v128shiftop {
     |     Some(f) => f(self, t, op)
5311 |     None => Ok(None)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn[T] ModuleTransformer::walk_v128ternaryop(
     |   self : ModuleTransformer[T],
     |   t : T,
     |   op : V128TernaryOp,
     | ) -> TransformerResult[T, V128TernaryOp] {
     |   match self.on_v128ternaryop {
     |     Some(f) => f(self, t, op)
5323 |     None => Ok(None)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

1328 uncovered line(s) in src/validate/env.mbt:

     | pub fn Env::resolve_subtype(env : Env, idx : TypeIdx) -> SubType? {
     |   match idx {
     |     TypeIdx(i) => env.global_types.get(i.reinterpret_as_int())
     |     RecIdx(j) => {
     |       let n = env.rec_stack.length()
     |       if n == 0 {
     |         return None
     |       }
     |       match env.rec_stack.get(n - 1) {
  30 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(group) => group.get(j.reinterpret_as_int())
     |       }
     |     }
     |   }
     | }
     …

     | pub fn Env::resolve_typeidx_subtype(env : Env, tidx : TypeIdx) -> SubType? {
     |   match tidx {
     |     TypeIdx(i) => env.global_types.get(i.reinterpret_as_int())
     |     RecIdx(j) => {
     |       let n = env.rec_stack.length()
     |       if n == 0 {
     |         return None
     |       }
     |       match env.rec_stack.get(n - 1) {
  92 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(group) => group.get(j.reinterpret_as_int())
     |       }
     |     }
     |   }
     | }
     …

     | fn instr_to_tinstr(
     |   instr : Instruction,
     |   stack : Array[TInstr],
     |   env : Env,
     | ) -> Result[Unit, String] {
     |   match instr {
     |     // === Constants ===
     |     I32Const(v) => stack.push(TInstr::i32_const(v))
     |     I64Const(v) => stack.push(TInstr::i64_const(v))
     |     F32Const(v) => stack.push(TInstr::f32_const(v))
     |     F64Const(v) => stack.push(TInstr::f64_const(v))
     |     RefNull(ht) => stack.push(TInstr::ref_null(ht))
     |     RefFunc(idx) => stack.push(TInstr::ref_func(idx))
     |     V128Const(
     |       b0,
     |       b1,
     |       b2,
     |       b3,
     |       b4,
     |       b5,
     |       b6,
     |       b7,
     |       b8,
     |       b9,
     |       b10,
     |       b11,
     |       b12,
     |       b13,
     |       b14,
     |       b15
     |     ) =>
     |       stack.push(
     |         TInstr::v128_const(
     |           b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,
     |         ),
     |       )
     | 
     |     // === Nullary ===
     |     Unreachable => stack.push(TInstr::unreachable_())
     |     Nop => stack.push(TInstr::nop())
     |     LocalGet(idx) => stack.push(TInstr::local_get(idx))
     |     GlobalGet(idx) => stack.push(TInstr::global_get(idx))
     |     MemorySize(idx) => stack.push(TInstr::memory_size(idx))
     |     TableSize(idx) => stack.push(TInstr::table_size(idx))
     | 
     |     // === Unary numeric ===
     |     I32Eqz => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i32_eqz(), op))
     |     }
     |     I64Eqz => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 614 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i64_eqz(), op))
     |     }
     |     I32Clz => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 621 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i32_clz(), op))
     |     }
     |     I32Ctz => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 628 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i32_ctz(), op))
     |     }
     |     I32Popcnt => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 635 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i32_popcnt(), op))
     |     }
     |     I64Clz => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 642 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i64_clz(), op))
     |     }
     |     I64Ctz => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 649 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i64_ctz(), op))
     |     }
     |     I64Popcnt => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 656 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::i64_popcnt(), op))
     |     }
     |     F32Abs => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 663 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_abs(), op))
     |     }
     |     F32Neg => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 670 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_neg(), op))
     |     }
     |     F32Ceil => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 677 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_ceil(), op))
     |     }
     |     F32Floor => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 684 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_floor(), op))
     |     }
     |     F32Trunc => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 691 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_trunc(), op))
     |     }
     |     F32Nearest => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 698 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_nearest(), op))
     |     }
     |     F32Sqrt => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 705 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f32_sqrt(), op))
     |     }
     |     F64Abs => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 712 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f64_abs(), op))
     |     }
     |     F64Neg => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 719 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f64_neg(), op))
     |     }
     |     F64Ceil => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 726 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f64_ceil(), op))
     |     }
     |     F64Floor => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
 733 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::unary(UnaryOp::f64_floor(), op))
     |     }
 737 |     F64Trunc => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 742 |       stack.push(TInstr::unary(UnaryOp::f64_trunc(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 744 |     F64Nearest => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 749 |       stack.push(TInstr::unary(UnaryOp::f64_nearest(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 751 |     F64Sqrt => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 756 |       stack.push(TInstr::unary(UnaryOp::f64_sqrt(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Conversions ===
 760 |     I32WrapI64 => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 765 |       stack.push(TInstr::unary(UnaryOp::i32_wrap_i64(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 767 |     I32TruncF32S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 772 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_f32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 774 |     I32TruncF32U => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 779 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_f32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 781 |     I32TruncF64S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 786 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_f64s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 788 |     I32TruncF64U => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 793 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_f64u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 795 |     I64ExtendI32S => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 800 |       stack.push(TInstr::unary(UnaryOp::i64_extend_i32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 802 |     I64ExtendI32U => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 807 |       stack.push(TInstr::unary(UnaryOp::i64_extend_i32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 809 |     I64TruncF32S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 814 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_f32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 816 |     I64TruncF32U => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 821 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_f32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 823 |     I64TruncF64S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 828 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_f64s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 830 |     I64TruncF64U => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 835 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_f64u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 837 |     F32ConvertI32S => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 842 |       stack.push(TInstr::unary(UnaryOp::f32_convert_i32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 844 |     F32ConvertI32U => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 849 |       stack.push(TInstr::unary(UnaryOp::f32_convert_i32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 851 |     F32ConvertI64S => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 856 |       stack.push(TInstr::unary(UnaryOp::f32_convert_i64s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 858 |     F32ConvertI64U => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 863 |       stack.push(TInstr::unary(UnaryOp::f32_convert_i64u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 865 |     F32DemoteF64 => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 870 |       stack.push(TInstr::unary(UnaryOp::f32_demote_f64(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 872 |     F64ConvertI32S => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 877 |       stack.push(TInstr::unary(UnaryOp::f64_convert_i32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 879 |     F64ConvertI32U => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 884 |       stack.push(TInstr::unary(UnaryOp::f64_convert_i32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 886 |     F64ConvertI64S => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 891 |       stack.push(TInstr::unary(UnaryOp::f64_convert_i64s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 893 |     F64ConvertI64U => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 898 |       stack.push(TInstr::unary(UnaryOp::f64_convert_i64u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 900 |     F64PromoteF32 => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 905 |       stack.push(TInstr::unary(UnaryOp::f64_promote_f32(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 907 |     I32ReinterpretF32 => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 912 |       stack.push(TInstr::unary(UnaryOp::i32_reinterpret_f32(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 914 |     I64ReinterpretF64 => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 919 |       stack.push(TInstr::unary(UnaryOp::i64_reinterpret_f64(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 921 |     F32ReinterpretI32 => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 926 |       stack.push(TInstr::unary(UnaryOp::f32_reinterpret_i32(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 928 |     F64ReinterpretI64 => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 933 |       stack.push(TInstr::unary(UnaryOp::f64_reinterpret_i64(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 935 |     I32Extend8S => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 940 |       stack.push(TInstr::unary(UnaryOp::i32_extend8s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 942 |     I32Extend16S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 947 |       stack.push(TInstr::unary(UnaryOp::i32_extend16s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 949 |     I64Extend8S => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 954 |       stack.push(TInstr::unary(UnaryOp::i64_extend8s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 956 |     I64Extend16S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 961 |       stack.push(TInstr::unary(UnaryOp::i64_extend16s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 963 |     I64Extend32S => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 968 |       stack.push(TInstr::unary(UnaryOp::i64_extend32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 970 |     I32TruncSatF32S => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 975 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_sat_f32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 977 |     I32TruncSatF32U => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 982 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_sat_f32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 984 |     I32TruncSatF64S => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 989 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_sat_f64s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 991 |     I32TruncSatF64U => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
 996 |       stack.push(TInstr::unary(UnaryOp::i32_trunc_sat_f64u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 998 |     I64TruncSatF32S => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1003 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_sat_f32s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1005 |     I64TruncSatF32U => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1010 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_sat_f32u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1012 |     I64TruncSatF64S => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1017 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_sat_f64s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1019 |     I64TruncSatF64U => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1024 |       stack.push(TInstr::unary(UnaryOp::i64_trunc_sat_f64u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Binary numeric ===
1028 |     I32Eq => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1033 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1037 |       stack.push(TInstr::binary(BinaryOp::i32_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1039 |     I32Ne => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1044 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1048 |       stack.push(TInstr::binary(BinaryOp::i32_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1050 |     I32LtS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1055 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1059 |       stack.push(TInstr::binary(BinaryOp::i32_lt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1061 |     I32LtU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1066 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1070 |       stack.push(TInstr::binary(BinaryOp::i32_lt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1072 |     I32GtS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1077 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1081 |       stack.push(TInstr::binary(BinaryOp::i32_gt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1083 |     I32GtU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1088 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1092 |       stack.push(TInstr::binary(BinaryOp::i32_gt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1094 |     I32LeS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1099 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1103 |       stack.push(TInstr::binary(BinaryOp::i32_le_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1105 |     I32LeU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1110 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1114 |       stack.push(TInstr::binary(BinaryOp::i32_le_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1116 |     I32GeS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1121 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1125 |       stack.push(TInstr::binary(BinaryOp::i32_ge_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1127 |     I32GeU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1132 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1136 |       stack.push(TInstr::binary(BinaryOp::i32_ge_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1138 |     I64Eq => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1143 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1147 |       stack.push(TInstr::binary(BinaryOp::i64_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1149 |     I64Ne => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1154 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1158 |       stack.push(TInstr::binary(BinaryOp::i64_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1160 |     I64LtS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1165 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1169 |       stack.push(TInstr::binary(BinaryOp::i64_lt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1171 |     I64LtU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1176 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1180 |       stack.push(TInstr::binary(BinaryOp::i64_lt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1182 |     I64GtS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1187 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1191 |       stack.push(TInstr::binary(BinaryOp::i64_gt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1193 |     I64GtU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1198 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1202 |       stack.push(TInstr::binary(BinaryOp::i64_gt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1204 |     I64LeS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1209 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1213 |       stack.push(TInstr::binary(BinaryOp::i64_le_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1215 |     I64LeU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1220 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1224 |       stack.push(TInstr::binary(BinaryOp::i64_le_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1226 |     I64GeS => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1231 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1235 |       stack.push(TInstr::binary(BinaryOp::i64_ge_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1237 |     I64GeU => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1242 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1246 |       stack.push(TInstr::binary(BinaryOp::i64_ge_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1248 |     F32Eq => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1253 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1257 |       stack.push(TInstr::binary(BinaryOp::f32_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1259 |     F32Ne => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1264 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1268 |       stack.push(TInstr::binary(BinaryOp::f32_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1270 |     F32Lt => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1275 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1279 |       stack.push(TInstr::binary(BinaryOp::f32_lt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1281 |     F32Gt => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1286 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1290 |       stack.push(TInstr::binary(BinaryOp::f32_gt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1292 |     F32Le => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1297 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1301 |       stack.push(TInstr::binary(BinaryOp::f32_le(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1303 |     F32Ge => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1308 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1312 |       stack.push(TInstr::binary(BinaryOp::f32_ge(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1314 |     F64Eq => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1319 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1323 |       stack.push(TInstr::binary(BinaryOp::f64_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1325 |     F64Ne => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1330 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1334 |       stack.push(TInstr::binary(BinaryOp::f64_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1336 |     F64Lt => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1341 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1345 |       stack.push(TInstr::binary(BinaryOp::f64_lt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1347 |     F64Gt => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1352 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1356 |       stack.push(TInstr::binary(BinaryOp::f64_gt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1358 |     F64Le => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1363 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1367 |       stack.push(TInstr::binary(BinaryOp::f64_le(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1369 |     F64Ge => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1374 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1378 |       stack.push(TInstr::binary(BinaryOp::f64_ge(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1380 |     I32Add => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1385 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1389 |       stack.push(TInstr::binary(BinaryOp::i32_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1391 |     I32Sub => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1396 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1400 |       stack.push(TInstr::binary(BinaryOp::i32_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1402 |     I32Mul => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1407 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1411 |       stack.push(TInstr::binary(BinaryOp::i32_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1413 |     I32DivS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1418 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1422 |       stack.push(TInstr::binary(BinaryOp::i32_div_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1424 |     I32DivU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1429 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1433 |       stack.push(TInstr::binary(BinaryOp::i32_div_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1435 |     I32RemS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1440 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1444 |       stack.push(TInstr::binary(BinaryOp::i32_rem_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1446 |     I32RemU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1451 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1455 |       stack.push(TInstr::binary(BinaryOp::i32_rem_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1457 |     I32And => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1462 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1466 |       stack.push(TInstr::binary(BinaryOp::i32_and(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1468 |     I32Or => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1473 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1477 |       stack.push(TInstr::binary(BinaryOp::i32_or(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1479 |     I32Xor => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1484 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1488 |       stack.push(TInstr::binary(BinaryOp::i32_xor(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1490 |     I32Shl => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1495 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1499 |       stack.push(TInstr::binary(BinaryOp::i32_shl(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1501 |     I32ShrS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1506 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1510 |       stack.push(TInstr::binary(BinaryOp::i32_shr_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1512 |     I32ShrU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1517 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1521 |       stack.push(TInstr::binary(BinaryOp::i32_shr_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1523 |     I32Rotl => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1528 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1532 |       stack.push(TInstr::binary(BinaryOp::i32_rotl(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1534 |     I32Rotr => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1539 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1543 |       stack.push(TInstr::binary(BinaryOp::i32_rotr(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     I64Add => {
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
1548 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let lhs = match pop(stack) {
     |         Ok(t) => t
1552 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::binary(BinaryOp::i64_add(), lhs, rhs))
     |     }
1556 |     I64Sub => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1561 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1565 |       stack.push(TInstr::binary(BinaryOp::i64_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1567 |     I64Mul => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1572 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1576 |       stack.push(TInstr::binary(BinaryOp::i64_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1578 |     I64DivS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1583 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1587 |       stack.push(TInstr::binary(BinaryOp::i64_div_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1589 |     I64DivU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1594 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1598 |       stack.push(TInstr::binary(BinaryOp::i64_div_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1600 |     I64RemS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1605 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1609 |       stack.push(TInstr::binary(BinaryOp::i64_rem_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1611 |     I64RemU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1616 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1620 |       stack.push(TInstr::binary(BinaryOp::i64_rem_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1622 |     I64And => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1627 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1631 |       stack.push(TInstr::binary(BinaryOp::i64_and(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1633 |     I64Or => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1638 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1642 |       stack.push(TInstr::binary(BinaryOp::i64_or(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1644 |     I64Xor => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1649 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1653 |       stack.push(TInstr::binary(BinaryOp::i64_xor(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1655 |     I64Shl => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1660 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1664 |       stack.push(TInstr::binary(BinaryOp::i64_shl(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1666 |     I64ShrS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1671 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1675 |       stack.push(TInstr::binary(BinaryOp::i64_shr_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1677 |     I64ShrU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1682 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1686 |       stack.push(TInstr::binary(BinaryOp::i64_shr_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1688 |     I64Rotl => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1693 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1697 |       stack.push(TInstr::binary(BinaryOp::i64_rotl(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1699 |     I64Rotr => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1704 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1708 |       stack.push(TInstr::binary(BinaryOp::i64_rotr(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1710 |     F32Add => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1715 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1719 |       stack.push(TInstr::binary(BinaryOp::f32_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1721 |     F32Sub => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1726 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1730 |       stack.push(TInstr::binary(BinaryOp::f32_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1732 |     F32Mul => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1737 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1741 |       stack.push(TInstr::binary(BinaryOp::f32_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1743 |     F32Div => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1748 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1752 |       stack.push(TInstr::binary(BinaryOp::f32_div(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1754 |     F32Min => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1759 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1763 |       stack.push(TInstr::binary(BinaryOp::f32_min(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1765 |     F32Max => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1770 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1774 |       stack.push(TInstr::binary(BinaryOp::f32_max(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1776 |     F32Copysign => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1781 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1785 |       stack.push(TInstr::binary(BinaryOp::f32_copysign(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1787 |     F64Add => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1792 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1796 |       stack.push(TInstr::binary(BinaryOp::f64_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1798 |     F64Sub => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1803 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1807 |       stack.push(TInstr::binary(BinaryOp::f64_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1809 |     F64Mul => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1814 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1818 |       stack.push(TInstr::binary(BinaryOp::f64_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1820 |     F64Div => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1825 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1829 |       stack.push(TInstr::binary(BinaryOp::f64_div(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1831 |     F64Min => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1836 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1840 |       stack.push(TInstr::binary(BinaryOp::f64_min(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1842 |     F64Max => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1847 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1851 |       stack.push(TInstr::binary(BinaryOp::f64_max(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1853 |     F64Copysign => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1858 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1862 |       stack.push(TInstr::binary(BinaryOp::f64_copysign(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Other unary ===
     |     Drop => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
1869 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::drop(op))
     |     }
     |     LocalSet(idx) => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
1876 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::local_set(idx, op))
     |     }
1880 |     LocalTee(idx) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1885 |       stack.push(TInstr::local_tee(idx, op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1887 |     GlobalSet(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1892 |       stack.push(TInstr::global_set(idx, op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1894 |     RefIsNull => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1899 |       stack.push(TInstr::ref_is_null(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     RefAsNonNull => {
     |       let op = match pop(stack) {
     |         Ok(t) => t
1904 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::ref_as_non_null(op))
     |     }
1908 |     RefEq => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1913 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1917 |       stack.push(TInstr::ref_eq(lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1919 |     RefI31 => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1924 |       stack.push(TInstr::ref_i31(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1926 |     I31GetS => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1931 |       stack.push(TInstr::i31_get_s(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1933 |     I31GetU => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1938 |       stack.push(TInstr::i31_get_u(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1940 |     ArrayLen => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1945 |       stack.push(TInstr::array_len(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1947 |     AnyConvertExtern => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1952 |       stack.push(TInstr::any_convert_extern(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1954 |     ExternConvertAny => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1959 |       stack.push(TInstr::extern_convert_any(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1961 |     ThrowRef => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1966 |       stack.push(TInstr::throw_ref(op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Loads ===
1970 |     I32Load(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1975 |       stack.push(TInstr::load(LoadOp::i32_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1977 |     I64Load(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1982 |       stack.push(TInstr::load(LoadOp::i64_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1984 |     F32Load(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1989 |       stack.push(TInstr::load(LoadOp::f32_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1991 |     F64Load(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
1996 |       stack.push(TInstr::load(LoadOp::f64_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
1998 |     I32Load8S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2003 |       stack.push(TInstr::load(LoadOp::i32_load8s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2005 |     I32Load8U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2010 |       stack.push(TInstr::load(LoadOp::i32_load8u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2012 |     I32Load16S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2017 |       stack.push(TInstr::load(LoadOp::i32_load16s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2019 |     I32Load16U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2024 |       stack.push(TInstr::load(LoadOp::i32_load16u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2026 |     I64Load8S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2031 |       stack.push(TInstr::load(LoadOp::i64_load8s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2033 |     I64Load8U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2038 |       stack.push(TInstr::load(LoadOp::i64_load8u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2040 |     I64Load16S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2045 |       stack.push(TInstr::load(LoadOp::i64_load16s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2047 |     I64Load16U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2052 |       stack.push(TInstr::load(LoadOp::i64_load16u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2054 |     I64Load32S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2059 |       stack.push(TInstr::load(LoadOp::i64_load32s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2061 |     I64Load32U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2066 |       stack.push(TInstr::load(LoadOp::i64_load32u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2068 |     I32AtomicLoad(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2073 |       stack.push(TInstr::load(LoadOp::i32_atomic_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2075 |     I64AtomicLoad(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2080 |       stack.push(TInstr::load(LoadOp::i64_atomic_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2082 |     I32AtomicLoad8U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2087 |       stack.push(TInstr::load(LoadOp::i32_atomic_load8_u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2089 |     I32AtomicLoad16U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2094 |       stack.push(TInstr::load(LoadOp::i32_atomic_load16_u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2096 |     I64AtomicLoad8U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2101 |       stack.push(TInstr::load(LoadOp::i64_atomic_load8_u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2103 |     I64AtomicLoad16U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2108 |       stack.push(TInstr::load(LoadOp::i64_atomic_load16_u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2110 |     I64AtomicLoad32U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2115 |       stack.push(TInstr::load(LoadOp::i64_atomic_load32_u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Stores ===
2119 |     I32Store(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2124 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2128 |       stack.push(TInstr::store(StoreOp::i32_store(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2130 |     I64Store(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2135 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2139 |       stack.push(TInstr::store(StoreOp::i64_store(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2141 |     F32Store(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2146 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2150 |       stack.push(TInstr::store(StoreOp::f32_store(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2152 |     F64Store(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2157 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2161 |       stack.push(TInstr::store(StoreOp::f64_store(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2163 |     I32Store8(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2168 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2172 |       stack.push(TInstr::store(StoreOp::i32_store8(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2174 |     I32Store16(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2179 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2183 |       stack.push(TInstr::store(StoreOp::i32_store16(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2185 |     I64Store8(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2190 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2194 |       stack.push(TInstr::store(StoreOp::i64_store8(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2196 |     I64Store16(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2201 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2205 |       stack.push(TInstr::store(StoreOp::i64_store16(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2207 |     I64Store32(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2212 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2216 |       stack.push(TInstr::store(StoreOp::i64_store32(), memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2218 |     I32AtomicStore(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2223 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2227 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i32_atomic_store(), memarg, addr, value),
     |       )
     |     }
2231 |     I64AtomicStore(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2236 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2240 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i64_atomic_store(), memarg, addr, value),
     |       )
     |     }
2244 |     I32AtomicStore8(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2249 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2253 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i32_atomic_store8(), memarg, addr, value),
     |       )
     |     }
2257 |     I32AtomicStore16(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2262 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2266 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i32_atomic_store16(), memarg, addr, value),
     |       )
     |     }
2270 |     I64AtomicStore8(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2275 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2279 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i64_atomic_store8(), memarg, addr, value),
     |       )
     |     }
2283 |     I64AtomicStore16(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2288 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2292 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i64_atomic_store16(), memarg, addr, value),
     |       )
     |     }
2296 |     I64AtomicStore32(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2301 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2305 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::store(StoreOp::i64_atomic_store32(), memarg, addr, value),
     |       )
     |     }
     | 
     |     // === Memory operations ===
2311 |     MemoryGrow(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let pages = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2316 |       stack.push(TInstr::memory_grow(idx, pages))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2318 |     MemoryFill(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2323 |       let val = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2327 |       let dest = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2331 |       stack.push(TInstr::memory_fill(idx, dest, val, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2333 |     MemoryCopy(dst, src) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2338 |       let src_addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2342 |       let dst_addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2346 |       stack.push(TInstr::memory_copy(dst, src, dst_addr, src_addr, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2348 |     MemoryInit(data_idx, mem_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2353 |       let src = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2357 |       let dst = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2361 |       stack.push(TInstr::memory_init(data_idx, mem_idx, dst, src, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2363 |     DataDrop(idx) => stack.push(TInstr::data_drop(idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     MemoryAtomicNotify(memarg) => {
     |       let count = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2369 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2373 |       stack.push(TInstr::memory_atomic_notify(memarg, addr, count))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2375 |     MemoryAtomicWait32(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let timeout = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2380 |       let expected = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2384 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2388 |       stack.push(TInstr::memory_atomic_wait32(memarg, addr, expected, timeout))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2390 |     MemoryAtomicWait64(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let timeout = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2395 |       let expected = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2399 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2403 |       stack.push(TInstr::memory_atomic_wait64(memarg, addr, expected, timeout))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2405 |     AtomicFence => stack.push(TInstr::atomic_fence())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AtomicRmw(op, memarg) => {
     |       let value = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2411 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2415 |       stack.push(TInstr::atomic_rmw(op, memarg, addr, value))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2417 |     AtomicCmpxchg(op, memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let replacement = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2422 |       let expected = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2426 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2430 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::atomic_cmpxchg(op, memarg, addr, expected, replacement),
     |       )
     |     }
     | 
     |     // === Table operations ===
2436 |     TableGet(idx) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let i = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2441 |       stack.push(TInstr::table_get(idx, i))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2443 |     TableSet(idx) => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2448 |       let i = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2452 |       stack.push(TInstr::table_set(idx, i, val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2454 |     TableGrow(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2459 |       let val = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2463 |       stack.push(TInstr::table_grow(idx, val, n))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2465 |     TableFill(idx) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2470 |       let val = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2474 |       let i = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2478 |       stack.push(TInstr::table_fill(idx, i, val, n))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2480 |     TableCopy(dst, src) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2485 |       let s = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2489 |       let d = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2493 |       stack.push(TInstr::table_copy(dst, src, d, s, n))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2495 |     TableInit(elem_idx, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2500 |       let s = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2504 |       let d = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2508 |       stack.push(TInstr::table_init(elem_idx, table_idx, d, s, n))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2510 |     ElemDrop(idx) => stack.push(TInstr::elem_drop(idx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // === Select ===
     |     Select(types) => {
     |       let cond = match pop(stack) {
     |         Ok(t) => t
2516 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let val2 = match pop(stack) {
     |         Ok(t) => t
2520 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let val1 = match pop(stack) {
     |         Ok(t) => t
2524 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::select(types, cond, val1, val2))
     |     }
     | 
     |     // === Control flow ===
     |     Block(bt, body) => {
     |       let n_inputs = block_type_inputs(bt, env)
     |       let inputs = match pop_n(stack, n_inputs) {
     |         Ok(t) => t
2534 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       // Create a new stack with inputs for the block body
     |       let body_stack : Array[TInstr] = []
     |       for input in inputs {
     |         body_stack.push(input)
     |       }
     |       for instr in body.0 {
     |         match instr_to_tinstr(instr, body_stack, env) {
     |           Ok(_) => ()
2544 |           Err(t) => return Err(t)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       stack.push(TInstr::block(bt, TExpr::new(body_stack)))
     |     }
2549 |     Loop(bt, body) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n_inputs = block_type_inputs(bt, env)
     |       let inputs = match pop_n(stack, n_inputs) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
     |       let body_stack = []
     |       for input in inputs {
2557 |         body_stack.push(input)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for instr in body.0 {
2560 |         match instr_to_tinstr(instr, body_stack, env) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(_) => ()
     |           Err(t) => return Err(t)
     |         }
     |       }
2565 |       stack.push(TInstr::loop_(bt, TExpr::new(body_stack)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2567 |     If(bt, then_branch, else_branch) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let cond = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2572 |       let n_inputs = block_type_inputs(bt, env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let inputs = match pop_n(stack, n_inputs) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
     |       let then_stack : Array[TInstr] = []
     |       for input in inputs {
2579 |         then_stack.push(input)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for instr in then_branch {
2582 |         match instr_to_tinstr(instr, then_stack, env) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(_) => ()
     |           Err(t) => return Err(t)
     |         }
     |       }
2587 |       let else_texpr : TExpr? = match else_branch {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(else_instrs) => {
     |           let else_stack : Array[TInstr] = []
     |           for input in inputs {
2591 |             else_stack.push(input)
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           for instr in else_instrs {
2594 |             match instr_to_tinstr(instr, else_stack, env) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Ok(_) => ()
     |               Err(t) => return Err(t)
     |             }
     |           }
2599 |           Some(TExpr::new(else_stack))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
2601 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
2603 |       stack.push(TInstr::if_(bt, cond, TExpr::new(then_stack), else_texpr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2605 |     TryTable(bt, catches, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n_inputs = block_type_inputs(bt, env)
     |       let inputs = match pop_n(stack, n_inputs) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
     |       let body_stack = []
     |       for input in inputs {
2613 |         body_stack.push(input)
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for instr in body.0 {
2616 |         match instr_to_tinstr(instr, body_stack, env) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(_) => ()
     |           Err(t) => return Err(t)
     |         }
     |       }
2621 |       stack.push(TInstr::try_table(bt, catches, TExpr::new(body_stack)))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     Throw(tag_idx) => {
     |       let n_args = match env.resolve_tag_functype(tag_idx) {
     |         Some(FuncType(params, _)) => params.length()
2626 |         None => 0
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let args = match pop_n(stack, n_args) {
2629 |         Ok(t) => t
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
2632 |       stack.push(TInstr::throw_(tag_idx, args))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Branches ===
2636 |     Br(label) => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // Get the arity from label
2638 |       let arity = match env.get_label(label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2642 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2646 |       stack.push(TInstr::br(label, values))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2648 |     BrIf(label) => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let cond = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2653 |       let arity = match env.get_label(label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2657 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2661 |       stack.push(TInstr::br_if(label, cond, values))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2663 |     BrTable(labels, default) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2668 |       let arity = match env.get_label(default) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2672 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2676 |       stack.push(TInstr::br_table(labels, default, idx, values))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2678 |     BrOnNull(label) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2683 |       let arity = match env.get_label(label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2687 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2691 |       stack.push(TInstr::br_on_null(label, ref_, values))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2693 |     BrOnNonNull(label) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2698 |       let arity = match env.get_label(label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2702 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2706 |       stack.push(TInstr::br_on_non_null(label, ref_, values))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2708 |     BrOnCast(label, castop, ht1, ht2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2713 |       let arity = match env.get_label(label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2717 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2721 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::br_on_cast(label, castop.0, ht1, castop.1, ht2, ref_, values),
     |       )
     |     }
2725 |     BrOnCastFail(label, castop, ht1, ht2) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2730 |       let arity = match env.get_label(label) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(types) => types.length()
     |         None => 0
     |       }
2734 |       let values = match pop_n(stack, arity) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2738 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::br_on_cast_fail(
     |           label,
     |           castop.0,
     |           ht1,
     |           castop.1,
     |           ht2,
     |           ref_,
     |           values,
     |         ),
     |       )
     |     }
     |     Return => {
     |       let arity = match env.return_type {
     |         Some(types) => types.length()
2753 |         None => 0
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let values = match pop_n(stack, arity) {
2756 |         Ok(t) => t
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
2759 |       stack.push(TInstr::return_(values))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === Calls ===
     |     Call(func_idx) => {
     |       let n_args = match env.funcs.get(func_idx.0.reinterpret_as_int()) {
     |         Some(FuncType(params, _)) => params.length()
2766 |         None => 0
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let args = match pop_n(stack, n_args) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
     |       stack.push(TInstr::call(func_idx, args))
     |     }
     |     CallIndirect(type_idx, table_idx) => {
     |       let idx = match pop(stack) {
     |         Ok(t) => t
2777 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let n_args = match env.resolve_functype(type_idx) {
     |         Some(FuncType(params, _)) => params.length()
2781 |         None => 0
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let args = match pop_n(stack, n_args) {
2784 |         Ok(t) => t
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => return Err(t)
     |       }
2787 |       stack.push(TInstr::call_indirect(type_idx, table_idx, args, idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2789 |     CallRef(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2794 |       let n_args = match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(params, _)) => params.length()
     |         None => 0
     |       }
2798 |       let args = match pop_n(stack, n_args) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2802 |       stack.push(TInstr::call_ref(type_idx, args, ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2804 |     ReturnCall(func_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let n_args = match env.funcs.get(func_idx.0.reinterpret_as_int()) {
     |         Some(FuncType(params, _)) => params.length()
     |         None => 0
     |       }
2809 |       let args = match pop_n(stack, n_args) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2813 |       stack.push(TInstr::return_call(func_idx, args))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2815 |     ReturnCallIndirect(type_idx, table_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2820 |       let n_args = match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(params, _)) => params.length()
     |         None => 0
     |       }
2824 |       let args = match pop_n(stack, n_args) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2828 |       stack.push(TInstr::return_call_indirect(type_idx, table_idx, args, idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2830 |     ReturnCallRef(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2835 |       let n_args = match env.resolve_functype(type_idx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(FuncType(params, _)) => params.length()
     |         None => 0
     |       }
2839 |       let args = match pop_n(stack, n_args) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2843 |       stack.push(TInstr::return_call_ref(type_idx, args, ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === GC: Structs ===
     |     StructNew(type_idx) => {
     |       let n_fields = match env.resolve_comptype(type_idx) {
     |         Some(StructCompType(fields)) => fields.length()
2850 |         _ => 0
     |         ^^^^^^ 	<-- UNCOVERED
     |       }
     |       let fields = match pop_n(stack, n_fields) {
     |         Ok(t) => t
2854 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       stack.push(TInstr::struct_new(type_idx, fields))
     |     }
     |     StructNewDefault(type_idx) =>
     |       stack.push(TInstr::struct_new_default(type_idx))
2860 |     StructGet(type_idx, field_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let struct_ref = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2865 |       stack.push(TInstr::struct_get(type_idx, field_idx, struct_ref))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2867 |     StructGetS(type_idx, field_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let struct_ref = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2872 |       stack.push(TInstr::struct_get_s(type_idx, field_idx, struct_ref))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2874 |     StructGetU(type_idx, field_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let struct_ref = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2879 |       stack.push(TInstr::struct_get_u(type_idx, field_idx, struct_ref))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2881 |     StructSet(type_idx, field_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2886 |       let struct_ref = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2890 |       stack.push(TInstr::struct_set(type_idx, field_idx, struct_ref, val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === GC: Arrays ===
2894 |     ArrayNew(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2899 |       let init = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2903 |       stack.push(TInstr::array_new(type_idx, init, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2905 |     ArrayNewDefault(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2910 |       stack.push(TInstr::array_new_default(type_idx, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2912 |     ArrayNewFixed(type_idx, n) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let elems = match pop_n(stack, n.0.reinterpret_as_int()) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2917 |       stack.push(TInstr::array_new_fixed(type_idx, elems))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2919 |     ArrayNewData(type_idx, data_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2924 |       let offset = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2928 |       stack.push(TInstr::array_new_data(type_idx, data_idx, offset, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2930 |     ArrayNewElem(type_idx, elem_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2935 |       let offset = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2939 |       stack.push(TInstr::array_new_elem(type_idx, elem_idx, offset, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2941 |     ArrayGet(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2946 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2950 |       stack.push(TInstr::array_get(type_idx, arr, idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2952 |     ArrayGetS(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2957 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2961 |       stack.push(TInstr::array_get_s(type_idx, arr, idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2963 |     ArrayGetU(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let idx = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2968 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2972 |       stack.push(TInstr::array_get_u(type_idx, arr, idx))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2974 |     ArraySet(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2979 |       let idx = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2983 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2987 |       stack.push(TInstr::array_set(type_idx, arr, idx, val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
2989 |     ArrayFill(type_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2994 |       let val = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
2998 |       let offset = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3002 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3006 |       stack.push(TInstr::array_fill(type_idx, arr, offset, val, len))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3008 |     ArrayCopy(dst_type, src_type) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3013 |       let src_offset = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3017 |       let src = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3021 |       let dst_offset = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3025 |       let dst = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3029 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::array_copy(
     |           dst_type, src_type, dst, dst_offset, src, src_offset, len,
     |         ),
     |       )
     |     }
3035 |     ArrayInitData(type_idx, data_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3040 |       let src = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3044 |       let dst = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3048 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3052 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::array_init_data(type_idx, data_idx, arr, dst, src, len),
     |       )
     |     }
3056 |     ArrayInitElem(type_idx, elem_idx) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let len = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3061 |       let src = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3065 |       let dst = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3069 |       let arr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3073 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::array_init_elem(type_idx, elem_idx, arr, dst, src, len),
     |       )
     |     }
     | 
     |     // === GC: Casts ===
3079 |     RefGetDesc => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3084 |       stack.push(TInstr::ref_get_desc(ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3086 |     RefTest(nullable, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3091 |       stack.push(TInstr::ref_test(nullable, ht, ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3093 |     RefCast(nullable, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3098 |       stack.push(TInstr::ref_cast(nullable, ht, ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3100 |     RefTestDesc(nullable, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3105 |       stack.push(TInstr::ref_test_desc(nullable, ht, ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3107 |     RefCastDescEq(nullable, ht) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let ref_ = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3112 |       stack.push(TInstr::ref_cast_desc_eq(nullable, ht, ref_))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD ===
3116 |     V128Load(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3121 |       stack.push(TInstr::load(LoadOp::v128_load(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3123 |     V128Load8x8S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3128 |       stack.push(TInstr::load(LoadOp::v128_load8x8s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3130 |     V128Load8x8U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3135 |       stack.push(TInstr::load(LoadOp::v128_load8x8u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3137 |     V128Load16x4S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3142 |       stack.push(TInstr::load(LoadOp::v128_load16x4s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3144 |     V128Load16x4U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3149 |       stack.push(TInstr::load(LoadOp::v128_load16x4u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3151 |     V128Load32x2S(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3156 |       stack.push(TInstr::load(LoadOp::v128_load32x2s(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3158 |     V128Load32x2U(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3163 |       stack.push(TInstr::load(LoadOp::v128_load32x2u(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3165 |     V128Load8Splat(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3170 |       stack.push(TInstr::load(LoadOp::v128_load8_splat(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3172 |     V128Load16Splat(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3177 |       stack.push(TInstr::load(LoadOp::v128_load16_splat(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3179 |     V128Load32Splat(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3184 |       stack.push(TInstr::load(LoadOp::v128_load32_splat(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3186 |     V128Load64Splat(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3191 |       stack.push(TInstr::load(LoadOp::v128_load64_splat(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3193 |     V128Load32Zero(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3198 |       stack.push(TInstr::load(LoadOp::v128_load32_zero(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3200 |     V128Load64Zero(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let addr = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3205 |       stack.push(TInstr::load(LoadOp::v128_load64_zero(), memarg, addr))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3207 |     V128Store(memarg) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3212 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3216 |       stack.push(TInstr::store(StoreOp::v128_store(), memarg, addr, val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3218 |     V128Load8Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3223 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3227 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_load_lane(
     |           V128LoadLaneOp::v128_load8_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3237 |     V128Load16Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3242 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3246 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_load_lane(
     |           V128LoadLaneOp::v128_load16_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3256 |     V128Load32Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3261 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3265 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_load_lane(
     |           V128LoadLaneOp::v128_load32_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3275 |     V128Load64Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3280 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3284 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_load_lane(
     |           V128LoadLaneOp::v128_load64_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3294 |     V128Store8Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3299 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3303 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_store_lane(
     |           V128StoreLaneOp::v128_store8_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3313 |     V128Store16Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3318 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3322 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_store_lane(
     |           V128StoreLaneOp::v128_store16_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3332 |     V128Store32Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3337 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3341 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_store_lane(
     |           V128StoreLaneOp::v128_store32_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
3351 |     V128Store64Lane(memarg, lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3356 |       let addr = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3360 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_store_lane(
     |           V128StoreLaneOp::v128_store64_lane(),
     |           memarg,
     |           lane,
     |           addr,
     |           vec,
     |         ),
     |       )
     |     }
     | 
     |     // === SIMD: Splat ===
3372 |     I8x16Splat => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3377 |       stack.push(TInstr::i8x16_splat(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3379 |     I16x8Splat => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3384 |       stack.push(TInstr::i16x8_splat(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3386 |     I32x4Splat => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3391 |       stack.push(TInstr::i32x4_splat(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3393 |     I64x2Splat => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3398 |       stack.push(TInstr::i64x2_splat(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3400 |     F32x4Splat => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3405 |       stack.push(TInstr::f32x4_splat(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3407 |     F64x2Splat => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3412 |       stack.push(TInstr::f64x2_splat(val))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Extract lane ===
3416 |     I8x16ExtractLaneS(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3421 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::i8x16_extract_lane_s(), lane, vec),
     |       )
     |     }
3425 |     I8x16ExtractLaneU(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3430 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::i8x16_extract_lane_u(), lane, vec),
     |       )
     |     }
3434 |     I16x8ExtractLaneS(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3439 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::i16x8_extract_lane_s(), lane, vec),
     |       )
     |     }
3443 |     I16x8ExtractLaneU(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3448 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::i16x8_extract_lane_u(), lane, vec),
     |       )
     |     }
3452 |     I32x4ExtractLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3457 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::i32x4_extract_lane(), lane, vec),
     |       )
     |     }
3461 |     I64x2ExtractLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3466 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::i64x2_extract_lane(), lane, vec),
     |       )
     |     }
3470 |     F32x4ExtractLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3475 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::f32x4_extract_lane(), lane, vec),
     |       )
     |     }
3479 |     F64x2ExtractLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let vec = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3484 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::extract_lane(ExtractLaneOp::f64x2_extract_lane(), lane, vec),
     |       )
     |     }
     | 
     |     // === SIMD: Replace lane ===
3490 |     I8x16ReplaceLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3495 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3499 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::replace_lane(
     |           ReplaceLaneOp::i8x16_replace_lane(),
     |           lane,
     |           vec,
     |           val,
     |         ),
     |       )
     |     }
3508 |     I16x8ReplaceLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3513 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3517 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::replace_lane(
     |           ReplaceLaneOp::i16x8_replace_lane(),
     |           lane,
     |           vec,
     |           val,
     |         ),
     |       )
     |     }
3526 |     I32x4ReplaceLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3531 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3535 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::replace_lane(
     |           ReplaceLaneOp::i32x4_replace_lane(),
     |           lane,
     |           vec,
     |           val,
     |         ),
     |       )
     |     }
3544 |     I64x2ReplaceLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3549 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3553 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::replace_lane(
     |           ReplaceLaneOp::i64x2_replace_lane(),
     |           lane,
     |           vec,
     |           val,
     |         ),
     |       )
     |     }
3562 |     F32x4ReplaceLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3567 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3571 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::replace_lane(
     |           ReplaceLaneOp::f32x4_replace_lane(),
     |           lane,
     |           vec,
     |           val,
     |         ),
     |       )
     |     }
3580 |     F64x2ReplaceLane(lane) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let val = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3585 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3589 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::replace_lane(
     |           ReplaceLaneOp::f64x2_replace_lane(),
     |           lane,
     |           vec,
     |           val,
     |         ),
     |       )
     |     }
     | 
     |     // === SIMD: Shuffle/Swizzle ===
     |     I8x16Shuffle(
     |       l0,
     |       l1,
     |       l2,
     |       l3,
     |       l4,
     |       l5,
     |       l6,
     |       l7,
     |       l8,
     |       l9,
     |       l10,
     |       l11,
     |       l12,
     |       l13,
     |       l14,
     |       l15
3617 |     ) => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       let v2 = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3622 |       let v1 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3626 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::i8x16_shuffle(
     |           l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, v1,
     |           v2,
     |         ),
     |       )
     |     }
3633 |     I8x16Swizzle => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let indices = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3638 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3642 |       stack.push(TInstr::i8x16_swizzle(vec, indices))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3644 |     I8x16RelaxedSwizzle => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let indices = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3649 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3653 |       stack.push(TInstr::i8x16_relaxed_swizzle(vec, indices))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Unary v128 -> v128 ===
3657 |     V128Not => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3662 |       stack.push(TInstr::unary(UnaryOp::v128_not(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3664 |     I8x16Abs => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3669 |       stack.push(TInstr::unary(UnaryOp::i8x16_abs(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3671 |     I8x16Neg => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3676 |       stack.push(TInstr::unary(UnaryOp::i8x16_neg(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3678 |     I8x16Popcnt => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3683 |       stack.push(TInstr::unary(UnaryOp::i8x16_popcnt(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3685 |     I16x8Abs => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3690 |       stack.push(TInstr::unary(UnaryOp::i16x8_abs(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     // === SIMD: Unary v128 -> v128 (continued) ===
3693 |     I16x8Neg => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3698 |       stack.push(TInstr::unary(UnaryOp::i16x8_neg(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3700 |     I32x4Abs => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3705 |       stack.push(TInstr::unary(UnaryOp::i32x4_abs(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3707 |     I32x4Neg => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3712 |       stack.push(TInstr::unary(UnaryOp::i32x4_neg(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3714 |     I64x2Abs => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3719 |       stack.push(TInstr::unary(UnaryOp::i64x2_abs(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3721 |     I64x2Neg => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3726 |       stack.push(TInstr::unary(UnaryOp::i64x2_neg(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3728 |     F32x4Abs => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3733 |       stack.push(TInstr::unary(UnaryOp::f32x4_abs(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3735 |     F32x4Neg => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3740 |       stack.push(TInstr::unary(UnaryOp::f32x4_neg(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3742 |     F32x4Sqrt => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3747 |       stack.push(TInstr::unary(UnaryOp::f32x4_sqrt(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3749 |     F32x4Ceil => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3754 |       stack.push(TInstr::unary(UnaryOp::f32x4_ceil(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3756 |     F32x4Floor => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3761 |       stack.push(TInstr::unary(UnaryOp::f32x4_floor(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3763 |     F32x4Trunc => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3768 |       stack.push(TInstr::unary(UnaryOp::f32x4_trunc(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3770 |     F32x4Nearest => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3775 |       stack.push(TInstr::unary(UnaryOp::f32x4_nearest(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3777 |     F64x2Abs => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3782 |       stack.push(TInstr::unary(UnaryOp::f64x2_abs(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3784 |     F64x2Neg => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3789 |       stack.push(TInstr::unary(UnaryOp::f64x2_neg(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3791 |     F64x2Sqrt => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3796 |       stack.push(TInstr::unary(UnaryOp::f64x2_sqrt(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3798 |     F64x2Ceil => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3803 |       stack.push(TInstr::unary(UnaryOp::f64x2_ceil(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3805 |     F64x2Floor => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3810 |       stack.push(TInstr::unary(UnaryOp::f64x2_floor(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3812 |     F64x2Trunc => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3817 |       stack.push(TInstr::unary(UnaryOp::f64x2_trunc(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3819 |     F64x2Nearest => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3824 |       stack.push(TInstr::unary(UnaryOp::f64x2_nearest(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: v128 -> i32 (bitmask/alltrue) ===
3828 |     V128AnyTrue => {
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3833 |       stack.push(TInstr::unary(UnaryOp::v128_any_true(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3835 |     I8x16AllTrue => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3840 |       stack.push(TInstr::unary(UnaryOp::i8x16_all_true(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3842 |     I8x16Bitmask => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3847 |       stack.push(TInstr::unary(UnaryOp::i8x16_bitmask(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3849 |     I16x8AllTrue => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3854 |       stack.push(TInstr::unary(UnaryOp::i16x8_all_true(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3856 |     I16x8Bitmask => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3861 |       stack.push(TInstr::unary(UnaryOp::i16x8_bitmask(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3863 |     I32x4AllTrue => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3868 |       stack.push(TInstr::unary(UnaryOp::i32x4_all_true(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3870 |     I32x4Bitmask => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3875 |       stack.push(TInstr::unary(UnaryOp::i32x4_bitmask(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3877 |     I64x2AllTrue => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3882 |       stack.push(TInstr::unary(UnaryOp::i64x2_all_true(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3884 |     I64x2Bitmask => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3889 |       stack.push(TInstr::unary(UnaryOp::i64x2_bitmask(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Extend (v128 -> v128) ===
3893 |     I16x8ExtendLowI8x16S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3898 |       stack.push(TInstr::unary(UnaryOp::i16x8_extend_low_i8x16s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3900 |     I16x8ExtendHighI8x16S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3905 |       stack.push(TInstr::unary(UnaryOp::i16x8_extend_high_i8x16s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3907 |     I16x8ExtendLowI8x16U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3912 |       stack.push(TInstr::unary(UnaryOp::i16x8_extend_low_i8x16u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3914 |     I16x8ExtendHighI8x16U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3919 |       stack.push(TInstr::unary(UnaryOp::i16x8_extend_high_i8x16u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3921 |     I32x4ExtendLowI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3926 |       stack.push(TInstr::unary(UnaryOp::i32x4_extend_low_i16x8s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3928 |     I32x4ExtendHighI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3933 |       stack.push(TInstr::unary(UnaryOp::i32x4_extend_high_i16x8s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3935 |     I32x4ExtendLowI16x8U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3940 |       stack.push(TInstr::unary(UnaryOp::i32x4_extend_low_i16x8u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3942 |     I32x4ExtendHighI16x8U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3947 |       stack.push(TInstr::unary(UnaryOp::i32x4_extend_high_i16x8u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3949 |     I64x2ExtendLowI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3954 |       stack.push(TInstr::unary(UnaryOp::i64x2_extend_low_i32x4s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3956 |     I64x2ExtendHighI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3961 |       stack.push(TInstr::unary(UnaryOp::i64x2_extend_high_i32x4s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3963 |     I64x2ExtendLowI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3968 |       stack.push(TInstr::unary(UnaryOp::i64x2_extend_low_i32x4u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3970 |     I64x2ExtendHighI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3975 |       stack.push(TInstr::unary(UnaryOp::i64x2_extend_high_i32x4u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Pairwise add (v128 -> v128) ===
3979 |     I16x8ExtaddPairwiseI8x16S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3984 |       stack.push(TInstr::unary(UnaryOp::i16x8_extadd_pairwise_i8x16s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3986 |     I16x8ExtaddPairwiseI8x16U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3991 |       stack.push(TInstr::unary(UnaryOp::i16x8_extadd_pairwise_i8x16u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
3993 |     I32x4ExtaddPairwiseI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
3998 |       stack.push(TInstr::unary(UnaryOp::i32x4_extadd_pairwise_i16x8s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4000 |     I32x4ExtaddPairwiseI16x8U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4005 |       stack.push(TInstr::unary(UnaryOp::i32x4_extadd_pairwise_i16x8u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Conversion (v128 -> v128) ===
4009 |     F32x4DemoteF64x2Zero => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4014 |       stack.push(TInstr::unary(UnaryOp::f32x4_demote_f64x2_zero(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4016 |     F64x2PromoteLowF32x4 => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4021 |       stack.push(TInstr::unary(UnaryOp::f64x2_promote_low_f32x4(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4023 |     I32x4TruncSatF32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4028 |       stack.push(TInstr::unary(UnaryOp::i32x4_trunc_sat_f32x4s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4030 |     I32x4TruncSatF32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4035 |       stack.push(TInstr::unary(UnaryOp::i32x4_trunc_sat_f32x4u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4037 |     F32x4ConvertI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4042 |       stack.push(TInstr::unary(UnaryOp::f32x4_convert_i32x4s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4044 |     F32x4ConvertI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4049 |       stack.push(TInstr::unary(UnaryOp::f32x4_convert_i32x4u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4051 |     I32x4TruncSatF64x2SZero => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4056 |       stack.push(TInstr::unary(UnaryOp::i32x4_trunc_sat_f64x2s_zero(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4058 |     I32x4TruncSatF64x2UZero => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4063 |       stack.push(TInstr::unary(UnaryOp::i32x4_trunc_sat_f64x2u_zero(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4065 |     F64x2ConvertLowI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4070 |       stack.push(TInstr::unary(UnaryOp::f64x2_convert_low_i32x4s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4072 |     F64x2ConvertLowI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4077 |       stack.push(TInstr::unary(UnaryOp::f64x2_convert_low_i32x4u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Relaxed truncation (v128 -> v128) ===
4081 |     I32x4RelaxedTruncF32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4086 |       stack.push(TInstr::unary(UnaryOp::i32x4_relaxed_trunc_f32x4s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4088 |     I32x4RelaxedTruncF32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4093 |       stack.push(TInstr::unary(UnaryOp::i32x4_relaxed_trunc_f32x4u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4095 |     I32x4RelaxedTruncZeroF64x2S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4100 |       stack.push(TInstr::unary(UnaryOp::i32x4_relaxed_trunc_zero_f64x2s(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4102 |     I32x4RelaxedTruncZeroF64x2U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let op = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4107 |       stack.push(TInstr::unary(UnaryOp::i32x4_relaxed_trunc_zero_f64x2u(), op))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Binary bitwise (v128, v128 -> v128) ===
4111 |     V128And => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4116 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4120 |       stack.push(TInstr::binary(BinaryOp::v128_and(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4122 |     V128Andnot => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4127 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4131 |       stack.push(TInstr::binary(BinaryOp::v128_andnot(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4133 |     V128Or => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4138 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4142 |       stack.push(TInstr::binary(BinaryOp::v128_or(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4144 |     V128Xor => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4149 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4153 |       stack.push(TInstr::binary(BinaryOp::v128_xor(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i8x16 comparisons ===
4157 |     I8x16Eq => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4162 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4166 |       stack.push(TInstr::binary(BinaryOp::i8x16_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4168 |     I8x16Ne => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4173 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4177 |       stack.push(TInstr::binary(BinaryOp::i8x16_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4179 |     I8x16LtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4184 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4188 |       stack.push(TInstr::binary(BinaryOp::i8x16_lt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4190 |     I8x16LtU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4195 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4199 |       stack.push(TInstr::binary(BinaryOp::i8x16_lt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4201 |     I8x16GtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4206 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4210 |       stack.push(TInstr::binary(BinaryOp::i8x16_gt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4212 |     I8x16GtU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4217 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4221 |       stack.push(TInstr::binary(BinaryOp::i8x16_gt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4223 |     I8x16LeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4228 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4232 |       stack.push(TInstr::binary(BinaryOp::i8x16_le_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4234 |     I8x16LeU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4239 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4243 |       stack.push(TInstr::binary(BinaryOp::i8x16_le_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4245 |     I8x16GeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4250 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4254 |       stack.push(TInstr::binary(BinaryOp::i8x16_ge_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4256 |     I8x16GeU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4261 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4265 |       stack.push(TInstr::binary(BinaryOp::i8x16_ge_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i16x8 comparisons ===
4269 |     I16x8Eq => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4274 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4278 |       stack.push(TInstr::binary(BinaryOp::i16x8_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4280 |     I16x8Ne => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4285 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4289 |       stack.push(TInstr::binary(BinaryOp::i16x8_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4291 |     I16x8LtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4296 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4300 |       stack.push(TInstr::binary(BinaryOp::i16x8_lt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4302 |     I16x8LtU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4307 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4311 |       stack.push(TInstr::binary(BinaryOp::i16x8_lt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4313 |     I16x8GtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4318 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4322 |       stack.push(TInstr::binary(BinaryOp::i16x8_gt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4324 |     I16x8GtU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4329 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4333 |       stack.push(TInstr::binary(BinaryOp::i16x8_gt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4335 |     I16x8LeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4340 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4344 |       stack.push(TInstr::binary(BinaryOp::i16x8_le_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4346 |     I16x8LeU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4351 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4355 |       stack.push(TInstr::binary(BinaryOp::i16x8_le_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4357 |     I16x8GeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4362 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4366 |       stack.push(TInstr::binary(BinaryOp::i16x8_ge_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4368 |     I16x8GeU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4373 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4377 |       stack.push(TInstr::binary(BinaryOp::i16x8_ge_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i32x4 comparisons ===
4381 |     I32x4Eq => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4386 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4390 |       stack.push(TInstr::binary(BinaryOp::i32x4_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4392 |     I32x4Ne => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4397 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4401 |       stack.push(TInstr::binary(BinaryOp::i32x4_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4403 |     I32x4LtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4408 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4412 |       stack.push(TInstr::binary(BinaryOp::i32x4_lt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4414 |     I32x4LtU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4419 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4423 |       stack.push(TInstr::binary(BinaryOp::i32x4_lt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4425 |     I32x4GtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4430 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4434 |       stack.push(TInstr::binary(BinaryOp::i32x4_gt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4436 |     I32x4GtU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4441 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4445 |       stack.push(TInstr::binary(BinaryOp::i32x4_gt_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4447 |     I32x4LeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4452 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4456 |       stack.push(TInstr::binary(BinaryOp::i32x4_le_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4458 |     I32x4LeU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4463 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4467 |       stack.push(TInstr::binary(BinaryOp::i32x4_le_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4469 |     I32x4GeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4474 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4478 |       stack.push(TInstr::binary(BinaryOp::i32x4_ge_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4480 |     I32x4GeU => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4485 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4489 |       stack.push(TInstr::binary(BinaryOp::i32x4_ge_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i64x2 comparisons ===
4493 |     I64x2Eq => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4498 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4502 |       stack.push(TInstr::binary(BinaryOp::i64x2_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4504 |     I64x2Ne => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4509 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4513 |       stack.push(TInstr::binary(BinaryOp::i64x2_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4515 |     I64x2LtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4520 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4524 |       stack.push(TInstr::binary(BinaryOp::i64x2_lt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4526 |     I64x2GtS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4531 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4535 |       stack.push(TInstr::binary(BinaryOp::i64x2_gt_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4537 |     I64x2LeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4542 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4546 |       stack.push(TInstr::binary(BinaryOp::i64x2_le_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4548 |     I64x2GeS => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4553 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4557 |       stack.push(TInstr::binary(BinaryOp::i64x2_ge_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: f32x4 comparisons ===
4561 |     F32x4Eq => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4566 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4570 |       stack.push(TInstr::binary(BinaryOp::f32x4_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4572 |     F32x4Ne => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4577 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4581 |       stack.push(TInstr::binary(BinaryOp::f32x4_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4583 |     F32x4Lt => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4588 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4592 |       stack.push(TInstr::binary(BinaryOp::f32x4_lt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4594 |     F32x4Gt => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4599 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4603 |       stack.push(TInstr::binary(BinaryOp::f32x4_gt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4605 |     F32x4Le => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4610 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4614 |       stack.push(TInstr::binary(BinaryOp::f32x4_le(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4616 |     F32x4Ge => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4621 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4625 |       stack.push(TInstr::binary(BinaryOp::f32x4_ge(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: f64x2 comparisons ===
4629 |     F64x2Eq => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4634 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4638 |       stack.push(TInstr::binary(BinaryOp::f64x2_eq(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4640 |     F64x2Ne => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4645 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4649 |       stack.push(TInstr::binary(BinaryOp::f64x2_ne(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4651 |     F64x2Lt => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4656 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4660 |       stack.push(TInstr::binary(BinaryOp::f64x2_lt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4662 |     F64x2Gt => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4667 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4671 |       stack.push(TInstr::binary(BinaryOp::f64x2_gt(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4673 |     F64x2Le => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4678 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4682 |       stack.push(TInstr::binary(BinaryOp::f64x2_le(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4684 |     F64x2Ge => {
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4689 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4693 |       stack.push(TInstr::binary(BinaryOp::f64x2_ge(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i8x16 arithmetic ===
4697 |     I8x16Add => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4702 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4706 |       stack.push(TInstr::binary(BinaryOp::i8x16_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4708 |     I8x16AddSatS => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4713 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4717 |       stack.push(TInstr::binary(BinaryOp::i8x16_add_sat_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4719 |     I8x16AddSatU => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4724 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4728 |       stack.push(TInstr::binary(BinaryOp::i8x16_add_sat_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4730 |     I8x16Sub => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4735 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4739 |       stack.push(TInstr::binary(BinaryOp::i8x16_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4741 |     I8x16SubSatS => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4746 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4750 |       stack.push(TInstr::binary(BinaryOp::i8x16_sub_sat_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4752 |     I8x16SubSatU => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4757 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4761 |       stack.push(TInstr::binary(BinaryOp::i8x16_sub_sat_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4763 |     I8x16MinS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4768 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4772 |       stack.push(TInstr::binary(BinaryOp::i8x16_min_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4774 |     I8x16MinU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4779 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4783 |       stack.push(TInstr::binary(BinaryOp::i8x16_min_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4785 |     I8x16MaxS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4790 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4794 |       stack.push(TInstr::binary(BinaryOp::i8x16_max_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4796 |     I8x16MaxU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4801 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4805 |       stack.push(TInstr::binary(BinaryOp::i8x16_max_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4807 |     I8x16AvgrU => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4812 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4816 |       stack.push(TInstr::binary(BinaryOp::i8x16_avgr_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4818 |     I8x16NarrowI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4823 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4827 |       stack.push(TInstr::binary(BinaryOp::i8x16_narrow_i16x8s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4829 |     I8x16NarrowI16x8U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4834 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4838 |       stack.push(TInstr::binary(BinaryOp::i8x16_narrow_i16x8u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i16x8 arithmetic ===
4842 |     I16x8Add => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4847 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4851 |       stack.push(TInstr::binary(BinaryOp::i16x8_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4853 |     I16x8AddSatS => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4858 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4862 |       stack.push(TInstr::binary(BinaryOp::i16x8_add_sat_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4864 |     I16x8AddSatU => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4869 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4873 |       stack.push(TInstr::binary(BinaryOp::i16x8_add_sat_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4875 |     I16x8Sub => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4880 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4884 |       stack.push(TInstr::binary(BinaryOp::i16x8_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4886 |     I16x8SubSatS => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4891 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4895 |       stack.push(TInstr::binary(BinaryOp::i16x8_sub_sat_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4897 |     I16x8SubSatU => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4902 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4906 |       stack.push(TInstr::binary(BinaryOp::i16x8_sub_sat_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4908 |     I16x8Mul => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4913 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4917 |       stack.push(TInstr::binary(BinaryOp::i16x8_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4919 |     I16x8MinS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4924 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4928 |       stack.push(TInstr::binary(BinaryOp::i16x8_min_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4930 |     I16x8MinU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4935 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4939 |       stack.push(TInstr::binary(BinaryOp::i16x8_min_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4941 |     I16x8MaxS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4946 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4950 |       stack.push(TInstr::binary(BinaryOp::i16x8_max_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4952 |     I16x8MaxU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4957 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4961 |       stack.push(TInstr::binary(BinaryOp::i16x8_max_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4963 |     I16x8AvgrU => {
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4968 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4972 |       stack.push(TInstr::binary(BinaryOp::i16x8_avgr_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4974 |     I16x8Q15mulrSatS => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4979 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4983 |       stack.push(TInstr::binary(BinaryOp::i16x8q15mulr_sat_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4985 |     I16x8NarrowI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4990 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
4994 |       stack.push(TInstr::binary(BinaryOp::i16x8_narrow_i32x4s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
4996 |     I16x8NarrowI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5001 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5005 |       stack.push(TInstr::binary(BinaryOp::i16x8_narrow_i32x4u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5007 |     I16x8ExtmulLowI8x16S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5012 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5016 |       stack.push(TInstr::binary(BinaryOp::i16x8_extmul_low_i8x16s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5018 |     I16x8ExtmulHighI8x16S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5023 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5027 |       stack.push(TInstr::binary(BinaryOp::i16x8_extmul_high_i8x16s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5029 |     I16x8ExtmulLowI8x16U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5034 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5038 |       stack.push(TInstr::binary(BinaryOp::i16x8_extmul_low_i8x16u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5040 |     I16x8ExtmulHighI8x16U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5045 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5049 |       stack.push(TInstr::binary(BinaryOp::i16x8_extmul_high_i8x16u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i32x4 arithmetic ===
5053 |     I32x4Add => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5058 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5062 |       stack.push(TInstr::binary(BinaryOp::i32x4_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5064 |     I32x4Sub => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5069 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5073 |       stack.push(TInstr::binary(BinaryOp::i32x4_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5075 |     I32x4Mul => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5080 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5084 |       stack.push(TInstr::binary(BinaryOp::i32x4_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5086 |     I32x4MinS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5091 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5095 |       stack.push(TInstr::binary(BinaryOp::i32x4_min_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5097 |     I32x4MinU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5102 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5106 |       stack.push(TInstr::binary(BinaryOp::i32x4_min_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5108 |     I32x4MaxS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5113 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5117 |       stack.push(TInstr::binary(BinaryOp::i32x4_max_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5119 |     I32x4MaxU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5124 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5128 |       stack.push(TInstr::binary(BinaryOp::i32x4_max_u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5130 |     I32x4DotI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5135 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5139 |       stack.push(TInstr::binary(BinaryOp::i32x4_dot_i16x8s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5141 |     I32x4ExtmulLowI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5146 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5150 |       stack.push(TInstr::binary(BinaryOp::i32x4_extmul_low_i16x8s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5152 |     I32x4ExtmulHighI16x8S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5157 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5161 |       stack.push(TInstr::binary(BinaryOp::i32x4_extmul_high_i16x8s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5163 |     I32x4ExtmulLowI16x8U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5168 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5172 |       stack.push(TInstr::binary(BinaryOp::i32x4_extmul_low_i16x8u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5174 |     I32x4ExtmulHighI16x8U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5179 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5183 |       stack.push(TInstr::binary(BinaryOp::i32x4_extmul_high_i16x8u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: i64x2 arithmetic ===
5187 |     I64x2Add => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5192 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5196 |       stack.push(TInstr::binary(BinaryOp::i64x2_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5198 |     I64x2Sub => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5203 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5207 |       stack.push(TInstr::binary(BinaryOp::i64x2_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5209 |     I64x2Mul => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5214 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5218 |       stack.push(TInstr::binary(BinaryOp::i64x2_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5220 |     I64x2ExtmulLowI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5225 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5229 |       stack.push(TInstr::binary(BinaryOp::i64x2_extmul_low_i32x4s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5231 |     I64x2ExtmulHighI32x4S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5236 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5240 |       stack.push(TInstr::binary(BinaryOp::i64x2_extmul_high_i32x4s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5242 |     I64x2ExtmulLowI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5247 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5251 |       stack.push(TInstr::binary(BinaryOp::i64x2_extmul_low_i32x4u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5253 |     I64x2ExtmulHighI32x4U => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5258 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5262 |       stack.push(TInstr::binary(BinaryOp::i64x2_extmul_high_i32x4u(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: f32x4 arithmetic ===
5266 |     F32x4Add => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5271 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5275 |       stack.push(TInstr::binary(BinaryOp::f32x4_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5277 |     F32x4Sub => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5282 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5286 |       stack.push(TInstr::binary(BinaryOp::f32x4_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5288 |     F32x4Mul => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5293 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5297 |       stack.push(TInstr::binary(BinaryOp::f32x4_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5299 |     F32x4Div => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5304 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5308 |       stack.push(TInstr::binary(BinaryOp::f32x4_div(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5310 |     F32x4Min => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5315 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5319 |       stack.push(TInstr::binary(BinaryOp::f32x4_min(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5321 |     F32x4Max => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5326 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5330 |       stack.push(TInstr::binary(BinaryOp::f32x4_max(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5332 |     F32x4Pmin => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5337 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5341 |       stack.push(TInstr::binary(BinaryOp::f32x4_pmin(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5343 |     F32x4Pmax => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5348 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5352 |       stack.push(TInstr::binary(BinaryOp::f32x4_pmax(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: f64x2 arithmetic ===
5356 |     F64x2Add => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5361 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5365 |       stack.push(TInstr::binary(BinaryOp::f64x2_add(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5367 |     F64x2Sub => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5372 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5376 |       stack.push(TInstr::binary(BinaryOp::f64x2_sub(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5378 |     F64x2Mul => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5383 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5387 |       stack.push(TInstr::binary(BinaryOp::f64x2_mul(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5389 |     F64x2Div => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5394 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5398 |       stack.push(TInstr::binary(BinaryOp::f64x2_div(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5400 |     F64x2Min => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5405 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5409 |       stack.push(TInstr::binary(BinaryOp::f64x2_min(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5411 |     F64x2Max => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5416 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5420 |       stack.push(TInstr::binary(BinaryOp::f64x2_max(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5422 |     F64x2Pmin => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5427 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5431 |       stack.push(TInstr::binary(BinaryOp::f64x2_pmin(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5433 |     F64x2Pmax => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5438 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5442 |       stack.push(TInstr::binary(BinaryOp::f64x2_pmax(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Relaxed binary ===
5446 |     F32x4RelaxedMin => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5451 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5455 |       stack.push(TInstr::binary(BinaryOp::f32x4_relaxed_min(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5457 |     F32x4RelaxedMax => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5462 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5466 |       stack.push(TInstr::binary(BinaryOp::f32x4_relaxed_max(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5468 |     F64x2RelaxedMin => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5473 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5477 |       stack.push(TInstr::binary(BinaryOp::f64x2_relaxed_min(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5479 |     F64x2RelaxedMax => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5484 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5488 |       stack.push(TInstr::binary(BinaryOp::f64x2_relaxed_max(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5490 |     I16x8RelaxedQ15mulrS => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5495 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5499 |       stack.push(TInstr::binary(BinaryOp::i16x8_relaxed_q15mulr_s(), lhs, rhs))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5501 |     I16x8RelaxedDotI8x16I7x16S => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let rhs = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5506 |       let lhs = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5510 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::binary(BinaryOp::i16x8_relaxed_dot_i8x16i7x16s(), lhs, rhs),
     |       )
     |     }
     | 
     |     // === SIMD: Shift (v128, i32 -> v128) ===
5516 |     I8x16Shl => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5521 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5525 |       stack.push(TInstr::v128_shift(V128ShiftOp::i8x16_shl(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5527 |     I8x16ShrS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5532 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5536 |       stack.push(TInstr::v128_shift(V128ShiftOp::i8x16_shr_s(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5538 |     I8x16ShrU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5543 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5547 |       stack.push(TInstr::v128_shift(V128ShiftOp::i8x16_shr_u(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5549 |     I16x8Shl => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5554 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5558 |       stack.push(TInstr::v128_shift(V128ShiftOp::i16x8_shl(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5560 |     I16x8ShrS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5565 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5569 |       stack.push(TInstr::v128_shift(V128ShiftOp::i16x8_shr_s(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5571 |     I16x8ShrU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5576 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5580 |       stack.push(TInstr::v128_shift(V128ShiftOp::i16x8_shr_u(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5582 |     I32x4Shl => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5587 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5591 |       stack.push(TInstr::v128_shift(V128ShiftOp::i32x4_shl(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5593 |     I32x4ShrS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5598 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5602 |       stack.push(TInstr::v128_shift(V128ShiftOp::i32x4_shr_s(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5604 |     I32x4ShrU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5609 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5613 |       stack.push(TInstr::v128_shift(V128ShiftOp::i32x4_shr_u(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5615 |     I64x2Shl => {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5620 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5624 |       stack.push(TInstr::v128_shift(V128ShiftOp::i64x2_shl(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5626 |     I64x2ShrS => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5631 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5635 |       stack.push(TInstr::v128_shift(V128ShiftOp::i64x2_shr_s(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
5637 |     I64x2ShrU => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let shift = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5642 |       let vec = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5646 |       stack.push(TInstr::v128_shift(V128ShiftOp::i64x2_shr_u(), vec, shift))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     // === SIMD: Ternary (v128, v128, v128 -> v128) ===
5650 |     V128Bitselect => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5655 |       let v2 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5659 |       let v1 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5663 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(V128TernaryOp::v128_bitselect(), v1, v2, c),
     |       )
     |     }
5667 |     I8x16RelaxedLaneselect => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5672 |       let v2 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5676 |       let v1 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5680 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(
     |           V128TernaryOp::i8x16_relaxed_laneselect(),
     |           v1,
     |           v2,
     |           c,
     |         ),
     |       )
     |     }
5689 |     I16x8RelaxedLaneselect => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5694 |       let v2 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5698 |       let v1 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5702 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(
     |           V128TernaryOp::i16x8_relaxed_laneselect(),
     |           v1,
     |           v2,
     |           c,
     |         ),
     |       )
     |     }
5711 |     I32x4RelaxedLaneselect => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5716 |       let v2 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5720 |       let v1 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5724 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(
     |           V128TernaryOp::i32x4_relaxed_laneselect(),
     |           v1,
     |           v2,
     |           c,
     |         ),
     |       )
     |     }
5733 |     I64x2RelaxedLaneselect => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5738 |       let v2 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5742 |       let v1 = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5746 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(
     |           V128TernaryOp::i64x2_relaxed_laneselect(),
     |           v1,
     |           v2,
     |           c,
     |         ),
     |       )
     |     }
5755 |     F32x4RelaxedMadd => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5760 |       let b = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5764 |       let a = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5768 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(V128TernaryOp::f32x4_relaxed_madd(), a, b, c),
     |       )
     |     }
5772 |     F32x4RelaxedNmadd => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5777 |       let b = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5781 |       let a = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5785 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(V128TernaryOp::f32x4_relaxed_nmadd(), a, b, c),
     |       )
     |     }
5789 |     F64x2RelaxedMadd => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5794 |       let b = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5798 |       let a = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5802 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(V128TernaryOp::f64x2_relaxed_madd(), a, b, c),
     |       )
     |     }
5806 |     F64x2RelaxedNmadd => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5811 |       let b = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5815 |       let a = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5819 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(V128TernaryOp::f64x2_relaxed_nmadd(), a, b, c),
     |       )
     |     }
5823 |     I32x4RelaxedDotI8x16I7x16AddS => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let c = match pop(stack) {
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5828 |       let b = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5832 |       let a = match pop(stack) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(t) => t
     |         Err(t) => return Err(t)
     |       }
5836 |       stack.push(
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::v128_ternary(
     |           V128TernaryOp::i32x4_relaxed_dot_i8x16i7x16_add_s(),
     |           a,
     |           b,
     |           c,
     |         ),
     |       )
     |     }
     |   }
     |   Ok(())
     | }
     …

77 uncovered line(s) in src/validate/gen_valid.mbt:

     | fn GenValidContext::random_int(self : GenValidContext, max : Int) -> Int {
     |   if max <= 0 {
 176 |     return 0
     |     ^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.rnd.next_positive_int() % max
     | }
     …

     | fn GenValidContext::get_callable_funcs(
     |   self : GenValidContext,
     | ) -> Array[(Int, ResultType, ResultType)] {
     |   let result : Array[(Int, ResultType, ResultType)] = []
     |   for t in self.func_sigs.iter() {
     |     let (func_idx, sig_idx) = t
     |     match self.sigs.get(sig_idx) {
     |       Some((accepts, returns)) => result.push((func_idx, accepts, returns))
 250 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   result
     | }
     …

     | pub fn gen_valid_numtype(ctx : GenValidContext) -> NumType {
 275 |   match ctx.random_int(4) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     0 => NumType::i32()
     |     1 => NumType::i64()
     |     2 => NumType::f32()
     |     _ => NumType::f64()
     |   }
     | }
     …

     | fn gen_table_set_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.table_count == 0 {
 300 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let idx = gen_i32_tinstr_simple(ctx)
     |   let func_ref = if ctx.func_idx > 0 && ctx.random_bool() {
     |     TInstr::ref_func(
     |       FuncIdx::new(ctx.random_int(ctx.func_idx).reinterpret_as_uint()),
     |     )
     |   } else {
     |     TInstr::ref_null(HeapType::abs(AbsHeapType::func()))
     |   }
     |   Some(TInstr::table_set(TableIdx::new(0), idx, func_ref))
     | }
     …

     | fn gen_table_size_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.table_count == 0 {
 317 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Some(TInstr::table_size(TableIdx::new(0)))
     | }
     …

     | fn gen_table_grow_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.table_count == 0 {
 326 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let init_val = TInstr::ref_null(HeapType::abs(AbsHeapType::func()))
     |   let delta = TInstr::i32_const(I32(ctx.random_int(5) + 1))
     |   Some(TInstr::table_grow(TableIdx::new(0), init_val, delta))
     | }
     …

     | fn gen_const_expr(ctx : GenValidContext, vt : ValType) -> Expr {
     |   match vt {
     |     NumTypeValType(I32NumType) =>
     |       Expr::new([Instruction::i32_const(I32(ctx.random_int(100)))])
     |     NumTypeValType(I64NumType) =>
     |       Expr::new([Instruction::i64_const(I64(ctx.random_int(100).to_int64()))])
     |     NumTypeValType(F32NumType) => Expr::new([Instruction::f32_const(F32(1.0))])
     |     NumTypeValType(F64NumType) =>
     |       Expr::new([Instruction::f64_const(F64(ctx.random_int(100).to_double()))])
     |     VecTypeValType =>
 353 |       Expr::new([
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         Instruction::v128_const(
     |           b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
     |           b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
     |         ),
     |       ])
 359 |     RefTypeValType(rt) => Expr::new([Instruction::ref_null(rt.get_heap_type())])
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BotValType => Expr::new([Instruction::unreachable_()])
     |   }
     | }
     …

     | pub fn gen_valid_result_type(
     |   ctx : GenValidContext,
     |   base : ResultType,
     |   strategy : TypeGenerationStrategy,
     | ) -> ResultType {
 370 |   match strategy {
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Exact => base
     |     AtLeast => {
     |       let extra = ctx.random_int(3)
     |       let result = base.copy()
     |       for _ in 0..<extra {
 376 |         result.push(gen_valid_valtype(ctx))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       result
     |     }
 380 |     AtMost => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       if base.length() == 0 {
 382 |         return []
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |       }
 384 |       let keep = ctx.random_int(base.length() + 1)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       base[0:keep].to_array()
     |     }
     |   }
     | }
     …

     | fn gen_call_indirect_tinstr(
     |   ctx : GenValidContext,
     |   target_return : ValType,
     | ) -> TInstr? {
     |   if ctx.table_count == 0 {
 418 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Find a signature that returns exactly the target type (single return only)
     |   let matching_sigs : Array[(Int, ResultType, ResultType)] = []
     |   for sig_idx, sig in ctx.sigs {
     |     let (accepts, returns) = sig
     |     // Only single-return functions to avoid multi-value issues
     |     if returns.length() == 1 && returns[0] == target_return {
     |       matching_sigs.push((sig_idx, accepts, returns))
     |     }
     |   }
     |   if matching_sigs.length() == 0 {
     |     return None
     |   }
     |   let (sig_idx, accepts, _) = matching_sigs[ctx.random_int(
     |       matching_sigs.length(),
     |     )]
     |   let args : Array[TInstr] = []
     |   for param_type in accepts {
     |     args.push(gen_tinstr_of_type(ctx, param_type))
     |   }
     | 
     |   // Table index (i32 on stack)
     |   let table_idx_val = gen_i32_tinstr_simple(ctx)
     |   Some(
     |     TInstr::call_indirect(
     |       TypeIdx::new(sig_idx.reinterpret_as_uint()),
     |       TableIdx::new(0),
     |       args,
     |       table_idx_val,
     |     ),
     |   )
     | }
     …

     | fn gen_struct_new_tinstr(ctx : GenValidContext) -> TInstr? {
 456 |   if ctx.struct_types.length() == 0 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return None
     |   }
 459 |   let (type_idx, fields) = ctx.struct_types[ctx.random_int(
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ctx.struct_types.length(),
     |     )]
     |   let field_values : Array[TInstr] = []
     |   for field in fields {
 464 |     let vt = storage_type_to_valtype(field.get_storage_type()) // Fixed
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     field_values.push(gen_tinstr_of_type(ctx, vt))
     |   }
     |   Some(
 468 |     TInstr::struct_new(
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       TypeIdx::new(type_idx.reinterpret_as_uint()),
     |       field_values,
     |     ),
     |   )
     | }
     …

     | fn gen_call_side_effect(ctx : GenValidContext) -> TInstr? {
     |   let callables = ctx.get_callable_funcs()
     |   if callables.length() == 0 {
 628 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Filter to functions with 0 or 1 return values (avoid multi-value complexity)
     |   let usable_funcs = callables.filter(fn(c) { c.2.length() <= 1 })
     | 
     |   // Prefer void functions
     |   let void_funcs = usable_funcs.filter(fn(c) { c.2.length() == 0 })
     |   if void_funcs.length() > 0 {
     |     let (func_idx, accepts, _) = void_funcs[ctx.random_int(void_funcs.length())]
     |     let args : Array[TInstr] = []
     |     for param_type in accepts {
     |       args.push(gen_tinstr_of_type(ctx, param_type))
     |     }
     |     return Some(
     |       TInstr::call(FuncIdx::new(func_idx.reinterpret_as_uint()), args),
     |     )
     |   }
     |   if usable_funcs.length() == 0 {
 647 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Call single-return function and drop result
 651 |   let (func_idx, accepts, _) = usable_funcs[ctx.random_int(
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       usable_funcs.length(),
     |     )]
     |   let args : Array[TInstr] = []
     |   for param_type in accepts {
 656 |     args.push(gen_tinstr_of_type(ctx, param_type))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 658 |   let call = TInstr::call(FuncIdx::new(func_idx.reinterpret_as_uint()), args)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   Some(TInstr::drop(call))
     | }
     …

     | fn gen_table_get_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.table_count == 0 {
 803 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let idx = gen_i32_tinstr_simple(ctx)
     |   Some(TInstr::table_get(TableIdx::new(0), idx))
     | }
     …

     | fn gen_memory_init_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.mem_count == 0 || ctx.data_idx == 0 {
 813 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Find a passive data segment
     |   for i, mode in ctx.data_modes {
     |     match mode {
     |       Passive => {
     |         let dest = gen_i32_tinstr_simple(ctx)
     |         let src_offset = TInstr::i32_const(I32(0))
     |         let size = TInstr::i32_const(I32(ctx.random_int(16) + 1))
     |         return Some(
     |           TInstr::memory_init(
     |             DataIdx::new(i.reinterpret_as_uint()),
     |             MemIdx::new(0),
     |             dest,
     |             src_offset,
     |             size,
     |           ),
     |         )
     |       }
     |       _ => continue
     |     }
     |   }
     |   None
     | }
     …

     | fn gen_memory_copy_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.mem_count == 0 {
 843 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let dest = gen_i32_tinstr_simple(ctx)
     |   let src = gen_i32_tinstr_simple(ctx)
     |   let size = TInstr::i32_const(I32(ctx.random_int(64) + 1))
     |   Some(TInstr::memory_copy(MemIdx::new(0), MemIdx::new(0), dest, src, size))
     | }
     …

     | fn gen_memory_fill_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.mem_count == 0 {
 855 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let dest = gen_i32_tinstr_simple(ctx)
     |   let value = gen_i32_tinstr_simple(ctx)
     |   let size = TInstr::i32_const(I32(ctx.random_int(64) + 1))
     |   Some(TInstr::memory_fill(MemIdx::new(0), dest, value, size))
     | }
     …

     | fn gen_array_copy_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.array_types.length() == 0 {
 897 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Find two compatible array types (same element type)
     |   for i in 0..<ctx.array_types.length() {
     |     let (type_idx_dst, elem_type_dst) = ctx.array_types[i]
     |     if not(elem_type_dst.is_mutable()) {
     |       continue
     |     }
     |     for j in 0..<ctx.array_types.length() {
     |       let (type_idx_src, elem_type_src) = ctx.array_types[j]
     |       if elem_type_dst.get_storage_type() == elem_type_src.get_storage_type() {
     |         let elem_vt = storage_type_to_valtype(elem_type_dst.get_storage_type())
     | 
     |         // Create destination array
     |         let dst_init = gen_tinstr_of_type(ctx, elem_vt)
     |         let dst = TInstr::array_new(
     |           TypeIdx::new(type_idx_dst.reinterpret_as_uint()),
     |           dst_init,
     |           TInstr::i32_const(I32(10)),
     |         )
     | 
     |         // Create source array
     |         let src_init = gen_tinstr_of_type(ctx, elem_vt)
     |         let src = TInstr::array_new(
     |           TypeIdx::new(type_idx_src.reinterpret_as_uint()),
     |           src_init,
     |           TInstr::i32_const(I32(10)),
     |         )
     |         let dst_offset = TInstr::i32_const(I32(ctx.random_int(5)))
     |         let src_offset = TInstr::i32_const(I32(ctx.random_int(5)))
     |         let length = TInstr::i32_const(I32(ctx.random_int(3) + 1))
     |         return Some(
     |           TInstr::array_copy(
     |             TypeIdx::new(type_idx_dst.reinterpret_as_uint()),
     |             TypeIdx::new(type_idx_src.reinterpret_as_uint()),
     |             dst,
     |             dst_offset,
     |             src,
     |             src_offset,
     |             length,
     |           ),
     |         )
     |       }
     |     }
     |   }
     |   None
     | }
     …

     | fn gen_ref_test_tinstr(ctx : GenValidContext) -> TInstr? {
     |   let ref_val = match gen_known_ref_value(ctx) {
 958 |     Some(v) => v
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => return None
     |   }
     |   let test_heap_type = if ctx.random_bool() {
 962 |     HeapType::abs(AbsHeapType::struct_())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   } else {
 964 |     HeapType::abs(AbsHeapType::array())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
 966 |   Some(TInstr::ref_test(false, test_heap_type, ref_val))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn gen_v128_tinstr(ctx : GenValidContext) -> TInstr {
 971 |   if ctx.random_bool() {
     |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TInstr::v128_const(
     |       b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
     |       b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
     |     )
     |   } else {
 977 |     TInstr::i32x4_splat(gen_i32_tinstr_simple(ctx))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn gen_ref_tinstr(ctx : GenValidContext, rt : RefType) -> TInstr {
 983 |   match rt.get_heap_type() {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     AbsHeapTypeHeapType(StructAbsHeapType) =>
 985 |       match gen_struct_new_tinstr(ctx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(instr) => instr
     |         None => TInstr::ref_null(rt.get_heap_type())
     |       }
     |     AbsHeapTypeHeapType(ArrayAbsHeapType) =>
 990 |       match gen_array_new_tinstr(ctx) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(instr) => instr
     |         None => TInstr::ref_null(rt.get_heap_type())
     |       }
     |     AbsHeapTypeHeapType(FuncAbsHeapType) =>
 995 |       if ctx.func_idx > 0 && ctx.random_bool() {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         TInstr::ref_func(
     |           FuncIdx::new(ctx.random_int(ctx.func_idx).reinterpret_as_uint()),
     |         )
     |       } else {
1000 |         TInstr::ref_null(rt.get_heap_type())
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
1002 |     _ => TInstr::ref_null(rt.get_heap_type())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn is_abs_heaptype_subtype(sub : AbsHeapType, sup : AbsHeapType) -> Bool {
1024 |   if sub == sup {
     |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return true
     |   }
1027 |   match (sub, sup) {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     // func <: func, nofunc <: func
1029 |     (NoFuncAbsHeapType, FuncAbsHeapType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     // extern <: extern, noextern <: extern
1031 |     (NoExternAbsHeapType, ExternAbsHeapType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     // i31, struct, array, none <: eq <: any
1033 |     (I31AbsHeapType, EqAbsHeapType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (I31AbsHeapType, AnyAbsHeapType) => true
     |     (StructAbsHeapType, EqAbsHeapType) => true
     |     (StructAbsHeapType, AnyAbsHeapType) => true
     |     (ArrayAbsHeapType, EqAbsHeapType) => true
     |     (ArrayAbsHeapType, AnyAbsHeapType) => true
     |     (NoneAbsHeapType, EqAbsHeapType) => true
     |     (NoneAbsHeapType, AnyAbsHeapType) => true
     |     (NoneAbsHeapType, I31AbsHeapType) => true
     |     (NoneAbsHeapType, StructAbsHeapType) => true
     |     (NoneAbsHeapType, ArrayAbsHeapType) => true
     |     (EqAbsHeapType, AnyAbsHeapType) => true
     |     _ => false
     |   }
     | }
     …

     | fn GenValidContext::find_callable_returning(
     |   self : GenValidContext,
     |   target : ResultType,
     |   strategy : TypeGenerationStrategy,
     | ) -> Array[(Int, ResultType, ResultType)] {
     |   let result : Array[(Int, ResultType, ResultType)] = []
     |   for func_idx, sig_idx in self.func_sigs {
     |     match self.sigs.get(sig_idx) {
     |       Some((accepts, returns)) => {
     |         let compatible = match strategy {
     |           Exact =>
     |             is_result_subtype(returns, target) &&
     |             returns.length() == target.length()
     |           AtLeast =>
     |             // Returns at least target types (can have more)
1066 |             if returns.length() < target.length() {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               false
     |             } else {
1069 |               let mut ok = true
     |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               for i in 0..<target.length() {
1071 |                 if not(is_valtype_subtype(returns[i], target[i])) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   ok = false
     |                   break
     |                 }
     |               }
     |               ok
     |             }
     |           AtMost =>
     |             // Returns at most target types (can have fewer)
1080 |             if returns.length() > target.length() {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               false
     |             } else {
1083 |               let mut ok = true
     |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               for i in 0..<returns.length() {
1085 |                 if not(is_valtype_subtype(returns[i], target[i])) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   ok = false
     |                   break
     |                 }
     |               }
     |               ok
     |             }
     |         }
     |         if compatible {
     |           result.push((func_idx, accepts, returns))
     |         }
     |       }
1097 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   result
     | }
     …

     | fn is_heaptype_subtype(sub : HeapType, sup : HeapType) -> Bool {
1106 |   match (sub, sup) {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (AbsHeapTypeHeapType(a), AbsHeapTypeHeapType(b)) =>
1108 |       is_abs_heaptype_subtype(a, b)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (HeapType(a), HeapType(b)) => a == b // Simplified: exact match only
     |     (HeapType(_), AbsHeapTypeHeapType(AnyAbsHeapType)) => true
     |     (HeapType(_), AbsHeapTypeHeapType(EqAbsHeapType)) => true
     |     _ => sub == sup
     |   }
     | }
     …

     | fn is_reftype_subtype(sub : RefType, sup : RefType) -> Bool {
     |   // If sup is nullable and sub is not, that's fine
     |   // If sup is not nullable and sub is nullable, that's not fine
1121 |   if not(sup.is_nullable()) && sub.is_nullable() {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return false
     |   }
1124 |   is_heaptype_subtype(sub.get_heap_type(), sup.get_heap_type())
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn is_valtype_subtype(sub : ValType, sup : ValType) -> Bool {
     |   match (sub, sup) {
     |     (NumTypeValType(a), NumTypeValType(b)) => a == b
1132 |     (VecTypeValType, VecTypeValType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (RefTypeValType(sub_rt), RefTypeValType(sup_rt)) =>
1134 |       is_reftype_subtype(sub_rt, sup_rt)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (BotValType, _) => true // bot is subtype of everything
     |     _ => sub == sup
     |   }
     | }
     …

     | fn gen_array_set_tinstr(ctx : GenValidContext) -> TInstr? {
     |   for t in ctx.array_types {
     |     let (type_idx, elem_type) = t
     |     if elem_type.is_mutable() {
     |       let elem_vt = storage_type_to_valtype(elem_type.get_storage_type())
     |       let init_val = match elem_vt {
1182 |         RefTypeValType(rt) => gen_ref_tinstr(ctx, rt)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => gen_tinstr_of_type(ctx, elem_vt)
     |       }
     |       let array = TInstr::array_new(
     |         TypeIdx::new(type_idx.reinterpret_as_uint()),
     |         init_val,
     |         TInstr::i32_const(I32(5)),
     |       )
     |       let index = TInstr::i32_const(I32(ctx.random_int(5)))
     |       let new_value = gen_tinstr_of_type(ctx, elem_vt)
     |       return Some(
     |         TInstr::array_set(
     |           TypeIdx::new(type_idx.reinterpret_as_uint()),
     |           array,
     |           index,
     |           new_value,
     |         ),
     |       )
     |     }
     |   }
     |   None
     | }
     …

     | fn gen_default_value(ctx : GenValidContext, vt : ValType) -> TInstr {
     |   match vt {
     |     NumTypeValType(I32NumType) => TInstr::i32_const(I32(ctx.random_int(100)))
     |     NumTypeValType(I64NumType) =>
     |       TInstr::i64_const(I64(ctx.random_int(100).to_int64()))
     |     NumTypeValType(F32NumType) =>
     |       TInstr::f32_const(
     |         F32(Float::from_double(ctx.random_int(100).to_double())),
     |       )
     |     NumTypeValType(F64NumType) =>
     |       TInstr::f64_const(F64(ctx.random_int(100).to_double()))
     |     VecTypeValType =>
1268 |       TInstr::v128_const(
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
     |         b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
     |       )
1272 |     RefTypeValType(rt) => TInstr::ref_null(rt.get_heap_type())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     BotValType => TInstr::unreachable_()
     |   }
     | }
     …

     | fn gen_elem_segments(ctx : GenValidContext) -> Array[Elem] {
     |   let segments : Array[Elem] = []
     |   if ctx.func_idx == 0 {
1310 |     return segments
     |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let num_segments = ctx.random_int(2) + 1
     |   for _ in 0..<num_segments {
     |     // Generate funcref expressions
     |     let num_refs = ctx.random_int(5) + 1
     |     let init_exprs : Array[Expr] = []
     |     for _ in 0..<num_refs {
     |       let func_idx = ctx.random_int(ctx.func_idx)
     |       init_exprs.push(
     |         Expr::new([
     |           Instruction::ref_func(FuncIdx::new(func_idx.reinterpret_as_uint())),
     |         ]),
     |       )
     |     }
     |     let ref_type = RefType::new(true, HeapType::abs(AbsHeapType::func()))
     |     if ctx.table_count > 0 && ctx.random_bool() {
     |       // Active elem segment
     |       let offset = Expr::new([Instruction::i32_const(I32(ctx.random_int(10)))])
     |       let mode = ElemMode::active(TableIdx::new(0), offset)
     |       let kind = ElemKind::typed_exprs(ref_type, init_exprs)
     |       ignore(ctx.add_elem_segment(mode))
     |       // ref_type, init_exprs, mode
     |       segments.push(Elem::new(mode, kind))
     |     } else if ctx.random_bool() {
     |       // Declarative elem segment
     |       let mode = ElemMode::declarative()
     |       let kind = ElemKind::typed_exprs(ref_type, init_exprs)
     |       ignore(ctx.add_elem_segment(mode))
     |       segments.push(Elem::new(mode, kind))
     |     } else {
     |       // Passive elem segment
     |       let mode = ElemMode::passive()
     |       let kind = ElemKind::typed_exprs(ref_type, init_exprs)
     |       ignore(ctx.add_elem_segment(mode))
     |       segments.push(Elem::new(mode, kind))
     |     }
     |   }
     |   segments
     | }
     …

     | fn gen_throw_tinstr(ctx : GenValidContext) -> TInstr? {
     |   if ctx.tag_idx == 0 {
1387 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let tag_idx_val = ctx.random_int(ctx.tag_idx)
     |   let (_, params) = ctx.tag_sigs[tag_idx_val]
     |   let args : Array[TInstr] = []
     |   for param_type in params {
     |     args.push(gen_tinstr_of_type(ctx, param_type))
     |   }
     |   Some(TInstr::throw_(TagIdx::new(tag_idx_val.reinterpret_as_uint()), args))
     | }
     …

     | fn gen_try_table_tinstr(ctx : GenValidContext) -> TInstr? {
     |   // Must have tags
     |   if ctx.tag_idx == 0 {
1402 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Must have an enclosing label (label 1)
     |   if ctx.label_stack.length() <= 1 {
     |     return None
     |   }
     |   let enclosing = ctx.label_stack[1]
     | 
     |   // Enclosing label must be catchable and void
     |   if !enclosing.catchable || enclosing.result.length() != 0 {
     |     return None
     |   }
     | 
     |   // Only allow EMPTY payload tags
     |   let empty_tags : Array[Int] = []
     |   for tag_i in 0..<ctx.tag_idx {
     |     let (_, params) = ctx.tag_sigs[tag_i]
     |     if params.length() == 0 {
     |       empty_tags.push(tag_i)
     |     }
     |   }
     |   if empty_tags.length() == 0 {
     |     return None
     |   }
     |   let tag_idx_val = empty_tags[ctx.random_int(empty_tags.length())]
     | 
     |   // try body
     |   ctx.push_label([], false)
     |   let body_instrs : Array[TInstr] = [
     |     TInstr::throw_(TagIdx::new(tag_idx_val.reinterpret_as_uint()), []),
     |   ]
     |   if ctx.random_bool() {
     |     body_instrs.push(gen_simple_side_effect(ctx))
     |   }
     |   ctx.pop_label()
     |   Some(
     |     TInstr::try_table(
     |       BlockType::void_(),
     |       [
     |         Catch::new(
     |           TagIdx::new(tag_idx_val.reinterpret_as_uint()),
     |           LabelIdx::new(1U),
     |         ),
     |       ],
     |       TExpr::new(body_instrs),
     |     ),
     |   )
     | }
     …

     | fn gen_load_tinstr(ctx : GenValidContext, target_type : ValType) -> TInstr? {
     |   if ctx.mem_count == 0 {
1471 |     return None
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let addr = gen_i32_tinstr_simple(ctx)
     |   let mem_arg = MemArg::new(U32(0), None, U64(0))
     |   match target_type {
     |     NumTypeValType(I32NumType) =>
     |       Some(TInstr::load(LoadOp::i32_load(), mem_arg, addr))
     |     NumTypeValType(I64NumType) =>
     |       Some(TInstr::load(LoadOp::i64_load(), mem_arg, addr))
     |     NumTypeValType(F32NumType) =>
     |       Some(TInstr::load(LoadOp::f32_load(), mem_arg, addr))
     |     NumTypeValType(F64NumType) =>
     |       Some(TInstr::load(LoadOp::f64_load(), mem_arg, addr))
1484 |     _ => None
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn gen_tinstr_of_type(ctx : GenValidContext, vt : ValType) -> TInstr {
     |   // Sometimes use a local if available
     |   if ctx.random_int(6) == 0 {
     |     for i, local_type in ctx.locals {
     |       if local_type == vt {
     |         return TInstr::local_get(LocalIdx::new(i.reinterpret_as_uint()))
     |       }
     |     }
     |   }
     | 
     |   // Sometimes use a global
     |   if ctx.random_int(6) == 0 {
     |     match gen_global_get_tinstr(ctx, vt) {
     |       Some(instr) => return instr
     |       None => ()
     |     }
     |   }
     | 
     |   // Sometimes use a memory load
     |   if ctx.random_int(8) == 0 {
     |     match gen_load_tinstr(ctx, vt) {
     |       Some(instr) => return instr
1512 |       None => ()
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     | 
     |   // Sometimes try to generate a call with subtyping
     |   if ctx.random_int(8) == 0 {
     |     let strategy = match ctx.random_int(3) {
     |       0 => Exact
     |       1 => AtLeast
     |       _ => AtMost
     |     }
     |     match gen_call_tinstr_v2(ctx, [vt], strategy) {
     |       Some(call) => return call
     |       None => ()
     |     }
     |   }
     | 
     |   // Sometimes try call_indirect
     |   if ctx.random_int(12) == 0 {
     |     match gen_call_indirect_tinstr(ctx, vt) {
     |       Some(call) => return call
     |       None => ()
     |     }
     |   }
     | 
     |   // Sometimes try struct.get
     |   if ctx.random_int(10) == 0 {
     |     match gen_struct_get_tinstr(ctx, vt) {
     |       Some(instr) => return instr
     |       None => ()
     |     }
     |   }
     | 
     |   // Sometimes try array.get
     |   if ctx.random_int(10) == 0 {
     |     match gen_array_get_tinstr(ctx, vt) {
     |       Some(instr) => return instr
     |       None => ()
     |     }
     |   }
     | 
     |   // For i32, try additional sources
     |   match vt {
     |     NumTypeValType(I32NumType) => {
     |       if ctx.random_int(15) == 0 {
     |         match gen_ref_test_tinstr(ctx) {
1558 |           Some(instr) => return instr
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => ()
     |         }
     |       }
     |       if ctx.random_int(15) == 0 {
     |         match gen_array_len_tinstr(ctx) {
     |           Some(instr) => return instr
     |           None => ()
     |         }
     |       }
     |       if ctx.random_int(15) == 0 {
     |         match gen_table_size_tinstr(ctx) {
     |           Some(instr) => return instr
1571 |           None => ()
     |           ^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       gen_i32_tinstr(ctx)
     |     }
     |     NumTypeValType(I64NumType) => gen_i64_tinstr(ctx)
     |     NumTypeValType(F32NumType) => gen_f32_tinstr(ctx)
     |     NumTypeValType(F64NumType) => gen_f64_tinstr(ctx)
1579 |     VecTypeValType => gen_v128_tinstr(ctx)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefTypeValType(rt) => gen_ref_tinstr(ctx, rt)
     |     BotValType => TInstr::unreachable_()
     |   }
     | }
     …

     | fn gen_known_ref_value(ctx : GenValidContext) -> TInstr? {
     |   // locals
     |   for i, vt in ctx.locals {
     |     match vt {
     |       RefTypeValType(_) =>
1591 |         if ctx.random_bool() {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Some(TInstr::local_get(LocalIdx::new(i.reinterpret_as_uint())))
     |         }
     |       _ => ()
     |     }
     |   }
     | 
     |   // globals
     |   for i, gt in ctx.globals {
     |     let GlobalType(vt, _) = gt
     |     match vt {
     |       RefTypeValType(_) =>
1603 |         if ctx.random_bool() {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Some(
     |             TInstr::global_get(GlobalIdx::new(i.reinterpret_as_uint())),
     |           )
     |         }
     |       _ => ()
     |     }
     |   }
     | 
     |   // fallback
     |   None
     | }
     …

     | pub fn gen_side_effect_tinstr(
     |   ctx : GenValidContext,
     |   depth : Int,
     |   label_depth? : Int = 0,
     | ) -> TInstr {
     |   if depth > 3 {
     |     return gen_simple_side_effect(ctx)
     |   }
     |   let has_mem = ctx.mem_count > 0
     |   let has_table = ctx.table_count > 0
     |   let has_callables = ctx.get_callable_funcs().length() > 0
     |   let has_structs = ctx.struct_types.length() > 0
     |   let has_arrays = ctx.array_types.length() > 0
     |   let has_data = ctx.data_idx > 0
     |   let has_elem = ctx.elem_idx > 0
     |   let has_tags = ctx.tag_idx > 0
     |   let has_globals = ctx.globals.length() > 0
     |   let has_labels = ctx.label_count() > 0
     |   let has_passive_data = ctx.data_modes
     |     .iter()
     |     .any(fn(m) {
     |       match m {
     |         Passive => true
     |         _ => false
     |       }
     |     })
     |   let ops : Array[() -> TInstr?] = []
     | 
     |   // ------------------------------------------------------------
     |   // Basic side effects
     |   // ------------------------------------------------------------
     |   ops.push(fn() {
     |     if ctx.locals.length() > 0 {
     |       let idx = ctx.random_int(ctx.locals.length())
     |       let vt = ctx.locals[idx]
     |       Some(
     |         TInstr::local_set(
     |           LocalIdx::new(idx.reinterpret_as_uint()),
     |           gen_tinstr_of_type(ctx, vt),
     |         ),
     |       )
     |     } else {
1660 |       Some(TInstr::drop(gen_tinstr_of_type(ctx, gen_valid_valtype(ctx))))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   })
     |   ops.push(fn() {
     |     Some(TInstr::drop(gen_tinstr_of_type(ctx, gen_valid_valtype(ctx))))
     |   })
     | 
     |   // ------------------------------------------------------------
     |   // Block
     |   // ------------------------------------------------------------
     |   ops.push(fn() {
     |     ctx.push_label([], true)
     |     let n = ctx.random_int(3) + 1
     |     let instrs : Array[TInstr] = []
     |     for _ in 0..<n {
     |       instrs.push(gen_side_effect_tinstr(ctx, depth + 1))
     |     }
     |     ctx.pop_label()
     |     Some(TInstr::block(BlockType::void_(), TExpr::new(instrs)))
     |   })
     | 
     |   // ------------------------------------------------------------
     |   // Loop
     |   // ------------------------------------------------------------
     |   ops.push(fn() {
     |     ctx.push_label([], true)
     |     let n = ctx.random_int(2) + 1
     |     let instrs : Array[TInstr] = []
     |     for _ in 0..<n {
     |       instrs.push(
     |         gen_side_effect_tinstr(ctx, depth + 1, label_depth=label_depth + 1),
     |       )
     |     }
     |     ctx.pop_label()
     |     Some(TInstr::loop_(BlockType::void_(), TExpr::new(instrs)))
     |   })
     | 
     |   // ------------------------------------------------------------
     |   // If
     |   // ------------------------------------------------------------
     |   ops.push(fn() {
     |     let cond = gen_i32_tinstr_simple(ctx)
     |     ctx.push_label([], true)
     |     let then_instrs : Array[TInstr] = []
     |     for _ in 0..<(ctx.random_int(2) + 1) {
     |       then_instrs.push(gen_side_effect_tinstr(ctx, depth + 1))
     |     }
     |     let else_branch = if ctx.random_bool() {
     |       let else_instrs : Array[TInstr] = []
     |       for _ in 0..<(ctx.random_int(2) + 1) {
     |         else_instrs.push(gen_side_effect_tinstr(ctx, depth + 1))
     |       }
     |       Some(TExpr::new(else_instrs))
     |     } else {
     |       None
     |     }
     |     ctx.pop_label()
     |     Some(
     |       TInstr::if_(
     |         BlockType::void_(),
     |         cond,
     |         TExpr::new(then_instrs),
     |         else_branch,
     |       ),
     |     )
     |   })
     | 
     |   // ------------------------------------------------------------
     |   // Branches
     |   // ------------------------------------------------------------
     |   if has_labels {
     |     ops.push(fn() { gen_br_if_tinstr(ctx) })
     |     ops.push(fn() { gen_br_table_tinstr(ctx) })
     |   }
     | 
     |   // ------------------------------------------------------------
     |   // Globals
     |   // ------------------------------------------------------------
     |   if has_globals {
     |     ops.push(fn() {
     |       let muts : Array[(Int, ValType)] = []
     |       for i, gt in ctx.globals {
     |         let GlobalType(vt, mut_) = gt
     |         if mut_ {
     |           muts.push((i, vt))
     |         }
     |       }
     |       if muts.length() == 0 {
1748 |         return None
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let (i, vt) = muts[ctx.random_int(muts.length())]
     |       Some(
     |         TInstr::global_set(
     |           GlobalIdx::new(i.reinterpret_as_uint()),
     |           gen_tinstr_of_type(ctx, vt),
     |         ),
     |       )
     |     })
     |     ops.push(fn() {
     |       let i = ctx.random_int(ctx.globals.length())
     |       Some(
     |         TInstr::drop(
     |           TInstr::global_get(GlobalIdx::new(i.reinterpret_as_uint())),
     |         ),
     |       )
     |     })
     |   }
     | 
     |   // ------------------------------------------------------------
     |   // Memory
     |   // ------------------------------------------------------------
     |   if has_mem {
     |     ops.push(fn() { Some(gen_store_tinstr(ctx)) })
     |     ops.push(fn() { gen_memory_fill_tinstr(ctx) })
     |     ops.push(fn() { gen_memory_copy_tinstr(ctx) })
     |     ops.push(fn() { Some(TInstr::drop(TInstr::memory_size(MemIdx::new(0)))) })
     |     ops.push(fn() {
     |       Some(
     |         TInstr::drop(
     |           TInstr::memory_grow(MemIdx::new(0), gen_i32_tinstr_simple(ctx)),
     |         ),
     |       )
     |     })
     |   }
     |   if has_mem && has_passive_data {
     |     ops.push(fn() { gen_memory_init_tinstr(ctx) })
     |   }
     | 
     |   // ------------------------------------------------------------
     |   // Table
     |   // ------------------------------------------------------------
     |   if has_table {
     |     ops.push(fn() { gen_table_set_tinstr(ctx) })
     |     ops.push(fn() {
     |       Some(
     |         TInstr::drop(
     |           gen_table_grow_tinstr(ctx).unwrap_or(TInstr::i32_const(I32(0))),
     |         ),
     |       )
     |     })
     |     ops.push(fn() {
     |       match gen_table_get_tinstr(ctx) {
     |         Some(x) => Some(TInstr::drop(x))
1803 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |     ops.push(fn() {
     |       match gen_table_size_tinstr(ctx) {
     |         Some(x) => Some(TInstr::drop(x))
1809 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     |   }
     | 
     |   // ------------------------------------------------------------
     |   // Calls / GC / Segments
     |   // ------------------------------------------------------------
     |   if has_callables {
     |     ops.push(fn() { gen_call_side_effect(ctx) })
     |   }
     |   if has_structs {
     |     ops.push(fn() { gen_struct_set_tinstr(ctx) })
     |   }
     |   if has_arrays {
     |     ops.push(fn() { gen_array_set_tinstr(ctx) })
     |     ops.push(fn() { gen_array_fill_tinstr(ctx) })
     |     ops.push(fn() { gen_array_copy_tinstr(ctx) })
     |   }
     |   if has_data {
     |     ops.push(fn() {
     |       Some(
     |         TInstr::data_drop(
     |           DataIdx::new(ctx.random_int(ctx.data_idx).reinterpret_as_uint()),
     |         ),
     |       )
     |     })
     |   }
     |   if has_elem {
     |     ops.push(fn() {
     |       Some(
     |         TInstr::elem_drop(
     |           ElemIdx::new(ctx.random_int(ctx.elem_idx).reinterpret_as_uint()),
     |         ),
     |       )
     |     })
     |   }
     | 
     |   // ------------------------------------------------------------
     |   // Exception handling (FINAL, SAFE)
     |   // ------------------------------------------------------------
     |   if has_tags {
     |     // Wrapper try_table ONLY for empty-payload tags
     |     ops.push(fn() {
     |       if ctx.label_stack.length() <= 1 {
     |         return None
     |       }
     |       let enclosing = ctx.label_stack[1]
     |       if !enclosing.catchable || enclosing.result.length() != 0 {
     |         return None
     |       }
     |       let empty_tags : Array[Int] = []
     |       for tag_i in 0..<ctx.tag_idx {
     |         let (_, params) = ctx.tag_sigs[tag_i]
     |         if params.length() == 0 {
     |           empty_tags.push(tag_i)
     |         }
     |       }
     |       if empty_tags.length() == 0 {
     |         return None
     |       }
     |       let tag_idx_val = empty_tags[ctx.random_int(empty_tags.length())]
     |       match gen_throw_tinstr(ctx) {
     |         Some(throw_instr) =>
     |           Some(
     |             TInstr::try_table(
     |               BlockType::void_(),
     |               [
     |                 Catch::new(
     |                   TagIdx::new(tag_idx_val.reinterpret_as_uint()),
     |                   LabelIdx::new(1U),
     |                 ),
     |               ],
     |               TExpr::new([throw_instr]),
     |             ),
     |           )
1885 |         None => None
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     })
     | 
     |     // Structured try_table
     |     ops.push(fn() { gen_try_table_tinstr(ctx) })
     |   }
     | 
     |   // ------------------------------------------------------------
     |   // Pick an operation
     |   // ------------------------------------------------------------
     |   for _ in 0..<5 {
     |     let op = ops[ctx.random_int(ops.length())]
     |     match op() {
     |       Some(instr) => return instr
     |       None => ()
     |     }
     |   }
     |   TInstr::drop(gen_tinstr_of_type(ctx, gen_valid_valtype(ctx)))
     | }
     …

69 uncovered line(s) in src/validate/invalid_fuzzer.mbt:

    | fn make_funcidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_funcidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : FuncIdx,
    |   ) -> TransformerResult[Unit, FuncIdx] {
    |     let FuncIdx(i) = idx
    |     // Make idempotent: if already large, don't transform again
    |     if i >= target {
 13 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), FuncIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_typeidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_typeidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : TypeIdx,
    |   ) -> TransformerResult[Unit, TypeIdx] {
    |     match idx {
    |       TypeIdx(i) =>
    |         if i >= target {
 31 |           Ok(None)
    |           ^^^^^^^^ 	<-- UNCOVERED
    |         } else {
    |           Ok(Some(((), TypeIdx::new(i + target))))
    |         }
    |       RecIdx(i) =>
 36 |         if i >= target {
    |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Ok(None)
    |         } else {
 39 |           Ok(Some(((), TypeIdx::rec(i + target))))
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |     }
    |   })
    | }
    …

    | fn make_localidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_localidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : LocalIdx,
    |   ) -> TransformerResult[Unit, LocalIdx] {
    |     let LocalIdx(i) = idx
    |     if i >= target {
 55 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), LocalIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_globalidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_globalidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : GlobalIdx,
    |   ) -> TransformerResult[Unit, GlobalIdx] {
    |     let GlobalIdx(i) = idx
    |     if i >= target {
 72 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), GlobalIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_labelidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_labelidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : LabelIdx,
    |   ) -> TransformerResult[Unit, LabelIdx] {
    |     let LabelIdx(i) = idx
    |     if i >= target {
 89 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), LabelIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_tableidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_tableidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : TableIdx,
    |   ) -> TransformerResult[Unit, TableIdx] {
    |     let TableIdx(i) = idx
    |     if i >= target {
106 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), TableIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_memidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_memidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : MemIdx,
    |   ) -> TransformerResult[Unit, MemIdx] {
    |     let MemIdx(i) = idx
    |     if i >= target {
123 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), MemIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_dataidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_dataidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : DataIdx,
    |   ) -> TransformerResult[Unit, DataIdx] {
    |     let DataIdx(i) = idx
    |     if i >= target {
140 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), DataIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_elemidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_elemidx_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     idx : ElemIdx,
    |   ) -> TransformerResult[Unit, ElemIdx] {
    |     let ElemIdx(i) = idx
    |     if i >= target {
157 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some(((), ElemIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_tagidx_oob_transformer(offset : UInt) -> ModuleTransformer[Bool] {
    |   let target = offset + 0x7FFFFFFF
    |   ModuleTransformer::new().on_tagidx_evt(fn(
    |     _ : ModuleTransformer[Bool],
    |     _ctx : Bool,
    |     idx : TagIdx,
    |   ) -> TransformerResult[Bool, TagIdx] {
    |     let TagIdx(i) = idx
    |     if i >= target {
174 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       Ok(Some((true, TagIdx::new(i + target))))
    |     }
    |   })
    | }
    …

    | fn make_type_corruption_transformer() -> ModuleTransformer[Bool] {
    |   ModuleTransformer::new().on_expr_evt(fn(
    |     _ : ModuleTransformer[Bool],
    |     done : Bool,
    |     expr : Expr,
    |   ) -> TransformerResult[Bool, Expr] {
    |     if done {
    |       return Ok(None)
    |     }
    |     let Expr(instrs) = expr
    |     if instrs.length() == 0 {
194 |       return Ok(None)
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     // Insert i32.const followed by i64.add - guaranteed type error
    |     let new_instrs = [Instruction::i32_const(I32(42)), Instruction::i64_add()]
    |     for i in instrs {
    |       new_instrs.push(i)
    |     }
    |     Ok(Some((true, Expr::new(new_instrs))))
    |   })
    | }
    …

    | fn make_numtype_swap_transformer() -> ModuleTransformer[Unit] {
    |   ModuleTransformer::new().on_valtype_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     vt : ValType,
    |   ) -> TransformerResult[Unit, ValType] {
    |     match vt {
    |       NumTypeValType(I32NumType) => Ok(Some(((), ValType::f64())))
    |       NumTypeValType(I64NumType) => Ok(Some(((), ValType::f32())))
    |       NumTypeValType(F32NumType) => Ok(Some(((), ValType::i64())))
    |       NumTypeValType(F64NumType) => Ok(Some(((), ValType::i32())))
217 |       _ => Ok(None)
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn make_nullability_flip_transformer() -> ModuleTransformer[Unit] {
    |   ModuleTransformer::new()
    |   .on_reftype_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     rt : RefType,
    |   ) -> TransformerResult[Unit, RefType] {
    |     match rt {
    |       // Force all ref types to be non-nullable
    |       HeapTypeRefType(true, ht) => Ok(Some(((), RefType::new(false, ht))))
    |       // Already non-nullable - convert to bottom type to cause more errors
236 |       HeapTypeRefType(false, AbsHeapTypeHeapType(NoneAbsHeapType)) => Ok(None)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       HeapTypeRefType(false, AbsHeapTypeHeapType(NoFuncAbsHeapType)) => Ok(None)
    |       HeapTypeRefType(false, AbsHeapTypeHeapType(NoExternAbsHeapType)) =>
239 |         Ok(None)
    |         ^^^^^^^^ 	<-- UNCOVERED
    |       HeapTypeRefType(false, ht) =>
    |         // Change to bottom type of same hierarchy - very restrictive
242 |         match ht {
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |           AbsHeapTypeHeapType(FuncAbsHeapType)
    |           | AbsHeapTypeHeapType(NoFuncAbsHeapType) =>
245 |             Ok(
    |             ^^^ 	<-- UNCOVERED
    |               Some(
247 |                 ((), RefType::new(false, HeapType::abs(AbsHeapType::no_func()))),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               ),
    |             )
    |           AbsHeapTypeHeapType(ExternAbsHeapType)
    |           | AbsHeapTypeHeapType(NoExternAbsHeapType) =>
252 |             Ok(
    |             ^^^ 	<-- UNCOVERED
    |               Some(
    |                 (
    |                   (),
256 |                   RefType::new(false, HeapType::abs(AbsHeapType::no_extern())),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 ),
    |               ),
    |             )
    |           AbsHeapTypeHeapType(ExnAbsHeapType)
    |           | AbsHeapTypeHeapType(NoExnAbsHeapType) =>
262 |             Ok(
    |             ^^^ 	<-- UNCOVERED
    |               Some(
264 |                 ((), RefType::new(false, HeapType::abs(AbsHeapType::no_exn()))),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               ),
    |             )
    |           _ =>
    |             // For any/eq/struct/array/i31 hierarchy, use none
269 |             Ok(
    |             ^^^ 	<-- UNCOVERED
    |               Some(
271 |                 ((), RefType::new(false, HeapType::abs(AbsHeapType::none()))),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               ),
    |             )
    |         }
    |       AbsHeapTypeRefType(aht) =>
    |         // These shorthands are nullable, make them non-null with explicit form
277 |         Ok(Some(((), RefType::new(false, HeapType::abs(aht)))))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    |   .on_instruction_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     instr : Instruction,
    |   ) -> TransformerResult[Unit, Instruction] {
    |     match instr {
    |       // ref.null produces nullable ref, but if types expect non-null, this fails
    |       // Replace with something that definitely won't typecheck
    |       RefNull(_) => Ok(Some(((), Instruction::i32_const(I32(0))))) // Completely wrong type
    |       RefFunc(_) => Ok(Some(((), Instruction::i64_const(I64(0L))))) // Wrong type for funcref
290 |       RefIsNull => Ok(Some(((), Instruction::i64_const(I64(0L))))) // Expects ref, we removed it
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ => Ok(None)
    |     }
    |   })
    | }
    …

    | fn make_signature_corruption_transformer() -> ModuleTransformer[Unit] {
    |   ModuleTransformer::new().on_comptype_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     ct : CompType,
    |   ) -> TransformerResult[Unit, CompType] {
    |     match ct {
    |       FuncCompType(params, results) => {
    |         // Add extra parameters that callers won't provide
    |         let new_params = params.copy()
    |         new_params.push(ValType::i64())
    |         new_params.push(ValType::f64())
    |         // Change result types
    |         let new_results = results.map(fn(vt) {
    |           match vt {
    |             NumTypeValType(I32NumType) => @lib.ValType::f64()
    |             NumTypeValType(I64NumType) => ValType::f32()
    |             NumTypeValType(F32NumType) => ValType::i64()
    |             NumTypeValType(F64NumType) => ValType::i32()
318 |             other => other
    |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         })
    |         Ok(Some(((), CompType::func(new_params, new_results))))
    |       }
    |       StructCompType(fields) => {
    |         // Change field types
    |         let new_fields = fields.map(fn(ft) {
    |           let FieldType(st, mutability) = ft
    |           match st {
    |             ValTypeStorageType(NumTypeValType(I32NumType)) =>
    |               FieldType::new(StorageType::val_type(ValType::f64()), mutability)
    |             ValTypeStorageType(NumTypeValType(I64NumType)) =>
    |               FieldType::new(StorageType::val_type(ValType::f32()), mutability)
    |             _ => ft
    |           }
    |         })
    |         Ok(Some(((), CompType::struct_(new_fields))))
    |       }
    |       ArrayCompType(FieldType(st, mutability)) => {
    |         let new_st = match st {
    |           ValTypeStorageType(NumTypeValType(I32NumType)) =>
    |             StorageType::val_type(ValType::f64())
    |           ValTypeStorageType(NumTypeValType(I64NumType)) =>
    |             StorageType::val_type(ValType::f32())
    |           _ => st
    |         }
    |         Ok(Some(((), CompType::array(FieldType::new(new_st, mutability)))))
    |       }
    |     }
    |   })
    | }
    …

    | fn make_global_init_mismatch_transformer() -> ModuleTransformer[Unit] {
    |   ModuleTransformer::new().on_global_evt(fn(
    |     _ : ModuleTransformer[Unit],
    |     _ctx : Unit,
    |     g : Global,
    |   ) -> TransformerResult[Unit, Global] {
    |     let Global(GlobalType(vt, mutable), _init) = g
    |     // Create an init expression with wrong type
    |     let wrong_init = match vt {
    |       NumTypeValType(I32NumType) =>
    |         Expr::new([Instruction::f64_const(F64(0.0))])
    |       NumTypeValType(I64NumType) =>
    |         Expr::new([Instruction::f32_const(F32(0.0))])
    |       NumTypeValType(F32NumType) => Expr::new([Instruction::i64_const(I64(0L))])
    |       NumTypeValType(F64NumType) => Expr::new([Instruction::i32_const(I32(0))])
368 |       RefTypeValType(_) => Expr::new([Instruction::i32_const(I32(0))]) // Definitely wrong
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       VecTypeValType => Expr::new([Instruction::i32_const(I32(0))])
    |       BotValType => return Ok(None)
    |     }
    |     Ok(Some(((), Global::new(GlobalType::new(vt, mutable), wrong_init))))
    |   })
    | }
    …

    | fn make_drop_insertion_transformer() -> ModuleTransformer[Bool] {
    |   ModuleTransformer::new().on_expr_evt(fn(
    |     _ : ModuleTransformer[Bool],
    |     done : Bool,
    |     expr : Expr,
    |   ) -> TransformerResult[Bool, Expr] {
    |     if done {
    |       return Ok(None)
    |     }
    |     let Expr(instrs) = expr
    |     if instrs.length() == 0 {
407 |       return Ok(None)
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     // Prepend Drop instructions to cause stack underflow
    |     let new_instrs : Array[Instruction] = [
    |       Instruction::drop(),
    |       Instruction::drop(),
    |       Instruction::drop(),
    |     ]
    |     for i in instrs {
    |       new_instrs.push(i)
    |     }
    |     Ok(Some((true, Expr::new(new_instrs))))
    |   })
    | }
    …

    | fn make_block_corruption_transformer() -> ModuleTransformer[Bool] {
    |   ModuleTransformer::new().on_expr_evt(fn(
    |     _ : ModuleTransformer[Bool],
    |     done : Bool,
    |     expr : Expr,
    |   ) -> TransformerResult[Bool, Expr] {
    |     if done {
    |       return Ok(None)
    |     }
    |     let Expr(instrs) = expr
    |     if instrs.length() > 0 {
    |       Ok(
    |         Some(
    |           (true, Expr::new(instrs.iter().take(instrs.length() - 1).collect())),
    |         ),
    |       )
    |     } else {
441 |       Ok(None)
    |       ^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn corrupt_blocktype(bt : BlockType) -> BlockType {
448 |   match bt {
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     VoidBlockType => BlockType::val_type(ValType::i32())
    |     ValTypeBlockType(NumTypeValType(I32NumType)) =>
451 |       BlockType::val_type(ValType::i64())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ValTypeBlockType(NumTypeValType(I64NumType)) =>
453 |       BlockType::val_type(ValType::i32())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ValTypeBlockType(_) => BlockType::void_()
    |     TypeIdxBlockType(TypeIdx(i)) => BlockType::type_idx(TypeIdx::new(i + 1))
    |     TypeIdxBlockType(RecIdx(i)) => BlockType::type_idx(TypeIdx::rec(i + 1))
    |   }
    | }
    …

    | fn make_blocktype_mismatch_transformer() -> ModuleTransformer[Bool] {
    |   ModuleTransformer::new().on_instruction_evt(fn(
    |     _ : ModuleTransformer[Bool],
    |     done : Bool,
    |     ins : Instruction,
    |   ) -> TransformerResult[Bool, Instruction] {
    |     if done {
    |       return Ok(None)
    |     }
    |     match ins {
    |       // Value-producing instructions: wrap in block claiming no result
    |       // Body produces value, block claims nothing -> mismatch
    |       I32Const(_)
    |       | I64Const(_)
    |       | F32Const(_)
    |       | F64Const(_)
    |       | V128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
479 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some((true, Instruction::block(BlockType::void_(), Expr::new([ins])))),
    |         )
    | 
    |       // Nop/Drop: wrap in block claiming it produces i32
    |       // Body produces nothing, block claims i32 -> mismatch
    |       Nop | Drop =>
486 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some(
    |             (
    |               true,
490 |               Instruction::block(
    |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 BlockType::val_type(ValType::i32()),
    |                 Expr::new([ins]),
    |               ),
    |             ),
    |           ),
    |         )
    | 
    |       // LocalGet produces a value - wrap in block claiming different type
    |       LocalGet(_) =>
500 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some(
    |             (
    |               true,
504 |               Instruction::block(
    |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 BlockType::val_type(ValType::i64()),
    |                 Expr::new([ins]),
    |               ),
    |             ),
    |           ),
    |         )
    | 
    |       // GlobalGet produces a value - wrap in block claiming empty
    |       GlobalGet(_) =>
514 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some((true, Instruction::block(BlockType::void_(), Expr::new([ins])))),
    |         )
    | 
    |       // Existing control flow: corrupt their block type
    |       Block(bt, body) =>
520 |         Ok(Some((true, Instruction::block(corrupt_blocktype(bt), body))))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Loop(bt, body) =>
522 |         Ok(Some((true, Instruction::loop_(corrupt_blocktype(bt), body))))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       If(bt, then_body, else_body) =>
524 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some(
    |             (
    |               true,
528 |               Instruction::if_(corrupt_blocktype(bt), then_body, else_body),
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             ),
    |           ),
    |         )
    |       TryTable(bt, catches, body) =>
533 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some(
535 |             (true, Instruction::try_table(corrupt_blocktype(bt), catches, body)),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           ),
    |         )
    | 
    |       // RefNull produces a ref - wrap in block claiming i32
    |       RefNull(_) =>
    |         Ok(
    |           Some(
    |             (
    |               true,
    |               Instruction::block(
    |                 BlockType::val_type(ValType::i32()),
    |                 Expr::new([ins]),
    |               ),
    |             ),
    |           ),
    |         )
    | 
    |       // RefFunc produces a ref - wrap in block claiming empty
    |       RefFunc(_) =>
    |         Ok(
    |           Some((true, Instruction::block(BlockType::void_(), Expr::new([ins])))),
    |         )
    | 
    |       // StructNewDefault produces a ref - wrap in block claiming i32
    |       StructNewDefault(_) =>
561 |         Ok(
    |         ^^^ 	<-- UNCOVERED
    |           Some(
    |             (
    |               true,
565 |               Instruction::block(
    |               ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 BlockType::val_type(ValType::i32()),
    |                 Expr::new([ins]),
    |               ),
    |             ),
    |           ),
    |         )
    | 
    |       // ArrayNewDefault needs i32 on stack, produces ref
    |       // Can't easily wrap this one without also providing the i32
    | 
576 |       _ => Ok(None)
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   })
    | }
    …

    | fn apply_strategy(
    |   strategy : InvalidationStrategy,
    |   mod_ : Module,
    | ) -> (Bool, Module) {
    |   match strategy {
    |     FuncIdxOOB(n) =>
    |       match make_funcidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
615 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TypeIdxOOB(n) =>
    |       match make_typeidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
620 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     LocalIdxOOB(n) =>
    |       match make_localidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
625 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     GlobalIdxOOB(n) =>
    |       match make_globalidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
630 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     LabelIdxOOB(n) =>
    |       match make_labelidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
635 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TableIdxOOB(n) =>
    |       match make_tableidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
640 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     MemIdxOOB(n) =>
    |       match make_memidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
645 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     DataIdxOOB(n) =>
    |       match make_dataidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
650 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     ElemIdxOOB(n) =>
    |       match make_elemidx_oob_transformer(n).walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
655 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TagIdxOOB(n) =>
    |       match make_tagidx_oob_transformer(n).walk_module(false, mod_) {
    |         Ok(Some((changed, new_mod))) if changed => (true, new_mod)
    |         _ => (false, mod_)
    |       }
    |     NumTypeSwap =>
    |       match make_numtype_swap_transformer().walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
665 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     NullabilityFlip =>
    |       match make_nullability_flip_transformer().walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
670 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     HeapTypeSwap =>
    |       match make_drop_insertion_transformer().walk_module(false, mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
675 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     InstructionTypeMismatch =>
    |       match make_type_corruption_transformer().walk_module(false, mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
680 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     BlockTypeMismatch =>
    |       match make_blocktype_mismatch_transformer().walk_module(false, mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
685 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     DropInsertion =>
    |       match make_drop_insertion_transformer().walk_module(false, mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
690 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     BlockCorruption =>
    |       match make_block_corruption_transformer().walk_module(false, mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
695 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     SignatureCorruption =>
    |       match make_signature_corruption_transformer().walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
700 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     GlobalInitMismatch =>
    |       match make_global_init_mismatch_transformer().walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
705 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     TableInitMismatch =>
    |       match make_table_init_mismatch_transformer().walk_module((), mod_) {
    |         Ok(Some((_, new_mod))) => (true, new_mod)
710 |         _ => (false, mod_)
    |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |   }
    | }
    …

    | fn fuzz_invalid_module_with_coverage(
    |   valid_module : Module,
    |   strategy : InvalidationStrategy,
    | ) -> (String, Bool, Bool) {
    |   let strategy_name = strategy.to_string()
    |   let (was_modified, invalid_module) = apply_strategy(strategy, valid_module)
    | 
    |   // Not tested if no modification was made OR module unchanged
    |   if not(was_modified) || invalid_module == valid_module {
    |     return (strategy_name, false, true)
    |   }
    |   match validate_module(invalid_module) {
755 |     Ok(_) => (strategy_name, true, false)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(_) => (strategy_name, true, true)
    |   }
    | }
    …

43 uncovered line(s) in src/validate/match.mbt:

     | pub impl Match for StorageType with matches(self, other, env) {
     |   match (self, other) {
     |     (ValTypeStorageType(v1), ValTypeStorageType(v2)) =>
     |       Match::matches(v1, v2, env)
     |     (PackTypeStorageType(p1), PackTypeStorageType(p2)) => p1 == p2
  84 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Match for AbsHeapType with matches(self, other, _) {
     |   if self == other {
     |     return true
     |   }
     |   match (self, other) {
     |     // eq <: any
     |     (EqAbsHeapType, AnyAbsHeapType) => true
     | 
     |     // i31/struct/array <: eq
     |     (I31AbsHeapType, EqAbsHeapType) => true
     |     (StructAbsHeapType, EqAbsHeapType) => true
     |     (ArrayAbsHeapType, EqAbsHeapType) => true
     | 
     |     // i31/struct/array <: any (transitive via eq)
     |     (I31AbsHeapType, AnyAbsHeapType) => true
 104 |     (StructAbsHeapType, AnyAbsHeapType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (ArrayAbsHeapType, AnyAbsHeapType) => true
     | 
     |     // none <: all internal types
     |     (NoneAbsHeapType, AnyAbsHeapType) => true
 109 |     (NoneAbsHeapType, EqAbsHeapType) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (NoneAbsHeapType, I31AbsHeapType) => true
     |     (NoneAbsHeapType, StructAbsHeapType) => true
     |     (NoneAbsHeapType, ArrayAbsHeapType) => true
     | 
     |     // nofunc <: func
     |     (NoFuncAbsHeapType, FuncAbsHeapType) => true
     | 
     |     // noextern <: extern
     |     (NoExternAbsHeapType, ExternAbsHeapType) => true
     | 
     |     // noexn <: exn
     |     (NoExnAbsHeapType, ExnAbsHeapType) => true
     |     _ => false
     |   }
     | }
     …

     | fn heaptype_matches_fuel(
     |   h1 : HeapType,
     |   h2 : HeapType,
     |   env : Env,
     |   fuel : Int,
     | ) -> Bool {
     |   if h1 == h2 {
     |     return true
     |   }
     |   if fuel <= 0 {
 143 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match (h1, h2) {
     |     (AbsHeapTypeHeapType(a1), AbsHeapTypeHeapType(a2)) =>
     |       Match::matches(a1, a2, env)
     | 
     |     // Spec: defined type judgement
     |     (DefTypeHeapType(dt1), DefTypeHeapType(dt2)) =>
 151 |       deftype_matches_fuel(dt1, dt2, env, fuel - 1)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // typeidx/recidx unfold on either side
     |     (HeapType(tidx), _) =>
     |       match env.resolve_subtype(tidx) {
 156 |         None => false
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(st1) => subtype_as_heap_fuel(st1, h2, env, fuel - 1)
     |       }
     |     (_, HeapType(tidx)) => heap_vs_typeidx_fuel(h1, tidx, env, fuel - 1)
     | 
     |     // deftype vs abs: use expansion-kind checks (struct/array/func → ...)
     |     (DefTypeHeapType(dt), AbsHeapTypeHeapType(abs)) =>
 163 |       deftype_matches_abs_fuel(dt, abs, env, fuel - 1)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // abs vs deftype: conservative (generally false in subtype direction)
 166 |     (AbsHeapTypeHeapType(_), DefTypeHeapType(_)) => false
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn subtype_as_heap_fuel(
     |   st : SubType,
     |   target : HeapType,
     |   env : Env,
     |   fuel : Int,
     | ) -> Bool {
     |   if fuel <= 0 {
 178 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let (is_final, supers, ct) = match st {
     |     CompTypeSubType(ct) => (false, [], ct)
     |     SubType(is_final, supers, ct) => (is_final, supers, ct)
     |   }
     | 
     |   // 1) Direct shape match against abstract heap supertypes
     |   match target {
     |     AbsHeapTypeHeapType(abs) => {
     |       if comptype_matches_abs(ct, abs) {
     |         return true
     |       }
     |       if is_final {
 192 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => if is_final { return false }
     |   }
     | 
     |   // 2) Chase declared supertypes
     |   for tu in supers {
     |     if heaptype_matches_fuel(HeapType::new(tu), target, env, fuel - 1) {
     |       return true
     |     }
     |   }
     |   false
     | }
     …

     | fn comptype_matches_abs(ct : CompType, abs : AbsHeapType) -> Bool {
     |   match ct {
     |     StructCompType(_) =>
     |       abs == AbsHeapType::struct_() ||
     |       abs == AbsHeapType::eq() ||
     |       abs == AbsHeapType::any()
     |     ArrayCompType(_) =>
     |       abs == AbsHeapType::array() ||
 216 |       abs == AbsHeapType::eq() ||
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       abs == AbsHeapType::any()
     |     FuncCompType(_, _) =>
     |       abs == AbsHeapType::func() || abs == AbsHeapType::any()
     |   }
     | }
     …

     | fn heap_vs_typeidx_fuel(
     |   h : HeapType,
     |   target : TypeIdx,
     |   env : Env,
     |   fuel : Int,
     | ) -> Bool {
     |   if fuel <= 0 {
 231 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match h {
     |     AbsHeapTypeHeapType(_) => false
     |     HeapType(tidx1) =>
 236 |       typeidx_leq_typeidx_fuel(tidx1, target, env, fuel - 1, [])
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     DefTypeHeapType(dt1) =>
 238 |       match dt1.project() {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => false
     |         Some(st1) => {
     |           let DefType(rt1, _) = dt1
 242 |           let env1 = env_with_rectype(env, rt1)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           match st1 {
     |             CompTypeSubType(_) => false
     |             SubType(is_final, supers, _) => {
     |               if is_final {
 247 |                 return false
     |                 ^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               for tu in supers {
 250 |                 if typeidx_leq_typeidx_fuel(tu, target, env1, fuel - 1, []) {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   return true
     |                 }
     |               }
     |               false
     |             }
     |           }
     |         }
     |       }
     |   }
     | }
     …

     | fn deftype_matches_abs_fuel(
     |   dt : DefType,
     |   abs : AbsHeapType,
     |   _env : Env,
     |   fuel : Int,
     | ) -> Bool {
 269 |   if fuel <= 0 {
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return false
     |   }
     | 
     |   // let DefType(rt, _) = dt
     |   // let env2 = env_with_rectype(env, rt)
     | 
 276 |   match dt.project() {
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => false
     |     Some(st) =>
 279 |       match st.get_comptype() {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         StructCompType(_) =>
 281 |           abs == AbsHeapType::struct_() ||
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           abs == AbsHeapType::eq() ||
     |           abs == AbsHeapType::any()
     |         ArrayCompType(_) =>
 285 |           abs == AbsHeapType::array() ||
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           abs == AbsHeapType::eq() ||
     |           abs == AbsHeapType::any()
     |         FuncCompType(_, _) =>
 289 |           abs == AbsHeapType::func() || abs == AbsHeapType::any()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | pub impl Match for DefType with matches(self, other, env) {
 326 |   let fuel = env.global_types.length() + 16 // Int
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   deftype_matches_fuel(self, other, env, fuel)
     | }
     …

     | fn deftype_matches_fuel(
     |   dt1 : DefType,
     |   dt2 : DefType,
     |   env : Env,
     |   fuel : Int,
     | ) -> Bool {
     |   // clos_C(dt1) == clos_C(dt2)
 338 |   if dt1 == dt2 {
     |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return true
     |   }
     |   if fuel <= 0 {
 342 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Put dt1’s rectype in scope for any RecIdx references during unroll/chasing
     |   let DefType(rt1, _) = dt1
 347 |   let env1 = env_with_rectype(env, rt1)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   match dt1.project() {
     |     None => false
     |     Some(st1) =>
 351 |       match st1 {
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |         CompTypeSubType(_) => false
     |         SubType(is_final, supers, _) => {
     |           // final types have no proper subtypes
     |           if is_final {
 356 |             return false
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 358 |           let ht2 = HeapType::def_type(dt2)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           for tu in supers {
     |             // “typeuse*[i] matches heaptype deftype2”
 361 |             if heaptype_matches_fuel(HeapType::new(tu), ht2, env1, fuel - 1) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               return true
     |             }
     |           }
     |           false
     |         }
     |       }
     |   }
     | }
     …

     | fn typeidx_leq_typeidx_fuel(
     |   a : TypeIdx,
     |   b : TypeIdx,
     |   env : Env,
     |   fuel : Int,
     |   visited : Array[TypeIdx],
     | ) -> Bool {
     |   if a == b {
     |     return true
     |   }
     |   if fuel <= 0 {
 440 |     return false
     |     ^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // cycle guard
     |   for v in visited {
 445 |     if v == a {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       return false
     |     }
     |   }
 449 |   match env.resolve_subtype(a) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => false
     |     Some(st) =>
 452 |       match st {
     |       ^^^^^^^^^^ 	<-- UNCOVERED
     |         CompTypeSubType(_) => false
     |         SubType(is_final, _, _) => {
     |           if is_final {
 456 |             return false
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 458 |           let visited2 = visited.copy()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           visited2.push(a)
     |           for s in st.super_types() {
 461 |             if typeidx_leq_typeidx_fuel(s, b, env, fuel - 1, visited2) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               return true
     |             }
     |           }
     |           false
     |         }
     |       }
     |   }
     | }
     …

     | pub impl Match for ExternType with matches(self, other, env) {
     |   match (self, other) {
 511 |     (TagExternType(t1), TagExternType(t2)) => Match::matches(t1, t2, env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (GlobalExternType(g1), GlobalExternType(g2)) => Match::matches(g1, g2, env)
     |     (MemExternType(m1), MemExternType(m2)) => Match::matches(m1, m2, env)
     |     (TableExternType(t1), TableExternType(t2)) => Match::matches(t1, t2, env)
     | 
     |     // Spec says: func deftype1 ≤ func deftype2 iff deftype1 ≤ deftype2.
 517 |     (FuncExternType(ti1), FuncExternType(ti2)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // Optional: ensure both are actually function types
     |       if env.resolve_functype(ti1) is None {
 520 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if env.resolve_functype(ti2) is None {
 523 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
 525 |       typeidx_leq_typeidx(ti1, ti2, env)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     _ => false
     |   }
     | }
     …

579 uncovered line(s) in src/validate/typecheck.mbt:

      | pub impl Show for TcState with output(self, logger) {
   10 |   logger.write_string("TcState {\n")
      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   logger.write_string("  env : ")
      |   self.env.output(logger)
      |   logger.write_string("\n  stack : ")
      |   self.stack.output(logger)
      |   logger.write_string("\n  reachable : ")
      |   self.reachable.output(logger)
      |   logger.write_string("\n}")
      | }
      …

      | fn TcState::pop_ref_or_bot(st : TcState) -> Result[(TcState, RefType?), String] {
      |   match st.pop1() {
   48 |     Err(e) => Err(e)
      |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok((st1, v)) =>
      |       match v {
      |         BotValType => Ok((st1, None)) // unknown ref type, but acceptable
      |         RefTypeValType(rt) => Ok((st1, Some(rt)))
      |         _ => Err("expected a reference operand")
      |       }
      |   }
      | }
      …

      | fn TcState::check_branch_args_present(
      |   st : TcState,
      |   l : LabelIdx,
      | ) -> Result[Array[ValType], String] {
      |   match st.env.get_label_types(l) {
   64 |     None => Err("invalid label index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(ts) => Ok(ts)
      |   }
      | }
      …

      | fn expect_ref_null_heaptype(v : ValType) -> Result[HeapType, String] {
      |   match v {
      |     RefTypeValType(rt) =>
      |       match rt {
      |         HeapTypeRefType(true, ht) => Ok(ht)
      |         HeapTypeRefType(false, _) =>
  143 |           Err("expected (ref null ht), got non-null ref")
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         AbsHeapTypeRefType(_) =>
  145 |           Err("expected (ref null ht), got abstract ref type")
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
  147 |     _ => Err("expected reference type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn pop_types_rev(st : TcState, ts : Array[ValType]) -> TcResult {
      |   let mut st = st
      |   for t in ts.rev_iter() {
      |     st = match st.pop_expect(t) {
  156 |       Err(t) => return Err(t)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(t) => t
      |     }
      |   }
      |   Ok(st)
      | }
      …

      | fn typecheck_select_typed(st : TcState, ts : Array[ValType]) -> TcResult {
      |   if Validate::validate(ts, st.env) is Err(t) {
  179 |     return Err("invalid select type annotation: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // condition
      |   let st1 = match st.pop_expect(ValType::i32()) {
  184 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match pop_types_rev(st1, ts) {
  188 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match pop_types_rev(st2, ts) {
  192 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // push ts
      |   let mut out = st3
      |   for t in ts {
      |     out = out.push1(t)
      |   }
      |   Ok(out)
      | }
      …

      | fn typecheck_select_untyped(st : TcState) -> TcResult {
      |   // pop condition (i32)
      |   let st1 = match st.pop_expect(ValType::i32()) {
  208 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop second operand
      |   let (st2, t2) = match st1.pop1() {
  214 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      | 
      |   // pop first operand
      |   let (st3, t1) = match st2.pop1() {
  220 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      | 
      |   // unreachable: stack is polymorphic, result type can be bot
      |   if !st.reachable {
  226 |     return Ok(st3.push1(ValType::bottom()))
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // reachable: operands must have the same type (mutual match)
      |   let same = Match::matches(t1, t2, st.env) && Match::matches(t2, t1, st.env)
      |   if !same {
      |     return Err("select requires both operands to have the same type")
      |   }
      |   Ok(st3.push1(t1))
      | }
      …

      | fn typecheck_local_tee(st : TcState, idx : LocalIdx) -> TcResult {
      |   match st.env.get_local_type(idx) {
  256 |     None => Err("invalid local index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(vt) =>
      |       // tee pops vt then pushes vt
      |       match st.pop_expect(vt) {
  260 |         Err(e) => Err(e)
      |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st2) => Ok(st2.push1(vt))
      |       }
      |   }
      | }
      …

      | fn typecheck_table_get(st : TcState, idx : TableIdx) -> TcResult {
      |   let TableType(rt, _) = match st.env.get_table_type(idx) {
      |     None => return Err("invalid table index")
      |     Some(tt) => tt
      |   }
      |   let st1 = match st.pop_expect(ValType::i32()) {
  296 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::ref_type(rt)))
      | }
      …

      | fn typecheck_table_set(st : TcState, idx : TableIdx) -> TcResult {
      |   let TableType(rt, _) = match st.env.get_table_type(idx) {
      |     None => return Err("invalid table index")
      |     Some(tt) => tt
      |   }
      | 
      |   // pop value (t)
      |   let st1 = match st.pop_expect(ValType::ref_type(rt)) {
  313 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop index (i32)
      |   let st2 = match st1.pop_expect(ValType::i32()) {
  319 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2)
      | }
      …

      | fn typecheck_table_grow(st : TcState, idx : TableIdx) -> TcResult {
      |   let TableType(rt, _) = match st.env.get_table_type(idx) {
      |     None => return Err("invalid table index")
      |     Some(tt) => tt
      |   }
      | 
      |   // pop delta (i32) — top of stack
      |   let st1 = match st.pop_expect(ValType::i32()) {
  346 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop init value (t)
      |   let st2 = match st1.pop_expect(ValType::ref_type(rt)) {
  352 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::i32()))
      | }
      …

      | fn typecheck_br(st : TcState, l : LabelIdx) -> TcResult {
      |   let ts = match st.env.get_label_types(l) {
      |     None => return Err("invalid label index")
      |     Some(x) => x
      |   }
      |   let st1 = match st.pop_types(ts) {
  365 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.set_unreachable())
      | }
      …

      | fn typecheck_block(st : TcState, bt : BlockType, body : Expr) -> TcResult {
      |   let (params, results) = match st.env.expand_blocktype(bt) {
  374 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      | 
      |   // Entry stack height after consuming params
      |   let st1 = match st.pop_types(params) {
  380 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let base_len = st1.stack.length()
      | 
      |   // Typecheck body with label = results
      |   let env2 = st1.env.with_label(results)
      |   let st_body0 = TcState::{ ..st1, env: env2 }
      |   let st_body = match Typecheck::typecheck(body, st_body0) {
  389 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // If reachable, enforce results on top
      |   let st2 = if st_body.reachable {
      |     match st_body.pop_types(results) {
  396 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(s) => s
      |     }
      |   } else {
  400 |     st_body
      |     ^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // Now drop any extra stack above base_len (polymorphic details omitted for now)
      |   let s = st2.stack.copy()
      |   while s.length() > base_len {
      |     // safe and ignorable because > base_len
  407 |     ignore(s.pop())
      |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let out = TcState::{ ..st, stack: s }
      |   Ok( // reachability after block is same as entry unless you model merges
      |     out.push_types(results),
      |   )
      | }
      …

      | fn typecheck_if(
      |   st : TcState,
      |   bt : BlockType,
      |   then_instrs : Array[Instruction],
      |   else_instrs_opt : Array[Instruction]?,
      | ) -> TcResult {
      |   let (params, results) = match st.env.expand_blocktype(bt) {
  423 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      | 
      |   // pop condition
      |   let st0 = match st.pop_expect(ValType::i32()) {
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
      | 
      |   // pop params
      |   let st1 = match st0.pop_types(params) {
  435 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let base_len = st1.stack.length()
      |   let else_instrs = match else_instrs_opt {
      |     None => []
      |     Some(xs) => xs
      |   }
      | 
      |   // typecheck then branch
      |   let env_branch = st1.env.with_label(results)
      |   let st_then0 = TcState::{ ..st1, env: env_branch }
      |   let st_then = match Typecheck::typecheck(Expr::new(then_instrs), st_then0) {
  448 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // typecheck else branch (same starting state!)
      |   let st_else0 = TcState::{ ..st1, env: env_branch }
      |   let st_else = match Typecheck::typecheck(Expr::new(else_instrs), st_else0) {
  455 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // For each reachable branch: enforce results on top and truncate to base_len.
      |   let norm_branch = fn(sb : TcState) -> Result[(Bool, Array[ValType]), String] {
      |     let sb2 = if sb.reachable {
      |       match sb.pop_types(results) {
  463 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |     } else {
  467 |       sb
      |       ^^ 	<-- UNCOVERED
      |     }
      |     let stack2 = sb2.stack.copy()
      |     while stack2.length() > base_len {
  471 |       ignore(stack2.pop())
      |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     Ok((sb2.reachable, stack2))
      |   }
      |   let (then_reach, then_stack) = match norm_branch(st_then) {
  476 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let (else_reach, else_stack) = match norm_branch(st_else) {
  480 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      | 
      |   // Merge rule: if both reachable, stacks must be identical at merge point.
      |   // If one unreachable, take the other.
      |   let merged_stack = match (then_reach, else_reach) {
      |     (true, true) => {
      |       if then_stack != else_stack {
  489 |         return Err("if branch stack mismatch")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       then_stack
      |     }
  493 |     (true, false) => then_stack
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     (false, true) => else_stack
      |     (false, false) => st1.stack.copy() // both unreachable, base is fine
      |   }
      |   let merged_reachable = then_reach || else_reach
      |   let out = TcState::{
      |     env: st.env,
      |     stack: merged_stack,
      |     reachable: merged_reachable,
      |   }
      |   Ok(out.push_types(results))
      | }
      …

      | fn typecheck_br_if(st : TcState, l : LabelIdx) -> TcResult {
      |   let ts = match st.env.get_label_types(l) {
      |     None => return Err("invalid label index")
      |     Some(x) => x
      |   }
      | 
      |   // Pop condition first
      |   let st1 = match st.pop_expect(ValType::i32()) {
  515 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // If unreachable, the stack is polymorphic; br_if is fine
      |   if !st.reachable {
      |     return Ok(st1)
      |   }
      | 
      |   // Check that branch arguments are present.
      |   // Important: do NOT keep the popped state; this is only a type check.
      |   let _ = match st1.pop_types(ts) {
  527 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(_) => ()
      |   }
      | 
      |   // Not-taken path continues with the stack after popping only the condition
      |   Ok(st1)
      | }
      …

      | fn typecheck_return(st : TcState) -> TcResult {
      |   let ts = match st.env.return_type {
  577 |     None => return Err("return used with no function return type in context")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(t) => t
      |   }
      |   let st1 = match st.pop_types(ts) {
  581 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.set_unreachable())
      | }
      …

      | fn typecheck_call_indirect(
      |   st : TcState,
      |   tidx : TypeIdx,
      |   tid : TableIdx,
      | ) -> TcResult {
      |   // Resolve the function type from the type index
      |   let FuncType(params, results) = match st.env.resolve_functype(tidx) {
  608 |     None => return Err("call_indirect type index is not a function type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(ft) => ft
      |   }
      | 
      |   // Table must exist and have element type compatible with funcref
      |   let TableType(elem_rt, _) = match st.env.get_table_type(tid) {
      |     None => return Err("invalid table index")
      |     Some(tt) => tt
      |   }
      | 
      |   // Require elem_rt <: funcref (spec requires the table contains functions)
      |   let fr = ValType::funcref()
      |   let elem_vt = ValType::ref_type(elem_rt)
      |   if !Match::matches(elem_vt, fr, st.env) {
      |     return Err("call_indirect table element type is not funcref-compatible")
      |   }
      | 
      |   // Pop table element index (i32)
      |   let st1 = match st.pop_expect(ValType::i32()) {
  627 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // Pop params
      |   let st2 = match st1.pop_types(params) {
  633 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push_types(results))
      | }
      …

      | fn typecheck_call_ref(st : TcState, tidx : TypeIdx) -> TcResult {
      |   let FuncType(params, results) = match st.env.resolve_functype(tidx) {
  642 |     None => return Err("call_ref type index is not a function type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(ft) => ft
      |   }
      | 
      |   // Pop funcref of type (ref null tidx)
      |   // Your representation: HeapTypeRefType(nullable, HeapType(TypeIdx))
      |   let fref = ValType::ref_type(RefType::new(true, HeapType::new(tidx)))
      |   let st1 = match st.pop_expect(fref) {
  650 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // Pop params
      |   let st2 = match st1.pop_types(params) {
  656 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push_types(results))
      | }
      …

      | fn require_return_results(
      |   st : TcState,
      |   results : Array[ValType],
      | ) -> Result[Unit, String] {
      |   match st.env.return_type {
  668 |     None => Err("return_call used with no function return type in context")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(rt) =>
      |       if equals(results, rt) {
      |         Ok(())
      |       } else {
      |         Err("tail call result mismatch")
      |       }
      |   }
      | }
      …

      | fn typecheck_return_call(st : TcState, fidx : FuncIdx) -> TcResult {
      |   let FuncType(params, results) = match st.env.get_functype_by_funcidx(fidx) {
  681 |     None => return Err("invalid function index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(ft) => ft
      |   }
      |   match require_return_results(st, results) {
  685 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(_) => ()
      |   }
      |   let st1 = match st.pop_types(params) {
  689 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.set_unreachable())
      | }
      …

      | fn typecheck_return_call_indirect(
      |   st : TcState,
      |   tidx : TypeIdx,
      |   t : TableIdx,
      | ) -> TcResult {
      |   let FuncType(params, results) = match st.env.resolve_functype(tidx) {
  702 |     None => return Err("return_call_indirect type index is not a function type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(ft) => ft
      |   }
      |   match require_return_results(st, results) {
      |     Err(e) => return Err(e)
      |     Ok(_) => ()
      |   }
      |   let TableType(elem_rt, _) = match st.env.get_table_type(t) {
  710 |     None => return Err("invalid table index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(tt) => tt
      |   }
      | 
      |   // elem_rt <: funcref
      |   let fr = ValType::ref_type(RefType::abs(AbsHeapType::func()))
      |   let elem_vt = ValType::ref_type(elem_rt)
      |   if !Match::matches(elem_vt, fr, st.env) {
      |     return Err(
      |       "return_call_indirect table element type is not funcref-compatible",
      |     )
      |   }
      |   let st1 = match st.pop_expect(ValType::i32()) {
  723 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_types(params) {
  727 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.set_unreachable())
      | }
      …

      | fn typecheck_return_call_ref(st : TcState, tidx : TypeIdx) -> TcResult {
      |   let FuncType(params, results) = match st.env.resolve_functype(tidx) {
  736 |     None => return Err("return_call_ref type index is not a function type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(ft) => ft
      |   }
      |   match require_return_results(st, results) {
  740 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(_) => ()
      |   }
      |   let fref = ValType::ref_type(RefType::new(true, HeapType::new(tidx)))
      |   let st1 = match st.pop_expect(fref) {
  745 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_types(params) {
  749 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.set_unreachable())
      | }
      …

      | fn expect_nullable_ref(v : ValType) -> Result[(HeapType, RefType), String] {
      |   match v {
      |     RefTypeValType(rt) => {
      |       if !rt.is_nullable() {
  760 |         return Err("expected a nullable reference type")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       Ok((rt.get_heap_type(), rt))
      |     }
  764 |     _ => Err("expected a reference type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn typecheck_br_on_null(st : TcState, l : LabelIdx) -> TcResult {
      |   let ts = match st.env.get_label_types(l) {
  771 |     None => return Err("invalid label index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(x) => x
      |   }
      | 
      |   // Pop operand: must be exactly (ref null ht)
      |   let (st1, v) = match st.pop1() {
  777 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      |   let ht = match expect_ref_null_heaptype(v) {
  781 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   if Validate::validate(ht, st.env) is Err(t) {
  785 |     return Err("Invalid heap type in br_on_null operand: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // Branch target label has type t*
      |   if st.reachable {
      |     let _ = match st1.pop_types(ts) {
  791 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(_) => ()
      |     }
      |   }
      | 
      |   // Fallthrough refines to non-null (ref ht)
      |   Ok(st1.push1(ValType::ref_type(RefType::new(false, ht))))
      | }
      …

      | fn typecheck_br_on_non_null(st : TcState, l : LabelIdx) -> TcResult {
      |   let label_ts = match st.env.get_label_types(l) {
  803 |     None => return Err("invalid label index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(x) => x
      |   }
      |   let (st1, v) = match st.pop1() {
  807 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      |   let (ht, _rt_in) = match expect_nullable_ref(v) {
  811 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   if Validate::validate(ht, st.env) is Err(t) {
  815 |     return Err("Invalid heap type in br_on_non_null operand: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   if label_ts.length() == 0 {
  818 |     return Err("br_on_non_null label type too short")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // Label must end with NON-NULLABLE ref of same heap type
      |   let non_null_rt = RefType::new(false, ht)
      |   let want_last = ValType::ref_type(non_null_rt)
      |   let last = label_ts[label_ts.length() - 1]
      |   if not(Match::matches(last, want_last, st.env)) {
      |     return Err("br_on_non_null label must end with non-nullable ref type")
      |   }
      |   if st.reachable {
      |     let end = label_ts.length() - 1
      |     let prefix = label_ts[0:end].to_array()
      |     if st1.pop_types(prefix) is Err(t) {
  832 |       return Err(t)
      |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |   }
      |   Ok(st1)
      | }
      …

      | fn typecheck_br_on_cast(
      |   st : TcState,
      |   l : LabelIdx,
      |   op : CastOp,
      |   ht1 : HeapType,
      |   ht2 : HeapType,
      | ) -> TcResult {
      |   let CastOp(n1, n2) = op
      |   let rt1 = RefType::new(n1, ht1)
      |   let rt2 = RefType::new(n2, ht2)
      |   if Validate::validate(rt1, st.env) is Err(t) {
  850 |     return Err("Invalid BrOnCast: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   if Validate::validate(rt2, st.env) is Err(t) {
  853 |     return Err("Invalid BrOnCast: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let label_ts = match st.check_branch_args_present(l) {
  856 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   if label_ts.length() == 0 {
      |     return Err("br_on_cast label type too short")
      |   }
      |   let rt_label = match label_ts[label_ts.length() - 1] {
      |     RefTypeValType(r) => r
      |     _ => return Err("br_on_cast label must end with a reftype")
      |   }
      | 
      |   // rt2 <: rt1 and rt2 <: rt_label
      |   if !Match::matches(rt2, rt1, st.env) {
      |     return Err("rt2 does not match rt1")
      |   }
      |   if !Match::matches(rt2, rt_label, st.env) {
  872 |     return Err("rt2 does not match label rt")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // pop rt1
      |   let st1 = match st.pop_expect(ValType::ref_type(rt1)) {
  877 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   if st.reachable {
      |     // Check label args excluding rt_label (because branch keeps rt2 / rt_label)
      |     // Per spec, label is t* rt, so the remaining stack must have t*
      |     let end = label_ts.length() - 1
      |     let prefix = label_ts[0:end].to_array()
      |     let _ = match st1.pop_types(prefix) {
  886 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(_) => ()
      |     }
      |   }
      | 
      |   // push (rt1 \ rt2)
      |   let rt_out = match diff(rt1, rt2) {
  893 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   Ok(st1.push1(ValType::ref_type(rt_out)))
      | }
      …

      | fn typecheck_br_on_cast_fail(
      |   st : TcState,
      |   l : LabelIdx,
      |   op : CastOp,
      |   ht1 : HeapType,
      |   ht2 : HeapType,
      | ) -> TcResult {
      |   let CastOp(n1, n2) = op
      |   let rt1 = RefType::new(n1, ht1)
      |   let rt2 = RefType::new(n2, ht2)
      |   if Validate::validate(rt1, st.env) is Err(t) {
  911 |     return Err("Invalid RefType on BrOnCastFail: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   if Validate::validate(rt2, st.env) is Err(t) {
  914 |     return Err("Invalid RefType on BrOnCastFail: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let label_ts = match st.check_branch_args_present(l) {
  917 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   if label_ts.length() == 0 {
      |     return Err("br_on_cast_fail label type too short")
      |   }
      |   let rt_label = match label_ts[label_ts.length() - 1] {
      |     RefTypeValType(r) => r
  925 |     _ => return Err("br_on_cast_fail label must end with a reftype")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   if !Match::matches(rt2, rt1, st.env) {
  928 |     return Err("rt2 does not match rt1")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let rt_diff = match diff(rt1, rt2) {
  931 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   if !Match::matches(rt_diff, rt_label, st.env) {
      |     return Err("rt1 \\ rt2 does not match label rt")
      |   }
      | 
      |   // pop rt1
      |   let st1 = match st.pop_expect(ValType::ref_type(rt1)) {
  940 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   if st.reachable {
      |     let end = label_ts.length() - 1
      |     let prefix = label_ts[0:end].to_array()
      |     let _ = match st1.pop_types(prefix) {
  947 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(_) => ()
      |     }
      |   }
      |   Ok(st1.push1(ValType::ref_type(rt2)))
      | }
      …

      | fn typecheck_throw(st : TcState, tag : TagIdx) -> TcResult {
      |   // validate tag index
      |   if Validate::validate(tag, st.env) is Err(e) {
      |     return Err(e)
      |   }
      | 
      |   // get payload params
      |   let TagType(tidx) = st.env.tags[tag.0.reinterpret_as_int()]
      |   let params = match st.env.resolve_functype(tidx) {
      |     Some(FuncType(ps, _)) => ps
  965 |     None => return Err("throw: invalid tag type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // pop payload
      |   let st1 = match st.pop_types(params) {
      |     Ok(s) => s
  971 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // throw always makes execution unreachable
      |   Ok(st1.set_unreachable())
      | }
      …

      | fn typecheck_throw_ref(st : TcState) -> TcResult {
      |   let st1 = match st.pop_expect(ValType::ref_null_exn()) {
  981 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.set_unreachable())
      | }
      …

      | fn tag_payload_types(env : Env, tag : TagIdx) -> Array[ValType] {
      |   let idx = tag.0
      |   // Guard against overflow - if idx >= 2^31, it would become negative when cast to Int
      |   if idx > 0x7FFFFFFF {
  992 |     return []
      |     ^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   match env.tags.get(idx.reinterpret_as_int()) {
      |     Some(TagType(tidx)) =>
      |       match env.resolve_functype(tidx) {
      |         Some(FuncType(params, _)) => params
  998 |         None => []
      |         ^^^^^^^^^^ 	<-- UNCOVERED
      |       }
 1000 |     None => []
      |     ^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn typecheck_catch_clause(st : TcState, c : Catch) -> TcResult {
      |   match c {
      |     Catch(tag, lbl) => {
      |       if Validate::validate(tag, st.env) is Err(e) {
      |         return Err(e)
      |       }
      |       // label must expect tag's payload types
      |       let label_idx = lbl.0.reinterpret_as_int()
      |       let label_types = match st.env.labels.get(label_idx) {
      |         Some(label_types) => label_types
      |         None => return Err("Invalid catch label index")
      |       }
      |       let payload = tag_payload_types(st.env, tag)
      |       if not(Match::matches(payload, label_types, st.env)) {
      |         return Err("catch types (payload) do not match label types")
      |       }
      |       Ok(st)
      |     }
      |     CatchRef(tag, lbl) => {
      |       if Validate::validate(tag, st.env) is Err(e) {
      |         return Err(e)
      |       }
      |       // label must expect tag's payload types + exnref
      |       let label_idx = lbl.0.reinterpret_as_int()
      |       let label_types = match st.env.labels.get(label_idx) {
      |         Some(label_types) => label_types
 1031 |         None => return Err("Invalid catch label index")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let payload = tag_payload_types(st.env, tag)
      |       let expected = payload.copy()
      |       expected.push(
      |         ValType::ref_type(
      |           RefType::new(false, HeapType::abs(AbsHeapType::exn())),
      |         ),
      |       )
      |       if not(Match::matches(expected, label_types, st.env)) {
      |         return Err(
      |           "catch_ref types (payload + exnref) do not match label types",
      |         )
      |       }
      |       Ok(st)
      |     }
      |     CatchAll(lbl) => {
      |       // label must expect empty
      |       let label_idx = lbl.0.reinterpret_as_int()
      |       let label_types = match st.env.labels.get(label_idx) {
      |         Some(label_types) => label_types
 1052 |         None => return Err("Invalid catch label index")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       if label_types.length() != 0 {
      |         return Err("catch_all label must expect no values")
      |       }
      |       Ok(st)
      |     }
      |     CatchAllRef(lbl) => {
      |       // label must expect just exnref
      |       let label_idx = lbl.0.reinterpret_as_int()
      |       let label_types = match st.env.labels.get(label_idx) {
      |         Some(label_types) => label_types
 1064 |         None => return Err("Invalid catch label index")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let expected = [
      |         ValType::ref_type(
      |           RefType::new(false, HeapType::abs(AbsHeapType::exn())),
      |         ),
      |       ]
      |       if not(Match::matches(expected, label_types, st.env)) {
      |         return Err("catch_all_ref label must expect exnref")
      |       }
      |       Ok(st)
      |     }
      |   }
      | }
      …

      | fn typecheck_try_table(
      |   st : TcState,
      |   bt : BlockType,
      |   catches : Array[Catch],
      |   body : Expr,
      | ) -> TcResult {
      |   let (params, results) = match st.env.expand_blocktype(bt) { // assuming you made it a method
 1087 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      | 
      |   // consume params
      |   let st1 = match st.pop_types(params) {
 1093 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let base_len = st1.stack.length()
      | 
      |   // extend context with innermost label = results
      |   let env2 = st1.env.with_label(results)
      |   let st_body0 = TcState::{ ..st1, env: env2 }
      | 
      |   // body must typecheck under extended env
      |   let st_body = match Typecheck::typecheck(body, st_body0) {
 1104 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // validate all catch clauses under the SAME extended env (spec: C')
      |   let st_catch_ctx = TcState::{ ..st1, env: env2 }
      |   for c in catches {
      |     match typecheck_catch_clause(st_catch_ctx, c) {
      |       Err(e) => return Err(e)
 1113 |       Ok(_) => ()
      |       ^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |   }
      | 
      |   // if reachable, enforce results on stack top
      |   let st2 = if st_body.reachable {
      |     match st_body.pop_types(results) {
 1120 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(s) => s
      |     }
      |   } else {
 1124 |     st_body
      |     ^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // truncate back to base_len
      |   let stack2 = st2.stack.copy()
      |   while stack2.length() > base_len {
 1130 |     ignore(stack2.pop())
      |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // restore outer env (pop the try_table label scope)
      |   let out = TcState::{ env: st.env, stack: stack2, reachable: st2.reachable }
      |   Ok(out.push_types(results))
      | }
      …

      | fn typecheck_table_copy(st : TcState, x : TableIdx, y : TableIdx) -> TcResult {
      |   let TableType(rt1, l1) = match st.env.get_table_type(x) {
 1141 |     None => return Err("invalid dest table index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(tt) => tt
      |   }
      |   let TableType(rt2, l2) = match st.env.get_table_type(y) {
 1145 |     None => return Err("invalid src table index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(tt) => tt
      |   }
      | 
      |   // require rt2 <: rt1
      |   if !Match::matches(rt2, rt1, st.env) {
 1151 |     return Err("table.copy source elem type does not match dest elem type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let at_len = min_addr(l1, l2)
      | 
      |   // Pop len, src, dst (LIFO), with types at_len, at2, at1
      |   let st1 = match st.pop_expect(at_len.addr_valtype()) {
 1157 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(l2.addr_valtype()) {
 1161 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(l1.addr_valtype()) {
 1165 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn typecheck_table_init(st : TcState, y : ElemIdx, x : TableIdx) -> TcResult {
      |   let TableType(rt1, l) = match st.env.get_table_type(x) {
 1174 |     None => return Err("invalid table index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(tt) => tt
      |   }
      |   let elem = match st.env.get_elem(y) {
 1178 |     None => return Err("invalid elem segment index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(e) => e
      |   }
      |   let rt2 = elem.reftype()
      |   if !Match::matches(rt2, rt1, st.env) {
 1183 |     return Err("table.init elem segment type does not match table element type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // Pop: len:i32, src:i32, dst:at  (LIFO order)
      |   let st1 = match st.pop_expect(ValType::i32()) {
 1188 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 1192 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(l.addr_valtype()) {
 1196 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn typecheck_table_fill(st : TcState, x : TableIdx) -> TcResult {
      |   let TableType(rt, lim) = match st.env.get_table_type(x) {
 1205 |     None => return Err("invalid table index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(tt) => tt
      |   }
      | 
      |   // pop len : i32
      |   let st1 = match st.pop_expect(ValType::i32()) {
 1211 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop val : rt
      |   let st2 = match st1.pop_expect(ValType::ref_type(rt)) {
 1217 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop start : at (derived from limits)
      |   let st3 = match st2.pop_expect(lim.addr_valtype()) {
 1223 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn memarg_check(
      |   st : TcState,
      |   ma : MemArg,
      |   default_mem : MemIdx,
      |   nbits : Int,
      | ) -> Result[(MemIdx, Limits), String] {
      |   let MemArg(U32(align_pow_u), mem_opt, U64(offset)) = ma
      |   let mem = match mem_opt {
      |     None => default_mem
      |     Some(m) => m
      |   }
      |   let MemType(lim) = match st.env.get_memtype(mem) {
      |     None => return Err("invalid memory index in memarg")
      |     Some(mt) => mt
      |   }
      | 
      |   // (1) alignment: 2^n <= N/8
      |   let max_align_bytes = nbits / 8
      |   if max_align_bytes <= 0 {
 1259 |     return Err("invalid access width")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let align_pow = align_pow_u.reinterpret_as_int()
      |   if align_pow < 0 {
 1263 |     return Err("negative alignment power")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   if align_pow >= 64 {
 1266 |     return Err("alignment too large")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let align_bytes : UInt64 = 1 << align_pow
      |   if align_bytes > max_align_bytes.to_uint64() {
      |     return Err("memarg alignment too large for access width")
      |   }
      | 
      |   // (2) offset: m < 2^|at|
      |   let bits = lim.mem_addr_bits()
      |   if bits == 32 {
      |     if offset >= 1 << 32 {
      |       return Err("memarg offset out of range for i32 memory")
      |     }
      |   } else {
      |     // i64 memory: offset is UInt64 so always < 2^64
 1281 |     ()
      |     ^^ 	<-- UNCOVERED
      |   }
      |   Ok((mem, lim))
      | }
      …

      | fn typecheck_load(
      |   st : TcState,
      |   ma : MemArg,
      |   nbits : Int,
      |   result : ValType,
      | ) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
      |     Err(e) => return Err(e)
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      |   let st1 = match st.pop_expect(at) {
 1299 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(result))
      | }
      …

      | fn typecheck_store(
      |   st : TcState,
      |   ma : MemArg,
      |   nbits : Int,
      |   value : ValType,
      | ) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
      |     Err(e) => return Err(e)
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      | 
      |   // pop value first (top of stack)
      |   let st1 = match st.pop_expect(value) {
 1320 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop address
      |   let st2 = match st1.pop_expect(at) {
 1326 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2)
      | }
      …

      | fn typecheck_atomic_notify(st : TcState, ma : MemArg) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), 32) {
 1335 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      |   let st1 = match st.pop_expect(ValType::i32()) {
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(at) {
 1344 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::i32()))
      | }
      …

      | fn typecheck_atomic_wait(
      |   st : TcState,
      |   ma : MemArg,
      |   nbits : Int,
      |   expected : ValType,
      | ) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1358 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      |   let st1 = match st.pop_expect(ValType::i64()) {
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(expected) {
      |     Err(e) => return Err(e)
 1368 |     Ok(s) => s
      |     ^^^^^^^^^^ 	<-- UNCOVERED
      |   }
 1370 |   let st3 = match st2.pop_expect(at) {
      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
 1374 |   Ok(st3.push1(ValType::i32()))
      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      | }
      …

      | fn typecheck_atomic_rmw(
      |   st : TcState,
      |   ma : MemArg,
      |   nbits : Int,
      |   ty : ValType,
      | ) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1385 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      |   let st1 = match st.pop_expect(ty) {
      |     Err(e) => return Err(e)
 1391 |     Ok(s) => s
      |     ^^^^^^^^^^ 	<-- UNCOVERED
      |   }
 1393 |   let st2 = match st1.pop_expect(at) {
      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
 1397 |   Ok(st2.push1(ty))
      |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      | }
      …

      | fn typecheck_atomic_cmpxchg(
      |   st : TcState,
      |   ma : MemArg,
      |   nbits : Int,
      |   ty : ValType,
      | ) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1408 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      |   let st1 = match st.pop_expect(ty) {
      |     Err(e) => return Err(e)
 1414 |     Ok(s) => s
      |     ^^^^^^^^^^ 	<-- UNCOVERED
      |   }
 1416 |   let st2 = match st1.pop_expect(ty) {
      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
 1420 |   let st3 = match st2.pop_expect(at) {
      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Err(e) => return Err(e)
      |     Ok(s) => s
      |   }
 1424 |   Ok(st3.push1(ty))
      |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      | }
      …

      | fn typecheck_loop(st : TcState, bt : BlockType, body : Expr) -> TcResult {
      |   let (params, results) = match st.env.expand_blocktype(bt) {
 1430 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      | 
      |   // consume params
      |   let st1 = match st.pop_types(params) {
 1436 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let base_len = st1.stack.length()
      | 
      |   // loop label is params (not results)
      |   let env2 = st1.env.with_label(params)
      |   let st_body0 = TcState::{ ..st1, env: env2 }
      |   let st_body = match Typecheck::typecheck(body, st_body0) {
 1445 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // if reachable, enforce results on top
      |   let st2 = if st_body.reachable {
      |     match st_body.pop_types(results) {
 1452 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(s) => s
      |     }
      |   } else {
 1456 |     st_body
      |     ^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // truncate back to base_len
      |   let stack2 = st2.stack.copy()
      |   while stack2.length() > base_len {
 1462 |     ignore(stack2.pop())
      |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // restore outer env (pop label scope)
      |   let out = TcState::{ env: st.env, stack: stack2, reachable: st2.reachable }
      |   Ok(out.push_types(results))
      | }
      …

      | fn typecheck_ref_null(st : TcState, ht : HeapType) -> TcResult {
      |   if Validate::validate(ht, st.env) is Err(t) {
 1473 |     return Err(t)
      |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   Ok(st.push1(ValType::ref_null(ht)))
      | }
      …

      | fn typecheck_ref_is_null(st : TcState) -> TcResult {
      |   let (st1, v) = match st.pop1() {
 1481 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      |   match v {
      |     RefTypeValType(rt) => {
      |       if !rt.is_nullable() {
 1487 |         return Err("ref.is_null expects a nullable reference")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       Ok(st1.push1(ValType::i32()))
      |     }
 1491 |     _ => Err("ref.is_null expects a reference type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn typecheck_ref_as_non_null(st : TcState) -> TcResult {
      |   let (st1, v) = match st.pop1() {
 1506 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      |   match v {
      |     RefTypeValType(rt) =>
      |       match rt {
      |         HeapTypeRefType(true, ht) =>
      |           Ok(st1.push1(ValType::ref_type(RefType::new(false, ht))))
      |         HeapTypeRefType(false, _) =>
 1515 |           Err("ref.as_non_null expects (ref null ht), got non-null ref")
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         AbsHeapTypeRefType(_) =>
 1517 |           Err("ref.as_non_null expects (ref null ht), got abstract ref type")
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
 1519 |     _ => Err("ref.as_non_null expects a reference type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn typecheck_ref_eq(st : TcState) -> TcResult {
      |   // pop second operand
      |   let st1 = match st.pop_expect(ValType::eqref_null()) {
 1527 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop first operand
      |   let st2 = match st1.pop_expect(ValType::eqref_null()) {
 1533 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::i32()))
      | }
      …

      | fn typecheck_ref_get_desc(st : TcState) -> TcResult {
      |   let (st1, rt_in_opt) = match st.pop_ref_or_bot() {
      |     Err(e) => return Err(e)
      |     Ok(x) => x
      |   }
      |   match rt_in_opt {
 1546 |     None => return Ok(st1.push1(st.env.descriptor_result_type()))
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(rt_in) =>
      |       if rt_in.is_nullable() {
      |         return Err("ref.get_desc expects a non-null reference operand")
      |       }
      |   }
      |   Ok(st1.push1(st.env.descriptor_result_type()))
      | }
      …

      | fn typecheck_ref_test(st : TcState, nullable : Bool, ht : HeapType) -> TcResult {
      |   let rt = RefType::new(nullable, ht)
      |   if Validate::validate(rt, st.env) is Err(t) {
 1559 |     return Err("invalid ref.test target reftype: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let (st1, v) = match st.pop1() {
 1562 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      |   let rt_in = match v {
      |     RefTypeValType(r) => r
 1567 |     _ => return Err("ref.test expects a reference operand")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | 
      |   // Spec: rt <: rt_in OR rt_in <: rt (types must be in same hierarchy)
      |   if not(Match::matches(rt, rt_in, st.env) || Match::matches(rt_in, rt, st.env)) {
      |     return Err("ref.test target does not match operand type")
      |   }
      |   Ok(st1.push1(ValType::i32()))
      | }
      …

      | fn typecheck_ref_cast(st : TcState, nullable : Bool, ht : HeapType) -> TcResult {
      |   let rt = RefType::new(nullable, ht)
      |   if Validate::validate(rt, st.env) is Err(t) {
 1581 |     return Err("invalid ref.cast target reftype: " + t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let (st1, rt_in_opt) = match st.pop_ref_or_bot() {
 1584 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   match rt_in_opt {
 1588 |     None => ()
      |     ^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(rt_in) =>
      |       if !Match::matches(rt, rt_in, st.env) {
 1591 |         return Err("ref.cast target does not match operand type")
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |   }
      |   Ok(st1.push1(ValType::ref_type(rt)))
      | }
      …

      | fn typecheck_ref_test_desc(
      |   st : TcState,
      |   nullable : Bool,
      |   ht : HeapType,
      | ) -> TcResult {
      |   let rt = match st.env.resolve_descriptor_target_ref_type(nullable, ht) {
      |     Ok(t) => t
      |     Err(e) => return Err(e)
      |   }
      |   let (st1, v) = match st.pop1() {
 1608 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(pair) => pair
      |   }
      |   let rt_in = match v {
      |     RefTypeValType(r) => r
      |     _ => return Err("ref.test_desc expects a reference operand")
      |   }
      |   if !descriptor_compatible(rt, rt_in, st.env) {
      |     return Err("ref.test_desc target does not match operand type")
      |   }
      |   Ok(st1.push1(ValType::i32()))
      | }
      …

      | fn typecheck_ref_cast_desc_eq(
      |   st : TcState,
      |   nullable : Bool,
      |   ht : HeapType,
      | ) -> TcResult {
      |   let rt = match st.env.resolve_descriptor_target_ref_type(nullable, ht) {
      |     Ok(t) => t
      |     Err(e) => return Err(e)
      |   }
      |   let (st1, rt_in_opt) = match st.pop_ref_or_bot() {
 1632 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   match rt_in_opt {
      |     None => ()
      |     Some(rt_in) =>
      |       if !descriptor_compatible(rt, rt_in, st.env) {
      |         return Err("ref.cast_desc_eq target does not match operand type")
      |       }
      |   }
      |   Ok(st1.push1(ValType::ref_type(rt)))
      | }
      …

      | fn typecheck_struct_new(st : TcState, x : TypeIdx) -> TcResult {
      |   let fields = match st.env.resolve_struct_fields(x) {
 1648 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(fs) => fs
      |   }
      | 
      |   // Compute expected argument types: unpack(storage) for each field, in order.
      |   let args : Array[ValType] = []
      |   for f in fields {
      |     let FieldType(stor, _) = f
      |     args.push(stor.unpack())
      |   }
      |   let st1 = match st.pop_types(args) {
 1659 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // push (ref x)
      |   Ok(st1.push1(ValType::ref_type(RefType::new(false, HeapType::new(x)))))
      | }
      …

      | fn typecheck_struct_new_default(st : TcState, x : TypeIdx) -> TcResult {
      |   let fields = match st.env.resolve_struct_fields(x) {
 1670 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(fs) => fs
      |   }
      |   for f in fields {
      |     let FieldType(stor, _) = f
      |     let vt = stor.unpack()
      |     if !has_default(vt) {
 1677 |       return Err("struct.new_default: no default for a non-null field type")
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |   }
      |   Ok(st.push1(ValType::ref_type(RefType::new(false, HeapType::new(x)))))
      | }
      …

      | fn typecheck_struct_get(st : TcState, x : TypeIdx, i : U32) -> TcResult {
      |   let fields = match st.env.resolve_struct_fields(x) {
 1686 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(fs) => fs
      |   }
      |   let FieldType(stor, _) = match get_struct_field(fields, i) {
 1690 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   if stor.is_packed() {
 1694 |     return Err(
      |     ^^^^^^^^^^^ 	<-- UNCOVERED
      |       "struct.get used on packed field; use struct.get_s or struct.get_u",
      |     )
      |   }
      |   let st1 = match
      |     st.pop_expect(ValType::ref_type(RefType::new(true, HeapType::new(x)))) {
 1700 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(stor.unpack()))
      | }
      …

      | fn typecheck_struct_get_s(st : TcState, x : TypeIdx, i : U32) -> TcResult {
      |   let fields = match st.env.resolve_struct_fields(x) {
 1709 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(fs) => fs
      |   }
      |   let FieldType(stor, _) = match get_struct_field(fields, i) {
 1713 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   if !stor.is_packed() {
 1717 |     return Err("struct.get_s requires packed field")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let st1 = match
      |     st.pop_expect(ValType::ref_type(RefType::new(true, HeapType::new(x)))) {
 1721 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::i32()))
      | }
      …

      | fn typecheck_struct_set(st : TcState, x : TypeIdx, i : U32) -> TcResult {
      |   let fields = match st.env.resolve_struct_fields(x) {
 1736 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(fs) => fs
      |   }
      |   let ft = match get_struct_field(fields, i) {
 1740 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   if !ft.is_mutable() {
 1744 |     return Err("struct.set on immutable field")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(stor, _) = ft
      |   let val_ty = stor.unpack()
      | 
      |   // pop value then ref
      |   let st1 = match st.pop_expect(val_ty) {
 1751 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match
      |     st1.pop_expect(ValType::ref_type(RefType::new(true, HeapType::new(x)))) {
 1756 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2)
      | }
      …

      | fn typecheck_unary(st : TcState, t_in : ValType, t_out : ValType) -> TcResult {
      |   let st1 = match st.pop_expect(t_in) {
 1765 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(t_out))
      | }
      …

      | fn typecheck_v128_ternary(st : TcState) -> TcResult {
      |   // v128 v128 v128 -> v128
      |   let st1 = match st.pop_expect(ValType::v128()) {
 1788 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::v128()) {
 1792 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(ValType::v128()) {
 1796 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3.push1(ValType::v128()))
      | }
      …

      | fn typecheck_v128_shift(st : TcState) -> TcResult {
      |   // v128 i32 -> v128 (shift count is i32)
      |   let st1 = match st.pop_expect(ValType::i32()) {
 1827 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::v128()) {
 1831 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::v128()))
      | }
      …

      | fn typecheck_lane_extract(st : TcState, out : ValType) -> TcResult {
      |   // v128 -> out (lane index is an immediate, not on stack)
      |   let st1 = match st.pop_expect(ValType::v128()) {
 1841 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(out))
      | }
      …

      | fn typecheck_lane_replace(st : TcState, in_v : ValType) -> TcResult {
      |   // v128, in_v -> v128
      |   let st1 = match st.pop_expect(in_v) {
 1851 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::v128()) {
 1855 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::v128()))
      | }
      …

      | fn typecheck_v128_mem_load(st : TcState, ma : MemArg, nbits : Int) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1875 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      |   let st1 = match st.pop_expect(at) {
 1880 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::v128()))
      | }
      …

      | fn typecheck_v128_mem_store(st : TcState, ma : MemArg, nbits : Int) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1889 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      | 
      |   // pop value first
      |   let st1 = match st.pop_expect(ValType::v128()) {
 1896 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop address
      |   let st2 = match st1.pop_expect(at) {
 1902 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2)
      | }
      …

      | fn typecheck_v128_load_lane(st : TcState, ma : MemArg, nbits : Int) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1920 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      | 
      |   // pop existing vector (top of stack)
      |   let st1 = match st.pop_expect(ValType::v128()) {
 1927 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop address
      |   let st2 = match st1.pop_expect(at) {
 1933 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::v128()))
      | }
      …

      | fn typecheck_v128_store_lane(
      |   st : TcState,
      |   ma : MemArg,
      |   nbits : Int,
      | ) -> TcResult {
      |   let (_mem, lim) = match memarg_check(st, ma, MemIdx::new(0), nbits) {
 1946 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(x) => x
      |   }
      |   let at = lim.addr_valtype()
      | 
      |   // pop vector (top of stack)
      |   let st1 = match st.pop_expect(ValType::v128()) {
 1953 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop address
      |   let st2 = match st1.pop_expect(at) {
 1959 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2)
      | }
      …

      | fn typecheck_memory_grow(st : TcState, mem : MemIdx) -> TcResult {
      |   let at = match st.mem_at_of(mem) {
      |     Err(e) => return Err(e)
      |     Ok(t) => t
      |   }
      |   let st1 = match st.pop_expect(at) {
 1995 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(at))
      | }
      …

      | fn typecheck_memory_init(
      |   st : TcState,
      |   data : DataIdx,
      |   mem : MemIdx,
      | ) -> TcResult {
      |   if !st.env.has_data(data) {
      |     return Err("invalid data segment index")
      |   }
      |   let at = match st.mem_at_of(mem) {
      |     Err(e) => return Err(e)
      |     Ok(t) => t
      |   }
      | 
      |   // pop len:i32, src:i32, dst:at
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2017 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2021 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(at) {
 2025 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn typecheck_memory_copy(st : TcState, dst : MemIdx, src : MemIdx) -> TcResult {
      |   let MemType(lim1) = match st.env.get_memtype(dst) {
      |     None => return Err("invalid dest memory index")
      |     Some(mt) => mt
      |   }
      |   let MemType(lim2) = match st.env.get_memtype(src) {
 2046 |     None => return Err("invalid src memory index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(mt) => mt
      |   }
      |   let at1 = lim1.addr_valtype()
      |   let at2 = lim2.addr_valtype()
      |   let at_len = min_addr_valtype(lim1, lim2)
      | 
      |   // pop len, src, dst
      |   let st1 = match st.pop_expect(at_len) {
 2055 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(at2) {
 2059 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(at1) {
 2063 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn typecheck_memory_fill(st : TcState, mem : MemIdx) -> TcResult {
      |   let at = match st.mem_at_of(mem) {
      |     Err(e) => return Err(e)
      |     Ok(t) => t
      |   }
      | 
      |   // pop len:i32, val:i32, dst:at
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2078 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2082 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(at) {
 2086 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn typecheck_any_convert_extern(st : TcState) -> TcResult {
      |   let st1 = match st.pop_expect(ValType::externref()) {
 2095 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::anyref()))
      | }
      …

      | fn typecheck_extern_convert_any(st : TcState) -> TcResult {
      |   let st1 = match st.pop_expect(ValType::anyref()) {
 2104 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::externref()))
      | }
      …

      | fn typecheck_ref_i31(st : TcState) -> TcResult {
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2113 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::i31ref()))
      | }
      …

      | fn typecheck_i31_get(st : TcState) -> TcResult {
      |   let st1 = match st.pop_expect(ValType::i31ref_nullable()) {
 2122 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::i32()))
      | }
      …

      | fn typecheck_array_new(st : TcState, x : TypeIdx) -> TcResult {
      |   let FieldType(sto, _) = match st.env.resolve_array_field(x) {
 2131 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   let elem_vt = sto.unpack()
      | 
      |   // pop length : i32
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2138 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop init value : elem_vt
      |   let st2 = match st1.pop_expect(elem_vt) {
 2144 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::ref_array_nonnull(x)))
      | }
      …

      | fn typecheck_array_new_default(st : TcState, x : TypeIdx) -> TcResult {
      |   let FieldType(sto, _) = match st.env.resolve_array_field(x) {
 2153 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   let elem_vt = sto.unpack()
      |   if !has_default(elem_vt) {
 2158 |     return Err("array.new_default: no default for element type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2161 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::ref_array_nonnull(x)))
      | }
      …

      | fn typecheck_array_new_fixed(st : TcState, x : TypeIdx, n : U32) -> TcResult {
      |   let FieldType(sto, _) = match st.env.resolve_array_field(x) {
 2170 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   let elem_vt = sto.unpack()
      |   let U32(nu) = n
      |   let count = nu.reinterpret_as_int()
      |   if count < 0 {
 2177 |     return Err("array.new_fixed: negative length")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let mut cur = st
      |   // pop count times
      |   for _ in 0..<count {
      |     cur = match cur.pop_expect(elem_vt) {
 2183 |       Err(e) => return Err(e)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       Ok(s) => s
      |     }
      |   }
      |   Ok(cur.push1(ValType::ref_array_nonnull(x)))
      | }
      …

      | fn typecheck_array_get(st : TcState, x : TypeIdx) -> TcResult {
      |   let FieldType(sto, _) = match st.env.resolve_array_field(x) {
 2193 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   if sto.is_packed() {
 2197 |     return Err(
      |     ^^^^^^^^^^^ 	<-- UNCOVERED
      |       "array.get used on packed element; use array.get_s or array.get_u",
      |     )
      |   }
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2202 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::ref_array_nullable(x)) {
 2206 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(sto.unpack()))
      | }
      …

      | fn typecheck_array_get_s(st : TcState, x : TypeIdx) -> TcResult {
      |   let FieldType(sto, _) = match st.env.resolve_array_field(x) {
 2215 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   if !sto.is_packed() {
 2219 |     return Err("array.get_s requires packed element type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2222 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::ref_array_nullable(x)) {
 2226 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::i32()))
      | }
      …

      | fn typecheck_array_set(st : TcState, x : TypeIdx) -> TcResult {
      |   let ft = match st.env.resolve_array_field(x) {
 2241 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   if !ft.is_mutable() {
 2245 |     return Err("array.set on immutable array element type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(sto, _) = ft
      |   let elem_vt = sto.unpack()
      | 
      |   // pop value
      |   let st1 = match st.pop_expect(elem_vt) {
 2252 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop index
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2258 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop array ref
      |   let st3 = match st2.pop_expect(ValType::ref_array_nullable(x)) {
 2264 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st3)
      | }
      …

      | fn typecheck_array_len(st : TcState) -> TcResult {
      |   let want = ValType::ref_type(
      |     RefType::new(true, HeapType::abs(AbsHeapType::array())),
      |   )
      |   let st1 = match st.pop_expect(want) {
 2276 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st1.push1(ValType::i32()))
      | }
      …

      | fn typecheck_array_fill(st : TcState, x : TypeIdx) -> TcResult {
      |   let ft = match st.env.resolve_array_field(x) {
 2285 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   if !ft.is_mutable() {
 2289 |     return Err("array.fill on immutable array element type")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(sto, _) = ft
      |   let elem_vt = sto.unpack()
      | 
      |   // pop len
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2296 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop value
      |   let st2 = match st1.pop_expect(elem_vt) {
 2302 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop start
      |   let st3 = match st2.pop_expect(ValType::i32()) {
 2308 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop array ref
      |   let st4 = match st3.pop_expect(ValType::ref_null_array_of(x)) {
 2314 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st4)
      | }
      …

      | fn typecheck_array_copy(st : TcState, x : TypeIdx, y : TypeIdx) -> TcResult {
      |   let ft_x = match st.env.resolve_array_field(x) {
 2323 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   let ft_y = match st.env.resolve_array_field(y) {
 2327 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   if !ft_x.is_mutable() {
 2331 |     return Err("array.copy requires destination array to be mutable")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(sto_x, _) = ft_x
      |   let FieldType(sto_y, _) = ft_y
      |   let vx = sto_x.unpack()
      |   let vy = sto_y.unpack()
      |   if !Match::matches(vy, vx, st.env) {
 2338 |     return Err(
      |     ^^^^^^^^^^^ 	<-- UNCOVERED
      |       "array.copy source element type does not match destination element type",
      |     )
      |   }
      | 
      |   // pop len
      |   let st = match st.pop_expect(ValType::i32()) {
 2345 |     Err(t) => return Err(t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(t) => t
      |   }
      | 
      |   // pop src index
      |   let st = match st.pop_expect(ValType::i32()) {
 2351 |     Err(t) => return Err(t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(t) => t
      |   }
      | 
      |   // pop src array
      |   let st = match st.pop_expect(ValType::ref_null_array_of(y)) {
 2357 |     Err(t) => return Err(t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(t) => t
      |   }
      | 
      |   // pop dst index
      |   let st = match st.pop_expect(ValType::i32()) {
 2363 |     Err(t) => return Err(t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(t) => t
      |   }
      | 
      |   // pop dst array
      |   let st = match st.pop_expect(ValType::ref_null_array_of(x)) {
 2369 |     Err(t) => return Err(t)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(t) => t
      |   }
      |   Ok(st)
      | }
      …

      | fn typecheck_array_init_data(
      |   st : TcState,
      |   x : TypeIdx,
      |   y : DataIdx,
      | ) -> TcResult {
      |   if !st.env.has_data(y) {
 2382 |     return Err("invalid data segment index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let ft = match st.env.resolve_array_field(x) {
 2385 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   if !ft.is_mutable() {
 2389 |     return Err("array.init_data requires array element to be mutable")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(sto, _) = ft
      |   let vt = sto.unpack()
      |   match vt {
      |     NumTypeValType(_) => ()
 2395 |     VecTypeValType => ()
      |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     _ =>
 2397 |       return Err(
      |       ^^^^^^^^^^^ 	<-- UNCOVERED
      |         "array.init_data requires unpack(element) to be numtype or vectype",
      |       )
      |   }
      | 
      |   // Stack: (ref null x) i32 i32 i32 -> ε
      |   // pop len, src, dst
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2405 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2409 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(ValType::i32()) {
 2413 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop array ref
      |   let st4 = match st3.pop_expect(ValType::ref_null_array_of(x)) {
 2419 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st4)
      | }
      …

      | fn typecheck_array_init_elem(
      |   st : TcState,
      |   x : TypeIdx,
      |   y : ElemIdx,
      | ) -> TcResult {
      |   let elem = match st.env.get_elem(y) {
 2432 |     None => return Err("invalid elem segment index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(e) => e
      |   }
      |   let ft = match st.env.resolve_array_field(x) {
 2436 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(f) => f
      |   }
      |   if !ft.is_mutable() {
 2440 |     return Err("array.init_elem requires array element to be mutable")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(sto, _) = ft
      | 
      |   // Spec: C.elems[y] ≤ zt (storage type), so storage type must be a ref valtype.
      |   let rt_array = match sto {
      |     ValTypeStorageType(RefTypeValType(rt)) => rt
      |     _ =>
 2448 |       return Err(
      |       ^^^^^^^^^^^ 	<-- UNCOVERED
      |         "array.init_elem requires array storage type to be a reference type",
      |       )
      |   }
      |   let rt_seg = elem.reftype()
      |   if !Match::matches(rt_seg, rt_array, st.env) {
 2454 |     return Err(
      |     ^^^^^^^^^^^ 	<-- UNCOVERED
      |       "array.init_elem elem segment type does not match array storage type",
      |     )
      |   }
      | 
      |   // Stack: (ref null x) i32 i32 i32 -> ε
      |   // pop len, src, dst
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2462 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2466 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st3 = match st2.pop_expect(ValType::i32()) {
 2470 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      | 
      |   // pop array ref
      |   let st4 = match st3.pop_expect(ValType::ref_null_array_of(x)) {
 2476 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st4)
      | }
      …

      | fn typecheck_array_new_elem(st : TcState, x : TypeIdx, y : ElemIdx) -> TcResult {
      |   let elem = match st.env.get_elem(y) {
 2485 |     None => return Err("invalid elem segment index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Some(e) => e
      |   }
      |   let FieldType(sto, _mut) = match st.env.resolve_array_field(x) {
 2489 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   let rt_array = match sto {
      |     ValTypeStorageType(RefTypeValType(rt)) => rt
      |     _ =>
 2495 |       return Err(
      |       ^^^^^^^^^^^ 	<-- UNCOVERED
      |         "array.new_elem requires array element storage type to be a reftype",
      |       )
      |   }
      |   let rt_seg = elem.reftype()
      |   if !Match::matches(rt_seg, rt_array, st.env) {
 2501 |     return Err(
      |     ^^^^^^^^^^^ 	<-- UNCOVERED
      |       "array.new_elem elem segment type does not match array element reftype",
      |     )
      |   }
      | 
      |   // Stack: i32 i32 -> (ref x)
      |   // (the two i32 are typically src and len; order doesn't matter for typing as both are i32)
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2509 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2513 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::ref_array_nonnull(x)))
      | }
      …

      | fn typecheck_array_new_data(st : TcState, x : TypeIdx, y : DataIdx) -> TcResult {
      |   if !st.env.has_data(y) {
 2522 |     return Err("invalid data segment index")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      |   let FieldType(sto, _mut) = match st.env.resolve_array_field(x) {
 2525 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(ft) => ft
      |   }
      |   let vt = sto.unpack()
      |   match vt {
      |     NumTypeValType(_) => ()
 2531 |     VecTypeValType => ()
      |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     _ =>
 2533 |       return Err(
      |       ^^^^^^^^^^^ 	<-- UNCOVERED
      |         "array.new_data requires unpack(element) to be numtype or vectype",
      |       )
      |   }
      | 
      |   // Stack: i32 i32 -> (ref x)
      |   let st1 = match st.pop_expect(ValType::i32()) {
 2540 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   let st2 = match st1.pop_expect(ValType::i32()) {
 2544 |     Err(e) => return Err(e)
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Ok(s) => s
      |   }
      |   Ok(st2.push1(ValType::ref_array_nonnull(x)))
      | }
      …

      | pub impl Typecheck for Instruction with typecheck(self, st) {
      |   match self {
      |     Unreachable => Ok(TcState::{ ..st, reachable: false })
      |     Nop => Ok(st)
      |     I32Const(_) => Ok(st.push1(ValType::i32()))
      |     I64Const(_) => Ok(st.push1(ValType::i64()))
      |     F32Const(_) => Ok(st.push1(ValType::f32()))
      |     F64Const(_) => Ok(st.push1(ValType::f64()))
      |     I32Load(ma) => typecheck_load(st, ma, 32, ValType::i32())
      |     I64Load(ma) => typecheck_load(st, ma, 64, ValType::i64())
      |     F32Load(ma) => typecheck_load(st, ma, 32, ValType::f32())
      |     F64Load(ma) => typecheck_load(st, ma, 64, ValType::f64())
      |     I32Load8S(ma) => typecheck_load(st, ma, 8, ValType::i32())
      |     I32Load8U(ma) => typecheck_load(st, ma, 8, ValType::i32())
      |     I32Load16S(ma) => typecheck_load(st, ma, 16, ValType::i32())
      |     I32Load16U(ma) => typecheck_load(st, ma, 16, ValType::i32())
      |     I64Load8S(ma) => typecheck_load(st, ma, 8, ValType::i64())
      |     I64Load8U(ma) => typecheck_load(st, ma, 8, ValType::i64())
      |     I64Load16S(ma) => typecheck_load(st, ma, 16, ValType::i64())
      |     I64Load16U(ma) => typecheck_load(st, ma, 16, ValType::i64())
      |     I64Load32S(ma) => typecheck_load(st, ma, 32, ValType::i64())
      |     I64Load32U(ma) => typecheck_load(st, ma, 32, ValType::i64())
      |     I32AtomicLoad(ma) => typecheck_load(st, ma, 32, ValType::i32())
 2574 |     I64AtomicLoad(ma) => typecheck_load(st, ma, 64, ValType::i64())
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     I32AtomicLoad8U(ma) => typecheck_load(st, ma, 8, ValType::i32())
      |     I32AtomicLoad16U(ma) => typecheck_load(st, ma, 16, ValType::i32())
      |     I64AtomicLoad8U(ma) => typecheck_load(st, ma, 8, ValType::i64())
      |     I64AtomicLoad16U(ma) => typecheck_load(st, ma, 16, ValType::i64())
      |     I64AtomicLoad32U(ma) => typecheck_load(st, ma, 32, ValType::i64())
      |     I32Store(ma) => typecheck_store(st, ma, 32, ValType::i32())
      |     I64Store(ma) => typecheck_store(st, ma, 64, ValType::i64())
      |     F32Store(ma) => typecheck_store(st, ma, 32, ValType::f32())
      |     F64Store(ma) => typecheck_store(st, ma, 64, ValType::f64())
      |     I32Store8(ma) => typecheck_store(st, ma, 8, ValType::i32())
      |     I32Store16(ma) => typecheck_store(st, ma, 16, ValType::i32())
      |     I64Store8(ma) => typecheck_store(st, ma, 8, ValType::i64())
      |     I64Store16(ma) => typecheck_store(st, ma, 16, ValType::i64())
      |     I64Store32(ma) => typecheck_store(st, ma, 32, ValType::i64())
      |     I32AtomicStore(ma) => typecheck_store(st, ma, 32, ValType::i32())
 2590 |     I64AtomicStore(ma) => typecheck_store(st, ma, 64, ValType::i64())
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     I32AtomicStore8(ma) => typecheck_store(st, ma, 8, ValType::i32())
      |     I32AtomicStore16(ma) => typecheck_store(st, ma, 16, ValType::i32())
      |     I64AtomicStore8(ma) => typecheck_store(st, ma, 8, ValType::i64())
      |     I64AtomicStore16(ma) => typecheck_store(st, ma, 16, ValType::i64())
      |     I64AtomicStore32(ma) => typecheck_store(st, ma, 32, ValType::i64())
      |     Drop => typecheck_drop(st)
      |     Select(None) => typecheck_select_untyped(st)
      |     Select(Some(ts)) => typecheck_select_typed(st, ts)
      |     LocalGet(i) => typecheck_local_get(st, i)
      |     LocalSet(i) => typecheck_local_set(st, i)
      |     LocalTee(i) => typecheck_local_tee(st, i)
      |     GlobalGet(i) => typecheck_global_get(st, i)
      |     GlobalSet(i) => typecheck_global_set(st, i)
      |     TableGet(i) => typecheck_table_get(st, i)
      |     TableSet(i) => typecheck_table_set(st, i)
      |     TableSize(i) => typecheck_table_size(st, i)
      |     TableGrow(i) => typecheck_table_grow(st, i)
      |     TableCopy(i0, i1) => typecheck_table_copy(st, i0, i1)
      |     TableInit(x, y) => typecheck_table_init(st, x, y)
      |     TableFill(x) => typecheck_table_fill(st, x)
      |     ElemDrop(y) => typecheck_elem_drop(st, y)
      |     MemorySize(m) => typecheck_memory_size(st, m)
      |     MemoryGrow(m) => typecheck_memory_grow(st, m)
      |     MemoryAtomicNotify(ma) => typecheck_atomic_notify(st, ma)
      |     MemoryAtomicWait32(ma) => typecheck_atomic_wait(st, ma, 32, ValType::i32())
      |     MemoryAtomicWait64(ma) => typecheck_atomic_wait(st, ma, 64, ValType::i64())
      |     AtomicFence => Ok(st)
      |     MemoryInit(d, m) => typecheck_memory_init(st, d, m)
      |     DataDrop(d) => typecheck_data_drop(st, d)
      |     MemoryCopy(d, s) => typecheck_memory_copy(st, d, s)
      |     MemoryFill(m) => typecheck_memory_fill(st, m)
      |     AtomicRmw(op, ma) =>
      |       match op {
      |         I32AtomicRmwAddOp => typecheck_atomic_rmw(st, ma, 32, ValType::i32())
 2625 |         I64AtomicRmwAddOp => typecheck_atomic_rmw(st, ma, 64, ValType::i64())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmw8AddUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i32())
      |         I32AtomicRmw16AddUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i32())
      |         I64AtomicRmw8AddUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i64())
      |         I64AtomicRmw16AddUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i64())
      |         I64AtomicRmw32AddUOp => typecheck_atomic_rmw(st, ma, 32, ValType::i64())
      |         I32AtomicRmwSubOp => typecheck_atomic_rmw(st, ma, 32, ValType::i32())
      |         I64AtomicRmwSubOp => typecheck_atomic_rmw(st, ma, 64, ValType::i64())
      |         I32AtomicRmw8SubUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i32())
      |         I32AtomicRmw16SubUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i32())
      |         I64AtomicRmw8SubUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i64())
      |         I64AtomicRmw16SubUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i64())
      |         I64AtomicRmw32SubUOp => typecheck_atomic_rmw(st, ma, 32, ValType::i64())
      |         I32AtomicRmwAndOp => typecheck_atomic_rmw(st, ma, 32, ValType::i32())
      |         I64AtomicRmwAndOp => typecheck_atomic_rmw(st, ma, 64, ValType::i64())
      |         I32AtomicRmw8AndUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i32())
      |         I32AtomicRmw16AndUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i32())
      |         I64AtomicRmw8AndUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i64())
      |         I64AtomicRmw16AndUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i64())
      |         I64AtomicRmw32AndUOp => typecheck_atomic_rmw(st, ma, 32, ValType::i64())
      |         I32AtomicRmwOrOp => typecheck_atomic_rmw(st, ma, 32, ValType::i32())
      |         I64AtomicRmwOrOp => typecheck_atomic_rmw(st, ma, 64, ValType::i64())
      |         I32AtomicRmw8OrUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i32())
      |         I32AtomicRmw16OrUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i32())
      |         I64AtomicRmw8OrUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i64())
      |         I64AtomicRmw16OrUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i64())
      |         I64AtomicRmw32OrUOp => typecheck_atomic_rmw(st, ma, 32, ValType::i64())
      |         I32AtomicRmwXorOp => typecheck_atomic_rmw(st, ma, 32, ValType::i32())
      |         I64AtomicRmwXorOp => typecheck_atomic_rmw(st, ma, 64, ValType::i64())
      |         I32AtomicRmw8XorUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i32())
      |         I32AtomicRmw16XorUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i32())
      |         I64AtomicRmw8XorUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i64())
      |         I64AtomicRmw16XorUOp => typecheck_atomic_rmw(st, ma, 16, ValType::i64())
      |         I64AtomicRmw32XorUOp => typecheck_atomic_rmw(st, ma, 32, ValType::i64())
      |         I32AtomicRmwXchgOp => typecheck_atomic_rmw(st, ma, 32, ValType::i32())
      |         I64AtomicRmwXchgOp => typecheck_atomic_rmw(st, ma, 64, ValType::i64())
      |         I32AtomicRmw8XchgUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i32())
      |         I32AtomicRmw16XchgUOp =>
 2663 |           typecheck_atomic_rmw(st, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8XchgUOp => typecheck_atomic_rmw(st, ma, 8, ValType::i64())
      |         I64AtomicRmw16XchgUOp =>
 2666 |           typecheck_atomic_rmw(st, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32XchgUOp =>
 2668 |           typecheck_atomic_rmw(st, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |     AtomicCmpxchg(op, ma) =>
      |       match op {
      |         I32AtomicRmwCmpxchgOp =>
 2673 |           typecheck_atomic_cmpxchg(st, ma, 32, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmwCmpxchgOp =>
      |           typecheck_atomic_cmpxchg(st, ma, 64, ValType::i64())
      |         I32AtomicRmw8CmpxchgUOp =>
 2677 |           typecheck_atomic_cmpxchg(st, ma, 8, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmw16CmpxchgUOp =>
 2679 |           typecheck_atomic_cmpxchg(st, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8CmpxchgUOp =>
 2681 |           typecheck_atomic_cmpxchg(st, ma, 8, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw16CmpxchgUOp =>
 2683 |           typecheck_atomic_cmpxchg(st, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32CmpxchgUOp =>
 2685 |           typecheck_atomic_cmpxchg(st, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |     Br(l) => typecheck_br(st, l)
      |     Block(bt, e) => typecheck_block(st, bt, e)
      |     If(bt, th, el) => typecheck_if(st, bt, th, el)
      |     BrIf(l) => typecheck_br_if(st, l)
      |     BrTable(ls, ldef) => typecheck_br_table(st, ls, ldef)
      |     BrOnNull(l) => typecheck_br_on_null(st, l)
      |     BrOnNonNull(l) => typecheck_br_on_non_null(st, l)
      |     BrOnCast(l, op, ht1, ht2) => typecheck_br_on_cast(st, l, op, ht1, ht2)
      |     BrOnCastFail(l, op, ht1, ht2) =>
      |       typecheck_br_on_cast_fail(st, l, op, ht1, ht2)
      |     Return => typecheck_return(st)
      |     Call(f) => typecheck_call(st, f)
      |     CallIndirect(tidx, t) => typecheck_call_indirect(st, tidx, t)
      |     CallRef(tidx) => typecheck_call_ref(st, tidx)
      |     ReturnCall(fidx) => typecheck_return_call(st, fidx)
      |     ReturnCallIndirect(tidx, t) => typecheck_return_call_indirect(st, tidx, t)
      |     ReturnCallRef(tidx) => typecheck_return_call_ref(st, tidx)
      |     Throw(t) => typecheck_throw(st, t)
      |     ThrowRef => typecheck_throw_ref(st)
      |     TryTable(bt, cs, e) => typecheck_try_table(st, bt, cs, e)
      |     Loop(bt, e) => typecheck_loop(st, bt, e)
      |     RefNull(ht) => typecheck_ref_null(st, ht)
      |     RefIsNull => typecheck_ref_is_null(st)
      |     RefFunc(f) => typecheck_ref_func(st, f)
      |     RefAsNonNull => typecheck_ref_as_non_null(st)
      |     RefEq => typecheck_ref_eq(st)
      |     RefGetDesc => typecheck_ref_get_desc(st)
      |     RefTest(nullable, ht) => typecheck_ref_test(st, nullable, ht)
      |     RefCast(nullable, ht) => typecheck_ref_cast(st, nullable, ht)
      |     RefTestDesc(nullable, ht) => typecheck_ref_test_desc(st, nullable, ht)
      |     RefCastDescEq(nullable, ht) => typecheck_ref_cast_desc_eq(st, nullable, ht)
      |     AnyConvertExtern => typecheck_any_convert_extern(st)
      |     ExternConvertAny => typecheck_extern_convert_any(st)
      |     RefI31 => typecheck_ref_i31(st)
      |     I31GetS => typecheck_i31_get(st)
      |     I31GetU => typecheck_i31_get(st)
      |     StructNew(x) => typecheck_struct_new(st, x)
      |     StructNewDefault(x) => typecheck_struct_new_default(st, x)
      |     StructGet(x, i) => typecheck_struct_get(st, x, i)
      |     StructGetS(x, i) => typecheck_struct_get_s(st, x, i)
      |     StructGetU(x, i) => typecheck_struct_get_u(st, x, i)
      |     StructSet(x, i) => typecheck_struct_set(st, x, i)
      |     ArrayNew(x) => typecheck_array_new(st, x)
      |     ArrayNewDefault(x) => typecheck_array_new_default(st, x)
      |     ArrayNewFixed(x, n) => typecheck_array_new_fixed(st, x, n)
      |     ArrayGet(x) => typecheck_array_get(st, x)
      |     ArrayGetS(x) => typecheck_array_get_s(st, x)
      |     ArrayGetU(x) => typecheck_array_get_u(st, x)
      |     ArraySet(x) => typecheck_array_set(st, x)
      |     ArrayLen => typecheck_array_len(st)
      |     ArrayFill(x) => typecheck_array_fill(st, x)
      |     ArrayCopy(x, y) => typecheck_array_copy(st, x, y)
      |     ArrayInitData(x, y) => typecheck_array_init_data(st, x, y)
      |     ArrayInitElem(x, y) => typecheck_array_init_elem(st, x, y)
      |     ArrayNewElem(x, y) => typecheck_array_new_elem(st, x, y)
      |     ArrayNewData(x, y) => typecheck_array_new_data(st, x, y)
      | 
      |     // ===== i32 relational =====
      |     I32Eqz => typecheck_unary(st, ValType::i32(), ValType::i32())
      |     I32Eq => typecheck_compare(st, ValType::i32())
      |     I32Ne => typecheck_compare(st, ValType::i32())
      |     I32LtS => typecheck_compare(st, ValType::i32())
      |     I32LtU => typecheck_compare(st, ValType::i32())
      |     I32GtS => typecheck_compare(st, ValType::i32())
      |     I32GtU => typecheck_compare(st, ValType::i32())
      |     I32LeS => typecheck_compare(st, ValType::i32())
      |     I32LeU => typecheck_compare(st, ValType::i32())
      |     I32GeS => typecheck_compare(st, ValType::i32())
      |     I32GeU => typecheck_compare(st, ValType::i32())
      | 
      |     // ===== i64 relational =====
      |     I64Eqz => typecheck_unary(st, ValType::i64(), ValType::i32())
      |     I64Eq => typecheck_compare(st, ValType::i64())
      |     I64Ne => typecheck_compare(st, ValType::i64())
      |     I64LtS => typecheck_compare(st, ValType::i64())
      |     I64LtU => typecheck_compare(st, ValType::i64())
      |     I64GtS => typecheck_compare(st, ValType::i64())
      |     I64GtU => typecheck_compare(st, ValType::i64())
      |     I64LeS => typecheck_compare(st, ValType::i64())
      |     I64LeU => typecheck_compare(st, ValType::i64())
      |     I64GeS => typecheck_compare(st, ValType::i64())
      |     I64GeU => typecheck_compare(st, ValType::i64())
      | 
      |     // ===== f32 relational =====
      |     F32Eq => typecheck_compare(st, ValType::f32())
      |     F32Ne => typecheck_compare(st, ValType::f32())
      |     F32Lt => typecheck_compare(st, ValType::f32())
      |     F32Gt => typecheck_compare(st, ValType::f32())
      |     F32Le => typecheck_compare(st, ValType::f32())
      |     F32Ge => typecheck_compare(st, ValType::f32())
      | 
      |     // ===== f64 relational =====
      |     F64Eq => typecheck_compare(st, ValType::f64())
      |     F64Ne => typecheck_compare(st, ValType::f64())
      |     F64Lt => typecheck_compare(st, ValType::f64())
      |     F64Gt => typecheck_compare(st, ValType::f64())
      |     F64Le => typecheck_compare(st, ValType::f64())
      |     F64Ge => typecheck_compare(st, ValType::f64())
      | 
      |     // ===== i32 unary =====
      |     I32Clz => typecheck_unary(st, ValType::i32(), ValType::i32())
      |     I32Ctz => typecheck_unary(st, ValType::i32(), ValType::i32())
      |     I32Popcnt => typecheck_unary(st, ValType::i32(), ValType::i32())
      | 
      |     // ===== i64 unary =====
      |     I64Clz => typecheck_unary(st, ValType::i64(), ValType::i64())
      |     I64Ctz => typecheck_unary(st, ValType::i64(), ValType::i64())
      |     I64Popcnt => typecheck_unary(st, ValType::i64(), ValType::i64())
      | 
      |     // ===== i32 binary =====
      |     I32Add => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Sub => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Mul => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32DivS => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32DivU => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32RemS => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32RemU => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32And => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Or => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Xor => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Shl => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32ShrS => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32ShrU => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Rotl => typecheck_binary(st, ValType::i32(), ValType::i32())
      |     I32Rotr => typecheck_binary(st, ValType::i32(), ValType::i32())
      | 
      |     // ===== i64 binary =====
      |     I64Add => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Sub => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Mul => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64DivS => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64DivU => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64RemS => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64RemU => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64And => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Or => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Xor => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Shl => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64ShrS => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64ShrU => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Rotl => typecheck_binary(st, ValType::i64(), ValType::i64())
      |     I64Rotr => typecheck_binary(st, ValType::i64(), ValType::i64())
      | 
      |     // ===== f32 unary =====
      |     F32Abs => typecheck_unary(st, ValType::f32(), ValType::f32())
      |     F32Neg => typecheck_unary(st, ValType::f32(), ValType::f32())
      |     F32Ceil => typecheck_unary(st, ValType::f32(), ValType::f32())
      |     F32Floor => typecheck_unary(st, ValType::f32(), ValType::f32())
      |     F32Trunc => typecheck_unary(st, ValType::f32(), ValType::f32())
      |     F32Nearest => typecheck_unary(st, ValType::f32(), ValType::f32())
      |     F32Sqrt => typecheck_unary(st, ValType::f32(), ValType::f32())
      | 
      |     // ===== f32 binary =====
      |     F32Add => typecheck_binary(st, ValType::f32(), ValType::f32())
      |     F32Sub => typecheck_binary(st, ValType::f32(), ValType::f32())
      |     F32Mul => typecheck_binary(st, ValType::f32(), ValType::f32())
      |     F32Div => typecheck_binary(st, ValType::f32(), ValType::f32())
      |     F32Min => typecheck_binary(st, ValType::f32(), ValType::f32())
      |     F32Max => typecheck_binary(st, ValType::f32(), ValType::f32())
      |     F32Copysign => typecheck_binary(st, ValType::f32(), ValType::f32())
      | 
      |     // ===== f64 unary =====
      |     F64Abs => typecheck_unary(st, ValType::f64(), ValType::f64())
      |     F64Neg => typecheck_unary(st, ValType::f64(), ValType::f64())
      |     F64Ceil => typecheck_unary(st, ValType::f64(), ValType::f64())
      |     F64Floor => typecheck_unary(st, ValType::f64(), ValType::f64())
      |     F64Trunc => typecheck_unary(st, ValType::f64(), ValType::f64())
      |     F64Nearest => typecheck_unary(st, ValType::f64(), ValType::f64())
      |     F64Sqrt => typecheck_unary(st, ValType::f64(), ValType::f64())
      | 
      |     // ===== f64 binary =====
      |     F64Add => typecheck_binary(st, ValType::f64(), ValType::f64())
      |     F64Sub => typecheck_binary(st, ValType::f64(), ValType::f64())
      |     F64Mul => typecheck_binary(st, ValType::f64(), ValType::f64())
      |     F64Div => typecheck_binary(st, ValType::f64(), ValType::f64())
      |     F64Min => typecheck_binary(st, ValType::f64(), ValType::f64())
      |     F64Max => typecheck_binary(st, ValType::f64(), ValType::f64())
      |     F64Copysign => typecheck_binary(st, ValType::f64(), ValType::f64())
      | 
      |     // ===== conversions / reinterprets =====
      | 
      |     // i32.wrap_i64 : i64 -> i32
      |     I32WrapI64 => typecheck_unary(st, ValType::i64(), ValType::i32())
      | 
      |     // i32.trunc_f32/f64_{s,u} : f32/f64 -> i32
      |     I32TruncF32S => typecheck_unary(st, ValType::f32(), ValType::i32())
      |     I32TruncF32U => typecheck_unary(st, ValType::f32(), ValType::i32())
      |     I32TruncF64S => typecheck_unary(st, ValType::f64(), ValType::i32())
      |     I32TruncF64U => typecheck_unary(st, ValType::f64(), ValType::i32())
      | 
      |     // i64.extend_i32_{s,u} : i32 -> i64
      |     I64ExtendI32S => typecheck_unary(st, ValType::i32(), ValType::i64())
      |     I64ExtendI32U => typecheck_unary(st, ValType::i32(), ValType::i64())
      | 
      |     // i64.trunc_f32/f64_{s,u} : f32/f64 -> i64
      |     I64TruncF32S => typecheck_unary(st, ValType::f32(), ValType::i64())
      |     I64TruncF32U => typecheck_unary(st, ValType::f32(), ValType::i64())
      |     I64TruncF64S => typecheck_unary(st, ValType::f64(), ValType::i64())
      |     I64TruncF64U => typecheck_unary(st, ValType::f64(), ValType::i64())
      | 
      |     // f32.convert_i32/i64_{s,u} : i32/i64 -> f32
      |     F32ConvertI32S => typecheck_unary(st, ValType::i32(), ValType::f32())
      |     F32ConvertI32U => typecheck_unary(st, ValType::i32(), ValType::f32())
      |     F32ConvertI64S => typecheck_unary(st, ValType::i64(), ValType::f32())
      |     F32ConvertI64U => typecheck_unary(st, ValType::i64(), ValType::f32())
      | 
      |     // f32.demote_f64 : f64 -> f32
      |     F32DemoteF64 => typecheck_unary(st, ValType::f64(), ValType::f32())
      | 
      |     // f64.convert_i32/i64_{s,u} : i32/i64 -> f64
      |     F64ConvertI32S => typecheck_unary(st, ValType::i32(), ValType::f64())
      |     F64ConvertI32U => typecheck_unary(st, ValType::i32(), ValType::f64())
      |     F64ConvertI64S => typecheck_unary(st, ValType::i64(), ValType::f64())
      |     F64ConvertI64U => typecheck_unary(st, ValType::i64(), ValType::f64())
      | 
      |     // f64.promote_f32 : f32 -> f64
      |     F64PromoteF32 => typecheck_unary(st, ValType::f32(), ValType::f64())
      | 
      |     // reinterprets
      |     I32ReinterpretF32 => typecheck_unary(st, ValType::f32(), ValType::i32())
      |     I64ReinterpretF64 => typecheck_unary(st, ValType::f64(), ValType::i64())
      |     F32ReinterpretI32 => typecheck_unary(st, ValType::i32(), ValType::f32())
      |     F64ReinterpretI64 => typecheck_unary(st, ValType::i64(), ValType::f64())
      | 
      |     // sign-extension (unary)
      |     I32Extend8S => typecheck_unary(st, ValType::i32(), ValType::i32())
      |     I32Extend16S => typecheck_unary(st, ValType::i32(), ValType::i32())
      |     I64Extend8S => typecheck_unary(st, ValType::i64(), ValType::i64())
      |     I64Extend16S => typecheck_unary(st, ValType::i64(), ValType::i64())
      |     I64Extend32S => typecheck_unary(st, ValType::i64(), ValType::i64())
      | 
      |     // saturating trunc (same typing as trunc)
      |     I32TruncSatF32S => typecheck_unary(st, ValType::f32(), ValType::i32())
      |     I32TruncSatF32U => typecheck_unary(st, ValType::f32(), ValType::i32())
      |     I32TruncSatF64S => typecheck_unary(st, ValType::f64(), ValType::i32())
      |     I32TruncSatF64U => typecheck_unary(st, ValType::f64(), ValType::i32())
      |     I64TruncSatF32S => typecheck_unary(st, ValType::f32(), ValType::i64())
      |     I64TruncSatF32U => typecheck_unary(st, ValType::f32(), ValType::i64())
      |     I64TruncSatF64S => typecheck_unary(st, ValType::f64(), ValType::i64())
      |     I64TruncSatF64U => typecheck_unary(st, ValType::f64(), ValType::i64())
      |     V128Not => typecheck_v128_unary(st)
      |     V128And => typecheck_v128_binary(st)
      |     V128Andnot => typecheck_v128_binary(st)
      |     V128Or => typecheck_v128_binary(st)
      |     V128Xor => typecheck_v128_binary(st)
      |     V128Bitselect => typecheck_v128_ternary(st)
      |     V128AnyTrue => typecheck_unary(st, ValType::v128(), ValType::i32())
      | 
      |     // Plain v128 load/store
      |     V128Load(ma) => typecheck_v128_mem_load(st, ma, 128)
      |     V128Store(ma) => typecheck_v128_mem_store(st, ma, 128)
      | 
      |     // Load and extend (64-bit loads)
      |     V128Load8x8S(ma) => typecheck_v128_mem_load_extend64(st, ma)
      |     V128Load8x8U(ma) => typecheck_v128_mem_load_extend64(st, ma)
      |     V128Load16x4S(ma) => typecheck_v128_mem_load_extend64(st, ma)
      |     V128Load16x4U(ma) => typecheck_v128_mem_load_extend64(st, ma)
      |     V128Load32x2S(ma) => typecheck_v128_mem_load_extend64(st, ma)
      |     V128Load32x2U(ma) => typecheck_v128_mem_load_extend64(st, ma)
      | 
      |     // Splat loads
      |     V128Load8Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 8)
      |     V128Load16Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 16)
      |     V128Load32Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 32)
      |     V128Load64Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 64)
      | 
      |     // Lane loads
      |     V128Load8Lane(ma, _) => typecheck_v128_load_lane(st, ma, 8)
 2955 |     V128Load16Lane(ma, _) => typecheck_v128_load_lane(st, ma, 16)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     V128Load32Lane(ma, _) => typecheck_v128_load_lane(st, ma, 32)
      |     V128Load64Lane(ma, _) => typecheck_v128_load_lane(st, ma, 64)
      | 
      |     // Lane stores
      |     V128Store8Lane(ma, _) => typecheck_v128_store_lane(st, ma, 8)
      |     V128Store16Lane(ma, _) => typecheck_v128_store_lane(st, ma, 16)
      |     V128Store32Lane(ma, _) => typecheck_v128_store_lane(st, ma, 32)
      |     V128Store64Lane(ma, _) => typecheck_v128_store_lane(st, ma, 64)
      | 
      |     // load*_zero
      |     V128Load32Zero(ma) => typecheck_v128_mem_load_zero(st, ma, 32)
      |     V128Load64Zero(ma) => typecheck_v128_mem_load_zero(st, ma, 64)
      |     V128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
      |       typecheck_v128_const(st)
      |     I8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
      |       // v128 v128 -> v128
      |       typecheck_v128_binary(st)
      |     I8x16Swizzle => typecheck_v128_binary(st) // v128 v128 -> v128
      |     I8x16Splat => typecheck_splat(st, ValType::i32()) // i32 -> v128 (only low 8 bits used)
      |     I16x8Splat => typecheck_splat(st, ValType::i32()) // i32 -> v128
      |     I32x4Splat => typecheck_splat(st, ValType::i32()) // i32 -> v128
      |     I64x2Splat => typecheck_splat(st, ValType::i64()) // i64 -> v128
      |     F32x4Splat => typecheck_splat(st, ValType::f32()) // f32 -> v128
      |     F64x2Splat => typecheck_splat(st, ValType::f64()) // f64 -> v128
      |     I8x16ExtractLaneS(_) => typecheck_lane_extract(st, ValType::i32())
 2981 |     I8x16ExtractLaneU(_) => typecheck_lane_extract(st, ValType::i32())
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     I16x8ExtractLaneS(_) => typecheck_lane_extract(st, ValType::i32())
      |     I16x8ExtractLaneU(_) => typecheck_lane_extract(st, ValType::i32())
      |     I32x4ExtractLane(_) => typecheck_lane_extract(st, ValType::i32())
      |     I64x2ExtractLane(_) => typecheck_lane_extract(st, ValType::i64())
      |     F32x4ExtractLane(_) => typecheck_lane_extract(st, ValType::f32())
      |     F64x2ExtractLane(_) => typecheck_lane_extract(st, ValType::f64())
      |     I8x16ReplaceLane(_) => typecheck_lane_replace(st, ValType::i32())
      |     I16x8ReplaceLane(_) => typecheck_lane_replace(st, ValType::i32())
      |     I32x4ReplaceLane(_) => typecheck_lane_replace(st, ValType::i32())
      |     I64x2ReplaceLane(_) => typecheck_lane_replace(st, ValType::i64())
      |     F32x4ReplaceLane(_) => typecheck_lane_replace(st, ValType::f32())
      |     F64x2ReplaceLane(_) => typecheck_lane_replace(st, ValType::f64())
      |     I8x16Eq => typecheck_v128_compare(st)
 2995 |     I8x16Ne => typecheck_v128_compare(st)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     I8x16LtS => typecheck_v128_compare(st)
      |     I8x16LtU => typecheck_v128_compare(st)
      |     I8x16GtS => typecheck_v128_compare(st)
      |     I8x16GtU => typecheck_v128_compare(st)
      |     I8x16LeS => typecheck_v128_compare(st)
      |     I8x16LeU => typecheck_v128_compare(st)
      |     I8x16GeS => typecheck_v128_compare(st)
      |     I8x16GeU => typecheck_v128_compare(st)
      |     I16x8Eq => typecheck_v128_compare(st)
      |     I16x8Ne => typecheck_v128_compare(st)
      |     I16x8LtS => typecheck_v128_compare(st)
 3007 |     I16x8LtU => typecheck_v128_compare(st)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     I16x8GtS => typecheck_v128_compare(st)
      |     I16x8GtU => typecheck_v128_compare(st)
      |     I16x8LeS => typecheck_v128_compare(st)
      |     I16x8LeU => typecheck_v128_compare(st)
      |     I16x8GeS => typecheck_v128_compare(st)
      |     I16x8GeU => typecheck_v128_compare(st)
      |     I32x4Eq => typecheck_v128_compare(st)
      |     I32x4Ne => typecheck_v128_compare(st)
      |     I32x4LtS => typecheck_v128_compare(st)
      |     I32x4LtU => typecheck_v128_compare(st)
      |     I32x4GtS => typecheck_v128_compare(st)
      |     I32x4GtU => typecheck_v128_compare(st)
 3020 |     I32x4LeS => typecheck_v128_compare(st)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     I32x4LeU => typecheck_v128_compare(st)
      |     I32x4GeS => typecheck_v128_compare(st)
      |     I32x4GeU => typecheck_v128_compare(st)
      |     F32x4Eq => typecheck_v128_compare(st)
      |     F32x4Ne => typecheck_v128_compare(st)
      |     F32x4Lt => typecheck_v128_compare(st)
      |     F32x4Gt => typecheck_v128_compare(st)
      |     F32x4Le => typecheck_v128_compare(st)
 3029 |     F32x4Ge => typecheck_v128_compare(st)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     F64x2Eq => typecheck_v128_compare(st)
      |     F64x2Ne => typecheck_v128_compare(st)
      |     F64x2Lt => typecheck_v128_compare(st)
      |     F64x2Gt => typecheck_v128_compare(st)
      |     F64x2Le => typecheck_v128_compare(st)
      |     F64x2Ge => typecheck_v128_compare(st)
      |     I8x16Abs => typecheck_v128_unary(st)
      |     I8x16Neg => typecheck_v128_unary(st)
      |     I8x16Popcnt => typecheck_v128_unary(st)
      |     I8x16AllTrue => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I8x16Bitmask => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I8x16NarrowI16x8S => typecheck_v128_binary(st)
      |     I8x16NarrowI16x8U => typecheck_v128_binary(st)
      |     I8x16Shl => typecheck_v128_shift(st)
      |     I8x16ShrS => typecheck_v128_shift(st)
      |     I8x16ShrU => typecheck_v128_shift(st)
      |     I8x16Add => typecheck_v128_binary(st)
      |     I8x16AddSatS => typecheck_v128_binary(st)
      |     I8x16AddSatU => typecheck_v128_binary(st)
      |     I8x16Sub => typecheck_v128_binary(st)
      |     I8x16SubSatS => typecheck_v128_binary(st)
      |     I8x16SubSatU => typecheck_v128_binary(st)
      |     I8x16MinS => typecheck_v128_binary(st)
      |     I8x16MinU => typecheck_v128_binary(st)
      |     I8x16MaxS => typecheck_v128_binary(st)
      |     I8x16MaxU => typecheck_v128_binary(st)
      |     I8x16AvgrU => typecheck_v128_binary(st)
      |     I16x8Abs => typecheck_v128_unary(st)
      |     I16x8Neg => typecheck_v128_unary(st)
      |     I16x8Q15mulrSatS => typecheck_v128_binary(st)
      |     I16x8AllTrue => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I16x8Bitmask => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I16x8NarrowI32x4S => typecheck_v128_binary(st)
      |     I16x8NarrowI32x4U => typecheck_v128_binary(st)
      |     I16x8ExtendLowI8x16S => typecheck_v128_unary(st)
      |     I16x8ExtendHighI8x16S => typecheck_v128_unary(st)
      |     I16x8ExtendLowI8x16U => typecheck_v128_unary(st)
      |     I16x8ExtendHighI8x16U => typecheck_v128_unary(st)
      |     I16x8Shl => typecheck_v128_shift(st)
      |     I16x8ShrS => typecheck_v128_shift(st)
      |     I16x8ShrU => typecheck_v128_shift(st)
      |     I16x8Add => typecheck_v128_binary(st)
      |     I16x8AddSatS => typecheck_v128_binary(st)
      |     I16x8AddSatU => typecheck_v128_binary(st)
      |     I16x8Sub => typecheck_v128_binary(st)
      |     I16x8SubSatS => typecheck_v128_binary(st)
      |     I16x8SubSatU => typecheck_v128_binary(st)
      |     I16x8Mul => typecheck_v128_binary(st)
      |     I16x8MinS => typecheck_v128_binary(st)
      |     I16x8MinU => typecheck_v128_binary(st)
      |     I16x8MaxS => typecheck_v128_binary(st)
      |     I16x8MaxU => typecheck_v128_binary(st)
      |     I16x8AvgrU => typecheck_v128_binary(st)
      |     I32x4Abs => typecheck_v128_unary(st)
      |     I32x4Neg => typecheck_v128_unary(st)
      |     I32x4AllTrue => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I32x4Bitmask => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I32x4ExtendLowI16x8S => typecheck_v128_unary(st)
      |     I32x4ExtendHighI16x8S => typecheck_v128_unary(st)
      |     I32x4ExtendLowI16x8U => typecheck_v128_unary(st)
      |     I32x4ExtendHighI16x8U => typecheck_v128_unary(st)
      |     I32x4Shl => typecheck_v128_shift(st)
      |     I32x4ShrS => typecheck_v128_shift(st)
      |     I32x4ShrU => typecheck_v128_shift(st)
      |     I32x4Add => typecheck_v128_binary(st)
      |     I32x4Sub => typecheck_v128_binary(st)
      |     I32x4Mul => typecheck_v128_binary(st)
      |     I32x4MinS => typecheck_v128_binary(st)
      |     I32x4MinU => typecheck_v128_binary(st)
      |     I32x4MaxS => typecheck_v128_binary(st)
      |     I32x4MaxU => typecheck_v128_binary(st)
      |     I32x4DotI16x8S => typecheck_v128_binary(st)
      |     I64x2Abs => typecheck_v128_unary(st)
      |     I64x2Neg => typecheck_v128_unary(st)
      |     I64x2AllTrue => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I64x2Bitmask => typecheck_unary(st, ValType::v128(), ValType::i32())
      |     I64x2Shl => typecheck_v128_shift(st)
      |     I64x2ShrS => typecheck_v128_shift(st)
      |     I64x2ShrU => typecheck_v128_shift(st)
      |     I64x2Add => typecheck_v128_binary(st)
      |     I64x2Sub => typecheck_v128_binary(st)
      |     I64x2Mul => typecheck_v128_binary(st)
      |     I64x2Eq => typecheck_v128_compare(st)
      |     I64x2Ne => typecheck_v128_compare(st)
      |     I64x2LtS => typecheck_v128_compare(st)
      |     I64x2GtS => typecheck_v128_compare(st)
      |     I64x2LeS => typecheck_v128_compare(st)
      |     I64x2GeS => typecheck_v128_compare(st)
      |     F32x4Abs => typecheck_v128_unary(st)
      |     F32x4Neg => typecheck_v128_unary(st)
      |     F32x4Sqrt => typecheck_v128_unary(st)
      |     F32x4Add => typecheck_v128_binary(st)
      |     F32x4Sub => typecheck_v128_binary(st)
      |     F32x4Mul => typecheck_v128_binary(st)
      |     F32x4Div => typecheck_v128_binary(st)
      |     F32x4Min => typecheck_v128_binary(st)
      |     F32x4Max => typecheck_v128_binary(st)
      |     F32x4Pmin => typecheck_v128_binary(st)
      |     F32x4Pmax => typecheck_v128_binary(st)
      |     F32x4Ceil => typecheck_v128_unary(st)
      |     F32x4Floor => typecheck_v128_unary(st)
      |     F32x4Trunc => typecheck_v128_unary(st)
      |     F32x4Nearest => typecheck_v128_unary(st)
      |     F64x2Abs => typecheck_v128_unary(st)
      |     F64x2Neg => typecheck_v128_unary(st)
      |     F64x2Sqrt => typecheck_v128_unary(st)
      |     F64x2Add => typecheck_v128_binary(st)
      |     F64x2Sub => typecheck_v128_binary(st)
      |     F64x2Mul => typecheck_v128_binary(st)
      |     F64x2Div => typecheck_v128_binary(st)
      |     F64x2Min => typecheck_v128_binary(st)
      |     F64x2Max => typecheck_v128_binary(st)
      |     F64x2Pmin => typecheck_v128_binary(st)
      |     F64x2Pmax => typecheck_v128_binary(st)
      |     F64x2Ceil => typecheck_v128_unary(st)
      |     F64x2Floor => typecheck_v128_unary(st)
      |     F64x2Trunc => typecheck_v128_unary(st)
      |     F64x2Nearest => typecheck_v128_unary(st)
      |     I32x4TruncSatF32x4S => typecheck_v128_unary(st)
      |     I32x4TruncSatF32x4U => typecheck_v128_unary(st)
      |     F32x4ConvertI32x4S => typecheck_v128_unary(st)
      |     F32x4ConvertI32x4U => typecheck_v128_unary(st)
      |     I32x4TruncSatF64x2SZero => typecheck_v128_unary(st)
      |     I32x4TruncSatF64x2UZero => typecheck_v128_unary(st)
      |     F64x2ConvertLowI32x4S => typecheck_v128_unary(st)
      |     F64x2ConvertLowI32x4U => typecheck_v128_unary(st)
      |     F32x4DemoteF64x2Zero => typecheck_v128_unary(st)
      |     F64x2PromoteLowF32x4 => typecheck_v128_unary(st)
      |     I8x16RelaxedSwizzle => typecheck_v128_binary(st)
      |     I32x4RelaxedTruncF32x4S => typecheck_v128_unary(st)
      |     I32x4RelaxedTruncF32x4U => typecheck_v128_unary(st)
      |     I32x4RelaxedTruncZeroF64x2S => typecheck_v128_unary(st)
      |     I32x4RelaxedTruncZeroF64x2U => typecheck_v128_unary(st)
      |     F32x4RelaxedMadd => typecheck_v128_ternary(st)
      |     F32x4RelaxedNmadd => typecheck_v128_ternary(st)
      |     F64x2RelaxedMadd => typecheck_v128_ternary(st)
      |     F64x2RelaxedNmadd => typecheck_v128_ternary(st)
      |     I8x16RelaxedLaneselect => typecheck_v128_ternary(st)
      |     I16x8RelaxedLaneselect => typecheck_v128_ternary(st)
      |     I32x4RelaxedLaneselect => typecheck_v128_ternary(st)
      |     I64x2RelaxedLaneselect => typecheck_v128_ternary(st)
      |     F32x4RelaxedMin => typecheck_v128_binary(st)
      |     F32x4RelaxedMax => typecheck_v128_binary(st)
      |     F64x2RelaxedMin => typecheck_v128_binary(st)
      |     F64x2RelaxedMax => typecheck_v128_binary(st)
      |     I16x8RelaxedQ15mulrS => typecheck_v128_binary(st)
      |     I16x8RelaxedDotI8x16I7x16S => typecheck_v128_binary(st)
      |     I32x4RelaxedDotI8x16I7x16AddS => typecheck_v128_ternary(st)
      | 
      |     // ===== extadd pairwise (unary) =====
      |     I16x8ExtaddPairwiseI8x16S => typecheck_v128_unary(st)
      |     I16x8ExtaddPairwiseI8x16U => typecheck_v128_unary(st)
      |     I32x4ExtaddPairwiseI16x8S => typecheck_v128_unary(st)
      |     I32x4ExtaddPairwiseI16x8U => typecheck_v128_unary(st)
      | 
      |     // ===== extend (unary) =====
      |     I64x2ExtendLowI32x4S => typecheck_v128_unary(st)
      |     I64x2ExtendLowI32x4U => typecheck_v128_unary(st)
      |     I64x2ExtendHighI32x4S => typecheck_v128_unary(st)
      |     I64x2ExtendHighI32x4U => typecheck_v128_unary(st)
      | 
      |     // ===== extmul low/high (binary) =====
      |     I16x8ExtmulLowI8x16S => typecheck_v128_binary(st)
      |     I16x8ExtmulLowI8x16U => typecheck_v128_binary(st)
      |     I16x8ExtmulHighI8x16S => typecheck_v128_binary(st)
      |     I16x8ExtmulHighI8x16U => typecheck_v128_binary(st)
      |     I32x4ExtmulLowI16x8S => typecheck_v128_binary(st)
      |     I32x4ExtmulLowI16x8U => typecheck_v128_binary(st)
      |     I32x4ExtmulHighI16x8S => typecheck_v128_binary(st)
      |     I32x4ExtmulHighI16x8U => typecheck_v128_binary(st)
      |     I64x2ExtmulLowI32x4S => typecheck_v128_binary(st)
      |     I64x2ExtmulLowI32x4U => typecheck_v128_binary(st)
      |     I64x2ExtmulHighI32x4S => typecheck_v128_binary(st)
      |     I64x2ExtmulHighI32x4U => typecheck_v128_binary(st)
      | 
      |     // _ => Err("unimplemented")
      |   }
      | }
      …

      | pub impl Typecheck for TInstr with typecheck(self, st) {
      |   match self {
      |     // === Constants ===
      |     TI32Const(_) => Ok(st.push1(ValType::i32()))
      |     TI64Const(_) => Ok(st.push1(ValType::i64()))
      |     TF32Const(_) => Ok(st.push1(ValType::f32()))
      |     TF64Const(_) => Ok(st.push1(ValType::f64()))
      |     TRefNull(ht) => typecheck_ref_null(st, ht)
      |     TRefFunc(f) => typecheck_ref_func(st, f)
      |     TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>
 3220 |       typecheck_v128_const(st)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      | 
      |     // === Nullary ===
 3223 |     TUnreachable => Ok(TcState::{ ..st, reachable: false })
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     TNop => Ok(st)
      |     TLocalGet(i) => typecheck_local_get(st, i)
      |     TGlobalGet(i) => typecheck_global_get(st, i)
      |     TMemorySize(m) => typecheck_memory_size(st, m)
      |     TTableSize(t) => typecheck_table_size(st, t)
      | 
      |     // === Unary ===
      |     TUnary(op, child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
 3234 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       match op {
      |         // Scalar
 3238 |         I32EqzOp => typecheck_unary(st1, ValType::i32(), ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64EqzOp => typecheck_unary(st1, ValType::i64(), ValType::i32())
      |         I32ClzOp => typecheck_unary(st1, ValType::i32(), ValType::i32())
 3241 |         I32CtzOp => typecheck_unary(st1, ValType::i32(), ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32PopcntOp => typecheck_unary(st1, ValType::i32(), ValType::i32())
      |         I64ClzOp => typecheck_unary(st1, ValType::i64(), ValType::i64())
      |         I64CtzOp => typecheck_unary(st1, ValType::i64(), ValType::i64())
      |         I64PopcntOp => typecheck_unary(st1, ValType::i64(), ValType::i64())
      |         F32AbsOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F32NegOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F32CeilOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F32FloorOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F32TruncOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F32NearestOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F32SqrtOp => typecheck_unary(st1, ValType::f32(), ValType::f32())
      |         F64AbsOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         F64NegOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         F64CeilOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         F64FloorOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         F64TruncOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         F64NearestOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         F64SqrtOp => typecheck_unary(st1, ValType::f64(), ValType::f64())
      |         I32WrapI64Op => typecheck_unary(st1, ValType::i64(), ValType::i32())
      |         I32TruncF32SOp => typecheck_unary(st1, ValType::f32(), ValType::i32())
      |         I32TruncF32UOp => typecheck_unary(st1, ValType::f32(), ValType::i32())
      |         I32TruncF64SOp => typecheck_unary(st1, ValType::f64(), ValType::i32())
      |         I32TruncF64UOp => typecheck_unary(st1, ValType::f64(), ValType::i32())
      |         I64ExtendI32SOp => typecheck_unary(st1, ValType::i32(), ValType::i64())
 3266 |         I64ExtendI32UOp => typecheck_unary(st1, ValType::i32(), ValType::i64())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64TruncF32SOp => typecheck_unary(st1, ValType::f32(), ValType::i64())
      |         I64TruncF32UOp => typecheck_unary(st1, ValType::f32(), ValType::i64())
      |         I64TruncF64SOp => typecheck_unary(st1, ValType::f64(), ValType::i64())
      |         I64TruncF64UOp => typecheck_unary(st1, ValType::f64(), ValType::i64())
      |         F32ConvertI32SOp => typecheck_unary(st1, ValType::i32(), ValType::f32())
 3272 |         F32ConvertI32UOp => typecheck_unary(st1, ValType::i32(), ValType::f32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F32ConvertI64SOp => typecheck_unary(st1, ValType::i64(), ValType::f32())
      |         F32ConvertI64UOp => typecheck_unary(st1, ValType::i64(), ValType::f32())
      |         F32DemoteF64Op => typecheck_unary(st1, ValType::f64(), ValType::f32())
      |         F64ConvertI32SOp => typecheck_unary(st1, ValType::i32(), ValType::f64())
      |         F64ConvertI32UOp => typecheck_unary(st1, ValType::i32(), ValType::f64())
      |         F64ConvertI64SOp => typecheck_unary(st1, ValType::i64(), ValType::f64())
 3279 |         F64ConvertI64UOp => typecheck_unary(st1, ValType::i64(), ValType::f64())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F64PromoteF32Op => typecheck_unary(st1, ValType::f32(), ValType::f64())
      |         I32ReinterpretF32Op =>
 3282 |           typecheck_unary(st1, ValType::f32(), ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64ReinterpretF64Op =>
 3284 |           typecheck_unary(st1, ValType::f64(), ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F32ReinterpretI32Op =>
 3286 |           typecheck_unary(st1, ValType::i32(), ValType::f32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F64ReinterpretI64Op =>
 3288 |           typecheck_unary(st1, ValType::i64(), ValType::f64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32Extend8SOp => typecheck_unary(st1, ValType::i32(), ValType::i32())
      |         I32Extend16SOp => typecheck_unary(st1, ValType::i32(), ValType::i32())
      |         I64Extend8SOp => typecheck_unary(st1, ValType::i64(), ValType::i64())
      |         I64Extend16SOp => typecheck_unary(st1, ValType::i64(), ValType::i64())
      |         I64Extend32SOp => typecheck_unary(st1, ValType::i64(), ValType::i64())
      |         I32TruncSatF32SOp =>
 3295 |           typecheck_unary(st1, ValType::f32(), ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32TruncSatF32UOp =>
 3297 |           typecheck_unary(st1, ValType::f32(), ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32TruncSatF64SOp =>
 3299 |           typecheck_unary(st1, ValType::f64(), ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32TruncSatF64UOp =>
 3301 |           typecheck_unary(st1, ValType::f64(), ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64TruncSatF32SOp =>
 3303 |           typecheck_unary(st1, ValType::f32(), ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64TruncSatF32UOp =>
 3305 |           typecheck_unary(st1, ValType::f32(), ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64TruncSatF64SOp =>
 3307 |           typecheck_unary(st1, ValType::f64(), ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64TruncSatF64UOp =>
 3309 |           typecheck_unary(st1, ValType::f64(), ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      | 
      |         // SIMD: Unary
 3312 |         V128NotOp => typecheck_v128_unary(st1)
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I8x16AbsOp => typecheck_v128_unary(st1)
      |         I8x16NegOp => typecheck_v128_unary(st1)
      |         I8x16PopcntOp => typecheck_v128_unary(st1)
      |         I16x8AbsOp => typecheck_v128_unary(st1)
      |         I16x8NegOp => typecheck_v128_unary(st1)
      |         I32x4AbsOp => typecheck_v128_unary(st1)
      |         I32x4NegOp => typecheck_v128_unary(st1)
      |         I64x2AbsOp => typecheck_v128_unary(st1)
      |         I64x2NegOp => typecheck_v128_unary(st1)
      |         F32x4AbsOp => typecheck_v128_unary(st1)
      |         F32x4NegOp => typecheck_v128_unary(st1)
      |         F32x4SqrtOp => typecheck_v128_unary(st1)
      |         F32x4CeilOp => typecheck_v128_unary(st1)
      |         F32x4FloorOp => typecheck_v128_unary(st1)
      |         F32x4TruncOp => typecheck_v128_unary(st1)
      |         F32x4NearestOp => typecheck_v128_unary(st1)
      |         F64x2AbsOp => typecheck_v128_unary(st1)
      |         F64x2NegOp => typecheck_v128_unary(st1)
      |         F64x2SqrtOp => typecheck_v128_unary(st1)
      |         F64x2CeilOp => typecheck_v128_unary(st1)
      |         F64x2FloorOp => typecheck_v128_unary(st1)
      |         F64x2TruncOp => typecheck_v128_unary(st1)
      |         F64x2NearestOp => typecheck_v128_unary(st1)
      | 
      |         // SIMD: Unary (v128 -> i32)
 3338 |         V128AnyTrueOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I8x16AllTrueOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I8x16BitmaskOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I16x8AllTrueOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I16x8BitmaskOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I32x4AllTrueOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I32x4BitmaskOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I64x2AllTrueOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      |         I64x2BitmaskOp => typecheck_unary(st1, ValType::v128(), ValType::i32())
      | 
      |         // SIMD: Extend/narrow/pairwise
 3349 |         I16x8ExtendLowI8x16SOp => typecheck_v128_unary(st1)
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I16x8ExtendHighI8x16SOp => typecheck_v128_unary(st1)
      |         I16x8ExtendLowI8x16UOp => typecheck_v128_unary(st1)
      |         I16x8ExtendHighI8x16UOp => typecheck_v128_unary(st1)
      |         I32x4ExtendLowI16x8SOp => typecheck_v128_unary(st1)
      |         I32x4ExtendHighI16x8SOp => typecheck_v128_unary(st1)
      |         I32x4ExtendLowI16x8UOp => typecheck_v128_unary(st1)
      |         I32x4ExtendHighI16x8UOp => typecheck_v128_unary(st1)
      |         I64x2ExtendLowI32x4SOp => typecheck_v128_unary(st1)
      |         I64x2ExtendHighI32x4SOp => typecheck_v128_unary(st1)
      |         I64x2ExtendLowI32x4UOp => typecheck_v128_unary(st1)
      |         I64x2ExtendHighI32x4UOp => typecheck_v128_unary(st1)
      |         I16x8ExtaddPairwiseI8x16SOp => typecheck_v128_unary(st1)
      |         I16x8ExtaddPairwiseI8x16UOp => typecheck_v128_unary(st1)
      |         I32x4ExtaddPairwiseI16x8SOp => typecheck_v128_unary(st1)
      |         I32x4ExtaddPairwiseI16x8UOp => typecheck_v128_unary(st1)
      | 
      |         // SIMD: Conversions
 3367 |         F32x4DemoteF64x2ZeroOp => typecheck_v128_unary(st1)
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F64x2PromoteLowF32x4Op => typecheck_v128_unary(st1)
      |         I32x4TruncSatF32x4SOp => typecheck_v128_unary(st1)
      |         I32x4TruncSatF32x4UOp => typecheck_v128_unary(st1)
      |         F32x4ConvertI32x4SOp => typecheck_v128_unary(st1)
      |         F32x4ConvertI32x4UOp => typecheck_v128_unary(st1)
      |         I32x4TruncSatF64x2SZeroOp => typecheck_v128_unary(st1)
      |         I32x4TruncSatF64x2UZeroOp => typecheck_v128_unary(st1)
      |         F64x2ConvertLowI32x4SOp => typecheck_v128_unary(st1)
      |         F64x2ConvertLowI32x4UOp => typecheck_v128_unary(st1)
      | 
      |         // SIMD: Relaxed
 3379 |         I32x4RelaxedTruncF32x4SOp => typecheck_v128_unary(st1)
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32x4RelaxedTruncF32x4UOp => typecheck_v128_unary(st1)
      |         I32x4RelaxedTruncZeroF64x2SOp => typecheck_v128_unary(st1)
      |         I32x4RelaxedTruncZeroF64x2UOp => typecheck_v128_unary(st1)
      |       }
      |     }
      |     TDrop(child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
      |       typecheck_drop(st1)
      |     }
      |     TLocalSet(i, child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
      |       typecheck_local_set(st1, i)
      |     }
 3399 |     TLocalTee(i, child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3404 |       typecheck_local_tee(st1, i)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TGlobalSet(i, child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
      |       typecheck_global_set(st1, i)
      |     }
 3413 |     TRefIsNull(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3418 |       typecheck_ref_is_null(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TRefAsNonNull(child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
 3423 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_ref_as_non_null(st1)
      |     }
 3427 |     TI31GetS(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3432 |       typecheck_i31_get(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3434 |     TI31GetU(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3439 |       typecheck_i31_get(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3441 |     TRefI31(child) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3446 |       typecheck_ref_i31(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TArrayLen(child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
 3451 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_len(st1)
      |     }
 3455 |     TAnyConvertExtern(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3460 |       typecheck_any_convert_extern(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3462 |     TExternConvertAny(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3467 |       typecheck_extern_convert_any(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3469 |     TThrowRef(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st1) => st1
      |         Err(t) => return Err(t)
      |       }
 3474 |       typecheck_throw_ref(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === Binary ===
      |     TBinary(op, left, right) => {
      |       let st1 = match Typecheck::typecheck(left, st) {
      |         Ok(st1) => st1
 3481 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(right, st1) {
      |         Ok(st2) => st2
 3485 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       match op {
      |         // Scalar Comparisons
 3489 |         I32EqOp => typecheck_compare(st2, ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32NeOp => typecheck_compare(st2, ValType::i32())
      |         I32LtSOp => typecheck_compare(st2, ValType::i32())
      |         I32LtUOp => typecheck_compare(st2, ValType::i32())
      |         I32GtSOp => typecheck_compare(st2, ValType::i32())
      |         I32GtUOp => typecheck_compare(st2, ValType::i32())
      |         I32LeSOp => typecheck_compare(st2, ValType::i32())
      |         I32LeUOp => typecheck_compare(st2, ValType::i32())
      |         I32GeSOp => typecheck_compare(st2, ValType::i32())
      |         I32GeUOp => typecheck_compare(st2, ValType::i32())
      |         I64EqOp => typecheck_compare(st2, ValType::i64())
      |         I64NeOp => typecheck_compare(st2, ValType::i64())
      |         I64LtSOp => typecheck_compare(st2, ValType::i64())
      |         I64LtUOp => typecheck_compare(st2, ValType::i64())
      |         I64GtSOp => typecheck_compare(st2, ValType::i64())
      |         I64GtUOp => typecheck_compare(st2, ValType::i64())
      |         I64LeSOp => typecheck_compare(st2, ValType::i64())
      |         I64LeUOp => typecheck_compare(st2, ValType::i64())
      |         I64GeSOp => typecheck_compare(st2, ValType::i64())
      |         I64GeUOp => typecheck_compare(st2, ValType::i64())
      |         F32EqOp => typecheck_compare(st2, ValType::f32())
      |         F32NeOp => typecheck_compare(st2, ValType::f32())
      |         F32LtOp => typecheck_compare(st2, ValType::f32())
      |         F32GtOp => typecheck_compare(st2, ValType::f32())
      |         F32LeOp => typecheck_compare(st2, ValType::f32())
      |         F32GeOp => typecheck_compare(st2, ValType::f32())
      |         F64EqOp => typecheck_compare(st2, ValType::f64())
      |         F64NeOp => typecheck_compare(st2, ValType::f64())
      |         F64LtOp => typecheck_compare(st2, ValType::f64())
      |         F64GtOp => typecheck_compare(st2, ValType::f64())
      |         F64LeOp => typecheck_compare(st2, ValType::f64())
      |         F64GeOp => typecheck_compare(st2, ValType::f64())
      | 
      |         // Scalar Arithmetic
      |         I32AddOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32SubOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32MulOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
 3526 |         I32DivSOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32DivUOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32RemSOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32RemUOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32AndOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32OrOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32XorOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32ShlOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32ShrSOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32ShrUOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32RotlOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I32RotrOp => typecheck_binary(st2, ValType::i32(), ValType::i32())
      |         I64AddOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
 3539 |         I64SubOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64MulOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64DivSOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64DivUOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64RemSOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64RemUOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64AndOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64OrOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64XorOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64ShlOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64ShrSOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64ShrUOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64RotlOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         I64RotrOp => typecheck_binary(st2, ValType::i64(), ValType::i64())
      |         F32AddOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
 3554 |         F32SubOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F32MulOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
      |         F32DivOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
      |         F32MinOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
      |         F32MaxOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
      |         F32CopysignOp => typecheck_binary(st2, ValType::f32(), ValType::f32())
      |         F64AddOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
 3561 |         F64SubOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         F64MulOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
      |         F64DivOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
      |         F64MinOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
      |         F64MaxOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
      |         F64CopysignOp => typecheck_binary(st2, ValType::f64(), ValType::f64())
      | 
      |         // SIMD Binary
 3569 |         V128AndOp => typecheck_v128_binary(st2)
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         V128AndnotOp => typecheck_v128_binary(st2)
      |         V128OrOp => typecheck_v128_binary(st2)
      |         V128XorOp => typecheck_v128_binary(st2)
      |         I8x16EqOp => typecheck_v128_compare(st2)
      |         I8x16NeOp => typecheck_v128_compare(st2)
      |         I8x16LtSOp => typecheck_v128_compare(st2)
      |         I8x16LtUOp => typecheck_v128_compare(st2)
      |         I8x16GtSOp => typecheck_v128_compare(st2)
      |         I8x16GtUOp => typecheck_v128_compare(st2)
      |         I8x16LeSOp => typecheck_v128_compare(st2)
      |         I8x16LeUOp => typecheck_v128_compare(st2)
      |         I8x16GeSOp => typecheck_v128_compare(st2)
      |         I8x16GeUOp => typecheck_v128_compare(st2)
      |         I16x8EqOp => typecheck_v128_compare(st2)
      |         I16x8NeOp => typecheck_v128_compare(st2)
      |         I16x8LtSOp => typecheck_v128_compare(st2)
      |         I16x8LtUOp => typecheck_v128_compare(st2)
      |         I16x8GtSOp => typecheck_v128_compare(st2)
      |         I16x8GtUOp => typecheck_v128_compare(st2)
      |         I16x8LeSOp => typecheck_v128_compare(st2)
      |         I16x8LeUOp => typecheck_v128_compare(st2)
      |         I16x8GeSOp => typecheck_v128_compare(st2)
      |         I16x8GeUOp => typecheck_v128_compare(st2)
      |         I32x4EqOp => typecheck_v128_compare(st2)
      |         I32x4NeOp => typecheck_v128_compare(st2)
      |         I32x4LtSOp => typecheck_v128_compare(st2)
      |         I32x4LtUOp => typecheck_v128_compare(st2)
      |         I32x4GtSOp => typecheck_v128_compare(st2)
      |         I32x4GtUOp => typecheck_v128_compare(st2)
      |         I32x4LeSOp => typecheck_v128_compare(st2)
      |         I32x4LeUOp => typecheck_v128_compare(st2)
      |         I32x4GeSOp => typecheck_v128_compare(st2)
      |         I32x4GeUOp => typecheck_v128_compare(st2)
      |         I64x2EqOp => typecheck_v128_compare(st2)
      |         I64x2NeOp => typecheck_v128_compare(st2)
      |         I64x2LtSOp => typecheck_v128_compare(st2)
      |         I64x2GtSOp => typecheck_v128_compare(st2)
      |         I64x2LeSOp => typecheck_v128_compare(st2)
      |         I64x2GeSOp => typecheck_v128_compare(st2)
      |         F32x4EqOp => typecheck_v128_compare(st2)
      |         F32x4NeOp => typecheck_v128_compare(st2)
      |         F32x4LtOp => typecheck_v128_compare(st2)
      |         F32x4GtOp => typecheck_v128_compare(st2)
      |         F32x4LeOp => typecheck_v128_compare(st2)
      |         F32x4GeOp => typecheck_v128_compare(st2)
      |         F64x2EqOp => typecheck_v128_compare(st2)
      |         F64x2NeOp => typecheck_v128_compare(st2)
      |         F64x2LtOp => typecheck_v128_compare(st2)
      |         F64x2GtOp => typecheck_v128_compare(st2)
      |         F64x2LeOp => typecheck_v128_compare(st2)
      |         F64x2GeOp => typecheck_v128_compare(st2)
      |         I8x16AddOp => typecheck_v128_binary(st2)
      |         I8x16AddSatSOp => typecheck_v128_binary(st2)
      |         I8x16AddSatUOp => typecheck_v128_binary(st2)
      |         I8x16SubOp => typecheck_v128_binary(st2)
      |         I8x16SubSatSOp => typecheck_v128_binary(st2)
      |         I8x16SubSatUOp => typecheck_v128_binary(st2)
      |         I8x16MinSOp => typecheck_v128_binary(st2)
      |         I8x16MinUOp => typecheck_v128_binary(st2)
      |         I8x16MaxSOp => typecheck_v128_binary(st2)
      |         I8x16MaxUOp => typecheck_v128_binary(st2)
      |         I8x16AvgrUOp => typecheck_v128_binary(st2)
      |         I8x16NarrowI16x8SOp => typecheck_v128_binary(st2)
      |         I8x16NarrowI16x8UOp => typecheck_v128_binary(st2)
      |         I16x8AddOp => typecheck_v128_binary(st2)
      |         I16x8AddSatSOp => typecheck_v128_binary(st2)
      |         I16x8AddSatUOp => typecheck_v128_binary(st2)
      |         I16x8SubOp => typecheck_v128_binary(st2)
      |         I16x8SubSatSOp => typecheck_v128_binary(st2)
      |         I16x8SubSatUOp => typecheck_v128_binary(st2)
      |         I16x8MulOp => typecheck_v128_binary(st2)
      |         I16x8MinSOp => typecheck_v128_binary(st2)
      |         I16x8MinUOp => typecheck_v128_binary(st2)
      |         I16x8MaxSOp => typecheck_v128_binary(st2)
      |         I16x8MaxUOp => typecheck_v128_binary(st2)
      |         I16x8AvgrUOp => typecheck_v128_binary(st2)
      |         I16x8Q15mulrSatSOp => typecheck_v128_binary(st2)
      |         I16x8NarrowI32x4SOp => typecheck_v128_binary(st2)
      |         I16x8NarrowI32x4UOp => typecheck_v128_binary(st2)
      |         I16x8ExtmulLowI8x16SOp => typecheck_v128_binary(st2)
      |         I16x8ExtmulHighI8x16SOp => typecheck_v128_binary(st2)
      |         I16x8ExtmulLowI8x16UOp => typecheck_v128_binary(st2)
      |         I16x8ExtmulHighI8x16UOp => typecheck_v128_binary(st2)
      |         I32x4AddOp => typecheck_v128_binary(st2)
      |         I32x4SubOp => typecheck_v128_binary(st2)
      |         I32x4MulOp => typecheck_v128_binary(st2)
      |         I32x4MinSOp => typecheck_v128_binary(st2)
      |         I32x4MinUOp => typecheck_v128_binary(st2)
      |         I32x4MaxSOp => typecheck_v128_binary(st2)
      |         I32x4MaxUOp => typecheck_v128_binary(st2)
      |         I32x4DotI16x8SOp => typecheck_v128_binary(st2)
      |         I32x4ExtmulLowI16x8SOp => typecheck_v128_binary(st2)
      |         I32x4ExtmulHighI16x8SOp => typecheck_v128_binary(st2)
      |         I32x4ExtmulLowI16x8UOp => typecheck_v128_binary(st2)
      |         I32x4ExtmulHighI16x8UOp => typecheck_v128_binary(st2)
      |         I64x2AddOp => typecheck_v128_binary(st2)
      |         I64x2SubOp => typecheck_v128_binary(st2)
      |         I64x2MulOp => typecheck_v128_binary(st2)
      |         I64x2ExtmulLowI32x4SOp => typecheck_v128_binary(st2)
      |         I64x2ExtmulHighI32x4SOp => typecheck_v128_binary(st2)
      |         I64x2ExtmulLowI32x4UOp => typecheck_v128_binary(st2)
      |         I64x2ExtmulHighI32x4UOp => typecheck_v128_binary(st2)
      |         F32x4AddOp => typecheck_v128_binary(st2)
      |         F32x4SubOp => typecheck_v128_binary(st2)
      |         F32x4MulOp => typecheck_v128_binary(st2)
      |         F32x4DivOp => typecheck_v128_binary(st2)
      |         F32x4MinOp => typecheck_v128_binary(st2)
      |         F32x4MaxOp => typecheck_v128_binary(st2)
      |         F32x4PminOp => typecheck_v128_binary(st2)
      |         F32x4PmaxOp => typecheck_v128_binary(st2)
      |         F64x2AddOp => typecheck_v128_binary(st2)
      |         F64x2SubOp => typecheck_v128_binary(st2)
      |         F64x2MulOp => typecheck_v128_binary(st2)
      |         F64x2DivOp => typecheck_v128_binary(st2)
      |         F64x2MinOp => typecheck_v128_binary(st2)
      |         F64x2MaxOp => typecheck_v128_binary(st2)
      |         F64x2PminOp => typecheck_v128_binary(st2)
      |         F64x2PmaxOp => typecheck_v128_binary(st2)
      |         F32x4RelaxedMinOp => typecheck_v128_binary(st2)
      |         F32x4RelaxedMaxOp => typecheck_v128_binary(st2)
      |         F64x2RelaxedMinOp => typecheck_v128_binary(st2)
      |         F64x2RelaxedMaxOp => typecheck_v128_binary(st2)
      |         I16x8RelaxedQ15mulrSOp => typecheck_v128_binary(st2)
      |         I16x8RelaxedDotI8x16I7x16SOp => typecheck_v128_binary(st2)
      |       }
      |     }
 3696 |     TRefEq(left, right) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(left, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3701 |       let st2 = match Typecheck::typecheck(right, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3705 |       typecheck_ref_eq(st2)
      |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TStore(op, ma, addr, val) => {
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
 3710 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(val, st1) {
      |         Ok(st) => st
 3714 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       match op {
      |         I32StoreOp => typecheck_store(st2, ma, 32, ValType::i32())
      |         I64StoreOp => typecheck_store(st2, ma, 64, ValType::i64())
      |         F32StoreOp => typecheck_store(st2, ma, 32, ValType::f32())
      |         F64StoreOp => typecheck_store(st2, ma, 64, ValType::f64())
 3721 |         I32Store8Op => typecheck_store(st2, ma, 8, ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32Store16Op => typecheck_store(st2, ma, 16, ValType::i32())
      |         I64Store8Op => typecheck_store(st2, ma, 8, ValType::i64())
      |         I64Store16Op => typecheck_store(st2, ma, 16, ValType::i64())
      |         I64Store32Op => typecheck_store(st2, ma, 32, ValType::i64())
      |         I32AtomicStoreOp => typecheck_store(st2, ma, 32, ValType::i32())
      |         I64AtomicStoreOp => typecheck_store(st2, ma, 64, ValType::i64())
      |         I32AtomicStore8Op => typecheck_store(st2, ma, 8, ValType::i32())
      |         I32AtomicStore16Op => typecheck_store(st2, ma, 16, ValType::i32())
      |         I64AtomicStore8Op => typecheck_store(st2, ma, 8, ValType::i64())
      |         I64AtomicStore16Op => typecheck_store(st2, ma, 16, ValType::i64())
      |         I64AtomicStore32Op => typecheck_store(st2, ma, 32, ValType::i64())
      |         V128StoreOp => typecheck_v128_mem_store(st2, ma, 128)
      |       }
      |     }
      | 
      |     // === Load ===
      |     TLoad(op, ma, addr) => {
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
 3741 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       match op {
      |         I32LoadOp => typecheck_load(st1, ma, 32, ValType::i32())
      |         I64LoadOp => typecheck_load(st1, ma, 64, ValType::i64())
      |         F32LoadOp => typecheck_load(st1, ma, 32, ValType::f32())
      |         F64LoadOp => typecheck_load(st1, ma, 64, ValType::f64())
 3748 |         I32Load8SOp => typecheck_load(st1, ma, 8, ValType::i32())
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32Load8UOp => typecheck_load(st1, ma, 8, ValType::i32())
      |         I32Load16SOp => typecheck_load(st1, ma, 16, ValType::i32())
      |         I32Load16UOp => typecheck_load(st1, ma, 16, ValType::i32())
      |         I64Load8SOp => typecheck_load(st1, ma, 8, ValType::i64())
      |         I64Load8UOp => typecheck_load(st1, ma, 8, ValType::i64())
      |         I64Load16SOp => typecheck_load(st1, ma, 16, ValType::i64())
      |         I64Load16UOp => typecheck_load(st1, ma, 16, ValType::i64())
      |         I64Load32SOp => typecheck_load(st1, ma, 32, ValType::i64())
      |         I64Load32UOp => typecheck_load(st1, ma, 32, ValType::i64())
      |         I32AtomicLoadOp => typecheck_load(st1, ma, 32, ValType::i32())
      |         I64AtomicLoadOp => typecheck_load(st1, ma, 64, ValType::i64())
      |         I32AtomicLoad8UOp => typecheck_load(st1, ma, 8, ValType::i32())
      |         I32AtomicLoad16UOp => typecheck_load(st1, ma, 16, ValType::i32())
      |         I64AtomicLoad8UOp => typecheck_load(st1, ma, 8, ValType::i64())
      |         I64AtomicLoad16UOp => typecheck_load(st1, ma, 16, ValType::i64())
      |         I64AtomicLoad32UOp => typecheck_load(st1, ma, 32, ValType::i64())
      |         V128LoadOp => typecheck_v128_mem_load(st1, ma, 128)
      |         V128Load8x8SOp => typecheck_v128_mem_load_extend64(st1, ma)
      |         V128Load8x8UOp => typecheck_v128_mem_load_extend64(st1, ma)
      |         V128Load16x4SOp => typecheck_v128_mem_load_extend64(st1, ma)
      |         V128Load16x4UOp => typecheck_v128_mem_load_extend64(st1, ma)
      |         V128Load32x2SOp => typecheck_v128_mem_load_extend64(st1, ma)
      |         V128Load32x2UOp => typecheck_v128_mem_load_extend64(st1, ma)
      |         V128Load8SplatOp => typecheck_v128_mem_load_splat(st1, ma, 8)
      |         V128Load16SplatOp => typecheck_v128_mem_load_splat(st1, ma, 16)
      |         V128Load32SplatOp => typecheck_v128_mem_load_splat(st1, ma, 32)
      |         V128Load64SplatOp => typecheck_v128_mem_load_splat(st1, ma, 64)
      |         V128Load32ZeroOp => typecheck_v128_mem_load_zero(st1, ma, 32)
      |         V128Load64ZeroOp => typecheck_v128_mem_load_zero(st1, ma, 64)
      |       }
      |     }
      | 
      |     // === Memory ops ===
      |     TMemoryGrow(m, delta) => {
      |       let st1 = match Typecheck::typecheck(delta, st) {
      |         Ok(st) => st
 3785 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_memory_grow(st1, m)
      |     }
      |     TMemoryFill(m, dst, val, len) => {
      |       let st1 = match Typecheck::typecheck(dst, st) {
      |         Ok(st) => st
 3792 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(val, st1) {
      |         Ok(st) => st
 3796 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st3 = match Typecheck::typecheck(len, st2) {
      |         Ok(st) => st
 3800 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_memory_fill(st3, m)
      |     }
      |     TMemoryCopy(mi0, mi1, dst, src, len) => {
      |       let st1 = match Typecheck::typecheck(dst, st) {
      |         Ok(st) => st
 3807 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(src, st1) {
      |         Ok(st) => st
 3811 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st3 = match Typecheck::typecheck(len, st2) {
      |         Ok(st) => st
 3815 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_memory_copy(st3, mi0, mi1)
      |     }
      |     TMemoryInit(d, m, dst, src, len) => {
      |       let st1 = match Typecheck::typecheck(dst, st) {
      |         Ok(st) => st
 3822 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(src, st1) {
      |         Ok(st) => st
 3826 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st3 = match Typecheck::typecheck(len, st2) {
      |         Ok(st) => st
 3830 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_memory_init(st3, d, m)
      |     }
      |     TDataDrop(d) => typecheck_data_drop(st, d)
 3835 |     TMemoryAtomicNotify(ma, addr, count) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3840 |       let st2 = match Typecheck::typecheck(count, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3844 |       typecheck_atomic_notify(st2, ma)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3846 |     TMemoryAtomicWait32(ma, addr, expected, timeout) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3851 |       let st2 = match Typecheck::typecheck(expected, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3855 |       let st3 = match Typecheck::typecheck(timeout, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3859 |       typecheck_atomic_wait(st3, ma, 32, ValType::i32())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3861 |     TMemoryAtomicWait64(ma, addr, expected, timeout) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3866 |       let st2 = match Typecheck::typecheck(expected, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3870 |       let st3 = match Typecheck::typecheck(timeout, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3874 |       typecheck_atomic_wait(st3, ma, 64, ValType::i64())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 3876 |     TAtomicFence => Ok(st)
      |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     TAtomicRmw(op, ma, addr, value) => {
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3882 |       let st2 = match Typecheck::typecheck(value, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3886 |       match op {
      |       ^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmwAddOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i32())
      |         I64AtomicRmwAddOp => typecheck_atomic_rmw(st2, ma, 64, ValType::i64())
      |         I32AtomicRmw8AddUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i32())
      |         I32AtomicRmw16AddUOp =>
 3891 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8AddUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i64())
      |         I64AtomicRmw16AddUOp =>
 3894 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32AddUOp =>
 3896 |           typecheck_atomic_rmw(st2, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmwSubOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i32())
      |         I64AtomicRmwSubOp => typecheck_atomic_rmw(st2, ma, 64, ValType::i64())
      |         I32AtomicRmw8SubUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i32())
      |         I32AtomicRmw16SubUOp =>
 3901 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8SubUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i64())
      |         I64AtomicRmw16SubUOp =>
 3904 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32SubUOp =>
 3906 |           typecheck_atomic_rmw(st2, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmwAndOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i32())
      |         I64AtomicRmwAndOp => typecheck_atomic_rmw(st2, ma, 64, ValType::i64())
      |         I32AtomicRmw8AndUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i32())
      |         I32AtomicRmw16AndUOp =>
 3911 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8AndUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i64())
      |         I64AtomicRmw16AndUOp =>
 3914 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32AndUOp =>
 3916 |           typecheck_atomic_rmw(st2, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmwOrOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i32())
      |         I64AtomicRmwOrOp => typecheck_atomic_rmw(st2, ma, 64, ValType::i64())
      |         I32AtomicRmw8OrUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i32())
      |         I32AtomicRmw16OrUOp => typecheck_atomic_rmw(st2, ma, 16, ValType::i32())
      |         I64AtomicRmw8OrUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i64())
      |         I64AtomicRmw16OrUOp => typecheck_atomic_rmw(st2, ma, 16, ValType::i64())
      |         I64AtomicRmw32OrUOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i64())
      |         I32AtomicRmwXorOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i32())
      |         I64AtomicRmwXorOp => typecheck_atomic_rmw(st2, ma, 64, ValType::i64())
      |         I32AtomicRmw8XorUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i32())
      |         I32AtomicRmw16XorUOp =>
 3928 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8XorUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i64())
      |         I64AtomicRmw16XorUOp =>
 3931 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32XorUOp =>
 3933 |           typecheck_atomic_rmw(st2, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmwXchgOp => typecheck_atomic_rmw(st2, ma, 32, ValType::i32())
      |         I64AtomicRmwXchgOp => typecheck_atomic_rmw(st2, ma, 64, ValType::i64())
      |         I32AtomicRmw8XchgUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i32())
      |         I32AtomicRmw16XchgUOp =>
 3938 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8XchgUOp => typecheck_atomic_rmw(st2, ma, 8, ValType::i64())
      |         I64AtomicRmw16XchgUOp =>
 3941 |           typecheck_atomic_rmw(st2, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32XchgUOp =>
 3943 |           typecheck_atomic_rmw(st2, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |     }
 3946 |     TAtomicCmpxchg(op, ma, addr, expected, replacement) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(addr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3951 |       let st2 = match Typecheck::typecheck(expected, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3955 |       let st3 = match Typecheck::typecheck(replacement, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 3959 |       match op {
      |       ^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmwCmpxchgOp =>
 3961 |           typecheck_atomic_cmpxchg(st3, ma, 32, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmwCmpxchgOp =>
 3963 |           typecheck_atomic_cmpxchg(st3, ma, 64, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmw8CmpxchgUOp =>
 3965 |           typecheck_atomic_cmpxchg(st3, ma, 8, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I32AtomicRmw16CmpxchgUOp =>
 3967 |           typecheck_atomic_cmpxchg(st3, ma, 16, ValType::i32())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw8CmpxchgUOp =>
 3969 |           typecheck_atomic_cmpxchg(st3, ma, 8, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw16CmpxchgUOp =>
 3971 |           typecheck_atomic_cmpxchg(st3, ma, 16, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         I64AtomicRmw32CmpxchgUOp =>
 3973 |           typecheck_atomic_cmpxchg(st3, ma, 32, ValType::i64())
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |     }
      | 
      |     // === Table ops ===
      |     TTableGet(t, idx) => {
      |       let st1 = match Typecheck::typecheck(idx, st) {
      |         Ok(st) => st
 3981 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_table_get(st1, t)
      |     }
      |     TTableSet(t, idx, val) => {
      |       let st1 = match Typecheck::typecheck(idx, st) {
      |         Ok(st) => st
 3988 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(val, st1) {
      |         Ok(st) => st
 3992 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_table_set(st2, t)
      |     }
      |     TTableGrow(t, init, delta) => {
      |       let st1 = match Typecheck::typecheck(init, st) {
      |         Ok(st) => st
 3999 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(delta, st1) {
      |         Ok(st) => st
 4003 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_table_grow(st2, t)
      |     }
 4007 |     TTableFill(t, idx, val, len) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(idx, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4012 |       let st2 = match Typecheck::typecheck(val, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4016 |       let st3 = match Typecheck::typecheck(len, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4020 |       typecheck_table_fill(st3, t)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4022 |     TTableCopy(t0, t1, dst, src, len) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(dst, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4027 |       let st2 = match Typecheck::typecheck(src, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4031 |       let st3 = match Typecheck::typecheck(len, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4035 |       typecheck_table_copy(st3, t0, t1)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4037 |     TTableInit(e, t, dst, src, len) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(dst, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4042 |       let st2 = match Typecheck::typecheck(src, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4046 |       let st3 = match Typecheck::typecheck(len, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4050 |       typecheck_table_init(st3, e, t)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TElemDrop(e) => typecheck_elem_drop(st, e)
      | 
      |     // === Calls ===
      |     TCall(f, args) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
      |       typecheck_call(st_acc, f)
      |     }
      |     TCallIndirect(tidx, t, args, tab_expr) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
      |       let st_final = match Typecheck::typecheck(tab_expr, st_acc) {
      |         Ok(st) => st
 4075 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_call_indirect(st_final, tidx, t)
      |     }
      |     TCallRef(tidx, args, funcref) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
 4084 |           Err(t) => return Err(t)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         }
      |       }
      |       let st_final = match Typecheck::typecheck(funcref, st_acc) {
      |         Ok(st) => st
 4089 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_call_ref(st_final, tidx)
      |     }
      |     TReturnCall(f, args) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
 4098 |           Err(t) => return Err(t)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         }
      |       }
      |       typecheck_return_call(st_acc, f)
      |     }
 4103 |     TReturnCallIndirect(tidx, t, args, tab_expr) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4106 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4111 |       let st_final = match Typecheck::typecheck(tab_expr, st_acc) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4115 |       typecheck_return_call_indirect(st_final, tidx, t)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4117 |     TReturnCallRef(tidx, args, funcref) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4120 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4125 |       let st_final = match Typecheck::typecheck(funcref, st_acc) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4129 |       typecheck_return_call_ref(st_final, tidx)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === Control Flow ===
      |     TBlock(bt, body) => {
      |       let (params, results) = match st.env.expand_blocktype(bt) {
 4135 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(x) => x
      |       }
      |       let st1 = match st.pop_types(params) {
 4139 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |       let base_len = st1.stack.length()
      |       let env2 = st1.env.with_label(results)
      |       let mut st_body = TcState::{ ..st1, env: env2 }
      |       let TExpr(body) = body
      |       for instr in body {
      |         st_body = match Typecheck::typecheck(instr, st_body) {
      |           Err(e) => return Err(e)
      |           Ok(s) => s
      |         }
      |       }
      |       let st2 = if st_body.reachable {
      |         match st_body.pop_types(results) {
 4154 |           Err(e) => return Err(e)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(s) => s
      |         }
      |       } else {
      |         st_body
      |       }
      |       let s = st2.stack.copy()
      |       while s.length() > base_len {
      |         ignore(s.pop())
      |       }
      |       let out = TcState::{ ..st, stack: s }
      |       Ok(out.push_types(results))
      |     }
      |     TLoop(bt, body) => {
      |       let (params, results) = match st.env.expand_blocktype(bt) {
 4169 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(x) => x
      |       }
      |       let st1 = match st.pop_types(params) {
 4173 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |       let base_len = st1.stack.length()
      |       let env2 = st1.env.with_label(params)
      |       let mut st_body = TcState::{ ..st1, env: env2 }
      |       let TExpr(body) = body
      |       for instr in body {
      |         st_body = match Typecheck::typecheck(instr, st_body) {
      |           Err(e) => return Err(e)
      |           Ok(s) => s
      |         }
      |       }
      |       let st2 = if st_body.reachable {
      |         match st_body.pop_types(results) {
 4188 |           Err(e) => return Err(e)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(s) => s
      |         }
      |       } else {
      |         st_body
      |       }
      |       let s = st2.stack.copy()
      |       while s.length() > base_len {
      |         ignore(s.pop())
      |       }
      |       let out = TcState::{ ..st, stack: s }
      |       Ok(out.push_types(results))
      |     }
      |     TIf(bt, cond, then_instrs, else_instrs_opt) => {
      |       let (params, results) = match st.env.expand_blocktype(bt) {
 4203 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(x) => x
      |       }
      |       let st0 = match Typecheck::typecheck(cond, st) {
 4207 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |       let st0 = match st0.pop_expect(ValType::i32()) {
 4211 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |       let st1 = match st0.pop_types(params) {
 4215 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |       let base_len = st1.stack.length()
      |       let else_instrs = match else_instrs_opt {
      |         None => []
      |         Some(TExpr(xs)) => xs
      |       }
      |       let env_branch = st1.env.with_label(results)
      |       let st_then0 = TcState::{ ..st1, env: env_branch }
      |       let mut st_then = st_then0
      |       let TExpr(then_instrs) = then_instrs
      |       for instr in then_instrs {
      |         st_then = match Typecheck::typecheck(instr, st_then) {
      |           Err(e) => return Err(e)
      |           Ok(s) => s
      |         }
      |       }
      |       let st_else0 = TcState::{ ..st1, env: env_branch }
      |       let mut st_else = st_else0
      |       for instr in else_instrs {
      |         st_else = match Typecheck::typecheck(instr, st_else) {
      |           Err(e) => return Err(e)
      |           Ok(s) => s
      |         }
      |       }
      |       let norm_branch = fn(
      |         sb : TcState,
      |       ) -> Result[(Bool, Array[ValType]), String] {
      |         let sb2 = if sb.reachable {
      |           match sb.pop_types(results) {
 4246 |             Err(e) => return Err(e)
      |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |             Ok(s) => s
      |           }
      |         } else {
      |           sb
      |         }
      |         let stack2 = sb2.stack.copy()
      |         while stack2.length() > base_len {
      |           ignore(stack2.pop())
      |         }
      |         Ok((sb2.reachable, stack2))
      |       }
      |       let (then_reach, then_stack) = match norm_branch(st_then) {
 4259 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(x) => x
      |       }
      |       let (else_reach, else_stack) = match norm_branch(st_else) {
 4263 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(x) => x
      |       }
      |       let merged_stack = match (then_reach, else_reach) {
      |         (true, true) => {
      |           if then_stack != else_stack {
 4269 |             return Err("if branch stack mismatch")
      |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           }
      |           then_stack
      |         }
      |         (true, false) => then_stack
      |         (false, true) => else_stack
      |         (false, false) => st1.stack.copy()
      |       }
      |       let merged_reachable = then_reach || else_reach
      |       let out = TcState::{
      |         env: st.env,
      |         stack: merged_stack,
      |         reachable: merged_reachable,
      |       }
      |       Ok(out.push_types(results))
      |     }
      |     TTryTable(bt, catches, body) => {
      |       let (params, results) = match st.env.expand_blocktype(bt) {
 4287 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(x) => x
      |       }
      |       let st1 = match st.pop_types(params) {
 4291 |         Err(e) => return Err(e)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(s) => s
      |       }
      |       let base_len = st1.stack.length()
      |       let env2 = st1.env.with_label(results)
      |       let st_body0 = TcState::{ ..st1, env: env2 }
      |       let mut st_body = st_body0
      |       let TExpr(body) = body
      |       for instr in body {
      |         st_body = match Typecheck::typecheck(instr, st_body) {
      |           Err(e) => return Err(e)
      |           Ok(s) => s
      |         }
      |       }
      |       let st_catch_ctx = TcState::{ ..st1, env: env2 }
      |       for c in catches {
      |         match typecheck_catch_clause(st_catch_ctx, c) {
      |           Err(e) => return Err(e)
      |           Ok(_) => ()
      |         }
      |       }
      |       let st2 = if st_body.reachable {
 4313 |         match st_body.pop_types(results) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Err(e) => return Err(e)
      |           Ok(s) => s
      |         }
      |       } else {
      |         st_body
      |       }
      |       let stack2 = st2.stack.copy()
      |       while stack2.length() > base_len {
      |         ignore(stack2.pop())
      |       }
      |       let out = TcState::{
      |         env: st.env,
      |         stack: stack2,
      |         reachable: st2.reachable,
      |       }
      |       Ok(out.push_types(results))
      |     }
      |     TThrow(tag, args) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
 4336 |           Err(t) => return Err(t)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         }
      |       }
      |       typecheck_throw(st_acc, tag)
      |     }
      | 
      |     // === Branches ===
 4343 |     TBr(l, args) => {
      |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4346 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4351 |       typecheck_br(st_acc, l)
      |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TBrIf(l, cond, args) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
 4358 |           Err(t) => return Err(t)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         }
      |       }
      |       let st_cond = match Typecheck::typecheck(cond, st_acc) {
      |         Ok(st) => st
 4363 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_br_if(st_cond, l)
      |     }
      |     TBrTable(ls, ldef, index, args) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
 4372 |           Err(t) => return Err(t)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         }
      |       }
      |       let st_idx = match Typecheck::typecheck(index, st_acc) {
      |         Ok(st) => st
 4377 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_br_table(st_idx, ls, ldef)
      |     }
 4381 |     TBrOnNull(l, r, args) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4384 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4389 |       let st_ref = match Typecheck::typecheck(r, st_acc) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4393 |       typecheck_br_on_null(st_ref, l)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4395 |     TBrOnNonNull(l, r, args) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4398 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4403 |       let st_ref = match Typecheck::typecheck(r, st_acc) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4407 |       typecheck_br_on_non_null(st_ref, l)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4409 |     TBrOnCast(l, op, ht1, ht2, r, args) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4412 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4417 |       let st_ref = match Typecheck::typecheck(r, st_acc) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4421 |       typecheck_br_on_cast(st_ref, l, op, ht1, ht2)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4423 |     TBrOnCastFail(l, op, ht1, ht2, r, args) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let mut st_acc = st
      |       for arg in args {
 4426 |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
 4431 |       let st_ref = match Typecheck::typecheck(r, st_acc) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4435 |       typecheck_br_on_cast_fail(st_ref, l, op, ht1, ht2)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TReturn(args) => {
      |       let mut st_acc = st
      |       for arg in args {
      |         st_acc = match Typecheck::typecheck(arg, st_acc) {
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
      |       typecheck_return(st_acc)
      |     }
      | 
      |     // === Select ===
 4449 |     TSelect(ty_opt, cond, t, f) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st_f = match Typecheck::typecheck(f, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4454 |       let st_t = match Typecheck::typecheck(t, st_f) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4458 |       let st_cond = match Typecheck::typecheck(cond, st_t) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4462 |       match ty_opt {
      |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         None => typecheck_select_untyped(st_cond)
      |         Some(ts) => typecheck_select_typed(st_cond, ts)
      |       }
      |     }
      | 
      |     // === Structs ===
      |     TStructNew(x, fields) => {
      |       let mut st_acc = st
      |       for f in fields {
      |         st_acc = match Typecheck::typecheck(f, st_acc) {
      |           Ok(st) => st
      |           Err(t) => return Err(t)
      |         }
      |       }
      |       typecheck_struct_new(st_acc, x)
      |     }
 4479 |     TStructNewDefault(x) => typecheck_struct_new_default(st, x)
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     TStructGet(x, i, s) => {
      |       let st1 = match Typecheck::typecheck(s, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       typecheck_struct_get(st1, x, i)
      |     }
      |     TStructGetS(x, i, s) => {
      |       let st1 = match Typecheck::typecheck(s, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       typecheck_struct_get_s(st1, x, i)
      |     }
 4494 |     TStructGetU(x, i, s) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(s, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4499 |       typecheck_struct_get_u(st1, x, i)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TStructSet(x, i, s, val) => {
      |       let st1 = match Typecheck::typecheck(s, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       let st2 = match Typecheck::typecheck(val, st1) {
      |         Ok(st) => st
 4508 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_struct_set(st2, x, i)
      |     }
      | 
      |     // === Arrays ===
      |     TArrayNew(x, init, len) => {
      |       let st1 = match Typecheck::typecheck(init, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       let st2 = match Typecheck::typecheck(len, st1) {
      |         Ok(st) => st
 4521 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_new(st2, x)
      |     }
      |     TArrayNewDefault(x, len) => {
      |       let st1 = match Typecheck::typecheck(len, st) {
      |         Ok(st) => st
 4528 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_new_default(st1, x)
      |     }
      |     TArrayNewFixed(x, fields) => {
      |       let mut st_acc = st
      |       for f in fields {
      |         st_acc = match Typecheck::typecheck(f, st_acc) {
      |           Ok(st) => st
 4537 |           Err(t) => return Err(t)
      |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         }
      |       }
      |       typecheck_array_new_fixed(
      |         st_acc,
      |         x,
      |         fields.length().reinterpret_as_uint(),
      |       )
      |     }
 4546 |     TArrayNewData(x, y, offset, len) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(offset, st) {
      |         Ok(t) => t
      |         Err(t) => return Err(t)
      |       }
 4551 |       let st2 = match Typecheck::typecheck(len, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(t) => t
      |         Err(t) => return Err(t)
      |       }
 4555 |       typecheck_array_new_data(st2, x, y)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4557 |     TArrayNewElem(x, y, offset, len) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(offset, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4562 |       let st2 = match Typecheck::typecheck(len, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4566 |       typecheck_array_new_elem(st2, x, y)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TArrayGet(x, arr, idx) => {
      |       let st1 = match Typecheck::typecheck(arr, st) {
      |         Ok(st) => st
 4571 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(idx, st1) {
      |         Ok(st) => st
 4575 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_get(st2, x)
      |     }
      |     TArrayGetS(x, arr, idx) => {
      |       let st1 = match Typecheck::typecheck(arr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       let st2 = match Typecheck::typecheck(idx, st1) {
      |         Ok(st) => st
 4586 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_get_s(st2, x)
      |     }
 4590 |     TArrayGetU(x, arr, idx) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(arr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4595 |       let st2 = match Typecheck::typecheck(idx, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4599 |       typecheck_array_get_u(st2, x)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TArraySet(x, arr, idx, val) => {
      |       let st1 = match Typecheck::typecheck(arr, st) {
      |         Ok(st) => st
 4604 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(idx, st1) {
      |         Ok(st) => st
 4608 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st3 = match Typecheck::typecheck(val, st2) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       typecheck_array_set(st3, x)
      |     }
      |     TArrayFill(x, arr, offset, val, len) => {
      |       let st1 = match Typecheck::typecheck(arr, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       let st2 = match Typecheck::typecheck(offset, st1) {
      |         Ok(st) => st
 4623 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st3 = match Typecheck::typecheck(val, st2) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       let st4 = match Typecheck::typecheck(len, st3) {
      |         Ok(st) => st
 4631 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_fill(st4, x)
      |     }
      |     TArrayCopy(x, y, arr2, idx2, arr1, idx1, len) => {
      |       let st1 = match Typecheck::typecheck(arr2, st) {
      |         Ok(st) => st
 4638 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st2 = match Typecheck::typecheck(idx2, st1) {
      |         Ok(st) => st
 4642 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st3 = match Typecheck::typecheck(arr1, st2) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
      |       let st4 = match Typecheck::typecheck(idx1, st3) {
      |         Ok(st) => st
 4650 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       let st5 = match Typecheck::typecheck(len, st4) {
      |         Ok(st) => st
 4654 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_array_copy(st5, x, y)
      |     }
 4658 |     TArrayInitData(x, y, i0, i1, i2, i3) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(i0, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4663 |       let st2 = match Typecheck::typecheck(i1, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4667 |       let st3 = match Typecheck::typecheck(i2, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4671 |       let st4 = match Typecheck::typecheck(i3, st3) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4675 |       typecheck_array_init_data(st4, x, y)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4677 |     TArrayInitElem(x, y, i0, i1, i2, i3) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(i0, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4682 |       let st2 = match Typecheck::typecheck(i1, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4686 |       let st3 = match Typecheck::typecheck(i2, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4690 |       let st4 = match Typecheck::typecheck(i3, st3) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4694 |       typecheck_array_init_elem(st4, x, y)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === GC: Casts ===
 4698 |     TRefGetDesc(child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4703 |       typecheck_ref_get_desc(st1)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4705 |     TRefTest(nullable, ht, child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4710 |       typecheck_ref_test(st1, nullable, ht)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      |     TRefCast(nullable, ht, child) => {
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st) => st
 4715 |         Err(t) => return Err(t)
      |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       }
      |       typecheck_ref_cast(st1, nullable, ht)
      |     }
 4719 |     TRefTestDesc(nullable, ht, child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4724 |       typecheck_ref_test_desc(st1, nullable, ht)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4726 |     TRefCastDescEq(nullable, ht, child) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(child, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4731 |       typecheck_ref_cast_desc_eq(st1, nullable, ht)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === SIMD: Splat ===
 4735 |     TI8x16Splat(x) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(x, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4740 |       typecheck_splat(st1, ValType::i32())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4742 |     TI16x8Splat(x) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(x, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4747 |       typecheck_splat(st1, ValType::i32())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4749 |     TI32x4Splat(x) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(x, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4754 |       typecheck_splat(st1, ValType::i32())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4756 |     TI64x2Splat(x) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(x, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4761 |       typecheck_splat(st1, ValType::i64())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4763 |     TF32x4Splat(x) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(x, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4768 |       typecheck_splat(st1, ValType::f32())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4770 |     TF64x2Splat(x) => {
      |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(x, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4775 |       typecheck_splat(st1, ValType::f64())
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === SIMD: Extract lane ===
 4779 |     TExtractLane(op, _, vec) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(vec, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4784 |       match op {
      |       ^^^^^^^^^^ 	<-- UNCOVERED
      |         I8x16ExtractLaneSOp => typecheck_lane_extract(st1, ValType::i32())
      |         I8x16ExtractLaneUOp => typecheck_lane_extract(st1, ValType::i32())
      |         I16x8ExtractLaneSOp => typecheck_lane_extract(st1, ValType::i32())
      |         I16x8ExtractLaneUOp => typecheck_lane_extract(st1, ValType::i32())
      |         I32x4ExtractLaneOp => typecheck_lane_extract(st1, ValType::i32())
      |         I64x2ExtractLaneOp => typecheck_lane_extract(st1, ValType::i64())
      |         F32x4ExtractLaneOp => typecheck_lane_extract(st1, ValType::f32())
      |         F64x2ExtractLaneOp => typecheck_lane_extract(st1, ValType::f64())
      |       }
      |     }
      | 
      |     // === SIMD: Replace lane ===
 4797 |     TReplaceLane(op, _, vec, val) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(vec, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4802 |       let st2 = match Typecheck::typecheck(val, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4806 |       match op {
      |       ^^^^^^^^^^ 	<-- UNCOVERED
      |         I8x16ReplaceLaneOp => typecheck_lane_replace(st2, ValType::i32())
      |         I16x8ReplaceLaneOp => typecheck_lane_replace(st2, ValType::i32())
      |         I32x4ReplaceLaneOp => typecheck_lane_replace(st2, ValType::i32())
      |         I64x2ReplaceLaneOp => typecheck_lane_replace(st2, ValType::i64())
      |         F32x4ReplaceLaneOp => typecheck_lane_replace(st2, ValType::f32())
      |         F64x2ReplaceLaneOp => typecheck_lane_replace(st2, ValType::f64())
      |       }
      |     }
      | 
      |     // === SIMD: Shuffle ===
 4817 |     TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, v1, v2) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(v1, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4822 |       let st2 = match Typecheck::typecheck(v2, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4826 |       typecheck_v128_binary(st2)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4828 |     TI8x16Swizzle(v1, v2) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(v1, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4833 |       let st2 = match Typecheck::typecheck(v2, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4837 |       typecheck_v128_binary(st2)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
 4839 |     TI8x16RelaxedSwizzle(v1, v2) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(v1, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4844 |       let st2 = match Typecheck::typecheck(v2, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4848 |       typecheck_v128_binary(st2)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === SIMD: Shift ===
 4852 |     TV128Shift(_, vec, shift) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(vec, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4857 |       let st2 = match Typecheck::typecheck(shift, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4861 |       typecheck_v128_shift(st2)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === SIMD: Ternary ===
 4865 |     TV128Ternary(_, c, v1, v2) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(c, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4870 |       let st2 = match Typecheck::typecheck(v1, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4874 |       let st3 = match Typecheck::typecheck(v2, st2) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4878 |       typecheck_v128_ternary(st3)
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     }
      | 
      |     // === SIMD: Lane load/store ===
 4882 |     TV128LoadLane(op, ma, _, vec, addr) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(vec, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4887 |       let st2 = match Typecheck::typecheck(addr, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4891 |       match op {
      |       ^^^^^^^^^^ 	<-- UNCOVERED
      |         V128Load8LaneOp => typecheck_v128_load_lane(st2, ma, 8)
      |         V128Load16LaneOp => typecheck_v128_load_lane(st2, ma, 16)
      |         V128Load32LaneOp => typecheck_v128_load_lane(st2, ma, 32)
      |         V128Load64LaneOp => typecheck_v128_load_lane(st2, ma, 64)
      |       }
      |     }
 4898 |     TV128StoreLane(op, ma, _, vec, addr) => {
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |       let st1 = match Typecheck::typecheck(vec, st) {
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4903 |       let st2 = match Typecheck::typecheck(addr, st1) {
      |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |         Ok(st) => st
      |         Err(t) => return Err(t)
      |       }
 4907 |       match op {
      |       ^^^^^^^^^^ 	<-- UNCOVERED
      |         V128Store8LaneOp => typecheck_v128_store_lane(st2, ma, 8)
      |         V128Store16LaneOp => typecheck_v128_store_lane(st2, ma, 16)
      |         V128Store32LaneOp => typecheck_v128_store_lane(st2, ma, 32)
      |         V128Store64LaneOp => typecheck_v128_store_lane(st2, ma, 64)
      |       }
      |     }
      |   }
      | }
      …

      | fn assert_stack(state : TcState, expected : Array[ValType]) -> Unit {
      |   if not(equals(state.stack, expected)) {
 4937 |     abort("Stack mismatch: expected \{expected}, got \{state.stack}")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn[T] assert_ok(result : Result[T, String]) -> T {
      |   match result {
      |     Ok(v) => v
 4945 |     Err(e) => abort("Expected Ok, got Err: \{e}")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |   }
      | }
      …

      | fn[T : Show] assert_err(result : Result[T, String]) -> Unit {
      |   match result {
 4952 |     Ok(v) => abort("Expected Err, got Ok: \{v}")
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
      |     Err(_) => ()
      |   }
      | }
      …

2 uncovered line(s) in src/validate/typecheck_negative_tests.mbt:

    | fn[T : Show] tcneg_assert_err_contains(
    |   result : Result[T, String],
    |   needle : String,
    | ) -> Unit {
    |   match result {
 12 |     Ok(v) => abort("expected Err containing '\{needle}', got Ok: \{v}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) =>
    |       if !e.contains(needle) {
 15 |         abort("expected Err containing '\{needle}', got: \{e}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |   }
    | }
    …

79 uncovered line(s) in src/validate/validate.mbt:

     | pub impl Validate for HeapType with validate(self, env) {
     |   match self {
     |     AbsHeapTypeHeapType(abs) => Validate::validate(abs, env)
     |     HeapType(tidx) => Validate::validate(tidx, env)
  41 |     DefTypeHeapType(dt) => Validate::validate(dt, env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Validate for DefType with validate(self, env) {
  47 |   let DefType(rt, _) = self
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let env2 = env_with_rectype(env, rt)
     |   match self.project() {
     |     Some(st) => Validate::validate(st, env2)
     |     None => Err("Invalid SubType Index")
     |   }
     | }
     …

     | pub impl[T : Validate] Validate for Array[T] with validate(self, env) {
     |   for v in self {
     |     if Validate::validate(v, env) is Err(t) {
  74 |       return Err(t)
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(())
     | }
     …

     | pub impl Validate for FuncType with validate(self, env) {
     |   let FuncType(t0, t1) = self
     |   match Validate::validate(t0, env) {
     |     Ok(_) => Validate::validate(t1, env)
 102 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Validate for CompType with validate(self, env) {
     |   match self {
     |     StructCompType(fts) => Validate::validate(fts, env)
     |     ArrayCompType(ft) => Validate::validate(ft, env)
     |     FuncCompType(v0, v1) =>
     |       match Validate::validate(v0, env) {
     |         Ok(_) => Validate::validate(v1, env)
 114 |         Err(t) => Err(t)
     |         ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | pub impl Validate for SubType with validate(self, env) {
     |   match self {
 152 |     SubType(_, matches, ct) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for m in matches {
 154 |         match Validate::validate(m, env) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(_) if env.resolve_subtype(m) is Some(t) &&
 156 |             Match::matches(ct, t.get_comptype(), env) => ()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(_) => return Err("Invalid subtype")
     |           Err(t) => return Err(t)
     |         }
     |       }
     |       Ok(())
     |     }
     |     CompTypeSubType(ct) => Validate::validate(ct, env)
     |   }
     | }
     …

     | pub impl ValidateMax for Limits with validate_max(self, _, k) {
     |   match self {
     |     I32Limits(n, m) => {
     |       let n = n.to_uint64()
     |       if n <= k &&
     |         (
     |           m is None ||
     |           (m is Some(m) && n <= m.to_uint64() && m.to_uint64() <= k)
     |         ) {
     |         Ok(())
     |       } else {
     |         Err("Invalid range for limits")
     |       }
     |     }
     |     I64Limits(n, m) =>
     |       if n <= k && (m is None || (m is Some(m) && n <= m && m <= k)) {
     |         Ok(())
     |       } else {
 186 |         Err("Invalid range for limits")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |   }
     | }
     …

     | pub impl Validate for TagType with validate(self, env) {
     |   let TagType(tidx) = self
     |   if Validate::validate(tidx, env) is Err(t) {
 215 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   match env.resolve_comptype(tidx) {
     |     Some(FuncCompType(params, results)) => {
     |       if results.length() != 0 {
 220 |         return Err("Tag type must have empty result list")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Validate::validate(params, env)
     |     }
 224 |     _ => Err("TagType not found or not a function type")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Validate for TagSec with validate(self, env) {
 230 |   let TagSec(t) = self
     |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   Validate::validate(t, env)
     | }
     …

     | pub impl Validate for Catch with validate(self, env) {
     |   match self {
     |     Catch(t, l) =>
 238 |       match Validate::validate(t, env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(_) => Validate::validate(l, env)
     |         Err(t) => Err(t)
     |       }
     |     CatchRef(t, l) =>
 243 |       match Validate::validate(t, env) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(_) => Validate::validate(l, env)
     |         Err(t) => Err(t)
     |       }
     |     CatchAll(l) => Validate::validate(l, env)
     |     CatchAllRef(l) => Validate::validate(l, env)
     |   }
     | }
     …

     | pub impl Validate for TableType with validate(self, env) {
     |   let TableType(rt, lim) = self
     |   match Validate::validate(rt, env) {
     |     Ok(_) => ValidateMax::validate_max(lim, env, 4294967295)
 269 |     Err(t) => Err(t)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub impl Validate for ExternType with validate(self, env) {
     |   match self {
 276 |     TagExternType(tt) => Validate::validate(tt, env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     GlobalExternType(gt) => Validate::validate(gt, env)
     |     MemExternType(mt) => Validate::validate(mt, env)
     |     TableExternType(tt) => Validate::validate(tt, env)
     |     FuncExternType(tidx) =>
     |       match env.resolve_functype(tidx) {
     |         Some(_) => Ok(())
     |         None => Err("Invalid ExternType: Func extern type not found")
     |       }
     |   }
     | }
     …

     | fn is_const_instr(ins : Instruction) -> Bool {
     |   match ins {
     |     I32Const(_) => true
     |     I64Const(_) => true
     |     F32Const(_) => true
     |     F64Const(_) => true
 295 |     V128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     RefNull(_) => true
     |     RefFunc(_) => true
 298 |     GlobalGet(_) => true
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Optional: enable later if desired/confirmed by spec subset you target
     |     // RefI31 => true
     |     _ => false
     |   }
     | }
     …

     | fn validate_const_expr(
     |   env : Env,
     |   expr : Expr,
     |   want : ValType,
     | ) -> Result[Unit, String] {
     |   let Expr(instrs) = expr
     | 
     |   // syntactic const restriction
     |   for ins in instrs {
     |     if !is_const_instr(ins) {
     |       return Err("initializer expression is not constant")
     |     }
     |   }
     | 
     |   // typecheck it under an empty stack/locals/labels context
     |   // (but with access to env globals, funcs, etc)
     |   let env_tc = Env::{ ..env, locals: [], labels: [], return_type: None }
     |   let st0 = TcState::{ env: env_tc, stack: [], reachable: true }
     |   let st1 = match Typecheck::typecheck(expr, st0) {
     |     Ok(s) => s
     |     Err(e) => return Err(e)
     |   }
     |   if !st1.reachable {
 330 |     return Err("const expr is unreachable")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if st1.stack.length() != 1 {
     |     return Err("const expr must leave exactly one value on the stack")
     |   }
     |   let actual = st1.stack[0]
     |   if Match::matches(actual, want, env_tc) {
     |     Ok(())
     |   } else {
     |     Err("const expr result type mismatch")
     |   }
     | }
     …

     | fn validate_global(env : Env, g : Global) -> Result[GlobalType, String] {
     |   let Global(gt, init) = g
     |   if Validate::validate(gt, env) is Err(t) {
 347 |     return Err(t) // checks vt validity
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let GlobalType(vt, _mut) = gt
     |   match validate_const_expr(env, init, vt) {
     |     Ok(_) => Ok(gt)
     |     Err(t) => Err(t)
     |   }
     | }
     …

     | pub fn validate_tagsec(tagsec : TagSec?, env0 : Env) -> Result[Env, String] {
     |   match tagsec {
     |     None => Ok(env0)
     |     Some(TagSec(tags)) => {
     |       let mut env = env0
     |       let out = env.tags.copy()
     |       for t in tags {
     |         // validate tag type under current env
     |         if Validate::validate(t, env) is Err(t) {
 392 |           return Err(t)
     |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     | 
     |         // extend tag index space incrementally
     |         out.push(t)
     |         env = Env::{
     |           global_types: env.global_types,
     |           rec_stack: env.rec_stack,
     |           funcs: env.funcs,
     |           tables: env.tables,
     |           mems: env.mems,
     |           globals: env.globals,
     |           elems: env.elems,
     |           datas: env.datas,
     |           tags: out,
     |           locals: env.locals,
     |           labels: env.labels,
     |           return_type: env.return_type,
     |         }
     |       }
     |       Ok(env)
     |     }
     |   }
     | }
     …

     | pub fn validate_memsec(memsec : MemSec?, env0 : Env) -> Result[Env, String] {
     |   match memsec {
     |     None => Ok(env0)
     |     Some(MemSec(ms)) => {
     |       let mut env = env0
     |       for mt in ms {
     |         match Validate::validate(mt, env) {
     |           Ok(_) => ()
 426 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         env = env.push_mem(mt)
     |       }
     |       Ok(env)
     |     }
     |   }
     | }
     …

     | fn validate_table(env : Env, t : Table) -> Result[TableType, String] {
     |   let Table(tt, init_opt) = t
     |   match Validate::validate(tt, env) {
     |     Ok(_) => ()
 440 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let TableType(rt, _lim) = tt
     |   match init_opt {
 444 |     None => Ok(tt)
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(init) => {
     |       // init expr must be const and produce value type rt
     |       let want = ValType::ref_type(rt)
     |       match validate_const_expr(env, init, want) {
     |         Ok(_) => Ok(tt)
     |         Err(e) => Err(e)
     |       }
     |     }
     |   }
     | }
     …

     | fn validate_locals_decls(
     |   env : Env,
     |   decls : Array[Locals],
     | ) -> Result[Unit, String] {
 482 |   for d in decls {
     |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     let Locals(n, vt) = d
     |     if Validate::validate(vt, env) is Err(e) {
 485 |       return Err(e)
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
 487 |     let count = n.reinterpret_as_int()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     if count < 0 {
 489 |       return Err("locals: negative count")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if !has_default(vt) {
 492 |       return Err("locals: type has no default value")
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(())
     | }
     …

     | fn validate_func_body_against_functype(
     |   env : Env,
     |   ft : FuncType,
     |   f : Func,
     | ) -> Result[Unit, String] {
     |   let FuncType(params, results) = ft
     |   match f {
 506 |     Func(local_decls, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       // Validate local declarations
     |       if validate_locals_decls(env, local_decls) is Err(e) {
 509 |         return Err(e)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       // Expand locals vector = params ++ expanded locals
 513 |       let locals_extra = match expand_locals(local_decls) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(xs) => xs
     |         Err(e) => return Err(e)
     |       }
 517 |       let all_locals = params.copy()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for vt in locals_extra {
 519 |         all_locals.push(vt)
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       // Extend context:
     |       // - locals
     |       // - labels appended by results (function label)
     |       // - return appended by results
     |       let env1 = env
 527 |         .with_locals(all_locals)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         .with_labels(
     |           {
 530 |             let ls = env.labels.copy()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             ls.push(results)
     |             ls
     |           },
     |         )
 535 |         .with_return_type(Some(results))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let st0 = TcState::{ env: env1, stack: [], reachable: true }
 537 |       let st1 = match Typecheck::typecheck(body, st0) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(s) => s
     |         Err(e) => return Err(e)
     |       }
     | 
     |       // Enforce results at end if reachable
     |       if st1.reachable {
 544 |         if st1.stack.length() != results.length() {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Err("function body leaves extra values on stack")
     |         }
     |         // Check types match
     |         for i in 0..<results.length() {
 549 |           if !Match::matches(st1.stack[i], results[i], env1) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             return Err("function body result type mismatch")
     |           }
     |         }
     |       }
     |       Ok(())
     |     }
     |     TFunc(local_vals, texpr) => {
     |       // TFunc(Array[ValType], TExpr) - local_vals contains the full local signature (params + extra locals)
     |       // Wait, does it contain params?
     |       // Given FuncType has params, and TFunc is the definition.
     |       // If TFunc matches the structure of Func (replacing Array[Locals] with Array[ValType]),
     |       // then local_vals are the EXTRA locals.
     |       // But TFunc is usually "fully typed". Let's assume local_vals = extra_locals flattened.
     | 
     |       let all_locals = params.copy()
     |       for vt in local_vals {
     |         all_locals.push(vt)
     |       }
     |       let env1 = env
     |         .with_locals(all_locals)
     |         .with_labels(
     |           {
     |             let ls = env.labels.copy()
     |             ls.push(results)
     |             ls
     |           },
     |         )
     |         .with_return_type(Some(results))
     |       let st0 = TcState::{ env: env1, stack: [], reachable: true }
     |       let st1 = match Typecheck::typecheck(texpr, st0) {
     |         Ok(s) => s
     |         Err(e) => return Err(e)
     |       }
     |       if st1.reachable {
     |         if st1.stack.length() != results.length() {
 585 |           return Err("typed function body leaves extra values on stack")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         for i in 0..<results.length() {
 588 |           if !Match::matches(st1.stack[i], results[i], env1) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             return Err("typed function body result type mismatch")
     |           }
     |         }
     |       }
     |       Ok(())
     |     }
     |   }
     | }
     …

     | pub fn validate_codesec(
     |   codesec : CodeSec?,
     |   funcsec : FuncSec?,
     |   env : Env,
     | ) -> Result[Unit, String] {
     |   match (codesec, funcsec) {
 605 |     (None, None) => Ok(())
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (Some(CodeSec(_)), None) => Err("codesec present without funcsec")
     |     (None, Some(FuncSec(ts))) =>
 608 |       if ts.length() == 0 {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(())
     |       } else {
 611 |         Err("funcsec present without codesec")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     (Some(CodeSec(bodies)), Some(FuncSec(type_idxs))) => {
     |       if bodies.length() != type_idxs.length() {
 615 |         return Err("codesec length does not match funcsec length")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let n_defined = bodies.length()
     |       let n_total = env.funcs.length()
     |       let n_imported = n_total - n_defined
     |       if n_imported < 0 {
 621 |         return Err("internal: negative imported func count")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for i in 0..<bodies.length() {
     |         let ft = match env.funcs.get(n_imported + i) {
     |           Some(x) => x
 626 |           None => return Err("internal: missing functype for code body")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         if validate_func_body_against_functype(env, ft, bodies[i]) is Err(e) {
     |           return Err(e)
     |         }
     |       }
     |       Ok(())
     |     }
     |   }
     | }
     …

     | pub fn validate_funcsec(funcsec : FuncSec?, env0 : Env) -> Result[Env, String] {
     |   match funcsec {
 640 |     None => Ok(env0)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(FuncSec(type_idxs)) => {
     |       let mut env = env0
     |       for tidx in type_idxs {
     |         // Each TypeIdx must resolve to a function type
     |         let ft = match env.resolve_functype(tidx) {
     |           Some(x) => x
     |           None => return Err("funcsec: typeidx does not resolve to functype")
     |         }
     |         env = env.push_func(ft)
     |       }
     |       Ok(env)
     |     }
     |   }
     | }
     …

     | fn validate_elem_mode(
     |   env : Env,
     |   mode : ElemMode,
     |   rt : RefType,
     | ) -> Result[Unit, String] {
     |   match mode {
     |     Passive => Ok(())
     |     Declarative => Ok(())
     |     Active(tidx, offset_expr) => {
     |       // table must exist
     |       let TableType(rt_table, lim) = match env.get_table_type(tidx) {
     |         None => return Err("elem.active: invalid table index")
     |         Some(tt) => tt
     |       }
     | 
     |       // require rt ≤ rt_table
     |       // If your Match::matches works on RefType, use that.
     |       // Otherwise use ValType wrapper.
     |       let ok = Match::matches(
     |         ValType::ref_type(rt),
     |         ValType::ref_type(rt_table),
     |         env,
     |       )
     |       if !ok {
 725 |         return Err("elem.active: elem type does not match table element type")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       // offset expr : at const
     |       let at = lim.addr_valtype()
     |       validate_const_expr(env, offset_expr, at)
     |     }
     |   }
     | }
     …

     | pub impl Validate for ElemKind with validate(self, env) {
     |   match self {
     |     // elemtype is funcref; initializers are function indices
 739 |     FuncsElemKind(fs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       for f in fs {
 741 |         if !env.has_func(f) {
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Err("elem.funcs: invalid function index")
     |         }
     |       }
     |       Ok(())
     |     }
     | 
     |     // legacy element expressions: elemtype is funcref; each expr must be const funcref
 749 |     FuncExprsElemKind(exprs) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let want = ValType::funcref()
     |       for e in exprs {
 752 |         if validate_const_expr(env, e, want) is Err(t) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Err(t)
     |         }
     |       }
     |       Ok(())
     |     }
     | 
     |     // typed element expressions: elemtype is provided; each expr must be const of that type
     |     TypedExprsElemKind(rt, exprs) => {
     |       if Validate::validate(rt, env) is Err(t) {
 762 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let want = ValType::ref_type(rt)
     |       for e in exprs {
     |         if validate_const_expr(env, e, want) is Err(t) {
     |           return Err(t)
     |         }
     |       }
     |       Ok(())
     |     }
     |   }
     | }
     …

     | pub impl Validate for Elem with validate(self, env) {
     |   let Elem(mode, kind) = self
     | 
     |   // kind validity (incl. elemtype and init exprs)
     |   if Validate::validate(kind, env) is Err(t) {
     |     return Err(t)
     |   }
     | 
     |   // derive elemtype from kind and validate it
     |   let rt = Elem::reftype(self)
     |   if Validate::validate(rt, env) is Err(t) {
 787 |     return Err(t)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // mode validity depends on elemtype
     |   validate_elem_mode(env, mode, rt)
     | }
     …

     | pub fn validate_importsec(
     |   importsec : ImportSec?,
     |   env0 : Env,
     | ) -> Result[Env, String] {
     |   match importsec {
     |     None => Ok(env0)
 826 |     Some(ImportSec(imps)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let mut env = env0
     |       for imp in imps {
 829 |         if Validate::validate(imp, env) is Err(e) {
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           return Err(e)
     |         }
     |         let Import(_, _, et) = imp
 833 |         match et {
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |           FuncExternType(tidx) => {
     |             let ft = match env.resolve_functype(tidx) {
     |               Some(x) => x
     |               None => return Err("import func: type index is not a functype")
     |             }
 839 |             env = env.push_func(ft)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
 841 |           TableExternType(tt) => env = env.push_table(tt)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           MemExternType(mt) => env = env.push_mem(mt)
     |           GlobalExternType(gt) => env = env.push_global(gt)
     |           TagExternType(tt) => env = env.push_tag(tt)
     |         }
     |       }
     |       Ok(env)
     |     }
     |   }
     | }
     …

     | pub fn validate_startsec(
     |   startsec : StartSec?,
     |   env : Env,
     | ) -> Result[Unit, String] {
     |   match startsec {
     |     None => Ok(())
     |     Some(StartSec(fidx)) => {
     |       let FuncType(params, results) = match env.get_functype_by_funcidx(fidx) {
 861 |         None => return Err("start: invalid function index")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(ft) => ft
     |       }
     |       if params.length() != 0 {
     |         return Err("start function must have empty parameter list")
     |       }
     |       if results.length() != 0 {
 868 |         return Err("start function must have empty result list")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Ok(())
     |     }
     |   }
     | }
     …

     | pub impl Validate for ExternIdx with validate(self, env) {
     |   match self {
     |     FuncExternIdx(i) => Validate::validate(i, env)
     |     TableExternIdx(i) => Validate::validate(i, env)
     |     MemExternIdx(i) => Validate::validate(i, env)
     |     GlobalExternIdx(i) => Validate::validate(i, env)
 917 |     TagExternIdx(i) => Validate::validate(i, env)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn validate_exportsec(
     |   exportsec : ExportSec?,
     |   env : Env,
     | ) -> Result[Unit, String] {
 932 |   match exportsec {
     |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => Ok(())
     |     Some(ExportSec(es)) => Validate::validate(es, env)
     |   }
     | }
     …

     | pub fn validate_typesec(typesec : TypeSec?, env0 : Env) -> Result[Env, String] {
     |   match typesec {
 942 |     None => Ok(env0)
     |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(TypeSec(rts)) => {
     |       let mut env = env0
     |       for rt in rts {
     |         env = match validate_rectype_and_extend(env, rt) {
     |           Ok(e) => e
 948 |           Err(t) => return Err(t)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       Ok(env)
     |     }
     |   }
     | }
     …

     | fn validate_rectype_and_extend(env : Env, rt : RecType) -> Result[Env, String] {
     |   // Validate rectype under recursive context (for RecIdx references)
     |   let env_rec = env_with_rectype(env, rt)
     | 
     |   // Validate rectype itself under env_rec
     |   if Validate::validate(rt, env_rec) is Err(e) {
 963 |     return Err(e)
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // If ok, append its defined subtypes to env.global_types
     |   Ok(env.append_rectype_types(rt))
     | }
     …

     | pub fn validate_datacnt(
     |   datacnt_opt : DataCntSec?,
     |   datasec_opt : DataSec?,
     | ) -> Result[Unit, String] {
     |   match datacnt_opt {
     |     None => Ok(())
     |     Some(DataCntSec(U32(n))) => {
     |       let actual : UInt = match datasec_opt {
 979 |         None => return Err("datacount section present but no data section")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(DataSec(ds)) => ds.length().reinterpret_as_uint()
     |       }
     |       if n == actual {
     |         Ok(())
     |       } else {
 985 |         Err("datacount does not match number of data segments")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |   }
     | }
     …

     | fn validate_exportsec_unique(
     |   exportsec : ExportSec?,
     |   env : Env,
     | ) -> Result[Unit, String] {
     |   match exportsec {
     |     None => Ok(())
     |     Some(ExportSec(es)) => {
     |       // First validate all exports
     |       if Validate::validate(es, env) is Err(t) {
1002 |         return Err(t)
     |         ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       // Check for duplicate export names
     |       let names : Array[Name] = []
     |       for e in es {
     |         let Export(name, _) = e
     |         for existing in names {
1009 |           if existing == name {
     |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             return Err("duplicate export name: " + name.0.to_string())
     |           }
     |         }
     |         names.push(name)
     |       }
     |       Ok(())
     |     }
     |   }
     | }
     …

     | pub fn validate_module(m : Module) -> Result[Unit, String] {
     |   let {
     |     type_sec: typesec_opt,
     |     import_sec: importsec_opt,
     |     func_sec: funcsec_opt,
     |     table_sec: tablesec_opt,
     |     mem_sec: memsec_opt,
     |     tag_sec: tagsec_opt,
     |     global_sec: globalsec_opt,
     |     export_sec: exportsec_opt,
     |     start_sec: startsec_opt,
     |     elem_sec: elemsec_opt,
     |     data_cnt_sec: datacntsec_opt,
     |     code_sec: codesec_opt,
     |     data_sec: datasec_opt,
     |     ..,
     |   } = m
     | 
     |   // Start from empty env (module validation does not take an external env)
     |   let mut env = empty_env()
     | 
     |   // (1) Types: defines global type index space
     |   env = match validate_typesec(typesec_opt, env) {
     |     Ok(e) => e
1046 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // (2) Imports: extend funcs/tables/mems/globals/tags index spaces
     |   env = match validate_importsec(importsec_opt, env) {
     |     Ok(e) => e
1052 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // (3) Function declarations (defined funcs): extend env.funcs
     |   env = match validate_funcsec(funcsec_opt, env) {
     |     Ok(e) => e
     |     Err(t) => return Err(t)
     |   }
     | 
     |   // (4) Tables / Memories / Tags / Globals: extend their index spaces
     |   env = match validate_tablesec(tablesec_opt, env) {
     |     Ok(e) => e
     |     Err(t) => return Err(t)
     |   }
     |   env = match validate_memsec(memsec_opt, env) {
     |     Ok(e) => e
1068 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   env = match validate_tagsec(tagsec_opt, env) {
     |     Ok(e) => e
1072 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   env = match validate_globalsec(globalsec_opt, env) {
     |     Ok(e) => e
     |     Err(t) => return Err(t)
     |   }
     | 
     |   // (5) Elements / Data: extend elems/datas (needed by instructions)
     |   env = match validate_elemsec(elemsec_opt, env) {
     |     Ok(e) => e
     |     Err(t) => return Err(t)
     |   }
     |   env = match validate_datasec(datasec_opt, env) {
     |     Ok(e) => e
     |     Err(t) => return Err(t)
     |   }
     | 
     |   // (6) DataCount section cross-check
     |   match validate_datacnt(datacntsec_opt, datasec_opt) {
     |     Ok(_) => ()
1092 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // (7) Start function validation
     |   match validate_startsec(startsec_opt, env) {
     |     Ok(_) => ()
     |     Err(t) => return Err(t)
     |   }
     | 
     |   // (8) Exports: validate indices and check name uniqueness
     |   match validate_exportsec_unique(exportsec_opt, env) {
     |     Ok(_) => ()
1104 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   // (9) Code: typecheck each function body against env.funcs
     |   match validate_codesec(codesec_opt, funcsec_opt, env) {
     |     Ok(_) => ()
     |     Err(t) => return Err(t)
     |   }
     |   Ok(())
     | }
     …

79 uncovered line(s) in src/wast/arbitrary.mbt:

    | fn rand_bounded(max_exclusive : UInt, st : RandomState) -> UInt {
    |   if max_exclusive == 0 {
  4 |     0
    |     ^ 	<-- UNCOVERED
    |   } else {
    |     st.next_uint() % max_exclusive
    |   }
    | }
    …

    | fn rand_ident(st : RandomState, prefix : String) -> String {
 28 |   "\{prefix}\{st.next_uint() % 64}"
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn rand_index(st : RandomState, bound : UInt) -> Index {
 33 |   Num(rand_bounded(bound, st))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn pick_value_type(st : RandomState) -> ValueType {
 38 |   match st.next_uint() % 6 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     0 => I32
    |     1 => I64
    |     2 => F32
    |     3 => F64
    |     4 => FuncRef
    |     _ => ExternRef
    |   }
    | }
    …

    | fn pick_binary_opcode(st : RandomState) -> Opcode {
    |   match st.next_uint() % 20 {
    |     0 => I32Add
    |     1 => I32Sub
    |     2 => I32Mul
    |     3 => I32And
    |     4 => I32Or
    |     5 => I32Xor
    |     6 => I64Add
    |     7 => I64Sub
    |     8 => I64Mul
    |     9 => I64And
    |     10 => I64Or
    |     11 => I64Xor
    |     12 => F32Add
    |     13 => F32Sub
    |     14 => F32Mul
    |     15 => F32Div
    |     16 => F64Add
116 |     17 => F64Sub
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     18 => F64Mul
    |     _ => F64Div
    |   }
    | }
    …

    | fn pick_const_text(op : Opcode, st : RandomState) -> String {
    |   match op {
    |     I32Const => "\{(st.next_uint() % 200).reinterpret_as_int() - 100}"
    |     I64Const =>
    |       "\{(st.next_uint() % 200).reinterpret_as_int().to_int64() - 100L}"
    |     F32Const | F64Const =>
    |       match st.next_uint() % 8 {
    |         0 => "0.0"
    |         1 => "1.0"
172 |         2 => "-1.0"
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |         3 => "3.5"
174 |         4 => "-2.25"
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         5 => "inf"
176 |         6 => "-inf"
    |         ^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ => "nan"
    |       }
    |     _ => "0"
    |   }
    | }
    …

    | fn gen_instruction(
    |   size : Int,
    |   st : RandomState,
    |   func_bound : UInt,
    | ) -> Instruction {
    |   if size <= 0 {
    |     match st.next_uint() % 12 {
206 |       0 => Nop
    |       ^^^^^^^^ 	<-- UNCOVERED
    |       1 => Drop
    |       2 => LocalGet(Num(0))
    |       3 => LocalSet(Num(0))
210 |       4 => GlobalGet(Num(0))
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       5 => MemorySize
    |       6 => TableSize(Num(0))
213 |       7 => Const(I32Const, pick_const_text(I32Const, st))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       8 => Const(I64Const, pick_const_text(I64Const, st))
215 |       9 => Const(F32Const, pick_const_text(F32Const, st))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       10 => Const(F64Const, pick_const_text(F64Const, st))
    |       _ => RefNull(FuncRef)
    |     }
    |   } else {
    |     let next = size / 2
    |     match st.next_uint() % 20 {
    |       0 => {
    |         let body : Array[Instruction] = []
    |         let n = rand_len(next, st, 3)
    |         for _ in 0..<n {
    |           body.push(gen_instruction(next, st, func_bound))
    |         }
    |         Block({ label: None, type_use: None }, body)
    |       }
    |       1 => {
    |         let body : Array[Instruction] = []
    |         let n = rand_len(next, st, 3)
    |         for _ in 0..<n {
    |           body.push(gen_instruction(next, st, func_bound))
    |         }
    |         Loop({ label: None, type_use: None }, body)
    |       }
    |       2 => {
    |         let then_body : Array[Instruction] = []
    |         let else_body : Array[Instruction] = []
    |         let nt = rand_len(next, st, 2)
    |         let ne = rand_len(next, st, 2)
    |         for _ in 0..<nt {
    |           then_body.push(gen_instruction(next, st, func_bound))
    |         }
    |         for _ in 0..<ne {
    |           else_body.push(gen_instruction(next, st, func_bound))
    |         }
    |         If({ label: None, type_use: None }, then_body, else_body)
    |       }
    |       3 => Br(Num(st.next_uint() % 2))
    |       4 => BrIf(Num(st.next_uint() % 2))
    |       5 => BrTable([Num(0), Num(1)], Num(0))
    |       6 => Return
    |       7 => Call(Num(rand_bounded(func_bound, st)))
    |       8 =>
    |         CallIndirect(Num(0), {
    |           type_index: Some(Num(0)),
    |           func_type: { params: [], results: [] },
    |         })
    |       9 => Load(I32Load, gen_memarg(st, 4))
    |       10 => Store(I32Store, gen_memarg(st, 4))
    |       11 => Unary(pick_unary_opcode(st))
    |       12 => Binary(pick_binary_opcode(st))
    |       13 => Test(I32Eqz)
    |       14 => Compare(pick_compare_opcode(st))
    |       15 => Convert(pick_convert_opcode(st))
    |       16 => RefFunc(Num(rand_bounded(func_bound, st)))
    |       17 => Select(Some([pick_numeric_value_type(st)]))
    |       18 => TableGet(Num(0))
    |       _ => {
    |         let op = pick_numeric_opcode(st)
    |         Const(op, pick_const_text(op, st))
    |       }
    |     }
    |   }
    | }
    …

    | pub impl Arbitrary for ValueType with arbitrary(_, st) {
419 |   pick_value_type(st)
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for Index with arbitrary(size, st) {
424 |   if (st.next_uint() & 1) == 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Num(rand_bounded((size + 1).reinterpret_as_uint(), st))
    |   } else {
427 |     let suffix = rand_ident(st, "id")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Id("$\{suffix}")
    |   }
    | }
    …

    | pub impl Arbitrary for Limits with arbitrary(_, st) {
434 |   let min = st.next_uint() % 5
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let max : UInt? = if (st.next_uint() & 1) == 1 {
436 |     Some(min + st.next_uint() % 3)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
438 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   }
    |   { min, max }
    | }
    …

    | pub impl Arbitrary for FuncType with arbitrary(_, st) {
445 |   gen_func_type(st)
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for TypeUse with arbitrary(size, st) {
450 |   gen_type_use(st, (size + 1).reinterpret_as_uint())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for InlineExport with arbitrary(_, st) {
455 |   Export("ex_\{st.next_uint() % 32}")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for TableType with arbitrary(_, st) {
460 |   {
    |   ^ 	<-- UNCOVERED
    |     limits: Arbitrary::arbitrary(2, st),
    |     elem_type: if (st.next_uint() & 1) == 1 {
463 |       FuncRef
    |       ^^^^^^^ 	<-- UNCOVERED
    |     } else {
465 |       ExternRef
    |       ^^^^^^^^^ 	<-- UNCOVERED
    |     },
    |   }
    | }
    …

    | pub impl Arbitrary for MemoryType with arbitrary(_, st) {
472 |   MemoryType(Arbitrary::arbitrary(2, st))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for GlobalType with arbitrary(_, st) {
477 |   { val_type: pick_numeric_value_type(st), mutable_: (st.next_uint() & 1) == 1 }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for Local with arbitrary(_, st) {
482 |   {
    |   ^ 	<-- UNCOVERED
    |     id: if (st.next_uint() & 1) == 1 {
484 |       Some("$l\{st.next_uint() % 32}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
486 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
488 |     val_type: pick_numeric_value_type(st),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Arbitrary for ImportDesc with arbitrary(size, st) {
494 |   match st.next_uint() % 4 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     0 => Func(Arbitrary::arbitrary(size, st))
    |     1 => Table(Arbitrary::arbitrary(size, st))
    |     2 => Memory(Arbitrary::arbitrary(size, st))
    |     _ => Global(Arbitrary::arbitrary(size, st))
    |   }
    | }
    …

    | pub impl Arbitrary for Import with arbitrary(size, st) {
504 |   {
    |   ^ 	<-- UNCOVERED
    |     module_name: "env",
    |     field_name: "f\{st.next_uint() % 64}",
507 |     desc: Arbitrary::arbitrary(size, st),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     id: if (st.next_uint() & 1) == 1 {
509 |       Some("$imp\{st.next_uint() % 64}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
511 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |   }
    | }
    …

    | pub impl Arbitrary for ExportDesc with arbitrary(size, st) {
518 |   match st.next_uint() % 4 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     0 => Func(rand_index(st, (size + 1).reinterpret_as_uint()))
    |     1 => Table(rand_index(st, 1))
    |     2 => Memory(rand_index(st, 1))
    |     _ => Global(rand_index(st, 1))
    |   }
    | }
    …

    | pub impl Arbitrary for Export with arbitrary(size, st) {
528 |   { name: "ex\{st.next_uint() % 64}", desc: Arbitrary::arbitrary(size, st) }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for Start with arbitrary(size, st) {
533 |   { func_index: rand_index(st, (size + 1).reinterpret_as_uint()) }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for MemArg with arbitrary(_, st) {
538 |   gen_memarg(st, 4)
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for BlockType with arbitrary(size, st) {
543 |   {
    |   ^ 	<-- UNCOVERED
    |     label: if (st.next_uint() & 1) == 1 {
545 |       Some("$b\{st.next_uint() % 32}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
547 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |     type_use: if (st.next_uint() & 1) == 1 {
550 |       Some(Arbitrary::arbitrary(size, st))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
552 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |   }
    | }
    …

    | pub impl Arbitrary for SimdShape with arbitrary(_, st) {
559 |   match st.next_uint() % 6 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     0 => I8x16
    |     1 => I16x8
    |     2 => I32x4
    |     3 => I64x2
    |     4 => F32x4
    |     _ => F64x2
    |   }
    | }
    …

    | pub impl Arbitrary for V128Const with arbitrary(_, st) {
571 |   let shape : SimdShape = Arbitrary::arbitrary(0, st)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let values : Array[String] = []
573 |   let count = match shape {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     I8x16 => 16
    |     I16x8 => 8
    |     I32x4 => 4
    |     I64x2 => 2
    |     F32x4 => 4
    |     F64x2 => 2
    |   }
    |   for _ in 0..<count {
582 |     values.push("\{(st.next_uint() % 32).reinterpret_as_int() - 16}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   { shape, values }
    | }
    …

    | pub impl Arbitrary for ShuffleLanes with arbitrary(_, st) {
589 |   let lanes : FixedArray[UInt] = FixedArray::make(16, 0)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for i = 0; i < 16; i = i + 1 {
    |     lanes[i] = st.next_uint() % 32
    |   }
    |   { lanes, }
    | }
    …

    | pub impl Arbitrary for Opcode with arbitrary(_, st) {
598 |   match st.next_uint() % 8 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     0 => pick_binary_opcode(st)
    |     1 => pick_unary_opcode(st)
    |     2 => pick_compare_opcode(st)
    |     3 => pick_convert_opcode(st)
    |     4 => I32Const
    |     5 => I64Const
    |     6 => F32Const
    |     _ => F64Const
    |   }
    | }
    …

    | pub impl Arbitrary for Instruction with arbitrary(size, st) {
612 |   gen_instruction(size, st, (size + 2).reinterpret_as_uint())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Arbitrary for Func with arbitrary(size, st) {
617 |   let locals : Array[Local] = []
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let local_n = rand_len(size, st, 3)
    |   for _ in 0..<local_n {
620 |     locals.push(Arbitrary::arbitrary(size, st))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let body : Array[Instruction] = []
623 |   let body_n = rand_len(size + 1, st, 8)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for _ in 0..<body_n {
625 |     body.push(gen_instruction(size, st, 4))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   {
    |     id: if (st.next_uint() & 1) == 1 {
629 |       Some("$f\{st.next_uint() % 64}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
631 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |     exports: [],
634 |     type_use: gen_type_use(st, (size + 1).reinterpret_as_uint()),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     locals,
    |     body,
    |   }
    | }
    …

    | pub impl Arbitrary for Global with arbitrary(size, st) {
642 |   {
    |   ^ 	<-- UNCOVERED
    |     id: if (st.next_uint() & 1) == 1 {
644 |       Some("$g\{st.next_uint() % 64}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
646 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |     exports: [],
649 |     global_type: Arbitrary::arbitrary(size, st),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     init: [Const(I32Const, "0")],
    |   }
    | }
    …

    | pub impl Arbitrary for Table with arbitrary(size, st) {
656 |   {
    |   ^ 	<-- UNCOVERED
    |     id: if (st.next_uint() & 1) == 1 {
658 |       Some("$t\{st.next_uint() % 64}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
660 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |     exports: [],
663 |     table_type: Arbitrary::arbitrary(size, st),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Arbitrary for Memory with arbitrary(size, st) {
669 |   {
    |   ^ 	<-- UNCOVERED
    |     id: if (st.next_uint() & 1) == 1 {
671 |       Some("$m\{st.next_uint() % 64}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
673 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
    |     exports: [],
676 |     memory_type: Arbitrary::arbitrary(size, st),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Arbitrary for TypeDef with arbitrary(size, st) {
682 |   {
    |   ^ 	<-- UNCOVERED
    |     id: if (st.next_uint() & 1) == 1 {
684 |       Some("$t\{st.next_uint() % 64}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
686 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     },
688 |     func_type: Arbitrary::arbitrary(size, st),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Arbitrary for DataSegment with arbitrary(size, _) {
694 |   {
    |   ^ 	<-- UNCOVERED
    |     id: None,
    |     memory_index: Num(0),
    |     offset: [Const(I32Const, "0")],
698 |     data: bytes_of("data\{size}"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Arbitrary for ElemSegment with arbitrary(size, st) {
704 |   let funcs : Array[Index] = []
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let n = rand_len(size, st, 3)
    |   for _ in 0..<n {
707 |     funcs.push(Num(st.next_uint() % 4))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   {
    |     id: None,
    |     table_index: Num(0),
    |     offset: [Const(I32Const, "0")],
    |     func_indices: funcs,
    |   }
    | }
    …

    | pub impl Arbitrary for ModuleField with arbitrary(size, st) {
719 |   match st.next_uint() % 10 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     0 => TypeField(Arbitrary::arbitrary(size, st))
    |     1 => FuncField(Arbitrary::arbitrary(size, st))
    |     2 => TableField(Arbitrary::arbitrary(size, st))
    |     3 => MemoryField(Arbitrary::arbitrary(size, st))
    |     4 => GlobalField(Arbitrary::arbitrary(size, st))
    |     5 => ImportField(Arbitrary::arbitrary(size, st))
    |     6 => ExportField(Arbitrary::arbitrary(size, st))
    |     7 => StartField(Arbitrary::arbitrary(size, st))
    |     8 => ElemField(Arbitrary::arbitrary(size, st))
    |     _ => DataField(Arbitrary::arbitrary(size, st))
    |   }
    | }
    …

40 uncovered line(s) in src/wast/lexer.mbt:

     | fn parse_hex_digit(c : Int) -> Int {
     |   if c >= 0x30 && c <= 0x39 {
     |     c - 0x30
  58 |   } else if c >= 0x41 && c <= 0x46 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     c - 0x41 + 10
     |   } else if c >= 0x61 && c <= 0x66 {
     |     c - 0x61 + 10
     |   } else {
  63 |     0
     |     ^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastLexer::get_location(self : WastLexer) -> Location {
     |   let first_col = if self.token_start >= self.line_start {
     |     self.token_start - self.line_start + 1
     |   } else {
 128 |     1
     |     ^ 	<-- UNCOVERED
     |   }
     |   let last_col = if self.cursor >= self.line_start {
     |     self.cursor - self.line_start + 1
     |   } else {
 133 |     1
     |     ^ 	<-- UNCOVERED
     |   }
     |   {
     |     filename: self.filename,
     |     line: self.line,
     |     first_column: first_col,
     |     last_column: last_col,
     |   }
     | }
     …

     | fn WastLexer::get_text(self : WastLexer, offset : Int) -> String {
     |   let start = self.token_start + offset
     |   if start >= self.buffer.length() || self.cursor <= start {
 147 |     return ""
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let len = self.cursor - start
     |   let chars : Array[Char] = Array::make(len, '\u{00}')
     |   for i = 0; i < len; i = i + 1 {
     |     chars[i] = self.buffer[start + i].to_int().unsafe_to_char()
     |   }
     |   String::from_array(chars)
     | }
     …

     | fn WastLexer::read_line_comment(self : WastLexer) -> Bool {
     |   while true {
     |     match self.read_char() {
     |       c if c == eof => return false
 233 |       0x0D => {
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |         // '\r'
     |         if self.peek_char() == 0x0A {
 236 |           let _ = self.read_char()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
 238 |         self.newline()
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         return true
     |       }
     |       0x0A => {
     |         // '\n'
     |         self.newline()
     |         return true
     |       }
     |       _ => ()
     |     }
     |   }
     |   false
     | }
     …

     | fn WastLexer::read_reserved_chars(self : WastLexer) -> ReservedChars {
     |   let mut ret = ReservedChars::None
     |   while true {
     |     let peek = self.peek_char()
     |     if is_id_char(peek) {
     |       let _ = self.read_char()
     |       if ret is ReservedChars::None {
     |         ret = Id
     |       }
     |     } else if peek == 0x22 {
     |       // '"'
 321 |       let _ = self.get_string_token()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ret = Some
     |     } else {
     |       break
     |     }
     |   }
     |   ret
     | }
     …

     | fn WastLexer::get_string_token(self : WastLexer) -> Token {
     |   let saved_token_start = self.token_start
     |   let mut has_error = false
     |   let mut in_string = true
     |   let _ = self.read_char() // consume opening '"'
     |   while in_string {
     |     match self.read_char() {
 347 |       c if c == eof => return self.bare_token(Eof)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       0x0A => {
     |         // '\n'
     |         self.token_start = self.cursor - 1
 351 |         self.error("newline in string")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         has_error = true
 353 |         self.newline()
     |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         continue
     |       }
     |       0x22 => {
     |         // '"'
     |         if self.peek_char() == 0x22 {
 359 |           self.error("invalid string token")
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           has_error = true
     |         }
     |         in_string = false
     |       }
     |       0x5C =>
     |         // '\\'
     |         match self.read_char() {
     |           0x74 | 0x6E | 0x72 | 0x22 | 0x27 | 0x5C =>
     |             // 't', 'n', 'r', '"', '\'', '\\'
     |             () // Valid escape
     |           c if is_hex_digit(c) =>
     |             if is_hex_digit(self.peek_char()) {
     |               let _ = self.read_char()
     |             } else {
 374 |               self.token_start = self.cursor - 2
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               self.error("bad escape")
     |               has_error = true
     |             }
     |           0x75 => {
     |             // 'u'
     |             self.token_start = self.cursor - 2
     |             if self.read_char() != 0x7B {
     |               // '{'
 383 |               self.error("bad escape")
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               has_error = true
     |               continue
     |             }
     |             let mut scalar_value : UInt = 0
     |             while is_hex_digit(self.peek_char()) {
     |               let digit = parse_hex_digit(self.read_char())
     |               scalar_value = (scalar_value << 4) | digit.reinterpret_as_uint()
     |               if scalar_value >= 0x110000 {
 392 |                 self.error("bad escape")
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 has_error = true
     |                 break
     |               }
     |             }
     |             if self.peek_char() != 0x7D {
     |               // '}'
 399 |               self.error("bad escape")
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               has_error = true
     |               continue
     |             }
     |             if scalar_value >= 0xD800 && scalar_value < 0xE000 {
 404 |               let _ = self.read_char()
     |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               self.error("bad escape")
     |               has_error = true
     |             }
     |           }
 409 |           _ => {
     |           ^^^^^^ 	<-- UNCOVERED
     |             self.token_start = self.cursor - 2
 411 |             self.error("bad escape")
     |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             has_error = true
     |           }
     |         }
     |       _ => ()
     |     }
     |   }
     |   self.token_start = saved_token_start
     |   if has_error {
 420 |     return { location: self.get_location(), token_type: Invalid, value: None }
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.text_token(Text, 0)
     | }
     …

     | fn WastLexer::get_number_token(
     |   self : WastLexer,
     |   token_type : TokenType,
     | ) -> Token {
     |   let mut tt = token_type
     |   if self.read_num() {
     |     if self.match_char(0x2E) {
     |       // '.'
     |       tt = Float
     |       if is_digit(self.peek_char()) && not(self.read_num()) {
 440 |         return self.get_reserved_token()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if self.match_char(0x65) || self.match_char(0x45) {
     |       // 'e' or 'E'
     |       tt = Float
     |       self.read_sign()
     |       if not(self.read_num()) {
 448 |         return self.get_reserved_token()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if self.no_trailing_reserved_chars() {
     |       if tt is Float {
     |         return self.literal_token(tt, LiteralType::Float)
     |       } else {
     |         return self.literal_token(tt, LiteralType::Int)
     |       }
     |     }
     |   }
 459 |   self.get_reserved_token()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn WastLexer::get_hex_number_token(
     |   self : WastLexer,
     |   token_type : TokenType,
     | ) -> Token {
     |   let mut tt = token_type
     |   if self.read_hex_num() {
     |     if self.match_char(0x2E) {
     |       // '.'
     |       tt = Float
     |       if is_hex_digit(self.peek_char()) && not(self.read_hex_num()) {
 473 |         return self.get_reserved_token()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if self.match_char(0x70) || self.match_char(0x50) {
     |       // 'p' or 'P'
     |       tt = Float
     |       self.read_sign()
     |       if not(self.read_num()) {
 481 |         return self.get_reserved_token()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     if self.no_trailing_reserved_chars() {
     |       if tt is Float {
     |         return self.literal_token(tt, Hexfloat)
     |       } else {
     |         return self.literal_token(tt, LiteralType::Int)
     |       }
     |     }
     |   }
 492 |   self.get_reserved_token()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn WastLexer::get_inf_token(self : WastLexer) -> Token {
     |   if self.match_string("inf") {
     |     if self.no_trailing_reserved_chars() {
     |       return self.literal_token(Float, Infinity)
     |     }
 501 |     return self.get_reserved_token()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.get_keyword_token()
     | }
     …

     | fn WastLexer::get_id_chars(self : WastLexer) -> Token {
     |   if self.read_reserved_chars() is Id {
     |     return self.text_token(Var, 0)
     |   }
 550 |   self.text_token(Reserved, 0)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn WastLexer::get_token(self : WastLexer) -> Token {
     |   while true {
     |     self.token_start = self.cursor
     |     match self.peek_char() {
     |       c if c == eof => return self.bare_token(Eof)
     |       0x28 =>
     |         // '('
     |         if self.match_string("(;") {
     |           if self.read_block_comment() {
     |             continue
     |           }
     |           return self.bare_token(Eof)
     |         } else if self.match_string("(@") {
     |           let _ = self.get_id_chars()
     |           return self.text_token(LparAnn, 2)
     |         } else {
     |           let _ = self.read_char()
     |           return self.bare_token(Lpar)
     |         }
     |       0x29 => {
     |         // ')'
     |         let _ = self.read_char()
     |         return self.bare_token(Rpar)
     |       }
     |       0x3B =>
     |         // ';'
     |         if self.match_string(";;") {
     |           if self.read_line_comment() {
     |             continue
     |           }
     |           return self.bare_token(Eof)
     |         } else {
 621 |           let _ = self.read_char()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           self.error("unexpected char")
     |           continue
     |         }
     |       0x20 | 0x09 | 0x0D | 0x0A => {
     |         // ' ', '\t', '\r', '\n'
     |         self.read_whitespace()
     |         continue
     |       }
     |       0x22 =>
     |         // '"'
     |         return self.get_string_token()
     |       0x2B | 0x2D => {
     |         // '+', '-'
     |         let _ = self.read_char()
     |         match self.peek_char() {
     |           0x69 =>
     |             // 'i'
     |             return self.get_inf_token()
     |           0x6E =>
     |             // 'n'
 642 |             return self.get_nan_token()
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           0x30 =>
     |             // '0'
 645 |             return if self.match_string("0x") {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               self.get_hex_number_token(Int)
     |             } else {
 648 |               self.get_number_token(Int)
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |           c if c >= 0x31 && c <= 0x39 =>
     |             // '1'-'9'
     |             return self.get_number_token(Int)
 653 |           _ => return self.get_reserved_token()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |       0x30 =>
     |         // '0'
     |         return if self.match_string("0x") {
     |           self.get_hex_number_token(Nat)
     |         } else {
     |           self.get_number_token(Nat)
     |         }
     |       c if c >= 0x31 && c <= 0x39 =>
     |         // '1'-'9'
     |         return self.get_number_token(Nat)
     |       0x24 =>
     |         // '$'
     |         return self.get_id_chars()
     |       0x61 =>
     |         // 'a'
     |         return self.get_name_eq_num_token("align=", AlignEqNat)
     |       0x69 =>
     |         // 'i'
     |         return self.get_inf_token()
     |       0x6E =>
     |         // 'n'
     |         return self.get_nan_token()
     |       0x6F =>
     |         // 'o'
     |         return self.get_name_eq_num_token("offset=", OffsetEqNat)
     |       c =>
     |         if is_keyword(c) {
     |           return self.get_keyword_token()
     |         } else if is_id_char(c) {
     |           return self.get_reserved_token()
     |         } else {
 687 |           let _ = self.read_char()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           self.error("unexpected char")
     |           continue
     |         }
     |     }
     |   }
 693 |   self.bare_token(Eof) // unreachable
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn WastLexer::get_errors(self : WastLexer) -> Array[LexerError] {
 702 |   self.errors
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn assert_token_type(token : Token, expected : TokenType) -> Unit raise Error {
     |   // Simple comparison - in real code you'd implement proper equality
     |   let matches = match (token.token_type, expected) {
     |     (Eof, Eof) => true
     |     (Lpar, Lpar) => true
     |     (Rpar, Rpar) => true
     |     (LparAnn, LparAnn) => true
     |     (Nat, Nat) => true
     |     (Int, Int) => true
     |     (Float, Float) => true
     |     (Text, Text) => true
     |     (Var, Var) => true
     |     (Reserved, Reserved) => true
     |     (AlignEqNat, AlignEqNat) => true
     |     (OffsetEqNat, OffsetEqNat) => true
 781 |     (Invalid, Invalid) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (Module, Module) => true
     |     (Func, Func) => true
     |     (Param, Param) => true
     |     (Result, Result) => true
     |     (Local, Local) => true
     |     (Global, Global) => true
     |     (Type, Type) => true
     |     (Table, Table) => true
     |     (Memory, Memory) => true
     |     (Import, Import) => true
     |     (Export, Export) => true
     |     (Block, Block) => true
     |     (Loop, Loop) => true
     |     (If, If) => true
     |     (Else, Else) => true
     |     (End, End) => true
     |     (ValueType(_), ValueType(_)) => true
     |     (Opcode(_), Opcode(_)) => true
 800 |     _ => false
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if not(matches) {
 803 |     raise TokenTypeMismatch
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

69 uncovered line(s) in src/wast/module_wast.mbt:

    | fn hex_digit(v : Int) -> Char {
    |   if v < 10 {
    |     (v + '0').unsafe_to_char()
    |   } else {
 11 |     (v - 10 + 'a').unsafe_to_char()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn quote_wast_string(s : String) -> String {
    |   let out = StringBuilder::new()
    |   out.write_char('"')
    |   for c in s {
    |     if c == '"' {
 21 |       out.write_string("\\\"")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else if c == '\\' {
 23 |       out.write_string("\\\\")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else if c == '\n' {
    |       out.write_string("\\n")
    |     } else if c == '\r' {
 27 |       out.write_string("\\r")
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else if c == '\t' {
 29 |       out.write_string("\\t")
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       out.write_char(c)
    |     }
    |   }
    |   out.write_char('"')
    |   out.to_string()
    | }
    …

    | fn quote_wast_bytes(bytes : Bytes) -> String {
    |   let out = StringBuilder::new()
    |   out.write_char('"')
    |   for b in bytes {
    |     if b >= 0x20 && b <= 0x7e && b != 0x22 && b != 0x5c {
    |       out.write_char(b.to_int().unsafe_to_char())
    |     } else if b == 0x22 {
 46 |       out.write_string("\\\"")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else if b == 0x5c {
 48 |       out.write_string("\\\\")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
    |       out.write_char('\\')
    |       out.write_char(hex_digit((b >> 4).to_int()))
    |       out.write_char(hex_digit((b & 0x0f).to_int()))
    |     }
    |   }
    |   out.write_char('"')
    |   out.to_string()
    | }
    …

    | fn lower_snake_from_pascal(name : String) -> String {
    |   if name.length() == 0 {
 71 |     return ""
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let out = StringBuilder::new()
    |   let mut i = 0
    |   while i < name.length() {
    |     let c = name[i]
    |     let is_upper = c >= 'A' && c <= 'Z'
    |     if i > 0 && is_upper {
    |       let prev = name[i - 1]
    |       let prev_is_lower_or_digit = (prev >= 'a' && prev <= 'z') ||
    |         (prev >= '0' && prev <= '9')
    |       let next_is_lower = if i + 1 < name.length() {
    |         let n = name[i + 1]
    |         n >= 'a' && n <= 'z'
    |       } else {
    |         false
    |       }
    |       if prev_is_lower_or_digit || next_is_lower {
    |         out.write_char('_')
    |       }
    |     }
    |     if is_upper {
    |       out.write_char((c.to_int() + 32).unsafe_to_char())
    |     } else {
    |       out.write_char(c.unsafe_to_char())
    |     }
    |     i += 1
    |   }
    |   out.to_string()
    | }
    …

    | fn keyword_from_opcode(op : Opcode) -> String {
    |   let raw = lower_snake_from_pascal("\{op}")
    |   let (head, tail) = split_first_underscore(raw)
    |   match tail {
    |     Some(t) => "\{head}.\{t}"
122 |     None => head
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn keyword_from_value_type(vt : ValueType) -> String {
    |   match vt {
    |     I32 => "i32"
    |     I64 => "i64"
    |     F32 => "f32"
    |     F64 => "f64"
133 |     V128 => "v128"
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     FuncRef => "funcref"
135 |     ExternRef => "externref"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn keyword_from_simd_shape(shape : SimdShape) -> String {
141 |   lower_snake_from_pascal("\{shape}").replace(old="_", new="")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn index_text(idx : Index) -> String {
    |   match idx {
    |     Num(n) => "\{n}"
148 |     Id(name) => name
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | fn render_block_type(bt : BlockType) -> String {
    |   let out = StringBuilder::new()
    |   match bt.label {
186 |     Some(label) => {
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.write_char(' ')
    |       out.write_string(label)
    |     }
    |     None => ()
    |   }
    |   match bt.type_use {
193 |     Some(type_use) => out.write_string(render_type_use(type_use))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   out.to_string()
    | }
    …

    | fn render_v128_const(v : V128Const) -> String {
213 |   let out = StringBuilder::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   out.write_string("v128.const ")
    |   out.write_string(keyword_from_simd_shape(v.shape))
    |   for value in v.values {
217 |     out.write_char(' ')
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     out.write_string(value)
    |   }
220 |   out.to_string()
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn render_shuffle_lanes(lanes : ShuffleLanes) -> String {
225 |   let out = StringBuilder::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for i = 0; i < 16; i = i + 1 {
    |     if i > 0 {
    |       out.write_char(' ')
    |     }
230 |     out.write_string("\{lanes.lanes[i]}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
232 |   out.to_string()
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn render_instruction_head(instr : Instruction) -> String raise WastTextError {
    |   match instr {
238 |     Unreachable => "unreachable"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Nop => "nop"
    |     Br(idx) => "br \{index_text(idx)}"
    |     BrIf(idx) => "br_if \{index_text(idx)}"
    |     BrTable(targets, fallback) => {
    |       let out = StringBuilder::new()
    |       out.write_string("br_table")
    |       for idx in targets {
    |         out.write_char(' ')
    |         out.write_string(index_text(idx))
    |       }
    |       out.write_char(' ')
    |       out.write_string(index_text(fallback))
    |       out.to_string()
    |     }
    |     Return => "return"
    |     Call(idx) => "call \{index_text(idx)}"
    |     CallIndirect(table_idx, type_use) =>
    |       "call_indirect \{index_text(table_idx)}\{render_type_use(type_use)}"
    |     Drop => "drop"
258 |     Select(None) => "select"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Select(Some(vts)) => {
    |       let out = StringBuilder::new()
    |       out.write_string("select (result")
    |       for vt in vts {
    |         out.write_char(' ')
    |         out.write_string(keyword_from_value_type(vt))
    |       }
    |       out.write_char(')')
    |       out.to_string()
    |     }
    |     LocalGet(idx) => "local.get \{index_text(idx)}"
    |     LocalSet(idx) => "local.set \{index_text(idx)}"
271 |     LocalTee(idx) => "local.tee \{index_text(idx)}"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     GlobalGet(idx) => "global.get \{index_text(idx)}"
    |     GlobalSet(idx) => "global.set \{index_text(idx)}"
    |     TableGet(idx) => "table.get \{index_text(idx)}"
275 |     TableSet(idx) => "table.set \{index_text(idx)}"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TableSize(idx) => "table.size \{index_text(idx)}"
277 |     TableGrow(idx) => "table.grow \{index_text(idx)}"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     TableFill(idx) => "table.fill \{index_text(idx)}"
    |     TableCopy(dst, src) => "table.copy \{index_text(dst)} \{index_text(src)}"
    |     TableInit(table_idx, elem_idx) =>
281 |       "table.init \{index_text(table_idx)} \{index_text(elem_idx)}"
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ElemDrop(idx) => "elem.drop \{index_text(idx)}"
    |     Load(op, ma) => "\{keyword_from_opcode(op)}\{render_memarg(ma)}"
    |     Store(op, ma) => "\{keyword_from_opcode(op)}\{render_memarg(ma)}"
285 |     MemorySize => "memory.size"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     MemoryGrow => "memory.grow"
    |     MemoryFill => "memory.fill"
    |     MemoryCopy => "memory.copy"
    |     MemoryInit(idx) => "memory.init \{index_text(idx)}"
    |     DataDrop(idx) => "data.drop \{index_text(idx)}"
    |     Const(op, text) => "\{keyword_from_opcode(op)} \{text}"
    |     Unary(op) => keyword_from_opcode(op)
    |     Binary(op) => keyword_from_opcode(op)
    |     Test(op) => keyword_from_opcode(op)
    |     Compare(op) => keyword_from_opcode(op)
    |     Convert(op) => keyword_from_opcode(op)
297 |     RefNull(vt) => "ref.null \{keyword_from_value_type(vt)}"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     RefIsNull => "ref.is_null"
    |     RefFunc(idx) => "ref.func \{index_text(idx)}"
    |     RefGetDesc => "ref.get_desc"
    |     RefTestDesc(false, idx) => "ref.test_desc \{index_text(idx)}"
    |     RefTestDesc(true, idx) => "ref.test_desc_null \{index_text(idx)}"
    |     RefCastDescEq(false, idx) => "ref.cast_desc_eq \{index_text(idx)}"
    |     RefCastDescEq(true, idx) => "ref.cast_desc_eq_null \{index_text(idx)}"
305 |     V128Const(v) => render_v128_const(v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     V128Load(ma) => "v128.load\{render_memarg(ma)}"
    |     V128Load8x8S(ma) => "v128.load8x8_s\{render_memarg(ma)}"
    |     V128Load8x8U(ma) => "v128.load8x8_u\{render_memarg(ma)}"
    |     V128Load16x4S(ma) => "v128.load16x4_s\{render_memarg(ma)}"
    |     V128Load16x4U(ma) => "v128.load16x4_u\{render_memarg(ma)}"
    |     V128Load32x2S(ma) => "v128.load32x2_s\{render_memarg(ma)}"
    |     V128Load32x2U(ma) => "v128.load32x2_u\{render_memarg(ma)}"
    |     V128Load8Splat(ma) => "v128.load8_splat\{render_memarg(ma)}"
    |     V128Load16Splat(ma) => "v128.load16_splat\{render_memarg(ma)}"
    |     V128Load32Splat(ma) => "v128.load32_splat\{render_memarg(ma)}"
    |     V128Load64Splat(ma) => "v128.load64_splat\{render_memarg(ma)}"
    |     V128Load32Zero(ma) => "v128.load32_zero\{render_memarg(ma)}"
    |     V128Load64Zero(ma) => "v128.load64_zero\{render_memarg(ma)}"
    |     V128Store(ma) => "v128.store\{render_memarg(ma)}"
    |     V128Load8Lane(ma, lane) => "v128.load8_lane\{render_memarg(ma)} \{lane}"
    |     V128Load16Lane(ma, lane) => "v128.load16_lane\{render_memarg(ma)} \{lane}"
    |     V128Load32Lane(ma, lane) => "v128.load32_lane\{render_memarg(ma)} \{lane}"
    |     V128Load64Lane(ma, lane) => "v128.load64_lane\{render_memarg(ma)} \{lane}"
    |     V128Store8Lane(ma, lane) => "v128.store8_lane\{render_memarg(ma)} \{lane}"
    |     V128Store16Lane(ma, lane) => "v128.store16_lane\{render_memarg(ma)} \{lane}"
    |     V128Store32Lane(ma, lane) => "v128.store32_lane\{render_memarg(ma)} \{lane}"
    |     V128Store64Lane(ma, lane) => "v128.store64_lane\{render_memarg(ma)} \{lane}"
    |     I8x16Shuffle(lanes) => "i8x16.shuffle \{render_shuffle_lanes(lanes)}"
    |     I8x16Swizzle => "i8x16.swizzle"
    |     I8x16Splat => "i8x16.splat"
    |     I16x8Splat => "i16x8.splat"
    |     I32x4Splat => "i32x4.splat"
    |     I64x2Splat => "i64x2.splat"
    |     F32x4Splat => "f32x4.splat"
    |     F64x2Splat => "f64x2.splat"
    |     I8x16ExtractLaneS(lane) => "i8x16.extract_lane_s \{lane}"
    |     I8x16ExtractLaneU(lane) => "i8x16.extract_lane_u \{lane}"
    |     I8x16ReplaceLane(lane) => "i8x16.replace_lane \{lane}"
    |     I16x8ExtractLaneS(lane) => "i16x8.extract_lane_s \{lane}"
    |     I16x8ExtractLaneU(lane) => "i16x8.extract_lane_u \{lane}"
    |     I16x8ReplaceLane(lane) => "i16x8.replace_lane \{lane}"
    |     I32x4ExtractLane(lane) => "i32x4.extract_lane \{lane}"
    |     I32x4ReplaceLane(lane) => "i32x4.replace_lane \{lane}"
    |     I64x2ExtractLane(lane) => "i64x2.extract_lane \{lane}"
    |     I64x2ReplaceLane(lane) => "i64x2.replace_lane \{lane}"
    |     F32x4ExtractLane(lane) => "f32x4.extract_lane \{lane}"
    |     F32x4ReplaceLane(lane) => "f32x4.replace_lane \{lane}"
    |     F64x2ExtractLane(lane) => "f64x2.extract_lane \{lane}"
    |     F64x2ReplaceLane(lane) => "f64x2.replace_lane \{lane}"
    |     SimdUnary(op) => keyword_from_opcode(op)
    |     SimdBinary(op) => keyword_from_opcode(op)
    |     SimdTernary(op) => keyword_from_opcode(op)
    |     SimdShift(op) => keyword_from_opcode(op)
    |     SimdTest(op) => keyword_from_opcode(op)
    |     SimdCompare(op) => keyword_from_opcode(op)
    |     SimdConvert(op) => keyword_from_opcode(op)
    |     SimdRelaxed(op) => keyword_from_opcode(op)
    |     Block(_, _) | Loop(_, _) | If(_, _, _) =>
359 |       raise Unsupported(
    |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         "structured instructions must be rendered with body context",
    |       )
    |   }
    | }
    …

    | fn write_inline_exports(
    |   out : StringBuilder,
    |   exports : Array[InlineExport],
    | ) -> Unit {
    |   for ex in exports {
417 |     match ex {
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |       Export(name) => out.write_string(" (export \{quote_wast_string(name)})")
    |     }
    |   }
    | }
    …

    | fn write_module_field(
    |   out : StringBuilder,
    |   field : ModuleField,
    |   indent : Int,
    | ) -> Unit raise WastTextError {
    |   let pad = " ".repeat(indent)
    |   match field {
    |     TypeField(td) => {
    |       out.write_string("\{pad}(type")
    |       if td.id is Some(id) {
    |         out.write_char(' ')
    |         out.write_string(id)
    |       }
    |       out.write_string(" (func")
    |       let tu = { type_index: None, func_type: td.func_type }
    |       out.write_string(render_type_use(tu))
    |       out.write_string("))\n")
    |     }
    |     FuncField(func) => {
    |       out.write_string("\{pad}(func")
    |       if func.id is Some(id) {
    |         out.write_char(' ')
    |         out.write_string(id)
    |       }
    |       write_inline_exports(out, func.exports)
    |       out.write_string(render_type_use(func.type_use))
    |       for loc in func.locals {
    |         out.write_string(" (local")
    |         if loc.id is Some(id) {
453 |           out.write_char(' ')
    |           ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           out.write_string(id)
    |         }
    |         out.write_char(' ')
    |         out.write_string(keyword_from_value_type(loc.val_type))
    |         out.write_char(')')
    |       }
    |       out.write_char('\n')
    |       write_instructions(out, func.body, indent + 2)
    |       out.write_string("\{pad})\n")
    |     }
    |     TableField(tbl) => {
    |       out.write_string("\{pad}(table")
    |       if tbl.id is Some(id) {
    |         out.write_char(' ')
    |         out.write_string(id)
    |       }
    |       write_inline_exports(out, tbl.exports)
    |       out.write_string(" \{tbl.table_type.limits.min}")
    |       if tbl.table_type.limits.max is Some(max) {
    |         out.write_string(" \{max}")
    |       }
    |       out.write_string(
    |         " \{keyword_from_value_type(tbl.table_type.elem_type)})\n",
    |       )
    |     }
    |     MemoryField(mem) => {
    |       out.write_string("\{pad}(memory")
    |       if mem.id is Some(id) {
    |         out.write_char(' ')
    |         out.write_string(id)
    |       }
    |       write_inline_exports(out, mem.exports)
    |       let lim = mem.memory_type.0
    |       out.write_string(" \{lim.min}")
    |       if lim.max is Some(max) {
    |         out.write_string(" \{max}")
    |       }
    |       out.write_string(")\n")
    |     }
    |     GlobalField(global) => {
    |       out.write_string("\{pad}(global")
    |       if global.id is Some(id) {
    |         out.write_char(' ')
    |         out.write_string(id)
    |       }
    |       write_inline_exports(out, global.exports)
    |       if global.global_type.mutable_ {
    |         out.write_string(
    |           " (mut \{keyword_from_value_type(global.global_type.val_type)})",
    |         )
    |       } else {
    |         out.write_string(
    |           " \{keyword_from_value_type(global.global_type.val_type)}",
    |         )
    |       }
    |       out.write_char('\n')
    |       write_instructions(out, global.init, indent + 2)
    |       out.write_string("\{pad})\n")
    |     }
    |     ImportField(im) => {
    |       out.write_string(
    |         "\{pad}(import \{quote_wast_string(im.module_name)} \{quote_wast_string(im.field_name)} (",
    |       )
    |       match im.desc {
    |         Func(type_use) => {
    |           out.write_string("func")
    |           if im.id is Some(id) {
    |             out.write_char(' ')
    |             out.write_string(id)
    |           }
    |           out.write_string(render_type_use(type_use))
    |         }
526 |         Table(tt) => {
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           out.write_string("table")
    |           if im.id is Some(id) {
529 |             out.write_char(' ')
    |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             out.write_string(id)
    |           }
532 |           out.write_string(" \{tt.limits.min}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           if tt.limits.max is Some(max) {
534 |             out.write_string(" \{max}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
536 |           out.write_string(" \{keyword_from_value_type(tt.elem_type)}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
538 |         Memory(mt) => {
    |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           out.write_string("memory")
    |           if im.id is Some(id) {
541 |             out.write_char(' ')
    |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             out.write_string(id)
    |           }
    |           let lim = mt.0
545 |           out.write_string(" \{lim.min}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           if lim.max is Some(max) {
547 |             out.write_string(" \{max}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
550 |         Global(gt) => {
    |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           out.write_string("global")
    |           if im.id is Some(id) {
553 |             out.write_char(' ')
    |             ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             out.write_string(id)
    |           }
    |           if gt.mutable_ {
557 |             out.write_string(" (mut \{keyword_from_value_type(gt.val_type)})")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           } else {
559 |             out.write_string(" \{keyword_from_value_type(gt.val_type)}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
    |       }
    |       out.write_string("))\n")
    |     }
    |     ExportField(ex) => {
    |       out.write_string("\{pad}(export \{quote_wast_string(ex.name)} (")
    |       match ex.desc {
    |         Func(idx) => out.write_string("func \{index_text(idx)}")
569 |         Table(idx) => out.write_string("table \{index_text(idx)}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Memory(idx) => out.write_string("memory \{index_text(idx)}")
    |         Global(idx) => out.write_string("global \{index_text(idx)}")
    |       }
    |       out.write_string("))\n")
    |     }
    |     StartField(start) =>
    |       out.write_string("\{pad}(start \{index_text(start.func_index)})\n")
    |     ElemField(elem) => {
    |       out.write_string("\{pad}(elem")
    |       if elem.id is Some(id) {
580 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(id)
    |       }
    |       out.write_char(' ')
    |       out.write_string(index_text(elem.table_index))
    |       if elem.offset.length() > 0 {
    |         out.write_string(" (offset\n")
    |         write_instructions(out, elem.offset, indent + 4)
    |         out.write_string("\{pad}  )")
    |       }
    |       for idx in elem.func_indices {
    |         out.write_char(' ')
    |         out.write_string(index_text(idx))
    |       }
    |       out.write_string(")\n")
    |     }
    |     DataField(data) => {
    |       out.write_string("\{pad}(data")
    |       if data.id is Some(id) {
599 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(id)
    |       }
    |       out.write_char(' ')
    |       out.write_string(index_text(data.memory_index))
    |       if data.offset.length() > 0 {
    |         out.write_string(" (offset\n")
    |         write_instructions(out, data.offset, indent + 4)
    |         out.write_string("\{pad}  )")
    |       }
    |       out.write_char(' ')
    |       out.write_string(quote_wast_bytes(data.data))
    |       out.write_string(")\n")
    |     }
    |   }
    | }
    …

    | fn render_wast_result(r : WastResult) -> String {
    |   match r {
    |     Value(v) => render_wast_value(v)
    |     F32NanCanonical => "(f32.const nan:canonical)"
    |     F32NanArithmetic => "(f32.const nan:arithmetic)"
    |     F64NanCanonical => "(f64.const nan:canonical)"
    |     F64NanArithmetic => "(f64.const nan:arithmetic)"
652 |     RefNull(None) => "(ref.null)"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     RefNull(Some(vt)) => "(ref.null \{keyword_from_value_type(vt)})"
    |     RefFunc => "(ref.func 0)"
    |   }
    | }
    …

    | fn render_action(a : WastActionType) -> String {
    |   match a {
    |     Invoke(act) => {
    |       let out = StringBuilder::new()
    |       out.write_string("(invoke")
    |       if act.module_name is Some(m) {
    |         out.write_char(' ')
    |         out.write_string(m)
    |       }
    |       out.write_char(' ')
    |       out.write_string(quote_wast_string(act.name))
    |       for arg in act.args {
    |         out.write_char(' ')
    |         out.write_string(render_wast_value(arg))
    |       }
    |       out.write_char(')')
    |       out.to_string()
    |     }
    |     Get(module_name, global_name) => {
    |       let out = StringBuilder::new()
    |       out.write_string("(get")
    |       if module_name is Some(m) {
681 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(m)
    |       }
    |       out.write_char(' ')
    |       out.write_string(quote_wast_string(global_name))
    |       out.write_char(')')
    |       out.to_string()
    |     }
    |   }
    | }
    …

    | fn render_command(cmd : WastCommand) -> String raise WastTextError {
    |   match cmd {
    |     Module(mod) => render_module(mod)
696 |     ModuleBinary(id, bytes) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = StringBuilder::new()
    |       out.write_string("(module")
    |       if id is Some(x) {
700 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(x)
    |       }
703 |       out.write_string(" binary ")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.write_string(quote_wast_bytes(bytes))
    |       out.write_string(")\n")
    |       out.to_string()
    |     }
708 |     ModuleQuote(id, strings) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let out = StringBuilder::new()
    |       out.write_string("(module")
    |       if id is Some(x) {
712 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(x)
    |       }
715 |       out.write_string(" quote")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       for s in strings {
717 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(quote_wast_string(s))
    |       }
720 |       out.write_string(")\n")
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out.to_string()
    |     }
    |     Register(name, module_id) => {
    |       let out = StringBuilder::new()
    |       out.write_string("(register ")
    |       out.write_string(quote_wast_string(name))
    |       if module_id is Some(id) {
728 |         out.write_char(' ')
    |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         out.write_string(id)
    |       }
    |       out.write_string(")\n")
    |       out.to_string()
    |     }
    |     Action(action) => "\{render_action(action)}\n"
    |     AssertReturn(action, results) => {
    |       let out = StringBuilder::new()
    |       out.write_string("(assert_return ")
    |       out.write_string(render_action(action))
    |       for r in results {
    |         out.write_char(' ')
    |         out.write_string(render_wast_result(r))
    |       }
    |       out.write_string(")\n")
    |       out.to_string()
    |     }
    |     AssertTrap(action, msg) =>
    |       "(assert_trap \{render_action(action)} \{quote_wast_string(msg)})\n"
    |     AssertExhaustion(action, msg) =>
    |       "(assert_exhaustion \{render_action(action)} \{quote_wast_string(msg)})\n"
    |     AssertMalformed(mod_def, msg) =>
    |       "(assert_malformed \{render_module_def(mod_def)} \{quote_wast_string(msg)})\n"
    |     AssertInvalid(mod_def, msg) =>
    |       "(assert_invalid \{render_module_def(mod_def)} \{quote_wast_string(msg)})\n"
    |     AssertUnlinkable(mod_def, msg) =>
755 |       "(assert_unlinkable \{render_module_def(mod_def)} \{quote_wast_string(msg)})\n"
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn module_to_wast(mod : Module) -> Result[String, String] {
    |   Result::Ok(render_module(mod)) catch {
789 |     WastTextError::Unsupported(msg) => Err(msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn module_to_wast_with_context(
    |   mod : Module,
    |   ctx : PrettyPrintContext,
    | ) -> Result[String, String] {
    |   match module_to_wast(mod) {
    |     Ok(text) => Ok(apply_pretty_context(text, ctx))
800 |     Err(msg) => Err(msg)
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn script_to_wast(script : WastScript) -> Result[String, String] {
    |   Result::Ok(render_script(script)) catch {
807 |     WastTextError::Unsupported(msg) => Err(msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn script_to_wast_with_context(
    |   script : WastScript,
    |   ctx : PrettyPrintContext,
    | ) -> Result[String, String] {
816 |   match script_to_wast(script) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Ok(text) => Ok(apply_pretty_context(text, ctx))
    |     Err(msg) => Err(msg)
    |   }
    | }
    …

    | pub impl Show for Module with output(self, logger) {
    |   match module_to_wast(self) {
    |     Ok(text) => logger.write_string(text)
826 |     Err(msg) => {
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       logger.write_string("(module ;; ")
    |       logger.write_string(msg)
    |       logger.write_string(")")
    |     }
    |   }
    | }
    …

    | pub impl Show for WastScript with output(self, logger) {
836 |   match script_to_wast(self) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Ok(text) => logger.write_string(text)
    |     Err(msg) => {
    |       logger.write_string(";; ")
    |       logger.write_string(msg)
    |     }
    |   }
    | }
    …

    | pub fn wast_to_module(
    |   source : String,
    |   filename? : String = "<memory>",
    | ) -> Result[Module, String] {
    |   let lexer = WastLexer::new(string_to_bytes_for_parser(source), filename)
    |   let parser = WastParser::new(lexer)
    |   Result::Ok(parser.parse_module()) catch {
    |     ParserError::UnexpectedToken(tok, msg) =>
    |       Err("\{msg} at \{tok.location.filename}:\{tok.location.line}")
855 |     ParserError::InvalidInstruction(msg) => Err(msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ParserError::Custom(msg) => Err(msg)
    |   }
    | }
    …

    | pub fn wast_to_script(
    |   source : String,
    |   filename? : String = "<memory>",
    | ) -> Result[WastScript, String] {
    |   let lexer = WastLexer::new(string_to_bytes_for_parser(source), filename)
    |   let parser = WastParser::new(lexer)
    |   Result::Ok(parser.parse_script()) catch {
    |     ParserError::UnexpectedToken(tok, msg) =>
    |       Err("\{msg} at \{tok.location.filename}:\{tok.location.line}")
870 |     ParserError::InvalidInstruction(msg) => Err(msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ParserError::Custom(msg) => Err(msg)
    |   }
    | }
    …

141 uncovered line(s) in src/wast/parser.mbt:

     | fn WastParser::check(self : WastParser, token_type : TokenType) -> Bool {
     |   match (self.current.token_type, token_type) {
     |     (Eof, Eof) => true
     |     (Lpar, Lpar) => true
     |     (Rpar, Rpar) => true
     |     (Nat, Nat) => true
 481 |     (Int, Int) => true
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (Float, Float) => true
     |     (Text, Text) => true
 484 |     (Var, Var) => true
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (Module, Module) => true
     |     (Func, Func) => true
     |     (Param, Param) => true
     |     (Result, Result) => true
     |     (Local, Local) => true
     |     (Global, Global) => true
     |     (Type, Type) => true
     |     (Table, Table) => true
     |     (Memory, Memory) => true
     |     (Import, Import) => true
     |     (Export, Export) => true
 496 |     (Block, Block) => true
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (Loop, Loop) => true
     |     (If, If) => true
     |     (Else, Else) => true
     |     (End, End) => true
     |     (Then, Then) => true
     |     (Start, Start) => true
     |     (Data, Data) => true
     |     (Elem, Elem) => true
     |     (Mut, Mut) => true
     |     (Offset, Offset) => true
 507 |     (Item, Item) => true
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     (ValueType(_), ValueType(_)) => true
     |     (Opcode(_), Opcode(_)) => true
     |     _ => false
     |   }
     | }
     …

     | fn WastParser::get_text(_ : WastParser, token : Token) -> String {
     |   match token.value {
     |     Text(s) => s
 551 |     _ => ""
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::get_literal_text(_ : WastParser, token : Token) -> String {
     |   match token.value {
     |     Literal(lit) => lit.text
 559 |     _ => ""
     |     ^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::parse_index(self : WastParser) -> Index raise ParserError {
     |   match self.current.token_type {
     |     Nat => {
     |       let token = self.advance()
     |       let text = self.get_literal_text(token)
     |       Index::Num(parse_uint(text))
     |     }
     |     Var => {
     |       let token = self.advance()
     |       let text = self.get_text(token)
     |       Index::Id(text)
     |     }
 603 |     _ => raise UnexpectedToken(self.current, "expected index")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn parse_uint(s : String) -> UInt {
     |   let mut result : UInt = 0
     |   let mut i = 0
     |   // Handle hex prefix
     |   if s.length() > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X') {
 621 |     i = 2
     |     ^^^^^ 	<-- UNCOVERED
     |     while i < s.length() {
 623 |       let c = s[i]
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       if c == '_' {
 625 |         i += 1
     |         ^^^^^^ 	<-- UNCOVERED
     |         continue
     |       }
     |       let digit = if c >= '0' && c <= '9' {
 629 |         c.to_int() - 0x30
     |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else if c >= 'a' && c <= 'f' {
     |         c.to_int() - 0x61 + 10
     |       } else if c >= 'A' && c <= 'F' {
     |         c.to_int() - 0x41 + 10
     |       } else {
 635 |         0
     |         ^ 	<-- UNCOVERED
     |       }
 637 |       result = (result << 4) | digit.reinterpret_as_uint()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       i += 1
     |     }
     |   } else {
     |     while i < s.length() {
     |       let c = s[i]
     |       if c == '_' {
 644 |         i += 1
     |         ^^^^^^ 	<-- UNCOVERED
     |         continue
     |       }
     |       if c >= '0' && c <= '9' {
     |         result = result * 10 + (c.to_int() - 0x30).reinterpret_as_uint()
     |       }
     |       i += 1
     |     }
     |   }
     |   result
     | }
     …

     | fn WastParser::parse_block_type(
     |   self : WastParser,
     | ) -> BlockType raise ParserError {
     |   let label : String? = if self.current.token_type is Var {
     |     let token = self.advance()
     |     Some(self.get_text(token))
     |   } else {
     |     None
     |   }
     | 
     |   // Try to parse type use for block
     |   let type_use : TypeUse? = if self.check(Lpar) {
     |     let saved_state = self.save_lexer_state()
     |     let saved_token = self.current
     |     self.expect_lpar()
     |     if self.check(Type) || self.check(Param) || self.check(Result) {
     |       // It's a type use, parse it
     |       self.restore_lexer_state(saved_state)
     |       self.current = saved_token
     |       Some(self.parse_type_use())
     |     } else {
     |       // Not a type use, restore
     |       self.restore_lexer_state(saved_state)
     |       self.current = saved_token
     |       None
     |     }
     |   } else if self.current.token_type is ValueType(_) {
     |     // Shorthand: just a result type (no parens)
 825 |     let vt = self.parse_value_type()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some({ type_index: None, func_type: { params: [], results: [vt] } })
     |   } else {
     |     None
     |   }
     |   { label, type_use }
     | }
     …

     | fn WastParser::parse_folded_instruction(
     |   self : WastParser,
     | ) -> Array[Instruction] raise ParserError {
     |   match self.current.token_type {
     |     Block => {
     |       let _ = self.advance()
     |       let block_type = self.parse_block_type()
     |       let body = self.parse_instructions()
     |       [Block(block_type, body)]
     |     }
     |     Loop => {
     |       let _ = self.advance()
     |       let block_type = self.parse_block_type()
     |       let body = self.parse_instructions()
     |       [Loop(block_type, body)]
     |     }
     |     If => {
     |       let _ = self.advance()
     |       let block_type = self.parse_block_type()
     | 
     |       // Collect condition operands first
     |       let result : Array[Instruction] = []
     | 
     |       // Parse condition operands (folded instructions before then/else)
     |       while self.check(Lpar) {
     |         let saved = self.save_lexer_state()
     |         let saved_token = self.current
     |         self.expect_lpar()
     |         if self.check(Then) || self.check(Else) {
     |           self.restore_lexer_state(saved)
     |           self.current = saved_token
     |           break
     |         }
     |         self.restore_lexer_state(saved)
     |         self.current = saved_token
     | 
     |         // Parse the operand
     |         self.expect_lpar()
     |         let nested = self.parse_folded_instruction()
     |         for i in nested {
     |           result.push(i)
     |         }
     |         self.expect_rpar()
     |       }
     |       let has_folded_then = self.check(Lpar) &&
     |         ({
     |           let saved = self.save_lexer_state()
     |           let saved_token = self.current
     |           self.expect_lpar()
     |           let is_then = self.check(Then)
     |           self.restore_lexer_state(saved)
     |           self.current = saved_token
     |           is_then
     |         })
     |       let mut then_body : Array[Instruction] = []
     |       let mut else_body : Array[Instruction] = []
     |       if has_folded_then {
     |         // Hybrid syntax
     |         self.expect_lpar()
     |         let _ = self.expect(Then, "expected 'then'")
     |         then_body = self.parse_instructions()
     |         self.expect_rpar()
     |         if self.check(Lpar) {
     |           let saved = self.save_lexer_state()
     |           let saved_token = self.current
     |           self.expect_lpar()
     |           if self.check(Else) {
     |             let _ = self.advance()
     |             else_body = self.parse_instructions()
     |             self.expect_rpar()
     |           } else {
 931 |             self.restore_lexer_state(saved)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             self.current = saved_token
     |           }
     |         }
     |       } else {
     |         // Flat syntax
 937 |         then_body = self.parse_block_body()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         else_body = if self.match_token(Else) {
 939 |           self.parse_block_body()
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         } else {
 941 |           []
     |           ^^ 	<-- UNCOVERED
     |         }
 943 |         let _ = self.expect(End, "expected 'end'")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       result.push(If(block_type, then_body, else_body))
     |       result
     |     }
     |     Opcode(op) => {
     |       let _ = self.advance()
     |       let instr = self.parse_opcode_instruction(op)
     |       // Parse nested operand instructions
     |       let result : Array[Instruction] = []
     |       while self.check(Lpar) {
     |         self.expect_lpar()
     |         let nested = self.parse_folded_instruction()
     |         for i in nested {
     |           result.push(i)
     |         }
     |         self.expect_rpar()
     |       }
     |       result.push(instr)
     |       result
     |     }
 964 |     _ => raise UnexpectedToken(self.current, "expected instruction")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::try_parse_plain_instruction(
     |   self : WastParser,
     | ) -> Instruction? raise ParserError {
     |   match self.current.token_type {
     |     Block => {
     |       let _ = self.advance()
     |       let block_type = self.parse_block_type()
     |       let body = self.parse_block_body()
     |       let _ = self.expect(End, "expected 'end'")
     |       Some(Block(block_type, body))
     |     }
     |     Loop => {
     |       let _ = self.advance()
     |       let block_type = self.parse_block_type()
     |       let body = self.parse_block_body()
     |       let _ = self.expect(End, "expected 'end'")
     |       Some(Loop(block_type, body))
     |     }
     |     If => {
     |       let _ = self.advance()
     |       let block_type = self.parse_block_type()
     |       let mut used_explicit_syntax = false
     | 
     |       // Check if we're using explicit (then ...) syntax
     |       let then_body : Array[Instruction] = if self.check(Lpar) {
     |         let saved_state = self.save_lexer_state()
     |         let saved_token = self.current
     |         self.expect_lpar()
     |         if self.check(Then) {
     |           // Explicit (then ...) form
     |           used_explicit_syntax = true
     |           let _ = self.advance()
     |           let instrs = self.parse_instructions()
     |           self.expect_rpar()
     |           instrs
     |         } else {
     |           // Not a then block, rollback and parse as regular instructions
1006 |           self.restore_lexer_state(saved_state)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           self.current = saved_token
1008 |           self.parse_block_body()
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
     |         // Flat form without explicit then
     |         self.parse_block_body()
     |       }
     | 
     |       // Parse else block
     |       let else_body : Array[Instruction] = if self.check(Lpar) {
     |         let saved_state = self.save_lexer_state()
     |         let saved_token = self.current
     |         self.expect_lpar()
     |         if self.check(Else) {
     |           // Explicit (else ...) form
     |           used_explicit_syntax = true
     |           let _ = self.advance()
     |           let instrs = self.parse_instructions()
     |           self.expect_rpar()
     |           instrs
     |         } else {
     |           // Not an else block, rollback
1029 |           self.restore_lexer_state(saved_state)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           self.current = saved_token
     |           if self.match_token(Else) {
1032 |             self.parse_block_body()
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           } else {
1034 |             []
     |             ^^ 	<-- UNCOVERED
     |           }
     |         }
     |       } else if self.match_token(Else) {
     |         // Bare else keyword in flat form
     |         self.parse_block_body()
     |       } else {
     |         []
     |       }
     | 
     |       // Only expect 'end' for flat form (no explicit then/else blocks)
     |       if not(used_explicit_syntax) {
     |         let _ = self.expect(End, "expected 'end'")
     |       }
     |       Some(If(block_type, then_body, else_body))
     |     }
     |     Opcode(op) => {
     |       let _ = self.advance()
     |       Some(self.parse_opcode_instruction(op))
     |     }
     |     _ => None
     |   }
     | }
     …

     | fn WastParser::parse_block_body(
     |   self : WastParser,
     | ) -> Array[Instruction] raise ParserError {
     |   let instrs : Array[Instruction] = []
     |   while true {
     |     match self.current.token_type {
     |       End | Else | Then | Eof => break
1066 |       Lpar => {
     |       ^^^^^^^^^ 	<-- UNCOVERED
     |         let saved_state = self.save_lexer_state()
     |         let saved_token = self.current
1069 |         self.expect_lpar()
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |         // Check for (then or (else which shouldn't be parsed as instructions
     |         if self.check(Then) || self.check(Else) {
1073 |           self.restore_lexer_state(saved_state)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           self.current = saved_token
     |           break
     |         }
1077 |         let folded = self.parse_folded_instruction()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         for instr in folded {
1079 |           instrs.push(instr)
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
1081 |         self.expect_rpar()
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       _ =>
     |         match self.try_parse_plain_instruction() {
     |           Some(instr) => instrs.push(instr)
     |           None => break
     |         }
     |     }
     |   }
     |   instrs
     | }
     …

     | fn WastParser::parse_opcode_instruction(
     |   self : WastParser,
     |   op : Opcode,
     | ) -> Instruction raise ParserError {
     |   match op {
     |     // Control
     |     Unreachable => Unreachable
     |     Nop => Nop
     |     Br => Br(self.parse_index())
     |     BrIf => BrIf(self.parse_index())
     |     BrTable => {
     |       let indices : Array[Index] = []
     |       while self.current.token_type is (Nat | Var) {
     |         indices.push(self.parse_index())
     |       }
     |       if indices.length() == 0 {
1110 |         raise Custom("br_table requires at least one index")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let default = indices.pop().unwrap()
     |       BrTable(indices, default)
     |     }
     |     Return => Return
     |     Call => Call(self.parse_index())
     |     CallIndirect => {
     |       let table_index = self.try_parse_index().unwrap_or(Index::Num(0))
     |       let type_use = self.parse_type_use()
     |       CallIndirect(table_index, type_use)
     |     }
     |     RefGetDesc => RefGetDesc
     |     RefTestDesc => RefTestDesc(false, self.parse_index())
     |     RefTestDescNull => RefTestDesc(true, self.parse_index())
     |     RefCastDescEq => RefCastDescEq(false, self.parse_index())
     |     RefCastDescEqNull => RefCastDescEq(true, self.parse_index())
     | 
     |     // Parametric
     |     Drop => Drop
     |     Select => {
     |       // Check for typed select
     |       let types : Array[ValueType]? = if self.check(Lpar) {
     |         let saved_state = self.save_lexer_state()
     |         let saved_token = self.current
     |         self.expect_lpar()
     |         if self.check(Result) {
     |           let _ = self.advance()
     |           let ts : Array[ValueType] = []
     |           while self.current.token_type is ValueType(_) {
     |             ts.push(self.parse_value_type())
     |           }
     |           self.expect_rpar()
     |           Some(ts)
     |         } else {
     |           self.restore_lexer_state(saved_state)
     |           self.current = saved_token
     |           None
     |         }
     |       } else {
1150 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |       Select(types)
     |     }
     | 
     |     // Variable
     |     LocalGet => LocalGet(self.parse_index())
     |     LocalSet => LocalSet(self.parse_index())
     |     LocalTee => LocalTee(self.parse_index())
     |     GlobalGet => GlobalGet(self.parse_index())
     |     GlobalSet => GlobalSet(self.parse_index())
     | 
     |     // Table
     |     TableGet => TableGet(self.try_parse_index().unwrap_or(Index::Num(0)))
     |     TableSet => TableSet(self.try_parse_index().unwrap_or(Index::Num(0)))
     |     TableSize => TableSize(self.try_parse_index().unwrap_or(Index::Num(0)))
     |     TableGrow => TableGrow(self.try_parse_index().unwrap_or(Index::Num(0)))
1167 |     TableFill => TableFill(self.try_parse_index().unwrap_or(Index::Num(0)))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     TableCopy => {
     |       let dst = self.try_parse_index().unwrap_or(Index::Num(0))
     |       let src = self.try_parse_index().unwrap_or(Index::Num(0))
     |       TableCopy(dst, src)
     |     }
     |     TableInit => {
     |       // table.init can have either:
     |       //   table.init elemidx           -> table defaults to 0
     |       //   table.init tableidx elemidx  -> explicit table index
     |       let first = self.try_parse_index()
     |       match first {
     |         Some(idx1) => {
     |           let second = self.try_parse_index()
     |           match second {
1182 |             Some(idx2) => TableInit(idx1, idx2) // tableidx, elemidx
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             None => TableInit(Index::Num(0), idx1) // default table 0, elemidx
     |           }
     |         }
1186 |         None => raise Custom("table.init requires at least one index")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     ElemDrop => ElemDrop(self.parse_index())
     | 
     |     // Memory
     |     I32Load => Load(op, self.parse_mem_arg(4))
     |     I64Load => Load(op, self.parse_mem_arg(8))
1194 |     F32Load => Load(op, self.parse_mem_arg(4))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64Load => Load(op, self.parse_mem_arg(8))
     |     I32Load8S | I32Load8U => Load(op, self.parse_mem_arg(1))
     |     I32Load16S | I32Load16U => Load(op, self.parse_mem_arg(2))
     |     I64Load8S | I64Load8U => Load(op, self.parse_mem_arg(1))
     |     I64Load16S | I64Load16U => Load(op, self.parse_mem_arg(2))
     |     I64Load32S | I64Load32U => Load(op, self.parse_mem_arg(4))
     |     I32Store => Store(op, self.parse_mem_arg(4))
     |     I64Store => Store(op, self.parse_mem_arg(8))
1203 |     F32Store => Store(op, self.parse_mem_arg(4))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     F64Store => Store(op, self.parse_mem_arg(8))
     |     I32Store8 | I64Store8 => Store(op, self.parse_mem_arg(1))
     |     I32Store16 | I64Store16 => Store(op, self.parse_mem_arg(2))
     |     I64Store32 => Store(op, self.parse_mem_arg(4))
     |     MemorySize => MemorySize
     |     MemoryGrow => MemoryGrow
     |     MemoryFill => MemoryFill
     |     MemoryCopy => MemoryCopy
     |     MemoryInit => MemoryInit(self.parse_index())
     |     DataDrop => DataDrop(self.parse_index())
     | 
     |     // Const
     |     I32Const | I64Const => {
     |       let token = self.advance()
     |       let text = match token.token_type {
     |         Nat | Int => self.get_literal_text(token)
1220 |         _ => "0"
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Const(op, text)
     |     }
     |     F32Const | F64Const => {
     |       let token = self.advance()
     |       let text = match token.token_type {
     |         Nat | Int | Float => self.get_literal_text(token)
1228 |         _ => "0"
     |         ^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       Const(op, text)
     |     }
     | 
     |     // Unary
     |     I32Clz
     |     | I32Ctz
     |     | I32Popcnt
     |     | I64Clz
     |     | I64Ctz
     |     | I64Popcnt
     |     | F32Abs
     |     | F32Neg
     |     | F32Ceil
     |     | F32Floor
     |     | F32Trunc
     |     | F32Nearest
     |     | F32Sqrt
     |     | F64Abs
     |     | F64Neg
     |     | F64Ceil
     |     | F64Floor
     |     | F64Trunc
     |     | F64Nearest
     |     | F64Sqrt
     |     | I32Extend8S
     |     | I32Extend16S
     |     | I64Extend8S
     |     | I64Extend16S
     |     | I64Extend32S => Unary(op)
     | 
     |     // Binary
     |     I32Add
     |     | I32Sub
     |     | I32Mul
     |     | I32DivS
     |     | I32DivU
     |     | I32RemS
     |     | I32RemU
     |     | I32And
     |     | I32Or
     |     | I32Xor
     |     | I32Shl
     |     | I32ShrS
     |     | I32ShrU
     |     | I32Rotl
     |     | I32Rotr
     |     | I64Add
     |     | I64Sub
     |     | I64Mul
     |     | I64DivS
     |     | I64DivU
     |     | I64RemS
     |     | I64RemU
     |     | I64And
     |     | I64Or
     |     | I64Xor
     |     | I64Shl
     |     | I64ShrS
     |     | I64ShrU
     |     | I64Rotl
     |     | I64Rotr
     |     | F32Add
     |     | F32Sub
     |     | F32Mul
     |     | F32Div
     |     | F32Min
     |     | F32Max
     |     | F32Copysign
     |     | F64Add
     |     | F64Sub
     |     | F64Mul
     |     | F64Div
     |     | F64Min
     |     | F64Max
     |     | F64Copysign => Binary(op)
     | 
     |     // Test
     |     I32Eqz | I64Eqz => Test(op)
     | 
     |     // Compare
     |     I32Eq
     |     | I32Ne
     |     | I32LtS
     |     | I32LtU
     |     | I32GtS
     |     | I32GtU
     |     | I32LeS
     |     | I32LeU
     |     | I32GeS
     |     | I32GeU
     |     | I64Eq
     |     | I64Ne
     |     | I64LtS
     |     | I64LtU
     |     | I64GtS
     |     | I64GtU
     |     | I64LeS
     |     | I64LeU
     |     | I64GeS
     |     | I64GeU
     |     | F32Eq
     |     | F32Ne
     |     | F32Lt
     |     | F32Gt
     |     | F32Le
     |     | F32Ge
     |     | F64Eq
     |     | F64Ne
     |     | F64Lt
     |     | F64Gt
     |     | F64Le
     |     | F64Ge => Compare(op)
     | 
     |     // Conversion
     |     I32WrapI64
     |     | I32TruncF32S
     |     | I32TruncF32U
     |     | I32TruncF64S
     |     | I32TruncF64U
     |     | I64ExtendI32S
     |     | I64ExtendI32U
     |     | I64TruncF32S
     |     | I64TruncF32U
     |     | I64TruncF64S
     |     | I64TruncF64U
     |     | F32ConvertI32S
     |     | F32ConvertI32U
     |     | F32ConvertI64S
     |     | F32ConvertI64U
     |     | F32DemoteF64
     |     | F64ConvertI32S
     |     | F64ConvertI32U
     |     | F64ConvertI64S
     |     | F64ConvertI64U
     |     | F64PromoteF32
     |     | I32ReinterpretF32
     |     | I64ReinterpretF64
     |     | F32ReinterpretI32
     |     | F64ReinterpretI64
     |     | I32TruncSatF32S
     |     | I32TruncSatF32U
     |     | I32TruncSatF64S
     |     | I32TruncSatF64U
     |     | I64TruncSatF32S
     |     | I64TruncSatF32U
     |     | I64TruncSatF64S
     |     | I64TruncSatF64U => Convert(op)
     | 
     |     // Reference
     |     RefNull => {
     |       let vt = self.parse_value_type()
     |       RefNull(vt)
     |     }
     |     RefIsNull => RefIsNull
     |     RefFunc => RefFunc(self.parse_index())
     | 
     |     // SIMD - delegate to SIMD parser
1387 |     _ => self.parse_simd_instruction(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::parse_type_def(self : WastParser) -> TypeDef raise ParserError {
     |   let _ = self.expect(Type, "expected 'type'")
     |   let id : String? = if self.current.token_type is Var {
     |     let token = self.advance()
     |     Some(self.get_text(token))
     |   } else {
     |     None
     |   }
     | 
     |   // (func ...)
     |   self.expect_lpar()
     |   let _ = self.expect(Func, "expected 'func'")
     |   let params : Array[ValueType] = []
     |   let results : Array[ValueType] = []
     | 
     |   // Parse params
     |   while self.check(Lpar) {
     |     let saved_state = self.save_lexer_state()
     |     let saved_token = self.current
     |     self.expect_lpar()
     |     if self.check(Param) {
     |       let _ = self.advance()
     |       if self.current.token_type is Var {
     |         let _ = self.advance()
     |         params.push(self.parse_value_type())
     |       } else {
     |         while self.current.token_type is ValueType(_) {
     |           params.push(self.parse_value_type())
     |         }
     |       }
     |       self.expect_rpar()
     |     } else {
     |       self.restore_lexer_state(saved_state)
     |       self.current = saved_token
     |       break
     |     }
     |   }
     | 
     |   // Parse results
     |   while self.check(Lpar) {
     |     let saved_state = self.save_lexer_state()
     |     let saved_token = self.current
     |     self.expect_lpar()
     |     if self.check(Result) {
     |       let _ = self.advance()
     |       while self.current.token_type is ValueType(_) {
     |         results.push(self.parse_value_type())
     |       }
     |       self.expect_rpar()
     |     } else {
1446 |       self.restore_lexer_state(saved_state)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.current = saved_token
     |       break
     |     }
     |   }
     |   self.expect_rpar() // close func
     |   { id, func_type: { params, results } }
     | }
     …

     | fn WastParser::parse_inline_exports(
     |   self : WastParser,
     | ) -> Array[InlineExport] raise ParserError {
     |   let exports : Array[InlineExport] = []
     |   while self.check(Lpar) {
     |     let saved_state = self.save_lexer_state()
     |     let saved_token = self.current
     |     self.expect_lpar()
     |     if self.check(Export) {
     |       let _ = self.advance()
     |       let name_token = self.expect(Text, "expected export name")
     |       let name = self.get_text(name_token)
     |       // Remove quotes from string
     |       let cleaned = if name.length() >= 2 {
     |         name.sub(start=1, end=name.length() - 1).to_string() catch {
1471 |           _ => name
     |           ^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       } else {
1474 |         name
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |       exports.push(InlineExport::Export(cleaned))
     |       self.expect_rpar()
     |     } else {
     |       self.restore_lexer_state(saved_state)
     |       self.current = saved_token
     |       break
     |     }
     |   }
     |   exports
     | }
     …

     | fn WastParser::parse_global(self : WastParser) -> Global raise ParserError {
     |   let _ = self.expect(Global, "expected 'global'")
     |   let id : String? = if self.current.token_type is Var {
     |     let token = self.advance()
     |     Some(self.get_text(token))
     |   } else {
     |     None
     |   }
     |   let exports = self.parse_inline_exports()
     | 
     |   // Parse global type
     |   let (val_type, mutable_) = if self.check(Lpar) {
     |     let saved_state = self.save_lexer_state()
     |     let saved_token = self.current
     |     self.expect_lpar()
     |     if self.check(Mut) {
     |       let _ = self.advance()
     |       let vt = self.parse_value_type()
     |       self.expect_rpar()
     |       (vt, true)
     |     } else {
1580 |       self.restore_lexer_state(saved_state)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       self.current = saved_token
1582 |       (self.parse_value_type(), false)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   } else {
     |     (self.parse_value_type(), false)
     |   }
     |   let init = self.parse_instructions()
     |   { id, exports, global_type: { val_type, mutable_ }, init }
     | }
     …

     | fn WastParser::parse_import(self : WastParser) -> Import raise ParserError {
     |   let _ = self.expect(Import, "expected 'import'")
     |   let module_token = self.expect(Text, "expected module name")
     |   let module_name = self.strip_quotes(self.get_text(module_token))
     |   let field_token = self.expect(Text, "expected field name")
     |   let field_name = self.strip_quotes(self.get_text(field_token))
     |   self.expect_lpar()
     |   let (desc, id) = match self.current.token_type {
     |     Func => {
     |       let _ = self.advance()
     |       let func_id : String? = if self.current.token_type is Var {
     |         let token = self.advance()
     |         Some(self.get_text(token))
     |       } else {
1606 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |       let type_use = self.parse_type_use()
     |       (ImportDesc::Func(type_use), func_id)
     |     }
     |     Table => {
     |       let _ = self.advance()
     |       let table_id : String? = if self.current.token_type is Var {
1614 |         let token = self.advance()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(self.get_text(token))
     |       } else {
     |         None
     |       }
     |       let limits = self.parse_limits()
     |       let elem_type = self.parse_value_type()
     |       (ImportDesc::Table({ limits, elem_type }), table_id)
     |     }
     |     Memory => {
     |       let _ = self.advance()
     |       let mem_id : String? = if self.current.token_type is Var {
     |         let token = self.advance()
     |         Some(self.get_text(token))
     |       } else {
     |         None
     |       }
     |       let limits = self.parse_limits()
     |       (ImportDesc::Memory(limits), mem_id)
     |     }
     |     Global => {
     |       let _ = self.advance()
     |       let global_id : String? = if self.current.token_type is Var {
1637 |         let token = self.advance()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(self.get_text(token))
     |       } else {
     |         None
     |       }
     |       let (val_type, mutable_) = if self.check(Lpar) {
     |         self.expect_lpar()
     |         let _ = self.expect(Mut, "expected 'mut'")
     |         let vt = self.parse_value_type()
     |         self.expect_rpar()
     |         (vt, true)
     |       } else {
     |         (self.parse_value_type(), false)
     |       }
     |       (ImportDesc::Global({ val_type, mutable_ }), global_id)
     |     }
     |     _ => raise UnexpectedToken(self.current, "expected import descriptor")
     |   }
     |   self.expect_rpar()
     |   { module_name, field_name, desc, id }
     | }
     …

     | fn WastParser::parse_export(self : WastParser) -> Export raise ParserError {
     |   let _ = self.expect(Export, "expected 'export'")
     |   let name_token = self.expect(Text, "expected export name")
     |   let name = self.strip_quotes(self.get_text(name_token))
     |   self.expect_lpar()
     |   let desc = match self.current.token_type {
     |     Func => {
     |       let _ = self.advance()
     |       ExportDesc::Func(self.parse_index())
     |     }
     |     Table => {
     |       let _ = self.advance()
     |       ExportDesc::Table(self.parse_index())
     |     }
     |     Memory => {
     |       let _ = self.advance()
     |       ExportDesc::Memory(self.parse_index())
     |     }
     |     Global => {
     |       let _ = self.advance()
     |       ExportDesc::Global(self.parse_index())
     |     }
1682 |     _ => raise UnexpectedToken(self.current, "expected export descriptor")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   self.expect_rpar()
     |   { name, desc }
     | }
     …

     | fn WastParser::parse_command(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   match self.current.token_type {
     |     Module => self.parse_module_command()
     |     Register => self.parse_register_command()
     |     Invoke => WastCommand::Action(self.parse_action())
     |     Get => WastCommand::Action(self.parse_action())
     |     AssertReturn => self.parse_assert_return()
     |     AssertTrap => self.parse_assert_trap()
     |     AssertExhaustion => self.parse_assert_exhaustion()
     |     AssertMalformed => self.parse_assert_malformed()
     |     AssertInvalid => self.parse_assert_invalid()
1716 |     AssertUnlinkable => self.parse_assert_unlinkable()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => raise UnexpectedToken(self.current, "expected WAST command")
     |   }
     | }
     …

     | fn WastParser::parse_module_command(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(Module, "expected 'module'")
     | 
     |   // Check for optional module id
     |   let id : String? = if self.current.token_type is Var {
1729 |     let token = self.advance()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(self.get_text(token))
     |   } else {
     |     None
     |   }
     | 
     |   // Check for binary or quote form
     |   match self.current.token_type {
1737 |     Binary => {
     |     ^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let data = self.parse_data_strings()
     |       WastCommand::ModuleBinary(id, data)
     |     }
1742 |     Quote => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let strings = self.parse_quote_strings()
     |       WastCommand::ModuleQuote(id, strings)
     |     }
     |     _ => {
     |       // Regular module - parse fields
     |       let fields : Array[ModuleField] = []
     |       while self.check(Lpar) {
     |         self.expect_lpar()
     |         fields.push(self.parse_module_field())
     |         self.expect_rpar()
     |       }
     |       WastCommand::Module({ id, fields })
     |     }
     |   }
     | }
     …

     | fn WastParser::parse_data_strings(self : WastParser) -> Bytes {
1762 |   let buf = @buffer.new()
     |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   while self.check(Text) {
1764 |     let token = self.advance()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     let text = self.get_text(token)
     |     let decoded = self.decode_string(text)
     |     buf.write_bytes(decoded)
     |   }
1769 |   buf.to_bytes()
     |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn WastParser::parse_quote_strings(self : WastParser) -> Array[String] {
1774 |   let strings : Array[String] = []
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   while self.check(Text) {
1776 |     let token = self.advance()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     strings.push(self.strip_quotes(self.get_text(token)))
     |   }
     |   strings
     | }
     …

     | fn WastParser::parse_register_command(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(Register, "expected 'register'")
1787 |   let name_token = self.expect(Text, "expected register name")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let name = self.strip_quotes(self.get_text(name_token))
     |   let module_id : String? = if self.current.token_type is Var {
1790 |     let token = self.advance()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(self.get_text(token))
     |   } else {
1793 |     None
     |     ^^^^ 	<-- UNCOVERED
     |   }
     |   WastCommand::Register(name, module_id)
     | }
     …

     | fn WastParser::parse_action(
     |   self : WastParser,
     | ) -> WastActionType raise ParserError {
     |   match self.current.token_type {
     |     Invoke => {
     |       let _ = self.advance()
     |       let module_name : String? = if self.current.token_type is Var {
     |         let token = self.advance()
     |         Some(self.get_text(token))
     |       } else {
     |         None
     |       }
     |       let name_token = self.expect(Text, "expected function name")
     |       let name = self.strip_quotes(self.get_text(name_token))
     |       let args = self.parse_wast_values()
     |       WastActionType::Invoke({ module_name, name, args })
     |     }
     |     Get => {
     |       let _ = self.advance()
     |       let module_name : String? = if self.current.token_type is Var {
1819 |         let token = self.advance()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(self.get_text(token))
     |       } else {
     |         None
     |       }
     |       let name_token = self.expect(Text, "expected global name")
     |       let name = self.strip_quotes(self.get_text(name_token))
     |       WastActionType::Get(module_name, name)
     |     }
1828 |     _ => raise UnexpectedToken(self.current, "expected 'invoke' or 'get'")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::parse_wast_value(
     |   self : WastParser,
     | ) -> WastValue raise ParserError {
     |   match self.current.token_type {
     |     Opcode(I32Const) => {
     |       let _ = self.advance()
     |       let token = self.advance()
     |       WastValue::I32(self.get_literal_text(token))
     |     }
     |     Opcode(I64Const) => {
     |       let _ = self.advance()
     |       let token = self.advance()
     |       WastValue::I64(self.get_literal_text(token))
     |     }
     |     Opcode(F32Const) => {
     |       let _ = self.advance()
     |       let token = self.advance()
     |       WastValue::F32(self.get_literal_text(token))
     |     }
     |     Opcode(F64Const) => {
     |       let _ = self.advance()
     |       let token = self.advance()
     |       WastValue::F64(self.get_literal_text(token))
     |     }
     |     Opcode(RefNull) => {
     |       let _ = self.advance()
     |       let vt = self.parse_value_type()
     |       WastValue::RefNull(vt)
     |     }
     |     Opcode(RefFunc) => {
     |       let _ = self.advance()
     |       WastValue::RefFunc
     |     }
1880 |     _ => raise UnexpectedToken(self.current, "expected const instruction")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::parse_wast_results(
     |   self : WastParser,
     | ) -> Array[WastResult] raise ParserError {
1888 |   let results : Array[WastResult] = []
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   while self.check(Lpar) {
1890 |     self.expect_lpar()
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     let result = self.parse_wast_result()
     |     results.push(result)
     |     self.expect_rpar()
     |   }
     |   results
     | }
     …

     | fn WastParser::parse_wast_result(
     |   self : WastParser,
     | ) -> WastResult raise ParserError {
1902 |   match self.current.token_type {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Opcode(I32Const) => {
     |       let _ = self.advance()
     |       let token = self.advance()
     |       WastResult::Value(WastValue::I32(self.get_literal_text(token)))
     |     }
1908 |     Opcode(I64Const) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let token = self.advance()
     |       WastResult::Value(WastValue::I64(self.get_literal_text(token)))
     |     }
1913 |     Opcode(F32Const) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let token = self.advance()
     |       let text = self.get_literal_text(token)
     |       if text == "nan:canonical" {
1918 |         WastResult::F32NanCanonical
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else if text == "nan:arithmetic" {
     |         WastResult::F32NanArithmetic
     |       } else {
1922 |         WastResult::Value(WastValue::F32(text))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1925 |     Opcode(F64Const) => {
     |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let token = self.advance()
     |       let text = self.get_literal_text(token)
     |       if text == "nan:canonical" {
1930 |         WastResult::F64NanCanonical
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else if text == "nan:arithmetic" {
     |         WastResult::F64NanArithmetic
     |       } else {
1934 |         WastResult::Value(WastValue::F64(text))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
1937 |     Opcode(RefNull) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let vt : ValueType? = if self.current.token_type is ValueType(_) {
1940 |         Some(self.parse_value_type())
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
1942 |         None
     |         ^^^^ 	<-- UNCOVERED
     |       }
     |       WastResult::RefNull(vt)
     |     }
1946 |     Opcode(RefFunc) => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       WastResult::RefFunc
     |     }
     |     // ref.extern result
1951 |     _ => raise UnexpectedToken(self.current, "expected result value")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::parse_assert_return(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(AssertReturn, "expected 'assert_return'")
1960 |   self.expect_lpar()
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let action = self.parse_action()
     |   self.expect_rpar()
     |   let results = self.parse_wast_results()
     |   WastCommand::AssertReturn(action, results)
     | }
     …

     | fn WastParser::parse_assert_trap(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(AssertTrap, "expected 'assert_trap'")
1972 |   self.expect_lpar()
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Can be either an action or a module
     |   if self.check(Invoke) || self.check(Get) {
1976 |     let action = self.parse_action()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     self.expect_rpar()
     |     let msg_token = self.expect(Text, "expected trap message")
     |     let msg = self.strip_quotes(self.get_text(msg_token))
     |     WastCommand::AssertTrap(action, msg)
     |   } else {
     |     // Module trap - treat as module definition that traps on instantiation
1983 |     let module_def = self.parse_module_def()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     self.expect_rpar()
     |     let msg_token = self.expect(Text, "expected trap message")
     |     let msg = self.strip_quotes(self.get_text(msg_token))
     |     // For module traps, we use AssertTrap with a dummy action
     |     // This could be refined with a separate AST variant
     |     WastCommand::AssertUnlinkable(module_def, msg)
     |   }
     | }
     …

     | fn WastParser::parse_assert_exhaustion(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(AssertExhaustion, "expected 'assert_exhaustion'")
1998 |   self.expect_lpar()
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let action = self.parse_action()
     |   self.expect_rpar()
     |   let msg_token = self.expect(Text, "expected exhaustion message")
     |   let msg = self.strip_quotes(self.get_text(msg_token))
     |   WastCommand::AssertExhaustion(action, msg)
     | }
     …

     | fn WastParser::parse_module_def(
     |   self : WastParser,
     | ) -> WastModuleDef raise ParserError {
2010 |   let _ = self.expect(Module, "expected 'module'")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |   // Skip optional id
     |   if self.current.token_type is Var {
2014 |     let _ = self.advance()
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
2016 |   match self.current.token_type {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Binary => {
     |       let _ = self.advance()
     |       let data = self.parse_data_strings()
     |       WastModuleDef::Binary(data)
     |     }
2022 |     Quote => {
     |     ^^^^^^^^^^ 	<-- UNCOVERED
     |       let _ = self.advance()
     |       let strings = self.parse_quote_strings()
     |       WastModuleDef::Quote(strings)
     |     }
2027 |     _ => {
     |     ^^^^^^ 	<-- UNCOVERED
     |       let fields : Array[ModuleField] = []
     |       while self.check(Lpar) {
2030 |         self.expect_lpar()
     |         ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         fields.push(self.parse_module_field())
     |         self.expect_rpar()
     |       }
     |       WastModuleDef::Inline({ id: None, fields })
     |     }
     |   }
     | }
     …

     | fn WastParser::parse_assert_malformed(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(AssertMalformed, "expected 'assert_malformed'")
2044 |   self.expect_lpar()
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let module_def = self.parse_module_def()
     |   self.expect_rpar()
     |   let msg_token = self.expect(Text, "expected error message")
     |   let msg = self.strip_quotes(self.get_text(msg_token))
     |   WastCommand::AssertMalformed(module_def, msg)
     | }
     …

     | fn WastParser::parse_assert_invalid(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
     |   let _ = self.expect(AssertInvalid, "expected 'assert_invalid'")
2057 |   self.expect_lpar()
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let module_def = self.parse_module_def()
     |   self.expect_rpar()
     |   let msg_token = self.expect(Text, "expected error message")
     |   let msg = self.strip_quotes(self.get_text(msg_token))
     |   WastCommand::AssertInvalid(module_def, msg)
     | }
     …

     | fn WastParser::parse_assert_unlinkable(
     |   self : WastParser,
     | ) -> WastCommand raise ParserError {
2069 |   let _ = self.expect(AssertUnlinkable, "expected 'assert_unlinkable'")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   self.expect_lpar()
     |   let module_def = self.parse_module_def()
     |   self.expect_rpar()
     |   let msg_token = self.expect(Text, "expected error message")
     |   let msg = self.strip_quotes(self.get_text(msg_token))
     |   WastCommand::AssertUnlinkable(module_def, msg)
     | }
     …

     | fn WastParser::parse_data(self : WastParser) -> DataSegment raise ParserError {
     |   let _ = self.expect(Data, "expected 'data'")
     |   let id : String? = if self.current.token_type is Var {
     |     let token = self.advance()
     |     Some(self.get_text(token))
     |   } else {
     |     None
     |   }
     | 
     |   // Memory index (optional, defaults to 0)
     |   let memory_index = self.try_parse_index().unwrap_or(Index::Num(0))
     | 
     |   // Offset expression
     |   let offset = if self.check(Lpar) {
     |     self.expect_lpar()
     |     if self.check(Offset) {
     |       let _ = self.advance()
     |     }
     |     let instrs = self.parse_instructions()
     |     self.expect_rpar()
     |     instrs
     |   } else {
2108 |     []
     |     ^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Data string(s)
     |   let data_bytes = @buffer.new()
     |   while self.check(Text) {
     |     let token = self.advance()
     |     let text = self.get_text(token)
     |     let decoded = self.decode_string(text)
     |     data_bytes.write_bytes(decoded)
     |   }
     |   { id, memory_index, offset, data: data_bytes.to_bytes() }
     | }
     …

     | fn WastParser::parse_elem(self : WastParser) -> ElemSegment raise ParserError {
     |   let _ = self.expect(Elem, "expected 'elem'")
     |   let id : String? = if self.current.token_type is Var {
     |     let token = self.advance()
     |     Some(self.get_text(token))
     |   } else {
     |     None
     |   }
     |   let table_index = self.try_parse_index().unwrap_or(Index::Num(0))
     | 
     |   // Offset expression
     |   let offset = if self.check(Lpar) {
     |     self.expect_lpar()
     |     if self.check(Offset) {
     |       let _ = self.advance()
     |     }
     |     let instrs = self.parse_instructions()
     |     self.expect_rpar()
     |     instrs
     |   } else {
2143 |     []
     |     ^^ 	<-- UNCOVERED
     |   }
     | 
     |   // Function indices
     |   let func_indices : Array[Index] = []
     |   while self.current.token_type is (Nat | Var) {
     |     func_indices.push(self.parse_index())
     |   }
     |   { id, table_index, offset, func_indices }
     | }
     …

     | fn WastParser::parse_v128_const(
     |   self : WastParser,
     | ) -> V128Const raise ParserError {
     |   // v128.const can have multiple forms:
     |   // v128.const i8x16 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
     |   // v128.const i16x8 0 1 2 3 4 5 6 7
     |   // v128.const i32x4 0 1 2 3
     |   // v128.const i64x2 0 1
     |   // v128.const f32x4 0.0 1.0 2.0 3.0
     |   // v128.const f64x2 0.0 1.0
     | 
2189 |   let shape = self.parse_simd_shape()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let count = match shape {
     |     I8x16 => 16
     |     I16x8 => 8
     |     I32x4 => 4
     |     I64x2 => 2
     |     F32x4 => 4
     |     F64x2 => 2
     |   }
     |   let values : Array[String] = []
2199 |   for i = 0; i < count; i = i + 1 {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     let token = self.advance()
     |     let text = match token.token_type {
     |       Nat | Int | Float => self.get_literal_text(token)
     |       _ => raise UnexpectedToken(token, "expected numeric literal")
     |     }
2205 |     values.push(text)
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   { shape, values }
     | }
     …

     | fn WastParser::parse_simd_shape(
     |   self : WastParser,
     | ) -> SimdShape raise ParserError {
2214 |   match self.current.token_type {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     SimdShapeToken(shape) => {
     |       let _ = self.advance()
     |       shape
     |     }
     |     _ =>
2220 |       raise UnexpectedToken(
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         self.current,
     |         "expected SIMD shape (i8x16, i16x8, etc.)",
     |       )
     |   }
     | }
     …

     | fn WastParser::parse_lane_index(self : WastParser) -> UInt raise ParserError {
2229 |   let token = self.expect(Nat, "expected lane index")
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   parse_uint(self.get_literal_text(token))
     | }
     …

     | fn WastParser::parse_shuffle_lanes(
     |   self : WastParser,
     | ) -> ShuffleLanes raise ParserError {
2237 |   let lanes : FixedArray[UInt] = FixedArray::make(16, 0U)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   for i = 0; i < 16; i = i + 1 {
     |     let token = self.expect(Nat, "expected shuffle lane index")
     |     lanes[i] = parse_uint(self.get_literal_text(token))
     |   }
     |   { lanes, }
     | }
     …

     | fn WastParser::parse_simd_mem_arg(
     |   self : WastParser,
     |   default_align : UInt,
     | ) -> MemArg {
2250 |   self.parse_mem_arg(default_align)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | fn WastParser::parse_simd_instruction(
     |   self : WastParser,
     |   op : Opcode,
     | ) -> Instruction raise ParserError {
2258 |   match op {
     |   ^^^^^^^^^^ 	<-- UNCOVERED
     |     // V128 Const
2260 |     V128Const => {
     |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let v128_const = self.parse_v128_const()
     |       V128Const(v128_const)
     |     }
     | 
     |     // V128 Memory - Load
2266 |     V128Load => V128Load(self.parse_simd_mem_arg(16))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     V128Load8x8S => V128Load8x8S(self.parse_simd_mem_arg(8))
     |     V128Load8x8U => V128Load8x8U(self.parse_simd_mem_arg(8))
     |     V128Load16x4S => V128Load16x4S(self.parse_simd_mem_arg(8))
     |     V128Load16x4U => V128Load16x4U(self.parse_simd_mem_arg(8))
     |     V128Load32x2S => V128Load32x2S(self.parse_simd_mem_arg(8))
     |     V128Load32x2U => V128Load32x2U(self.parse_simd_mem_arg(8))
     |     V128Load8Splat => V128Load8Splat(self.parse_simd_mem_arg(1))
     |     V128Load16Splat => V128Load16Splat(self.parse_simd_mem_arg(2))
     |     V128Load32Splat => V128Load32Splat(self.parse_simd_mem_arg(4))
     |     V128Load64Splat => V128Load64Splat(self.parse_simd_mem_arg(8))
     |     V128Load32Zero => V128Load32Zero(self.parse_simd_mem_arg(4))
     |     V128Load64Zero => V128Load64Zero(self.parse_simd_mem_arg(8))
     |     V128Store => V128Store(self.parse_simd_mem_arg(16))
     | 
     |     // V128 Memory - Lane operations
2282 |     V128Load8Lane => {
     |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(1)
     |       let lane = self.parse_lane_index()
     |       V128Load8Lane(memarg, lane)
     |     }
2287 |     V128Load16Lane => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(2)
     |       let lane = self.parse_lane_index()
     |       V128Load16Lane(memarg, lane)
     |     }
2292 |     V128Load32Lane => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(4)
     |       let lane = self.parse_lane_index()
     |       V128Load32Lane(memarg, lane)
     |     }
2297 |     V128Load64Lane => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(8)
     |       let lane = self.parse_lane_index()
     |       V128Load64Lane(memarg, lane)
     |     }
2302 |     V128Store8Lane => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(1)
     |       let lane = self.parse_lane_index()
     |       V128Store8Lane(memarg, lane)
     |     }
2307 |     V128Store16Lane => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(2)
     |       let lane = self.parse_lane_index()
     |       V128Store16Lane(memarg, lane)
     |     }
2312 |     V128Store32Lane => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(4)
     |       let lane = self.parse_lane_index()
     |       V128Store32Lane(memarg, lane)
     |     }
2317 |     V128Store64Lane => {
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let memarg = self.parse_simd_mem_arg(8)
     |       let lane = self.parse_lane_index()
     |       V128Store64Lane(memarg, lane)
     |     }
     | 
     |     // Shuffle
2324 |     I8x16Shuffle => {
     |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let lanes = self.parse_shuffle_lanes()
     |       I8x16Shuffle(lanes)
     |     }
2328 |     I8x16Swizzle => I8x16Swizzle
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Splat
2331 |     I8x16Splat => I8x16Splat
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8Splat => I16x8Splat
     |     I32x4Splat => I32x4Splat
     |     I64x2Splat => I64x2Splat
     |     F32x4Splat => F32x4Splat
     |     F64x2Splat => F64x2Splat
     | 
     |     // Extract lane
2339 |     I8x16ExtractLaneS => I8x16ExtractLaneS(self.parse_lane_index())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I8x16ExtractLaneU => I8x16ExtractLaneU(self.parse_lane_index())
     |     I16x8ExtractLaneS => I16x8ExtractLaneS(self.parse_lane_index())
     |     I16x8ExtractLaneU => I16x8ExtractLaneU(self.parse_lane_index())
     |     I32x4ExtractLane => I32x4ExtractLane(self.parse_lane_index())
     |     I64x2ExtractLane => I64x2ExtractLane(self.parse_lane_index())
     |     F32x4ExtractLane => F32x4ExtractLane(self.parse_lane_index())
     |     F64x2ExtractLane => F64x2ExtractLane(self.parse_lane_index())
     | 
     |     // Replace lane
2349 |     I8x16ReplaceLane => I8x16ReplaceLane(self.parse_lane_index())
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     I16x8ReplaceLane => I16x8ReplaceLane(self.parse_lane_index())
     |     I32x4ReplaceLane => I32x4ReplaceLane(self.parse_lane_index())
     |     I64x2ReplaceLane => I64x2ReplaceLane(self.parse_lane_index())
     |     F32x4ReplaceLane => F32x4ReplaceLane(self.parse_lane_index())
     |     F64x2ReplaceLane => F64x2ReplaceLane(self.parse_lane_index())
     | 
     |     // Unary operations
     |     I8x16Abs
     |     | I8x16Neg
     |     | I8x16Popcnt
     |     | I16x8Abs
     |     | I16x8Neg
     |     | I32x4Abs
     |     | I32x4Neg
     |     | I64x2Abs
     |     | I64x2Neg
     |     | F32x4Abs
     |     | F32x4Neg
     |     | F32x4Sqrt
     |     | F32x4Ceil
     |     | F32x4Floor
     |     | F32x4Trunc
     |     | F32x4Nearest
     |     | F64x2Abs
     |     | F64x2Neg
     |     | F64x2Sqrt
     |     | F64x2Ceil
     |     | F64x2Floor
     |     | F64x2Trunc
     |     | F64x2Nearest
2380 |     | V128Not => SimdUnary(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Binary operations
     |     I8x16Add
     |     | I8x16AddSatS
     |     | I8x16AddSatU
     |     | I8x16Sub
     |     | I8x16SubSatS
     |     | I8x16SubSatU
     |     | I8x16MinS
     |     | I8x16MinU
     |     | I8x16MaxS
     |     | I8x16MaxU
     |     | I8x16AvgrU
     |     | I16x8Add
     |     | I16x8AddSatS
     |     | I16x8AddSatU
     |     | I16x8Sub
     |     | I16x8SubSatS
     |     | I16x8SubSatU
     |     | I16x8Mul
     |     | I16x8MinS
     |     | I16x8MinU
     |     | I16x8MaxS
     |     | I16x8MaxU
     |     | I16x8AvgrU
     |     | I16x8Q15mulrSatS
     |     | I32x4Add
     |     | I32x4Sub
     |     | I32x4Mul
     |     | I32x4MinS
     |     | I32x4MinU
     |     | I32x4MaxS
     |     | I32x4MaxU
     |     | I32x4DotI16x8S
     |     | I64x2Add
     |     | I64x2Sub
     |     | I64x2Mul
     |     | F32x4Add
     |     | F32x4Sub
     |     | F32x4Mul
     |     | F32x4Div
     |     | F32x4Min
     |     | F32x4Max
     |     | F32x4Pmin
     |     | F32x4Pmax
     |     | F64x2Add
     |     | F64x2Sub
     |     | F64x2Mul
     |     | F64x2Div
     |     | F64x2Min
     |     | F64x2Max
     |     | F64x2Pmin
     |     | F64x2Pmax
     |     | V128And
     |     | V128AndNot
     |     | V128Or
     |     | V128Xor
     |     | I8x16NarrowI16x8S
     |     | I8x16NarrowI16x8U
     |     | I16x8NarrowI32x4S
     |     | I16x8NarrowI32x4U
     |     | I16x8ExtmulLowI8x16S
     |     | I16x8ExtmulHighI8x16S
     |     | I16x8ExtmulLowI8x16U
     |     | I16x8ExtmulHighI8x16U
     |     | I32x4ExtmulLowI16x8S
     |     | I32x4ExtmulHighI16x8S
     |     | I32x4ExtmulLowI16x8U
     |     | I32x4ExtmulHighI16x8U
     |     | I64x2ExtmulLowI32x4S
     |     | I64x2ExtmulHighI32x4S
     |     | I64x2ExtmulLowI32x4U
2453 |     | I64x2ExtmulHighI32x4U => SimdBinary(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Ternary operations
     |     V128Bitselect
     |     | F32x4RelaxedMadd
     |     | F32x4RelaxedNmadd
     |     | F64x2RelaxedMadd
     |     | F64x2RelaxedNmadd
     |     | I8x16RelaxedLaneselect
     |     | I16x8RelaxedLaneselect
     |     | I32x4RelaxedLaneselect
2464 |     | I64x2RelaxedLaneselect => SimdTernary(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Shift operations
     |     I8x16Shl
     |     | I8x16ShrS
     |     | I8x16ShrU
     |     | I16x8Shl
     |     | I16x8ShrS
     |     | I16x8ShrU
     |     | I32x4Shl
     |     | I32x4ShrS
     |     | I32x4ShrU
     |     | I64x2Shl
     |     | I64x2ShrS
2478 |     | I64x2ShrU => SimdShift(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Test operations (return i32)
     |     V128AnyTrue
     |     | I8x16AllTrue
     |     | I8x16Bitmask
     |     | I16x8AllTrue
     |     | I16x8Bitmask
     |     | I32x4AllTrue
     |     | I32x4Bitmask
     |     | I64x2AllTrue
2489 |     | I64x2Bitmask => SimdTest(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Comparison operations
     |     I8x16Eq
     |     | I8x16Ne
     |     | I8x16LtS
     |     | I8x16LtU
     |     | I8x16GtS
     |     | I8x16GtU
     |     | I8x16LeS
     |     | I8x16LeU
     |     | I8x16GeS
     |     | I8x16GeU
     |     | I16x8Eq
     |     | I16x8Ne
     |     | I16x8LtS
     |     | I16x8LtU
     |     | I16x8GtS
     |     | I16x8GtU
     |     | I16x8LeS
     |     | I16x8LeU
     |     | I16x8GeS
     |     | I16x8GeU
     |     | I32x4Eq
     |     | I32x4Ne
     |     | I32x4LtS
     |     | I32x4LtU
     |     | I32x4GtS
     |     | I32x4GtU
     |     | I32x4LeS
     |     | I32x4LeU
     |     | I32x4GeS
     |     | I32x4GeU
     |     | I64x2Eq
     |     | I64x2Ne
     |     | I64x2LtS
     |     | I64x2GtS
     |     | I64x2LeS
     |     | I64x2GeS
     |     | F32x4Eq
     |     | F32x4Ne
     |     | F32x4Lt
     |     | F32x4Gt
     |     | F32x4Le
     |     | F32x4Ge
     |     | F64x2Eq
     |     | F64x2Ne
     |     | F64x2Lt
     |     | F64x2Gt
     |     | F64x2Le
2539 |     | F64x2Ge => SimdCompare(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Conversion operations
     |     I16x8ExtendLowI8x16S
     |     | I16x8ExtendHighI8x16S
     |     | I16x8ExtendLowI8x16U
     |     | I16x8ExtendHighI8x16U
     |     | I32x4ExtendLowI16x8S
     |     | I32x4ExtendHighI16x8S
     |     | I32x4ExtendLowI16x8U
     |     | I32x4ExtendHighI16x8U
     |     | I64x2ExtendLowI32x4S
     |     | I64x2ExtendHighI32x4S
     |     | I64x2ExtendLowI32x4U
     |     | I64x2ExtendHighI32x4U
     |     | I32x4TruncSatF32x4S
     |     | I32x4TruncSatF32x4U
     |     | I32x4TruncSatF64x2SZero
     |     | I32x4TruncSatF64x2UZero
     |     | F32x4ConvertI32x4S
     |     | F32x4ConvertI32x4U
     |     | F32x4DemoteF64x2Zero
     |     | F64x2ConvertLowI32x4S
     |     | F64x2ConvertLowI32x4U
2563 |     | F64x2PromoteLowF32x4 => SimdConvert(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |     // Relaxed SIMD
     |     I8x16RelaxedSwizzle
     |     | I32x4RelaxedTruncF32x4S
     |     | I32x4RelaxedTruncF32x4U
     |     | I32x4RelaxedTruncF64x2SZero
     |     | I32x4RelaxedTruncF64x2UZero
     |     | F32x4RelaxedMin
     |     | F32x4RelaxedMax
     |     | F64x2RelaxedMin
     |     | F64x2RelaxedMax
     |     | I16x8RelaxedQ15mulrS
     |     | I16x8RelaxedDotI8x16I7x16S
2577 |     | I32x4RelaxedDotI8x16I7x16AddS => SimdRelaxed(op)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => raise InvalidInstruction("unhandled SIMD opcode")
     |   }
     | }
     …

     | fn WastParser::strip_quotes(_ : WastParser, s : String) -> String {
     |   if s.length() >= 2 && s[0] == '"' && s[s.length() - 1] == '"' {
     |     s.sub(start=1, end=s.length() - 1).to_string() catch {
2610 |       _ => s
     |       ^^^^^^ 	<-- UNCOVERED
     |     }
     |   } else {
2613 |     s
     |     ^ 	<-- UNCOVERED
     |   }
     | }
     …

     | fn WastParser::decode_string(self : WastParser, s : String) -> Bytes {
     |   let buf = @buffer.new()
     |   let inner = self.strip_quotes(s)
     |   let mut i = 0
     |   while i < inner.length() {
     |     let c = inner[i]
     |     if c == '\\' && i + 1 < inner.length() {
     |       let next = inner[i + 1]
     |       match next {
     |         'n' => {
     |           buf.write_byte(b'\n')
     |           i += 2
     |         }
2631 |         't' => {
     |         ^^^^^^^^ 	<-- UNCOVERED
     |           buf.write_byte(b'\t')
     |           i += 2
     |         }
2635 |         'r' => {
     |         ^^^^^^^^ 	<-- UNCOVERED
     |           buf.write_byte(b'\r')
     |           i += 2
     |         }
2639 |         '"' => {
     |         ^^^^^^^^ 	<-- UNCOVERED
     |           buf.write_byte(b'"')
     |           i += 2
     |         }
2643 |         '\'' => {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           buf.write_byte(b'\'')
     |           i += 2
     |         }
2647 |         '\\' => {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           buf.write_byte(b'\\')
     |           i += 2
     |         }
     |         _ =>
     |           // Hex escape \XX
     |           if i + 2 < inner.length() {
     |             let h1 = hex_val(inner[i + 1].unsafe_to_char())
     |             let h2 = hex_val(inner[i + 2].unsafe_to_char())
     |             if h1 >= 0 && h2 >= 0 {
     |               buf.write_byte(((h1 << 4) | h2).to_byte())
     |               i += 3
     |             } else {
2660 |               buf.write_byte(c.to_int().to_byte())
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               i += 1
     |             }
     |           } else {
2664 |             buf.write_byte(c.to_int().to_byte())
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             i += 1
     |           }
     |       }
     |     } else {
     |       buf.write_byte(c.to_int().to_byte())
     |       i += 1
     |     }
     |   }
     |   buf.to_bytes()
     | }
     …

     | fn hex_val(c : Char) -> Int {
     |   if c >= '0' && c <= '9' {
     |     c.to_int() - 0x30
2680 |   } else if c >= 'a' && c <= 'f' {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     c.to_int() - 0x61 + 10
     |   } else if c >= 'A' && c <= 'F' {
     |     c.to_int() - 0x41 + 10
     |   } else {
2685 |     -1
     |     ^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn WastParser::get_errors(self : WastParser) -> Array[ParseError] {
2696 |   self.errors
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

49 uncovered line(s) in src/wast/pretty_print_impls.mbt:

    | fn pretty_from_show(value : &Show, ctx : PrettyPrintContext) -> String {
  3 |   apply_pretty_context(value.to_string(), ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Module with pretty_print(self, ctx) {
    |   match module_to_wast_with_context(self, ctx) {
    |     Ok(text) => text
 10 |     Err(msg) => "(module ;; \{msg})"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl PrettyPrint for WastScript with pretty_print(self, ctx) {
 16 |   match script_to_wast_with_context(self, ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Ok(text) => text
    |     Err(msg) => ";; \{msg}"
    |   }
    | }
    …

    | pub impl PrettyPrint for Index with pretty_print(self, ctx) {
 24 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Limits with pretty_print(self, ctx) {
 29 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for FuncType with pretty_print(self, ctx) {
 34 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TypeUse with pretty_print(self, ctx) {
 39 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for InlineExport with pretty_print(self, ctx) {
 44 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ImportDesc with pretty_print(self, ctx) {
 49 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Import with pretty_print(self, ctx) {
 54 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ExportDesc with pretty_print(self, ctx) {
 59 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Export with pretty_print(self, ctx) {
 64 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TableType with pretty_print(self, ctx) {
 69 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for MemoryType with pretty_print(self, ctx) {
 74 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for GlobalType with pretty_print(self, ctx) {
 79 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Local with pretty_print(self, ctx) {
 84 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Func with pretty_print(self, ctx) {
 89 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Global with pretty_print(self, ctx) {
 94 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Table with pretty_print(self, ctx) {
 99 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Memory with pretty_print(self, ctx) {
104 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TypeDef with pretty_print(self, ctx) {
109 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for DataSegment with pretty_print(self, ctx) {
114 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ElemSegment with pretty_print(self, ctx) {
119 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Start with pretty_print(self, ctx) {
124 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ModuleField with pretty_print(self, ctx) {
129 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for MemArg with pretty_print(self, ctx) {
134 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for BlockType with pretty_print(self, ctx) {
139 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for V128Const with pretty_print(self, ctx) {
144 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for SimdShape with pretty_print(self, ctx) {
149 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ShuffleLanes with pretty_print(self, ctx) {
154 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Instruction with pretty_print(self, ctx) {
159 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for WastValue with pretty_print(self, ctx) {
164 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for WastResult with pretty_print(self, ctx) {
169 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for WastAction with pretty_print(self, ctx) {
174 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for WastActionType with pretty_print(self, ctx) {
179 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for WastCommand with pretty_print(self, ctx) {
184 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for WastModuleDef with pretty_print(self, ctx) {
189 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ParseError with pretty_print(self, ctx) {
194 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ParserError with pretty_print(self, ctx) {
199 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for LiteralType with pretty_print(self, ctx) {
204 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ErrorLevel with pretty_print(self, ctx) {
209 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Location with pretty_print(self, ctx) {
214 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Literal with pretty_print(self, ctx) {
219 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Token with pretty_print(self, ctx) {
224 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for LexerError with pretty_print(self, ctx) {
229 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for ValueType with pretty_print(self, ctx) {
234 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for Opcode with pretty_print(self, ctx) {
239 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TokenType with pretty_print(self, ctx) {
244 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl PrettyPrint for TokenValue with pretty_print(self, ctx) {
249 |   pretty_from_show(self, ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

Total: 10980 uncovered line(s) in 96 file(s)
