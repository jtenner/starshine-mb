// Generated using `moon info`, DON'T EDIT IT
package "jtenner/starshine/passes"

import {
  "jtenner/starshine/dataflow",
  "jtenner/starshine/lib",
  "jtenner/starshine/transformer",
  "moonbitlang/core/hashmap",
  "moonbitlang/core/set",
}

// Values
pub fn alignment_lowering_pass() -> @transformer.ModuleTransformer[AlignmentLoweringContext]

pub fn code_folding_pass() -> @transformer.ModuleTransformer[CodeFoldingState]

pub fn code_pushing_pass() -> @transformer.ModuleTransformer[Unit]

pub fn const_hoisting_pass() -> @transformer.ModuleTransformer[ConstHoistingState]

pub fn constant_field_propagation_pass() -> @transformer.ModuleTransformer[CFPState]

pub fn defs(@lib.TInstr) -> @set.Set[@lib.LocalIdx]

pub fn directize_module(@lib.Module, Bool) -> Result[@lib.Module, String]

pub fn gvn_pass(@dataflow.Graph) -> Unit

pub fn lift_to_texpr_pass() -> @transformer.ModuleTransformer[Unit]

pub fn lower_to_expr_pass() -> @transformer.ModuleTransformer[Unit]

pub fn optimize(@dataflow.Graph) -> Unit

pub fn optimize_casts(@lib.Module) -> @lib.Module

pub fn optimize_graph(@dataflow.Graph) -> Unit

pub fn propagate_to_supertypes(CFPState) -> Unit

pub fn remove_unused(@lib.Module) -> Result[@lib.Module, String]

pub fn run_constant_field_propagation(@lib.Module) -> Result[@lib.Module, String]

pub fn run_denam(@lib.Module) -> Result[@lib.Module, String]

pub fn run_lower_to_expr_pass(@lib.Module) -> @lib.Module

pub fn uses(@lib.TInstr) -> @set.Set[@lib.LocalIdx]

// Errors

// Types and methods
pub struct AlignmentLoweringContext {
  mut locals : Array[@lib.ValType]
  memories : Array[@lib.MemType]
}
pub fn AlignmentLoweringContext::new(Array[@lib.MemType]) -> Self

type BlockLiveness
pub impl Show for BlockLiveness

pub struct CFPState {
  field_values : @hashmap.HashMap[(Int, Int), FieldValue]
  type_sec : @lib.TypeSec?
}
pub fn CFPState::from_module(@lib.Module) -> Self
pub fn CFPState::new() -> Self

type CastOptState
pub impl Show for CastOptState

type CodeFoldingState

pub struct ConstHoistingState {
  usage : Map[Literal, Int]
}
pub fn ConstHoistingState::new() -> Self

type ConstKey
pub impl Eq for ConstKey
pub impl Hash for ConstKey

pub struct DCEState {
  used : UsedIndices
  remap : Remappings
  imports : ImportCounts
}

pub enum FieldValue {
  Uninitialized
  Constant(@lib.TInstr)
  Unknown
}
pub impl Eq for FieldValue

type GVNKey
pub impl Eq for GVNKey
pub impl Hash for GVNKey

type ImportCounts

pub struct Literal(LiteralKind, Bytes)


pub impl Compare for Literal
pub impl Eq for Literal
pub impl Hash for Literal
pub impl Show for Literal

pub enum LiteralKind {
  I32LiteralKind
  I64LiteralKind
  F32LiteralKind
  F64LiteralKind
  V128LiteralKind
}
pub impl Compare for LiteralKind
pub impl Eq for LiteralKind
pub impl Hash for LiteralKind
pub impl Show for LiteralKind

type NodeUsers
pub fn NodeUsers::add_user(Self, @dataflow.NodeId, @dataflow.NodeId) -> Unit
pub fn NodeUsers::build(@dataflow.Graph) -> Self
pub fn NodeUsers::get_users(Self, @dataflow.NodeId) -> Array[@dataflow.NodeId]
pub fn NodeUsers::new() -> Self
pub fn NodeUsers::num_uses(Self, @dataflow.NodeId) -> Int
pub fn NodeUsers::remove_all_uses_of(Self, @dataflow.NodeId) -> Unit
pub fn NodeUsers::remove_user(Self, @dataflow.NodeId, @dataflow.NodeId) -> Unit

type Remappings

pub struct SquareMatrix[T] {
  storage : Map[UInt64, T]
  n : UInt
}
pub fn[T] SquareMatrix::get_or(Self[T], T, UInt, UInt) -> Result[T, String]
pub fn[T : Default] SquareMatrix::get_or_default(Self[T], UInt, UInt) -> Result[T, String]
pub fn[T] SquareMatrix::new(size? : UInt) -> Self[T]

type Tail
pub impl Eq for Tail

type UsedIndices

// Type aliases

// Traits

