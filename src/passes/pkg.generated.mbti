// Generated using `moon info`, DON'T EDIT IT
package "jtenner/starshine/passes"

import {
  "jtenner/starshine/ir",
  "jtenner/starshine/lib",
  "jtenner/starshine/transformer",
  "moonbitlang/core/hashmap",
  "moonbitlang/core/set",
}

// Values
pub fn alignment_lowering_pass(@lib.Module) -> @transformer.ModuleTransformer[@ir.IRContext]

pub fn code_folding_pass() -> @transformer.ModuleTransformer[CodeFoldingState]

pub fn code_pushing_pass() -> @transformer.ModuleTransformer[Unit]

pub fn const_hoisting_pass() -> @transformer.ModuleTransformer[ConstHoistingState]

pub fn constant_field_propagation_pass() -> @transformer.ModuleTransformer[CFPState]

pub fn dataflow_optimization_pass(@lib.Module) -> @transformer.ModuleTransformer[@ir.IRContext]

pub fn defs(@lib.TInstr) -> @set.Set[@lib.LocalIdx]

pub fn directize_module(@lib.Module, Bool) -> Result[@lib.Module, String]

pub fn global_type_optimization(@lib.Module) -> Result[@lib.Module, String]

pub fn i64_to_i32_lowering(@lib.Module) -> Result[@lib.Module, String]

pub fn lift_to_texpr_pass() -> @transformer.ModuleTransformer[Unit]

pub fn lower_to_expr_pass() -> @transformer.ModuleTransformer[Unit]

pub fn memory_packing(@lib.Module, MemoryPackingPassProps) -> Result[@lib.Module, String]

pub fn optimize_casts(@lib.Module) -> @lib.Module

pub fn optimize_module(@lib.Module, Array[ModulePass]) -> Result[@lib.Module, String]

pub fn optimize_module_with_options(@lib.Module, Array[ModulePass], OptimizeOptions) -> Result[@lib.Module, String]

pub fn propagate_to_supertypes(CFPState) -> Unit

pub fn remove_unused(@lib.Module) -> Result[@lib.Module, String]

pub fn run_constant_field_propagation(@lib.Module) -> Result[@lib.Module, String]

pub fn run_denam(@lib.Module) -> Result[@lib.Module, String]

pub fn run_lower_to_expr_pass(@lib.Module) -> @lib.Module

pub fn run_memory_paacking_on_module(@lib.Module, MemoryPackingPassProps) -> Result[@lib.Module, String]

pub fn run_memory_packing_on_module(@lib.Module, MemoryPackingPassProps) -> Result[@lib.Module, String]

pub fn uses(@lib.TInstr) -> @set.Set[@lib.LocalIdx]

// Errors

// Types and methods
pub(all) struct AbstractTypeRefiningPassProps {
  traps_never_happen : Bool
}

type BlockLiveness
pub impl Show for BlockLiveness

pub struct CFPState {
  field_values : @hashmap.HashMap[(Int, Int), FieldValue]
  type_sec : @lib.TypeSec?
}
pub fn CFPState::from_module(@lib.Module) -> Self
pub fn CFPState::new() -> Self

type CallSite
pub impl Eq for CallSite
pub impl Show for CallSite

type CastOptState
pub impl Show for CastOptState

type CodeFoldingState

pub struct ConstHoistingState {
  usage : Map[Literal, Int]
}
pub fn ConstHoistingState::new() -> Self

type ConstKey
pub impl Eq for ConstKey
pub impl Hash for ConstKey

pub struct DCEState {
  used : UsedIndices
  remap : Remappings
  imports : ImportCounts
}

type DFEKey
pub impl Eq for DFEKey
pub impl Hash for DFEKey

pub enum FieldValue {
  Uninitialized
  Constant(@lib.TInstr)
  Unknown
}
pub impl Eq for FieldValue

type ILCallKind
pub impl Eq for ILCallKind

type ILTrivialKind
pub impl Eq for ILTrivialKind

type ImportCounts

pub struct InliningOptions {
  always_inline_max_size : Int
  one_caller_inline_max_size : Int
  flexible_inline_max_size : Int
  max_combined_binary_size : Int
  allow_functions_with_loops : Bool
  partial_inlining_ifs : Int
}
pub fn InliningOptions::new(always_inline_max_size? : Int, one_caller_inline_max_size? : Int, flexible_inline_max_size? : Int, max_combined_binary_size? : Int, allow_functions_with_loops? : Bool, partial_inlining_ifs? : Int) -> Self

pub struct Literal(LiteralKind, Bytes)


pub fn Literal::f32(Float) -> Self
pub fn Literal::f64(Double) -> Self
pub fn Literal::i32(Int) -> Self
pub fn Literal::i64(Int64) -> Self
pub fn Literal::v128(Bytes) -> Self
pub impl Compare for Literal
pub impl Eq for Literal
pub impl Hash for Literal
pub impl Show for Literal

pub enum LiteralKind {
  I32LiteralKind
  I64LiteralKind
  F32LiteralKind
  F64LiteralKind
  V128LiteralKind
}
pub impl Compare for LiteralKind
pub impl Eq for LiteralKind
pub impl Hash for LiteralKind
pub impl Show for LiteralKind

pub(all) struct MemoryPackingPassProps {
  zero_filled_memory : Bool
  traps_never_happen : Bool
  max_data_segments : Int
}
pub fn MemoryPackingPassProps::new(zero_filled_memory? : Bool, traps_never_happen? : Bool, max_data_segments? : Int) -> Self

pub(all) enum ModulePass {
  AbstractTypeRefining(AbstractTypeRefiningPassProps)
  AlignmentLowering
  AvoidReinterprets
  CoalesceLocals
  CodeFolding
  CodePushing
  ConstHoisting
  ConstantFieldPropagation
  DataflowOptimization
  DeadCodeElimination
  DeadArgumentElimination
  DuplicateImportElimination
  GlobalRefining
  GlobalStructInference
  GlobalStructInferenceDescCast
  GlobalTypeOptimization
  Heap2Local
  HeapStoreOptimization
  Inlining
  InliningOptimizing
  InlineMain
  LocalCSE
  LocalSubtyping
  MemoryPacking(MemoryPackingPassProps)
  GUFA
  GUFAOptimizing
  GUFACastAll
  I64ToI32Lowering
  DuplicateFunctionElimination
  Directize(Bool)
  OptimizeCasts
  DeNaN
  RemoveUnused
}

pub struct OptimizeOptions {
  optimize_level : Int
  shrink_level : Int
  inlining : InliningOptions
}
pub fn OptimizeOptions::new(optimize_level? : Int, shrink_level? : Int, inlining? : InliningOptions) -> Self

type Remappings

pub struct SquareMatrix[T] {
  storage : Map[UInt64, T]
  n : UInt
}
pub fn[T] SquareMatrix::get_or(Self[T], T, UInt, UInt) -> Result[T, String]
pub fn[T : Default] SquareMatrix::get_or_default(Self[T], UInt, UInt) -> Result[T, String]
pub fn[T] SquareMatrix::new(size? : UInt) -> Self[T]

type Tail
pub impl Eq for Tail

type UsedIndices

// Type aliases

// Traits

