// Generated using `moon info`, DON'T EDIT IT
package "jtenner/starshine/passes"

import {
  "jtenner/starshine/ir",
  "jtenner/starshine/lib",
  "jtenner/starshine/transformer",
  "moonbitlang/core/hashmap",
  "moonbitlang/core/set",
}

// Values
pub fn alignment_lowering_pass(@lib.Module) -> @transformer.ModuleTransformer[@ir.IRContext]

pub fn asyncify(@lib.Module, props? : AsyncifyPassProps, optimize_level? : Int) -> Result[@lib.Module, String]

pub fn asyncify_apply_arguments(AsyncifyPassProps, Array[String]) -> Result[AsyncifyPassProps, String]

pub fn code_folding_pass() -> @transformer.ModuleTransformer[CodeFoldingState]

pub fn code_pushing_pass() -> @transformer.ModuleTransformer[Unit]

pub fn const_hoisting_pass() -> @transformer.ModuleTransformer[ConstHoistingState]

pub fn constant_field_propagation_pass() -> @transformer.ModuleTransformer[CFPState]

pub fn createAsyncifyPass(props? : AsyncifyPassProps) -> ModulePass

pub fn createOptimizeAddedConstantsPass() -> ModulePass

pub fn createOptimizeAddedConstantsPropagatePass() -> ModulePass

pub fn dataflow_optimization_pass(@lib.Module) -> @transformer.ModuleTransformer[@ir.IRContext]

pub fn defs(@lib.TInstr) -> @set.Set[@lib.LocalIdx]

pub fn directize_module(@lib.Module, Bool) -> Result[@lib.Module, String]

pub fn global_type_optimization(@lib.Module) -> Result[@lib.Module, String]

pub fn i64_to_i32_lowering(@lib.Module) -> Result[@lib.Module, String]

pub fn lift_to_texpr_pass() -> @transformer.ModuleTransformer[Unit]

pub fn lower_to_expr_pass() -> @transformer.ModuleTransformer[Unit]

pub fn memory_packing(@lib.Module, MemoryPackingPassProps) -> Result[@lib.Module, String]

pub fn minimize_rec_groups(@lib.Module) -> Result[@lib.Module, String]

pub fn monomorphize(@lib.Module, options? : OptimizeOptions, always? : Bool) -> Result[@lib.Module, String]

pub fn monomorphize_apply_arguments(OptimizeOptions, Array[String]) -> OptimizeOptions

pub fn once_reduction(@lib.Module) -> Result[@lib.Module, String]

pub fn optimize_casts(@lib.Module) -> @lib.Module

pub fn optimize_module(@lib.Module, Array[ModulePass]) -> Result[@lib.Module, String]

pub fn optimize_module_with_options(@lib.Module, Array[ModulePass], OptimizeOptions) -> Result[@lib.Module, String]

pub fn propagate_to_supertypes(CFPState) -> Unit

pub fn remove_unused(@lib.Module) -> Result[@lib.Module, String]

pub fn run_constant_field_propagation(@lib.Module) -> Result[@lib.Module, String]

pub fn run_denam(@lib.Module) -> Result[@lib.Module, String]

pub fn run_lower_to_expr_pass(@lib.Module) -> @lib.Module

pub fn run_memory_paacking_on_module(@lib.Module, MemoryPackingPassProps) -> Result[@lib.Module, String]

pub fn run_memory_packing_on_module(@lib.Module, MemoryPackingPassProps) -> Result[@lib.Module, String]

pub fn uses(@lib.TInstr) -> @set.Set[@lib.LocalIdx]

// Errors

// Types and methods
pub(all) struct AbstractTypeRefiningPassProps {
  traps_never_happen : Bool
}

pub(all) struct AsyncifyPassProps {
  imports : Array[String]
  ignore_imports : Bool
  ignore_indirect : Bool
  asserts : Bool
  ignore_unwind_from_catch : Bool
  verbose : Bool
  memory : String?
  removelist : Array[String]
  addlist : Array[String]
  propagate_addlist : Bool
  onlylist : Array[String]
  import_globals : Bool
  export_globals : Bool
  in_secondary_memory : Bool
  secondary_memory_size : UInt64
}
pub fn AsyncifyPassProps::new(imports? : Array[String], ignore_imports? : Bool, ignore_indirect? : Bool, asserts? : Bool, ignore_unwind_from_catch? : Bool, verbose? : Bool, memory? : String?, removelist? : Array[String], addlist? : Array[String], propagate_addlist? : Bool, onlylist? : Array[String], import_globals? : Bool, export_globals? : Bool, in_secondary_memory? : Bool, secondary_memory_size? : UInt64) -> Self

type BlockLiveness
pub impl Show for BlockLiveness

pub struct CFPState {
  field_values : @hashmap.HashMap[(Int, Int), FieldValue]
  type_sec : @lib.TypeSec?
}
pub fn CFPState::from_module(@lib.Module) -> Self
pub fn CFPState::new() -> Self

type CallSite
pub impl Eq for CallSite
pub impl Show for CallSite

type CodeFoldingState

pub struct ConstHoistingState {
  usage : Map[Literal, Int]
}
pub fn ConstHoistingState::new() -> Self

type ConstKey
pub impl Eq for ConstKey
pub impl Hash for ConstKey

pub struct DCEState {
  used : UsedIndices
  remap : Remappings
  imports : ImportCounts
}

type DFEKey
pub impl Eq for DFEKey
pub impl Hash for DFEKey

type EquivalentClass
pub impl Eq for EquivalentClass
pub impl Show for EquivalentClass

pub enum FieldValue {
  Uninitialized
  Constant(@lib.TInstr)
  Unknown
}
pub impl Eq for FieldValue

type ILCallKind
pub impl Eq for ILCallKind

type ILTrivialKind
pub impl Eq for ILTrivialKind

type ImportCounts

pub struct InliningOptions {
  always_inline_max_size : Int
  one_caller_inline_max_size : Int
  flexible_inline_max_size : Int
  max_combined_binary_size : Int
  allow_functions_with_loops : Bool
  partial_inlining_ifs : Int
}
pub fn InliningOptions::new(always_inline_max_size? : Int, one_caller_inline_max_size? : Int, flexible_inline_max_size? : Int, max_combined_binary_size? : Int, allow_functions_with_loops? : Bool, partial_inlining_ifs? : Int) -> Self

pub struct Literal(LiteralKind, Bytes)


pub fn Literal::f32(Float) -> Self
pub fn Literal::f64(Double) -> Self
pub fn Literal::i32(Int) -> Self
pub fn Literal::i64(Int64) -> Self
pub fn Literal::v128(Bytes) -> Self
pub impl Compare for Literal
pub impl Eq for Literal
pub impl Hash for Literal
pub impl Show for Literal

pub enum LiteralKind {
  I32LiteralKind
  I64LiteralKind
  F32LiteralKind
  F64LiteralKind
  V128LiteralKind
}
pub impl Compare for LiteralKind
pub impl Eq for LiteralKind
pub impl Hash for LiteralKind
pub impl Show for LiteralKind

type MSFCallSite
pub impl Eq for MSFCallSite
pub impl Hash for MSFCallSite
pub impl Show for MSFCallSite

type MSFDefinedFunc
pub impl Eq for MSFDefinedFunc
pub impl Show for MSFDefinedFunc

type MSFHashBucketKey
pub impl Eq for MSFHashBucketKey
pub impl Hash for MSFHashBucketKey

type MSFHashState
pub impl Show for MSFHashState

type MSFParamKey
pub impl Eq for MSFParamKey
pub impl Hash for MSFParamKey

type MSFParamKind
pub impl Eq for MSFParamKind
pub impl Hash for MSFParamKind
pub impl Show for MSFParamKind

type MSFSiteValue
pub impl Eq for MSFSiteValue
pub impl Hash for MSFSiteValue
pub impl Show for MSFSiteValue

pub(all) struct MemoryPackingPassProps {
  zero_filled_memory : Bool
  traps_never_happen : Bool
  max_data_segments : Int
}
pub fn MemoryPackingPassProps::new(zero_filled_memory? : Bool, traps_never_happen? : Bool, max_data_segments? : Int) -> Self

pub(all) enum ModulePass {
  AbstractTypeRefining(AbstractTypeRefiningPassProps)
  AlignmentLowering
  AvoidReinterprets
  CoalesceLocals
  CodeFolding
  CodePushing
  ConstHoisting
  ConstantFieldPropagation
  DataflowOptimization
  DeadCodeElimination
  DeadArgumentElimination
  DuplicateImportElimination
  GlobalRefining
  GlobalStructInference
  GlobalStructInferenceDescCast
  GlobalTypeOptimization
  Heap2Local
  HeapStoreOptimization
  Inlining
  InliningOptimizing
  InlineMain
  LocalCSE
  LocalSubtyping
  LoopInvariantCodeMotion
  MergeLocals
  MergeSimilarFunctions
  MergeBlocks
  OnceReduction
  Asyncify(AsyncifyPassProps)
  MinimizeRecGroups
  Monomorphize
  MonomorphizeAlways
  MemoryPacking(MemoryPackingPassProps)
  OptimizeAddedConstants
  OptimizeAddedConstantsPropagate
  OptimizeInstructions
  PickLoadSigns
  GUFA
  GUFAOptimizing
  GUFACastAll
  I64ToI32Lowering
  DuplicateFunctionElimination
  Directize(Bool)
  OptimizeCasts
  DeNaN
  RemoveUnused
}

pub struct OptimizeOptions {
  optimize_level : Int
  shrink_level : Int
  inlining : InliningOptions
  monomorphize_min_benefit : Int
  low_memory_unused : Bool
  low_memory_bound : UInt64
}
pub fn OptimizeOptions::new(optimize_level? : Int, shrink_level? : Int, inlining? : InliningOptions, monomorphize_min_benefit? : Int, low_memory_unused? : Bool, low_memory_bound? : UInt64) -> Self

type ParamInfo
pub impl Eq for ParamInfo
pub impl Hash for ParamInfo
pub impl Show for ParamInfo

type Remappings

pub struct SquareMatrix[T] {
  storage : Map[UInt64, T]
  n : UInt
}
pub fn[T] SquareMatrix::get_or(Self[T], T, UInt, UInt) -> Result[T, String]
pub fn[T : Default] SquareMatrix::get_or_default(Self[T], UInt, UInt) -> Result[T, String]
pub fn[T] SquareMatrix::new(size? : UInt) -> Self[T]

type Tail
pub impl Eq for Tail

type UsedIndices

// Type aliases

// Traits

