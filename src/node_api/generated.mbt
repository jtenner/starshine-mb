pub fn __js_bytes_from_array(value : Array[Byte]) -> Bytes {
  Bytes::from_array(value)
}

pub fn __js_bytes_length(value : Bytes) -> Int {
  value.length()
}

pub fn __js_bytes_get(value : Bytes, index : Int) -> Byte {
  value[index]
}

pub fn __js_array_1_new() -> Array[String] {
  Array::new()
}

pub fn __js_array_1_push(value : Array[String], item : String) -> Unit {
  value.push(item)
}

pub fn __js_array_1_length(value : Array[String]) -> Int {
  value.length()
}

pub fn __js_array_1_get(value : Array[String], index : Int) -> String {
  value[index]
}

pub fn __js_array_2_new() -> Array[@cli.CliOutputTarget] {
  Array::new()
}

pub fn __js_array_2_push(value : Array[@cli.CliOutputTarget], item : @cli.CliOutputTarget) -> Unit {
  value.push(item)
}

pub fn __js_array_2_length(value : Array[@cli.CliOutputTarget]) -> Int {
  value.length()
}

pub fn __js_array_2_get(value : Array[@cli.CliOutputTarget], index : Int) -> @cli.CliOutputTarget {
  value[index]
}

pub fn __js_array_3_new() -> Array[@cli.CliOptimizationFlag] {
  Array::new()
}

pub fn __js_array_3_push(value : Array[@cli.CliOptimizationFlag], item : @cli.CliOptimizationFlag) -> Unit {
  value.push(item)
}

pub fn __js_array_3_length(value : Array[@cli.CliOptimizationFlag]) -> Int {
  value.length()
}

pub fn __js_array_3_get(value : Array[@cli.CliOptimizationFlag], index : Int) -> @cli.CliOptimizationFlag {
  value[index]
}

pub fn __js_array_4_new() -> Array[(String, String)] {
  Array::new()
}

pub fn __js_array_4_push(value : Array[(String, String)], item : (String, String)) -> Unit {
  value.push(item)
}

pub fn __js_array_4_length(value : Array[(String, String)]) -> Int {
  value.length()
}

pub fn __js_array_4_get(value : Array[(String, String)], index : Int) -> (String, String) {
  value[index]
}

pub fn __js_array_5_new() -> Array[@ir.BlockId] {
  Array::new()
}

pub fn __js_array_5_push(value : Array[@ir.BlockId], item : @ir.BlockId) -> Unit {
  value.push(item)
}

pub fn __js_array_5_length(value : Array[@ir.BlockId]) -> Int {
  value.length()
}

pub fn __js_array_5_get(value : Array[@ir.BlockId], index : Int) -> @ir.BlockId {
  value[index]
}

pub fn __js_array_6_new() -> Array[@lib.ValType] {
  Array::new()
}

pub fn __js_array_6_push(value : Array[@lib.ValType], item : @lib.ValType) -> Unit {
  value.push(item)
}

pub fn __js_array_6_length(value : Array[@lib.ValType]) -> Int {
  value.length()
}

pub fn __js_array_6_get(value : Array[@lib.ValType], index : Int) -> @lib.ValType {
  value[index]
}

pub fn __js_array_7_new() -> Array[@lib.TInstr] {
  Array::new()
}

pub fn __js_array_7_push(value : Array[@lib.TInstr], item : @lib.TInstr) -> Unit {
  value.push(item)
}

pub fn __js_array_7_length(value : Array[@lib.TInstr]) -> Int {
  value.length()
}

pub fn __js_array_7_get(value : Array[@lib.TInstr], index : Int) -> @lib.TInstr {
  value[index]
}

pub fn __js_array_8_new() -> Array[@ir.SSAUse] {
  Array::new()
}

pub fn __js_array_8_push(value : Array[@ir.SSAUse], item : @ir.SSAUse) -> Unit {
  value.push(item)
}

pub fn __js_array_8_length(value : Array[@ir.SSAUse]) -> Int {
  value.length()
}

pub fn __js_array_8_get(value : Array[@ir.SSAUse], index : Int) -> @ir.SSAUse {
  value[index]
}

pub fn __js_array_9_new() -> Array[@lib.Locals] {
  Array::new()
}

pub fn __js_array_9_push(value : Array[@lib.Locals], item : @lib.Locals) -> Unit {
  value.push(item)
}

pub fn __js_array_9_length(value : Array[@lib.Locals]) -> Int {
  value.length()
}

pub fn __js_array_9_get(value : Array[@lib.Locals], index : Int) -> @lib.Locals {
  value[index]
}

pub fn __js_array_10_new() -> Array[@lib.FieldType] {
  Array::new()
}

pub fn __js_array_10_push(value : Array[@lib.FieldType], item : @lib.FieldType) -> Unit {
  value.push(item)
}

pub fn __js_array_10_length(value : Array[@lib.FieldType]) -> Int {
  value.length()
}

pub fn __js_array_10_get(value : Array[@lib.FieldType], index : Int) -> @lib.FieldType {
  value[index]
}

pub fn __js_array_11_new() -> Array[@lib.SubType] {
  Array::new()
}

pub fn __js_array_11_push(value : Array[@lib.SubType], item : @lib.SubType) -> Unit {
  value.push(item)
}

pub fn __js_array_11_length(value : Array[@lib.SubType]) -> Int {
  value.length()
}

pub fn __js_array_11_get(value : Array[@lib.SubType], index : Int) -> @lib.SubType {
  value[index]
}

pub fn __js_array_12_new() -> Array[@lib.TypeIdx] {
  Array::new()
}

pub fn __js_array_12_push(value : Array[@lib.TypeIdx], item : @lib.TypeIdx) -> Unit {
  value.push(item)
}

pub fn __js_array_12_length(value : Array[@lib.TypeIdx]) -> Int {
  value.length()
}

pub fn __js_array_12_get(value : Array[@lib.TypeIdx], index : Int) -> @lib.TypeIdx {
  value[index]
}

pub fn __js_array_13_new() -> Array[@lib.Func] {
  Array::new()
}

pub fn __js_array_13_push(value : Array[@lib.Func], item : @lib.Func) -> Unit {
  value.push(item)
}

pub fn __js_array_13_length(value : Array[@lib.Func]) -> Int {
  value.length()
}

pub fn __js_array_13_get(value : Array[@lib.Func], index : Int) -> @lib.Func {
  value[index]
}

pub fn __js_array_14_new() -> Array[@lib.Data] {
  Array::new()
}

pub fn __js_array_14_push(value : Array[@lib.Data], item : @lib.Data) -> Unit {
  value.push(item)
}

pub fn __js_array_14_length(value : Array[@lib.Data]) -> Int {
  value.length()
}

pub fn __js_array_14_get(value : Array[@lib.Data], index : Int) -> @lib.Data {
  value[index]
}

pub fn __js_array_15_new() -> Array[@lib.Expr] {
  Array::new()
}

pub fn __js_array_15_push(value : Array[@lib.Expr], item : @lib.Expr) -> Unit {
  value.push(item)
}

pub fn __js_array_15_length(value : Array[@lib.Expr]) -> Int {
  value.length()
}

pub fn __js_array_15_get(value : Array[@lib.Expr], index : Int) -> @lib.Expr {
  value[index]
}

pub fn __js_array_16_new() -> Array[@lib.FuncIdx] {
  Array::new()
}

pub fn __js_array_16_push(value : Array[@lib.FuncIdx], item : @lib.FuncIdx) -> Unit {
  value.push(item)
}

pub fn __js_array_16_length(value : Array[@lib.FuncIdx]) -> Int {
  value.length()
}

pub fn __js_array_16_get(value : Array[@lib.FuncIdx], index : Int) -> @lib.FuncIdx {
  value[index]
}

pub fn __js_array_17_new() -> Array[@lib.Elem] {
  Array::new()
}

pub fn __js_array_17_push(value : Array[@lib.Elem], item : @lib.Elem) -> Unit {
  value.push(item)
}

pub fn __js_array_17_length(value : Array[@lib.Elem]) -> Int {
  value.length()
}

pub fn __js_array_17_get(value : Array[@lib.Elem], index : Int) -> @lib.Elem {
  value[index]
}

pub fn __js_array_18_new() -> Array[@lib.Export] {
  Array::new()
}

pub fn __js_array_18_push(value : Array[@lib.Export], item : @lib.Export) -> Unit {
  value.push(item)
}

pub fn __js_array_18_length(value : Array[@lib.Export]) -> Int {
  value.length()
}

pub fn __js_array_18_get(value : Array[@lib.Export], index : Int) -> @lib.Export {
  value[index]
}

pub fn __js_array_19_new() -> Array[@lib.Instruction] {
  Array::new()
}

pub fn __js_array_19_push(value : Array[@lib.Instruction], item : @lib.Instruction) -> Unit {
  value.push(item)
}

pub fn __js_array_19_length(value : Array[@lib.Instruction]) -> Int {
  value.length()
}

pub fn __js_array_19_get(value : Array[@lib.Instruction], index : Int) -> @lib.Instruction {
  value[index]
}

pub fn __js_array_20_new() -> Array[@lib.Global] {
  Array::new()
}

pub fn __js_array_20_push(value : Array[@lib.Global], item : @lib.Global) -> Unit {
  value.push(item)
}

pub fn __js_array_20_length(value : Array[@lib.Global]) -> Int {
  value.length()
}

pub fn __js_array_20_get(value : Array[@lib.Global], index : Int) -> @lib.Global {
  value[index]
}

pub fn __js_array_21_new() -> Array[@lib.Import] {
  Array::new()
}

pub fn __js_array_21_push(value : Array[@lib.Import], item : @lib.Import) -> Unit {
  value.push(item)
}

pub fn __js_array_21_length(value : Array[@lib.Import]) -> Int {
  value.length()
}

pub fn __js_array_21_get(value : Array[@lib.Import], index : Int) -> @lib.Import {
  value[index]
}

pub fn __js_array_22_new() -> Array[@lib.LabelIdx] {
  Array::new()
}

pub fn __js_array_22_push(value : Array[@lib.LabelIdx], item : @lib.LabelIdx) -> Unit {
  value.push(item)
}

pub fn __js_array_22_length(value : Array[@lib.LabelIdx]) -> Int {
  value.length()
}

pub fn __js_array_22_get(value : Array[@lib.LabelIdx], index : Int) -> @lib.LabelIdx {
  value[index]
}

pub fn __js_array_23_new() -> Array[@lib.Catch] {
  Array::new()
}

pub fn __js_array_23_push(value : Array[@lib.Catch], item : @lib.Catch) -> Unit {
  value.push(item)
}

pub fn __js_array_23_length(value : Array[@lib.Catch]) -> Int {
  value.length()
}

pub fn __js_array_23_get(value : Array[@lib.Catch], index : Int) -> @lib.Catch {
  value[index]
}

pub fn __js_array_24_new() -> Array[@lib.MemType] {
  Array::new()
}

pub fn __js_array_24_push(value : Array[@lib.MemType], item : @lib.MemType) -> Unit {
  value.push(item)
}

pub fn __js_array_24_length(value : Array[@lib.MemType]) -> Int {
  value.length()
}

pub fn __js_array_24_get(value : Array[@lib.MemType], index : Int) -> @lib.MemType {
  value[index]
}

pub fn __js_array_25_new() -> Array[@lib.CustomSec] {
  Array::new()
}

pub fn __js_array_25_push(value : Array[@lib.CustomSec], item : @lib.CustomSec) -> Unit {
  value.push(item)
}

pub fn __js_array_25_length(value : Array[@lib.CustomSec]) -> Int {
  value.length()
}

pub fn __js_array_25_get(value : Array[@lib.CustomSec], index : Int) -> @lib.CustomSec {
  value[index]
}

pub fn __js_array_26_new() -> Array[@lib.Table] {
  Array::new()
}

pub fn __js_array_26_push(value : Array[@lib.Table], item : @lib.Table) -> Unit {
  value.push(item)
}

pub fn __js_array_26_length(value : Array[@lib.Table]) -> Int {
  value.length()
}

pub fn __js_array_26_get(value : Array[@lib.Table], index : Int) -> @lib.Table {
  value[index]
}

pub fn __js_array_27_new() -> Array[@lib.TagType] {
  Array::new()
}

pub fn __js_array_27_push(value : Array[@lib.TagType], item : @lib.TagType) -> Unit {
  value.push(item)
}

pub fn __js_array_27_length(value : Array[@lib.TagType]) -> Int {
  value.length()
}

pub fn __js_array_27_get(value : Array[@lib.TagType], index : Int) -> @lib.TagType {
  value[index]
}

pub fn __js_array_28_new() -> Array[@lib.RecType] {
  Array::new()
}

pub fn __js_array_28_push(value : Array[@lib.RecType], item : @lib.RecType) -> Unit {
  value.push(item)
}

pub fn __js_array_28_length(value : Array[@lib.RecType]) -> Int {
  value.length()
}

pub fn __js_array_28_get(value : Array[@lib.RecType], index : Int) -> @lib.RecType {
  value[index]
}

pub fn __js_array_29_new() -> Array[@passes.ModulePass] {
  Array::new()
}

pub fn __js_array_29_push(value : Array[@passes.ModulePass], item : @passes.ModulePass) -> Unit {
  value.push(item)
}

pub fn __js_array_29_length(value : Array[@passes.ModulePass]) -> Int {
  value.length()
}

pub fn __js_array_29_get(value : Array[@passes.ModulePass], index : Int) -> @passes.ModulePass {
  value[index]
}

pub fn __js_array_30_new() -> Array[@lib.FuncType] {
  Array::new()
}

pub fn __js_array_30_push(value : Array[@lib.FuncType], item : @lib.FuncType) -> Unit {
  value.push(item)
}

pub fn __js_array_30_length(value : Array[@lib.FuncType]) -> Int {
  value.length()
}

pub fn __js_array_30_get(value : Array[@lib.FuncType], index : Int) -> @lib.FuncType {
  value[index]
}

pub fn __js_array_31_new() -> Array[@lib.GlobalType] {
  Array::new()
}

pub fn __js_array_31_push(value : Array[@lib.GlobalType], item : @lib.GlobalType) -> Unit {
  value.push(item)
}

pub fn __js_array_31_length(value : Array[@lib.GlobalType]) -> Int {
  value.length()
}

pub fn __js_array_31_get(value : Array[@lib.GlobalType], index : Int) -> @lib.GlobalType {
  value[index]
}

pub fn __js_array_32_new() -> Array[Array[@lib.ValType]] {
  Array::new()
}

pub fn __js_array_32_push(value : Array[Array[@lib.ValType]], item : Array[@lib.ValType]) -> Unit {
  value.push(item)
}

pub fn __js_array_32_length(value : Array[Array[@lib.ValType]]) -> Int {
  value.length()
}

pub fn __js_array_32_get(value : Array[Array[@lib.ValType]], index : Int) -> Array[@lib.ValType] {
  value[index]
}

pub fn __js_array_33_new() -> Array[@lib.TableType] {
  Array::new()
}

pub fn __js_array_33_push(value : Array[@lib.TableType], item : @lib.TableType) -> Unit {
  value.push(item)
}

pub fn __js_array_33_length(value : Array[@lib.TableType]) -> Int {
  value.length()
}

pub fn __js_array_33_get(value : Array[@lib.TableType], index : Int) -> @lib.TableType {
  value[index]
}

pub fn __js_array_34_new() -> Array[@wast.LexerError] {
  Array::new()
}

pub fn __js_array_34_push(value : Array[@wast.LexerError], item : @wast.LexerError) -> Unit {
  value.push(item)
}

pub fn __js_array_34_length(value : Array[@wast.LexerError]) -> Int {
  value.length()
}

pub fn __js_array_34_get(value : Array[@wast.LexerError], index : Int) -> @wast.LexerError {
  value[index]
}

pub fn __js_array_35_new() -> Array[@wast.ParseError] {
  Array::new()
}

pub fn __js_array_35_push(value : Array[@wast.ParseError], item : @wast.ParseError) -> Unit {
  value.push(item)
}

pub fn __js_array_35_length(value : Array[@wast.ParseError]) -> Int {
  value.length()
}

pub fn __js_array_35_get(value : Array[@wast.ParseError], index : Int) -> @wast.ParseError {
  value[index]
}

pub fn __js_array_36_new() -> Array[Byte] {
  Array::new()
}

pub fn __js_array_36_push(value : Array[Byte], item : Byte) -> Unit {
  value.push(item)
}

pub fn __js_array_36_length(value : Array[Byte]) -> Int {
  value.length()
}

pub fn __js_array_36_get(value : Array[Byte], index : Int) -> Byte {
  value[index]
}

pub fn __js_option_1_none() -> @cli.CliInputFormat? {
  None
}

pub fn __js_option_1_some(value : @cli.CliInputFormat) -> @cli.CliInputFormat? {
  Some(value)
}

pub fn __js_option_1_is_some(value : @cli.CliInputFormat?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_1_unwrap(value : @cli.CliInputFormat?) -> @cli.CliInputFormat {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_2_none() -> String? {
  None
}

pub fn __js_option_2_some(value : String) -> String? {
  Some(value)
}

pub fn __js_option_2_is_some(value : String?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_2_unwrap(value : String?) -> String {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_3_none() -> @cli.TrapMode? {
  None
}

pub fn __js_option_3_some(value : @cli.TrapMode) -> @cli.TrapMode? {
  Some(value)
}

pub fn __js_option_3_is_some(value : @cli.TrapMode?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_3_unwrap(value : @cli.TrapMode?) -> @cli.TrapMode {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_4_none() -> Int? {
  None
}

pub fn __js_option_4_some(value : Int) -> Int? {
  Some(value)
}

pub fn __js_option_4_is_some(value : Int?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_4_unwrap(value : Int?) -> Int {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_5_none() -> Bool? {
  None
}

pub fn __js_option_5_some(value : Bool) -> Bool? {
  Some(value)
}

pub fn __js_option_5_is_some(value : Bool?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_5_unwrap(value : Bool?) -> Bool {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_6_none() -> UInt64? {
  None
}

pub fn __js_option_6_some(value : UInt64) -> UInt64? {
  Some(value)
}

pub fn __js_option_6_is_some(value : UInt64?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_6_unwrap(value : UInt64?) -> UInt64 {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_7_none() -> Bytes? {
  None
}

pub fn __js_option_7_some(value : Bytes) -> Bytes? {
  Some(value)
}

pub fn __js_option_7_is_some(value : Bytes?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_7_unwrap(value : Bytes?) -> Bytes {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_8_none() -> @ir.BasicBlock? {
  None
}

pub fn __js_option_8_some(value : @ir.BasicBlock) -> @ir.BasicBlock? {
  Some(value)
}

pub fn __js_option_8_is_some(value : @ir.BasicBlock?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_8_unwrap(value : @ir.BasicBlock?) -> @ir.BasicBlock {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_9_none() -> @lib.Module? {
  None
}

pub fn __js_option_9_some(value : @lib.Module) -> @lib.Module? {
  Some(value)
}

pub fn __js_option_9_is_some(value : @lib.Module?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_9_unwrap(value : @lib.Module?) -> @lib.Module {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_10_none() -> @ir.SSATypeInfo? {
  None
}

pub fn __js_option_10_some(value : @ir.SSATypeInfo) -> @ir.SSATypeInfo? {
  Some(value)
}

pub fn __js_option_10_is_some(value : @ir.SSATypeInfo?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_10_unwrap(value : @ir.SSATypeInfo?) -> @ir.SSATypeInfo {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_11_none() -> @lib.TExpr? {
  None
}

pub fn __js_option_11_some(value : @lib.TExpr) -> @lib.TExpr? {
  Some(value)
}

pub fn __js_option_11_is_some(value : @lib.TExpr?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_11_unwrap(value : @lib.TExpr?) -> @lib.TExpr {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_12_none() -> @lib.ValType? {
  None
}

pub fn __js_option_12_some(value : @lib.ValType) -> @lib.ValType? {
  Some(value)
}

pub fn __js_option_12_is_some(value : @lib.ValType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_12_unwrap(value : @lib.ValType?) -> @lib.ValType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_13_none() -> (@ir.BlockId, @ir.SSADef)? {
  None
}

pub fn __js_option_13_some(value : (@ir.BlockId, @ir.SSADef)) -> (@ir.BlockId, @ir.SSADef)? {
  Some(value)
}

pub fn __js_option_13_is_some(value : (@ir.BlockId, @ir.SSADef)?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_13_unwrap(value : (@ir.BlockId, @ir.SSADef)?) -> (@ir.BlockId, @ir.SSADef) {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_14_none() -> @lib.SubType? {
  None
}

pub fn __js_option_14_some(value : @lib.SubType) -> @lib.SubType? {
  Some(value)
}

pub fn __js_option_14_is_some(value : @lib.SubType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_14_unwrap(value : @lib.SubType?) -> @lib.SubType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_15_none() -> Array[@lib.Instruction]? {
  None
}

pub fn __js_option_15_some(value : Array[@lib.Instruction]) -> Array[@lib.Instruction]? {
  Some(value)
}

pub fn __js_option_15_is_some(value : Array[@lib.Instruction]?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_15_unwrap(value : Array[@lib.Instruction]?) -> Array[@lib.Instruction] {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_16_none() -> Array[@lib.ValType]? {
  None
}

pub fn __js_option_16_some(value : Array[@lib.ValType]) -> Array[@lib.ValType]? {
  Some(value)
}

pub fn __js_option_16_is_some(value : Array[@lib.ValType]?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_16_unwrap(value : Array[@lib.ValType]?) -> Array[@lib.ValType] {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_17_none() -> @lib.MemIdx? {
  None
}

pub fn __js_option_17_some(value : @lib.MemIdx) -> @lib.MemIdx? {
  Some(value)
}

pub fn __js_option_17_is_some(value : @lib.MemIdx?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_17_unwrap(value : @lib.MemIdx?) -> @lib.MemIdx {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_18_none() -> @lib.TypeSec? {
  None
}

pub fn __js_option_18_some(value : @lib.TypeSec) -> @lib.TypeSec? {
  Some(value)
}

pub fn __js_option_18_is_some(value : @lib.TypeSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_18_unwrap(value : @lib.TypeSec?) -> @lib.TypeSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_19_none() -> @lib.ImportSec? {
  None
}

pub fn __js_option_19_some(value : @lib.ImportSec) -> @lib.ImportSec? {
  Some(value)
}

pub fn __js_option_19_is_some(value : @lib.ImportSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_19_unwrap(value : @lib.ImportSec?) -> @lib.ImportSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_20_none() -> @lib.FuncSec? {
  None
}

pub fn __js_option_20_some(value : @lib.FuncSec) -> @lib.FuncSec? {
  Some(value)
}

pub fn __js_option_20_is_some(value : @lib.FuncSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_20_unwrap(value : @lib.FuncSec?) -> @lib.FuncSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_21_none() -> @lib.TableSec? {
  None
}

pub fn __js_option_21_some(value : @lib.TableSec) -> @lib.TableSec? {
  Some(value)
}

pub fn __js_option_21_is_some(value : @lib.TableSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_21_unwrap(value : @lib.TableSec?) -> @lib.TableSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_22_none() -> @lib.MemSec? {
  None
}

pub fn __js_option_22_some(value : @lib.MemSec) -> @lib.MemSec? {
  Some(value)
}

pub fn __js_option_22_is_some(value : @lib.MemSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_22_unwrap(value : @lib.MemSec?) -> @lib.MemSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_23_none() -> @lib.TagSec? {
  None
}

pub fn __js_option_23_some(value : @lib.TagSec) -> @lib.TagSec? {
  Some(value)
}

pub fn __js_option_23_is_some(value : @lib.TagSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_23_unwrap(value : @lib.TagSec?) -> @lib.TagSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_24_none() -> @lib.GlobalSec? {
  None
}

pub fn __js_option_24_some(value : @lib.GlobalSec) -> @lib.GlobalSec? {
  Some(value)
}

pub fn __js_option_24_is_some(value : @lib.GlobalSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_24_unwrap(value : @lib.GlobalSec?) -> @lib.GlobalSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_25_none() -> @lib.ExportSec? {
  None
}

pub fn __js_option_25_some(value : @lib.ExportSec) -> @lib.ExportSec? {
  Some(value)
}

pub fn __js_option_25_is_some(value : @lib.ExportSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_25_unwrap(value : @lib.ExportSec?) -> @lib.ExportSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_26_none() -> @lib.StartSec? {
  None
}

pub fn __js_option_26_some(value : @lib.StartSec) -> @lib.StartSec? {
  Some(value)
}

pub fn __js_option_26_is_some(value : @lib.StartSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_26_unwrap(value : @lib.StartSec?) -> @lib.StartSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_27_none() -> @lib.ElemSec? {
  None
}

pub fn __js_option_27_some(value : @lib.ElemSec) -> @lib.ElemSec? {
  Some(value)
}

pub fn __js_option_27_is_some(value : @lib.ElemSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_27_unwrap(value : @lib.ElemSec?) -> @lib.ElemSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_28_none() -> @lib.DataCntSec? {
  None
}

pub fn __js_option_28_some(value : @lib.DataCntSec) -> @lib.DataCntSec? {
  Some(value)
}

pub fn __js_option_28_is_some(value : @lib.DataCntSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_28_unwrap(value : @lib.DataCntSec?) -> @lib.DataCntSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_29_none() -> @lib.CodeSec? {
  None
}

pub fn __js_option_29_some(value : @lib.CodeSec) -> @lib.CodeSec? {
  Some(value)
}

pub fn __js_option_29_is_some(value : @lib.CodeSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_29_unwrap(value : @lib.CodeSec?) -> @lib.CodeSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_30_none() -> @lib.DataSec? {
  None
}

pub fn __js_option_30_some(value : @lib.DataSec) -> @lib.DataSec? {
  Some(value)
}

pub fn __js_option_30_is_some(value : @lib.DataSec?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_30_unwrap(value : @lib.DataSec?) -> @lib.DataSec {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_31_none() -> @lib.Expr? {
  None
}

pub fn __js_option_31_some(value : @lib.Expr) -> @lib.Expr? {
  Some(value)
}

pub fn __js_option_31_is_some(value : @lib.Expr?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_31_unwrap(value : @lib.Expr?) -> @lib.Expr {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_32_none() -> @lib.Elem? {
  None
}

pub fn __js_option_32_some(value : @lib.Elem) -> @lib.Elem? {
  Some(value)
}

pub fn __js_option_32_is_some(value : @lib.Elem?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_32_unwrap(value : @lib.Elem?) -> @lib.Elem {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_33_none() -> @lib.FuncType? {
  None
}

pub fn __js_option_33_some(value : @lib.FuncType) -> @lib.FuncType? {
  Some(value)
}

pub fn __js_option_33_is_some(value : @lib.FuncType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_33_unwrap(value : @lib.FuncType?) -> @lib.FuncType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_34_none() -> @lib.TypeIdx? {
  None
}

pub fn __js_option_34_some(value : @lib.TypeIdx) -> @lib.TypeIdx? {
  Some(value)
}

pub fn __js_option_34_is_some(value : @lib.TypeIdx?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_34_unwrap(value : @lib.TypeIdx?) -> @lib.TypeIdx {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_35_none() -> @lib.GlobalType? {
  None
}

pub fn __js_option_35_some(value : @lib.GlobalType) -> @lib.GlobalType? {
  Some(value)
}

pub fn __js_option_35_is_some(value : @lib.GlobalType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_35_unwrap(value : @lib.GlobalType?) -> @lib.GlobalType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_36_none() -> @lib.MemType? {
  None
}

pub fn __js_option_36_some(value : @lib.MemType) -> @lib.MemType? {
  Some(value)
}

pub fn __js_option_36_is_some(value : @lib.MemType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_36_unwrap(value : @lib.MemType?) -> @lib.MemType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_37_none() -> @lib.TableType? {
  None
}

pub fn __js_option_37_some(value : @lib.TableType) -> @lib.TableType? {
  Some(value)
}

pub fn __js_option_37_is_some(value : @lib.TableType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_37_unwrap(value : @lib.TableType?) -> @lib.TableType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_38_none() -> @lib.TagType? {
  None
}

pub fn __js_option_38_some(value : @lib.TagType) -> @lib.TagType? {
  Some(value)
}

pub fn __js_option_38_is_some(value : @lib.TagType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_38_unwrap(value : @lib.TagType?) -> @lib.TagType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_39_none() -> @lib.CompType? {
  None
}

pub fn __js_option_39_some(value : @lib.CompType) -> @lib.CompType? {
  Some(value)
}

pub fn __js_option_39_is_some(value : @lib.CompType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_39_unwrap(value : @lib.CompType?) -> @lib.CompType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_option_40_none() -> @wast.TokenType? {
  None
}

pub fn __js_option_40_some(value : @wast.TokenType) -> @wast.TokenType? {
  Some(value)
}

pub fn __js_option_40_is_some(value : @wast.TokenType?) -> Bool {
  match value {
    Some(_) => true
    None => false
  }
}

pub fn __js_option_40_unwrap(value : @wast.TokenType?) -> @wast.TokenType {
  match value {
    Some(inner) => inner
    None => abort("Attempted to unwrap None inside the Node adapter.")
  }
}

pub fn __js_result_1_is_ok(value : Result[@lib.Module, @binary.DecodeError]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_1_unwrap_ok(value : Result[@lib.Module, @binary.DecodeError]) -> @lib.Module {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_1_unwrap_err(value : Result[@lib.Module, @binary.DecodeError]) -> @binary.DecodeError {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_2_is_ok(value : Result[(@lib.Module, Int), @binary.ModuleDecodeErrorDetail]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_2_unwrap_ok(value : Result[(@lib.Module, Int), @binary.ModuleDecodeErrorDetail]) -> (@lib.Module, Int) {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_2_unwrap_err(value : Result[(@lib.Module, Int), @binary.ModuleDecodeErrorDetail]) -> @binary.ModuleDecodeErrorDetail {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_3_is_ok(value : Result[Bytes, @binary.EncodeError]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_3_unwrap_ok(value : Result[Bytes, @binary.EncodeError]) -> Bytes {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_3_unwrap_err(value : Result[Bytes, @binary.EncodeError]) -> @binary.EncodeError {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_4_is_ok(value : Result[Int, @binary.BinaryEncodeError]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_4_unwrap_ok(value : Result[Int, @binary.BinaryEncodeError]) -> Int {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_4_unwrap_err(value : Result[Int, @binary.BinaryEncodeError]) -> @binary.BinaryEncodeError {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_5_is_ok(value : Result[@cli.CliParseResult, @cli.CliParseError]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_5_unwrap_ok(value : Result[@cli.CliParseResult, @cli.CliParseError]) -> @cli.CliParseResult {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_5_unwrap_err(value : Result[@cli.CliParseResult, @cli.CliParseError]) -> @cli.CliParseError {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_6_is_ok(value : Result[@cmd.DifferentialValidationReport, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_6_unwrap_ok(value : Result[@cmd.DifferentialValidationReport, String]) -> @cmd.DifferentialValidationReport {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_6_unwrap_err(value : Result[@cmd.DifferentialValidationReport, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_7_is_ok(value : Result[(String, String?), String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_7_unwrap_ok(value : Result[(String, String?), String]) -> (String, String?) {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_7_unwrap_err(value : Result[(String, String?), String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_8_is_ok(value : Result[@cmd.CmdRunSummary, @cmd.CmdError]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_8_unwrap_ok(value : Result[@cmd.CmdRunSummary, @cmd.CmdError]) -> @cmd.CmdRunSummary {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_8_unwrap_err(value : Result[@cmd.CmdRunSummary, @cmd.CmdError]) -> @cmd.CmdError {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_9_is_ok(value : Result[Unit, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_9_unwrap_ok(value : Result[Unit, String]) -> Unit {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_9_unwrap_err(value : Result[Unit, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_10_is_ok(value : Result[@ir.TypeContext, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_10_unwrap_ok(value : Result[@ir.TypeContext, String]) -> @ir.TypeContext {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_10_unwrap_err(value : Result[@ir.TypeContext, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_11_is_ok(value : Result[Array[@lib.ValType], String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_11_unwrap_ok(value : Result[Array[@lib.ValType], String]) -> Array[@lib.ValType] {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_11_unwrap_err(value : Result[Array[@lib.ValType], String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_12_is_ok(value : Result[@lib.FieldType, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_12_unwrap_ok(value : Result[@lib.FieldType, String]) -> @lib.FieldType {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_12_unwrap_err(value : Result[@lib.FieldType, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_13_is_ok(value : Result[@lib.Module, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_13_unwrap_ok(value : Result[@lib.Module, String]) -> @lib.Module {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_13_unwrap_err(value : Result[@lib.Module, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_14_is_ok(value : Result[@lib.RefType, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_14_unwrap_ok(value : Result[@lib.RefType, String]) -> @lib.RefType {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_14_unwrap_err(value : Result[@lib.RefType, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_15_is_ok(value : Result[@lib.TExpr, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_15_unwrap_ok(value : Result[@lib.TExpr, String]) -> @lib.TExpr {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_15_unwrap_err(value : Result[@lib.TExpr, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_16_is_ok(value : Result[@validate.Env, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_16_unwrap_ok(value : Result[@validate.Env, String]) -> @validate.Env {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_16_unwrap_err(value : Result[@validate.Env, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_17_is_ok(value : Result[Unit, @validate.ValidationError]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_17_unwrap_ok(value : Result[Unit, @validate.ValidationError]) -> Unit {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_17_unwrap_err(value : Result[Unit, @validate.ValidationError]) -> @validate.ValidationError {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_18_is_ok(value : Result[(Array[@lib.ValType], Array[@lib.ValType]), String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_18_unwrap_ok(value : Result[(Array[@lib.ValType], Array[@lib.ValType]), String]) -> (Array[@lib.ValType], Array[@lib.ValType]) {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_18_unwrap_err(value : Result[(Array[@lib.ValType], Array[@lib.ValType]), String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_19_is_ok(value : Result[Array[@lib.FieldType], String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_19_unwrap_ok(value : Result[Array[@lib.FieldType], String]) -> Array[@lib.FieldType] {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_19_unwrap_err(value : Result[Array[@lib.FieldType], String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_20_is_ok(value : Result[String, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_20_unwrap_ok(value : Result[String, String]) -> String {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_20_unwrap_err(value : Result[String, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_21_is_ok(value : Result[(String, @lib.Module), String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_21_unwrap_ok(value : Result[(String, @lib.Module), String]) -> (String, @lib.Module) {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_21_unwrap_err(value : Result[(String, @lib.Module), String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_22_is_ok(value : Result[@wast.Module, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_22_unwrap_ok(value : Result[@wast.Module, String]) -> @wast.Module {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_22_unwrap_err(value : Result[@wast.Module, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_result_23_is_ok(value : Result[@wast.WastScript, String]) -> Bool {
  match value {
    Ok(_) => true
    Err(_) => false
  }
}

pub fn __js_result_23_unwrap_ok(value : Result[@wast.WastScript, String]) -> @wast.WastScript {
  match value {
    Ok(inner) => inner
    Err(_) => abort("Attempted to unwrap Err as Ok inside the Node adapter.")
  }
}

pub fn __js_result_23_unwrap_err(value : Result[@wast.WastScript, String]) -> String {
  match value {
    Ok(_) => abort("Attempted to unwrap Ok as Err inside the Node adapter.")
    Err(inner) => inner
  }
}

pub fn __js_tuple_1_new(arg0 : @lib.Module, arg1 : Int) -> (@lib.Module, Int) {
  (arg0, arg1)
}

pub fn __js_tuple_1_get_0(value : (@lib.Module, Int)) -> @lib.Module {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_1_get_1(value : (@lib.Module, Int)) -> Int {
  let (_, item1) = value
  item1
}

pub fn __js_tuple_2_new(arg0 : Bool, arg1 : Bool) -> (Bool, Bool) {
  (arg0, arg1)
}

pub fn __js_tuple_2_get_0(value : (Bool, Bool)) -> Bool {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_2_get_1(value : (Bool, Bool)) -> Bool {
  let (_, item1) = value
  item1
}

pub fn __js_tuple_3_new(arg0 : String, arg1 : String?) -> (String, String?) {
  (arg0, arg1)
}

pub fn __js_tuple_3_get_0(value : (String, String?)) -> String {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_3_get_1(value : (String, String?)) -> String? {
  let (_, item1) = value
  item1
}

pub fn __js_tuple_4_new(arg0 : String, arg1 : String) -> (String, String) {
  (arg0, arg1)
}

pub fn __js_tuple_4_get_0(value : (String, String)) -> String {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_4_get_1(value : (String, String)) -> String {
  let (_, item1) = value
  item1
}

pub fn __js_tuple_5_new(arg0 : @ir.BlockId, arg1 : @ir.SSADef) -> (@ir.BlockId, @ir.SSADef) {
  (arg0, arg1)
}

pub fn __js_tuple_5_get_0(value : (@ir.BlockId, @ir.SSADef)) -> @ir.BlockId {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_5_get_1(value : (@ir.BlockId, @ir.SSADef)) -> @ir.SSADef {
  let (_, item1) = value
  item1
}

pub fn __js_tuple_6_new(arg0 : Array[@lib.ValType], arg1 : Array[@lib.ValType]) -> (Array[@lib.ValType], Array[@lib.ValType]) {
  (arg0, arg1)
}

pub fn __js_tuple_6_get_0(value : (Array[@lib.ValType], Array[@lib.ValType])) -> Array[@lib.ValType] {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_6_get_1(value : (Array[@lib.ValType], Array[@lib.ValType])) -> Array[@lib.ValType] {
  let (_, item1) = value
  item1
}

pub fn __js_tuple_7_new(arg0 : String, arg1 : @lib.Module) -> (String, @lib.Module) {
  (arg0, arg1)
}

pub fn __js_tuple_7_get_0(value : (String, @lib.Module)) -> String {
  let (item0, _) = value
  item0
}

pub fn __js_tuple_7_get_1(value : (String, @lib.Module)) -> @lib.Module {
  let (_, item1) = value
  item1
}

pub fn __js_show_binary_BinaryDecodeError(value : @binary.BinaryDecodeError) -> String {
  value.to_string()
}

pub fn __js_show_binary_BinaryEncodeError(value : @binary.BinaryEncodeError) -> String {
  value.to_string()
}

pub fn __js_show_binary_DecodeError(value : @binary.DecodeError) -> String {
  value.to_string()
}

pub fn __js_show_binary_EncodeError(value : @binary.EncodeError) -> String {
  value.to_string()
}

pub fn __js_show_binary_ModuleDecodeErrorDetail(value : @binary.ModuleDecodeErrorDetail) -> String {
  value.to_string()
}

pub fn __js_show_cli_CliInputFormat(value : @cli.CliInputFormat) -> String {
  value.to_string()
}

pub fn __js_show_cli_CliOptimizationFlag(value : @cli.CliOptimizationFlag) -> String {
  value.to_string()
}

pub fn __js_show_cli_CliOutputTarget(value : @cli.CliOutputTarget) -> String {
  value.to_string()
}

pub fn __js_show_cli_CliParseError(value : @cli.CliParseError) -> String {
  value.to_string()
}

pub fn __js_show_cli_CliParseResult(value : @cli.CliParseResult) -> String {
  value.to_string()
}

pub fn __js_show_cli_TrapMode(value : @cli.TrapMode) -> String {
  value.to_string()
}

pub fn __js_show_cmd_CmdEncodeError(value : @cmd.CmdEncodeError) -> String {
  value.to_string()
}

pub fn __js_show_cmd_CmdError(value : @cmd.CmdError) -> String {
  value.to_string()
}

pub fn __js_show_cmd_CmdRunSummary(value : @cmd.CmdRunSummary) -> String {
  value.to_string()
}

pub fn __js_show_cmd_DifferentialValidationReport(value : @cmd.DifferentialValidationReport) -> String {
  value.to_string()
}

pub fn __js_show_cmd_FuzzFailureReport(value : @cmd.FuzzFailureReport) -> String {
  value.to_string()
}

pub fn __js_show_cmd_ReadmeApiVerifyBlock(value : @cmd.ReadmeApiVerifyBlock) -> String {
  value.to_string()
}

pub fn __js_show_cmd_WasmSmithFuzzStats(value : @cmd.WasmSmithFuzzStats) -> String {
  value.to_string()
}

pub fn __js_show_ir_BasicBlock(value : @ir.BasicBlock) -> String {
  value.to_string()
}

pub fn __js_show_ir_BlockId(value : @ir.BlockId) -> String {
  value.to_string()
}

pub fn __js_show_ir_CFG(value : @ir.CFG) -> String {
  value.to_string()
}

pub fn __js_show_ir_PhiNode(value : @ir.PhiNode) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSABlock(value : @ir.SSABlock) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSACFG(value : @ir.SSACFG) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSAInstr(value : @ir.SSAInstr) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSALiteral(value : @ir.SSALiteral) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSAOp(value : @ir.SSAOp) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSATerminator(value : @ir.SSATerminator) -> String {
  value.to_string()
}

pub fn __js_show_ir_SSAValue(value : @ir.SSAValue) -> String {
  value.to_string()
}

pub fn __js_show_ir_SplatOp(value : @ir.SplatOp) -> String {
  value.to_string()
}

pub fn __js_show_ir_Terminator(value : @ir.Terminator) -> String {
  value.to_string()
}

pub fn __js_show_lib_AbsHeapType(value : @lib.AbsHeapType) -> String {
  value.to_string()
}

pub fn __js_show_lib_AtomicCmpxchgOp(value : @lib.AtomicCmpxchgOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_AtomicRmwOp(value : @lib.AtomicRmwOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_BinaryOp(value : @lib.BinaryOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_BlockType(value : @lib.BlockType) -> String {
  value.to_string()
}

pub fn __js_show_lib_CastOp(value : @lib.CastOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_Catch(value : @lib.Catch) -> String {
  value.to_string()
}

pub fn __js_show_lib_CodeSec(value : @lib.CodeSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_CompType(value : @lib.CompType) -> String {
  value.to_string()
}

pub fn __js_show_lib_CustomSec(value : @lib.CustomSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_Data(value : @lib.Data) -> String {
  value.to_string()
}

pub fn __js_show_lib_DataCntSec(value : @lib.DataCntSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_DataIdx(value : @lib.DataIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_DataMode(value : @lib.DataMode) -> String {
  value.to_string()
}

pub fn __js_show_lib_DataSec(value : @lib.DataSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_DefType(value : @lib.DefType) -> String {
  value.to_string()
}

pub fn __js_show_lib_Elem(value : @lib.Elem) -> String {
  value.to_string()
}

pub fn __js_show_lib_ElemIdx(value : @lib.ElemIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_ElemKind(value : @lib.ElemKind) -> String {
  value.to_string()
}

pub fn __js_show_lib_ElemMode(value : @lib.ElemMode) -> String {
  value.to_string()
}

pub fn __js_show_lib_ElemSec(value : @lib.ElemSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_Export(value : @lib.Export) -> String {
  value.to_string()
}

pub fn __js_show_lib_ExportSec(value : @lib.ExportSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_Expr(value : @lib.Expr) -> String {
  value.to_string()
}

pub fn __js_show_lib_ExternIdx(value : @lib.ExternIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_ExternType(value : @lib.ExternType) -> String {
  value.to_string()
}

pub fn __js_show_lib_ExtractLaneOp(value : @lib.ExtractLaneOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_F32(value : @lib.F32) -> String {
  value.to_string()
}

pub fn __js_show_lib_F64(value : @lib.F64) -> String {
  value.to_string()
}

pub fn __js_show_lib_FieldType(value : @lib.FieldType) -> String {
  value.to_string()
}

pub fn __js_show_lib_Func(value : @lib.Func) -> String {
  value.to_string()
}

pub fn __js_show_lib_FuncIdx(value : @lib.FuncIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_FuncSec(value : @lib.FuncSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_FuncType(value : @lib.FuncType) -> String {
  value.to_string()
}

pub fn __js_show_lib_Global(value : @lib.Global) -> String {
  value.to_string()
}

pub fn __js_show_lib_GlobalIdx(value : @lib.GlobalIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_GlobalSec(value : @lib.GlobalSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_GlobalType(value : @lib.GlobalType) -> String {
  value.to_string()
}

pub fn __js_show_lib_HeapType(value : @lib.HeapType) -> String {
  value.to_string()
}

pub fn __js_show_lib_I32(value : @lib.I32) -> String {
  value.to_string()
}

pub fn __js_show_lib_I64(value : @lib.I64) -> String {
  value.to_string()
}

pub fn __js_show_lib_Import(value : @lib.Import) -> String {
  value.to_string()
}

pub fn __js_show_lib_ImportSec(value : @lib.ImportSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_Instruction(value : @lib.Instruction) -> String {
  value.to_string()
}

pub fn __js_show_lib_LabelIdx(value : @lib.LabelIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_LaneIdx(value : @lib.LaneIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_Limits(value : @lib.Limits) -> String {
  value.to_string()
}

pub fn __js_show_lib_LoadOp(value : @lib.LoadOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_LocalIdx(value : @lib.LocalIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_Locals(value : @lib.Locals) -> String {
  value.to_string()
}

pub fn __js_show_lib_MemArg(value : @lib.MemArg) -> String {
  value.to_string()
}

pub fn __js_show_lib_MemIdx(value : @lib.MemIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_MemSec(value : @lib.MemSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_MemType(value : @lib.MemType) -> String {
  value.to_string()
}

pub fn __js_show_lib_Module(value : @lib.Module) -> String {
  value.to_string()
}

pub fn __js_show_lib_Mut(value : @lib.Mut) -> String {
  value.to_string()
}

pub fn __js_show_lib_Name(value : @lib.Name) -> String {
  value.to_string()
}

pub fn __js_show_lib_NumType(value : @lib.NumType) -> String {
  value.to_string()
}

pub fn __js_show_lib_PackType(value : @lib.PackType) -> String {
  value.to_string()
}

pub fn __js_show_lib_PrettyPrintContext(value : @lib.PrettyPrintContext) -> String {
  value.to_string()
}

pub fn __js_show_lib_RecType(value : @lib.RecType) -> String {
  value.to_string()
}

pub fn __js_show_lib_RefType(value : @lib.RefType) -> String {
  value.to_string()
}

pub fn __js_show_lib_ReplaceLaneOp(value : @lib.ReplaceLaneOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_S33(value : @lib.S33) -> String {
  value.to_string()
}

pub fn __js_show_lib_StartSec(value : @lib.StartSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_StorageType(value : @lib.StorageType) -> String {
  value.to_string()
}

pub fn __js_show_lib_StoreOp(value : @lib.StoreOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_SubType(value : @lib.SubType) -> String {
  value.to_string()
}

pub fn __js_show_lib_TExpr(value : @lib.TExpr) -> String {
  value.to_string()
}

pub fn __js_show_lib_TInstr(value : @lib.TInstr) -> String {
  value.to_string()
}

pub fn __js_show_lib_TInstrKind(value : @lib.TInstrKind) -> String {
  value.to_string()
}

pub fn __js_show_lib_Table(value : @lib.Table) -> String {
  value.to_string()
}

pub fn __js_show_lib_TableIdx(value : @lib.TableIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_TableSec(value : @lib.TableSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_TableType(value : @lib.TableType) -> String {
  value.to_string()
}

pub fn __js_show_lib_TabsOrSpaces(value : @lib.TabsOrSpaces) -> String {
  value.to_string()
}

pub fn __js_show_lib_TagIdx(value : @lib.TagIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_TagSec(value : @lib.TagSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_TagType(value : @lib.TagType) -> String {
  value.to_string()
}

pub fn __js_show_lib_TypeIdx(value : @lib.TypeIdx) -> String {
  value.to_string()
}

pub fn __js_show_lib_TypeSec(value : @lib.TypeSec) -> String {
  value.to_string()
}

pub fn __js_show_lib_U32(value : @lib.U32) -> String {
  value.to_string()
}

pub fn __js_show_lib_U64(value : @lib.U64) -> String {
  value.to_string()
}

pub fn __js_show_lib_UnaryOp(value : @lib.UnaryOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_V128LoadLaneOp(value : @lib.V128LoadLaneOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_V128ShiftOp(value : @lib.V128ShiftOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_V128StoreLaneOp(value : @lib.V128StoreLaneOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_V128TernaryOp(value : @lib.V128TernaryOp) -> String {
  value.to_string()
}

pub fn __js_show_lib_ValType(value : @lib.ValType) -> String {
  value.to_string()
}

pub fn __js_show_passes_AbstractTypeRefiningPassProps(value : @passes.AbstractTypeRefiningPassProps) -> String {
  value.to_string()
}

pub fn __js_show_passes_AsyncifyPassProps(value : @passes.AsyncifyPassProps) -> String {
  value.to_string()
}

pub fn __js_show_passes_BlockLiveness(value : @passes.BlockLiveness) -> String {
  value.to_string()
}

pub fn __js_show_passes_CallSite(value : @passes.CallSite) -> String {
  value.to_string()
}

pub fn __js_show_passes_EquivalentClass(value : @passes.EquivalentClass) -> String {
  value.to_string()
}

pub fn __js_show_passes_Literal(value : @passes.Literal) -> String {
  value.to_string()
}

pub fn __js_show_passes_LiteralKind(value : @passes.LiteralKind) -> String {
  value.to_string()
}

pub fn __js_show_passes_MSFCallSite(value : @passes.MSFCallSite) -> String {
  value.to_string()
}

pub fn __js_show_passes_MSFDefinedFunc(value : @passes.MSFDefinedFunc) -> String {
  value.to_string()
}

pub fn __js_show_passes_MSFHashState(value : @passes.MSFHashState) -> String {
  value.to_string()
}

pub fn __js_show_passes_MSFParamKind(value : @passes.MSFParamKind) -> String {
  value.to_string()
}

pub fn __js_show_passes_MSFSiteValue(value : @passes.MSFSiteValue) -> String {
  value.to_string()
}

pub fn __js_show_passes_MemoryPackingPassProps(value : @passes.MemoryPackingPassProps) -> String {
  value.to_string()
}

pub fn __js_show_passes_ModulePass(value : @passes.ModulePass) -> String {
  value.to_string()
}

pub fn __js_show_passes_ParamInfo(value : @passes.ParamInfo) -> String {
  value.to_string()
}

pub fn __js_show_validate_ValidationError(value : @validate.ValidationError) -> String {
  value.to_string()
}

pub fn __js_show_validate_Env(value : @validate.Env) -> String {
  value.to_string()
}

pub fn __js_show_validate_TcState(value : @validate.TcState) -> String {
  value.to_string()
}

pub fn __js_show_wast_ParserError(value : @wast.ParserError) -> String {
  value.to_string()
}

pub fn __js_show_wast_BlockType(value : @wast.BlockType) -> String {
  value.to_string()
}

pub fn __js_show_wast_CatchClause(value : @wast.CatchClause) -> String {
  value.to_string()
}

pub fn __js_show_wast_DataSegment(value : @wast.DataSegment) -> String {
  value.to_string()
}

pub fn __js_show_wast_ElemInitExpr(value : @wast.ElemInitExpr) -> String {
  value.to_string()
}

pub fn __js_show_wast_ElemSegment(value : @wast.ElemSegment) -> String {
  value.to_string()
}

pub fn __js_show_wast_ErrorLevel(value : @wast.ErrorLevel) -> String {
  value.to_string()
}

pub fn __js_show_wast_Export(value : @wast.Export) -> String {
  value.to_string()
}

pub fn __js_show_wast_ExportDesc(value : @wast.ExportDesc) -> String {
  value.to_string()
}

pub fn __js_show_wast_Func(value : @wast.Func) -> String {
  value.to_string()
}

pub fn __js_show_wast_FuncType(value : @wast.FuncType) -> String {
  value.to_string()
}

pub fn __js_show_wast_Global(value : @wast.Global) -> String {
  value.to_string()
}

pub fn __js_show_wast_GlobalType(value : @wast.GlobalType) -> String {
  value.to_string()
}

pub fn __js_show_wast_HeapTypeRef(value : @wast.HeapTypeRef) -> String {
  value.to_string()
}

pub fn __js_show_wast_Import(value : @wast.Import) -> String {
  value.to_string()
}

pub fn __js_show_wast_ImportDesc(value : @wast.ImportDesc) -> String {
  value.to_string()
}

pub fn __js_show_wast_Index(value : @wast.Index) -> String {
  value.to_string()
}

pub fn __js_show_wast_InlineExport(value : @wast.InlineExport) -> String {
  value.to_string()
}

pub fn __js_show_wast_Instruction(value : @wast.Instruction) -> String {
  value.to_string()
}

pub fn __js_show_wast_LegacyCatchClause(value : @wast.LegacyCatchClause) -> String {
  value.to_string()
}

pub fn __js_show_wast_LexerError(value : @wast.LexerError) -> String {
  value.to_string()
}

pub fn __js_show_wast_Limits(value : @wast.Limits) -> String {
  value.to_string()
}

pub fn __js_show_wast_Literal(value : @wast.Literal) -> String {
  value.to_string()
}

pub fn __js_show_wast_LiteralType(value : @wast.LiteralType) -> String {
  value.to_string()
}

pub fn __js_show_wast_Local(value : @wast.Local) -> String {
  value.to_string()
}

pub fn __js_show_wast_Location(value : @wast.Location) -> String {
  value.to_string()
}

pub fn __js_show_wast_MemArg(value : @wast.MemArg) -> String {
  value.to_string()
}

pub fn __js_show_wast_Memory(value : @wast.Memory) -> String {
  value.to_string()
}

pub fn __js_show_wast_MemoryType(value : @wast.MemoryType) -> String {
  value.to_string()
}

pub fn __js_show_wast_Module(value : @wast.Module) -> String {
  value.to_string()
}

pub fn __js_show_wast_ModuleField(value : @wast.ModuleField) -> String {
  value.to_string()
}

pub fn __js_show_wast_Opcode(value : @wast.Opcode) -> String {
  value.to_string()
}

pub fn __js_show_wast_ParseError(value : @wast.ParseError) -> String {
  value.to_string()
}

pub fn __js_show_wast_ShuffleLanes(value : @wast.ShuffleLanes) -> String {
  value.to_string()
}

pub fn __js_show_wast_SimdShape(value : @wast.SimdShape) -> String {
  value.to_string()
}

pub fn __js_show_wast_Start(value : @wast.Start) -> String {
  value.to_string()
}

pub fn __js_show_wast_Table(value : @wast.Table) -> String {
  value.to_string()
}

pub fn __js_show_wast_TableType(value : @wast.TableType) -> String {
  value.to_string()
}

pub fn __js_show_wast_Tag(value : @wast.Tag) -> String {
  value.to_string()
}

pub fn __js_show_wast_Token(value : @wast.Token) -> String {
  value.to_string()
}

pub fn __js_show_wast_TokenType(value : @wast.TokenType) -> String {
  value.to_string()
}

pub fn __js_show_wast_TokenValue(value : @wast.TokenValue) -> String {
  value.to_string()
}

pub fn __js_show_wast_TypeDef(value : @wast.TypeDef) -> String {
  value.to_string()
}

pub fn __js_show_wast_TypeUse(value : @wast.TypeUse) -> String {
  value.to_string()
}

pub fn __js_show_wast_V128Const(value : @wast.V128Const) -> String {
  value.to_string()
}

pub fn __js_show_wast_ValueType(value : @wast.ValueType) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastAction(value : @wast.WastAction) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastActionType(value : @wast.WastActionType) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastCommand(value : @wast.WastCommand) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastModuleDef(value : @wast.WastModuleDef) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastResult(value : @wast.WastResult) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastScript(value : @wast.WastScript) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastSpecFileReport(value : @wast.WastSpecFileReport) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastSpecFileStatus(value : @wast.WastSpecFileStatus) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastSpecRunSummary(value : @wast.WastSpecRunSummary) -> String {
  value.to_string()
}

pub fn __js_show_wast_WastValue(value : @wast.WastValue) -> String {
  value.to_string()
}

pub fn binary__decode_module(arg0 : Bytes) -> Result[@lib.Module, @binary.DecodeError] {
  @binary.decode_module(arg0)
}

pub fn binary__decode_module_with_detail(arg0 : Bytes, arg1 : Int) -> Result[(@lib.Module, Int), @binary.ModuleDecodeErrorDetail] {
  @binary.decode_module_with_detail(arg0, arg1)
}

pub fn binary__encode_module(arg0 : @lib.Module) -> Result[Bytes, @binary.EncodeError] {
  @binary.encode_module(arg0)
}

pub fn binary__size_signed(arg0 : Int64, arg1 : Int) -> Result[Int, @binary.BinaryEncodeError] {
  @binary.size_signed(arg0, arg1)
}

pub fn binary__size_unsigned(arg0 : UInt64, arg1 : Int) -> Result[Int, @binary.BinaryEncodeError] {
  @binary.size_unsigned(arg0, arg1)
}

pub fn cli__cli_config_schema_json() -> String {
  @cli.cli_config_schema_json()
}

pub fn cli__expand_globs(arg0 : Array[String], arg1 : Array[String]) -> Array[String] {
  @cli.expand_globs(arg0, arg1)
}

pub fn cli__glob_match(arg0 : String, arg1 : String) -> Bool {
  @cli.glob_match(arg0, arg1)
}

pub fn cli__infer_input_format(arg0 : String) -> @cli.CliInputFormat? {
  @cli.infer_input_format(arg0)
}

pub fn cli__normalize_cli_path(arg0 : String) -> String {
  @cli.normalize_cli_path(arg0)
}

pub fn cli__parse_cli_args__arity_1(arg0 : Array[String]) -> Result[@cli.CliParseResult, @cli.CliParseError] {
  @cli.parse_cli_args(arg0)
}

pub fn cli__parse_cli_args(arg0 : Array[String], arg1 : String?) -> Result[@cli.CliParseResult, @cli.CliParseError] {
  @cli.parse_cli_args(arg0, starshine_input=arg1)
}

pub fn cli__parse_starshine_input_env(arg0 : String?) -> Array[String] {
  @cli.parse_starshine_input_env(arg0)
}

pub fn cli__resolve_pass_flags(arg0 : @cli.CliParseResult) -> Array[String] {
  @cli.resolve_pass_flags(arg0)
}

pub fn cli__resolve_traps_never_happen__arity_1(arg0 : @cli.CliParseResult) -> Bool {
  @cli.resolve_traps_never_happen(arg0)
}

pub fn cli__resolve_traps_never_happen(arg0 : @cli.CliParseResult, arg1 : Bool) -> Bool {
  @cli.resolve_traps_never_happen(arg0, default=arg1)
}

pub fn cli__CliInputFormat__wasm() -> @cli.CliInputFormat {
  @cli.CliInputFormat::wasm()
}

pub fn cli__CliInputFormat__wast() -> @cli.CliInputFormat {
  @cli.CliInputFormat::wast()
}

pub fn cli__CliInputFormat__wat() -> @cli.CliInputFormat {
  @cli.CliInputFormat::wat()
}

pub fn cli__CliOptimizationFlag__olevel(arg0 : Int, arg1 : Bool) -> @cli.CliOptimizationFlag {
  @cli.CliOptimizationFlag::olevel(arg0, arg1)
}

pub fn cli__CliOptimizationFlag__optimize() -> @cli.CliOptimizationFlag {
  @cli.CliOptimizationFlag::optimize()
}

pub fn cli__CliOptimizationFlag__shrink() -> @cli.CliOptimizationFlag {
  @cli.CliOptimizationFlag::shrink()
}

pub fn cli__CliOutputTarget__dir(arg0 : String) -> @cli.CliOutputTarget {
  @cli.CliOutputTarget::dir(arg0)
}

pub fn cli__CliOutputTarget__file(arg0 : String) -> @cli.CliOutputTarget {
  @cli.CliOutputTarget::file(arg0)
}

pub fn cli__CliOutputTarget__stdout() -> @cli.CliOutputTarget {
  @cli.CliOutputTarget::stdout()
}

pub fn cli__CliParseError__invalid_input_format(arg0 : String) -> @cli.CliParseError {
  @cli.CliParseError::invalid_input_format(arg0)
}

pub fn cli__CliParseError__invalid_long_flag(arg0 : String) -> @cli.CliParseError {
  @cli.CliParseError::invalid_long_flag(arg0)
}

pub fn cli__CliParseError__invalid_optimization_flag(arg0 : String) -> @cli.CliParseError {
  @cli.CliParseError::invalid_optimization_flag(arg0)
}

pub fn cli__CliParseError__invalid_trap_mode(arg0 : String) -> @cli.CliParseError {
  @cli.CliParseError::invalid_trap_mode(arg0)
}

pub fn cli__CliParseError__missing_flag_value(arg0 : String) -> @cli.CliParseError {
  @cli.CliParseError::missing_flag_value(arg0)
}

pub fn cli__CliParseError__stdin_needs_format() -> @cli.CliParseError {
  @cli.CliParseError::stdin_needs_format()
}

pub fn cli__CliParseError__unexpected_flag_value(arg0 : String) -> @cli.CliParseError {
  @cli.CliParseError::unexpected_flag_value(arg0)
}

pub fn cli__CliParseError__unknown_short_flag(arg0 : Char) -> @cli.CliParseError {
  @cli.CliParseError::unknown_short_flag(arg0)
}

pub fn cli__CliParseResult__new__arity_0() -> @cli.CliParseResult {
  @cli.CliParseResult::new()
}

pub fn cli__CliParseResult__new__arity_1(arg0 : String?) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0)
}

pub fn cli__CliParseResult__new__arity_2(arg0 : String?, arg1 : Array[String]) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1)
}

pub fn cli__CliParseResult__new__arity_3(arg0 : String?, arg1 : Array[String], arg2 : Bool) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2)
}

pub fn cli__CliParseResult__new__arity_4(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3)
}

pub fn cli__CliParseResult__new__arity_5(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4)
}

pub fn cli__CliParseResult__new__arity_6(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5)
}

pub fn cli__CliParseResult__new__arity_7(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget]) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6)
}

pub fn cli__CliParseResult__new__arity_8(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget], arg7 : Array[String]) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6, pass_flags=arg7)
}

pub fn cli__CliParseResult__new__arity_9(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget], arg7 : Array[String], arg8 : Array[@cli.CliOptimizationFlag]) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6, pass_flags=arg7, optimize_flags=arg8)
}

pub fn cli__CliParseResult__new__arity_10(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget], arg7 : Array[String], arg8 : Array[@cli.CliOptimizationFlag], arg9 : @cli.TrapMode?) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6, pass_flags=arg7, optimize_flags=arg8, trap_mode=arg9)
}

pub fn cli__CliParseResult__new__arity_11(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget], arg7 : Array[String], arg8 : Array[@cli.CliOptimizationFlag], arg9 : @cli.TrapMode?, arg10 : Int?) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6, pass_flags=arg7, optimize_flags=arg8, trap_mode=arg9, monomorphize_min_benefit=arg10)
}

pub fn cli__CliParseResult__new__arity_12(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget], arg7 : Array[String], arg8 : Array[@cli.CliOptimizationFlag], arg9 : @cli.TrapMode?, arg10 : Int?, arg11 : Bool?) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6, pass_flags=arg7, optimize_flags=arg8, trap_mode=arg9, monomorphize_min_benefit=arg10, low_memory_unused=arg11)
}

pub fn cli__CliParseResult__new(arg0 : String?, arg1 : Array[String], arg2 : Bool, arg3 : Bool, arg4 : Bool, arg5 : @cli.CliInputFormat?, arg6 : Array[@cli.CliOutputTarget], arg7 : Array[String], arg8 : Array[@cli.CliOptimizationFlag], arg9 : @cli.TrapMode?, arg10 : Int?, arg11 : Bool?, arg12 : UInt64?) -> @cli.CliParseResult {
  @cli.CliParseResult::new(config_path=arg0, input_globs=arg1, help_requested=arg2, version_requested=arg3, read_stdin=arg4, input_format=arg5, output_targets=arg6, pass_flags=arg7, optimize_flags=arg8, trap_mode=arg9, monomorphize_min_benefit=arg10, low_memory_unused=arg11, low_memory_bound=arg12)
}

pub fn cli__TrapMode__allow() -> @cli.TrapMode {
  @cli.TrapMode::allow()
}

pub fn cli__TrapMode__never() -> @cli.TrapMode {
  @cli.TrapMode::never()
}

pub fn cmd__cmd_help_text() -> String {
  @cmd.cmd_help_text()
}

pub fn cmd__cmd_version_text() -> String {
  @cmd.cmd_version_text()
}

pub fn cmd__differential_validate_wasm__arity_1(arg0 : Bytes) -> Result[@cmd.DifferentialValidationReport, String] {
  @cmd.differential_validate_wasm(arg0)
}

pub fn cmd__differential_validate_wasm(arg0 : Bytes, arg1 : @cmd.DifferentialAdapters) -> Result[@cmd.DifferentialValidationReport, String] {
  @cmd.differential_validate_wasm(arg0, adapters=arg1)
}

pub fn cmd__native_differential_tools_available() -> (Bool, Bool) {
  @cmd.native_differential_tools_available()
}

pub fn cmd__persist_fuzz_failure_report__arity_2(arg0 : @cmd.FuzzFailureReport, arg1 : @cmd.FuzzFailurePersistIO) -> Result[(String, String?), String] {
  @cmd.persist_fuzz_failure_report(arg0, arg1)
}

pub fn cmd__persist_fuzz_failure_report(arg0 : @cmd.FuzzFailureReport, arg1 : @cmd.FuzzFailurePersistIO, arg2 : String) -> Result[(String, String?), String] {
  @cmd.persist_fuzz_failure_report(arg0, arg1, corpus_dir=arg2)
}

pub fn cmd__run_cmd(arg0 : Array[String]) -> Result[@cmd.CmdRunSummary, @cmd.CmdError] {
  @cmd.run_cmd(arg0)
}

pub fn cmd__run_cmd_exit_code(arg0 : Array[String]) -> Int {
  @cmd.run_cmd_exit_code(arg0)
}

pub fn cmd__run_cmd_exit_code_with_adapter__arity_2(arg0 : Array[String], arg1 : @cmd.CmdIO) -> Int {
  @cmd.run_cmd_exit_code_with_adapter(arg0, arg1)
}

pub fn cmd__run_cmd_exit_code_with_adapter(arg0 : Array[String], arg1 : @cmd.CmdIO, arg2 : String?) -> Int {
  @cmd.run_cmd_exit_code_with_adapter(arg0, arg1, config_json=arg2)
}

pub fn cmd__run_cmd_with_adapter__arity_2(arg0 : Array[String], arg1 : @cmd.CmdIO) -> Result[@cmd.CmdRunSummary, @cmd.CmdError] {
  @cmd.run_cmd_with_adapter(arg0, arg1)
}

pub fn cmd__run_cmd_with_adapter(arg0 : Array[String], arg1 : @cmd.CmdIO, arg2 : String?) -> Result[@cmd.CmdRunSummary, @cmd.CmdError] {
  @cmd.run_cmd_with_adapter(arg0, arg1, config_json=arg2)
}

pub fn cmd__verify_readme_api_signatures(arg0 : String, arg1 : Array[(String, String)]) -> Result[Unit, String] {
  @cmd.verify_readme_api_signatures(arg0, arg1)
}

pub fn cmd__verify_readme_api_signatures_with_required_blocks(arg0 : String, arg1 : Array[(String, String)], arg2 : Array[String]) -> Result[Unit, String] {
  @cmd.verify_readme_api_signatures_with_required_blocks(arg0, arg1, arg2)
}

pub fn cmd__CmdEncodeError__adapter(arg0 : String) -> @cmd.CmdEncodeError {
  @cmd.CmdEncodeError::adapter(arg0)
}

pub fn cmd__CmdEncodeError__encode(arg0 : @binary.EncodeError) -> @cmd.CmdEncodeError {
  @cmd.CmdEncodeError::encode(arg0)
}

pub fn cmd__CmdError__ambiguous_output_file(arg0 : String) -> @cmd.CmdError {
  @cmd.CmdError::ambiguous_output_file(arg0)
}

pub fn cmd__CmdError__unknown_pass_flag(arg0 : String) -> @cmd.CmdError {
  @cmd.CmdError::unknown_pass_flag(arg0)
}

pub fn cmd__CmdRunSummary__new__arity_0() -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new()
}

pub fn cmd__CmdRunSummary__new__arity_1(arg0 : Array[String]) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0)
}

pub fn cmd__CmdRunSummary__new__arity_2(arg0 : Array[String], arg1 : Array[String]) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1)
}

pub fn cmd__CmdRunSummary__new__arity_3(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String]) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2)
}

pub fn cmd__CmdRunSummary__new__arity_4(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String], arg3 : Int) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2, optimize_level=arg3)
}

pub fn cmd__CmdRunSummary__new__arity_5(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String], arg3 : Int, arg4 : Int) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2, optimize_level=arg3, shrink_level=arg4)
}

pub fn cmd__CmdRunSummary__new__arity_6(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String], arg3 : Int, arg4 : Int, arg5 : Bool) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2, optimize_level=arg3, shrink_level=arg4, traps_never_happen=arg5)
}

pub fn cmd__CmdRunSummary__new__arity_7(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String], arg3 : Int, arg4 : Int, arg5 : Bool, arg6 : Int) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2, optimize_level=arg3, shrink_level=arg4, traps_never_happen=arg5, monomorphize_min_benefit=arg6)
}

pub fn cmd__CmdRunSummary__new__arity_8(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String], arg3 : Int, arg4 : Int, arg5 : Bool, arg6 : Int, arg7 : Bool) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2, optimize_level=arg3, shrink_level=arg4, traps_never_happen=arg5, monomorphize_min_benefit=arg6, low_memory_unused=arg7)
}

pub fn cmd__CmdRunSummary__new(arg0 : Array[String], arg1 : Array[String], arg2 : Array[String], arg3 : Int, arg4 : Int, arg5 : Bool, arg6 : Int, arg7 : Bool, arg8 : UInt64) -> @cmd.CmdRunSummary {
  @cmd.CmdRunSummary::new(input_files=arg0, output_files=arg1, resolved_passes=arg2, optimize_level=arg3, shrink_level=arg4, traps_never_happen=arg5, monomorphize_min_benefit=arg6, low_memory_unused=arg7, low_memory_bound=arg8)
}

pub fn cmd__FuzzFailureReport__new__arity_5(arg0 : UInt64, arg1 : Int, arg2 : Int, arg3 : String, arg4 : String) -> @cmd.FuzzFailureReport {
  @cmd.FuzzFailureReport::new(arg0, arg1, arg2, arg3, arg4)
}

pub fn cmd__FuzzFailureReport__new__arity_6(arg0 : UInt64, arg1 : Int, arg2 : Int, arg3 : String, arg4 : String, arg5 : Array[String]) -> @cmd.FuzzFailureReport {
  @cmd.FuzzFailureReport::new(arg0, arg1, arg2, arg3, arg4, optimize_passes=arg5)
}

pub fn cmd__FuzzFailureReport__new__arity_7(arg0 : UInt64, arg1 : Int, arg2 : Int, arg3 : String, arg4 : String, arg5 : Array[String], arg6 : Array[String]) -> @cmd.FuzzFailureReport {
  @cmd.FuzzFailureReport::new(arg0, arg1, arg2, arg3, arg4, optimize_passes=arg5, minimized_passes=arg6)
}

pub fn cmd__FuzzFailureReport__new(arg0 : UInt64, arg1 : Int, arg2 : Int, arg3 : String, arg4 : String, arg5 : Array[String], arg6 : Array[String], arg7 : Bytes?) -> @cmd.FuzzFailureReport {
  @cmd.FuzzFailureReport::new(arg0, arg1, arg2, arg3, arg4, optimize_passes=arg5, minimized_passes=arg6, wasm=arg7)
}

pub fn cmd__WasmSmithFuzzStats__new__arity_0() -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new()
}

pub fn cmd__WasmSmithFuzzStats__new__arity_1(arg0 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0)
}

pub fn cmd__WasmSmithFuzzStats__new__arity_2(arg0 : Int, arg1 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0, generated_valid=arg1)
}

pub fn cmd__WasmSmithFuzzStats__new__arity_3(arg0 : Int, arg1 : Int, arg2 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0, generated_valid=arg1, generated_invalid=arg2)
}

pub fn cmd__WasmSmithFuzzStats__new__arity_4(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0, generated_valid=arg1, generated_invalid=arg2, pipeline_validated=arg3)
}

pub fn cmd__WasmSmithFuzzStats__new__arity_5(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int, arg4 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0, generated_valid=arg1, generated_invalid=arg2, pipeline_validated=arg3, optimized=arg4)
}

pub fn cmd__WasmSmithFuzzStats__new__arity_6(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int, arg4 : Int, arg5 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0, generated_valid=arg1, generated_invalid=arg2, pipeline_validated=arg3, optimized=arg4, roundtripped=arg5)
}

pub fn cmd__WasmSmithFuzzStats__new(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int, arg4 : Int, arg5 : Int, arg6 : Int) -> @cmd.WasmSmithFuzzStats {
  @cmd.WasmSmithFuzzStats::new(attempts=arg0, generated_valid=arg1, generated_invalid=arg2, pipeline_validated=arg3, optimized=arg4, roundtripped=arg5, differential_checked=arg6)
}

pub fn ir__compat_is_f32_nan(arg0 : Float) -> Bool {
  @ir.compat_is_f32_nan(arg0)
}

pub fn ir__compat_is_f64_nan(arg0 : Double) -> Bool {
  @ir.compat_is_f64_nan(arg0)
}

pub fn ir__compat_is_f64_non_finite(arg0 : Double) -> Bool {
  @ir.compat_is_f64_non_finite(arg0)
}

pub fn ir__compat_trunc_f64_to_i64_s(arg0 : Double) -> Int64? {
  @ir.compat_trunc_f64_to_i64_s(arg0)
}

pub fn ir__compat_trunc_f64_to_i64_u(arg0 : Double) -> Int64? {
  @ir.compat_trunc_f64_to_i64_u(arg0)
}

pub fn ir__infer_ssa_types(arg0 : @ir.SSACFG, arg1 : @ir.TypeContext) -> @ir.SSATypeInfo {
  @ir.infer_ssa_types(arg0, arg1)
}

pub fn ir__run_gvn(arg0 : @ir.SSACFG, arg1 : Map[@ir.BlockId, @ir.BlockId]) -> @ir.SSACFG {
  @ir.run_gvn(arg0, arg1)
}

pub fn ir__BlockId__inner(arg0 : @ir.BlockId) -> Int {
  @ir.BlockId::inner(arg0)
}

pub fn ir__CFG__block(arg0 : @ir.CFG, arg1 : @ir.BlockId) -> @ir.BasicBlock? {
  @ir.CFG::block(arg0, arg1)
}

pub fn ir__CFG__build(arg0 : @lib.TExpr) -> @ir.CFG {
  @ir.CFG::build(arg0)
}

pub fn ir__CFG__dominance_frontier(arg0 : @ir.CFG) -> Map[@ir.BlockId, @set.Set[@ir.BlockId]] {
  @ir.CFG::dominance_frontier(arg0)
}

pub fn ir__CFG__dominates(arg0 : @ir.CFG, arg1 : @ir.BlockId, arg2 : @ir.BlockId) -> Bool {
  @ir.CFG::dominates(arg0, arg1, arg2)
}

pub fn ir__CFG__dominators(arg0 : @ir.CFG) -> Map[@ir.BlockId, @ir.BlockId] {
  @ir.CFG::dominators(arg0)
}

pub fn ir__CFG__entry(arg0 : @ir.CFG) -> @ir.BlockId {
  @ir.CFG::entry(arg0)
}

pub fn ir__CFG__predecessors(arg0 : @ir.CFG, arg1 : @ir.BlockId) -> Array[@ir.BlockId] {
  @ir.CFG::predecessors(arg0, arg1)
}

pub fn ir__CFG__strict_dominates(arg0 : @ir.CFG, arg1 : @ir.BlockId, arg2 : @ir.BlockId) -> Bool {
  @ir.CFG::strict_dominates(arg0, arg1, arg2)
}

pub fn ir__CFG__successors(arg0 : @ir.CFG, arg1 : @ir.BlockId) -> Array[@ir.BlockId] {
  @ir.CFG::successors(arg0, arg1)
}

pub fn ir__CFG__to_ssa(arg0 : @ir.CFG, arg1 : Map[@ir.BlockId, @ir.BlockId], arg2 : Map[@ir.BlockId, @set.Set[@ir.BlockId]], arg3 : Int) -> @ir.SSACFG {
  @ir.CFG::to_ssa(arg0, arg1, arg2, arg3)
}

pub fn ir__CFG__validate(arg0 : @ir.CFG) -> Result[Unit, String] {
  @ir.CFG::validate(arg0)
}

pub fn ir__IRContext__apply_gvn(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::apply_gvn(arg0)
}

pub fn ir__IRContext__apply_ssa_optimize(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::apply_ssa_optimize(arg0)
}

pub fn ir__IRContext__cfg_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::cfg_dirty(arg0)
}

pub fn ir__IRContext__get_cfg(arg0 : @ir.IRContext) -> @ir.CFG {
  @ir.IRContext::get_cfg(arg0)
}

pub fn ir__IRContext__get_gvn(arg0 : @ir.IRContext) -> @ir.SSACFG {
  @ir.IRContext::get_gvn(arg0)
}

pub fn ir__IRContext__get_liveness(arg0 : @ir.IRContext) -> @ir.LivenessInfo {
  @ir.IRContext::get_liveness(arg0)
}

pub fn ir__IRContext__get_local_graph(arg0 : @ir.IRContext) -> @ir.LocalGraph {
  @ir.IRContext::get_local_graph(arg0)
}

pub fn ir__IRContext__get_mod(arg0 : @ir.IRContext) -> @lib.Module? {
  @ir.IRContext::get_mod(arg0)
}

pub fn ir__IRContext__get_ssa(arg0 : @ir.IRContext) -> @ir.SSACFG {
  @ir.IRContext::get_ssa(arg0)
}

pub fn ir__IRContext__get_type_ctx(arg0 : @ir.IRContext) -> Result[@ir.TypeContext, String] {
  @ir.IRContext::get_type_ctx(arg0)
}

pub fn ir__IRContext__get_types(arg0 : @ir.IRContext) -> @ir.SSATypeInfo? {
  @ir.IRContext::get_types(arg0)
}

pub fn ir__IRContext__get_usedef(arg0 : @ir.IRContext) -> @ir.UseDefInfo {
  @ir.IRContext::get_usedef(arg0)
}

pub fn ir__IRContext__gvn_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::gvn_dirty(arg0)
}

pub fn ir__IRContext__liveness_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::liveness_dirty(arg0)
}

pub fn ir__IRContext__local_graph_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::local_graph_dirty(arg0)
}

pub fn ir__IRContext__lower_to_cfg(arg0 : @ir.IRContext) -> @ir.CFG {
  @ir.IRContext::lower_to_cfg(arg0)
}

pub fn ir__IRContext__new() -> @ir.IRContext {
  @ir.IRContext::new()
}

pub fn ir__IRContext__optimize_body_with_ssa(arg0 : @ir.IRContext) -> @lib.TExpr? {
  @ir.IRContext::optimize_body_with_ssa(arg0)
}

pub fn ir__IRContext__set_body(arg0 : @ir.IRContext, arg1 : @lib.TExpr) -> Unit {
  @ir.IRContext::set_body(arg0, arg1)
}

pub fn ir__IRContext__set_locals(arg0 : @ir.IRContext, arg1 : Array[@lib.ValType]) -> Unit {
  @ir.IRContext::set_locals(arg0, arg1)
}

pub fn ir__IRContext__set_mod(arg0 : @ir.IRContext, arg1 : @lib.Module) -> Unit {
  @ir.IRContext::set_mod(arg0, arg1)
}

pub fn ir__IRContext__ssa_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::ssa_dirty(arg0)
}

pub fn ir__IRContext__types_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::types_dirty(arg0)
}

pub fn ir__IRContext__usedef_dirty(arg0 : @ir.IRContext) -> Unit {
  @ir.IRContext::usedef_dirty(arg0)
}

pub fn ir__IRContext__validate(arg0 : @ir.IRContext) -> Result[Unit, String] {
  @ir.IRContext::validate(arg0)
}

pub fn ir__LivenessInfo__get_live_in(arg0 : @ir.LivenessInfo, arg1 : @ir.BlockId) -> @set.Set[@ir.SSAValue] {
  @ir.LivenessInfo::get_live_in(arg0, arg1)
}

pub fn ir__LivenessInfo__get_live_out(arg0 : @ir.LivenessInfo, arg1 : @ir.BlockId) -> @set.Set[@ir.SSAValue] {
  @ir.LivenessInfo::get_live_out(arg0, arg1)
}

pub fn ir__LivenessInfo__is_live_in(arg0 : @ir.LivenessInfo, arg1 : @ir.BlockId, arg2 : @ir.SSAValue) -> Bool {
  @ir.LivenessInfo::is_live_in(arg0, arg1, arg2)
}

pub fn ir__LivenessInfo__is_live_out(arg0 : @ir.LivenessInfo, arg1 : @ir.BlockId, arg2 : @ir.SSAValue) -> Bool {
  @ir.LivenessInfo::is_live_out(arg0, arg1, arg2)
}

pub fn ir__LocalGraph__get_sets(arg0 : @ir.LocalGraph, arg1 : Int) -> @set.Set[@ir.LocalSet] {
  @ir.LocalGraph::get_sets(arg0, arg1)
}

pub fn ir__LocalGraph__new(arg0 : Array[@lib.TInstr]) -> @ir.LocalGraph {
  @ir.LocalGraph::new(arg0)
}

pub fn ir__SSACFG__build_use_def(arg0 : @ir.SSACFG) -> @ir.UseDefInfo {
  @ir.SSACFG::build_use_def(arg0)
}

pub fn ir__SSACFG__compute_liveness(arg0 : @ir.SSACFG) -> @ir.LivenessInfo {
  @ir.SSACFG::compute_liveness(arg0)
}

pub fn ir__SSACFG__optimize(arg0 : @ir.SSACFG) -> @ir.SSACFG {
  @ir.SSACFG::optimize(arg0)
}

pub fn ir__SSACFG__split_critical_edges(arg0 : @ir.SSACFG) -> @ir.SSACFG {
  @ir.SSACFG::split_critical_edges(arg0)
}

pub fn ir__SSACFG__to_cfg(arg0 : @ir.SSACFG, arg1 : Int) -> @ir.CFG {
  @ir.SSACFG::to_cfg(arg0, arg1)
}

pub fn ir__SSATypeInfo__get(arg0 : @ir.SSATypeInfo, arg1 : @ir.SSAValue) -> @lib.ValType? {
  @ir.SSATypeInfo::get(arg0, arg1)
}

pub fn ir__SSAValue__inner(arg0 : @ir.SSAValue) -> Int {
  @ir.SSAValue::inner(arg0)
}

pub fn ir__TypeContext__empty() -> @ir.TypeContext {
  @ir.TypeContext::empty()
}

pub fn ir__TypeContext__from_module(arg0 : @lib.Module, arg1 : Array[@lib.ValType]) -> @ir.TypeContext {
  @ir.TypeContext::from_module(arg0, arg1)
}

pub fn ir__UseDefInfo__get_def(arg0 : @ir.UseDefInfo, arg1 : @ir.SSAValue) -> (@ir.BlockId, @ir.SSADef)? {
  @ir.UseDefInfo::get_def(arg0, arg1)
}

pub fn ir__UseDefInfo__get_uses(arg0 : @ir.UseDefInfo, arg1 : @ir.SSAValue) -> Array[@ir.SSAUse] {
  @ir.UseDefInfo::get_uses(arg0, arg1)
}

pub fn ir__UseDefInfo__is_dead(arg0 : @ir.UseDefInfo, arg1 : @ir.SSAValue) -> Bool {
  @ir.UseDefInfo::is_dead(arg0, arg1)
}

pub fn lib__apply_pretty_context(arg0 : String, arg1 : @lib.PrettyPrintContext) -> String {
  @lib.apply_pretty_context(arg0, arg1)
}

pub fn lib__array_comp_type(arg0 : @lib.FieldType) -> @lib.CompType {
  @lib.array_comp_type(arg0)
}

pub fn lib__comp_type_sub_type(arg0 : @lib.CompType) -> @lib.SubType {
  @lib.comp_type_sub_type(arg0)
}

pub fn lib__expand_locals(arg0 : Array[@lib.Locals]) -> Result[Array[@lib.ValType], String] {
  @lib.expand_locals(arg0)
}

pub fn lib__func_comp_type(arg0 : Array[@lib.ValType], arg1 : Array[@lib.ValType]) -> @lib.CompType {
  @lib.func_comp_type(arg0, arg1)
}

pub fn lib__func_extern_idx(arg0 : @lib.FuncIdx) -> @lib.ExternIdx {
  @lib.func_extern_idx(arg0)
}

pub fn lib__func_extern_type(arg0 : @lib.TypeIdx) -> @lib.ExternType {
  @lib.func_extern_type(arg0)
}

pub fn lib__func_idx(arg0 : UInt) -> @lib.FuncIdx {
  @lib.func_idx(arg0)
}

pub fn lib__get_struct_field(arg0 : Array[@lib.FieldType], arg1 : @lib.U32) -> Result[@lib.FieldType, String] {
  @lib.get_struct_field(arg0, arg1)
}

pub fn lib__global_extern_idx(arg0 : @lib.GlobalIdx) -> @lib.ExternIdx {
  @lib.global_extern_idx(arg0)
}

pub fn lib__global_extern_type(arg0 : @lib.GlobalType) -> @lib.ExternType {
  @lib.global_extern_type(arg0)
}

pub fn lib__global_idx(arg0 : UInt) -> @lib.GlobalIdx {
  @lib.global_idx(arg0)
}

pub fn lib__global_type(arg0 : @lib.ValType, arg1 : Bool) -> @lib.GlobalType {
  @lib.global_type(arg0, arg1)
}

pub fn lib__group_rec_type(arg0 : Array[@lib.SubType]) -> @lib.RecType {
  @lib.group_rec_type(arg0)
}

pub fn lib__has_default(arg0 : @lib.ValType) -> Bool {
  @lib.has_default(arg0)
}

pub fn lib__mem_extern_idx(arg0 : @lib.MemIdx) -> @lib.ExternIdx {
  @lib.mem_extern_idx(arg0)
}

pub fn lib__mem_extern_type(arg0 : @lib.MemType) -> @lib.ExternType {
  @lib.mem_extern_type(arg0)
}

pub fn lib__mem_type(arg0 : @lib.Limits) -> @lib.MemType {
  @lib.mem_type(arg0)
}

pub fn lib__min_addr(arg0 : @lib.Limits, arg1 : @lib.Limits) -> @lib.Limits {
  @lib.min_addr(arg0, arg1)
}

pub fn lib__min_addr_valtype(arg0 : @lib.Limits, arg1 : @lib.Limits) -> @lib.ValType {
  @lib.min_addr_valtype(arg0, arg1)
}

pub fn lib__rec_idx(arg0 : UInt) -> @lib.TypeIdx {
  @lib.rec_idx(arg0)
}

pub fn lib__single_rec_type(arg0 : @lib.SubType) -> @lib.RecType {
  @lib.single_rec_type(arg0)
}

pub fn lib__struct_comp_type(arg0 : Array[@lib.FieldType]) -> @lib.CompType {
  @lib.struct_comp_type(arg0)
}

pub fn lib__sub_type(arg0 : Bool, arg1 : Array[@lib.TypeIdx], arg2 : @lib.CompType) -> @lib.SubType {
  @lib.sub_type(arg0, arg1, arg2)
}

pub fn lib__table_extern_idx(arg0 : @lib.TableIdx) -> @lib.ExternIdx {
  @lib.table_extern_idx(arg0)
}

pub fn lib__table_extern_type(arg0 : @lib.TableType) -> @lib.ExternType {
  @lib.table_extern_type(arg0)
}

pub fn lib__table_idx(arg0 : UInt) -> @lib.TableIdx {
  @lib.table_idx(arg0)
}

pub fn lib__tag_extern_idx(arg0 : @lib.TagIdx) -> @lib.ExternIdx {
  @lib.tag_extern_idx(arg0)
}

pub fn lib__tag_extern_type(arg0 : @lib.TagType) -> @lib.ExternType {
  @lib.tag_extern_type(arg0)
}

pub fn lib__tag_type(arg0 : @lib.TypeIdx) -> @lib.TagType {
  @lib.tag_type(arg0)
}

pub fn lib__tlocals_to_locals(arg0 : Array[@lib.ValType]) -> Array[@lib.Locals] {
  @lib.tlocals_to_locals(arg0)
}

pub fn lib__AbsHeapType__any() -> @lib.AbsHeapType {
  @lib.AbsHeapType::any()
}

pub fn lib__AbsHeapType__array() -> @lib.AbsHeapType {
  @lib.AbsHeapType::array()
}

pub fn lib__AbsHeapType__eq() -> @lib.AbsHeapType {
  @lib.AbsHeapType::eq()
}

pub fn lib__AbsHeapType__exn() -> @lib.AbsHeapType {
  @lib.AbsHeapType::exn()
}

pub fn lib__AbsHeapType__extern_() -> @lib.AbsHeapType {
  @lib.AbsHeapType::extern_()
}

pub fn lib__AbsHeapType__func() -> @lib.AbsHeapType {
  @lib.AbsHeapType::func()
}

pub fn lib__AbsHeapType__i31() -> @lib.AbsHeapType {
  @lib.AbsHeapType::i31()
}

pub fn lib__AbsHeapType__no_exn() -> @lib.AbsHeapType {
  @lib.AbsHeapType::no_exn()
}

pub fn lib__AbsHeapType__no_extern() -> @lib.AbsHeapType {
  @lib.AbsHeapType::no_extern()
}

pub fn lib__AbsHeapType__no_func() -> @lib.AbsHeapType {
  @lib.AbsHeapType::no_func()
}

pub fn lib__AbsHeapType__none() -> @lib.AbsHeapType {
  @lib.AbsHeapType::none()
}

pub fn lib__AbsHeapType__struct_() -> @lib.AbsHeapType {
  @lib.AbsHeapType::struct_()
}

pub fn lib__AtomicCmpxchgOp__i32() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i32()
}

pub fn lib__AtomicCmpxchgOp__i32_16_u() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i32_16_u()
}

pub fn lib__AtomicCmpxchgOp__i32_8_u() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i32_8_u()
}

pub fn lib__AtomicCmpxchgOp__i64() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i64()
}

pub fn lib__AtomicCmpxchgOp__i64_16_u() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i64_16_u()
}

pub fn lib__AtomicCmpxchgOp__i64_32_u() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i64_32_u()
}

pub fn lib__AtomicCmpxchgOp__i64_8_u() -> @lib.AtomicCmpxchgOp {
  @lib.AtomicCmpxchgOp::i64_8_u()
}

pub fn lib__AtomicRmwOp__i32_16_add_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_16_add_u()
}

pub fn lib__AtomicRmwOp__i32_16_and_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_16_and_u()
}

pub fn lib__AtomicRmwOp__i32_16_or_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_16_or_u()
}

pub fn lib__AtomicRmwOp__i32_16_sub_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_16_sub_u()
}

pub fn lib__AtomicRmwOp__i32_16_xchg_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_16_xchg_u()
}

pub fn lib__AtomicRmwOp__i32_16_xor_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_16_xor_u()
}

pub fn lib__AtomicRmwOp__i32_8_add_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_8_add_u()
}

pub fn lib__AtomicRmwOp__i32_8_and_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_8_and_u()
}

pub fn lib__AtomicRmwOp__i32_8_or_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_8_or_u()
}

pub fn lib__AtomicRmwOp__i32_8_sub_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_8_sub_u()
}

pub fn lib__AtomicRmwOp__i32_8_xchg_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_8_xchg_u()
}

pub fn lib__AtomicRmwOp__i32_8_xor_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_8_xor_u()
}

pub fn lib__AtomicRmwOp__i32_add() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_add()
}

pub fn lib__AtomicRmwOp__i32_and() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_and()
}

pub fn lib__AtomicRmwOp__i32_or() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_or()
}

pub fn lib__AtomicRmwOp__i32_sub() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_sub()
}

pub fn lib__AtomicRmwOp__i32_xchg() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_xchg()
}

pub fn lib__AtomicRmwOp__i32_xor() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i32_xor()
}

pub fn lib__AtomicRmwOp__i64_16_add_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_16_add_u()
}

pub fn lib__AtomicRmwOp__i64_16_and_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_16_and_u()
}

pub fn lib__AtomicRmwOp__i64_16_or_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_16_or_u()
}

pub fn lib__AtomicRmwOp__i64_16_sub_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_16_sub_u()
}

pub fn lib__AtomicRmwOp__i64_16_xchg_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_16_xchg_u()
}

pub fn lib__AtomicRmwOp__i64_16_xor_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_16_xor_u()
}

pub fn lib__AtomicRmwOp__i64_32_add_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_32_add_u()
}

pub fn lib__AtomicRmwOp__i64_32_and_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_32_and_u()
}

pub fn lib__AtomicRmwOp__i64_32_or_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_32_or_u()
}

pub fn lib__AtomicRmwOp__i64_32_sub_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_32_sub_u()
}

pub fn lib__AtomicRmwOp__i64_32_xchg_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_32_xchg_u()
}

pub fn lib__AtomicRmwOp__i64_32_xor_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_32_xor_u()
}

pub fn lib__AtomicRmwOp__i64_8_add_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_8_add_u()
}

pub fn lib__AtomicRmwOp__i64_8_and_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_8_and_u()
}

pub fn lib__AtomicRmwOp__i64_8_or_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_8_or_u()
}

pub fn lib__AtomicRmwOp__i64_8_sub_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_8_sub_u()
}

pub fn lib__AtomicRmwOp__i64_8_xchg_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_8_xchg_u()
}

pub fn lib__AtomicRmwOp__i64_8_xor_u() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_8_xor_u()
}

pub fn lib__AtomicRmwOp__i64_add() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_add()
}

pub fn lib__AtomicRmwOp__i64_and() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_and()
}

pub fn lib__AtomicRmwOp__i64_or() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_or()
}

pub fn lib__AtomicRmwOp__i64_sub() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_sub()
}

pub fn lib__AtomicRmwOp__i64_xchg() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_xchg()
}

pub fn lib__AtomicRmwOp__i64_xor() -> @lib.AtomicRmwOp {
  @lib.AtomicRmwOp::i64_xor()
}

pub fn lib__BinaryOp__f32_add() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_add()
}

pub fn lib__BinaryOp__f32_copysign() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_copysign()
}

pub fn lib__BinaryOp__f32_div() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_div()
}

pub fn lib__BinaryOp__f32_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_eq()
}

pub fn lib__BinaryOp__f32_ge() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_ge()
}

pub fn lib__BinaryOp__f32_gt() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_gt()
}

pub fn lib__BinaryOp__f32_le() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_le()
}

pub fn lib__BinaryOp__f32_lt() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_lt()
}

pub fn lib__BinaryOp__f32_max() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_max()
}

pub fn lib__BinaryOp__f32_min() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_min()
}

pub fn lib__BinaryOp__f32_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_mul()
}

pub fn lib__BinaryOp__f32_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_ne()
}

pub fn lib__BinaryOp__f32_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::f32_sub()
}

pub fn lib__BinaryOp__f32x4_add() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_add()
}

pub fn lib__BinaryOp__f32x4_div() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_div()
}

pub fn lib__BinaryOp__f32x4_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_eq()
}

pub fn lib__BinaryOp__f32x4_ge() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_ge()
}

pub fn lib__BinaryOp__f32x4_gt() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_gt()
}

pub fn lib__BinaryOp__f32x4_le() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_le()
}

pub fn lib__BinaryOp__f32x4_lt() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_lt()
}

pub fn lib__BinaryOp__f32x4_max() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_max()
}

pub fn lib__BinaryOp__f32x4_min() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_min()
}

pub fn lib__BinaryOp__f32x4_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_mul()
}

pub fn lib__BinaryOp__f32x4_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_ne()
}

pub fn lib__BinaryOp__f32x4_pmax() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_pmax()
}

pub fn lib__BinaryOp__f32x4_pmin() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_pmin()
}

pub fn lib__BinaryOp__f32x4_relaxed_max() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_relaxed_max()
}

pub fn lib__BinaryOp__f32x4_relaxed_min() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_relaxed_min()
}

pub fn lib__BinaryOp__f32x4_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::f32x4_sub()
}

pub fn lib__BinaryOp__f64_add() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_add()
}

pub fn lib__BinaryOp__f64_copysign() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_copysign()
}

pub fn lib__BinaryOp__f64_div() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_div()
}

pub fn lib__BinaryOp__f64_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_eq()
}

pub fn lib__BinaryOp__f64_ge() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_ge()
}

pub fn lib__BinaryOp__f64_gt() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_gt()
}

pub fn lib__BinaryOp__f64_le() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_le()
}

pub fn lib__BinaryOp__f64_lt() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_lt()
}

pub fn lib__BinaryOp__f64_max() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_max()
}

pub fn lib__BinaryOp__f64_min() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_min()
}

pub fn lib__BinaryOp__f64_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_mul()
}

pub fn lib__BinaryOp__f64_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_ne()
}

pub fn lib__BinaryOp__f64_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::f64_sub()
}

pub fn lib__BinaryOp__f64x2_add() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_add()
}

pub fn lib__BinaryOp__f64x2_div() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_div()
}

pub fn lib__BinaryOp__f64x2_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_eq()
}

pub fn lib__BinaryOp__f64x2_ge() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_ge()
}

pub fn lib__BinaryOp__f64x2_gt() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_gt()
}

pub fn lib__BinaryOp__f64x2_le() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_le()
}

pub fn lib__BinaryOp__f64x2_lt() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_lt()
}

pub fn lib__BinaryOp__f64x2_max() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_max()
}

pub fn lib__BinaryOp__f64x2_min() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_min()
}

pub fn lib__BinaryOp__f64x2_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_mul()
}

pub fn lib__BinaryOp__f64x2_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_ne()
}

pub fn lib__BinaryOp__f64x2_pmax() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_pmax()
}

pub fn lib__BinaryOp__f64x2_pmin() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_pmin()
}

pub fn lib__BinaryOp__f64x2_relaxed_max() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_relaxed_max()
}

pub fn lib__BinaryOp__f64x2_relaxed_min() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_relaxed_min()
}

pub fn lib__BinaryOp__f64x2_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::f64x2_sub()
}

pub fn lib__BinaryOp__i16x8_add() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_add()
}

pub fn lib__BinaryOp__i16x8_add_sat_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_add_sat_s()
}

pub fn lib__BinaryOp__i16x8_add_sat_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_add_sat_u()
}

pub fn lib__BinaryOp__i16x8_avgr_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_avgr_u()
}

pub fn lib__BinaryOp__i16x8_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_eq()
}

pub fn lib__BinaryOp__i16x8_extmul_high_i8x16s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_extmul_high_i8x16s()
}

pub fn lib__BinaryOp__i16x8_extmul_high_i8x16u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_extmul_high_i8x16u()
}

pub fn lib__BinaryOp__i16x8_extmul_low_i8x16s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_extmul_low_i8x16s()
}

pub fn lib__BinaryOp__i16x8_extmul_low_i8x16u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_extmul_low_i8x16u()
}

pub fn lib__BinaryOp__i16x8_ge_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_ge_s()
}

pub fn lib__BinaryOp__i16x8_ge_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_ge_u()
}

pub fn lib__BinaryOp__i16x8_gt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_gt_s()
}

pub fn lib__BinaryOp__i16x8_gt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_gt_u()
}

pub fn lib__BinaryOp__i16x8_le_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_le_s()
}

pub fn lib__BinaryOp__i16x8_le_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_le_u()
}

pub fn lib__BinaryOp__i16x8_lt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_lt_s()
}

pub fn lib__BinaryOp__i16x8_lt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_lt_u()
}

pub fn lib__BinaryOp__i16x8_max_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_max_s()
}

pub fn lib__BinaryOp__i16x8_max_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_max_u()
}

pub fn lib__BinaryOp__i16x8_min_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_min_s()
}

pub fn lib__BinaryOp__i16x8_min_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_min_u()
}

pub fn lib__BinaryOp__i16x8_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_mul()
}

pub fn lib__BinaryOp__i16x8_narrow_i32x4s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_narrow_i32x4s()
}

pub fn lib__BinaryOp__i16x8_narrow_i32x4u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_narrow_i32x4u()
}

pub fn lib__BinaryOp__i16x8_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_ne()
}

pub fn lib__BinaryOp__i16x8_relaxed_dot_i8x16i7x16s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_relaxed_dot_i8x16i7x16s()
}

pub fn lib__BinaryOp__i16x8_relaxed_q15mulr_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_relaxed_q15mulr_s()
}

pub fn lib__BinaryOp__i16x8_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_sub()
}

pub fn lib__BinaryOp__i16x8_sub_sat_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_sub_sat_s()
}

pub fn lib__BinaryOp__i16x8_sub_sat_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8_sub_sat_u()
}

pub fn lib__BinaryOp__i16x8q15mulr_sat_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i16x8q15mulr_sat_s()
}

pub fn lib__BinaryOp__i32_add() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_add()
}

pub fn lib__BinaryOp__i32_and() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_and()
}

pub fn lib__BinaryOp__i32_div_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_div_s()
}

pub fn lib__BinaryOp__i32_div_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_div_u()
}

pub fn lib__BinaryOp__i32_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_eq()
}

pub fn lib__BinaryOp__i32_ge_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_ge_s()
}

pub fn lib__BinaryOp__i32_ge_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_ge_u()
}

pub fn lib__BinaryOp__i32_gt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_gt_s()
}

pub fn lib__BinaryOp__i32_gt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_gt_u()
}

pub fn lib__BinaryOp__i32_le_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_le_s()
}

pub fn lib__BinaryOp__i32_le_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_le_u()
}

pub fn lib__BinaryOp__i32_lt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_lt_s()
}

pub fn lib__BinaryOp__i32_lt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_lt_u()
}

pub fn lib__BinaryOp__i32_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_mul()
}

pub fn lib__BinaryOp__i32_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_ne()
}

pub fn lib__BinaryOp__i32_or() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_or()
}

pub fn lib__BinaryOp__i32_rem_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_rem_s()
}

pub fn lib__BinaryOp__i32_rem_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_rem_u()
}

pub fn lib__BinaryOp__i32_rotl() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_rotl()
}

pub fn lib__BinaryOp__i32_rotr() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_rotr()
}

pub fn lib__BinaryOp__i32_shl() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_shl()
}

pub fn lib__BinaryOp__i32_shr_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_shr_s()
}

pub fn lib__BinaryOp__i32_shr_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_shr_u()
}

pub fn lib__BinaryOp__i32_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_sub()
}

pub fn lib__BinaryOp__i32_xor() -> @lib.BinaryOp {
  @lib.BinaryOp::i32_xor()
}

pub fn lib__BinaryOp__i32x4_add() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_add()
}

pub fn lib__BinaryOp__i32x4_dot_i16x8s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_dot_i16x8s()
}

pub fn lib__BinaryOp__i32x4_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_eq()
}

pub fn lib__BinaryOp__i32x4_extmul_high_i16x8s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_extmul_high_i16x8s()
}

pub fn lib__BinaryOp__i32x4_extmul_high_i16x8u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_extmul_high_i16x8u()
}

pub fn lib__BinaryOp__i32x4_extmul_low_i16x8s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_extmul_low_i16x8s()
}

pub fn lib__BinaryOp__i32x4_extmul_low_i16x8u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_extmul_low_i16x8u()
}

pub fn lib__BinaryOp__i32x4_ge_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_ge_s()
}

pub fn lib__BinaryOp__i32x4_ge_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_ge_u()
}

pub fn lib__BinaryOp__i32x4_gt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_gt_s()
}

pub fn lib__BinaryOp__i32x4_gt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_gt_u()
}

pub fn lib__BinaryOp__i32x4_le_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_le_s()
}

pub fn lib__BinaryOp__i32x4_le_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_le_u()
}

pub fn lib__BinaryOp__i32x4_lt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_lt_s()
}

pub fn lib__BinaryOp__i32x4_lt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_lt_u()
}

pub fn lib__BinaryOp__i32x4_max_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_max_s()
}

pub fn lib__BinaryOp__i32x4_max_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_max_u()
}

pub fn lib__BinaryOp__i32x4_min_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_min_s()
}

pub fn lib__BinaryOp__i32x4_min_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_min_u()
}

pub fn lib__BinaryOp__i32x4_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_mul()
}

pub fn lib__BinaryOp__i32x4_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_ne()
}

pub fn lib__BinaryOp__i32x4_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::i32x4_sub()
}

pub fn lib__BinaryOp__i64_add() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_add()
}

pub fn lib__BinaryOp__i64_and() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_and()
}

pub fn lib__BinaryOp__i64_div_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_div_s()
}

pub fn lib__BinaryOp__i64_div_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_div_u()
}

pub fn lib__BinaryOp__i64_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_eq()
}

pub fn lib__BinaryOp__i64_ge_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_ge_s()
}

pub fn lib__BinaryOp__i64_ge_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_ge_u()
}

pub fn lib__BinaryOp__i64_gt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_gt_s()
}

pub fn lib__BinaryOp__i64_gt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_gt_u()
}

pub fn lib__BinaryOp__i64_le_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_le_s()
}

pub fn lib__BinaryOp__i64_le_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_le_u()
}

pub fn lib__BinaryOp__i64_lt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_lt_s()
}

pub fn lib__BinaryOp__i64_lt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_lt_u()
}

pub fn lib__BinaryOp__i64_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_mul()
}

pub fn lib__BinaryOp__i64_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_ne()
}

pub fn lib__BinaryOp__i64_or() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_or()
}

pub fn lib__BinaryOp__i64_rem_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_rem_s()
}

pub fn lib__BinaryOp__i64_rem_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_rem_u()
}

pub fn lib__BinaryOp__i64_rotl() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_rotl()
}

pub fn lib__BinaryOp__i64_rotr() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_rotr()
}

pub fn lib__BinaryOp__i64_shl() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_shl()
}

pub fn lib__BinaryOp__i64_shr_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_shr_s()
}

pub fn lib__BinaryOp__i64_shr_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_shr_u()
}

pub fn lib__BinaryOp__i64_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_sub()
}

pub fn lib__BinaryOp__i64_xor() -> @lib.BinaryOp {
  @lib.BinaryOp::i64_xor()
}

pub fn lib__BinaryOp__i64x2_add() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_add()
}

pub fn lib__BinaryOp__i64x2_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_eq()
}

pub fn lib__BinaryOp__i64x2_extmul_high_i32x4s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_extmul_high_i32x4s()
}

pub fn lib__BinaryOp__i64x2_extmul_high_i32x4u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_extmul_high_i32x4u()
}

pub fn lib__BinaryOp__i64x2_extmul_low_i32x4s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_extmul_low_i32x4s()
}

pub fn lib__BinaryOp__i64x2_extmul_low_i32x4u() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_extmul_low_i32x4u()
}

pub fn lib__BinaryOp__i64x2_ge_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_ge_s()
}

pub fn lib__BinaryOp__i64x2_gt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_gt_s()
}

pub fn lib__BinaryOp__i64x2_le_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_le_s()
}

pub fn lib__BinaryOp__i64x2_lt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_lt_s()
}

pub fn lib__BinaryOp__i64x2_mul() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_mul()
}

pub fn lib__BinaryOp__i64x2_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_ne()
}

pub fn lib__BinaryOp__i64x2_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::i64x2_sub()
}

pub fn lib__BinaryOp__i8x16_add() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_add()
}

pub fn lib__BinaryOp__i8x16_add_sat_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_add_sat_s()
}

pub fn lib__BinaryOp__i8x16_add_sat_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_add_sat_u()
}

pub fn lib__BinaryOp__i8x16_avgr_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_avgr_u()
}

pub fn lib__BinaryOp__i8x16_eq() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_eq()
}

pub fn lib__BinaryOp__i8x16_ge_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_ge_s()
}

pub fn lib__BinaryOp__i8x16_ge_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_ge_u()
}

pub fn lib__BinaryOp__i8x16_gt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_gt_s()
}

pub fn lib__BinaryOp__i8x16_gt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_gt_u()
}

pub fn lib__BinaryOp__i8x16_le_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_le_s()
}

pub fn lib__BinaryOp__i8x16_le_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_le_u()
}

pub fn lib__BinaryOp__i8x16_lt_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_lt_s()
}

pub fn lib__BinaryOp__i8x16_lt_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_lt_u()
}

pub fn lib__BinaryOp__i8x16_max_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_max_s()
}

pub fn lib__BinaryOp__i8x16_max_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_max_u()
}

pub fn lib__BinaryOp__i8x16_min_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_min_s()
}

pub fn lib__BinaryOp__i8x16_min_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_min_u()
}

pub fn lib__BinaryOp__i8x16_narrow_i16x8s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_narrow_i16x8s()
}

pub fn lib__BinaryOp__i8x16_narrow_i16x8u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_narrow_i16x8u()
}

pub fn lib__BinaryOp__i8x16_ne() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_ne()
}

pub fn lib__BinaryOp__i8x16_sub() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_sub()
}

pub fn lib__BinaryOp__i8x16_sub_sat_s() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_sub_sat_s()
}

pub fn lib__BinaryOp__i8x16_sub_sat_u() -> @lib.BinaryOp {
  @lib.BinaryOp::i8x16_sub_sat_u()
}

pub fn lib__BinaryOp__v128_and() -> @lib.BinaryOp {
  @lib.BinaryOp::v128_and()
}

pub fn lib__BinaryOp__v128_andnot() -> @lib.BinaryOp {
  @lib.BinaryOp::v128_andnot()
}

pub fn lib__BinaryOp__v128_or() -> @lib.BinaryOp {
  @lib.BinaryOp::v128_or()
}

pub fn lib__BinaryOp__v128_xor() -> @lib.BinaryOp {
  @lib.BinaryOp::v128_xor()
}

pub fn lib__BlockType__type_idx(arg0 : @lib.TypeIdx) -> @lib.BlockType {
  @lib.BlockType::type_idx(arg0)
}

pub fn lib__BlockType__val_type(arg0 : @lib.ValType) -> @lib.BlockType {
  @lib.BlockType::val_type(arg0)
}

pub fn lib__BlockType__void_() -> @lib.BlockType {
  @lib.BlockType::void_()
}

pub fn lib__CastOp__new(arg0 : Bool, arg1 : Bool) -> @lib.CastOp {
  @lib.CastOp::new(arg0, arg1)
}

pub fn lib__CastOp__source_nullable(arg0 : @lib.CastOp) -> Bool {
  @lib.CastOp::source_nullable(arg0)
}

pub fn lib__CastOp__target_nullable(arg0 : @lib.CastOp) -> Bool {
  @lib.CastOp::target_nullable(arg0)
}

pub fn lib__Catch__all(arg0 : @lib.LabelIdx) -> @lib.Catch {
  @lib.Catch::all(arg0)
}

pub fn lib__Catch__all_ref(arg0 : @lib.LabelIdx) -> @lib.Catch {
  @lib.Catch::all_ref(arg0)
}

pub fn lib__Catch__new(arg0 : @lib.TagIdx, arg1 : @lib.LabelIdx) -> @lib.Catch {
  @lib.Catch::new(arg0, arg1)
}

pub fn lib__Catch__ref_(arg0 : @lib.TagIdx, arg1 : @lib.LabelIdx) -> @lib.Catch {
  @lib.Catch::ref_(arg0, arg1)
}

pub fn lib__CodeSec__inner(arg0 : @lib.CodeSec) -> Array[@lib.Func] {
  @lib.CodeSec::inner(arg0)
}

pub fn lib__CodeSec__new(arg0 : Array[@lib.Func]) -> @lib.CodeSec {
  @lib.CodeSec::new(arg0)
}

pub fn lib__CompType__array(arg0 : @lib.FieldType) -> @lib.CompType {
  @lib.CompType::array(arg0)
}

pub fn lib__CompType__func(arg0 : Array[@lib.ValType], arg1 : Array[@lib.ValType]) -> @lib.CompType {
  @lib.CompType::func(arg0, arg1)
}

pub fn lib__CompType__struct_(arg0 : Array[@lib.FieldType]) -> @lib.CompType {
  @lib.CompType::struct_(arg0)
}

pub fn lib__CustomSec__new(arg0 : @lib.Name, arg1 : Bytes) -> @lib.CustomSec {
  @lib.CustomSec::new(arg0, arg1)
}

pub fn lib__Data__new(arg0 : @lib.DataMode, arg1 : Bytes) -> @lib.Data {
  @lib.Data::new(arg0, arg1)
}

pub fn lib__DataCntSec__inner(arg0 : @lib.DataCntSec) -> @lib.U32 {
  @lib.DataCntSec::inner(arg0)
}

pub fn lib__DataCntSec__new(arg0 : @lib.U32) -> @lib.DataCntSec {
  @lib.DataCntSec::new(arg0)
}

pub fn lib__DataIdx__inner(arg0 : @lib.DataIdx) -> UInt {
  @lib.DataIdx::inner(arg0)
}

pub fn lib__DataIdx__new(arg0 : UInt) -> @lib.DataIdx {
  @lib.DataIdx::new(arg0)
}

pub fn lib__DataMode__active(arg0 : @lib.MemIdx, arg1 : @lib.Expr) -> @lib.DataMode {
  @lib.DataMode::active(arg0, arg1)
}

pub fn lib__DataMode__passive() -> @lib.DataMode {
  @lib.DataMode::passive()
}

pub fn lib__DataSec__inner(arg0 : @lib.DataSec) -> Array[@lib.Data] {
  @lib.DataSec::inner(arg0)
}

pub fn lib__DataSec__new(arg0 : Array[@lib.Data]) -> @lib.DataSec {
  @lib.DataSec::new(arg0)
}

pub fn lib__DefType__new(arg0 : @lib.RecType, arg1 : UInt) -> @lib.DefType {
  @lib.DefType::new(arg0, arg1)
}

pub fn lib__DefType__project(arg0 : @lib.DefType) -> @lib.SubType? {
  @lib.DefType::project(arg0)
}

pub fn lib__Elem__new(arg0 : @lib.ElemMode, arg1 : @lib.ElemKind) -> @lib.Elem {
  @lib.Elem::new(arg0, arg1)
}

pub fn lib__Elem__reftype(arg0 : @lib.Elem) -> @lib.RefType {
  @lib.Elem::reftype(arg0)
}

pub fn lib__ElemIdx__inner(arg0 : @lib.ElemIdx) -> UInt {
  @lib.ElemIdx::inner(arg0)
}

pub fn lib__ElemIdx__new(arg0 : UInt) -> @lib.ElemIdx {
  @lib.ElemIdx::new(arg0)
}

pub fn lib__ElemKind__func_exprs(arg0 : Array[@lib.Expr]) -> @lib.ElemKind {
  @lib.ElemKind::func_exprs(arg0)
}

pub fn lib__ElemKind__funcs(arg0 : Array[@lib.FuncIdx]) -> @lib.ElemKind {
  @lib.ElemKind::funcs(arg0)
}

pub fn lib__ElemKind__typed_exprs(arg0 : @lib.RefType, arg1 : Array[@lib.Expr]) -> @lib.ElemKind {
  @lib.ElemKind::typed_exprs(arg0, arg1)
}

pub fn lib__ElemMode__active(arg0 : @lib.TableIdx, arg1 : @lib.Expr) -> @lib.ElemMode {
  @lib.ElemMode::active(arg0, arg1)
}

pub fn lib__ElemMode__declarative() -> @lib.ElemMode {
  @lib.ElemMode::declarative()
}

pub fn lib__ElemMode__passive() -> @lib.ElemMode {
  @lib.ElemMode::passive()
}

pub fn lib__ElemSec__inner(arg0 : @lib.ElemSec) -> Array[@lib.Elem] {
  @lib.ElemSec::inner(arg0)
}

pub fn lib__ElemSec__new(arg0 : Array[@lib.Elem]) -> @lib.ElemSec {
  @lib.ElemSec::new(arg0)
}

pub fn lib__Export__new(arg0 : @lib.Name, arg1 : @lib.ExternIdx) -> @lib.Export {
  @lib.Export::new(arg0, arg1)
}

pub fn lib__ExportSec__inner(arg0 : @lib.ExportSec) -> Array[@lib.Export] {
  @lib.ExportSec::inner(arg0)
}

pub fn lib__ExportSec__new(arg0 : Array[@lib.Export]) -> @lib.ExportSec {
  @lib.ExportSec::new(arg0)
}

pub fn lib__Expr__inner(arg0 : @lib.Expr) -> Array[@lib.Instruction] {
  @lib.Expr::inner(arg0)
}

pub fn lib__Expr__new(arg0 : Array[@lib.Instruction]) -> @lib.Expr {
  @lib.Expr::new(arg0)
}

pub fn lib__ExternIdx__func(arg0 : @lib.FuncIdx) -> @lib.ExternIdx {
  @lib.ExternIdx::func(arg0)
}

pub fn lib__ExternIdx__global(arg0 : @lib.GlobalIdx) -> @lib.ExternIdx {
  @lib.ExternIdx::global(arg0)
}

pub fn lib__ExternIdx__mem(arg0 : @lib.MemIdx) -> @lib.ExternIdx {
  @lib.ExternIdx::mem(arg0)
}

pub fn lib__ExternIdx__table(arg0 : @lib.TableIdx) -> @lib.ExternIdx {
  @lib.ExternIdx::table(arg0)
}

pub fn lib__ExternIdx__tag(arg0 : @lib.TagIdx) -> @lib.ExternIdx {
  @lib.ExternIdx::tag(arg0)
}

pub fn lib__ExternType__func(arg0 : @lib.TypeIdx) -> @lib.ExternType {
  @lib.ExternType::func(arg0)
}

pub fn lib__ExternType__global(arg0 : @lib.GlobalType) -> @lib.ExternType {
  @lib.ExternType::global(arg0)
}

pub fn lib__ExternType__mem(arg0 : @lib.MemType) -> @lib.ExternType {
  @lib.ExternType::mem(arg0)
}

pub fn lib__ExternType__table(arg0 : @lib.TableType) -> @lib.ExternType {
  @lib.ExternType::table(arg0)
}

pub fn lib__ExternType__tag(arg0 : @lib.TagType) -> @lib.ExternType {
  @lib.ExternType::tag(arg0)
}

pub fn lib__ExtractLaneOp__f32x4_extract_lane() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::f32x4_extract_lane()
}

pub fn lib__ExtractLaneOp__f64x2_extract_lane() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::f64x2_extract_lane()
}

pub fn lib__ExtractLaneOp__i16x8_extract_lane_s() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::i16x8_extract_lane_s()
}

pub fn lib__ExtractLaneOp__i16x8_extract_lane_u() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::i16x8_extract_lane_u()
}

pub fn lib__ExtractLaneOp__i32x4_extract_lane() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::i32x4_extract_lane()
}

pub fn lib__ExtractLaneOp__i64x2_extract_lane() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::i64x2_extract_lane()
}

pub fn lib__ExtractLaneOp__i8x16_extract_lane_s() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::i8x16_extract_lane_s()
}

pub fn lib__ExtractLaneOp__i8x16_extract_lane_u() -> @lib.ExtractLaneOp {
  @lib.ExtractLaneOp::i8x16_extract_lane_u()
}

pub fn lib__F32__inner(arg0 : @lib.F32) -> Float {
  @lib.F32::inner(arg0)
}

pub fn lib__F64__inner(arg0 : @lib.F64) -> Double {
  @lib.F64::inner(arg0)
}

pub fn lib__FieldType__get_storage_type(arg0 : @lib.FieldType) -> @lib.StorageType {
  @lib.FieldType::get_storage_type(arg0)
}

pub fn lib__FieldType__is_mutable(arg0 : @lib.FieldType) -> Bool {
  @lib.FieldType::is_mutable(arg0)
}

pub fn lib__FieldType__new(arg0 : @lib.StorageType, arg1 : @lib.Mut) -> @lib.FieldType {
  @lib.FieldType::new(arg0, arg1)
}

pub fn lib__FieldType__unpack(arg0 : @lib.FieldType) -> @lib.ValType {
  @lib.FieldType::unpack(arg0)
}

pub fn lib__Func__new(arg0 : Array[@lib.Locals], arg1 : @lib.Expr) -> @lib.Func {
  @lib.Func::new(arg0, arg1)
}

pub fn lib__Func__t_func(arg0 : Array[@lib.ValType], arg1 : @lib.TExpr) -> @lib.Func {
  @lib.Func::t_func(arg0, arg1)
}

pub fn lib__FuncIdx__inner(arg0 : @lib.FuncIdx) -> UInt {
  @lib.FuncIdx::inner(arg0)
}

pub fn lib__FuncIdx__new(arg0 : UInt) -> @lib.FuncIdx {
  @lib.FuncIdx::new(arg0)
}

pub fn lib__FuncSec__inner(arg0 : @lib.FuncSec) -> Array[@lib.TypeIdx] {
  @lib.FuncSec::inner(arg0)
}

pub fn lib__FuncSec__new(arg0 : Array[@lib.TypeIdx]) -> @lib.FuncSec {
  @lib.FuncSec::new(arg0)
}

pub fn lib__FuncType__new(arg0 : Array[@lib.ValType], arg1 : Array[@lib.ValType]) -> @lib.FuncType {
  @lib.FuncType::new(arg0, arg1)
}

pub fn lib__Global__new(arg0 : @lib.GlobalType, arg1 : @lib.Expr) -> @lib.Global {
  @lib.Global::new(arg0, arg1)
}

pub fn lib__GlobalIdx__inner(arg0 : @lib.GlobalIdx) -> UInt {
  @lib.GlobalIdx::inner(arg0)
}

pub fn lib__GlobalIdx__new(arg0 : UInt) -> @lib.GlobalIdx {
  @lib.GlobalIdx::new(arg0)
}

pub fn lib__GlobalSec__inner(arg0 : @lib.GlobalSec) -> Array[@lib.Global] {
  @lib.GlobalSec::inner(arg0)
}

pub fn lib__GlobalSec__new(arg0 : Array[@lib.Global]) -> @lib.GlobalSec {
  @lib.GlobalSec::new(arg0)
}

pub fn lib__GlobalType__new(arg0 : @lib.ValType, arg1 : Bool) -> @lib.GlobalType {
  @lib.GlobalType::new(arg0, arg1)
}

pub fn lib__HeapType__abs(arg0 : @lib.AbsHeapType) -> @lib.HeapType {
  @lib.HeapType::abs(arg0)
}

pub fn lib__HeapType__bottom() -> @lib.HeapType {
  @lib.HeapType::bottom()
}

pub fn lib__HeapType__def_type(arg0 : @lib.DefType) -> @lib.HeapType {
  @lib.HeapType::def_type(arg0)
}

pub fn lib__HeapType__is_array(arg0 : @lib.HeapType) -> Bool {
  @lib.HeapType::is_array(arg0)
}

pub fn lib__HeapType__is_gc_aggregate(arg0 : @lib.HeapType) -> Bool {
  @lib.HeapType::is_gc_aggregate(arg0)
}

pub fn lib__HeapType__is_struct(arg0 : @lib.HeapType) -> Bool {
  @lib.HeapType::is_struct(arg0)
}

pub fn lib__HeapType__new(arg0 : @lib.TypeIdx) -> @lib.HeapType {
  @lib.HeapType::new(arg0)
}

pub fn lib__I32__inner(arg0 : @lib.I32) -> Int {
  @lib.I32::inner(arg0)
}

pub fn lib__I64__inner(arg0 : @lib.I64) -> Int64 {
  @lib.I64::inner(arg0)
}

pub fn lib__Import__new(arg0 : @lib.Name, arg1 : @lib.Name, arg2 : @lib.ExternType) -> @lib.Import {
  @lib.Import::new(arg0, arg1, arg2)
}

pub fn lib__ImportSec__inner(arg0 : @lib.ImportSec) -> Array[@lib.Import] {
  @lib.ImportSec::inner(arg0)
}

pub fn lib__ImportSec__new(arg0 : Array[@lib.Import]) -> @lib.ImportSec {
  @lib.ImportSec::new(arg0)
}

pub fn lib__Instruction__any_convert_extern() -> @lib.Instruction {
  @lib.Instruction::any_convert_extern()
}

pub fn lib__Instruction__array_copy(arg0 : @lib.TypeIdx, arg1 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_copy(arg0, arg1)
}

pub fn lib__Instruction__array_fill(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_fill(arg0)
}

pub fn lib__Instruction__array_get(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_get(arg0)
}

pub fn lib__Instruction__array_get_s(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_get_s(arg0)
}

pub fn lib__Instruction__array_get_u(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_get_u(arg0)
}

pub fn lib__Instruction__array_init_data(arg0 : @lib.TypeIdx, arg1 : @lib.DataIdx) -> @lib.Instruction {
  @lib.Instruction::array_init_data(arg0, arg1)
}

pub fn lib__Instruction__array_init_elem(arg0 : @lib.TypeIdx, arg1 : @lib.ElemIdx) -> @lib.Instruction {
  @lib.Instruction::array_init_elem(arg0, arg1)
}

pub fn lib__Instruction__array_len() -> @lib.Instruction {
  @lib.Instruction::array_len()
}

pub fn lib__Instruction__array_new(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_new(arg0)
}

pub fn lib__Instruction__array_new_data(arg0 : @lib.TypeIdx, arg1 : @lib.DataIdx) -> @lib.Instruction {
  @lib.Instruction::array_new_data(arg0, arg1)
}

pub fn lib__Instruction__array_new_default(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_new_default(arg0)
}

pub fn lib__Instruction__array_new_elem(arg0 : @lib.TypeIdx, arg1 : @lib.ElemIdx) -> @lib.Instruction {
  @lib.Instruction::array_new_elem(arg0, arg1)
}

pub fn lib__Instruction__array_new_fixed(arg0 : @lib.TypeIdx, arg1 : @lib.U32) -> @lib.Instruction {
  @lib.Instruction::array_new_fixed(arg0, arg1)
}

pub fn lib__Instruction__array_set(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::array_set(arg0)
}

pub fn lib__Instruction__atomic_cmpxchg(arg0 : @lib.AtomicCmpxchgOp, arg1 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::atomic_cmpxchg(arg0, arg1)
}

pub fn lib__Instruction__atomic_fence() -> @lib.Instruction {
  @lib.Instruction::atomic_fence()
}

pub fn lib__Instruction__atomic_rmw(arg0 : @lib.AtomicRmwOp, arg1 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::atomic_rmw(arg0, arg1)
}

pub fn lib__Instruction__block(arg0 : @lib.BlockType, arg1 : @lib.Expr) -> @lib.Instruction {
  @lib.Instruction::block(arg0, arg1)
}

pub fn lib__Instruction__br(arg0 : @lib.LabelIdx) -> @lib.Instruction {
  @lib.Instruction::br(arg0)
}

pub fn lib__Instruction__br_if(arg0 : @lib.LabelIdx) -> @lib.Instruction {
  @lib.Instruction::br_if(arg0)
}

pub fn lib__Instruction__br_on_cast(arg0 : @lib.LabelIdx, arg1 : Bool, arg2 : @lib.HeapType, arg3 : Bool, arg4 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::br_on_cast(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__Instruction__br_on_cast_fail(arg0 : @lib.LabelIdx, arg1 : Bool, arg2 : @lib.HeapType, arg3 : Bool, arg4 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::br_on_cast_fail(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__Instruction__br_on_non_null(arg0 : @lib.LabelIdx) -> @lib.Instruction {
  @lib.Instruction::br_on_non_null(arg0)
}

pub fn lib__Instruction__br_on_null(arg0 : @lib.LabelIdx) -> @lib.Instruction {
  @lib.Instruction::br_on_null(arg0)
}

pub fn lib__Instruction__br_table(arg0 : Array[@lib.LabelIdx], arg1 : @lib.LabelIdx) -> @lib.Instruction {
  @lib.Instruction::br_table(arg0, arg1)
}

pub fn lib__Instruction__call(arg0 : @lib.FuncIdx) -> @lib.Instruction {
  @lib.Instruction::call(arg0)
}

pub fn lib__Instruction__call_indirect(arg0 : @lib.TypeIdx, arg1 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::call_indirect(arg0, arg1)
}

pub fn lib__Instruction__call_ref(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::call_ref(arg0)
}

pub fn lib__Instruction__data_drop(arg0 : @lib.DataIdx) -> @lib.Instruction {
  @lib.Instruction::data_drop(arg0)
}

pub fn lib__Instruction__drop() -> @lib.Instruction {
  @lib.Instruction::drop()
}

pub fn lib__Instruction__elem_drop(arg0 : @lib.ElemIdx) -> @lib.Instruction {
  @lib.Instruction::elem_drop(arg0)
}

pub fn lib__Instruction__extern_convert_any() -> @lib.Instruction {
  @lib.Instruction::extern_convert_any()
}

pub fn lib__Instruction__f32_abs() -> @lib.Instruction {
  @lib.Instruction::f32_abs()
}

pub fn lib__Instruction__f32_add() -> @lib.Instruction {
  @lib.Instruction::f32_add()
}

pub fn lib__Instruction__f32_ceil() -> @lib.Instruction {
  @lib.Instruction::f32_ceil()
}

pub fn lib__Instruction__f32_const(arg0 : @lib.F32) -> @lib.Instruction {
  @lib.Instruction::f32_const(arg0)
}

pub fn lib__Instruction__f32_convert_i32s() -> @lib.Instruction {
  @lib.Instruction::f32_convert_i32s()
}

pub fn lib__Instruction__f32_convert_i32u() -> @lib.Instruction {
  @lib.Instruction::f32_convert_i32u()
}

pub fn lib__Instruction__f32_convert_i64s() -> @lib.Instruction {
  @lib.Instruction::f32_convert_i64s()
}

pub fn lib__Instruction__f32_convert_i64u() -> @lib.Instruction {
  @lib.Instruction::f32_convert_i64u()
}

pub fn lib__Instruction__f32_copysign() -> @lib.Instruction {
  @lib.Instruction::f32_copysign()
}

pub fn lib__Instruction__f32_demote_f64() -> @lib.Instruction {
  @lib.Instruction::f32_demote_f64()
}

pub fn lib__Instruction__f32_div() -> @lib.Instruction {
  @lib.Instruction::f32_div()
}

pub fn lib__Instruction__f32_eq() -> @lib.Instruction {
  @lib.Instruction::f32_eq()
}

pub fn lib__Instruction__f32_floor() -> @lib.Instruction {
  @lib.Instruction::f32_floor()
}

pub fn lib__Instruction__f32_ge() -> @lib.Instruction {
  @lib.Instruction::f32_ge()
}

pub fn lib__Instruction__f32_gt() -> @lib.Instruction {
  @lib.Instruction::f32_gt()
}

pub fn lib__Instruction__f32_le() -> @lib.Instruction {
  @lib.Instruction::f32_le()
}

pub fn lib__Instruction__f32_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::f32_load(arg0)
}

pub fn lib__Instruction__f32_lt() -> @lib.Instruction {
  @lib.Instruction::f32_lt()
}

pub fn lib__Instruction__f32_max() -> @lib.Instruction {
  @lib.Instruction::f32_max()
}

pub fn lib__Instruction__f32_min() -> @lib.Instruction {
  @lib.Instruction::f32_min()
}

pub fn lib__Instruction__f32_mul() -> @lib.Instruction {
  @lib.Instruction::f32_mul()
}

pub fn lib__Instruction__f32_ne() -> @lib.Instruction {
  @lib.Instruction::f32_ne()
}

pub fn lib__Instruction__f32_nearest() -> @lib.Instruction {
  @lib.Instruction::f32_nearest()
}

pub fn lib__Instruction__f32_neg() -> @lib.Instruction {
  @lib.Instruction::f32_neg()
}

pub fn lib__Instruction__f32_reinterpret_i32() -> @lib.Instruction {
  @lib.Instruction::f32_reinterpret_i32()
}

pub fn lib__Instruction__f32_sqrt() -> @lib.Instruction {
  @lib.Instruction::f32_sqrt()
}

pub fn lib__Instruction__f32_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::f32_store(arg0)
}

pub fn lib__Instruction__f32_sub() -> @lib.Instruction {
  @lib.Instruction::f32_sub()
}

pub fn lib__Instruction__f32_trunc() -> @lib.Instruction {
  @lib.Instruction::f32_trunc()
}

pub fn lib__Instruction__f32x4_abs() -> @lib.Instruction {
  @lib.Instruction::f32x4_abs()
}

pub fn lib__Instruction__f32x4_add() -> @lib.Instruction {
  @lib.Instruction::f32x4_add()
}

pub fn lib__Instruction__f32x4_ceil() -> @lib.Instruction {
  @lib.Instruction::f32x4_ceil()
}

pub fn lib__Instruction__f32x4_convert_i32x4s() -> @lib.Instruction {
  @lib.Instruction::f32x4_convert_i32x4s()
}

pub fn lib__Instruction__f32x4_convert_i32x4u() -> @lib.Instruction {
  @lib.Instruction::f32x4_convert_i32x4u()
}

pub fn lib__Instruction__f32x4_demote_f64x2_zero() -> @lib.Instruction {
  @lib.Instruction::f32x4_demote_f64x2_zero()
}

pub fn lib__Instruction__f32x4_div() -> @lib.Instruction {
  @lib.Instruction::f32x4_div()
}

pub fn lib__Instruction__f32x4_eq() -> @lib.Instruction {
  @lib.Instruction::f32x4_eq()
}

pub fn lib__Instruction__f32x4_extract_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::f32x4_extract_lane(arg0)
}

pub fn lib__Instruction__f32x4_floor() -> @lib.Instruction {
  @lib.Instruction::f32x4_floor()
}

pub fn lib__Instruction__f32x4_ge() -> @lib.Instruction {
  @lib.Instruction::f32x4_ge()
}

pub fn lib__Instruction__f32x4_gt() -> @lib.Instruction {
  @lib.Instruction::f32x4_gt()
}

pub fn lib__Instruction__f32x4_le() -> @lib.Instruction {
  @lib.Instruction::f32x4_le()
}

pub fn lib__Instruction__f32x4_lt() -> @lib.Instruction {
  @lib.Instruction::f32x4_lt()
}

pub fn lib__Instruction__f32x4_max() -> @lib.Instruction {
  @lib.Instruction::f32x4_max()
}

pub fn lib__Instruction__f32x4_min() -> @lib.Instruction {
  @lib.Instruction::f32x4_min()
}

pub fn lib__Instruction__f32x4_mul() -> @lib.Instruction {
  @lib.Instruction::f32x4_mul()
}

pub fn lib__Instruction__f32x4_ne() -> @lib.Instruction {
  @lib.Instruction::f32x4_ne()
}

pub fn lib__Instruction__f32x4_nearest() -> @lib.Instruction {
  @lib.Instruction::f32x4_nearest()
}

pub fn lib__Instruction__f32x4_neg() -> @lib.Instruction {
  @lib.Instruction::f32x4_neg()
}

pub fn lib__Instruction__f32x4_pmax() -> @lib.Instruction {
  @lib.Instruction::f32x4_pmax()
}

pub fn lib__Instruction__f32x4_pmin() -> @lib.Instruction {
  @lib.Instruction::f32x4_pmin()
}

pub fn lib__Instruction__f32x4_relaxed_madd() -> @lib.Instruction {
  @lib.Instruction::f32x4_relaxed_madd()
}

pub fn lib__Instruction__f32x4_relaxed_max() -> @lib.Instruction {
  @lib.Instruction::f32x4_relaxed_max()
}

pub fn lib__Instruction__f32x4_relaxed_min() -> @lib.Instruction {
  @lib.Instruction::f32x4_relaxed_min()
}

pub fn lib__Instruction__f32x4_relaxed_nmadd() -> @lib.Instruction {
  @lib.Instruction::f32x4_relaxed_nmadd()
}

pub fn lib__Instruction__f32x4_replace_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::f32x4_replace_lane(arg0)
}

pub fn lib__Instruction__f32x4_splat() -> @lib.Instruction {
  @lib.Instruction::f32x4_splat()
}

pub fn lib__Instruction__f32x4_sqrt() -> @lib.Instruction {
  @lib.Instruction::f32x4_sqrt()
}

pub fn lib__Instruction__f32x4_sub() -> @lib.Instruction {
  @lib.Instruction::f32x4_sub()
}

pub fn lib__Instruction__f32x4_trunc() -> @lib.Instruction {
  @lib.Instruction::f32x4_trunc()
}

pub fn lib__Instruction__f64_abs() -> @lib.Instruction {
  @lib.Instruction::f64_abs()
}

pub fn lib__Instruction__f64_add() -> @lib.Instruction {
  @lib.Instruction::f64_add()
}

pub fn lib__Instruction__f64_ceil() -> @lib.Instruction {
  @lib.Instruction::f64_ceil()
}

pub fn lib__Instruction__f64_const(arg0 : @lib.F64) -> @lib.Instruction {
  @lib.Instruction::f64_const(arg0)
}

pub fn lib__Instruction__f64_convert_i32s() -> @lib.Instruction {
  @lib.Instruction::f64_convert_i32s()
}

pub fn lib__Instruction__f64_convert_i32u() -> @lib.Instruction {
  @lib.Instruction::f64_convert_i32u()
}

pub fn lib__Instruction__f64_convert_i64s() -> @lib.Instruction {
  @lib.Instruction::f64_convert_i64s()
}

pub fn lib__Instruction__f64_convert_i64u() -> @lib.Instruction {
  @lib.Instruction::f64_convert_i64u()
}

pub fn lib__Instruction__f64_copysign() -> @lib.Instruction {
  @lib.Instruction::f64_copysign()
}

pub fn lib__Instruction__f64_div() -> @lib.Instruction {
  @lib.Instruction::f64_div()
}

pub fn lib__Instruction__f64_eq() -> @lib.Instruction {
  @lib.Instruction::f64_eq()
}

pub fn lib__Instruction__f64_floor() -> @lib.Instruction {
  @lib.Instruction::f64_floor()
}

pub fn lib__Instruction__f64_ge() -> @lib.Instruction {
  @lib.Instruction::f64_ge()
}

pub fn lib__Instruction__f64_gt() -> @lib.Instruction {
  @lib.Instruction::f64_gt()
}

pub fn lib__Instruction__f64_le() -> @lib.Instruction {
  @lib.Instruction::f64_le()
}

pub fn lib__Instruction__f64_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::f64_load(arg0)
}

pub fn lib__Instruction__f64_lt() -> @lib.Instruction {
  @lib.Instruction::f64_lt()
}

pub fn lib__Instruction__f64_max() -> @lib.Instruction {
  @lib.Instruction::f64_max()
}

pub fn lib__Instruction__f64_min() -> @lib.Instruction {
  @lib.Instruction::f64_min()
}

pub fn lib__Instruction__f64_mul() -> @lib.Instruction {
  @lib.Instruction::f64_mul()
}

pub fn lib__Instruction__f64_ne() -> @lib.Instruction {
  @lib.Instruction::f64_ne()
}

pub fn lib__Instruction__f64_nearest() -> @lib.Instruction {
  @lib.Instruction::f64_nearest()
}

pub fn lib__Instruction__f64_neg() -> @lib.Instruction {
  @lib.Instruction::f64_neg()
}

pub fn lib__Instruction__f64_promote_f32() -> @lib.Instruction {
  @lib.Instruction::f64_promote_f32()
}

pub fn lib__Instruction__f64_reinterpret_i64() -> @lib.Instruction {
  @lib.Instruction::f64_reinterpret_i64()
}

pub fn lib__Instruction__f64_sqrt() -> @lib.Instruction {
  @lib.Instruction::f64_sqrt()
}

pub fn lib__Instruction__f64_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::f64_store(arg0)
}

pub fn lib__Instruction__f64_sub() -> @lib.Instruction {
  @lib.Instruction::f64_sub()
}

pub fn lib__Instruction__f64_trunc() -> @lib.Instruction {
  @lib.Instruction::f64_trunc()
}

pub fn lib__Instruction__f64x2_abs() -> @lib.Instruction {
  @lib.Instruction::f64x2_abs()
}

pub fn lib__Instruction__f64x2_add() -> @lib.Instruction {
  @lib.Instruction::f64x2_add()
}

pub fn lib__Instruction__f64x2_ceil() -> @lib.Instruction {
  @lib.Instruction::f64x2_ceil()
}

pub fn lib__Instruction__f64x2_convert_low_i32x4s() -> @lib.Instruction {
  @lib.Instruction::f64x2_convert_low_i32x4s()
}

pub fn lib__Instruction__f64x2_convert_low_i32x4u() -> @lib.Instruction {
  @lib.Instruction::f64x2_convert_low_i32x4u()
}

pub fn lib__Instruction__f64x2_div() -> @lib.Instruction {
  @lib.Instruction::f64x2_div()
}

pub fn lib__Instruction__f64x2_eq() -> @lib.Instruction {
  @lib.Instruction::f64x2_eq()
}

pub fn lib__Instruction__f64x2_extract_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::f64x2_extract_lane(arg0)
}

pub fn lib__Instruction__f64x2_floor() -> @lib.Instruction {
  @lib.Instruction::f64x2_floor()
}

pub fn lib__Instruction__f64x2_ge() -> @lib.Instruction {
  @lib.Instruction::f64x2_ge()
}

pub fn lib__Instruction__f64x2_gt() -> @lib.Instruction {
  @lib.Instruction::f64x2_gt()
}

pub fn lib__Instruction__f64x2_le() -> @lib.Instruction {
  @lib.Instruction::f64x2_le()
}

pub fn lib__Instruction__f64x2_lt() -> @lib.Instruction {
  @lib.Instruction::f64x2_lt()
}

pub fn lib__Instruction__f64x2_max() -> @lib.Instruction {
  @lib.Instruction::f64x2_max()
}

pub fn lib__Instruction__f64x2_min() -> @lib.Instruction {
  @lib.Instruction::f64x2_min()
}

pub fn lib__Instruction__f64x2_mul() -> @lib.Instruction {
  @lib.Instruction::f64x2_mul()
}

pub fn lib__Instruction__f64x2_ne() -> @lib.Instruction {
  @lib.Instruction::f64x2_ne()
}

pub fn lib__Instruction__f64x2_nearest() -> @lib.Instruction {
  @lib.Instruction::f64x2_nearest()
}

pub fn lib__Instruction__f64x2_neg() -> @lib.Instruction {
  @lib.Instruction::f64x2_neg()
}

pub fn lib__Instruction__f64x2_pmax() -> @lib.Instruction {
  @lib.Instruction::f64x2_pmax()
}

pub fn lib__Instruction__f64x2_pmin() -> @lib.Instruction {
  @lib.Instruction::f64x2_pmin()
}

pub fn lib__Instruction__f64x2_promote_low_f32x4() -> @lib.Instruction {
  @lib.Instruction::f64x2_promote_low_f32x4()
}

pub fn lib__Instruction__f64x2_relaxed_madd() -> @lib.Instruction {
  @lib.Instruction::f64x2_relaxed_madd()
}

pub fn lib__Instruction__f64x2_relaxed_max() -> @lib.Instruction {
  @lib.Instruction::f64x2_relaxed_max()
}

pub fn lib__Instruction__f64x2_relaxed_min() -> @lib.Instruction {
  @lib.Instruction::f64x2_relaxed_min()
}

pub fn lib__Instruction__f64x2_relaxed_nmadd() -> @lib.Instruction {
  @lib.Instruction::f64x2_relaxed_nmadd()
}

pub fn lib__Instruction__f64x2_replace_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::f64x2_replace_lane(arg0)
}

pub fn lib__Instruction__f64x2_splat() -> @lib.Instruction {
  @lib.Instruction::f64x2_splat()
}

pub fn lib__Instruction__f64x2_sqrt() -> @lib.Instruction {
  @lib.Instruction::f64x2_sqrt()
}

pub fn lib__Instruction__f64x2_sub() -> @lib.Instruction {
  @lib.Instruction::f64x2_sub()
}

pub fn lib__Instruction__f64x2_trunc() -> @lib.Instruction {
  @lib.Instruction::f64x2_trunc()
}

pub fn lib__Instruction__global_get(arg0 : @lib.GlobalIdx) -> @lib.Instruction {
  @lib.Instruction::global_get(arg0)
}

pub fn lib__Instruction__global_set(arg0 : @lib.GlobalIdx) -> @lib.Instruction {
  @lib.Instruction::global_set(arg0)
}

pub fn lib__Instruction__i16x8_abs() -> @lib.Instruction {
  @lib.Instruction::i16x8_abs()
}

pub fn lib__Instruction__i16x8_add() -> @lib.Instruction {
  @lib.Instruction::i16x8_add()
}

pub fn lib__Instruction__i16x8_add_sat_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_add_sat_s()
}

pub fn lib__Instruction__i16x8_add_sat_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_add_sat_u()
}

pub fn lib__Instruction__i16x8_all_true() -> @lib.Instruction {
  @lib.Instruction::i16x8_all_true()
}

pub fn lib__Instruction__i16x8_avgr_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_avgr_u()
}

pub fn lib__Instruction__i16x8_bitmask() -> @lib.Instruction {
  @lib.Instruction::i16x8_bitmask()
}

pub fn lib__Instruction__i16x8_eq() -> @lib.Instruction {
  @lib.Instruction::i16x8_eq()
}

pub fn lib__Instruction__i16x8_extadd_pairwise_i8x16s() -> @lib.Instruction {
  @lib.Instruction::i16x8_extadd_pairwise_i8x16s()
}

pub fn lib__Instruction__i16x8_extadd_pairwise_i8x16u() -> @lib.Instruction {
  @lib.Instruction::i16x8_extadd_pairwise_i8x16u()
}

pub fn lib__Instruction__i16x8_extend_high_i8x16s() -> @lib.Instruction {
  @lib.Instruction::i16x8_extend_high_i8x16s()
}

pub fn lib__Instruction__i16x8_extend_high_i8x16u() -> @lib.Instruction {
  @lib.Instruction::i16x8_extend_high_i8x16u()
}

pub fn lib__Instruction__i16x8_extend_low_i8x16s() -> @lib.Instruction {
  @lib.Instruction::i16x8_extend_low_i8x16s()
}

pub fn lib__Instruction__i16x8_extend_low_i8x16u() -> @lib.Instruction {
  @lib.Instruction::i16x8_extend_low_i8x16u()
}

pub fn lib__Instruction__i16x8_extmul_high_i8x16s() -> @lib.Instruction {
  @lib.Instruction::i16x8_extmul_high_i8x16s()
}

pub fn lib__Instruction__i16x8_extmul_high_i8x16u() -> @lib.Instruction {
  @lib.Instruction::i16x8_extmul_high_i8x16u()
}

pub fn lib__Instruction__i16x8_extmul_low_i8x16s() -> @lib.Instruction {
  @lib.Instruction::i16x8_extmul_low_i8x16s()
}

pub fn lib__Instruction__i16x8_extmul_low_i8x16u() -> @lib.Instruction {
  @lib.Instruction::i16x8_extmul_low_i8x16u()
}

pub fn lib__Instruction__i16x8_extract_lane_s(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i16x8_extract_lane_s(arg0)
}

pub fn lib__Instruction__i16x8_extract_lane_u(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i16x8_extract_lane_u(arg0)
}

pub fn lib__Instruction__i16x8_ge_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_ge_s()
}

pub fn lib__Instruction__i16x8_ge_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_ge_u()
}

pub fn lib__Instruction__i16x8_gt_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_gt_s()
}

pub fn lib__Instruction__i16x8_gt_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_gt_u()
}

pub fn lib__Instruction__i16x8_le_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_le_s()
}

pub fn lib__Instruction__i16x8_le_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_le_u()
}

pub fn lib__Instruction__i16x8_lt_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_lt_s()
}

pub fn lib__Instruction__i16x8_lt_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_lt_u()
}

pub fn lib__Instruction__i16x8_max_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_max_s()
}

pub fn lib__Instruction__i16x8_max_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_max_u()
}

pub fn lib__Instruction__i16x8_min_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_min_s()
}

pub fn lib__Instruction__i16x8_min_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_min_u()
}

pub fn lib__Instruction__i16x8_mul() -> @lib.Instruction {
  @lib.Instruction::i16x8_mul()
}

pub fn lib__Instruction__i16x8_narrow_i32x4s() -> @lib.Instruction {
  @lib.Instruction::i16x8_narrow_i32x4s()
}

pub fn lib__Instruction__i16x8_narrow_i32x4u() -> @lib.Instruction {
  @lib.Instruction::i16x8_narrow_i32x4u()
}

pub fn lib__Instruction__i16x8_ne() -> @lib.Instruction {
  @lib.Instruction::i16x8_ne()
}

pub fn lib__Instruction__i16x8_neg() -> @lib.Instruction {
  @lib.Instruction::i16x8_neg()
}

pub fn lib__Instruction__i16x8_relaxed_dot_i8x16i7x16s() -> @lib.Instruction {
  @lib.Instruction::i16x8_relaxed_dot_i8x16i7x16s()
}

pub fn lib__Instruction__i16x8_relaxed_laneselect() -> @lib.Instruction {
  @lib.Instruction::i16x8_relaxed_laneselect()
}

pub fn lib__Instruction__i16x8_relaxed_q15mulr_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_relaxed_q15mulr_s()
}

pub fn lib__Instruction__i16x8_replace_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i16x8_replace_lane(arg0)
}

pub fn lib__Instruction__i16x8_shl() -> @lib.Instruction {
  @lib.Instruction::i16x8_shl()
}

pub fn lib__Instruction__i16x8_shr_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_shr_s()
}

pub fn lib__Instruction__i16x8_shr_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_shr_u()
}

pub fn lib__Instruction__i16x8_splat() -> @lib.Instruction {
  @lib.Instruction::i16x8_splat()
}

pub fn lib__Instruction__i16x8_sub() -> @lib.Instruction {
  @lib.Instruction::i16x8_sub()
}

pub fn lib__Instruction__i16x8_sub_sat_s() -> @lib.Instruction {
  @lib.Instruction::i16x8_sub_sat_s()
}

pub fn lib__Instruction__i16x8_sub_sat_u() -> @lib.Instruction {
  @lib.Instruction::i16x8_sub_sat_u()
}

pub fn lib__Instruction__i16x8q15mulr_sat_s() -> @lib.Instruction {
  @lib.Instruction::i16x8q15mulr_sat_s()
}

pub fn lib__Instruction__i31_get_s() -> @lib.Instruction {
  @lib.Instruction::i31_get_s()
}

pub fn lib__Instruction__i31_get_u() -> @lib.Instruction {
  @lib.Instruction::i31_get_u()
}

pub fn lib__Instruction__i32_add() -> @lib.Instruction {
  @lib.Instruction::i32_add()
}

pub fn lib__Instruction__i32_and() -> @lib.Instruction {
  @lib.Instruction::i32_and()
}

pub fn lib__Instruction__i32_atomic_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_atomic_load(arg0)
}

pub fn lib__Instruction__i32_atomic_load16_u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_atomic_load16_u(arg0)
}

pub fn lib__Instruction__i32_atomic_load8_u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_atomic_load8_u(arg0)
}

pub fn lib__Instruction__i32_atomic_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_atomic_store(arg0)
}

pub fn lib__Instruction__i32_atomic_store16(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_atomic_store16(arg0)
}

pub fn lib__Instruction__i32_atomic_store8(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_atomic_store8(arg0)
}

pub fn lib__Instruction__i32_clz() -> @lib.Instruction {
  @lib.Instruction::i32_clz()
}

pub fn lib__Instruction__i32_const(arg0 : @lib.I32) -> @lib.Instruction {
  @lib.Instruction::i32_const(arg0)
}

pub fn lib__Instruction__i32_ctz() -> @lib.Instruction {
  @lib.Instruction::i32_ctz()
}

pub fn lib__Instruction__i32_div_s() -> @lib.Instruction {
  @lib.Instruction::i32_div_s()
}

pub fn lib__Instruction__i32_div_u() -> @lib.Instruction {
  @lib.Instruction::i32_div_u()
}

pub fn lib__Instruction__i32_eq() -> @lib.Instruction {
  @lib.Instruction::i32_eq()
}

pub fn lib__Instruction__i32_eqz() -> @lib.Instruction {
  @lib.Instruction::i32_eqz()
}

pub fn lib__Instruction__i32_extend16s() -> @lib.Instruction {
  @lib.Instruction::i32_extend16s()
}

pub fn lib__Instruction__i32_extend8s() -> @lib.Instruction {
  @lib.Instruction::i32_extend8s()
}

pub fn lib__Instruction__i32_ge_s() -> @lib.Instruction {
  @lib.Instruction::i32_ge_s()
}

pub fn lib__Instruction__i32_ge_u() -> @lib.Instruction {
  @lib.Instruction::i32_ge_u()
}

pub fn lib__Instruction__i32_gt_s() -> @lib.Instruction {
  @lib.Instruction::i32_gt_s()
}

pub fn lib__Instruction__i32_gt_u() -> @lib.Instruction {
  @lib.Instruction::i32_gt_u()
}

pub fn lib__Instruction__i32_le_s() -> @lib.Instruction {
  @lib.Instruction::i32_le_s()
}

pub fn lib__Instruction__i32_le_u() -> @lib.Instruction {
  @lib.Instruction::i32_le_u()
}

pub fn lib__Instruction__i32_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_load(arg0)
}

pub fn lib__Instruction__i32_load16s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_load16s(arg0)
}

pub fn lib__Instruction__i32_load16u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_load16u(arg0)
}

pub fn lib__Instruction__i32_load8s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_load8s(arg0)
}

pub fn lib__Instruction__i32_load8u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_load8u(arg0)
}

pub fn lib__Instruction__i32_lt_s() -> @lib.Instruction {
  @lib.Instruction::i32_lt_s()
}

pub fn lib__Instruction__i32_lt_u() -> @lib.Instruction {
  @lib.Instruction::i32_lt_u()
}

pub fn lib__Instruction__i32_mul() -> @lib.Instruction {
  @lib.Instruction::i32_mul()
}

pub fn lib__Instruction__i32_ne() -> @lib.Instruction {
  @lib.Instruction::i32_ne()
}

pub fn lib__Instruction__i32_or() -> @lib.Instruction {
  @lib.Instruction::i32_or()
}

pub fn lib__Instruction__i32_popcnt() -> @lib.Instruction {
  @lib.Instruction::i32_popcnt()
}

pub fn lib__Instruction__i32_reinterpret_f32() -> @lib.Instruction {
  @lib.Instruction::i32_reinterpret_f32()
}

pub fn lib__Instruction__i32_rem_s() -> @lib.Instruction {
  @lib.Instruction::i32_rem_s()
}

pub fn lib__Instruction__i32_rem_u() -> @lib.Instruction {
  @lib.Instruction::i32_rem_u()
}

pub fn lib__Instruction__i32_rotl() -> @lib.Instruction {
  @lib.Instruction::i32_rotl()
}

pub fn lib__Instruction__i32_rotr() -> @lib.Instruction {
  @lib.Instruction::i32_rotr()
}

pub fn lib__Instruction__i32_shl() -> @lib.Instruction {
  @lib.Instruction::i32_shl()
}

pub fn lib__Instruction__i32_shr_s() -> @lib.Instruction {
  @lib.Instruction::i32_shr_s()
}

pub fn lib__Instruction__i32_shr_u() -> @lib.Instruction {
  @lib.Instruction::i32_shr_u()
}

pub fn lib__Instruction__i32_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_store(arg0)
}

pub fn lib__Instruction__i32_store16(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_store16(arg0)
}

pub fn lib__Instruction__i32_store8(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i32_store8(arg0)
}

pub fn lib__Instruction__i32_sub() -> @lib.Instruction {
  @lib.Instruction::i32_sub()
}

pub fn lib__Instruction__i32_trunc_f32s() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_f32s()
}

pub fn lib__Instruction__i32_trunc_f32u() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_f32u()
}

pub fn lib__Instruction__i32_trunc_f64s() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_f64s()
}

pub fn lib__Instruction__i32_trunc_f64u() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_f64u()
}

pub fn lib__Instruction__i32_trunc_sat_f32s() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_sat_f32s()
}

pub fn lib__Instruction__i32_trunc_sat_f32u() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_sat_f32u()
}

pub fn lib__Instruction__i32_trunc_sat_f64s() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_sat_f64s()
}

pub fn lib__Instruction__i32_trunc_sat_f64u() -> @lib.Instruction {
  @lib.Instruction::i32_trunc_sat_f64u()
}

pub fn lib__Instruction__i32_wrap_i64() -> @lib.Instruction {
  @lib.Instruction::i32_wrap_i64()
}

pub fn lib__Instruction__i32_xor() -> @lib.Instruction {
  @lib.Instruction::i32_xor()
}

pub fn lib__Instruction__i32x4_abs() -> @lib.Instruction {
  @lib.Instruction::i32x4_abs()
}

pub fn lib__Instruction__i32x4_add() -> @lib.Instruction {
  @lib.Instruction::i32x4_add()
}

pub fn lib__Instruction__i32x4_all_true() -> @lib.Instruction {
  @lib.Instruction::i32x4_all_true()
}

pub fn lib__Instruction__i32x4_bitmask() -> @lib.Instruction {
  @lib.Instruction::i32x4_bitmask()
}

pub fn lib__Instruction__i32x4_dot_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i32x4_dot_i16x8s()
}

pub fn lib__Instruction__i32x4_eq() -> @lib.Instruction {
  @lib.Instruction::i32x4_eq()
}

pub fn lib__Instruction__i32x4_extadd_pairwise_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i32x4_extadd_pairwise_i16x8s()
}

pub fn lib__Instruction__i32x4_extadd_pairwise_i16x8u() -> @lib.Instruction {
  @lib.Instruction::i32x4_extadd_pairwise_i16x8u()
}

pub fn lib__Instruction__i32x4_extend_high_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i32x4_extend_high_i16x8s()
}

pub fn lib__Instruction__i32x4_extend_high_i16x8u() -> @lib.Instruction {
  @lib.Instruction::i32x4_extend_high_i16x8u()
}

pub fn lib__Instruction__i32x4_extend_low_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i32x4_extend_low_i16x8s()
}

pub fn lib__Instruction__i32x4_extend_low_i16x8u() -> @lib.Instruction {
  @lib.Instruction::i32x4_extend_low_i16x8u()
}

pub fn lib__Instruction__i32x4_extmul_high_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i32x4_extmul_high_i16x8s()
}

pub fn lib__Instruction__i32x4_extmul_high_i16x8u() -> @lib.Instruction {
  @lib.Instruction::i32x4_extmul_high_i16x8u()
}

pub fn lib__Instruction__i32x4_extmul_low_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i32x4_extmul_low_i16x8s()
}

pub fn lib__Instruction__i32x4_extmul_low_i16x8u() -> @lib.Instruction {
  @lib.Instruction::i32x4_extmul_low_i16x8u()
}

pub fn lib__Instruction__i32x4_extract_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i32x4_extract_lane(arg0)
}

pub fn lib__Instruction__i32x4_ge_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_ge_s()
}

pub fn lib__Instruction__i32x4_ge_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_ge_u()
}

pub fn lib__Instruction__i32x4_gt_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_gt_s()
}

pub fn lib__Instruction__i32x4_gt_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_gt_u()
}

pub fn lib__Instruction__i32x4_le_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_le_s()
}

pub fn lib__Instruction__i32x4_le_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_le_u()
}

pub fn lib__Instruction__i32x4_lt_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_lt_s()
}

pub fn lib__Instruction__i32x4_lt_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_lt_u()
}

pub fn lib__Instruction__i32x4_max_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_max_s()
}

pub fn lib__Instruction__i32x4_max_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_max_u()
}

pub fn lib__Instruction__i32x4_min_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_min_s()
}

pub fn lib__Instruction__i32x4_min_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_min_u()
}

pub fn lib__Instruction__i32x4_mul() -> @lib.Instruction {
  @lib.Instruction::i32x4_mul()
}

pub fn lib__Instruction__i32x4_ne() -> @lib.Instruction {
  @lib.Instruction::i32x4_ne()
}

pub fn lib__Instruction__i32x4_neg() -> @lib.Instruction {
  @lib.Instruction::i32x4_neg()
}

pub fn lib__Instruction__i32x4_relaxed_dot_i8x16i7x16_add_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_relaxed_dot_i8x16i7x16_add_s()
}

pub fn lib__Instruction__i32x4_relaxed_laneselect() -> @lib.Instruction {
  @lib.Instruction::i32x4_relaxed_laneselect()
}

pub fn lib__Instruction__i32x4_relaxed_trunc_f32x4s() -> @lib.Instruction {
  @lib.Instruction::i32x4_relaxed_trunc_f32x4s()
}

pub fn lib__Instruction__i32x4_relaxed_trunc_f32x4u() -> @lib.Instruction {
  @lib.Instruction::i32x4_relaxed_trunc_f32x4u()
}

pub fn lib__Instruction__i32x4_relaxed_trunc_zero_f64x2s() -> @lib.Instruction {
  @lib.Instruction::i32x4_relaxed_trunc_zero_f64x2s()
}

pub fn lib__Instruction__i32x4_relaxed_trunc_zero_f64x2u() -> @lib.Instruction {
  @lib.Instruction::i32x4_relaxed_trunc_zero_f64x2u()
}

pub fn lib__Instruction__i32x4_replace_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i32x4_replace_lane(arg0)
}

pub fn lib__Instruction__i32x4_shl() -> @lib.Instruction {
  @lib.Instruction::i32x4_shl()
}

pub fn lib__Instruction__i32x4_shr_s() -> @lib.Instruction {
  @lib.Instruction::i32x4_shr_s()
}

pub fn lib__Instruction__i32x4_shr_u() -> @lib.Instruction {
  @lib.Instruction::i32x4_shr_u()
}

pub fn lib__Instruction__i32x4_splat() -> @lib.Instruction {
  @lib.Instruction::i32x4_splat()
}

pub fn lib__Instruction__i32x4_sub() -> @lib.Instruction {
  @lib.Instruction::i32x4_sub()
}

pub fn lib__Instruction__i32x4_trunc_sat_f32x4s() -> @lib.Instruction {
  @lib.Instruction::i32x4_trunc_sat_f32x4s()
}

pub fn lib__Instruction__i32x4_trunc_sat_f32x4u() -> @lib.Instruction {
  @lib.Instruction::i32x4_trunc_sat_f32x4u()
}

pub fn lib__Instruction__i32x4_trunc_sat_f64x2s_zero() -> @lib.Instruction {
  @lib.Instruction::i32x4_trunc_sat_f64x2s_zero()
}

pub fn lib__Instruction__i32x4_trunc_sat_f64x2u_zero() -> @lib.Instruction {
  @lib.Instruction::i32x4_trunc_sat_f64x2u_zero()
}

pub fn lib__Instruction__i64_add() -> @lib.Instruction {
  @lib.Instruction::i64_add()
}

pub fn lib__Instruction__i64_and() -> @lib.Instruction {
  @lib.Instruction::i64_and()
}

pub fn lib__Instruction__i64_atomic_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_load(arg0)
}

pub fn lib__Instruction__i64_atomic_load16_u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_load16_u(arg0)
}

pub fn lib__Instruction__i64_atomic_load32_u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_load32_u(arg0)
}

pub fn lib__Instruction__i64_atomic_load8_u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_load8_u(arg0)
}

pub fn lib__Instruction__i64_atomic_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_store(arg0)
}

pub fn lib__Instruction__i64_atomic_store16(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_store16(arg0)
}

pub fn lib__Instruction__i64_atomic_store32(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_store32(arg0)
}

pub fn lib__Instruction__i64_atomic_store8(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_atomic_store8(arg0)
}

pub fn lib__Instruction__i64_clz() -> @lib.Instruction {
  @lib.Instruction::i64_clz()
}

pub fn lib__Instruction__i64_const(arg0 : @lib.I64) -> @lib.Instruction {
  @lib.Instruction::i64_const(arg0)
}

pub fn lib__Instruction__i64_ctz() -> @lib.Instruction {
  @lib.Instruction::i64_ctz()
}

pub fn lib__Instruction__i64_div_s() -> @lib.Instruction {
  @lib.Instruction::i64_div_s()
}

pub fn lib__Instruction__i64_div_u() -> @lib.Instruction {
  @lib.Instruction::i64_div_u()
}

pub fn lib__Instruction__i64_eq() -> @lib.Instruction {
  @lib.Instruction::i64_eq()
}

pub fn lib__Instruction__i64_eqz() -> @lib.Instruction {
  @lib.Instruction::i64_eqz()
}

pub fn lib__Instruction__i64_extend16s() -> @lib.Instruction {
  @lib.Instruction::i64_extend16s()
}

pub fn lib__Instruction__i64_extend32s() -> @lib.Instruction {
  @lib.Instruction::i64_extend32s()
}

pub fn lib__Instruction__i64_extend8s() -> @lib.Instruction {
  @lib.Instruction::i64_extend8s()
}

pub fn lib__Instruction__i64_extend_i32s() -> @lib.Instruction {
  @lib.Instruction::i64_extend_i32s()
}

pub fn lib__Instruction__i64_extend_i32u() -> @lib.Instruction {
  @lib.Instruction::i64_extend_i32u()
}

pub fn lib__Instruction__i64_ge_s() -> @lib.Instruction {
  @lib.Instruction::i64_ge_s()
}

pub fn lib__Instruction__i64_ge_u() -> @lib.Instruction {
  @lib.Instruction::i64_ge_u()
}

pub fn lib__Instruction__i64_gt_s() -> @lib.Instruction {
  @lib.Instruction::i64_gt_s()
}

pub fn lib__Instruction__i64_gt_u() -> @lib.Instruction {
  @lib.Instruction::i64_gt_u()
}

pub fn lib__Instruction__i64_le_s() -> @lib.Instruction {
  @lib.Instruction::i64_le_s()
}

pub fn lib__Instruction__i64_le_u() -> @lib.Instruction {
  @lib.Instruction::i64_le_u()
}

pub fn lib__Instruction__i64_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load(arg0)
}

pub fn lib__Instruction__i64_load16s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load16s(arg0)
}

pub fn lib__Instruction__i64_load16u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load16u(arg0)
}

pub fn lib__Instruction__i64_load32s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load32s(arg0)
}

pub fn lib__Instruction__i64_load32u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load32u(arg0)
}

pub fn lib__Instruction__i64_load8s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load8s(arg0)
}

pub fn lib__Instruction__i64_load8u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_load8u(arg0)
}

pub fn lib__Instruction__i64_lt_s() -> @lib.Instruction {
  @lib.Instruction::i64_lt_s()
}

pub fn lib__Instruction__i64_lt_u() -> @lib.Instruction {
  @lib.Instruction::i64_lt_u()
}

pub fn lib__Instruction__i64_mul() -> @lib.Instruction {
  @lib.Instruction::i64_mul()
}

pub fn lib__Instruction__i64_ne() -> @lib.Instruction {
  @lib.Instruction::i64_ne()
}

pub fn lib__Instruction__i64_or() -> @lib.Instruction {
  @lib.Instruction::i64_or()
}

pub fn lib__Instruction__i64_popcnt() -> @lib.Instruction {
  @lib.Instruction::i64_popcnt()
}

pub fn lib__Instruction__i64_reinterpret_f64() -> @lib.Instruction {
  @lib.Instruction::i64_reinterpret_f64()
}

pub fn lib__Instruction__i64_rem_s() -> @lib.Instruction {
  @lib.Instruction::i64_rem_s()
}

pub fn lib__Instruction__i64_rem_u() -> @lib.Instruction {
  @lib.Instruction::i64_rem_u()
}

pub fn lib__Instruction__i64_rotl() -> @lib.Instruction {
  @lib.Instruction::i64_rotl()
}

pub fn lib__Instruction__i64_rotr() -> @lib.Instruction {
  @lib.Instruction::i64_rotr()
}

pub fn lib__Instruction__i64_shl() -> @lib.Instruction {
  @lib.Instruction::i64_shl()
}

pub fn lib__Instruction__i64_shr_s() -> @lib.Instruction {
  @lib.Instruction::i64_shr_s()
}

pub fn lib__Instruction__i64_shr_u() -> @lib.Instruction {
  @lib.Instruction::i64_shr_u()
}

pub fn lib__Instruction__i64_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_store(arg0)
}

pub fn lib__Instruction__i64_store16(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_store16(arg0)
}

pub fn lib__Instruction__i64_store32(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_store32(arg0)
}

pub fn lib__Instruction__i64_store8(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::i64_store8(arg0)
}

pub fn lib__Instruction__i64_sub() -> @lib.Instruction {
  @lib.Instruction::i64_sub()
}

pub fn lib__Instruction__i64_trunc_f32s() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_f32s()
}

pub fn lib__Instruction__i64_trunc_f32u() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_f32u()
}

pub fn lib__Instruction__i64_trunc_f64s() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_f64s()
}

pub fn lib__Instruction__i64_trunc_f64u() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_f64u()
}

pub fn lib__Instruction__i64_trunc_sat_f32s() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_sat_f32s()
}

pub fn lib__Instruction__i64_trunc_sat_f32u() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_sat_f32u()
}

pub fn lib__Instruction__i64_trunc_sat_f64s() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_sat_f64s()
}

pub fn lib__Instruction__i64_trunc_sat_f64u() -> @lib.Instruction {
  @lib.Instruction::i64_trunc_sat_f64u()
}

pub fn lib__Instruction__i64_xor() -> @lib.Instruction {
  @lib.Instruction::i64_xor()
}

pub fn lib__Instruction__i64x2_abs() -> @lib.Instruction {
  @lib.Instruction::i64x2_abs()
}

pub fn lib__Instruction__i64x2_add() -> @lib.Instruction {
  @lib.Instruction::i64x2_add()
}

pub fn lib__Instruction__i64x2_all_true() -> @lib.Instruction {
  @lib.Instruction::i64x2_all_true()
}

pub fn lib__Instruction__i64x2_bitmask() -> @lib.Instruction {
  @lib.Instruction::i64x2_bitmask()
}

pub fn lib__Instruction__i64x2_eq() -> @lib.Instruction {
  @lib.Instruction::i64x2_eq()
}

pub fn lib__Instruction__i64x2_extend_high_i32x4s() -> @lib.Instruction {
  @lib.Instruction::i64x2_extend_high_i32x4s()
}

pub fn lib__Instruction__i64x2_extend_high_i32x4u() -> @lib.Instruction {
  @lib.Instruction::i64x2_extend_high_i32x4u()
}

pub fn lib__Instruction__i64x2_extend_low_i32x4s() -> @lib.Instruction {
  @lib.Instruction::i64x2_extend_low_i32x4s()
}

pub fn lib__Instruction__i64x2_extend_low_i32x4u() -> @lib.Instruction {
  @lib.Instruction::i64x2_extend_low_i32x4u()
}

pub fn lib__Instruction__i64x2_extmul_high_i32x4s() -> @lib.Instruction {
  @lib.Instruction::i64x2_extmul_high_i32x4s()
}

pub fn lib__Instruction__i64x2_extmul_high_i32x4u() -> @lib.Instruction {
  @lib.Instruction::i64x2_extmul_high_i32x4u()
}

pub fn lib__Instruction__i64x2_extmul_low_i32x4s() -> @lib.Instruction {
  @lib.Instruction::i64x2_extmul_low_i32x4s()
}

pub fn lib__Instruction__i64x2_extmul_low_i32x4u() -> @lib.Instruction {
  @lib.Instruction::i64x2_extmul_low_i32x4u()
}

pub fn lib__Instruction__i64x2_extract_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i64x2_extract_lane(arg0)
}

pub fn lib__Instruction__i64x2_ge_s() -> @lib.Instruction {
  @lib.Instruction::i64x2_ge_s()
}

pub fn lib__Instruction__i64x2_gt_s() -> @lib.Instruction {
  @lib.Instruction::i64x2_gt_s()
}

pub fn lib__Instruction__i64x2_le_s() -> @lib.Instruction {
  @lib.Instruction::i64x2_le_s()
}

pub fn lib__Instruction__i64x2_lt_s() -> @lib.Instruction {
  @lib.Instruction::i64x2_lt_s()
}

pub fn lib__Instruction__i64x2_mul() -> @lib.Instruction {
  @lib.Instruction::i64x2_mul()
}

pub fn lib__Instruction__i64x2_ne() -> @lib.Instruction {
  @lib.Instruction::i64x2_ne()
}

pub fn lib__Instruction__i64x2_neg() -> @lib.Instruction {
  @lib.Instruction::i64x2_neg()
}

pub fn lib__Instruction__i64x2_relaxed_laneselect() -> @lib.Instruction {
  @lib.Instruction::i64x2_relaxed_laneselect()
}

pub fn lib__Instruction__i64x2_replace_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i64x2_replace_lane(arg0)
}

pub fn lib__Instruction__i64x2_shl() -> @lib.Instruction {
  @lib.Instruction::i64x2_shl()
}

pub fn lib__Instruction__i64x2_shr_s() -> @lib.Instruction {
  @lib.Instruction::i64x2_shr_s()
}

pub fn lib__Instruction__i64x2_shr_u() -> @lib.Instruction {
  @lib.Instruction::i64x2_shr_u()
}

pub fn lib__Instruction__i64x2_splat() -> @lib.Instruction {
  @lib.Instruction::i64x2_splat()
}

pub fn lib__Instruction__i64x2_sub() -> @lib.Instruction {
  @lib.Instruction::i64x2_sub()
}

pub fn lib__Instruction__i8x16_abs() -> @lib.Instruction {
  @lib.Instruction::i8x16_abs()
}

pub fn lib__Instruction__i8x16_add() -> @lib.Instruction {
  @lib.Instruction::i8x16_add()
}

pub fn lib__Instruction__i8x16_add_sat_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_add_sat_s()
}

pub fn lib__Instruction__i8x16_add_sat_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_add_sat_u()
}

pub fn lib__Instruction__i8x16_all_true() -> @lib.Instruction {
  @lib.Instruction::i8x16_all_true()
}

pub fn lib__Instruction__i8x16_avgr_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_avgr_u()
}

pub fn lib__Instruction__i8x16_bitmask() -> @lib.Instruction {
  @lib.Instruction::i8x16_bitmask()
}

pub fn lib__Instruction__i8x16_eq() -> @lib.Instruction {
  @lib.Instruction::i8x16_eq()
}

pub fn lib__Instruction__i8x16_extract_lane_s(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i8x16_extract_lane_s(arg0)
}

pub fn lib__Instruction__i8x16_extract_lane_u(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i8x16_extract_lane_u(arg0)
}

pub fn lib__Instruction__i8x16_ge_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_ge_s()
}

pub fn lib__Instruction__i8x16_ge_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_ge_u()
}

pub fn lib__Instruction__i8x16_gt_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_gt_s()
}

pub fn lib__Instruction__i8x16_gt_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_gt_u()
}

pub fn lib__Instruction__i8x16_le_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_le_s()
}

pub fn lib__Instruction__i8x16_le_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_le_u()
}

pub fn lib__Instruction__i8x16_lt_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_lt_s()
}

pub fn lib__Instruction__i8x16_lt_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_lt_u()
}

pub fn lib__Instruction__i8x16_max_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_max_s()
}

pub fn lib__Instruction__i8x16_max_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_max_u()
}

pub fn lib__Instruction__i8x16_min_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_min_s()
}

pub fn lib__Instruction__i8x16_min_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_min_u()
}

pub fn lib__Instruction__i8x16_narrow_i16x8s() -> @lib.Instruction {
  @lib.Instruction::i8x16_narrow_i16x8s()
}

pub fn lib__Instruction__i8x16_narrow_i16x8u() -> @lib.Instruction {
  @lib.Instruction::i8x16_narrow_i16x8u()
}

pub fn lib__Instruction__i8x16_ne() -> @lib.Instruction {
  @lib.Instruction::i8x16_ne()
}

pub fn lib__Instruction__i8x16_neg() -> @lib.Instruction {
  @lib.Instruction::i8x16_neg()
}

pub fn lib__Instruction__i8x16_popcnt() -> @lib.Instruction {
  @lib.Instruction::i8x16_popcnt()
}

pub fn lib__Instruction__i8x16_relaxed_laneselect() -> @lib.Instruction {
  @lib.Instruction::i8x16_relaxed_laneselect()
}

pub fn lib__Instruction__i8x16_relaxed_swizzle() -> @lib.Instruction {
  @lib.Instruction::i8x16_relaxed_swizzle()
}

pub fn lib__Instruction__i8x16_replace_lane(arg0 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i8x16_replace_lane(arg0)
}

pub fn lib__Instruction__i8x16_shl() -> @lib.Instruction {
  @lib.Instruction::i8x16_shl()
}

pub fn lib__Instruction__i8x16_shr_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_shr_s()
}

pub fn lib__Instruction__i8x16_shr_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_shr_u()
}

pub fn lib__Instruction__i8x16_shuffle(arg0 : @lib.LaneIdx, arg1 : @lib.LaneIdx, arg2 : @lib.LaneIdx, arg3 : @lib.LaneIdx, arg4 : @lib.LaneIdx, arg5 : @lib.LaneIdx, arg6 : @lib.LaneIdx, arg7 : @lib.LaneIdx, arg8 : @lib.LaneIdx, arg9 : @lib.LaneIdx, arg10 : @lib.LaneIdx, arg11 : @lib.LaneIdx, arg12 : @lib.LaneIdx, arg13 : @lib.LaneIdx, arg14 : @lib.LaneIdx, arg15 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::i8x16_shuffle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
}

pub fn lib__Instruction__i8x16_splat() -> @lib.Instruction {
  @lib.Instruction::i8x16_splat()
}

pub fn lib__Instruction__i8x16_sub() -> @lib.Instruction {
  @lib.Instruction::i8x16_sub()
}

pub fn lib__Instruction__i8x16_sub_sat_s() -> @lib.Instruction {
  @lib.Instruction::i8x16_sub_sat_s()
}

pub fn lib__Instruction__i8x16_sub_sat_u() -> @lib.Instruction {
  @lib.Instruction::i8x16_sub_sat_u()
}

pub fn lib__Instruction__i8x16_swizzle() -> @lib.Instruction {
  @lib.Instruction::i8x16_swizzle()
}

pub fn lib__Instruction__if_(arg0 : @lib.BlockType, arg1 : Array[@lib.Instruction], arg2 : Array[@lib.Instruction]?) -> @lib.Instruction {
  @lib.Instruction::if_(arg0, arg1, arg2)
}

pub fn lib__Instruction__local_get(arg0 : @lib.LocalIdx) -> @lib.Instruction {
  @lib.Instruction::local_get(arg0)
}

pub fn lib__Instruction__local_set(arg0 : @lib.LocalIdx) -> @lib.Instruction {
  @lib.Instruction::local_set(arg0)
}

pub fn lib__Instruction__local_tee(arg0 : @lib.LocalIdx) -> @lib.Instruction {
  @lib.Instruction::local_tee(arg0)
}

pub fn lib__Instruction__loop_(arg0 : @lib.BlockType, arg1 : @lib.Expr) -> @lib.Instruction {
  @lib.Instruction::loop_(arg0, arg1)
}

pub fn lib__Instruction__memory_atomic_notify(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::memory_atomic_notify(arg0)
}

pub fn lib__Instruction__memory_atomic_wait32(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::memory_atomic_wait32(arg0)
}

pub fn lib__Instruction__memory_atomic_wait64(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::memory_atomic_wait64(arg0)
}

pub fn lib__Instruction__memory_copy(arg0 : @lib.MemIdx, arg1 : @lib.MemIdx) -> @lib.Instruction {
  @lib.Instruction::memory_copy(arg0, arg1)
}

pub fn lib__Instruction__memory_fill(arg0 : @lib.MemIdx) -> @lib.Instruction {
  @lib.Instruction::memory_fill(arg0)
}

pub fn lib__Instruction__memory_grow(arg0 : @lib.MemIdx) -> @lib.Instruction {
  @lib.Instruction::memory_grow(arg0)
}

pub fn lib__Instruction__memory_init(arg0 : @lib.DataIdx, arg1 : @lib.MemIdx) -> @lib.Instruction {
  @lib.Instruction::memory_init(arg0, arg1)
}

pub fn lib__Instruction__memory_size(arg0 : @lib.MemIdx) -> @lib.Instruction {
  @lib.Instruction::memory_size(arg0)
}

pub fn lib__Instruction__nop() -> @lib.Instruction {
  @lib.Instruction::nop()
}

pub fn lib__Instruction__ref_as_non_null() -> @lib.Instruction {
  @lib.Instruction::ref_as_non_null()
}

pub fn lib__Instruction__ref_cast(arg0 : Bool, arg1 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::ref_cast(arg0, arg1)
}

pub fn lib__Instruction__ref_cast_desc_eq(arg0 : Bool, arg1 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::ref_cast_desc_eq(arg0, arg1)
}

pub fn lib__Instruction__ref_eq() -> @lib.Instruction {
  @lib.Instruction::ref_eq()
}

pub fn lib__Instruction__ref_func(arg0 : @lib.FuncIdx) -> @lib.Instruction {
  @lib.Instruction::ref_func(arg0)
}

pub fn lib__Instruction__ref_get_desc() -> @lib.Instruction {
  @lib.Instruction::ref_get_desc()
}

pub fn lib__Instruction__ref_i31() -> @lib.Instruction {
  @lib.Instruction::ref_i31()
}

pub fn lib__Instruction__ref_is_null() -> @lib.Instruction {
  @lib.Instruction::ref_is_null()
}

pub fn lib__Instruction__ref_null(arg0 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::ref_null(arg0)
}

pub fn lib__Instruction__ref_test(arg0 : Bool, arg1 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::ref_test(arg0, arg1)
}

pub fn lib__Instruction__ref_test_desc(arg0 : Bool, arg1 : @lib.HeapType) -> @lib.Instruction {
  @lib.Instruction::ref_test_desc(arg0, arg1)
}

pub fn lib__Instruction__return_() -> @lib.Instruction {
  @lib.Instruction::return_()
}

pub fn lib__Instruction__return_call(arg0 : @lib.FuncIdx) -> @lib.Instruction {
  @lib.Instruction::return_call(arg0)
}

pub fn lib__Instruction__return_call_indirect(arg0 : @lib.TypeIdx, arg1 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::return_call_indirect(arg0, arg1)
}

pub fn lib__Instruction__return_call_ref(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::return_call_ref(arg0)
}

pub fn lib__Instruction__select__arity_0() -> @lib.Instruction {
  @lib.Instruction::select()
}

pub fn lib__Instruction__select(arg0 : Array[@lib.ValType]?) -> @lib.Instruction {
  @lib.Instruction::select(types=arg0)
}

pub fn lib__Instruction__struct_get(arg0 : @lib.TypeIdx, arg1 : @lib.U32) -> @lib.Instruction {
  @lib.Instruction::struct_get(arg0, arg1)
}

pub fn lib__Instruction__struct_get_s(arg0 : @lib.TypeIdx, arg1 : @lib.U32) -> @lib.Instruction {
  @lib.Instruction::struct_get_s(arg0, arg1)
}

pub fn lib__Instruction__struct_get_u(arg0 : @lib.TypeIdx, arg1 : @lib.U32) -> @lib.Instruction {
  @lib.Instruction::struct_get_u(arg0, arg1)
}

pub fn lib__Instruction__struct_new(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::struct_new(arg0)
}

pub fn lib__Instruction__struct_new_default(arg0 : @lib.TypeIdx) -> @lib.Instruction {
  @lib.Instruction::struct_new_default(arg0)
}

pub fn lib__Instruction__struct_set(arg0 : @lib.TypeIdx, arg1 : @lib.U32) -> @lib.Instruction {
  @lib.Instruction::struct_set(arg0, arg1)
}

pub fn lib__Instruction__table_copy(arg0 : @lib.TableIdx, arg1 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_copy(arg0, arg1)
}

pub fn lib__Instruction__table_fill(arg0 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_fill(arg0)
}

pub fn lib__Instruction__table_get(arg0 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_get(arg0)
}

pub fn lib__Instruction__table_grow(arg0 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_grow(arg0)
}

pub fn lib__Instruction__table_init(arg0 : @lib.ElemIdx, arg1 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_init(arg0, arg1)
}

pub fn lib__Instruction__table_set(arg0 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_set(arg0)
}

pub fn lib__Instruction__table_size(arg0 : @lib.TableIdx) -> @lib.Instruction {
  @lib.Instruction::table_size(arg0)
}

pub fn lib__Instruction__throw_(arg0 : @lib.TagIdx) -> @lib.Instruction {
  @lib.Instruction::throw_(arg0)
}

pub fn lib__Instruction__throw_ref() -> @lib.Instruction {
  @lib.Instruction::throw_ref()
}

pub fn lib__Instruction__try_table(arg0 : @lib.BlockType, arg1 : Array[@lib.Catch], arg2 : @lib.Expr) -> @lib.Instruction {
  @lib.Instruction::try_table(arg0, arg1, arg2)
}

pub fn lib__Instruction__unreachable_() -> @lib.Instruction {
  @lib.Instruction::unreachable_()
}

pub fn lib__Instruction__v128_and() -> @lib.Instruction {
  @lib.Instruction::v128_and()
}

pub fn lib__Instruction__v128_andnot() -> @lib.Instruction {
  @lib.Instruction::v128_andnot()
}

pub fn lib__Instruction__v128_any_true() -> @lib.Instruction {
  @lib.Instruction::v128_any_true()
}

pub fn lib__Instruction__v128_bitselect() -> @lib.Instruction {
  @lib.Instruction::v128_bitselect()
}

pub fn lib__Instruction__v128_const(arg0 : Byte, arg1 : Byte, arg2 : Byte, arg3 : Byte, arg4 : Byte, arg5 : Byte, arg6 : Byte, arg7 : Byte, arg8 : Byte, arg9 : Byte, arg10 : Byte, arg11 : Byte, arg12 : Byte, arg13 : Byte, arg14 : Byte, arg15 : Byte) -> @lib.Instruction {
  @lib.Instruction::v128_const(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
}

pub fn lib__Instruction__v128_load(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load(arg0)
}

pub fn lib__Instruction__v128_load16_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_load16_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_load16_splat(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load16_splat(arg0)
}

pub fn lib__Instruction__v128_load16x4s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load16x4s(arg0)
}

pub fn lib__Instruction__v128_load16x4u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load16x4u(arg0)
}

pub fn lib__Instruction__v128_load32_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_load32_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_load32_splat(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load32_splat(arg0)
}

pub fn lib__Instruction__v128_load32_zero(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load32_zero(arg0)
}

pub fn lib__Instruction__v128_load32x2s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load32x2s(arg0)
}

pub fn lib__Instruction__v128_load32x2u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load32x2u(arg0)
}

pub fn lib__Instruction__v128_load64_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_load64_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_load64_splat(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load64_splat(arg0)
}

pub fn lib__Instruction__v128_load64_zero(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load64_zero(arg0)
}

pub fn lib__Instruction__v128_load8_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_load8_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_load8_splat(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load8_splat(arg0)
}

pub fn lib__Instruction__v128_load8x8s(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load8x8s(arg0)
}

pub fn lib__Instruction__v128_load8x8u(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_load8x8u(arg0)
}

pub fn lib__Instruction__v128_not() -> @lib.Instruction {
  @lib.Instruction::v128_not()
}

pub fn lib__Instruction__v128_or() -> @lib.Instruction {
  @lib.Instruction::v128_or()
}

pub fn lib__Instruction__v128_store(arg0 : @lib.MemArg) -> @lib.Instruction {
  @lib.Instruction::v128_store(arg0)
}

pub fn lib__Instruction__v128_store16_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_store16_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_store32_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_store32_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_store64_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_store64_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_store8_lane(arg0 : @lib.MemArg, arg1 : @lib.LaneIdx) -> @lib.Instruction {
  @lib.Instruction::v128_store8_lane(arg0, arg1)
}

pub fn lib__Instruction__v128_xor() -> @lib.Instruction {
  @lib.Instruction::v128_xor()
}

pub fn lib__LabelIdx__inner(arg0 : @lib.LabelIdx) -> UInt {
  @lib.LabelIdx::inner(arg0)
}

pub fn lib__LabelIdx__new(arg0 : UInt) -> @lib.LabelIdx {
  @lib.LabelIdx::new(arg0)
}

pub fn lib__LaneIdx__inner(arg0 : @lib.LaneIdx) -> Byte {
  @lib.LaneIdx::inner(arg0)
}

pub fn lib__LaneIdx__new(arg0 : Byte) -> @lib.LaneIdx {
  @lib.LaneIdx::new(arg0)
}

pub fn lib__Limits__addr_valtype(arg0 : @lib.Limits) -> @lib.ValType {
  @lib.Limits::addr_valtype(arg0)
}

pub fn lib__Limits__i32(arg0 : UInt, arg1 : UInt?) -> @lib.Limits {
  @lib.Limits::i32(arg0, arg1)
}

pub fn lib__Limits__i64(arg0 : UInt64, arg1 : UInt64?) -> @lib.Limits {
  @lib.Limits::i64(arg0, arg1)
}

pub fn lib__Limits__mem_addr_bits(arg0 : @lib.Limits) -> Int {
  @lib.Limits::mem_addr_bits(arg0)
}

pub fn lib__LoadOp__f32_load() -> @lib.LoadOp {
  @lib.LoadOp::f32_load()
}

pub fn lib__LoadOp__f64_load() -> @lib.LoadOp {
  @lib.LoadOp::f64_load()
}

pub fn lib__LoadOp__i32_atomic_load() -> @lib.LoadOp {
  @lib.LoadOp::i32_atomic_load()
}

pub fn lib__LoadOp__i32_atomic_load16_u() -> @lib.LoadOp {
  @lib.LoadOp::i32_atomic_load16_u()
}

pub fn lib__LoadOp__i32_atomic_load8_u() -> @lib.LoadOp {
  @lib.LoadOp::i32_atomic_load8_u()
}

pub fn lib__LoadOp__i32_load() -> @lib.LoadOp {
  @lib.LoadOp::i32_load()
}

pub fn lib__LoadOp__i32_load16s() -> @lib.LoadOp {
  @lib.LoadOp::i32_load16s()
}

pub fn lib__LoadOp__i32_load16u() -> @lib.LoadOp {
  @lib.LoadOp::i32_load16u()
}

pub fn lib__LoadOp__i32_load8s() -> @lib.LoadOp {
  @lib.LoadOp::i32_load8s()
}

pub fn lib__LoadOp__i32_load8u() -> @lib.LoadOp {
  @lib.LoadOp::i32_load8u()
}

pub fn lib__LoadOp__i64_atomic_load() -> @lib.LoadOp {
  @lib.LoadOp::i64_atomic_load()
}

pub fn lib__LoadOp__i64_atomic_load16_u() -> @lib.LoadOp {
  @lib.LoadOp::i64_atomic_load16_u()
}

pub fn lib__LoadOp__i64_atomic_load32_u() -> @lib.LoadOp {
  @lib.LoadOp::i64_atomic_load32_u()
}

pub fn lib__LoadOp__i64_atomic_load8_u() -> @lib.LoadOp {
  @lib.LoadOp::i64_atomic_load8_u()
}

pub fn lib__LoadOp__i64_load() -> @lib.LoadOp {
  @lib.LoadOp::i64_load()
}

pub fn lib__LoadOp__i64_load16s() -> @lib.LoadOp {
  @lib.LoadOp::i64_load16s()
}

pub fn lib__LoadOp__i64_load16u() -> @lib.LoadOp {
  @lib.LoadOp::i64_load16u()
}

pub fn lib__LoadOp__i64_load32s() -> @lib.LoadOp {
  @lib.LoadOp::i64_load32s()
}

pub fn lib__LoadOp__i64_load32u() -> @lib.LoadOp {
  @lib.LoadOp::i64_load32u()
}

pub fn lib__LoadOp__i64_load8s() -> @lib.LoadOp {
  @lib.LoadOp::i64_load8s()
}

pub fn lib__LoadOp__i64_load8u() -> @lib.LoadOp {
  @lib.LoadOp::i64_load8u()
}

pub fn lib__LoadOp__v128_load() -> @lib.LoadOp {
  @lib.LoadOp::v128_load()
}

pub fn lib__LoadOp__v128_load16_splat() -> @lib.LoadOp {
  @lib.LoadOp::v128_load16_splat()
}

pub fn lib__LoadOp__v128_load16x4s() -> @lib.LoadOp {
  @lib.LoadOp::v128_load16x4s()
}

pub fn lib__LoadOp__v128_load16x4u() -> @lib.LoadOp {
  @lib.LoadOp::v128_load16x4u()
}

pub fn lib__LoadOp__v128_load32_splat() -> @lib.LoadOp {
  @lib.LoadOp::v128_load32_splat()
}

pub fn lib__LoadOp__v128_load32_zero() -> @lib.LoadOp {
  @lib.LoadOp::v128_load32_zero()
}

pub fn lib__LoadOp__v128_load32x2s() -> @lib.LoadOp {
  @lib.LoadOp::v128_load32x2s()
}

pub fn lib__LoadOp__v128_load32x2u() -> @lib.LoadOp {
  @lib.LoadOp::v128_load32x2u()
}

pub fn lib__LoadOp__v128_load64_splat() -> @lib.LoadOp {
  @lib.LoadOp::v128_load64_splat()
}

pub fn lib__LoadOp__v128_load64_zero() -> @lib.LoadOp {
  @lib.LoadOp::v128_load64_zero()
}

pub fn lib__LoadOp__v128_load8_splat() -> @lib.LoadOp {
  @lib.LoadOp::v128_load8_splat()
}

pub fn lib__LoadOp__v128_load8x8s() -> @lib.LoadOp {
  @lib.LoadOp::v128_load8x8s()
}

pub fn lib__LoadOp__v128_load8x8u() -> @lib.LoadOp {
  @lib.LoadOp::v128_load8x8u()
}

pub fn lib__LocalIdx__inner(arg0 : @lib.LocalIdx) -> UInt {
  @lib.LocalIdx::inner(arg0)
}

pub fn lib__LocalIdx__new(arg0 : UInt) -> @lib.LocalIdx {
  @lib.LocalIdx::new(arg0)
}

pub fn lib__Locals__new(arg0 : UInt, arg1 : @lib.ValType) -> @lib.Locals {
  @lib.Locals::new(arg0, arg1)
}

pub fn lib__MemArg__new(arg0 : @lib.U32, arg1 : @lib.MemIdx?, arg2 : @lib.U64) -> @lib.MemArg {
  @lib.MemArg::new(arg0, arg1, arg2)
}

pub fn lib__MemIdx__inner(arg0 : @lib.MemIdx) -> UInt {
  @lib.MemIdx::inner(arg0)
}

pub fn lib__MemIdx__new(arg0 : UInt) -> @lib.MemIdx {
  @lib.MemIdx::new(arg0)
}

pub fn lib__MemSec__inner(arg0 : @lib.MemSec) -> Array[@lib.MemType] {
  @lib.MemSec::inner(arg0)
}

pub fn lib__MemSec__new(arg0 : Array[@lib.MemType]) -> @lib.MemSec {
  @lib.MemSec::new(arg0)
}

pub fn lib__MemType__inner(arg0 : @lib.MemType) -> @lib.Limits {
  @lib.MemType::inner(arg0)
}

pub fn lib__MemType__new(arg0 : @lib.Limits) -> @lib.MemType {
  @lib.MemType::new(arg0)
}

pub fn lib__Module__new__arity_0() -> @lib.Module {
  @lib.Module::new()
}

pub fn lib__Module__new__arity_1(arg0 : Array[@lib.CustomSec]) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0)
}

pub fn lib__Module__new__arity_2(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1)
}

pub fn lib__Module__new__arity_3(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2)
}

pub fn lib__Module__new__arity_4(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3)
}

pub fn lib__Module__new__arity_5(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4)
}

pub fn lib__Module__new__arity_6(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5)
}

pub fn lib__Module__new__arity_7(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6)
}

pub fn lib__Module__new__arity_8(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7)
}

pub fn lib__Module__new__arity_9(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?, arg8 : @lib.ExportSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7, export_sec=arg8)
}

pub fn lib__Module__new__arity_10(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?, arg8 : @lib.ExportSec?, arg9 : @lib.StartSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7, export_sec=arg8, start_sec=arg9)
}

pub fn lib__Module__new__arity_11(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?, arg8 : @lib.ExportSec?, arg9 : @lib.StartSec?, arg10 : @lib.ElemSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7, export_sec=arg8, start_sec=arg9, elem_sec=arg10)
}

pub fn lib__Module__new__arity_12(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?, arg8 : @lib.ExportSec?, arg9 : @lib.StartSec?, arg10 : @lib.ElemSec?, arg11 : @lib.DataCntSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7, export_sec=arg8, start_sec=arg9, elem_sec=arg10, data_cnt_sec=arg11)
}

pub fn lib__Module__new__arity_13(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?, arg8 : @lib.ExportSec?, arg9 : @lib.StartSec?, arg10 : @lib.ElemSec?, arg11 : @lib.DataCntSec?, arg12 : @lib.CodeSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7, export_sec=arg8, start_sec=arg9, elem_sec=arg10, data_cnt_sec=arg11, code_sec=arg12)
}

pub fn lib__Module__new(arg0 : Array[@lib.CustomSec], arg1 : @lib.TypeSec?, arg2 : @lib.ImportSec?, arg3 : @lib.FuncSec?, arg4 : @lib.TableSec?, arg5 : @lib.MemSec?, arg6 : @lib.TagSec?, arg7 : @lib.GlobalSec?, arg8 : @lib.ExportSec?, arg9 : @lib.StartSec?, arg10 : @lib.ElemSec?, arg11 : @lib.DataCntSec?, arg12 : @lib.CodeSec?, arg13 : @lib.DataSec?) -> @lib.Module {
  @lib.Module::new(custom_secs=arg0, type_sec=arg1, import_sec=arg2, func_sec=arg3, table_sec=arg4, mem_sec=arg5, tag_sec=arg6, global_sec=arg7, export_sec=arg8, start_sec=arg9, elem_sec=arg10, data_cnt_sec=arg11, code_sec=arg12, data_sec=arg13)
}

pub fn lib__Module__with_code_sec(arg0 : @lib.Module, arg1 : @lib.CodeSec) -> @lib.Module {
  @lib.Module::with_code_sec(arg0, arg1)
}

pub fn lib__Module__with_custom_secs(arg0 : @lib.Module, arg1 : Array[@lib.CustomSec]) -> @lib.Module {
  @lib.Module::with_custom_secs(arg0, arg1)
}

pub fn lib__Module__with_data_cnt_sec(arg0 : @lib.Module, arg1 : @lib.DataCntSec) -> @lib.Module {
  @lib.Module::with_data_cnt_sec(arg0, arg1)
}

pub fn lib__Module__with_data_sec(arg0 : @lib.Module, arg1 : @lib.DataSec) -> @lib.Module {
  @lib.Module::with_data_sec(arg0, arg1)
}

pub fn lib__Module__with_elem_sec(arg0 : @lib.Module, arg1 : @lib.ElemSec) -> @lib.Module {
  @lib.Module::with_elem_sec(arg0, arg1)
}

pub fn lib__Module__with_export_sec(arg0 : @lib.Module, arg1 : @lib.ExportSec) -> @lib.Module {
  @lib.Module::with_export_sec(arg0, arg1)
}

pub fn lib__Module__with_func_sec(arg0 : @lib.Module, arg1 : @lib.FuncSec) -> @lib.Module {
  @lib.Module::with_func_sec(arg0, arg1)
}

pub fn lib__Module__with_global_sec(arg0 : @lib.Module, arg1 : @lib.GlobalSec) -> @lib.Module {
  @lib.Module::with_global_sec(arg0, arg1)
}

pub fn lib__Module__with_import_sec(arg0 : @lib.Module, arg1 : @lib.ImportSec) -> @lib.Module {
  @lib.Module::with_import_sec(arg0, arg1)
}

pub fn lib__Module__with_mem_sec(arg0 : @lib.Module, arg1 : @lib.MemSec) -> @lib.Module {
  @lib.Module::with_mem_sec(arg0, arg1)
}

pub fn lib__Module__with_start_sec(arg0 : @lib.Module, arg1 : @lib.StartSec) -> @lib.Module {
  @lib.Module::with_start_sec(arg0, arg1)
}

pub fn lib__Module__with_table_sec(arg0 : @lib.Module, arg1 : @lib.TableSec) -> @lib.Module {
  @lib.Module::with_table_sec(arg0, arg1)
}

pub fn lib__Module__with_tag_sec(arg0 : @lib.Module, arg1 : @lib.TagSec) -> @lib.Module {
  @lib.Module::with_tag_sec(arg0, arg1)
}

pub fn lib__Module__with_type_sec(arg0 : @lib.Module, arg1 : @lib.TypeSec) -> @lib.Module {
  @lib.Module::with_type_sec(arg0, arg1)
}

pub fn lib__Mut__const_() -> @lib.Mut {
  @lib.Mut::const_()
}

pub fn lib__Mut__var_() -> @lib.Mut {
  @lib.Mut::var_()
}

pub fn lib__Name__inner(arg0 : @lib.Name) -> StringView {
  @lib.Name::inner(arg0)
}

pub fn lib__Name__new(arg0 : StringView) -> @lib.Name {
  @lib.Name::new(arg0)
}

pub fn lib__NumType__f32() -> @lib.NumType {
  @lib.NumType::f32()
}

pub fn lib__NumType__f64() -> @lib.NumType {
  @lib.NumType::f64()
}

pub fn lib__NumType__i32() -> @lib.NumType {
  @lib.NumType::i32()
}

pub fn lib__NumType__i64() -> @lib.NumType {
  @lib.NumType::i64()
}

pub fn lib__PackType__i16() -> @lib.PackType {
  @lib.PackType::i16()
}

pub fn lib__PackType__i8() -> @lib.PackType {
  @lib.PackType::i8()
}

pub fn lib__PrettyPrintContext__indent(arg0 : @lib.PrettyPrintContext, arg1 : UInt) -> String {
  @lib.PrettyPrintContext::indent(arg0, arg1)
}

pub fn lib__PrettyPrintContext__indent_unit(arg0 : @lib.PrettyPrintContext) -> String {
  @lib.PrettyPrintContext::indent_unit(arg0)
}

pub fn lib__PrettyPrintContext__new__arity_0() -> @lib.PrettyPrintContext {
  @lib.PrettyPrintContext::new()
}

pub fn lib__PrettyPrintContext__new__arity_1(arg0 : UInt) -> @lib.PrettyPrintContext {
  @lib.PrettyPrintContext::new(max_line_width=arg0)
}

pub fn lib__PrettyPrintContext__new__arity_2(arg0 : UInt, arg1 : @lib.TabsOrSpaces) -> @lib.PrettyPrintContext {
  @lib.PrettyPrintContext::new(max_line_width=arg0, tabs_or_spaces=arg1)
}

pub fn lib__PrettyPrintContext__new__arity_3(arg0 : UInt, arg1 : @lib.TabsOrSpaces, arg2 : UInt) -> @lib.PrettyPrintContext {
  @lib.PrettyPrintContext::new(max_line_width=arg0, tabs_or_spaces=arg1, tab_width=arg2)
}

pub fn lib__PrettyPrintContext__new__arity_4(arg0 : UInt, arg1 : @lib.TabsOrSpaces, arg2 : UInt, arg3 : UInt) -> @lib.PrettyPrintContext {
  @lib.PrettyPrintContext::new(max_line_width=arg0, tabs_or_spaces=arg1, tab_width=arg2, continuation_indent=arg3)
}

pub fn lib__PrettyPrintContext__new(arg0 : UInt, arg1 : @lib.TabsOrSpaces, arg2 : UInt, arg3 : UInt, arg4 : UInt) -> @lib.PrettyPrintContext {
  @lib.PrettyPrintContext::new(max_line_width=arg0, tabs_or_spaces=arg1, tab_width=arg2, continuation_indent=arg3, source_indent_width=arg4)
}

pub fn lib__RecType__get_subtype(arg0 : @lib.RecType, arg1 : UInt) -> @lib.SubType? {
  @lib.RecType::get_subtype(arg0, arg1)
}

pub fn lib__RecType__group(arg0 : Array[@lib.SubType]) -> @lib.RecType {
  @lib.RecType::group(arg0)
}

pub fn lib__RecType__new(arg0 : @lib.SubType) -> @lib.RecType {
  @lib.RecType::new(arg0)
}

pub fn lib__RefType__abs(arg0 : @lib.AbsHeapType) -> @lib.RefType {
  @lib.RefType::abs(arg0)
}

pub fn lib__RefType__get_heap_type(arg0 : @lib.RefType) -> @lib.HeapType {
  @lib.RefType::get_heap_type(arg0)
}

pub fn lib__RefType__is_defaultable(arg0 : @lib.RefType) -> Bool {
  @lib.RefType::is_defaultable(arg0)
}

pub fn lib__RefType__is_non_nullable(arg0 : @lib.RefType) -> Bool {
  @lib.RefType::is_non_nullable(arg0)
}

pub fn lib__RefType__is_nullable(arg0 : @lib.RefType) -> Bool {
  @lib.RefType::is_nullable(arg0)
}

pub fn lib__RefType__make_nullable(arg0 : @lib.RefType) -> @lib.RefType {
  @lib.RefType::make_nullable(arg0)
}

pub fn lib__RefType__new(arg0 : Bool, arg1 : @lib.HeapType) -> @lib.RefType {
  @lib.RefType::new(arg0, arg1)
}

pub fn lib__ReplaceLaneOp__f32x4_replace_lane() -> @lib.ReplaceLaneOp {
  @lib.ReplaceLaneOp::f32x4_replace_lane()
}

pub fn lib__ReplaceLaneOp__f64x2_replace_lane() -> @lib.ReplaceLaneOp {
  @lib.ReplaceLaneOp::f64x2_replace_lane()
}

pub fn lib__ReplaceLaneOp__i16x8_replace_lane() -> @lib.ReplaceLaneOp {
  @lib.ReplaceLaneOp::i16x8_replace_lane()
}

pub fn lib__ReplaceLaneOp__i32x4_replace_lane() -> @lib.ReplaceLaneOp {
  @lib.ReplaceLaneOp::i32x4_replace_lane()
}

pub fn lib__ReplaceLaneOp__i64x2_replace_lane() -> @lib.ReplaceLaneOp {
  @lib.ReplaceLaneOp::i64x2_replace_lane()
}

pub fn lib__ReplaceLaneOp__i8x16_replace_lane() -> @lib.ReplaceLaneOp {
  @lib.ReplaceLaneOp::i8x16_replace_lane()
}

pub fn lib__S33__inner(arg0 : @lib.S33) -> UInt {
  @lib.S33::inner(arg0)
}

pub fn lib__StartSec__inner(arg0 : @lib.StartSec) -> @lib.FuncIdx {
  @lib.StartSec::inner(arg0)
}

pub fn lib__StartSec__new(arg0 : @lib.FuncIdx) -> @lib.StartSec {
  @lib.StartSec::new(arg0)
}

pub fn lib__StorageType__is_packed(arg0 : @lib.StorageType) -> Bool {
  @lib.StorageType::is_packed(arg0)
}

pub fn lib__StorageType__pack_type(arg0 : @lib.PackType) -> @lib.StorageType {
  @lib.StorageType::pack_type(arg0)
}

pub fn lib__StorageType__unpack(arg0 : @lib.StorageType) -> @lib.ValType {
  @lib.StorageType::unpack(arg0)
}

pub fn lib__StorageType__val_type(arg0 : @lib.ValType) -> @lib.StorageType {
  @lib.StorageType::val_type(arg0)
}

pub fn lib__StoreOp__f32_store() -> @lib.StoreOp {
  @lib.StoreOp::f32_store()
}

pub fn lib__StoreOp__f64_store() -> @lib.StoreOp {
  @lib.StoreOp::f64_store()
}

pub fn lib__StoreOp__i32_atomic_store() -> @lib.StoreOp {
  @lib.StoreOp::i32_atomic_store()
}

pub fn lib__StoreOp__i32_atomic_store16() -> @lib.StoreOp {
  @lib.StoreOp::i32_atomic_store16()
}

pub fn lib__StoreOp__i32_atomic_store8() -> @lib.StoreOp {
  @lib.StoreOp::i32_atomic_store8()
}

pub fn lib__StoreOp__i32_store() -> @lib.StoreOp {
  @lib.StoreOp::i32_store()
}

pub fn lib__StoreOp__i32_store16() -> @lib.StoreOp {
  @lib.StoreOp::i32_store16()
}

pub fn lib__StoreOp__i32_store8() -> @lib.StoreOp {
  @lib.StoreOp::i32_store8()
}

pub fn lib__StoreOp__i64_atomic_store() -> @lib.StoreOp {
  @lib.StoreOp::i64_atomic_store()
}

pub fn lib__StoreOp__i64_atomic_store16() -> @lib.StoreOp {
  @lib.StoreOp::i64_atomic_store16()
}

pub fn lib__StoreOp__i64_atomic_store32() -> @lib.StoreOp {
  @lib.StoreOp::i64_atomic_store32()
}

pub fn lib__StoreOp__i64_atomic_store8() -> @lib.StoreOp {
  @lib.StoreOp::i64_atomic_store8()
}

pub fn lib__StoreOp__i64_store() -> @lib.StoreOp {
  @lib.StoreOp::i64_store()
}

pub fn lib__StoreOp__i64_store16() -> @lib.StoreOp {
  @lib.StoreOp::i64_store16()
}

pub fn lib__StoreOp__i64_store32() -> @lib.StoreOp {
  @lib.StoreOp::i64_store32()
}

pub fn lib__StoreOp__i64_store8() -> @lib.StoreOp {
  @lib.StoreOp::i64_store8()
}

pub fn lib__StoreOp__v128_store() -> @lib.StoreOp {
  @lib.StoreOp::v128_store()
}

pub fn lib__SubType__comp_type(arg0 : @lib.CompType) -> @lib.SubType {
  @lib.SubType::comp_type(arg0)
}

pub fn lib__SubType__get_comptype(arg0 : @lib.SubType) -> @lib.CompType {
  @lib.SubType::get_comptype(arg0)
}

pub fn lib__SubType__new(arg0 : Bool, arg1 : Array[@lib.TypeIdx], arg2 : @lib.CompType) -> @lib.SubType {
  @lib.SubType::new(arg0, arg1, arg2)
}

pub fn lib__SubType__super_types(arg0 : @lib.SubType) -> Array[@lib.TypeIdx] {
  @lib.SubType::super_types(arg0)
}

pub fn lib__TExpr__inner(arg0 : @lib.TExpr) -> Array[@lib.TInstr] {
  @lib.TExpr::inner(arg0)
}

pub fn lib__TExpr__new(arg0 : Array[@lib.TInstr]) -> @lib.TExpr {
  @lib.TExpr::new(arg0)
}

pub fn lib__TExpr__to_expr(arg0 : @lib.TExpr) -> @lib.Expr {
  @lib.TExpr::to_expr(arg0)
}

pub fn lib__TInstr__any_convert_extern(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::any_convert_extern(arg0)
}

pub fn lib__TInstr__array_copy(arg0 : @lib.TypeIdx, arg1 : @lib.TypeIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr, arg5 : @lib.TInstr, arg6 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_copy(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

pub fn lib__TInstr__array_fill(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_fill(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__array_get(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_get(arg0, arg1, arg2)
}

pub fn lib__TInstr__array_get_s(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_get_s(arg0, arg1, arg2)
}

pub fn lib__TInstr__array_get_u(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_get_u(arg0, arg1, arg2)
}

pub fn lib__TInstr__array_init_data(arg0 : @lib.TypeIdx, arg1 : @lib.DataIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr, arg5 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_init_data(arg0, arg1, arg2, arg3, arg4, arg5)
}

pub fn lib__TInstr__array_init_elem(arg0 : @lib.TypeIdx, arg1 : @lib.ElemIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr, arg5 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_init_elem(arg0, arg1, arg2, arg3, arg4, arg5)
}

pub fn lib__TInstr__array_len(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_len(arg0)
}

pub fn lib__TInstr__array_new(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_new(arg0, arg1, arg2)
}

pub fn lib__TInstr__array_new_data(arg0 : @lib.TypeIdx, arg1 : @lib.DataIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_new_data(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__array_new_default(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_new_default(arg0, arg1)
}

pub fn lib__TInstr__array_new_elem(arg0 : @lib.TypeIdx, arg1 : @lib.ElemIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_new_elem(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__array_new_fixed(arg0 : @lib.TypeIdx, arg1 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::array_new_fixed(arg0, arg1)
}

pub fn lib__TInstr__array_set(arg0 : @lib.TypeIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::array_set(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__atomic_cmpxchg(arg0 : @lib.AtomicCmpxchgOp, arg1 : @lib.MemArg, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::atomic_cmpxchg(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__atomic_fence() -> @lib.TInstr {
  @lib.TInstr::atomic_fence()
}

pub fn lib__TInstr__atomic_rmw(arg0 : @lib.AtomicRmwOp, arg1 : @lib.MemArg, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::atomic_rmw(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__binary(arg0 : @lib.BinaryOp, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::binary(arg0, arg1, arg2)
}

pub fn lib__TInstr__block(arg0 : @lib.BlockType, arg1 : @lib.TExpr) -> @lib.TInstr {
  @lib.TInstr::block(arg0, arg1)
}

pub fn lib__TInstr__br(arg0 : @lib.LabelIdx, arg1 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br(arg0, arg1)
}

pub fn lib__TInstr__br_if(arg0 : @lib.LabelIdx, arg1 : @lib.TInstr, arg2 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br_if(arg0, arg1, arg2)
}

pub fn lib__TInstr__br_on_cast(arg0 : @lib.LabelIdx, arg1 : Bool, arg2 : @lib.HeapType, arg3 : Bool, arg4 : @lib.HeapType, arg5 : @lib.TInstr, arg6 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br_on_cast(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

pub fn lib__TInstr__br_on_cast_fail(arg0 : @lib.LabelIdx, arg1 : Bool, arg2 : @lib.HeapType, arg3 : Bool, arg4 : @lib.HeapType, arg5 : @lib.TInstr, arg6 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br_on_cast_fail(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

pub fn lib__TInstr__br_on_non_null(arg0 : @lib.LabelIdx, arg1 : @lib.TInstr, arg2 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br_on_non_null(arg0, arg1, arg2)
}

pub fn lib__TInstr__br_on_null(arg0 : @lib.LabelIdx, arg1 : @lib.TInstr, arg2 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br_on_null(arg0, arg1, arg2)
}

pub fn lib__TInstr__br_table(arg0 : Array[@lib.LabelIdx], arg1 : @lib.LabelIdx, arg2 : @lib.TInstr, arg3 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::br_table(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__call(arg0 : @lib.FuncIdx, arg1 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::call(arg0, arg1)
}

pub fn lib__TInstr__call_indirect(arg0 : @lib.TypeIdx, arg1 : @lib.TableIdx, arg2 : Array[@lib.TInstr], arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::call_indirect(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__call_ref(arg0 : @lib.TypeIdx, arg1 : Array[@lib.TInstr], arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::call_ref(arg0, arg1, arg2)
}

pub fn lib__TInstr__data_drop(arg0 : @lib.DataIdx) -> @lib.TInstr {
  @lib.TInstr::data_drop(arg0)
}

pub fn lib__TInstr__drop(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::drop(arg0)
}

pub fn lib__TInstr__elem_drop(arg0 : @lib.ElemIdx) -> @lib.TInstr {
  @lib.TInstr::elem_drop(arg0)
}

pub fn lib__TInstr__extern_convert_any(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::extern_convert_any(arg0)
}

pub fn lib__TInstr__extract_lane(arg0 : @lib.ExtractLaneOp, arg1 : @lib.LaneIdx, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::extract_lane(arg0, arg1, arg2)
}

pub fn lib__TInstr__f32_const(arg0 : @lib.F32) -> @lib.TInstr {
  @lib.TInstr::f32_const(arg0)
}

pub fn lib__TInstr__f32x4_splat(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::f32x4_splat(arg0)
}

pub fn lib__TInstr__f64_const(arg0 : @lib.F64) -> @lib.TInstr {
  @lib.TInstr::f64_const(arg0)
}

pub fn lib__TInstr__f64x2_splat(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::f64x2_splat(arg0)
}

pub fn lib__TInstr__global_get(arg0 : @lib.GlobalIdx) -> @lib.TInstr {
  @lib.TInstr::global_get(arg0)
}

pub fn lib__TInstr__global_set(arg0 : @lib.GlobalIdx, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::global_set(arg0, arg1)
}

pub fn lib__TInstr__i16x8_splat(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i16x8_splat(arg0)
}

pub fn lib__TInstr__i31_get_s(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i31_get_s(arg0)
}

pub fn lib__TInstr__i31_get_u(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i31_get_u(arg0)
}

pub fn lib__TInstr__i32_const(arg0 : @lib.I32) -> @lib.TInstr {
  @lib.TInstr::i32_const(arg0)
}

pub fn lib__TInstr__i32x4_splat(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i32x4_splat(arg0)
}

pub fn lib__TInstr__i64_const(arg0 : @lib.I64) -> @lib.TInstr {
  @lib.TInstr::i64_const(arg0)
}

pub fn lib__TInstr__i64x2_splat(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i64x2_splat(arg0)
}

pub fn lib__TInstr__i8x16_relaxed_swizzle(arg0 : @lib.TInstr, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i8x16_relaxed_swizzle(arg0, arg1)
}

pub fn lib__TInstr__i8x16_shuffle(arg0 : @lib.LaneIdx, arg1 : @lib.LaneIdx, arg2 : @lib.LaneIdx, arg3 : @lib.LaneIdx, arg4 : @lib.LaneIdx, arg5 : @lib.LaneIdx, arg6 : @lib.LaneIdx, arg7 : @lib.LaneIdx, arg8 : @lib.LaneIdx, arg9 : @lib.LaneIdx, arg10 : @lib.LaneIdx, arg11 : @lib.LaneIdx, arg12 : @lib.LaneIdx, arg13 : @lib.LaneIdx, arg14 : @lib.LaneIdx, arg15 : @lib.LaneIdx, arg16 : @lib.TInstr, arg17 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i8x16_shuffle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17)
}

pub fn lib__TInstr__i8x16_splat(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i8x16_splat(arg0)
}

pub fn lib__TInstr__i8x16_swizzle(arg0 : @lib.TInstr, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::i8x16_swizzle(arg0, arg1)
}

pub fn lib__TInstr__if_(arg0 : @lib.BlockType, arg1 : @lib.TInstr, arg2 : @lib.TExpr, arg3 : @lib.TExpr?) -> @lib.TInstr {
  @lib.TInstr::if_(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__load(arg0 : @lib.LoadOp, arg1 : @lib.MemArg, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::load(arg0, arg1, arg2)
}

pub fn lib__TInstr__local_get(arg0 : @lib.LocalIdx) -> @lib.TInstr {
  @lib.TInstr::local_get(arg0)
}

pub fn lib__TInstr__local_set(arg0 : @lib.LocalIdx, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::local_set(arg0, arg1)
}

pub fn lib__TInstr__local_tee(arg0 : @lib.LocalIdx, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::local_tee(arg0, arg1)
}

pub fn lib__TInstr__loop_(arg0 : @lib.BlockType, arg1 : @lib.TExpr) -> @lib.TInstr {
  @lib.TInstr::loop_(arg0, arg1)
}

pub fn lib__TInstr__memory_atomic_notify(arg0 : @lib.MemArg, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_atomic_notify(arg0, arg1, arg2)
}

pub fn lib__TInstr__memory_atomic_wait32(arg0 : @lib.MemArg, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_atomic_wait32(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__memory_atomic_wait64(arg0 : @lib.MemArg, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_atomic_wait64(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__memory_copy(arg0 : @lib.MemIdx, arg1 : @lib.MemIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_copy(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__memory_fill(arg0 : @lib.MemIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_fill(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__memory_grow(arg0 : @lib.MemIdx, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_grow(arg0, arg1)
}

pub fn lib__TInstr__memory_init(arg0 : @lib.DataIdx, arg1 : @lib.MemIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::memory_init(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__memory_size(arg0 : @lib.MemIdx) -> @lib.TInstr {
  @lib.TInstr::memory_size(arg0)
}

pub fn lib__TInstr__nop() -> @lib.TInstr {
  @lib.TInstr::nop()
}

pub fn lib__TInstr__ref_as_non_null(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_as_non_null(arg0)
}

pub fn lib__TInstr__ref_cast(arg0 : Bool, arg1 : @lib.HeapType, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_cast(arg0, arg1, arg2)
}

pub fn lib__TInstr__ref_cast_desc_eq(arg0 : Bool, arg1 : @lib.HeapType, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_cast_desc_eq(arg0, arg1, arg2)
}

pub fn lib__TInstr__ref_eq(arg0 : @lib.TInstr, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_eq(arg0, arg1)
}

pub fn lib__TInstr__ref_func(arg0 : @lib.FuncIdx) -> @lib.TInstr {
  @lib.TInstr::ref_func(arg0)
}

pub fn lib__TInstr__ref_get_desc(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_get_desc(arg0)
}

pub fn lib__TInstr__ref_i31(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_i31(arg0)
}

pub fn lib__TInstr__ref_is_null(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_is_null(arg0)
}

pub fn lib__TInstr__ref_null(arg0 : @lib.HeapType) -> @lib.TInstr {
  @lib.TInstr::ref_null(arg0)
}

pub fn lib__TInstr__ref_test(arg0 : Bool, arg1 : @lib.HeapType, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_test(arg0, arg1, arg2)
}

pub fn lib__TInstr__ref_test_desc(arg0 : Bool, arg1 : @lib.HeapType, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::ref_test_desc(arg0, arg1, arg2)
}

pub fn lib__TInstr__replace_lane(arg0 : @lib.ReplaceLaneOp, arg1 : @lib.LaneIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::replace_lane(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__return_(arg0 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::return_(arg0)
}

pub fn lib__TInstr__return_call(arg0 : @lib.FuncIdx, arg1 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::return_call(arg0, arg1)
}

pub fn lib__TInstr__return_call_indirect(arg0 : @lib.TypeIdx, arg1 : @lib.TableIdx, arg2 : Array[@lib.TInstr], arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::return_call_indirect(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__return_call_ref(arg0 : @lib.TypeIdx, arg1 : Array[@lib.TInstr], arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::return_call_ref(arg0, arg1, arg2)
}

pub fn lib__TInstr__select(arg0 : Array[@lib.ValType]?, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::select(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__store(arg0 : @lib.StoreOp, arg1 : @lib.MemArg, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::store(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__struct_get(arg0 : @lib.TypeIdx, arg1 : @lib.U32, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::struct_get(arg0, arg1, arg2)
}

pub fn lib__TInstr__struct_get_s(arg0 : @lib.TypeIdx, arg1 : @lib.U32, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::struct_get_s(arg0, arg1, arg2)
}

pub fn lib__TInstr__struct_get_u(arg0 : @lib.TypeIdx, arg1 : @lib.U32, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::struct_get_u(arg0, arg1, arg2)
}

pub fn lib__TInstr__struct_new(arg0 : @lib.TypeIdx, arg1 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::struct_new(arg0, arg1)
}

pub fn lib__TInstr__struct_new_default(arg0 : @lib.TypeIdx) -> @lib.TInstr {
  @lib.TInstr::struct_new_default(arg0)
}

pub fn lib__TInstr__struct_set(arg0 : @lib.TypeIdx, arg1 : @lib.U32, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::struct_set(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__table_copy(arg0 : @lib.TableIdx, arg1 : @lib.TableIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::table_copy(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__table_fill(arg0 : @lib.TableIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::table_fill(arg0, arg1, arg2, arg3)
}

pub fn lib__TInstr__table_get(arg0 : @lib.TableIdx, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::table_get(arg0, arg1)
}

pub fn lib__TInstr__table_grow(arg0 : @lib.TableIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::table_grow(arg0, arg1, arg2)
}

pub fn lib__TInstr__table_init(arg0 : @lib.ElemIdx, arg1 : @lib.TableIdx, arg2 : @lib.TInstr, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::table_init(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__table_set(arg0 : @lib.TableIdx, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::table_set(arg0, arg1, arg2)
}

pub fn lib__TInstr__table_size(arg0 : @lib.TableIdx) -> @lib.TInstr {
  @lib.TInstr::table_size(arg0)
}

pub fn lib__TInstr__throw_(arg0 : @lib.TagIdx, arg1 : Array[@lib.TInstr]) -> @lib.TInstr {
  @lib.TInstr::throw_(arg0, arg1)
}

pub fn lib__TInstr__throw_ref(arg0 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::throw_ref(arg0)
}

pub fn lib__TInstr__try_table(arg0 : @lib.BlockType, arg1 : Array[@lib.Catch], arg2 : @lib.TExpr) -> @lib.TInstr {
  @lib.TInstr::try_table(arg0, arg1, arg2)
}

pub fn lib__TInstr__unary(arg0 : @lib.UnaryOp, arg1 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::unary(arg0, arg1)
}

pub fn lib__TInstr__unreachable_() -> @lib.TInstr {
  @lib.TInstr::unreachable_()
}

pub fn lib__TInstr__v128_const(arg0 : Byte, arg1 : Byte, arg2 : Byte, arg3 : Byte, arg4 : Byte, arg5 : Byte, arg6 : Byte, arg7 : Byte, arg8 : Byte, arg9 : Byte, arg10 : Byte, arg11 : Byte, arg12 : Byte, arg13 : Byte, arg14 : Byte, arg15 : Byte) -> @lib.TInstr {
  @lib.TInstr::v128_const(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
}

pub fn lib__TInstr__v128_load_lane(arg0 : @lib.V128LoadLaneOp, arg1 : @lib.MemArg, arg2 : @lib.LaneIdx, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::v128_load_lane(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__v128_shift(arg0 : @lib.V128ShiftOp, arg1 : @lib.TInstr, arg2 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::v128_shift(arg0, arg1, arg2)
}

pub fn lib__TInstr__v128_store_lane(arg0 : @lib.V128StoreLaneOp, arg1 : @lib.MemArg, arg2 : @lib.LaneIdx, arg3 : @lib.TInstr, arg4 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::v128_store_lane(arg0, arg1, arg2, arg3, arg4)
}

pub fn lib__TInstr__v128_ternary(arg0 : @lib.V128TernaryOp, arg1 : @lib.TInstr, arg2 : @lib.TInstr, arg3 : @lib.TInstr) -> @lib.TInstr {
  @lib.TInstr::v128_ternary(arg0, arg1, arg2, arg3)
}

pub fn lib__Table__new(arg0 : @lib.TableType, arg1 : @lib.Expr?) -> @lib.Table {
  @lib.Table::new(arg0, arg1)
}

pub fn lib__TableIdx__inner(arg0 : @lib.TableIdx) -> UInt {
  @lib.TableIdx::inner(arg0)
}

pub fn lib__TableIdx__new(arg0 : UInt) -> @lib.TableIdx {
  @lib.TableIdx::new(arg0)
}

pub fn lib__TableSec__inner(arg0 : @lib.TableSec) -> Array[@lib.Table] {
  @lib.TableSec::inner(arg0)
}

pub fn lib__TableSec__new(arg0 : Array[@lib.Table]) -> @lib.TableSec {
  @lib.TableSec::new(arg0)
}

pub fn lib__TableType__new(arg0 : @lib.RefType, arg1 : @lib.Limits) -> @lib.TableType {
  @lib.TableType::new(arg0, arg1)
}

pub fn lib__TabsOrSpaces__spaces() -> @lib.TabsOrSpaces {
  @lib.TabsOrSpaces::spaces()
}

pub fn lib__TabsOrSpaces__tabs() -> @lib.TabsOrSpaces {
  @lib.TabsOrSpaces::tabs()
}

pub fn lib__TagIdx__inner(arg0 : @lib.TagIdx) -> UInt {
  @lib.TagIdx::inner(arg0)
}

pub fn lib__TagIdx__new(arg0 : UInt) -> @lib.TagIdx {
  @lib.TagIdx::new(arg0)
}

pub fn lib__TagSec__inner(arg0 : @lib.TagSec) -> Array[@lib.TagType] {
  @lib.TagSec::inner(arg0)
}

pub fn lib__TagSec__new(arg0 : Array[@lib.TagType]) -> @lib.TagSec {
  @lib.TagSec::new(arg0)
}

pub fn lib__TagType__inner(arg0 : @lib.TagType) -> @lib.TypeIdx {
  @lib.TagType::inner(arg0)
}

pub fn lib__TagType__new(arg0 : @lib.TypeIdx) -> @lib.TagType {
  @lib.TagType::new(arg0)
}

pub fn lib__TypeIdx__new(arg0 : UInt) -> @lib.TypeIdx {
  @lib.TypeIdx::new(arg0)
}

pub fn lib__TypeIdx__rec(arg0 : UInt) -> @lib.TypeIdx {
  @lib.TypeIdx::rec(arg0)
}

pub fn lib__TypeSec__inner(arg0 : @lib.TypeSec) -> Array[@lib.RecType] {
  @lib.TypeSec::inner(arg0)
}

pub fn lib__TypeSec__new(arg0 : Array[@lib.RecType]) -> @lib.TypeSec {
  @lib.TypeSec::new(arg0)
}

pub fn lib__U32__inner(arg0 : @lib.U32) -> UInt {
  @lib.U32::inner(arg0)
}

pub fn lib__U64__inner(arg0 : @lib.U64) -> UInt64 {
  @lib.U64::inner(arg0)
}

pub fn lib__UnaryOp__f32_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_abs()
}

pub fn lib__UnaryOp__f32_ceil() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_ceil()
}

pub fn lib__UnaryOp__f32_convert_i32s() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_convert_i32s()
}

pub fn lib__UnaryOp__f32_convert_i32u() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_convert_i32u()
}

pub fn lib__UnaryOp__f32_convert_i64s() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_convert_i64s()
}

pub fn lib__UnaryOp__f32_convert_i64u() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_convert_i64u()
}

pub fn lib__UnaryOp__f32_demote_f64() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_demote_f64()
}

pub fn lib__UnaryOp__f32_floor() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_floor()
}

pub fn lib__UnaryOp__f32_nearest() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_nearest()
}

pub fn lib__UnaryOp__f32_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_neg()
}

pub fn lib__UnaryOp__f32_reinterpret_i32() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_reinterpret_i32()
}

pub fn lib__UnaryOp__f32_sqrt() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_sqrt()
}

pub fn lib__UnaryOp__f32_trunc() -> @lib.UnaryOp {
  @lib.UnaryOp::f32_trunc()
}

pub fn lib__UnaryOp__f32x4_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_abs()
}

pub fn lib__UnaryOp__f32x4_ceil() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_ceil()
}

pub fn lib__UnaryOp__f32x4_convert_i32x4s() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_convert_i32x4s()
}

pub fn lib__UnaryOp__f32x4_convert_i32x4u() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_convert_i32x4u()
}

pub fn lib__UnaryOp__f32x4_demote_f64x2_zero() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_demote_f64x2_zero()
}

pub fn lib__UnaryOp__f32x4_floor() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_floor()
}

pub fn lib__UnaryOp__f32x4_nearest() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_nearest()
}

pub fn lib__UnaryOp__f32x4_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_neg()
}

pub fn lib__UnaryOp__f32x4_sqrt() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_sqrt()
}

pub fn lib__UnaryOp__f32x4_trunc() -> @lib.UnaryOp {
  @lib.UnaryOp::f32x4_trunc()
}

pub fn lib__UnaryOp__f64_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_abs()
}

pub fn lib__UnaryOp__f64_ceil() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_ceil()
}

pub fn lib__UnaryOp__f64_convert_i32s() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_convert_i32s()
}

pub fn lib__UnaryOp__f64_convert_i32u() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_convert_i32u()
}

pub fn lib__UnaryOp__f64_convert_i64s() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_convert_i64s()
}

pub fn lib__UnaryOp__f64_convert_i64u() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_convert_i64u()
}

pub fn lib__UnaryOp__f64_floor() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_floor()
}

pub fn lib__UnaryOp__f64_nearest() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_nearest()
}

pub fn lib__UnaryOp__f64_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_neg()
}

pub fn lib__UnaryOp__f64_promote_f32() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_promote_f32()
}

pub fn lib__UnaryOp__f64_reinterpret_i64() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_reinterpret_i64()
}

pub fn lib__UnaryOp__f64_sqrt() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_sqrt()
}

pub fn lib__UnaryOp__f64_trunc() -> @lib.UnaryOp {
  @lib.UnaryOp::f64_trunc()
}

pub fn lib__UnaryOp__f64x2_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_abs()
}

pub fn lib__UnaryOp__f64x2_ceil() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_ceil()
}

pub fn lib__UnaryOp__f64x2_convert_low_i32x4s() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_convert_low_i32x4s()
}

pub fn lib__UnaryOp__f64x2_convert_low_i32x4u() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_convert_low_i32x4u()
}

pub fn lib__UnaryOp__f64x2_floor() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_floor()
}

pub fn lib__UnaryOp__f64x2_nearest() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_nearest()
}

pub fn lib__UnaryOp__f64x2_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_neg()
}

pub fn lib__UnaryOp__f64x2_promote_low_f32x4() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_promote_low_f32x4()
}

pub fn lib__UnaryOp__f64x2_sqrt() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_sqrt()
}

pub fn lib__UnaryOp__f64x2_trunc() -> @lib.UnaryOp {
  @lib.UnaryOp::f64x2_trunc()
}

pub fn lib__UnaryOp__i16x8_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_abs()
}

pub fn lib__UnaryOp__i16x8_all_true() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_all_true()
}

pub fn lib__UnaryOp__i16x8_bitmask() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_bitmask()
}

pub fn lib__UnaryOp__i16x8_extadd_pairwise_i8x16s() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_extadd_pairwise_i8x16s()
}

pub fn lib__UnaryOp__i16x8_extadd_pairwise_i8x16u() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_extadd_pairwise_i8x16u()
}

pub fn lib__UnaryOp__i16x8_extend_high_i8x16s() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_extend_high_i8x16s()
}

pub fn lib__UnaryOp__i16x8_extend_high_i8x16u() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_extend_high_i8x16u()
}

pub fn lib__UnaryOp__i16x8_extend_low_i8x16s() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_extend_low_i8x16s()
}

pub fn lib__UnaryOp__i16x8_extend_low_i8x16u() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_extend_low_i8x16u()
}

pub fn lib__UnaryOp__i16x8_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::i16x8_neg()
}

pub fn lib__UnaryOp__i32_clz() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_clz()
}

pub fn lib__UnaryOp__i32_ctz() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_ctz()
}

pub fn lib__UnaryOp__i32_eqz() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_eqz()
}

pub fn lib__UnaryOp__i32_extend16s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_extend16s()
}

pub fn lib__UnaryOp__i32_extend8s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_extend8s()
}

pub fn lib__UnaryOp__i32_popcnt() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_popcnt()
}

pub fn lib__UnaryOp__i32_reinterpret_f32() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_reinterpret_f32()
}

pub fn lib__UnaryOp__i32_trunc_f32s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_f32s()
}

pub fn lib__UnaryOp__i32_trunc_f32u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_f32u()
}

pub fn lib__UnaryOp__i32_trunc_f64s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_f64s()
}

pub fn lib__UnaryOp__i32_trunc_f64u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_f64u()
}

pub fn lib__UnaryOp__i32_trunc_sat_f32s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_sat_f32s()
}

pub fn lib__UnaryOp__i32_trunc_sat_f32u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_sat_f32u()
}

pub fn lib__UnaryOp__i32_trunc_sat_f64s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_sat_f64s()
}

pub fn lib__UnaryOp__i32_trunc_sat_f64u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_trunc_sat_f64u()
}

pub fn lib__UnaryOp__i32_wrap_i64() -> @lib.UnaryOp {
  @lib.UnaryOp::i32_wrap_i64()
}

pub fn lib__UnaryOp__i32x4_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_abs()
}

pub fn lib__UnaryOp__i32x4_all_true() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_all_true()
}

pub fn lib__UnaryOp__i32x4_bitmask() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_bitmask()
}

pub fn lib__UnaryOp__i32x4_extadd_pairwise_i16x8s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_extadd_pairwise_i16x8s()
}

pub fn lib__UnaryOp__i32x4_extadd_pairwise_i16x8u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_extadd_pairwise_i16x8u()
}

pub fn lib__UnaryOp__i32x4_extend_high_i16x8s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_extend_high_i16x8s()
}

pub fn lib__UnaryOp__i32x4_extend_high_i16x8u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_extend_high_i16x8u()
}

pub fn lib__UnaryOp__i32x4_extend_low_i16x8s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_extend_low_i16x8s()
}

pub fn lib__UnaryOp__i32x4_extend_low_i16x8u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_extend_low_i16x8u()
}

pub fn lib__UnaryOp__i32x4_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_neg()
}

pub fn lib__UnaryOp__i32x4_relaxed_trunc_f32x4s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_relaxed_trunc_f32x4s()
}

pub fn lib__UnaryOp__i32x4_relaxed_trunc_f32x4u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_relaxed_trunc_f32x4u()
}

pub fn lib__UnaryOp__i32x4_relaxed_trunc_zero_f64x2s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_relaxed_trunc_zero_f64x2s()
}

pub fn lib__UnaryOp__i32x4_relaxed_trunc_zero_f64x2u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_relaxed_trunc_zero_f64x2u()
}

pub fn lib__UnaryOp__i32x4_trunc_sat_f32x4s() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_trunc_sat_f32x4s()
}

pub fn lib__UnaryOp__i32x4_trunc_sat_f32x4u() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_trunc_sat_f32x4u()
}

pub fn lib__UnaryOp__i32x4_trunc_sat_f64x2s_zero() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_trunc_sat_f64x2s_zero()
}

pub fn lib__UnaryOp__i32x4_trunc_sat_f64x2u_zero() -> @lib.UnaryOp {
  @lib.UnaryOp::i32x4_trunc_sat_f64x2u_zero()
}

pub fn lib__UnaryOp__i64_clz() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_clz()
}

pub fn lib__UnaryOp__i64_ctz() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_ctz()
}

pub fn lib__UnaryOp__i64_eqz() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_eqz()
}

pub fn lib__UnaryOp__i64_extend16s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_extend16s()
}

pub fn lib__UnaryOp__i64_extend32s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_extend32s()
}

pub fn lib__UnaryOp__i64_extend8s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_extend8s()
}

pub fn lib__UnaryOp__i64_extend_i32s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_extend_i32s()
}

pub fn lib__UnaryOp__i64_extend_i32u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_extend_i32u()
}

pub fn lib__UnaryOp__i64_popcnt() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_popcnt()
}

pub fn lib__UnaryOp__i64_reinterpret_f64() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_reinterpret_f64()
}

pub fn lib__UnaryOp__i64_trunc_f32s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_f32s()
}

pub fn lib__UnaryOp__i64_trunc_f32u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_f32u()
}

pub fn lib__UnaryOp__i64_trunc_f64s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_f64s()
}

pub fn lib__UnaryOp__i64_trunc_f64u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_f64u()
}

pub fn lib__UnaryOp__i64_trunc_sat_f32s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_sat_f32s()
}

pub fn lib__UnaryOp__i64_trunc_sat_f32u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_sat_f32u()
}

pub fn lib__UnaryOp__i64_trunc_sat_f64s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_sat_f64s()
}

pub fn lib__UnaryOp__i64_trunc_sat_f64u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64_trunc_sat_f64u()
}

pub fn lib__UnaryOp__i64x2_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_abs()
}

pub fn lib__UnaryOp__i64x2_all_true() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_all_true()
}

pub fn lib__UnaryOp__i64x2_bitmask() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_bitmask()
}

pub fn lib__UnaryOp__i64x2_extend_high_i32x4s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_extend_high_i32x4s()
}

pub fn lib__UnaryOp__i64x2_extend_high_i32x4u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_extend_high_i32x4u()
}

pub fn lib__UnaryOp__i64x2_extend_low_i32x4s() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_extend_low_i32x4s()
}

pub fn lib__UnaryOp__i64x2_extend_low_i32x4u() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_extend_low_i32x4u()
}

pub fn lib__UnaryOp__i64x2_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::i64x2_neg()
}

pub fn lib__UnaryOp__i8x16_abs() -> @lib.UnaryOp {
  @lib.UnaryOp::i8x16_abs()
}

pub fn lib__UnaryOp__i8x16_all_true() -> @lib.UnaryOp {
  @lib.UnaryOp::i8x16_all_true()
}

pub fn lib__UnaryOp__i8x16_bitmask() -> @lib.UnaryOp {
  @lib.UnaryOp::i8x16_bitmask()
}

pub fn lib__UnaryOp__i8x16_neg() -> @lib.UnaryOp {
  @lib.UnaryOp::i8x16_neg()
}

pub fn lib__UnaryOp__i8x16_popcnt() -> @lib.UnaryOp {
  @lib.UnaryOp::i8x16_popcnt()
}

pub fn lib__UnaryOp__v128_any_true() -> @lib.UnaryOp {
  @lib.UnaryOp::v128_any_true()
}

pub fn lib__UnaryOp__v128_not() -> @lib.UnaryOp {
  @lib.UnaryOp::v128_not()
}

pub fn lib__V128LoadLaneOp__v128_load16_lane() -> @lib.V128LoadLaneOp {
  @lib.V128LoadLaneOp::v128_load16_lane()
}

pub fn lib__V128LoadLaneOp__v128_load32_lane() -> @lib.V128LoadLaneOp {
  @lib.V128LoadLaneOp::v128_load32_lane()
}

pub fn lib__V128LoadLaneOp__v128_load64_lane() -> @lib.V128LoadLaneOp {
  @lib.V128LoadLaneOp::v128_load64_lane()
}

pub fn lib__V128LoadLaneOp__v128_load8_lane() -> @lib.V128LoadLaneOp {
  @lib.V128LoadLaneOp::v128_load8_lane()
}

pub fn lib__V128ShiftOp__i16x8_shl() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i16x8_shl()
}

pub fn lib__V128ShiftOp__i16x8_shr_s() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i16x8_shr_s()
}

pub fn lib__V128ShiftOp__i16x8_shr_u() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i16x8_shr_u()
}

pub fn lib__V128ShiftOp__i32x4_shl() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i32x4_shl()
}

pub fn lib__V128ShiftOp__i32x4_shr_s() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i32x4_shr_s()
}

pub fn lib__V128ShiftOp__i32x4_shr_u() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i32x4_shr_u()
}

pub fn lib__V128ShiftOp__i64x2_shl() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i64x2_shl()
}

pub fn lib__V128ShiftOp__i64x2_shr_s() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i64x2_shr_s()
}

pub fn lib__V128ShiftOp__i64x2_shr_u() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i64x2_shr_u()
}

pub fn lib__V128ShiftOp__i8x16_shl() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i8x16_shl()
}

pub fn lib__V128ShiftOp__i8x16_shr_s() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i8x16_shr_s()
}

pub fn lib__V128ShiftOp__i8x16_shr_u() -> @lib.V128ShiftOp {
  @lib.V128ShiftOp::i8x16_shr_u()
}

pub fn lib__V128StoreLaneOp__v128_store16_lane() -> @lib.V128StoreLaneOp {
  @lib.V128StoreLaneOp::v128_store16_lane()
}

pub fn lib__V128StoreLaneOp__v128_store32_lane() -> @lib.V128StoreLaneOp {
  @lib.V128StoreLaneOp::v128_store32_lane()
}

pub fn lib__V128StoreLaneOp__v128_store64_lane() -> @lib.V128StoreLaneOp {
  @lib.V128StoreLaneOp::v128_store64_lane()
}

pub fn lib__V128StoreLaneOp__v128_store8_lane() -> @lib.V128StoreLaneOp {
  @lib.V128StoreLaneOp::v128_store8_lane()
}

pub fn lib__V128TernaryOp__f32x4_relaxed_madd() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::f32x4_relaxed_madd()
}

pub fn lib__V128TernaryOp__f32x4_relaxed_nmadd() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::f32x4_relaxed_nmadd()
}

pub fn lib__V128TernaryOp__f64x2_relaxed_madd() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::f64x2_relaxed_madd()
}

pub fn lib__V128TernaryOp__f64x2_relaxed_nmadd() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::f64x2_relaxed_nmadd()
}

pub fn lib__V128TernaryOp__i16x8_relaxed_laneselect() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::i16x8_relaxed_laneselect()
}

pub fn lib__V128TernaryOp__i32x4_relaxed_dot_i8x16i7x16_add_s() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::i32x4_relaxed_dot_i8x16i7x16_add_s()
}

pub fn lib__V128TernaryOp__i32x4_relaxed_laneselect() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::i32x4_relaxed_laneselect()
}

pub fn lib__V128TernaryOp__i64x2_relaxed_laneselect() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::i64x2_relaxed_laneselect()
}

pub fn lib__V128TernaryOp__i8x16_relaxed_laneselect() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::i8x16_relaxed_laneselect()
}

pub fn lib__V128TernaryOp__v128_bitselect() -> @lib.V128TernaryOp {
  @lib.V128TernaryOp::v128_bitselect()
}

pub fn lib__ValType__anyref() -> @lib.ValType {
  @lib.ValType::anyref()
}

pub fn lib__ValType__bottom() -> @lib.ValType {
  @lib.ValType::bottom()
}

pub fn lib__ValType__eqref_null() -> @lib.ValType {
  @lib.ValType::eqref_null()
}

pub fn lib__ValType__externref() -> @lib.ValType {
  @lib.ValType::externref()
}

pub fn lib__ValType__f32() -> @lib.ValType {
  @lib.ValType::f32()
}

pub fn lib__ValType__f64() -> @lib.ValType {
  @lib.ValType::f64()
}

pub fn lib__ValType__funcref() -> @lib.ValType {
  @lib.ValType::funcref()
}

pub fn lib__ValType__i31ref() -> @lib.ValType {
  @lib.ValType::i31ref()
}

pub fn lib__ValType__i31ref_nullable() -> @lib.ValType {
  @lib.ValType::i31ref_nullable()
}

pub fn lib__ValType__i32() -> @lib.ValType {
  @lib.ValType::i32()
}

pub fn lib__ValType__i64() -> @lib.ValType {
  @lib.ValType::i64()
}

pub fn lib__ValType__is_ref_type(arg0 : @lib.ValType) -> Bool {
  @lib.ValType::is_ref_type(arg0)
}

pub fn lib__ValType__num_type(arg0 : @lib.NumType) -> @lib.ValType {
  @lib.ValType::num_type(arg0)
}

pub fn lib__ValType__ref_array_nonnull(arg0 : @lib.TypeIdx) -> @lib.ValType {
  @lib.ValType::ref_array_nonnull(arg0)
}

pub fn lib__ValType__ref_array_nullable(arg0 : @lib.TypeIdx) -> @lib.ValType {
  @lib.ValType::ref_array_nullable(arg0)
}

pub fn lib__ValType__ref_null(arg0 : @lib.HeapType) -> @lib.ValType {
  @lib.ValType::ref_null(arg0)
}

pub fn lib__ValType__ref_null_array_of(arg0 : @lib.TypeIdx) -> @lib.ValType {
  @lib.ValType::ref_null_array_of(arg0)
}

pub fn lib__ValType__ref_null_exn() -> @lib.ValType {
  @lib.ValType::ref_null_exn()
}

pub fn lib__ValType__ref_type(arg0 : @lib.RefType) -> @lib.ValType {
  @lib.ValType::ref_type(arg0)
}

pub fn lib__ValType__v128() -> @lib.ValType {
  @lib.ValType::v128()
}

pub fn passes__default_function_optimization_passes(arg0 : @lib.Module, arg1 : @passes.OptimizeOptions) -> Array[@passes.ModulePass] {
  @passes.default_function_optimization_passes(arg0, arg1)
}

pub fn passes__default_global_optimization_post_passes(arg0 : @lib.Module, arg1 : @passes.OptimizeOptions) -> Array[@passes.ModulePass] {
  @passes.default_global_optimization_post_passes(arg0, arg1)
}

pub fn passes__default_global_optimization_pre_passes__arity_2(arg0 : @lib.Module, arg1 : @passes.OptimizeOptions) -> Array[@passes.ModulePass] {
  @passes.default_global_optimization_pre_passes(arg0, arg1)
}

pub fn passes__default_global_optimization_pre_passes(arg0 : @lib.Module, arg1 : @passes.OptimizeOptions, arg2 : Bool) -> Array[@passes.ModulePass] {
  @passes.default_global_optimization_pre_passes(arg0, arg1, closed_world=arg2)
}

pub fn passes__optimize_module(arg0 : @lib.Module, arg1 : Array[@passes.ModulePass]) -> Result[@lib.Module, String] {
  @passes.optimize_module(arg0, arg1)
}

pub fn passes__optimize_module_with_options(arg0 : @lib.Module, arg1 : Array[@passes.ModulePass], arg2 : @passes.OptimizeOptions) -> Result[@lib.Module, String] {
  @passes.optimize_module_with_options(arg0, arg1, arg2)
}

pub fn passes__InliningOptions__new__arity_0() -> @passes.InliningOptions {
  @passes.InliningOptions::new()
}

pub fn passes__InliningOptions__new__arity_1(arg0 : Int) -> @passes.InliningOptions {
  @passes.InliningOptions::new(always_inline_max_size=arg0)
}

pub fn passes__InliningOptions__new__arity_2(arg0 : Int, arg1 : Int) -> @passes.InliningOptions {
  @passes.InliningOptions::new(always_inline_max_size=arg0, one_caller_inline_max_size=arg1)
}

pub fn passes__InliningOptions__new__arity_3(arg0 : Int, arg1 : Int, arg2 : Int) -> @passes.InliningOptions {
  @passes.InliningOptions::new(always_inline_max_size=arg0, one_caller_inline_max_size=arg1, flexible_inline_max_size=arg2)
}

pub fn passes__InliningOptions__new__arity_4(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int) -> @passes.InliningOptions {
  @passes.InliningOptions::new(always_inline_max_size=arg0, one_caller_inline_max_size=arg1, flexible_inline_max_size=arg2, max_combined_binary_size=arg3)
}

pub fn passes__InliningOptions__new__arity_5(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int, arg4 : Bool) -> @passes.InliningOptions {
  @passes.InliningOptions::new(always_inline_max_size=arg0, one_caller_inline_max_size=arg1, flexible_inline_max_size=arg2, max_combined_binary_size=arg3, allow_functions_with_loops=arg4)
}

pub fn passes__InliningOptions__new(arg0 : Int, arg1 : Int, arg2 : Int, arg3 : Int, arg4 : Bool, arg5 : Int) -> @passes.InliningOptions {
  @passes.InliningOptions::new(always_inline_max_size=arg0, one_caller_inline_max_size=arg1, flexible_inline_max_size=arg2, max_combined_binary_size=arg3, allow_functions_with_loops=arg4, partial_inlining_ifs=arg5)
}

pub fn passes__OptimizeOptions__new__arity_0() -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new()
}

pub fn passes__OptimizeOptions__new__arity_1(arg0 : Int) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0)
}

pub fn passes__OptimizeOptions__new__arity_2(arg0 : Int, arg1 : Int) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0, shrink_level=arg1)
}

pub fn passes__OptimizeOptions__new__arity_3(arg0 : Int, arg1 : Int, arg2 : @passes.InliningOptions) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0, shrink_level=arg1, inlining=arg2)
}

pub fn passes__OptimizeOptions__new__arity_4(arg0 : Int, arg1 : Int, arg2 : @passes.InliningOptions, arg3 : Int) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0, shrink_level=arg1, inlining=arg2, monomorphize_min_benefit=arg3)
}

pub fn passes__OptimizeOptions__new__arity_5(arg0 : Int, arg1 : Int, arg2 : @passes.InliningOptions, arg3 : Int, arg4 : Bool) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0, shrink_level=arg1, inlining=arg2, monomorphize_min_benefit=arg3, low_memory_unused=arg4)
}

pub fn passes__OptimizeOptions__new__arity_6(arg0 : Int, arg1 : Int, arg2 : @passes.InliningOptions, arg3 : Int, arg4 : Bool, arg5 : UInt64) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0, shrink_level=arg1, inlining=arg2, monomorphize_min_benefit=arg3, low_memory_unused=arg4, low_memory_bound=arg5)
}

pub fn passes__OptimizeOptions__new(arg0 : Int, arg1 : Int, arg2 : @passes.InliningOptions, arg3 : Int, arg4 : Bool, arg5 : UInt64, arg6 : Bool) -> @passes.OptimizeOptions {
  @passes.OptimizeOptions::new(optimize_level=arg0, shrink_level=arg1, inlining=arg2, monomorphize_min_benefit=arg3, low_memory_unused=arg4, low_memory_bound=arg5, traps_never_happen=arg6)
}

pub fn validate__descriptor_compatible(arg0 : @lib.RefType, arg1 : @lib.RefType, arg2 : @validate.Env) -> Bool {
  @validate.descriptor_compatible(arg0, arg1, arg2)
}

pub fn validate__diff(arg0 : @lib.RefType, arg1 : @lib.RefType) -> Result[@lib.RefType, String] {
  @validate.diff(arg0, arg1)
}

pub fn validate__empty_env() -> @validate.Env {
  @validate.empty_env()
}

pub fn validate__gen_side_effect_tinstr__arity_2(arg0 : @validate.GenValidContext, arg1 : Int) -> @lib.TInstr {
  @validate.gen_side_effect_tinstr(arg0, arg1)
}

pub fn validate__gen_side_effect_tinstr(arg0 : @validate.GenValidContext, arg1 : Int, arg2 : Int) -> @lib.TInstr {
  @validate.gen_side_effect_tinstr(arg0, arg1, label_depth=arg2)
}

pub fn validate__gen_tinstr_of_type(arg0 : @validate.GenValidContext, arg1 : @lib.ValType) -> @lib.TInstr {
  @validate.gen_tinstr_of_type(arg0, arg1)
}

pub fn validate__gen_valid_module(arg0 : @splitmix.RandomState) -> @lib.Module {
  @validate.gen_valid_module(arg0)
}

pub fn validate__gen_valid_numtype(arg0 : @validate.GenValidContext) -> @lib.NumType {
  @validate.gen_valid_numtype(arg0)
}

pub fn validate__gen_valid_result_type(arg0 : @validate.GenValidContext, arg1 : Array[@lib.ValType], arg2 : @validate.TypeGenerationStrategy) -> Array[@lib.ValType] {
  @validate.gen_valid_result_type(arg0, arg1, arg2)
}

pub fn validate__gen_valid_tfunc(arg0 : @validate.GenValidContext, arg1 : Array[@lib.ValType], arg2 : Array[@lib.ValType]) -> @lib.Func {
  @validate.gen_valid_tfunc(arg0, arg1, arg2)
}

pub fn validate__gen_valid_valtype(arg0 : @validate.GenValidContext) -> @lib.ValType {
  @validate.gen_valid_valtype(arg0)
}

pub fn validate__to_texpr(arg0 : @lib.Expr, arg1 : @validate.Env) -> Result[@lib.TExpr, String] {
  @validate.to_texpr(arg0, arg1)
}

pub fn validate__validate_codesec(arg0 : @lib.CodeSec?, arg1 : @lib.FuncSec?, arg2 : @validate.Env) -> Result[Unit, String] {
  @validate.validate_codesec(arg0, arg1, arg2)
}

pub fn validate__validate_datacnt(arg0 : @lib.DataCntSec?, arg1 : @lib.DataSec?) -> Result[Unit, String] {
  @validate.validate_datacnt(arg0, arg1)
}

pub fn validate__validate_datasec(arg0 : @lib.DataSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_datasec(arg0, arg1)
}

pub fn validate__validate_elemsec(arg0 : @lib.ElemSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_elemsec(arg0, arg1)
}

pub fn validate__validate_exportsec(arg0 : @lib.ExportSec?, arg1 : @validate.Env) -> Result[Unit, String] {
  @validate.validate_exportsec(arg0, arg1)
}

pub fn validate__validate_funcsec(arg0 : @lib.FuncSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_funcsec(arg0, arg1)
}

pub fn validate__validate_globalsec(arg0 : @lib.GlobalSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_globalsec(arg0, arg1)
}

pub fn validate__validate_importsec(arg0 : @lib.ImportSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_importsec(arg0, arg1)
}

pub fn validate__validate_memsec(arg0 : @lib.MemSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_memsec(arg0, arg1)
}

pub fn validate__validate_module(arg0 : @lib.Module) -> Result[Unit, @validate.ValidationError] {
  @validate.validate_module(arg0)
}

pub fn validate__validate_startsec(arg0 : @lib.StartSec?, arg1 : @validate.Env) -> Result[Unit, String] {
  @validate.validate_startsec(arg0, arg1)
}

pub fn validate__validate_tablesec(arg0 : @lib.TableSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_tablesec(arg0, arg1)
}

pub fn validate__validate_tagsec(arg0 : @lib.TagSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_tagsec(arg0, arg1)
}

pub fn validate__validate_typesec(arg0 : @lib.TypeSec?, arg1 : @validate.Env) -> Result[@validate.Env, String] {
  @validate.validate_typesec(arg0, arg1)
}

pub fn validate__Env__append_rectype_types(arg0 : @validate.Env, arg1 : @lib.RecType) -> @validate.Env {
  @validate.Env::append_rectype_types(arg0, arg1)
}

pub fn validate__Env__descriptor_result_type(arg0 : @validate.Env) -> @lib.ValType {
  @validate.Env::descriptor_result_type(arg0)
}

pub fn validate__Env__expand_blocktype(arg0 : @validate.Env, arg1 : @lib.BlockType) -> Result[(Array[@lib.ValType], Array[@lib.ValType]), String] {
  @validate.Env::expand_blocktype(arg0, arg1)
}

pub fn validate__Env__get_catch_label_types(arg0 : @validate.Env, arg1 : @lib.LabelIdx) -> Array[@lib.ValType]? {
  @validate.Env::get_catch_label_types(arg0, arg1)
}

pub fn validate__Env__get_elem(arg0 : @validate.Env, arg1 : @lib.ElemIdx) -> @lib.Elem? {
  @validate.Env::get_elem(arg0, arg1)
}

pub fn validate__Env__get_functype_by_funcidx(arg0 : @validate.Env, arg1 : @lib.FuncIdx) -> @lib.FuncType? {
  @validate.Env::get_functype_by_funcidx(arg0, arg1)
}

pub fn validate__Env__get_functypeidx_by_funcidx(arg0 : @validate.Env, arg1 : @lib.FuncIdx) -> @lib.TypeIdx? {
  @validate.Env::get_functypeidx_by_funcidx(arg0, arg1)
}

pub fn validate__Env__get_global_type(arg0 : @validate.Env, arg1 : @lib.GlobalIdx) -> @lib.GlobalType? {
  @validate.Env::get_global_type(arg0, arg1)
}

pub fn validate__Env__get_label(arg0 : @validate.Env, arg1 : @lib.LabelIdx) -> Array[@lib.ValType]? {
  @validate.Env::get_label(arg0, arg1)
}

pub fn validate__Env__get_label_types(arg0 : @validate.Env, arg1 : @lib.LabelIdx) -> Array[@lib.ValType]? {
  @validate.Env::get_label_types(arg0, arg1)
}

pub fn validate__Env__get_local_type(arg0 : @validate.Env, arg1 : @lib.LocalIdx) -> @lib.ValType? {
  @validate.Env::get_local_type(arg0, arg1)
}

pub fn validate__Env__get_memtype(arg0 : @validate.Env, arg1 : @lib.MemIdx) -> @lib.MemType? {
  @validate.Env::get_memtype(arg0, arg1)
}

pub fn validate__Env__get_table_type(arg0 : @validate.Env, arg1 : @lib.TableIdx) -> @lib.TableType? {
  @validate.Env::get_table_type(arg0, arg1)
}

pub fn validate__Env__get_tag(arg0 : @validate.Env, arg1 : @lib.TagIdx) -> @lib.TagType? {
  @validate.Env::get_tag(arg0, arg1)
}

pub fn validate__Env__has_data(arg0 : @validate.Env, arg1 : @lib.DataIdx) -> Bool {
  @validate.Env::has_data(arg0, arg1)
}

pub fn validate__Env__has_func(arg0 : @validate.Env, arg1 : @lib.FuncIdx) -> Bool {
  @validate.Env::has_func(arg0, arg1)
}

pub fn validate__Env__new() -> @validate.Env {
  @validate.Env::new()
}

pub fn validate__Env__push_data(arg0 : @validate.Env, arg1 : @lib.Data) -> @validate.Env {
  @validate.Env::push_data(arg0, arg1)
}

pub fn validate__Env__push_elem(arg0 : @validate.Env, arg1 : @lib.Elem) -> @validate.Env {
  @validate.Env::push_elem(arg0, arg1)
}

pub fn validate__Env__push_func(arg0 : @validate.Env, arg1 : @lib.FuncType) -> @validate.Env {
  @validate.Env::push_func(arg0, arg1)
}

pub fn validate__Env__push_func_with_typeidx(arg0 : @validate.Env, arg1 : @lib.FuncType, arg2 : @lib.TypeIdx?) -> @validate.Env {
  @validate.Env::push_func_with_typeidx(arg0, arg1, arg2)
}

pub fn validate__Env__push_global(arg0 : @validate.Env, arg1 : @lib.GlobalType) -> @validate.Env {
  @validate.Env::push_global(arg0, arg1)
}

pub fn validate__Env__push_mem(arg0 : @validate.Env, arg1 : @lib.MemType) -> @validate.Env {
  @validate.Env::push_mem(arg0, arg1)
}

pub fn validate__Env__push_table(arg0 : @validate.Env, arg1 : @lib.TableType) -> @validate.Env {
  @validate.Env::push_table(arg0, arg1)
}

pub fn validate__Env__push_tag(arg0 : @validate.Env, arg1 : @lib.TagType) -> @validate.Env {
  @validate.Env::push_tag(arg0, arg1)
}

pub fn validate__Env__resolve_array_field(arg0 : @validate.Env, arg1 : @lib.TypeIdx) -> Result[@lib.FieldType, String] {
  @validate.Env::resolve_array_field(arg0, arg1)
}

pub fn validate__Env__resolve_comptype(arg0 : @validate.Env, arg1 : @lib.TypeIdx) -> @lib.CompType? {
  @validate.Env::resolve_comptype(arg0, arg1)
}

pub fn validate__Env__resolve_descriptor_target_ref_type(arg0 : @validate.Env, arg1 : Bool, arg2 : @lib.HeapType) -> Result[@lib.RefType, String] {
  @validate.Env::resolve_descriptor_target_ref_type(arg0, arg1, arg2)
}

pub fn validate__Env__resolve_functype(arg0 : @validate.Env, arg1 : @lib.TypeIdx) -> @lib.FuncType? {
  @validate.Env::resolve_functype(arg0, arg1)
}

pub fn validate__Env__resolve_heaptype_subtype(arg0 : @validate.Env, arg1 : @lib.HeapType) -> @lib.SubType? {
  @validate.Env::resolve_heaptype_subtype(arg0, arg1)
}

pub fn validate__Env__resolve_struct_fields(arg0 : @validate.Env, arg1 : @lib.TypeIdx) -> Result[Array[@lib.FieldType], String] {
  @validate.Env::resolve_struct_fields(arg0, arg1)
}

pub fn validate__Env__resolve_subtype(arg0 : @validate.Env, arg1 : @lib.TypeIdx) -> @lib.SubType? {
  @validate.Env::resolve_subtype(arg0, arg1)
}

pub fn validate__Env__resolve_tag_functype(arg0 : @validate.Env, arg1 : @lib.TagIdx) -> @lib.FuncType? {
  @validate.Env::resolve_tag_functype(arg0, arg1)
}

pub fn validate__Env__resolve_typeidx_subtype(arg0 : @validate.Env, arg1 : @lib.TypeIdx) -> @lib.SubType? {
  @validate.Env::resolve_typeidx_subtype(arg0, arg1)
}

pub fn validate__Env__with_elems(arg0 : @validate.Env, arg1 : Array[@lib.Elem]) -> @validate.Env {
  @validate.Env::with_elems(arg0, arg1)
}

pub fn validate__Env__with_funcs(arg0 : @validate.Env, arg1 : Array[@lib.FuncType]) -> @validate.Env {
  @validate.Env::with_funcs(arg0, arg1)
}

pub fn validate__Env__with_globals(arg0 : @validate.Env, arg1 : Array[@lib.GlobalType]) -> @validate.Env {
  @validate.Env::with_globals(arg0, arg1)
}

pub fn validate__Env__with_label(arg0 : @validate.Env, arg1 : Array[@lib.ValType]) -> @validate.Env {
  @validate.Env::with_label(arg0, arg1)
}

pub fn validate__Env__with_labels(arg0 : @validate.Env, arg1 : Array[Array[@lib.ValType]]) -> @validate.Env {
  @validate.Env::with_labels(arg0, arg1)
}

pub fn validate__Env__with_locals(arg0 : @validate.Env, arg1 : Array[@lib.ValType]) -> @validate.Env {
  @validate.Env::with_locals(arg0, arg1)
}

pub fn validate__Env__with_mems(arg0 : @validate.Env, arg1 : Array[@lib.MemType]) -> @validate.Env {
  @validate.Env::with_mems(arg0, arg1)
}

pub fn validate__Env__with_module(arg0 : @validate.Env, arg1 : @lib.Module) -> @validate.Env {
  @validate.Env::with_module(arg0, arg1)
}

pub fn validate__Env__with_rectype(arg0 : @validate.Env, arg1 : @lib.RecType) -> @validate.Env {
  @validate.Env::with_rectype(arg0, arg1)
}

pub fn validate__Env__with_return_type(arg0 : @validate.Env, arg1 : Array[@lib.ValType]?) -> @validate.Env {
  @validate.Env::with_return_type(arg0, arg1)
}

pub fn validate__Env__with_tables(arg0 : @validate.Env, arg1 : Array[@lib.TableType]) -> @validate.Env {
  @validate.Env::with_tables(arg0, arg1)
}

pub fn validate__Env__with_tags(arg0 : @validate.Env, arg1 : Array[@lib.TagType]) -> @validate.Env {
  @validate.Env::with_tags(arg0, arg1)
}

pub fn validate__Env__with_types(arg0 : @validate.Env, arg1 : Array[@lib.SubType]) -> @validate.Env {
  @validate.Env::with_types(arg0, arg1)
}

pub fn wast__lookup_keyword(arg0 : String) -> @wast.TokenType? {
  @wast.lookup_keyword(arg0)
}

pub fn wast__module_to_wast(arg0 : @wast.Module) -> Result[String, String] {
  @wast.module_to_wast(arg0)
}

pub fn wast__module_to_wast_with_context(arg0 : @wast.Module, arg1 : @lib.PrettyPrintContext) -> Result[String, String] {
  @wast.module_to_wast_with_context(arg0, arg1)
}

pub fn wast__run_wast_spec_file(arg0 : String, arg1 : String) -> @wast.WastSpecFileReport {
  @wast.run_wast_spec_file(arg0, arg1)
}

pub fn wast__run_wast_spec_suite(arg0 : Array[(String, String)]) -> @wast.WastSpecRunSummary {
  @wast.run_wast_spec_suite(arg0)
}

pub fn wast__script_to_wast(arg0 : @wast.WastScript) -> Result[String, String] {
  @wast.script_to_wast(arg0)
}

pub fn wast__script_to_wast_with_context(arg0 : @wast.WastScript, arg1 : @lib.PrettyPrintContext) -> Result[String, String] {
  @wast.script_to_wast_with_context(arg0, arg1)
}

pub fn wast__wast_ast_to_binary_module(arg0 : @wast.Module) -> Result[@lib.Module, String] {
  @wast.wast_ast_to_binary_module(arg0)
}

pub fn wast__wast_text_binary_roundtrip__arity_1(arg0 : String) -> Result[(String, @lib.Module), String] {
  @wast.wast_text_binary_roundtrip(arg0)
}

pub fn wast__wast_text_binary_roundtrip(arg0 : String, arg1 : String) -> Result[(String, @lib.Module), String] {
  @wast.wast_text_binary_roundtrip(arg0, filename=arg1)
}

pub fn wast__wast_to_binary_module__arity_1(arg0 : String) -> Result[@lib.Module, String] {
  @wast.wast_to_binary_module(arg0)
}

pub fn wast__wast_to_binary_module(arg0 : String, arg1 : String) -> Result[@lib.Module, String] {
  @wast.wast_to_binary_module(arg0, filename=arg1)
}

pub fn wast__wast_to_module__arity_1(arg0 : String) -> Result[@wast.Module, String] {
  @wast.wast_to_module(arg0)
}

pub fn wast__wast_to_module(arg0 : String, arg1 : String) -> Result[@wast.Module, String] {
  @wast.wast_to_module(arg0, filename=arg1)
}

pub fn wast__wast_to_script__arity_1(arg0 : String) -> Result[@wast.WastScript, String] {
  @wast.wast_to_script(arg0)
}

pub fn wast__wast_to_script(arg0 : String, arg1 : String) -> Result[@wast.WastScript, String] {
  @wast.wast_to_script(arg0, filename=arg1)
}

pub fn wast__KeywordTable__lookup(arg0 : @wast.KeywordTable, arg1 : String) -> @wast.TokenType? {
  @wast.KeywordTable::lookup(arg0, arg1)
}

pub fn wast__MemoryType__inner(arg0 : @wast.MemoryType) -> @wast.Limits {
  @wast.MemoryType::inner(arg0)
}

pub fn wast__WastLexer__get_errors(arg0 : @wast.WastLexer) -> Array[@wast.LexerError] {
  @wast.WastLexer::get_errors(arg0)
}

pub fn wast__WastLexer__get_token(arg0 : @wast.WastLexer) -> @wast.Token {
  @wast.WastLexer::get_token(arg0)
}

pub fn wast__WastLexer__has_errors(arg0 : @wast.WastLexer) -> Bool {
  @wast.WastLexer::has_errors(arg0)
}

pub fn wast__WastLexer__new(arg0 : Bytes, arg1 : String) -> @wast.WastLexer {
  @wast.WastLexer::new(arg0, arg1)
}

pub fn wast__WastParser__get_errors(arg0 : @wast.WastParser) -> Array[@wast.ParseError] {
  @wast.WastParser::get_errors(arg0)
}

pub fn wast__WastParser__has_errors(arg0 : @wast.WastParser) -> Bool {
  @wast.WastParser::has_errors(arg0)
}

pub fn wast__WastParser__new(arg0 : @wast.WastLexer) -> @wast.WastParser {
  @wast.WastParser::new(arg0)
}

pub fn wat__lookup_keyword(arg0 : String) -> @wast.TokenType? {
  @wat.lookup_keyword(arg0)
}

pub fn wat__module_to_wat(arg0 : @wast.Module) -> Result[String, String] {
  @wat.module_to_wat(arg0)
}

pub fn wat__module_to_wat_with_context(arg0 : @wast.Module, arg1 : @lib.PrettyPrintContext) -> Result[String, String] {
  @wat.module_to_wat_with_context(arg0, arg1)
}

pub fn wat__script_to_wat(arg0 : @wast.WastScript) -> Result[String, String] {
  @wat.script_to_wat(arg0)
}

pub fn wat__script_to_wat_with_context(arg0 : @wast.WastScript, arg1 : @lib.PrettyPrintContext) -> Result[String, String] {
  @wat.script_to_wat_with_context(arg0, arg1)
}

pub fn wat__wat_to_module__arity_1(arg0 : String) -> Result[@wast.Module, String] {
  @wat.wat_to_module(arg0)
}

pub fn wat__wat_to_module(arg0 : String, arg1 : String) -> Result[@wast.Module, String] {
  @wat.wat_to_module(arg0, filename=arg1)
}

pub fn wat__wat_to_script__arity_1(arg0 : String) -> Result[@wast.WastScript, String] {
  @wat.wat_to_script(arg0)
}

pub fn wat__wat_to_script(arg0 : String, arg1 : String) -> Result[@wast.WastScript, String] {
  @wat.wat_to_script(arg0, filename=arg1)
}

fn main {
  ()
}
