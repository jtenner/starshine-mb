// Generated using `moon info`, DON'T EDIT IT
package "jtenner/starshine/validate"

import {
  "jtenner/starshine/lib",
  "moonbitlang/core/quickcheck/splitmix",
}

// Values
pub fn diff(@lib.RefType, @lib.RefType) -> Result[@lib.RefType, String]

pub fn gen_side_effect_tinstr(GenValidContext, Int, label_depth? : Int) -> @lib.TInstr

pub fn gen_tinstr_of_type(GenValidContext, @lib.ValType) -> @lib.TInstr

pub fn gen_valid_module(@splitmix.RandomState) -> @lib.Module

pub fn gen_valid_numtype(GenValidContext) -> @lib.NumType

pub fn gen_valid_result_type(GenValidContext, Array[@lib.ValType], TypeGenerationStrategy) -> Array[@lib.ValType]

pub fn gen_valid_tfunc(GenValidContext, Array[@lib.ValType], Array[@lib.ValType]) -> @lib.Func

pub fn gen_valid_valtype(GenValidContext) -> @lib.ValType

pub fn validate_codesec(@lib.CodeSec?, @lib.FuncSec?, @lib.Env) -> Result[Unit, String]

pub fn validate_datacnt(@lib.DataCntSec?, @lib.DataSec?) -> Result[Unit, String]

pub fn validate_datasec(@lib.DataSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_elemsec(@lib.ElemSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_exportsec(@lib.ExportSec?, @lib.Env) -> Result[Unit, String]

pub fn validate_funcsec(@lib.FuncSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_globalsec(@lib.GlobalSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_importsec(@lib.ImportSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_memsec(@lib.MemSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_module(@lib.Module) -> Result[Unit, String]

pub fn validate_startsec(@lib.StartSec?, @lib.Env) -> Result[Unit, String]

pub fn validate_tablesec(@lib.TableSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_tagsec(@lib.TagSec?, @lib.Env) -> Result[@lib.Env, String]

pub fn validate_typesec(@lib.TypeSec?, @lib.Env) -> Result[@lib.Env, String]

// Errors

// Types and methods
type GenValidContext

pub struct TcState {
  env : @lib.Env
  stack : Array[@lib.ValType]
  reachable : Bool
}
pub impl Show for TcState

type TypeGenerationStrategy

// Type aliases
pub type TcResult = Result[TcState, String]

// Traits
pub trait DeclMatch {
  matches_decl(Self, Self, @lib.Env) -> Bool
}

pub trait Match {
  matches(Self, Self, @lib.Env) -> Bool
}
pub impl Match for @lib.AbsHeapType
pub impl Match for @lib.CompType
pub impl Match for @lib.DefType
pub impl Match for @lib.ExternType
pub impl Match for @lib.FieldType
pub impl Match for @lib.GlobalType
pub impl Match for @lib.HeapType
pub impl Match for @lib.Limits
pub impl Match for @lib.MemType
pub impl Match for @lib.RefType
pub impl Match for @lib.StorageType
pub impl Match for @lib.TableType
pub impl Match for @lib.TagType
pub impl Match for @lib.ValType
pub impl[T : Match] Match for Array[T]

pub trait Typecheck {
  typecheck(Self, TcState) -> Result[TcState, String]
}
pub impl Typecheck for @lib.Expr
pub impl Typecheck for @lib.Instruction
pub impl Typecheck for @lib.TExpr
pub impl Typecheck for @lib.TInstr

pub trait Validate {
  validate(Self, @lib.Env) -> Result[Unit, String]
}
pub impl Validate for @lib.AbsHeapType
pub impl Validate for @lib.BlockType
pub impl Validate for @lib.Catch
pub impl Validate for @lib.CompType
pub impl Validate for @lib.Data
pub impl Validate for @lib.DataMode
pub impl Validate for @lib.DefType
pub impl Validate for @lib.Elem
pub impl Validate for @lib.ElemKind
pub impl Validate for @lib.Export
pub impl Validate for @lib.ExternIdx
pub impl Validate for @lib.ExternType
pub impl Validate for @lib.FieldType
pub impl Validate for @lib.FuncIdx
pub impl Validate for @lib.FuncType
pub impl Validate for @lib.GlobalIdx
pub impl Validate for @lib.GlobalType
pub impl Validate for @lib.HeapType
pub impl Validate for @lib.Import
pub impl Validate for @lib.LabelIdx
pub impl Validate for @lib.MemIdx
pub impl Validate for @lib.MemType
pub impl Validate for @lib.NumType
pub impl Validate for @lib.RecType
pub impl Validate for @lib.RefType
pub impl Validate for @lib.StorageType
pub impl Validate for @lib.SubType
pub impl Validate for @lib.TableIdx
pub impl Validate for @lib.TableType
pub impl Validate for @lib.TagIdx
pub impl Validate for @lib.TagSec
pub impl Validate for @lib.TagType
pub impl Validate for @lib.TypeIdx
pub impl Validate for @lib.ValType
pub impl[T : Validate] Validate for Array[T]

pub trait ValidateMax {
  validate_max(Self, @lib.Env, UInt64) -> Result[Unit, String]
}
pub impl ValidateMax for @lib.Limits

