// Generated using `moon info`, DON'T EDIT IT
package "jtenner/starshine/dataflow"

import {
  "jtenner/starshine/lib",
  "moonbitlang/core/set",
}

// Values

// Errors

// Types and methods
pub struct BinaryExpr {
  op : BinaryOp
  left : ExprId
  right : ExprId
  result_type : WasmType
}
pub fn BinaryExpr::new(BinaryOp, ExprId, ExprId, WasmType) -> Self
pub impl Eq for BinaryExpr
pub impl Show for BinaryExpr

pub enum BinaryOp {
  AddInt32
  AddInt64
  SubInt32
  SubInt64
  MulInt32
  MulInt64
  DivSInt32
  DivSInt64
  DivUInt32
  DivUInt64
  RemSInt32
  RemSInt64
  RemUInt32
  RemUInt64
  AndInt32
  AndInt64
  OrInt32
  OrInt64
  XorInt32
  XorInt64
  ShlInt32
  ShlInt64
  ShrUInt32
  ShrUInt64
  ShrSInt32
  ShrSInt64
  RotLInt32
  RotLInt64
  RotRInt32
  RotRInt64
  EqInt32
  EqInt64
  NeInt32
  NeInt64
  LtSInt32
  LtSInt64
  LtUInt32
  LtUInt64
  LeSInt32
  LeSInt64
  LeUInt32
  LeUInt64
  GtSInt32
  GtSInt64
  GtUInt32
  GtUInt64
  GeSInt32
  GeSInt64
  GeUInt32
  GeUInt64
  AddFloat32
  AddFloat64
  SubFloat32
  SubFloat64
  MulFloat32
  MulFloat64
  DivFloat32
  DivFloat64
  MinFloat32
  MaxFloat32
  CopysignFloat32
  EqFloat32
  NeFloat32
  LtFloat32
  LeFloat32
  GtFloat32
  GeFloat32
  MinFloat64
  MaxFloat64
  CopysignFloat64
  EqFloat64
  NeFloat64
  LtFloat64
  LeFloat64
  GtFloat64
  GeFloat64
}
pub fn BinaryOp::add_float32() -> Self
pub fn BinaryOp::add_float64() -> Self
pub fn BinaryOp::add_int32() -> Self
pub fn BinaryOp::add_int64() -> Self
pub fn BinaryOp::and_int32() -> Self
pub fn BinaryOp::and_int64() -> Self
pub fn BinaryOp::copysign_float32() -> Self
pub fn BinaryOp::copysign_float64() -> Self
pub fn BinaryOp::div_float32() -> Self
pub fn BinaryOp::div_float64() -> Self
pub fn BinaryOp::div_s_int32() -> Self
pub fn BinaryOp::div_s_int64() -> Self
pub fn BinaryOp::div_u_int32() -> Self
pub fn BinaryOp::div_u_int64() -> Self
pub fn BinaryOp::eq_float32() -> Self
pub fn BinaryOp::eq_float64() -> Self
pub fn BinaryOp::eq_int32() -> Self
pub fn BinaryOp::eq_int64() -> Self
pub fn BinaryOp::ge_float32() -> Self
pub fn BinaryOp::ge_float64() -> Self
pub fn BinaryOp::ge_s_int32() -> Self
pub fn BinaryOp::ge_s_int64() -> Self
pub fn BinaryOp::ge_u_int32() -> Self
pub fn BinaryOp::ge_u_int64() -> Self
pub fn BinaryOp::get_opposite(Self) -> Self?
pub fn BinaryOp::gt_float32() -> Self
pub fn BinaryOp::gt_float64() -> Self
pub fn BinaryOp::gt_s_int32() -> Self
pub fn BinaryOp::gt_s_int64() -> Self
pub fn BinaryOp::gt_u_int32() -> Self
pub fn BinaryOp::gt_u_int64() -> Self
pub fn BinaryOp::is_associative(Self) -> Bool
pub fn BinaryOp::is_relational(Self) -> Bool
pub fn BinaryOp::le_float32() -> Self
pub fn BinaryOp::le_float64() -> Self
pub fn BinaryOp::le_s_int32() -> Self
pub fn BinaryOp::le_s_int64() -> Self
pub fn BinaryOp::le_u_int32() -> Self
pub fn BinaryOp::le_u_int64() -> Self
pub fn BinaryOp::lt_float32() -> Self
pub fn BinaryOp::lt_float64() -> Self
pub fn BinaryOp::lt_s_int32() -> Self
pub fn BinaryOp::lt_s_int64() -> Self
pub fn BinaryOp::lt_u_int32() -> Self
pub fn BinaryOp::lt_u_int64() -> Self
pub fn BinaryOp::max_float32() -> Self
pub fn BinaryOp::max_float64() -> Self
pub fn BinaryOp::min_float32() -> Self
pub fn BinaryOp::min_float64() -> Self
pub fn BinaryOp::mul_float32() -> Self
pub fn BinaryOp::mul_float64() -> Self
pub fn BinaryOp::mul_int32() -> Self
pub fn BinaryOp::mul_int64() -> Self
pub fn BinaryOp::ne_float32() -> Self
pub fn BinaryOp::ne_float64() -> Self
pub fn BinaryOp::ne_int32() -> Self
pub fn BinaryOp::ne_int64() -> Self
pub fn BinaryOp::or_int32() -> Self
pub fn BinaryOp::or_int64() -> Self
pub fn BinaryOp::rem_s_int32() -> Self
pub fn BinaryOp::rem_s_int64() -> Self
pub fn BinaryOp::rem_u_int32() -> Self
pub fn BinaryOp::rem_u_int64() -> Self
pub fn BinaryOp::rot_l_int32() -> Self
pub fn BinaryOp::rot_l_int64() -> Self
pub fn BinaryOp::rot_r_int32() -> Self
pub fn BinaryOp::rot_r_int64() -> Self
pub fn BinaryOp::shl_int32() -> Self
pub fn BinaryOp::shl_int64() -> Self
pub fn BinaryOp::shr_s_int32() -> Self
pub fn BinaryOp::shr_s_int64() -> Self
pub fn BinaryOp::shr_u_int32() -> Self
pub fn BinaryOp::shr_u_int64() -> Self
pub fn BinaryOp::sub_float32() -> Self
pub fn BinaryOp::sub_float64() -> Self
pub fn BinaryOp::sub_int32() -> Self
pub fn BinaryOp::sub_int64() -> Self
pub fn BinaryOp::xor_int32() -> Self
pub fn BinaryOp::xor_int64() -> Self
pub impl Eq for BinaryOp
pub impl Show for BinaryOp

pub struct BlockExpr {
  name : String?
  list : Array[ExprId]
  result_type : WasmType
}
pub fn BlockExpr::new(String?, Array[ExprId], WasmType) -> Self
pub impl Eq for BlockExpr
pub impl Show for BlockExpr

pub struct BreakExpr {
  name : String
  value : ExprId?
  condition : ExprId?
}
pub fn BreakExpr::new(String, ExprId?, ExprId?) -> Self
pub impl Eq for BreakExpr
pub impl Show for BreakExpr

pub struct CallExpr {
  target : String
  operands : Array[ExprId]
  result_type : WasmType
}
pub fn CallExpr::new(String, Array[ExprId], WasmType) -> Self
pub impl Eq for CallExpr
pub impl Show for CallExpr

pub struct ConstExpr {
  value : Literal
}
pub impl Eq for ConstExpr
pub impl Show for ConstExpr

type DominatorGVN
pub fn DominatorGVN::new() -> Self
pub fn DominatorGVN::process_block(Self, Graph, Node, NodeUsers, Array[(NodeId, NodeId)]) -> Unit
pub fn DominatorGVN::process_if(Self, Graph, IfExpr, NodeUsers, Array[(NodeId, NodeId)]) -> Unit
pub fn DominatorGVN::process_node(Self, Graph, Node) -> NodeId?

type DominatorInfo

pub struct DropExpr {
  value : ExprId
}
pub fn DropExpr::new(ExprId) -> Self
pub impl Eq for DropExpr
pub impl Show for DropExpr

pub struct ExprId(Int)
#deprecated
pub fn ExprId::inner(Self) -> Int
pub fn ExprId::new(Int) -> Self
pub impl Compare for ExprId
pub impl Eq for ExprId
pub impl Hash for ExprId
pub impl Show for ExprId

pub enum Expression {
  Nop
  Block(BlockExpr)
  If(IfExpr)
  Loop(LoopExpr)
  Break(BreakExpr)
  Switch(SwitchExpr)
  LocalGet(LocalGetExpr)
  LocalSet(LocalSetExpr)
  Const(ConstExpr)
  Unary(UnaryExpr)
  Binary(BinaryExpr)
  Select(SelectExpr)
  Drop(DropExpr)
  Unreachable
  Call(CallExpr)
  Return(ReturnExpr)
  Generic(GenericExpr)
  Load(LoadExpr)
  Store(StoreExpr)
  MemorySize(MemorySizeExpr)
  MemoryGrow(MemoryGrowExpr)
}
pub fn Expression::binary(BinaryExpr) -> Self
pub fn Expression::block(BlockExpr) -> Self
pub fn Expression::break_(BreakExpr) -> Self
pub fn Expression::call(CallExpr) -> Self
pub fn Expression::const_(ConstExpr) -> Self
pub fn Expression::drop(DropExpr) -> Self
pub fn Expression::generic(GenericExpr) -> Self
pub fn Expression::get_type(Self) -> WasmType
pub fn Expression::if_(IfExpr) -> Self
pub fn Expression::load(LoadExpr) -> Self
pub fn Expression::local_get(LocalGetExpr) -> Self
pub fn Expression::local_set(LocalSetExpr) -> Self
pub fn Expression::loop_(LoopExpr) -> Self
pub fn Expression::memory_grow(MemoryGrowExpr) -> Self
pub fn Expression::memory_size(MemorySizeExpr) -> Self
pub fn Expression::nop() -> Self
pub fn Expression::return_(ReturnExpr) -> Self
pub fn Expression::select(SelectExpr) -> Self
pub fn Expression::store(StoreExpr) -> Self
pub fn Expression::switch(SwitchExpr) -> Self
pub fn Expression::unary(UnaryExpr) -> Self
pub fn Expression::unreachable_() -> Self
pub impl Eq for Expression
pub impl Show for Expression

pub struct ExpressionStore {
  expressions : Array[Expression]
  types : Array[WasmType]
}
pub fn ExpressionStore::add(Self, Expression, WasmType) -> ExprId
pub fn ExpressionStore::get(Self, ExprId) -> Expression?
pub fn ExpressionStore::get_type(Self, ExprId) -> WasmType
pub fn ExpressionStore::new() -> Self

pub struct FlowState {
  locals : Array[NodeId]
  condition : NodeId
}
pub fn FlowState::new(Array[NodeId], NodeId) -> Self

pub struct Function {
  name : String
  params : Array[WasmType]
  results : Array[WasmType]
  locals : Array[LocalInfo]
  body : ExprId?
  expressions : ExpressionStore
}
pub fn Function::add_local(Self, WasmType, String?) -> Int
pub fn Function::add_param(Self, WasmType) -> Int
pub fn Function::get_local_type(Self, Int) -> WasmType
pub fn Function::get_num_locals(Self) -> Int
pub fn Function::is_param(Self, Int) -> Bool
pub fn Function::new(String) -> Self

pub struct GVN {
  value_number : Map[NodeId, NodeId]
  expr_to_leader : Map[GVNKey, NodeId]
  in_progress : @set.Set[NodeId]
  mut iteration : Int
  mut changed : Bool
}
pub fn GVN::get_value_number(Self, NodeId) -> NodeId
pub fn GVN::has_self_reference(Self, Node) -> Bool
pub fn GVN::new() -> Self
pub fn GVN::process_node_optimistic(Self, Graph, Node) -> Unit
pub fn GVN::reprocess_node(Self, Graph, Node) -> Unit
pub fn GVN::set_changed(Self, Bool) -> Unit
pub fn GVN::set_iteration(Self, Int) -> Unit

type GVNKey

pub struct GenericExpr {
  children : Array[ExprId]
  result_type : WasmType
}
pub fn GenericExpr::new(Array[ExprId], WasmType) -> Self
pub impl Eq for GenericExpr
pub impl Show for GenericExpr

pub struct Graph {
  node_store : NodeStore
  set_node_map : Map[ExprId, NodeId]
  expression_condition_map : Map[ExprId, Array[NodeId]]
  expression_parent_map : Map[ExprId, ExprId]
  node_parent_map : Map[NodeId, ExprId]
  sets : Array[ExprId]
  constant_nodes : Map[Literal, NodeId]
  break_states : Map[String, Array[Array[NodeId]]]
  mut locals : Array[NodeId]
  mut parent : ExprId?
  mut func : Function?
  mut mod : Module?
  mut mssa : MemorySSA?
}
pub fn Graph::add_node(Self, Node) -> NodeId
pub fn Graph::bad(Self) -> NodeId
pub fn Graph::build(Self, Function, Module) -> Unit
pub fn Graph::debug_print(Self) -> String
pub fn Graph::do_visit_binary(Self, BinaryExpr, ExprId) -> NodeId
pub fn Graph::do_visit_block(Self, BlockExpr, ExprId) -> NodeId
pub fn Graph::do_visit_break(Self, BreakExpr) -> NodeId
pub fn Graph::do_visit_call(Self, CallExpr, ExprId) -> NodeId
pub fn Graph::do_visit_const(Self, ConstExpr) -> NodeId
pub fn Graph::do_visit_drop(Self, DropExpr, ExprId) -> NodeId
pub fn Graph::do_visit_generic(Self, Expression, ExprId) -> NodeId
pub fn Graph::do_visit_if(Self, IfExpr, ExprId) -> NodeId
pub fn Graph::do_visit_load(Self, LoadExpr, ExprId) -> NodeId
pub fn Graph::do_visit_local_get(Self, LocalGetExpr) -> NodeId
pub fn Graph::do_visit_local_set(Self, LocalSetExpr, ExprId) -> NodeId
pub fn Graph::do_visit_loop(Self, LoopExpr, ExprId) -> NodeId
pub fn Graph::do_visit_memory_grow(Self, MemoryGrowExpr, ExprId) -> NodeId
pub fn Graph::do_visit_memory_size(Self, MemorySizeExpr, ExprId) -> NodeId
pub fn Graph::do_visit_select(Self, SelectExpr, ExprId) -> NodeId
pub fn Graph::do_visit_store(Self, StoreExpr, ExprId) -> NodeId
pub fn Graph::do_visit_switch(Self, SwitchExpr) -> NodeId
pub fn Graph::do_visit_unary(Self, UnaryExpr, ExprId) -> NodeId
pub fn Graph::do_visit_unreachable(Self) -> NodeId
pub fn Graph::dominates(Self, NodeId, NodeId) -> Bool
pub fn Graph::ensure_i1(Self, NodeId, ExprId?) -> NodeId
pub fn Graph::expand_from_i1(Self, NodeId, ExprId?) -> NodeId
pub fn Graph::get_block_of_node(Self, NodeId) -> NodeId
pub fn Graph::get_conditions(Self, ExprId) -> Array[NodeId]
pub fn Graph::get_dominator_info(Self) -> DominatorInfo
pub fn Graph::get_node_for_set(Self, ExprId) -> NodeId?
pub fn Graph::get_parent(Self, ExprId) -> ExprId?
pub fn Graph::get_set_for_expr(Self, ExprId) -> ExprId?
pub fn Graph::get_set_for_node(Self, NodeId) -> ExprId?
pub fn Graph::get_sets(Self) -> Array[ExprId]
pub fn Graph::is_flow_state_unreachable(Self, FlowState) -> Bool
pub fn Graph::is_in_unreachable(Self) -> Bool
pub fn Graph::is_locals_unreachable(Self, Array[NodeId]) -> Bool
pub fn Graph::is_relevant_local(Self, Int) -> Bool
pub fn Graph::is_relevant_type(Self, WasmType) -> Bool
pub fn Graph::make_const(Self, Literal) -> NodeId
pub fn Graph::make_use(Self, NodeId) -> Expression?
pub fn Graph::make_var(Self, WasmType) -> NodeId
pub fn Graph::make_zero(Self, WasmType) -> NodeId
pub fn Graph::make_zero_comp(Self, NodeId, Bool, ExprId?) -> NodeId
pub fn Graph::merge(Self, Array[FlowState]) -> Unit
pub fn Graph::merge_block(Self, Array[Array[NodeId]]) -> Unit
pub fn Graph::merge_if(Self, Array[NodeId], Array[NodeId], NodeId, ExprId) -> Unit
pub fn Graph::new() -> Self
pub fn Graph::replace_all_uses(Self, NodeUsers, NodeId, NodeId, @set.Set[NodeId]) -> Unit
pub fn Graph::set_in_reachable(Self) -> Unit
pub fn Graph::set_in_unreachable(Self) -> Unit
pub fn Graph::visit(Self, ExprId) -> NodeId
pub fn Graph::visit_expression(Self, Expression, ExprId) -> NodeId

pub struct IfExpr {
  condition : ExprId
  if_true : ExprId
  if_false : ExprId?
  result_type : WasmType
}
pub fn IfExpr::new(ExprId, ExprId, ExprId?, WasmType) -> Self
pub impl Eq for IfExpr
pub impl Show for IfExpr

pub enum Literal {
  LitI32(Int)
  LitI64(Int64)
  LitF32(Float)
  LitF64(Double)
}
pub fn Literal::f32(Float) -> Self
pub fn Literal::f64(Double) -> Self
pub fn Literal::get_type(Self) -> WasmType
pub fn Literal::i32(Int) -> Self
pub fn Literal::i64(Int64) -> Self
pub fn Literal::make_zero(WasmType) -> Self
pub fn Literal::to_tinstr(Self) -> @lib.TInstr
pub impl Eq for Literal
pub impl Hash for Literal
pub impl Show for Literal

pub struct LoadExpr {
  op : LoadOp
  ptr : ExprId
  offset : Int
  align : Int
  result_type : WasmType
}
pub fn LoadExpr::new(LoadOp, ExprId, Int, Int, WasmType) -> Self
pub impl Eq for LoadExpr
pub impl Show for LoadExpr

pub enum LoadOp {
  LoadI32
  Load8SI32
  Load8UI32
  Load16SI32
  Load16UI32
  LoadI64
  Load8SI64
  Load8UI64
  Load16SI64
  Load16UI64
  Load32SI64
  Load32UI64
  LoadF32
  LoadF64
}
pub fn LoadOp::load16si32() -> Self
pub fn LoadOp::load16si64() -> Self
pub fn LoadOp::load16ui32() -> Self
pub fn LoadOp::load16ui64() -> Self
pub fn LoadOp::load32si64() -> Self
pub fn LoadOp::load32ui64() -> Self
pub fn LoadOp::load8si32() -> Self
pub fn LoadOp::load8si64() -> Self
pub fn LoadOp::load8ui32() -> Self
pub fn LoadOp::load8ui64() -> Self
pub fn LoadOp::load_f32() -> Self
pub fn LoadOp::load_f64() -> Self
pub fn LoadOp::load_i32() -> Self
pub fn LoadOp::load_i64() -> Self
pub impl Eq for LoadOp
pub impl Show for LoadOp

pub struct LocalGetExpr {
  index : Int
}
pub fn LocalGetExpr::new(Int) -> Self
pub impl Eq for LocalGetExpr
pub impl Show for LocalGetExpr

pub struct LocalInfo {
  local_type : WasmType
  is_param : Bool
  name : String?
}

pub struct LocalSetExpr {
  index : Int
  value : ExprId
  is_tee : Bool
}
pub fn LocalSetExpr::new(Int, ExprId, Bool) -> Self
pub impl Eq for LocalSetExpr
pub impl Show for LocalSetExpr

pub struct LoopExpr {
  name : String?
  body : ExprId
  result_type : WasmType
}
pub fn LoopExpr::new(String?, ExprId, WasmType) -> Self
pub impl Eq for LoopExpr
pub impl Show for LoopExpr

pub struct MemoryGrowExpr {
  memory_index : Int
  delta : ExprId
}
pub fn MemoryGrowExpr::new(Int, ExprId) -> Self
pub impl Eq for MemoryGrowExpr
pub impl Show for MemoryGrowExpr

pub struct MemoryNode {
  id : NodeId
  node_type : MemoryNodeType
  defining_access : NodeId?
  expr_id : ExprId?
}
pub fn MemoryNode::new(NodeId, MemoryNodeType, NodeId?, ExprId?) -> Self

pub enum MemoryNodeType {
  MemoryDef
  MemoryUse
  MemoryPhi
}
pub fn MemoryNodeType::memory_def() -> Self
pub fn MemoryNodeType::memory_phi() -> Self
pub fn MemoryNodeType::memory_use() -> Self

type MemorySSA
pub fn MemorySSA::get_current_state(Self) -> NodeId
pub fn MemorySSA::get_defining_access(Self, NodeId) -> NodeId?
pub fn MemorySSA::merge_states(Self, Graph, Array[NodeId], ExprId) -> Unit
pub fn MemorySSA::new(Graph) -> Self
pub fn MemorySSA::record_call(Self, Graph, NodeId, ExprId) -> Unit
pub fn MemorySSA::record_load(Self, Graph, NodeId, ExprId) -> Unit
pub fn MemorySSA::record_memory_grow(Self, Graph, NodeId, ExprId) -> Unit
pub fn MemorySSA::record_store(Self, Graph, NodeId, ExprId) -> Unit
pub fn MemorySSA::set_current_state(Self, NodeId) -> Unit

pub struct MemorySizeExpr {
  memory_index : Int
}
pub fn MemorySizeExpr::new(Int) -> Self
pub impl Eq for MemorySizeExpr
pub impl Show for MemorySizeExpr

pub struct MemoryState {
  current : NodeId
}
pub fn MemoryState::new(NodeId) -> Self

pub struct Module {
  functions : Map[String, Function]
  name : String?
}
pub fn Module::add_function(Self, Function) -> Unit
pub fn Module::new() -> Self

pub struct Node {
  mut id : NodeId
  node_type : NodeType
  mut wasm_type : WasmType
  expr : Expression?
  mut index : Int
  mut origin : ExprId?
  values : Array[NodeId]
}
pub fn Node::add_value(Self, NodeId) -> Unit
pub fn Node::get_value(Self, Int) -> NodeId?
pub fn Node::has_side_effects(Self) -> Bool
pub fn Node::is_bad(Self) -> Bool
pub fn Node::is_block(Self) -> Bool
pub fn Node::is_cond(Self) -> Bool
pub fn Node::is_const(Self) -> Bool
pub fn Node::is_expr(Self) -> Bool
pub fn Node::is_memory_def(Self) -> Bool
pub fn Node::is_memory_phi(Self) -> Bool
pub fn Node::is_phi(Self) -> Bool
pub fn Node::is_root(Self) -> Bool
pub fn Node::is_var(Self) -> Bool
pub fn Node::is_zext(Self) -> Bool
pub fn Node::make_bad(NodeId) -> Self
pub fn Node::make_block(NodeId) -> Self
pub fn Node::make_cond(NodeId, NodeId, Int, NodeId) -> Self
pub fn Node::make_expr(NodeId, Expression, ExprId?) -> Self
pub fn Node::make_memory_def(NodeId, NodeId?) -> Self
pub fn Node::make_memory_phi(NodeId, Array[NodeId]) -> Self
pub fn Node::make_phi(NodeId, NodeId, Int) -> Self
pub fn Node::make_var(NodeId, WasmType) -> Self
pub fn Node::make_zext(NodeId, NodeId, ExprId?) -> Self
pub fn Node::new(NodeId, NodeType) -> Self
pub fn Node::returns_i1(Self) -> Bool

pub struct NodeId(Int)
#deprecated
pub fn NodeId::inner(Self) -> Int
pub fn NodeId::new(Int) -> Self
pub impl Compare for NodeId
pub impl Eq for NodeId
pub impl Hash for NodeId
pub impl Show for NodeId

pub struct NodeStore {
  mut nodes : Array[Node]
  mut bad_node_id : NodeId
}
pub fn NodeStore::add_node(Self, Node) -> NodeId
pub fn NodeStore::bad(Self) -> NodeId
pub fn NodeStore::get(Self, NodeId) -> Node?
pub fn NodeStore::get_mut(Self, NodeId) -> Node?
pub fn NodeStore::get_wasm_type(Self, NodeId) -> WasmType
pub fn NodeStore::is_bad(Self, NodeId) -> Bool
pub fn NodeStore::len(Self) -> Int
pub fn NodeStore::new() -> Self
pub fn NodeStore::remove(Self, NodeId) -> Unit

pub enum NodeType {
  Var
  Expr
  Phi
  Cond
  Block
  Zext
  Bad
  MemoryDef
  MemoryPhi
}
pub impl Eq for NodeType
pub impl Show for NodeType

type NodeUsers
pub fn NodeUsers::add_user(Self, NodeId, NodeId) -> Unit
pub fn NodeUsers::build(Graph) -> Self
pub fn NodeUsers::get_users(Self, NodeId) -> Array[NodeId]
pub fn NodeUsers::new() -> Self
pub fn NodeUsers::num_uses(Self, NodeId) -> Int
pub fn NodeUsers::remove_all_uses_of(Self, NodeId) -> Unit
pub fn NodeUsers::remove_user(Self, NodeId, NodeId) -> Unit

pub struct PhiCongruence {
  class_rep : Map[NodeId, NodeId]
  class_members : Map[NodeId, Array[NodeId]]
}
pub fn PhiCongruence::find(Self, NodeId) -> NodeId
pub fn PhiCongruence::new() -> Self
pub fn PhiCongruence::union(Self, NodeId, NodeId) -> Unit

pub struct PhiWebGVN {
  gvn : GVN
  congruence : PhiCongruence
  worklist : Array[(NodeId, NodeId)]
}
pub fn PhiWebGVN::check_phi_congruence(Self, Graph, Node, Node) -> Bool
pub fn PhiWebGVN::compute_congruence(Self, Graph) -> Unit
pub fn PhiWebGVN::new() -> Self

pub struct ReturnExpr {
  value : ExprId?
}
pub fn ReturnExpr::new(ExprId?) -> Self
pub impl Eq for ReturnExpr
pub impl Show for ReturnExpr

pub struct SelectExpr {
  if_true : ExprId
  if_false : ExprId
  condition : ExprId
  result_type : WasmType
}
pub fn SelectExpr::new(ExprId, ExprId, ExprId, WasmType) -> Self
pub impl Eq for SelectExpr
pub impl Show for SelectExpr

pub struct StoreExpr {
  op : StoreOp
  ptr : ExprId
  value : ExprId
  offset : Int
  align : Int
}
pub fn StoreExpr::new(StoreOp, ExprId, ExprId, Int, Int) -> Self
pub impl Eq for StoreExpr
pub impl Show for StoreExpr

pub enum StoreOp {
  StoreI32
  Store8I32
  Store16I32
  StoreI64
  Store8I64
  Store16I64
  Store32I64
  StoreF32
  StoreF64
}
pub fn StoreOp::store16_i32() -> Self
pub fn StoreOp::store16_i64() -> Self
pub fn StoreOp::store32_i64() -> Self
pub fn StoreOp::store8_i32() -> Self
pub fn StoreOp::store_8i64() -> Self
pub fn StoreOp::store_f32() -> Self
pub fn StoreOp::store_f64() -> Self
pub fn StoreOp::store_i32() -> Self
pub fn StoreOp::store_i64() -> Self
pub impl Eq for StoreOp
pub impl Show for StoreOp

pub struct SwitchExpr {
  condition : ExprId
  targets : Array[String]
  default : String
}
pub fn SwitchExpr::new(ExprId, Array[String], String) -> Self
pub impl Eq for SwitchExpr
pub impl Show for SwitchExpr

pub struct UnaryExpr {
  op : UnaryOp
  value : ExprId
  result_type : WasmType
}
pub fn UnaryExpr::new(UnaryOp, ExprId, WasmType) -> Self
pub impl Eq for UnaryExpr
pub impl Show for UnaryExpr

pub enum UnaryOp {
  ClzInt32
  ClzInt64
  CtzInt32
  CtzInt64
  PopcntInt32
  PopcntInt64
  EqZInt32
  EqZInt64
  ExtendSInt32
  ExtendUInt32
  WrapInt64
  NegFloat32
  NegFloat64
  AbsFloat32
  AbsFloat64
  SqrtFloat32
  CeilFloat32
  FloorFloat32
  TruncFloat32
  NearestFloat32
  SqrtFloat64
  CeilFloat64
  FloorFloat64
  TruncFloat64
  NearestFloat64
  TruncSFloat32ToInt32
  TruncUFloat32ToInt32
  TruncSFloat64ToInt32
  TruncUFloat64ToInt32
  TruncSFloat32ToInt64
  TruncUFloat32ToInt64
  TruncSFloat64ToInt64
  TruncUFloat64ToInt64
  ConvertSInt32ToFloat32
  ConvertUInt32ToFloat32
  ConvertSInt64ToFloat32
  ConvertUInt64ToFloat32
  ConvertSInt32ToFloat64
  ConvertUInt32ToFloat64
  ConvertSInt64ToFloat64
  ConvertUInt64ToFloat64
  PromoteFloat32
  DemoteFloat64
  ReinterpretFloat32
  ReinterpretFloat64
  ReinterpretInt32
  ReinterpretInt64
}
pub fn UnaryOp::abs_float32() -> Self
pub fn UnaryOp::abs_float64() -> Self
pub fn UnaryOp::ceil_float32() -> Self
pub fn UnaryOp::ceil_float64() -> Self
pub fn UnaryOp::clz_int32() -> Self
pub fn UnaryOp::clz_int64() -> Self
pub fn UnaryOp::convert_s_int32_to_float32() -> Self
pub fn UnaryOp::convert_s_int32_to_float64() -> Self
pub fn UnaryOp::convert_s_int64_to_float32() -> Self
pub fn UnaryOp::convert_s_int64_to_float64() -> Self
pub fn UnaryOp::convert_u_int32_to_float32() -> Self
pub fn UnaryOp::convert_u_int32_to_float64() -> Self
pub fn UnaryOp::convert_u_int64_to_float32() -> Self
pub fn UnaryOp::convert_u_int64_to_float64() -> Self
pub fn UnaryOp::ctz_int32() -> Self
pub fn UnaryOp::ctz_int64() -> Self
pub fn UnaryOp::demote_float64() -> Self
pub fn UnaryOp::eq_z_int32() -> Self
pub fn UnaryOp::eq_z_int64() -> Self
pub fn UnaryOp::extend_s_int32() -> Self
pub fn UnaryOp::extend_u_int32() -> Self
pub fn UnaryOp::floor_float32() -> Self
pub fn UnaryOp::floor_float64() -> Self
pub fn UnaryOp::is_relational(Self) -> Bool
pub fn UnaryOp::nearest_float32() -> Self
pub fn UnaryOp::nearest_float64() -> Self
pub fn UnaryOp::neg_float32() -> Self
pub fn UnaryOp::neg_float64() -> Self
pub fn UnaryOp::popcnt_int32() -> Self
pub fn UnaryOp::popcnt_int64() -> Self
pub fn UnaryOp::promote_float32() -> Self
pub fn UnaryOp::reinterpret_float32() -> Self
pub fn UnaryOp::reinterpret_float64() -> Self
pub fn UnaryOp::reinterpret_int32() -> Self
pub fn UnaryOp::reinterpret_int64() -> Self
pub fn UnaryOp::sqrt_float32() -> Self
pub fn UnaryOp::sqrt_float64() -> Self
pub fn UnaryOp::trunc_float32() -> Self
pub fn UnaryOp::trunc_float64() -> Self
pub fn UnaryOp::trunc_s_float32_to_int32() -> Self
pub fn UnaryOp::trunc_s_float32_to_int64() -> Self
pub fn UnaryOp::trunc_s_float64_to_int32() -> Self
pub fn UnaryOp::trunc_s_float64_to_int64() -> Self
pub fn UnaryOp::trunc_u_float32_to_int32() -> Self
pub fn UnaryOp::trunc_u_float32_to_int64() -> Self
pub fn UnaryOp::trunc_u_float64_to_int32() -> Self
pub fn UnaryOp::trunc_u_float64_to_int64() -> Self
pub fn UnaryOp::wrap_int64() -> Self
pub impl Eq for UnaryOp
pub impl Show for UnaryOp

pub enum WasmType {
  I32
  I64
  F32
  F64
  V128
  FuncRef
  ExternRef
  Unreachable
  None
}
pub fn WasmType::bit_size(Self) -> Int
pub fn WasmType::extern_ref() -> Self
pub fn WasmType::f32() -> Self
pub fn WasmType::f64() -> Self
pub fn WasmType::func_ref() -> Self
pub fn WasmType::i32() -> Self
pub fn WasmType::i64() -> Self
pub fn WasmType::is_concrete(Self) -> Bool
pub fn WasmType::is_integer(Self) -> Bool
pub fn WasmType::none() -> Self
pub fn WasmType::unreachable_() -> Self
pub fn WasmType::v128() -> Self
pub impl Eq for WasmType
pub impl Hash for WasmType
pub impl Show for WasmType

// Type aliases
pub type Locals = Array[NodeId]

// Traits

