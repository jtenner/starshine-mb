{"version":3,"sources":["/home/jtenner/Projects/starshine-mb/src/validate/__generated_driver_for_internal_test.mbt","/home/jtenner/Projects/starshine-mb/src/validate/invalid_fuzzer.mbt","/home/jtenner/Projects/starshine-mb/src/validate/match.mbt","/home/jtenner/Projects/starshine-mb/src/validate/typecheck.mbt","/home/jtenner/Projects/starshine-mb/src/validate/validate.mbt","/home/jtenner/Projects/starshine-mb/src/validate/gen_valid.mbt","/home/jtenner/Projects/starshine-mb/src/lib/env.mbt","/home/jtenner/Projects/starshine-mb/src/lib/eq.mbt","/home/jtenner/Projects/starshine-mb/src/lib/show.mbt","/home/jtenner/Projects/starshine-mb/src/lib/texpr.mbt","/home/jtenner/Projects/starshine-mb/src/lib/transformer.mbt","/home/jtenner/Projects/starshine-mb/src/lib/types.mbt","/home/jtenner/Projects/starshine-mb/src/lib/util.mbt","/home/jtenner/.moon/lib/core/quickcheck/splitmix/random.mbt","/home/jtenner/.moon/lib/core/float/methods.mbt","/home/jtenner/.moon/lib/core/double/double.mbt","/home/jtenner/.moon/lib/core/double/internal/ryu/ryu.mbt","/home/jtenner/.moon/lib/core/builtin/array.mbt","/home/jtenner/.moon/lib/core/builtin/arraycore_nonjs.mbt","/home/jtenner/.moon/lib/core/builtin/array_block.mbt","/home/jtenner/.moon/lib/core/builtin/arrayview.mbt","/home/jtenner/.moon/lib/core/builtin/assert.mbt","/home/jtenner/.moon/lib/core/builtin/autoloc.mbt","/home/jtenner/.moon/lib/core/builtin/bool.mbt","/home/jtenner/.moon/lib/core/builtin/bytes.mbt","/home/jtenner/.moon/lib/core/builtin/bytesview.mbt","/home/jtenner/.moon/lib/core/builtin/console.mbt","/home/jtenner/.moon/lib/core/builtin/hasher.mbt","/home/jtenner/.moon/lib/core/builtin/iterator.mbt","/home/jtenner/.moon/lib/core/builtin/intrinsics.mbt","/home/jtenner/.moon/lib/core/builtin/byte.mbt","/home/jtenner/.moon/lib/core/builtin/linked_hash_map.mbt","/home/jtenner/.moon/lib/core/builtin/int.mbt","/home/jtenner/.moon/lib/core/builtin/option.mbt","/home/jtenner/.moon/lib/core/builtin/readonlyarray.mbt","/home/jtenner/.moon/lib/core/builtin/result.mbt","/home/jtenner/.moon/lib/core/builtin/show.mbt","/home/jtenner/.moon/lib/core/builtin/string_methods.mbt","/home/jtenner/.moon/lib/core/builtin/string.mbt","/home/jtenner/.moon/lib/core/builtin/stringbuilder_buffer.mbt","/home/jtenner/.moon/lib/core/builtin/stringbuilder.mbt","/home/jtenner/.moon/lib/core/builtin/stringview.mbt","/home/jtenner/.moon/lib/core/builtin/failure.mbt","/home/jtenner/.moon/lib/core/builtin/to_string.mbt","/home/jtenner/.moon/lib/core/builtin/traits.mbt","/home/jtenner/.moon/lib/core/builtin/uninitialized_array.mbt","/home/jtenner/.moon/lib/core/builtin/unit.mbt","/home/jtenner/.moon/lib/core/abort/abort.mbt"],"sourcesContent":[null,"///|\n/// Increment all indices of a specific type to cause out-of-bounds errors\nfn make_funcidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_funcidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : FuncIdx,\n    ) -> TransformerResult[Unit, FuncIdx] {\n      let FuncIdx(i) = idx\n      // Make idempotent: if already large, don't transform again\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), FuncIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_typeidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_typeidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : TypeIdx,\n    ) -> TransformerResult[Unit, TypeIdx] {\n      match idx {\n        TypeIdx(i) =>\n          if i >= target {\n            Ok(None)\n          } else {\n            Ok(Some(((), TypeIdx(i + target))))\n          }\n        RecIdx(i) =>\n          if i >= target {\n            Ok(None)\n          } else {\n            Ok(Some(((), RecIdx(i + target))))\n          }\n      }\n    }),\n  }\n}\n\n///|\nfn make_localidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_localidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : LocalIdx,\n    ) -> TransformerResult[Unit, LocalIdx] {\n      let LocalIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), LocalIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_globalidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_globalidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : GlobalIdx,\n    ) -> TransformerResult[Unit, GlobalIdx] {\n      let GlobalIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), GlobalIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_labelidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_labelidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : LabelIdx,\n    ) -> TransformerResult[Unit, LabelIdx] {\n      let LabelIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), LabelIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_tableidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_tableidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : TableIdx,\n    ) -> TransformerResult[Unit, TableIdx] {\n      let TableIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), TableIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_memidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_memidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : MemIdx,\n    ) -> TransformerResult[Unit, MemIdx] {\n      let MemIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), MemIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_dataidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_dataidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : DataIdx,\n    ) -> TransformerResult[Unit, DataIdx] {\n      let DataIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), DataIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_elemidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_elemidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : ElemIdx,\n    ) -> TransformerResult[Unit, ElemIdx] {\n      let ElemIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), ElemIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\nfn make_tagidx_oob_transformer(offset : UInt) -> ModuleTransformer[Unit] {\n  let target = offset + 0x7FFFFFFF\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_tagidx: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      idx : TagIdx,\n    ) -> TransformerResult[Unit, TagIdx] {\n      let TagIdx(i) = idx\n      if i >= target {\n        Ok(None)\n      } else {\n        Ok(Some(((), TagIdx(i + target))))\n      }\n    }),\n  }\n}\n\n///|\n/// Use Bool context to track if we've already corrupted an expr\nfn make_type_corruption_transformer() -> ModuleTransformer[Bool] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_expr: Some(fn(\n      _ : ModuleTransformer[Bool],\n      done : Bool,\n      expr : Expr,\n    ) -> TransformerResult[Bool, Expr] {\n      if done {\n        return Ok(None)\n      }\n      let Expr(instrs) = expr\n      if instrs.length() == 0 {\n        return Ok(None)\n      }\n      // Insert i32.const followed by i64.add - guaranteed type error\n      let new_instrs = [@lib.I32Const(I32(42)), I64Add]\n      for i in instrs {\n        new_instrs.push(i)\n      }\n      Ok(Some((true, Expr(new_instrs))))\n    }),\n  }\n}\n\n///|\nfn make_numtype_swap_transformer() -> ModuleTransformer[Unit] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new()\n    // Only swap the VALUE TYPES, not the instructions\n    // This creates mismatches between declared types and instruction semantics\n    ,\n    on_valtype: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      vt : ValType,\n    ) -> TransformerResult[Unit, ValType] {\n      match vt {\n        NumTypeValType(I32NumType) => Ok(Some(((), NumTypeValType(F64NumType))))\n        NumTypeValType(I64NumType) => Ok(Some(((), NumTypeValType(F32NumType))))\n        NumTypeValType(F32NumType) => Ok(Some(((), NumTypeValType(I64NumType))))\n        NumTypeValType(F64NumType) => Ok(Some(((), NumTypeValType(I32NumType))))\n        _ => Ok(None)\n      }\n    }),\n  }\n}\n\n///|\n/// Aggressive nullability flip - make ALL ref types non-nullable\n/// This will fail if there's any ref.null, table without init, or nullable parameter\nfn make_nullability_flip_transformer() -> ModuleTransformer[Unit] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_reftype: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      rt : RefType,\n    ) -> TransformerResult[Unit, RefType] {\n      match rt {\n        // Force all ref types to be non-nullable\n        HeapTypeRefType(true, ht) => Ok(Some(((), HeapTypeRefType(false, ht))))\n        // Already non-nullable - convert to bottom type to cause more errors\n        HeapTypeRefType(false, AbsHeapTypeHeapType(NoneAbsHeapType)) => Ok(None)\n        HeapTypeRefType(false, AbsHeapTypeHeapType(NoFuncAbsHeapType)) =>\n          Ok(None)\n        HeapTypeRefType(false, AbsHeapTypeHeapType(NoExternAbsHeapType)) =>\n          Ok(None)\n        HeapTypeRefType(false, ht) =>\n          // Change to bottom type of same hierarchy - very restrictive\n          match ht {\n            AbsHeapTypeHeapType(FuncAbsHeapType)\n            | AbsHeapTypeHeapType(NoFuncAbsHeapType) =>\n              Ok(\n                Some(\n                  (\n                    (),\n                    HeapTypeRefType(\n                      false,\n                      AbsHeapTypeHeapType(NoFuncAbsHeapType),\n                    ),\n                  ),\n                ),\n              )\n            AbsHeapTypeHeapType(ExternAbsHeapType)\n            | AbsHeapTypeHeapType(NoExternAbsHeapType) =>\n              Ok(\n                Some(\n                  (\n                    (),\n                    HeapTypeRefType(\n                      false,\n                      AbsHeapTypeHeapType(NoExternAbsHeapType),\n                    ),\n                  ),\n                ),\n              )\n            AbsHeapTypeHeapType(ExnAbsHeapType)\n            | AbsHeapTypeHeapType(NoExnAbsHeapType) =>\n              Ok(\n                Some(\n                  (\n                    (),\n                    HeapTypeRefType(\n                      false,\n                      AbsHeapTypeHeapType(NoExnAbsHeapType),\n                    ),\n                  ),\n                ),\n              )\n            _ =>\n              // For any/eq/struct/array/i31 hierarchy, use none\n              Ok(\n                Some(\n                  (\n                    (),\n                    HeapTypeRefType(false, AbsHeapTypeHeapType(NoneAbsHeapType)),\n                  ),\n                ),\n              )\n          }\n        AbsHeapTypeRefType(aht) =>\n          // These shorthands are nullable, make them non-null with explicit form\n          Ok(Some(((), HeapTypeRefType(false, AbsHeapTypeHeapType(aht)))))\n      }\n    }),\n    // Also corrupt ref.null to create definite type errors\n    on_instruction: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      instr : Instruction,\n    ) -> TransformerResult[Unit, Instruction] {\n      match instr {\n        // ref.null produces nullable ref, but if types expect non-null, this fails\n        // Replace with something that definitely won't typecheck\n        RefNull(_) => Ok(Some(((), I32Const(I32(0))))) // Completely wrong type\n        RefFunc(_) => Ok(Some(((), I64Const(I64(0L))))) // Wrong type for funcref\n        RefIsNull => Ok(Some(((), I64Const(I64(0L))))) // Expects ref, we removed it\n        _ => Ok(None)\n      }\n    }),\n  }\n}\n\n///|\n/// Alternative strategy: corrupt ONLY type declarations, not code\n/// This creates inconsistency between what's declared and what's executed\nfn make_signature_corruption_transformer() -> ModuleTransformer[Unit] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_comptype: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      ct : CompType,\n    ) -> TransformerResult[Unit, CompType] {\n      match ct {\n        FuncCompType(params, results) => {\n          // Add extra parameters that callers won't provide\n          let new_params = params.copy()\n          new_params.push(NumTypeValType(I64NumType))\n          new_params.push(NumTypeValType(F64NumType))\n          // Change result types\n          let new_results = results.map(fn(vt) {\n            match vt {\n              NumTypeValType(I32NumType) => @lib.NumTypeValType(F64NumType)\n              NumTypeValType(I64NumType) => NumTypeValType(F32NumType)\n              NumTypeValType(F32NumType) => NumTypeValType(I64NumType)\n              NumTypeValType(F64NumType) => NumTypeValType(I32NumType)\n              other => other\n            }\n          })\n          Ok(Some(((), FuncCompType(new_params, new_results))))\n        }\n        StructCompType(fields) => {\n          // Change field types\n          let new_fields = fields.map(fn(ft) {\n            let FieldType(st, mutability) = ft\n            match st {\n              ValTypeStorageType(NumTypeValType(I32NumType)) =>\n                @lib.FieldType(\n                  ValTypeStorageType(NumTypeValType(F64NumType)),\n                  mutability,\n                )\n              ValTypeStorageType(NumTypeValType(I64NumType)) =>\n                FieldType(\n                  ValTypeStorageType(NumTypeValType(F32NumType)),\n                  mutability,\n                )\n              _ => ft\n            }\n          })\n          Ok(Some(((), StructCompType(new_fields))))\n        }\n        ArrayCompType(FieldType(st, mutability)) => {\n          let new_st = match st {\n            ValTypeStorageType(NumTypeValType(I32NumType)) =>\n              @lib.ValTypeStorageType(NumTypeValType(F64NumType))\n            ValTypeStorageType(NumTypeValType(I64NumType)) =>\n              ValTypeStorageType(NumTypeValType(F32NumType))\n            _ => st\n          }\n          Ok(Some(((), ArrayCompType(FieldType(new_st, mutability)))))\n        }\n      }\n    }),\n  }\n}\n\n///|\n/// Strategy that corrupts global initializers to not match declared types\nfn make_global_init_mismatch_transformer() -> ModuleTransformer[Unit] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_global: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      g : Global,\n    ) -> TransformerResult[Unit, Global] {\n      let Global(GlobalType(vt, mutable), _init) = g\n      // Create an init expression with wrong type\n      let wrong_init = match vt {\n        NumTypeValType(I32NumType) => @lib.Expr([F64Const(F64(0.0))])\n        NumTypeValType(I64NumType) => Expr([F32Const(F32(0.0))])\n        NumTypeValType(F32NumType) => Expr([I64Const(I64(0L))])\n        NumTypeValType(F64NumType) => Expr([I32Const(I32(0))])\n        RefTypeValType(_) => Expr([I32Const(I32(0))]) // Definitely wrong\n        VecTypeValType => Expr([I32Const(I32(0))])\n        BotValType => return Ok(None)\n      }\n      Ok(Some(((), Global(GlobalType(vt, mutable), wrong_init))))\n    }),\n  }\n}\n\n///|\n/// Strategy that corrupts table initializers\nfn make_table_init_mismatch_transformer() -> ModuleTransformer[Unit] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_table: Some(fn(\n      _ : ModuleTransformer[Unit],\n      _ctx : Unit,\n      t : Table,\n    ) -> TransformerResult[Unit, Table] {\n      let Table(tt, _init) = t\n      // Set init to wrong type expression\n      Ok(Some(((), Table(tt, Some(Expr([I32Const(I32(42))]))))))\n    }),\n  }\n}\n\n///|\n/// More aggressive drop insertion - prepend Drop to cause stack underflow\nfn make_drop_insertion_transformer() -> ModuleTransformer[Bool] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_expr: Some(fn(\n      _ : ModuleTransformer[Bool],\n      done : Bool,\n      expr : Expr,\n    ) -> TransformerResult[Bool, Expr] {\n      if done {\n        return Ok(None)\n      }\n      let Expr(instrs) = expr\n      if instrs.length() == 0 {\n        return Ok(None)\n      }\n      // Prepend Drop instructions to cause stack underflow\n      let new_instrs : Array[Instruction] = [Drop, Drop, Drop]\n      for i in instrs {\n        new_instrs.push(i)\n      }\n      Ok(Some((true, Expr(new_instrs))))\n    }),\n  }\n}\n\n///|\n/// Remove block ends / corrupt block structure - use Bool to do once\nfn make_block_corruption_transformer() -> ModuleTransformer[Bool] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_expr: Some(fn(\n      _ : ModuleTransformer[Bool],\n      done : Bool,\n      expr : Expr,\n    ) -> TransformerResult[Bool, Expr] {\n      if done {\n        return Ok(None)\n      }\n      let Expr(instrs) = expr\n      if instrs.length() > 0 {\n        Ok(\n          Some((true, Expr(instrs.iter().take(instrs.length() - 1).collect()))),\n        )\n      } else {\n        Ok(None)\n      }\n    }),\n  }\n}\n\n///|\nfn corrupt_blocktype(bt : BlockType) -> BlockType {\n  match bt {\n    EmptyBlockType => ValTypeBlockType(NumTypeValType(I32NumType))\n    ValTypeBlockType(NumTypeValType(I32NumType)) =>\n      ValTypeBlockType(NumTypeValType(I64NumType))\n    ValTypeBlockType(NumTypeValType(I64NumType)) =>\n      ValTypeBlockType(NumTypeValType(I32NumType))\n    ValTypeBlockType(_) => EmptyBlockType\n    TypeIdxBlockType(TypeIdx(i)) => TypeIdxBlockType(TypeIdx(i + 1))\n    TypeIdxBlockType(RecIdx(i)) => TypeIdxBlockType(RecIdx(i + 1))\n  }\n}\n\n///|\n/// Block type mismatch - insert blocks with wrong types or corrupt existing ones\nfn make_blocktype_mismatch_transformer() -> ModuleTransformer[Bool] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_instruction: Some(fn(\n      _ : ModuleTransformer[Bool],\n      done : Bool,\n      ins : Instruction,\n    ) -> TransformerResult[Bool, Instruction] {\n      if done {\n        return Ok(None)\n      }\n      match ins {\n        // Value-producing instructions: wrap in block claiming no result\n        // Body produces value, block claims nothing -> mismatch\n        I32Const(_)\n        | I64Const(_)\n        | F32Const(_)\n        | F64Const(_)\n        | V128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>\n          Ok(Some((true, Block(EmptyBlockType, [ins]))))\n\n        // Nop/Drop: wrap in block claiming it produces i32\n        // Body produces nothing, block claims i32 -> mismatch\n        Nop | Drop =>\n          Ok(\n            Some(\n              (true, Block(ValTypeBlockType(NumTypeValType(I32NumType)), [ins])),\n            ),\n          )\n\n        // LocalGet produces a value - wrap in block claiming different type\n        LocalGet(_) =>\n          Ok(\n            Some(\n              (true, Block(ValTypeBlockType(NumTypeValType(I64NumType)), [ins])),\n            ),\n          )\n\n        // GlobalGet produces a value - wrap in block claiming empty\n        GlobalGet(_) => Ok(Some((true, Block(EmptyBlockType, [ins]))))\n\n        // Existing control flow: corrupt their block type\n        Block(bt, body) => Ok(Some((true, Block(corrupt_blocktype(bt), body))))\n        Loop(bt, body) => Ok(Some((true, Loop(corrupt_blocktype(bt), body))))\n        If(bt, then_body, else_body) =>\n          Ok(Some((true, If(corrupt_blocktype(bt), then_body, else_body))))\n        TryTable(bt, catches, body) =>\n          Ok(Some((true, TryTable(corrupt_blocktype(bt), catches, body))))\n\n        // RefNull produces a ref - wrap in block claiming i32\n        RefNull(_) =>\n          Ok(\n            Some(\n              (true, Block(ValTypeBlockType(NumTypeValType(I32NumType)), [ins])),\n            ),\n          )\n\n        // RefFunc produces a ref - wrap in block claiming empty\n        RefFunc(_) => Ok(Some((true, Block(EmptyBlockType, [ins]))))\n\n        // StructNewDefault produces a ref - wrap in block claiming i32\n        StructNewDefault(_) =>\n          Ok(\n            Some(\n              (true, Block(ValTypeBlockType(NumTypeValType(I32NumType)), [ins])),\n            ),\n          )\n\n        // ArrayNewDefault needs i32 on stack, produces ref\n        // Can't easily wrap this one without also providing the i32\n\n        _ => Ok(None)\n      }\n    }),\n  }\n}\n\n///|\npriv enum InvalidationStrategy {\n  FuncIdxOOB(UInt)\n  TypeIdxOOB(UInt)\n  LocalIdxOOB(UInt)\n  GlobalIdxOOB(UInt)\n  LabelIdxOOB(UInt)\n  TableIdxOOB(UInt)\n  MemIdxOOB(UInt)\n  DataIdxOOB(UInt)\n  ElemIdxOOB(UInt)\n  TagIdxOOB(UInt)\n  NumTypeSwap\n  NullabilityFlip\n  HeapTypeSwap\n  InstructionTypeMismatch\n  BlockTypeMismatch\n  DropInsertion\n  BlockCorruption\n  SignatureCorruption\n  GlobalInitMismatch\n  TableInitMismatch\n}\n\n///|\n/// Apply strategy and return transformed module\nfn apply_strategy(\n  strategy : InvalidationStrategy,\n  mod_ : Module,\n) -> (Bool, Module) {\n  match strategy {\n    FuncIdxOOB(n) =>\n      match make_funcidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    TypeIdxOOB(n) =>\n      match make_typeidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    LocalIdxOOB(n) =>\n      match make_localidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    GlobalIdxOOB(n) =>\n      match make_globalidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    LabelIdxOOB(n) =>\n      match make_labelidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    TableIdxOOB(n) =>\n      match make_tableidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    MemIdxOOB(n) =>\n      match make_memidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    DataIdxOOB(n) =>\n      match make_dataidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    ElemIdxOOB(n) =>\n      match make_elemidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    TagIdxOOB(n) =>\n      match make_tagidx_oob_transformer(n).walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    NumTypeSwap =>\n      match make_numtype_swap_transformer().walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    NullabilityFlip =>\n      match make_nullability_flip_transformer().walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    HeapTypeSwap =>\n      match make_drop_insertion_transformer().walk_module(false, mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    InstructionTypeMismatch =>\n      match make_type_corruption_transformer().walk_module(false, mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    BlockTypeMismatch =>\n      match make_blocktype_mismatch_transformer().walk_module(false, mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    DropInsertion =>\n      match make_drop_insertion_transformer().walk_module(false, mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    BlockCorruption =>\n      match make_block_corruption_transformer().walk_module(false, mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    SignatureCorruption =>\n      match make_signature_corruption_transformer().walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    GlobalInitMismatch =>\n      match make_global_init_mismatch_transformer().walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n    TableInitMismatch =>\n      match make_table_init_mismatch_transformer().walk_module((), mod_) {\n        Ok(Some((_, new_mod))) => (true, new_mod)\n        _ => (false, mod_)\n      }\n  }\n}\n\n///|\nfn InvalidationStrategy::to_string(self : InvalidationStrategy) -> String {\n  match self {\n    FuncIdxOOB(_) => \"FuncIdxOOB\"\n    TypeIdxOOB(_) => \"TypeIdxOOB\"\n    LocalIdxOOB(_) => \"LocalIdxOOB\"\n    GlobalIdxOOB(_) => \"GlobalIdxOOB\"\n    LabelIdxOOB(_) => \"LabelIdxOOB\"\n    TableIdxOOB(_) => \"TableIdxOOB\"\n    MemIdxOOB(_) => \"MemIdxOOB\"\n    DataIdxOOB(_) => \"DataIdxOOB\"\n    ElemIdxOOB(_) => \"ElemIdxOOB\"\n    TagIdxOOB(_) => \"TagIdxOOB\"\n    NumTypeSwap => \"NumTypeSwap\"\n    NullabilityFlip => \"NullabilityFlip\"\n    HeapTypeSwap => \"HeapTypeSwap\"\n    InstructionTypeMismatch => \"InstructionTypeMismatch\"\n    BlockTypeMismatch => \"BlockTypeMismatch\"\n    DropInsertion => \"DropInsertion\"\n    BlockCorruption => \"BlockCorruption\"\n    SignatureCorruption => \"SignatureCorruption\"\n    GlobalInitMismatch => \"GlobalInitMismatch\"\n    TableInitMismatch => \"TableInitMismatch\"\n  }\n}\n\n///|\n/// Result of testing a single strategy\nfn fuzz_invalid_module_with_coverage(\n  valid_module : Module,\n  strategy : InvalidationStrategy,\n) -> (String, Bool, Bool) {\n  let strategy_name = strategy.to_string()\n  let (was_modified, invalid_module) = apply_strategy(strategy, valid_module)\n\n  // Not tested if no modification was made OR module unchanged\n  if not(was_modified) || invalid_module == valid_module {\n    return (strategy_name, false, true)\n  }\n  match validate_module(invalid_module) {\n    Ok(_) => (strategy_name, true, false)\n    Err(_) => (strategy_name, true, true)\n  }\n}\n\n///|\nfn fuzz_all_strategies_with_coverage(\n  valid_module : Module,\n) -> Array[(String, Bool, Bool)] {\n  let strategies : Array[InvalidationStrategy] = [\n    FuncIdxOOB(1),\n    FuncIdxOOB(100),\n    TypeIdxOOB(1),\n    TypeIdxOOB(100),\n    LocalIdxOOB(1),\n    LocalIdxOOB(100),\n    GlobalIdxOOB(1),\n    LabelIdxOOB(1),\n    TableIdxOOB(1),\n    MemIdxOOB(1),\n    DataIdxOOB(1),\n    ElemIdxOOB(1),\n    TagIdxOOB(1),\n    NumTypeSwap,\n    NullabilityFlip,\n    HeapTypeSwap,\n    InstructionTypeMismatch,\n    BlockTypeMismatch,\n    DropInsertion,\n    BlockCorruption,\n    SignatureCorruption,\n    GlobalInitMismatch,\n    TableInitMismatch,\n  ]\n  strategies.map(fn(s) { fuzz_invalid_module_with_coverage(valid_module, s) })\n}\n\n///|\ntest \"invalidation fuzzing with coverage\" {\n  let rnd = @quickcheck/splitmix.new()\n  let tested_count : Map[String, Int] = {}\n  let rejected_count : Map[String, Int] = {}\n  let strategy_names = [\n    \"FuncIdxOOB\", \"TypeIdxOOB\", \"LocalIdxOOB\", \"GlobalIdxOOB\", \"LabelIdxOOB\", \"TableIdxOOB\",\n    \"MemIdxOOB\", \"DataIdxOOB\", \"ElemIdxOOB\", \"TagIdxOOB\", \"NumTypeSwap\", \"NullabilityFlip\",\n    \"HeapTypeSwap\", \"InstructionTypeMismatch\", \"BlockTypeMismatch\", \"DropInsertion\",\n    \"BlockCorruption\", \"SignatureCorruption\", \"GlobalInitMismatch\", \"TableInitMismatch\",\n  ]\n  for s in strategy_names {\n    tested_count[s] = 0\n    rejected_count[s] = 0\n  }\n  for _ in 0..<200 {\n    let ctx = gen_ctx_new(200, rnd=Some(rnd))\n    let (_, valid_module) = match gen_module_valid_full(ctx) {\n      Ok(t) => t\n      Err(_) => continue\n    }\n    if validate_module(valid_module) is Err(_) {\n      continue\n    }\n    let results = fuzz_all_strategies_with_coverage(valid_module)\n    for result in results {\n      let (strategy_name, was_tested, passed) = result\n      if was_tested {\n        tested_count[strategy_name] = tested_count\n          .get(strategy_name)\n          .unwrap_or(0) +\n          1\n        if passed {\n          rejected_count[strategy_name] = rejected_count\n            .get(strategy_name)\n            .unwrap_or(0) +\n            1\n        }\n      }\n    }\n  }\n  let problems : Array[String] = []\n  for s in strategy_names {\n    let tested = tested_count.get(s).unwrap_or(0)\n    let rejected = rejected_count.get(s).unwrap_or(0)\n    if tested >= 10 {\n      let reject_rate = rejected * 100 / tested\n      if reject_rate < 80 {\n        problems.push(\n          \"\\{s}: only \\{reject_rate}% rejected (\\{rejected}/\\{tested})\",\n        )\n      }\n    }\n  }\n  if problems.length() > 0 {\n    fail(\n      \"Strategies with low rejection rate (potential validator bugs):\\n  \" +\n      problems.iter().intersperse(\"\\n  \").fold(init=\"\", fn(a, b) { a + b }),\n    )\n  }\n}\n\n///|\ntest \"HeapTypeSwap transformer actually modifies heap types\" {\n  // Test that each swap produces a different heap type\n  let swaps : Array[(HeapType, HeapType)] = [\n    (\n      AbsHeapTypeHeapType(FuncAbsHeapType),\n      AbsHeapTypeHeapType(ExternAbsHeapType),\n    ),\n    (\n      AbsHeapTypeHeapType(ExternAbsHeapType),\n      AbsHeapTypeHeapType(FuncAbsHeapType),\n    ),\n    (AbsHeapTypeHeapType(AnyAbsHeapType), AbsHeapTypeHeapType(FuncAbsHeapType)),\n    (AbsHeapTypeHeapType(EqAbsHeapType), AbsHeapTypeHeapType(ExternAbsHeapType)),\n    (AbsHeapTypeHeapType(I31AbsHeapType), AbsHeapTypeHeapType(FuncAbsHeapType)),\n    (\n      AbsHeapTypeHeapType(StructAbsHeapType),\n      AbsHeapTypeHeapType(ExternAbsHeapType),\n    ),\n    (\n      AbsHeapTypeHeapType(ArrayAbsHeapType),\n      AbsHeapTypeHeapType(FuncAbsHeapType),\n    ),\n    (AbsHeapTypeHeapType(ExnAbsHeapType), AbsHeapTypeHeapType(AnyAbsHeapType)),\n  ]\n  for pair in swaps {\n    let (before, after) = pair\n    assert_not_eq(before, after)\n  }\n}\n\n///|\ntest \"RefType AbsHeapTypeRefType swaps produce different values\" {\n  let swaps : Array[(RefType, RefType)] = [\n    (AbsHeapTypeRefType(FuncAbsHeapType), AbsHeapTypeRefType(ExternAbsHeapType)),\n    (AbsHeapTypeRefType(ExternAbsHeapType), AbsHeapTypeRefType(FuncAbsHeapType)),\n    (AbsHeapTypeRefType(AnyAbsHeapType), AbsHeapTypeRefType(FuncAbsHeapType)),\n    (AbsHeapTypeRefType(ExnAbsHeapType), AbsHeapTypeRefType(AnyAbsHeapType)),\n  ]\n  for pair in swaps {\n    let (before, after) = pair\n    assert_not_eq(before, after)\n  }\n}\n\n///|\ntest \"Exn to Any swap - verify these are actually different hierarchies\" {\n  // These should NOT be equal\n  assert_not_eq(\n    @lib.AbsHeapTypeRefType(ExnAbsHeapType),\n    AbsHeapTypeRefType(AnyAbsHeapType),\n  )\n  assert_not_eq(\n    @lib.AbsHeapTypeHeapType(ExnAbsHeapType),\n    AbsHeapTypeHeapType(AnyAbsHeapType),\n  )\n}\n","///|\npub trait Match {\n  matches(Self, Self, Env) -> Bool\n}\n\n///|\npub trait DeclMatch {\n  matches_decl(Self, Self, Env) -> Bool\n}\n\n///|\npub impl[T : Match] Match for Array[T] with matches(self, other, env) {\n  if self.length() != other.length() {\n    return false\n  }\n  for i in 0..<self.length() {\n    if !self[i].matches(other[i], env) {\n      return false\n    }\n  }\n  true\n}\n\n///|\npub impl Match for CompType with matches(self, other, env) {\n  match (self, other) {\n    // self <: other\n    (FuncCompType(p_self, r_self), FuncCompType(p_other, r_other)) =>\n      // contravariant in params, covariant in results\n      Match::matches(p_other, p_self, env) &&\n      Match::matches(r_self, r_other, env)\n    (StructCompType(fs0), StructCompType(fs1)) => Match::matches(fs0, fs1, env)\n    (ArrayCompType(f0), ArrayCompType(f1)) => Match::matches(f0, f1, env)\n    _ => false\n  }\n}\n\n///|\npub impl Match for ValType with matches(self, other, env) {\n  match (self, other) {\n    (RefTypeValType(r0), RefTypeValType(r1)) => Match::matches(r0, r1, env)\n    _ => self == other\n  }\n}\n\n///|\npub impl Match for RefType with matches(self, other, env) {\n  let ht0 = self.get_heap_type()\n  let ht1 = other.get_heap_type()\n\n  // Heap type compatibility (start with equality; extend later)\n  if !Match::matches(ht0, ht1, env) {\n    return false\n  }\n\n  // Nullability: non-null <: nullable\n  let n0 = self.is_nullable()\n  let n1 = other.is_nullable()\n  (!n0 && n1) || n0 == n1\n}\n\n///|\npub impl Match for FieldType with matches(self, other, env) {\n  let FieldType(st0, m0) = self\n  let FieldType(st1, m1) = other\n  match (m0, m1) {\n    (Const, Const) => Match::matches(st0, st1, env) // covariant\n    (Var, Var) => Match::matches(st0, st1, env) && Match::matches(st1, st0, env) // invariant\n    _ => false\n  }\n}\n\n///|\npub impl Match for StorageType with matches(self, other, env) {\n  match (self, other) {\n    (ValTypeStorageType(v1), ValTypeStorageType(v2)) =>\n      Match::matches(v1, v2, env)\n    (PackTypeStorageType(p1), PackTypeStorageType(p2)) => p1 == p2\n    _ => false\n  }\n}\n\n///|\npub impl Match for AbsHeapType with matches(self, other, _) {\n  if self == other {\n    return true\n  }\n  match (self, other) {\n    // eq <: any\n    (EqAbsHeapType, AnyAbsHeapType) => true\n\n    // i31/struct/array <: eq\n    (I31AbsHeapType, EqAbsHeapType) => true\n    (StructAbsHeapType, EqAbsHeapType) => true\n    (ArrayAbsHeapType, EqAbsHeapType) => true\n\n    // i31/struct/array <: any (transitive via eq)\n    (I31AbsHeapType, AnyAbsHeapType) => true\n    (StructAbsHeapType, AnyAbsHeapType) => true\n    (ArrayAbsHeapType, AnyAbsHeapType) => true\n\n    // none <: all internal types\n    (NoneAbsHeapType, AnyAbsHeapType) => true\n    (NoneAbsHeapType, EqAbsHeapType) => true\n    (NoneAbsHeapType, I31AbsHeapType) => true\n    (NoneAbsHeapType, StructAbsHeapType) => true\n    (NoneAbsHeapType, ArrayAbsHeapType) => true\n\n    // nofunc <: func\n    (NoFuncAbsHeapType, FuncAbsHeapType) => true\n\n    // noextern <: extern\n    (NoExternAbsHeapType, ExternAbsHeapType) => true\n\n    // noexn <: exn\n    (NoExnAbsHeapType, ExnAbsHeapType) => true\n    _ => false\n  }\n}\n\n///|\npub impl Match for HeapType with matches(self, other, env) {\n  let fuel = env.global_types.length() + 16\n  heaptype_matches_fuel(self, other, env, fuel)\n}\n\n///|\nfn heaptype_matches_fuel(\n  h1 : HeapType,\n  h2 : HeapType,\n  env : Env,\n  fuel : Int,\n) -> Bool {\n  if h1 == h2 {\n    return true\n  }\n  if fuel <= 0 {\n    return false\n  }\n  match (h1, h2) {\n    (AbsHeapTypeHeapType(a1), AbsHeapTypeHeapType(a2)) =>\n      Match::matches(a1, a2, env)\n\n    // Spec: defined type judgement\n    (DefTypeHeapType(dt1), DefTypeHeapType(dt2)) =>\n      deftype_matches_fuel(dt1, dt2, env, fuel - 1)\n\n    // typeidx/recidx unfold on either side\n    (HeapType(tidx), _) =>\n      match env.resolve_subtype(tidx) {\n        None => false\n        Some(st1) => subtype_as_heap_fuel(st1, h2, env, fuel - 1)\n      }\n    (_, HeapType(tidx)) => heap_vs_typeidx_fuel(h1, tidx, env, fuel - 1)\n\n    // deftype vs abs: use expansion-kind checks (struct/array/func → ...)\n    (DefTypeHeapType(dt), AbsHeapTypeHeapType(abs)) =>\n      deftype_matches_abs_fuel(dt, abs, env, fuel - 1)\n\n    // abs vs deftype: conservative (generally false in subtype direction)\n    (AbsHeapTypeHeapType(_), DefTypeHeapType(_)) => false\n  }\n}\n\n///|\nfn subtype_as_heap_fuel(\n  st : SubType,\n  target : HeapType,\n  env : Env,\n  fuel : Int,\n) -> Bool {\n  if fuel <= 0 {\n    return false\n  }\n  let (is_final, supers, ct) = match st {\n    CompTypeSubType(ct) => (false, [], ct)\n    SubType(is_final, supers, ct) => (is_final, supers, ct)\n  }\n\n  // 1) Direct shape match against abstract heap supertypes\n  match target {\n    AbsHeapTypeHeapType(abs) => {\n      if comptype_matches_abs(ct, abs) {\n        return true\n      }\n      if is_final {\n        return false\n      }\n    }\n    _ => if is_final { return false }\n  }\n\n  // 2) Chase declared supertypes\n  for tu in supers {\n    if heaptype_matches_fuel(HeapType(tu), target, env, fuel - 1) {\n      return true\n    }\n  }\n  false\n}\n\n///|\nfn comptype_matches_abs(ct : CompType, abs : AbsHeapType) -> Bool {\n  match ct {\n    StructCompType(_) =>\n      abs == StructAbsHeapType || abs == EqAbsHeapType || abs == AnyAbsHeapType\n    ArrayCompType(_) =>\n      abs == ArrayAbsHeapType || abs == EqAbsHeapType || abs == AnyAbsHeapType\n    FuncCompType(_, _) => abs == FuncAbsHeapType || abs == AnyAbsHeapType\n  }\n}\n\n///|\nfn heap_vs_typeidx_fuel(\n  h : HeapType,\n  target : TypeIdx,\n  env : Env,\n  fuel : Int,\n) -> Bool {\n  if fuel <= 0 {\n    return false\n  }\n  match h {\n    AbsHeapTypeHeapType(_) => false\n    HeapType(tidx1) =>\n      typeidx_leq_typeidx_fuel(tidx1, target, env, fuel - 1, [])\n    DefTypeHeapType(dt1) =>\n      match dt1.project() {\n        None => false\n        Some(st1) => {\n          let DefType(rt1, _) = dt1\n          let env1 = env_with_rectype(env, rt1)\n          match st1 {\n            CompTypeSubType(_) => false\n            SubType(is_final, supers, _) => {\n              if is_final {\n                return false\n              }\n              for tu in supers {\n                if typeidx_leq_typeidx_fuel(tu, target, env1, fuel - 1, []) {\n                  return true\n                }\n              }\n              false\n            }\n          }\n        }\n      }\n  }\n}\n\n///|\nfn deftype_matches_abs_fuel(\n  dt : DefType,\n  abs : AbsHeapType,\n  _env : Env,\n  fuel : Int,\n) -> Bool {\n  if fuel <= 0 {\n    return false\n  }\n\n  // let DefType(rt, _) = dt\n  // let env2 = env_with_rectype(env, rt)\n\n  match dt.project() {\n    None => false\n    Some(st) =>\n      match st.get_comptype() {\n        StructCompType(_) =>\n          abs == StructAbsHeapType ||\n          abs == EqAbsHeapType ||\n          abs == AnyAbsHeapType\n        ArrayCompType(_) =>\n          abs == ArrayAbsHeapType ||\n          abs == EqAbsHeapType ||\n          abs == AnyAbsHeapType\n        FuncCompType(_, _) => abs == FuncAbsHeapType || abs == AnyAbsHeapType\n      }\n  }\n}\n\n///|\nfn env_with_rectype(env : Env, rt : RecType) -> Env {\n  match rt {\n    SingleRecType(st) => env_add_rec_group(env, [st])\n    GroupRecType(sts) => env_add_rec_group(env, sts)\n  }\n}\n\n// Adjust this to your preferred stack API (immut/mut)\n\n///|\nfn env_add_rec_group(env : Env, group : Array[SubType]) -> Env {\n  let rs = env.rec_stack.copy()\n  rs.push(group)\n  Env::{\n    global_types: env.global_types,\n    rec_stack: rs,\n    funcs: env.funcs,\n    tables: env.tables,\n    mems: env.mems,\n    globals: env.globals,\n    elems: env.elems,\n    datas: env.datas,\n    tags: env.tags,\n    locals: env.locals,\n    labels: env.labels,\n    return_type: env.return_type,\n  }\n}\n\n///|\npub impl Match for DefType with matches(self, other, env) {\n  let fuel = env.global_types.length() + 16 // Int\n  deftype_matches_fuel(self, other, env, fuel)\n}\n\n///|\nfn deftype_matches_fuel(\n  dt1 : DefType,\n  dt2 : DefType,\n  env : Env,\n  fuel : Int,\n) -> Bool {\n  // clos_C(dt1) == clos_C(dt2)\n  if dt1 == dt2 {\n    return true\n  }\n  if fuel <= 0 {\n    return false\n  }\n\n  // Put dt1’s rectype in scope for any RecIdx references during unroll/chasing\n  let DefType(rt1, _) = dt1\n  let env1 = env_with_rectype(env, rt1)\n  match dt1.project() {\n    None => false\n    Some(st1) =>\n      match st1 {\n        CompTypeSubType(_) => false\n        SubType(is_final, supers, _) => {\n          // final types have no proper subtypes\n          if is_final {\n            return false\n          }\n          let ht2 = @lib.DefTypeHeapType(dt2)\n          for tu in supers {\n            // “typeuse*[i] matches heaptype deftype2”\n            if heaptype_matches_fuel(HeapType(tu), ht2, env1, fuel - 1) {\n              return true\n            }\n          }\n          false\n        }\n      }\n  }\n}\n\n///|\npub impl Match for Limits with matches(self, other, _) {\n  match (self, other) {\n    (I32Limits(n1, m1), I32Limits(n2, m2)) =>\n      limits_range_matches_u64(\n        n1.to_uint64(),\n        m1.map(fn(x) { x.to_uint64() }),\n        n2.to_uint64(),\n        m2.map(fn(x) { x.to_uint64() }),\n      )\n    (I64Limits(n1, m1), I64Limits(n2, m2)) =>\n      limits_range_matches_u64(n1, m1, n2, m2)\n    _ => false\n  }\n}\n\n// Implements: [n1..m1?] ≤ [n2..m2?]\n\n///|\nfn limits_range_matches_u64(\n  n1 : UInt64,\n  m1 : UInt64?,\n  n2 : UInt64,\n  m2 : UInt64?,\n) -> Bool {\n  // n1 >= n2\n  if n1 < n2 {\n    return false\n  }\n  match (m1, m2) {\n    // [n1..m1] ≤ [n2..m2] requires m1 <= m2\n    (Some(x1), Some(x2)) => x1 <= x2\n\n    // [n1..m1] ≤ [n2..∞] always (given n1>=n2)\n    (Some(_), None) => true\n\n    // [n1..∞] ≤ [n2..∞] ok\n    (None, None) => true\n\n    // [n1..∞] ≤ [n2..m2] impossible\n    (None, Some(_)) => false\n  }\n}\n\n///|\npub impl Match for TagType with matches(self, other, env) {\n  let TagType(a) = self\n  let TagType(b) = other\n  typeidx_leq_typeidx(a, b, env) && typeidx_leq_typeidx(b, a, env)\n}\n\n///|\nfn typeidx_leq_typeidx(a : TypeIdx, b : TypeIdx, env : Env) -> Bool {\n  let fuel = env.global_types.length() + 16\n  typeidx_leq_typeidx_fuel(a, b, env, fuel, [])\n}\n\n///|\nfn typeidx_leq_typeidx_fuel(\n  a : TypeIdx,\n  b : TypeIdx,\n  env : Env,\n  fuel : Int,\n  visited : Array[TypeIdx],\n) -> Bool {\n  if a == b {\n    return true\n  }\n  if fuel <= 0 {\n    return false\n  }\n\n  // cycle guard\n  for v in visited {\n    if v == a {\n      return false\n    }\n  }\n  match env.resolve_subtype(a) {\n    None => false\n    Some(st) =>\n      match st {\n        CompTypeSubType(_) => false\n        SubType(is_final, _, _) => {\n          if is_final {\n            return false\n          }\n          let visited2 = visited.copy()\n          visited2.push(a)\n          for s in st.super_types() {\n            if typeidx_leq_typeidx_fuel(s, b, env, fuel - 1, visited2) {\n              return true\n            }\n          }\n          false\n        }\n      }\n  }\n}\n\n///|\npub impl Match for MemType with matches(self, other, env) {\n  let MemType(l1) = self\n  let MemType(l2) = other\n  Match::matches(l1, l2, env)\n}\n\n///|\npub impl Match for GlobalType with matches(self, other, env) {\n  let GlobalType(v1, m1) = self\n  let GlobalType(v2, m2) = other\n\n  // Always: valtype1 ≤ valtype2\n  if !Match::matches(v1, v2, env) {\n    return false\n  }\n  match (m1, m2) {\n    // const ≤ const (covariant already checked)\n    (false, false) => true\n\n    // mut ≤ mut requires invariance\n    (true, true) => Match::matches(v2, v1, env)\n\n    // mixed mutability does not match\n    _ => false\n  }\n}\n\n///|\npub impl Match for TableType with matches(self, other, env) {\n  let TableType(rt1, lim1) = self\n  let TableType(rt2, lim2) = other\n  Match::matches(lim1, lim2, env) &&\n  Match::matches(rt1, rt2, env) &&\n  Match::matches(rt2, rt1, env)\n}\n\n///|\npub impl Match for ExternType with matches(self, other, env) {\n  match (self, other) {\n    (TagExternType(t1), TagExternType(t2)) => Match::matches(t1, t2, env)\n    (GlobalExternType(g1), GlobalExternType(g2)) => Match::matches(g1, g2, env)\n    (MemExternType(m1), MemExternType(m2)) => Match::matches(m1, m2, env)\n    (TableExternType(t1), TableExternType(t2)) => Match::matches(t1, t2, env)\n\n    // Spec says: func deftype1 ≤ func deftype2 iff deftype1 ≤ deftype2.\n    (FuncExternType(ti1), FuncExternType(ti2)) => {\n      // Optional: ensure both are actually function types\n      if env.resolve_functype(ti1) is None {\n        return false\n      }\n      if env.resolve_functype(ti2) is None {\n        return false\n      }\n      typeidx_leq_typeidx(ti1, ti2, env)\n    }\n    _ => false\n  }\n}\n\n// =============================================================================\n// AbsHeapType Tests\n// =============================================================================\n\n///|\ntest \"AbsHeapType: reflexivity\" {\n  let env = Env::new()\n  assert_true(Match::matches(@lib.AnyAbsHeapType, AnyAbsHeapType, env))\n  assert_true(Match::matches(@lib.EqAbsHeapType, EqAbsHeapType, env))\n  assert_true(Match::matches(@lib.I31AbsHeapType, I31AbsHeapType, env))\n  assert_true(Match::matches(@lib.StructAbsHeapType, StructAbsHeapType, env))\n  assert_true(Match::matches(@lib.ArrayAbsHeapType, ArrayAbsHeapType, env))\n  assert_true(Match::matches(@lib.FuncAbsHeapType, FuncAbsHeapType, env))\n  assert_true(Match::matches(@lib.ExternAbsHeapType, ExternAbsHeapType, env))\n  assert_true(Match::matches(@lib.NoneAbsHeapType, NoneAbsHeapType, env))\n  assert_true(Match::matches(@lib.NoFuncAbsHeapType, NoFuncAbsHeapType, env))\n  assert_true(\n    Match::matches(@lib.NoExternAbsHeapType, NoExternAbsHeapType, env),\n  )\n  assert_true(Match::matches(@lib.NoExnAbsHeapType, NoExnAbsHeapType, env))\n}\n\n///|\ntest \"AbsHeapType: eq <: any\" {\n  let env = Env::new()\n  assert_true(Match::matches(@lib.EqAbsHeapType, AnyAbsHeapType, env))\n  assert_false(Match::matches(@lib.AnyAbsHeapType, EqAbsHeapType, env))\n}\n\n///|\ntest \"AbsHeapType: i31/struct/array <: eq\" {\n  let env = Env::new()\n  assert_true(Match::matches(@lib.I31AbsHeapType, EqAbsHeapType, env))\n  assert_true(Match::matches(@lib.StructAbsHeapType, EqAbsHeapType, env))\n  assert_true(Match::matches(@lib.ArrayAbsHeapType, EqAbsHeapType, env))\n\n  // reverse should not hold\n  assert_false(Match::matches(@lib.EqAbsHeapType, I31AbsHeapType, env))\n  assert_false(Match::matches(@lib.EqAbsHeapType, StructAbsHeapType, env))\n  assert_false(Match::matches(@lib.EqAbsHeapType, ArrayAbsHeapType, env))\n}\n\n///|\ntest \"AbsHeapType: none <: any\" {\n  let env = Env::new()\n  assert_true(Match::matches(@lib.NoneAbsHeapType, AnyAbsHeapType, env))\n  assert_false(Match::matches(@lib.AnyAbsHeapType, NoneAbsHeapType, env))\n}\n\n///|\ntest \"AbsHeapType: noX <: X (bottom types)\" {\n  let env = Env::new()\n  assert_true(Match::matches(@lib.NoFuncAbsHeapType, FuncAbsHeapType, env))\n  assert_true(Match::matches(@lib.NoExternAbsHeapType, ExternAbsHeapType, env))\n  assert_true(Match::matches(@lib.NoExnAbsHeapType, ExnAbsHeapType, env))\n\n  // reverse should not hold\n  assert_false(Match::matches(@lib.FuncAbsHeapType, NoFuncAbsHeapType, env))\n  assert_false(Match::matches(@lib.ExternAbsHeapType, NoExternAbsHeapType, env))\n  assert_false(Match::matches(@lib.ExnAbsHeapType, NoExnAbsHeapType, env))\n}\n\n///|\ntest \"AbsHeapType: unrelated types don't match\" {\n  let env = Env::new()\n  assert_false(Match::matches(@lib.FuncAbsHeapType, ExternAbsHeapType, env))\n  assert_false(Match::matches(@lib.ExternAbsHeapType, FuncAbsHeapType, env))\n  assert_false(Match::matches(@lib.I31AbsHeapType, FuncAbsHeapType, env))\n  assert_false(Match::matches(@lib.StructAbsHeapType, ArrayAbsHeapType, env))\n}\n\n// =============================================================================\n// Limits Tests\n// =============================================================================\n\n///|\ntest \"Limits: reflexivity\" {\n  let env = Env::new()\n  let l1 = @lib.I32Limits(10, Some(100))\n  let l2 = @lib.I64Limits(10UL, Some(100UL))\n  assert_true(Match::matches(l1, l1, env))\n  assert_true(Match::matches(l2, l2, env))\n}\n\n///|\ntest \"Limits: n1 >= n2 required\" {\n  let env = Env::new()\n  // [10..100] matches [5..100] (10 >= 5)\n  assert_true(\n    Match::matches(@lib.I32Limits(10, Some(100)), I32Limits(5, Some(100)), env),\n  )\n  // [5..100] does not match [10..100] (5 < 10)\n  assert_false(\n    Match::matches(@lib.I32Limits(5, Some(100)), I32Limits(10, Some(100)), env),\n  )\n}\n\n///|\ntest \"Limits: m1 <= m2 required when both bounded\" {\n  let env = Env::new()\n  // [10..50] matches [10..100] (50 <= 100)\n  assert_true(\n    Match::matches(@lib.I32Limits(10, Some(50)), I32Limits(10, Some(100)), env),\n  )\n  // [10..100] does not match [10..50] (100 > 50)\n  assert_false(\n    Match::matches(@lib.I32Limits(10, Some(100)), I32Limits(10, Some(50)), env),\n  )\n}\n\n///|\ntest \"Limits: bounded matches unbounded\" {\n  let env = Env::new()\n  // [10..100] matches [10..∞]\n  assert_true(\n    Match::matches(@lib.I32Limits(10, Some(100)), I32Limits(10, None), env),\n  )\n}\n\n///|\ntest \"Limits: unbounded matches unbounded\" {\n  let env = Env::new()\n  assert_true(\n    Match::matches(@lib.I32Limits(10, None), I32Limits(10, None), env),\n  )\n  assert_true(Match::matches(@lib.I32Limits(10, None), I32Limits(5, None), env))\n}\n\n///|\ntest \"Limits: unbounded does not match bounded\" {\n  let env = Env::new()\n  // [10..∞] does not match [10..100]\n  assert_false(\n    Match::matches(@lib.I32Limits(10, None), I32Limits(10, Some(100)), env),\n  )\n}\n\n///|\ntest \"Limits: i32 vs i64 don't match\" {\n  let env = Env::new()\n  assert_false(\n    Match::matches(\n      @lib.I32Limits(10, Some(100)),\n      I64Limits(10UL, Some(100UL)),\n      env,\n    ),\n  )\n  assert_false(\n    Match::matches(\n      @lib.I64Limits(10UL, Some(100UL)),\n      I32Limits(10, Some(100)),\n      env,\n    ),\n  )\n}\n\n// =============================================================================\n// MemType Tests\n// =============================================================================\n\n///|\ntest \"MemType: delegates to limits\" {\n  let env = Env::new()\n  let m1 = @lib.MemType(I32Limits(1, Some(10)))\n  let m2 = @lib.MemType(I32Limits(1, Some(20)))\n  let m3 = @lib.MemType(I32Limits(2, Some(10)))\n  assert_true(Match::matches(m1, m1, env))\n  assert_true(Match::matches(m1, m2, env)) // [1..10] <: [1..20]\n  assert_false(Match::matches(m2, m1, env)) // [1..20] not <: [1..10]\n  assert_false(Match::matches(m1, m3, env)) // Match::matches(min, \n}\n\n// =============================================================================\n// StorageType Tests\n// =============================================================================\n\n///|\ntest \"StorageType: equality based\" {\n  let env = Env::new()\n  // Assuming storage types like PackTypeStorageType(I8PackType), PackTypeStorageType(I16PackType), ValTypeStorageType\n  let s1 = @lib.PackTypeStorageType(I8PackType)\n  let s2 = @lib.PackTypeStorageType(I16PackType)\n  assert_true(Match::matches(s1, s1, env))\n  assert_true(Match::matches(s2, s2, env))\n  assert_false(Match::matches(s1, s2, env))\n}\n\n// =============================================================================\n// FieldType Tests\n// =============================================================================\n\n///|\ntest \"FieldType: const is covariant\" {\n  let env = Env::new()\n  let st = @lib.PackTypeStorageType(I8PackType)\n  let f1 = @lib.FieldType(st, Const)\n  let f2 = @lib.FieldType(st, Const)\n  assert_true(Match::matches(f1, f2, env))\n}\n\n///|\ntest \"FieldType: var is invariant\" {\n  let env = Env::new()\n  let st = @lib.PackTypeStorageType(I8PackType)\n  let f1 = @lib.FieldType(st, Var)\n  let f2 = @lib.FieldType(st, Var)\n  assert_true(Match::matches(f1, f2, env))\n}\n\n///|\ntest \"FieldType: const vs var don't match\" {\n  let env = Env::new()\n  let st = @lib.PackTypeStorageType(I8PackType)\n  let const_field = @lib.FieldType(st, Const)\n  let var_field = @lib.FieldType(st, Var)\n  assert_false(Match::matches(const_field, var_field, env))\n  assert_false(Match::matches(var_field, const_field, env))\n}\n\n// =============================================================================\n// ValType Tests\n// =============================================================================\n\n///|\ntest \"ValType: primitive types use equality\" {\n  let env = Env::new()\n  assert_true(\n    Match::matches(\n      @lib.NumTypeValType(I32NumType),\n      NumTypeValType(I32NumType),\n      env,\n    ),\n  )\n  assert_true(\n    Match::matches(\n      @lib.NumTypeValType(I64NumType),\n      NumTypeValType(I64NumType),\n      env,\n    ),\n  )\n  assert_true(\n    Match::matches(\n      @lib.NumTypeValType(F32NumType),\n      NumTypeValType(F32NumType),\n      env,\n    ),\n  )\n  assert_true(\n    Match::matches(\n      @lib.NumTypeValType(F64NumType),\n      NumTypeValType(F64NumType),\n      env,\n    ),\n  )\n  assert_false(\n    Match::matches(\n      @lib.NumTypeValType(I32NumType),\n      NumTypeValType(I64NumType),\n      env,\n    ),\n  )\n  assert_false(\n    Match::matches(\n      @lib.NumTypeValType(F32NumType),\n      NumTypeValType(F64NumType),\n      env,\n    ),\n  )\n}\n\n///|\ntest \"ValType: ref types delegate to RefType matching\" {\n  let env = Env::new()\n  // (ref null any) matches (ref null any)\n  let rt1 = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  let rt2 = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  assert_true(\n    Match::matches(@lib.RefTypeValType(rt1), RefTypeValType(rt2), env),\n  )\n}\n\n// =============================================================================\n// RefType Tests\n// =============================================================================\n\n///|\ntest \"RefType: nullability - non-null <: nullable\" {\n  let env = Env::new()\n  let non_null = @lib.HeapTypeRefType(\n    false,\n    AbsHeapTypeHeapType(AnyAbsHeapType),\n  )\n  let nullable = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  assert_true(Match::matches(non_null, nullable, env))\n  assert_false(Match::matches(nullable, non_null, env))\n}\n\n///|\ntest \"RefType: same nullability\" {\n  let env = Env::new()\n  let null1 = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  let null2 = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  let non1 = @lib.HeapTypeRefType(false, AbsHeapTypeHeapType(AnyAbsHeapType))\n  let non2 = @lib.HeapTypeRefType(false, AbsHeapTypeHeapType(AnyAbsHeapType))\n  assert_true(Match::matches(null1, null2, env))\n  assert_true(Match::matches(non1, non2, env))\n}\n\n///|\ntest \"RefType: heap type subtyping with nullability\" {\n  let env = Env::new()\n  // (ref null eq) <: (ref null any)\n  let ref_eq = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType))\n  let ref_any = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  assert_true(Match::matches(ref_eq, ref_any, env))\n  assert_false(Match::matches(ref_any, ref_eq, env))\n}\n\n///|\ntest \"RefType: non-null subtype matches nullable supertype\" {\n  let env = Env::new()\n  // (ref eq) <: (ref null any)\n  let ref_eq_nonnull = @lib.HeapTypeRefType(\n    false,\n    AbsHeapTypeHeapType(EqAbsHeapType),\n  )\n  let ref_any_null = @lib.HeapTypeRefType(\n    true,\n    AbsHeapTypeHeapType(AnyAbsHeapType),\n  )\n  assert_true(Match::matches(ref_eq_nonnull, ref_any_null, env))\n}\n\n// =============================================================================\n// HeapType Tests (wrapping AbsHeapType)\n// =============================================================================\n\n///|\ntest \"HeapType: abs heap type matching\" {\n  let env = Env::new()\n  let h1 = @lib.AbsHeapTypeHeapType(EqAbsHeapType)\n  let h2 = @lib.AbsHeapTypeHeapType(AnyAbsHeapType)\n  assert_true(Match::matches(h1, h2, env))\n  assert_false(Match::matches(h2, h1, env))\n}\n\n// =============================================================================\n// Array[T] Tests\n// =============================================================================\n\n///|\ntest \"Array: empty arrays match\" {\n  let env = Env::new()\n  let arr1 : Array[ValType] = []\n  let arr2 : Array[ValType] = []\n  assert_true(Match::matches(arr1, arr2, env))\n}\n\n///|\ntest \"Array: length mismatch\" {\n  let env = Env::new()\n  let arr1 = [@lib.NumTypeValType(I32NumType)]\n  let arr2 = [@lib.NumTypeValType(I32NumType), NumTypeValType(I64NumType)]\n  assert_false(Match::matches(arr1, arr2, env))\n}\n\n///|\ntest \"Array: element-wise matching\" {\n  let env = Env::new()\n  let arr1 = [@lib.NumTypeValType(I32NumType), NumTypeValType(I64NumType)]\n  let arr2 = [@lib.NumTypeValType(I32NumType), NumTypeValType(I64NumType)]\n  let arr3 = [@lib.NumTypeValType(I32NumType), NumTypeValType(F64NumType)]\n  assert_true(Match::matches(arr1, arr2, env))\n  assert_false(Match::matches(arr1, arr3, env))\n}\n\n// =============================================================================\n// CompType Tests\n// =============================================================================\n\n///|\ntest \"CompType: FuncCompType - contravariant params, covariant results\" {\n  let env = Env::new()\n\n  // For functions: (p1 -> r1) <: (p2 -> r2) iff p2 <: p1 and r1 <: r2\n  // Using ref types for subtyping examples\n  let ref_any = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)),\n  )\n  let ref_eq = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)),\n  )\n\n  // func(any) -> eq  <:  func(eq) -> any\n  // params: eq <: any (contravariant check)\n  // results: eq <: any (covariant check)\n  let f1 = @lib.FuncCompType([ref_any], [ref_eq])\n  let f2 = @lib.FuncCompType([ref_eq], [ref_any])\n  assert_true(Match::matches(f1, f2, env))\n  assert_false(Match::matches(f2, f1, env))\n}\n\n///|\ntest \"CompType: FuncCompType - reflexivity\" {\n  let env = Env::new()\n  let f = @lib.FuncCompType([NumTypeValType(I32NumType)], [\n    NumTypeValType(I64NumType),\n  ])\n  assert_true(Match::matches(f, f, env))\n}\n\n///|\ntest \"CompType: FuncCompType - param count mismatch\" {\n  let env = Env::new()\n  let f1 = @lib.FuncCompType([NumTypeValType(I32NumType)], [])\n  let f2 = @lib.FuncCompType(\n    [NumTypeValType(I32NumType), NumTypeValType(I64NumType)],\n    [],\n  )\n  assert_false(Match::matches(f1, f2, env))\n}\n\n///|\ntest \"CompType: StructCompType - field matching\" {\n  let env = Env::new()\n  let s1 = @lib.StructCompType([\n    FieldType(PackTypeStorageType(I8PackType), Const),\n  ])\n  let s2 = @lib.StructCompType([\n    FieldType(PackTypeStorageType(I8PackType), Const),\n  ])\n  let s3 = @lib.StructCompType([\n    FieldType(PackTypeStorageType(I16PackType), Const),\n  ])\n  assert_true(Match::matches(s1, s2, env))\n  assert_false(Match::matches(s1, s3, env))\n}\n\n///|\ntest \"CompType: ArrayCompType - field matching\" {\n  let env = Env::new()\n  let a1 = @lib.ArrayCompType(FieldType(PackTypeStorageType(I8PackType), Const))\n  let a2 = @lib.ArrayCompType(FieldType(PackTypeStorageType(I8PackType), Const))\n  let a3 = @lib.ArrayCompType(FieldType(PackTypeStorageType(I8PackType), Var))\n  assert_true(Match::matches(a1, a2, env))\n  assert_false(Match::matches(a1, a3, env))\n}\n\n///|\ntest \"CompType: different kinds don't match\" {\n  let env = Env::new()\n  let func = @lib.FuncCompType([], [])\n  let struct_ = @lib.StructCompType([])\n  let array = @lib.ArrayCompType(\n    FieldType(PackTypeStorageType(I8PackType), Const),\n  )\n  assert_false(Match::matches(func, struct_, env))\n  assert_false(Match::matches(struct_, array, env))\n  assert_false(Match::matches(array, func, env))\n}\n\n// =============================================================================\n// GlobalType Tests\n// =============================================================================\n\n///|\ntest \"GlobalType: const is covariant\" {\n  let env = Env::new()\n  let ref_eq = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)),\n  )\n  let ref_any = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)),\n  )\n  let g1 = @lib.GlobalType(ref_eq, false) // const\n  let g2 = @lib.GlobalType(ref_any, false) // const\n\n  // (const eq) <: (const any)\n  assert_true(Match::matches(g1, g2, env))\n  assert_false(Match::matches(g2, g1, env))\n}\n\n///|\ntest \"GlobalType: mut is invariant\" {\n  let env = Env::new()\n  let ref_eq = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)),\n  )\n  let ref_any = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)),\n  )\n  let g1 = @lib.GlobalType(ref_eq, true) // mut\n  let g2 = @lib.GlobalType(ref_any, true) // mut\n\n  // (mut eq) does not match (mut any) - invariant\n  assert_false(Match::matches(g1, g2, env))\n  assert_false(Match::matches(g2, g1, env))\n}\n\n///|\ntest \"GlobalType: mut self-match\" {\n  let env = Env::new()\n  let g = @lib.GlobalType(NumTypeValType(I32NumType), true)\n  assert_true(Match::matches(g, g, env))\n}\n\n///|\ntest \"GlobalType: const vs mut don't match\" {\n  let env = Env::new()\n  let const_g = @lib.GlobalType(NumTypeValType(I32NumType), false)\n  let mut_g = @lib.GlobalType(NumTypeValType(I32NumType), true)\n  assert_false(Match::matches(const_g, mut_g, env))\n  assert_false(Match::matches(mut_g, const_g, env))\n}\n\n// =============================================================================\n// TableType Tests\n// =============================================================================\n\n///|\ntest \"TableType: limits and reftype must match\" {\n  let env = Env::new()\n  let rt = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  let t1 = @lib.TableType(rt, I32Limits(0, Some(100)))\n  let t2 = @lib.TableType(rt, I32Limits(0, Some(200)))\n\n  // limits: [0..100] <: [0..200]\n  // reftype must be invariant\n  assert_true(Match::matches(t1, t2, env))\n}\n\n///|\ntest \"TableType: reftype is invariant\" {\n  let env = Env::new()\n  let rt_func = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  let rt_any = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  let limits = @lib.I32Limits(0, Some(100))\n  let t1 = @lib.TableType(rt_func, limits)\n  let t2 = @lib.TableType(rt_any, limits)\n\n  // Even though func might be a subtype, table element type is invariant\n  assert_false(Match::matches(t1, t2, env))\n  assert_false(Match::matches(t2, t1, env))\n}\n\n// =============================================================================\n// TagType Tests\n// =============================================================================\n\n///|\ntest \"TagType: requires bidirectional typeidx matching\" {\n  let env = Env::new()\n  // Assuming typeidx 0 exists and matches itself\n  let t1 = @lib.TagType(TypeIdx(0))\n  let t2 = @lib.TagType(TypeIdx(0))\n  assert_true(Match::matches(t1, t2, env))\n}\n\n// =============================================================================\n// ExternType Tests\n// =============================================================================\n\n///|\ntest \"ExternType: different kinds don't match\" {\n  let env = Env::new()\n  let mem = @lib.MemExternType(MemType(I32Limits(1, None)))\n  let global = @lib.GlobalExternType(\n    GlobalType(NumTypeValType(I32NumType), false),\n  )\n  assert_false(Match::matches(mem, global, env))\n  assert_false(Match::matches(global, mem, env))\n}\n\n///|\ntest \"ExternType: MemExternType delegates to MemType\" {\n  let env = Env::new()\n  let m1 = @lib.MemExternType(MemType(I32Limits(1, Some(10))))\n  let m2 = @lib.MemExternType(MemType(I32Limits(1, Some(20))))\n  assert_true(Match::matches(m1, m2, env))\n  assert_false(Match::matches(m2, m1, env))\n}\n\n///|\ntest \"ExternType: GlobalExternType delegates to GlobalType\" {\n  let env = Env::new()\n  let g1 = @lib.GlobalExternType(GlobalType(NumTypeValType(I32NumType), false))\n  let g2 = @lib.GlobalExternType(GlobalType(NumTypeValType(I32NumType), false))\n  assert_true(Match::matches(g1, g2, env))\n}\n\n///|\ntest \"ExternType: TableExternType delegates to TableType\" {\n  let env = Env::new()\n  let rt = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  let t1 = @lib.TableExternType(TableType(rt, I32Limits(0, Some(10))))\n  let t2 = @lib.TableExternType(TableType(rt, I32Limits(0, Some(10))))\n  assert_true(Match::matches(t1, t2, env))\n}\n\n// =============================================================================\n// Edge Cases & Integration Tests\n// =============================================================================\n\n///|\ntest \"transitive subtyping: i31 <: eq <: any\" {\n  let env = Env::new()\n  // i31 <: eq\n  assert_true(Match::matches(@lib.I31AbsHeapType, EqAbsHeapType, env))\n  // eq <: any\n  assert_true(Match::matches(@lib.EqAbsHeapType, AnyAbsHeapType, env))\n  // i31 <: any (transitively, though not directly in AbsHeapType.matches)\n  // This should work through HeapType matching\n  let h_i31 = @lib.AbsHeapTypeHeapType(I31AbsHeapType)\n  let h_any = @lib.AbsHeapTypeHeapType(AnyAbsHeapType)\n  assert_true(Match::matches(h_i31, h_any, env))\n}\n\n///|\ntest \"complex function type subtyping\" {\n  let env = Env::new()\n\n  // func(ref null any, ref null any) -> (ref null eq)\n  // <:\n  // func(ref null eq, ref null eq) -> (ref null any)\n  let ref_any = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)),\n  )\n  let ref_eq = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)),\n  )\n  let f1 = @lib.FuncCompType([ref_any, ref_any], [ref_eq])\n  let f2 = @lib.FuncCompType([ref_eq, ref_eq], [ref_any])\n  assert_true(Match::matches(f1, f2, env))\n}\n\n///|\ntest \"nested ref type in struct field\" {\n  let env = Env::new()\n\n  // const field with ref type - covariant\n  let ref_eq = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType))\n  let ref_any = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  let st_eq = @lib.ValTypeStorageType(RefTypeValType(ref_eq))\n  let st_any = @lib.ValTypeStorageType(RefTypeValType(ref_any))\n  let f1 = @lib.FieldType(st_eq, Const)\n  let f2 = @lib.FieldType(st_any, Const)\n  assert_true(Match::matches(f1, f2, env))\n  assert_false(Match::matches(f2, f1, env))\n}\n","///|\npub struct TcState {\n  env : Env\n  stack : Array[ValType]\n  reachable : Bool\n}\n\n///|\npub impl Show for TcState with output(self, logger) {\n  logger.write_string(\"TcState {\\n\")\n  logger.write_string(\"  env : \")\n  self.env.output(logger)\n  logger.write_string(\"\\n  stack : \")\n  self.stack.output(logger)\n  logger.write_string(\"\\n  reachable : \")\n  self.reachable.output(logger)\n  logger.write_string(\"\\n}\")\n}\n\n///|\npub type TcResult = Result[TcState, String]\n\n///|\npub trait Typecheck {\n  typecheck(Self, TcState) -> Result[TcState, String]\n}\n\n///|\nfn empty_env() -> Env {\n  Env::new()\n}\n\n///|\nfn TcState::with_stack(st : TcState, stack : Array[ValType]) -> TcState {\n  TcState::{ ..st, stack, }\n}\n\n///|\nfn TcState::set_unreachable(st : TcState) -> TcState {\n  TcState::{ ..st, reachable: false }\n}\n\n///|\nfn TcState::push1(st : TcState, vt : ValType) -> TcState {\n  let s = st.stack.copy()\n  s.push(vt)\n  st.with_stack(s)\n}\n\n///|\nfn TcState::pop_ref_or_bot(st : TcState) -> Result[(TcState, RefType?), String] {\n  match st.pop1() {\n    Err(e) => Err(e)\n    Ok((st1, v)) =>\n      match v {\n        BotValType => Ok((st1, None)) // unknown ref type, but acceptable\n        RefTypeValType(rt) => Ok((st1, Some(rt)))\n        _ => Err(\"expected a reference operand\")\n      }\n  }\n}\n\n///|\nfn TcState::check_branch_args_present(\n  st : TcState,\n  l : LabelIdx,\n) -> Result[Array[ValType], String] {\n  match st.env.get_label_types(l) {\n    None => Err(\"invalid label index\")\n    Some(ts) => Ok(ts)\n  }\n}\n\n///|\nfn TcState::pop1(st : TcState) -> Result[(TcState, ValType), String] {\n  if !st.reachable {\n    // polymorphic stack when unreachable (spec “bot” behavior)\n    return Ok((st, BotValType))\n  }\n  let s = st.stack.copy()\n  match s.pop() {\n    None => Err(\"stack underflow\")\n    Some(v) => Ok((st.with_stack(s), v))\n  }\n}\n\n///|\nfn TcState::pop_expect(st : TcState, expected : ValType) -> TcResult {\n  match st.pop1() {\n    Err(e) => Err(e)\n    Ok((st2, actual)) => {\n      if !st.reachable {\n        return Ok(st2)\n      }\n      if Match::matches(actual, expected, st.env) {\n        Ok(st2)\n      } else {\n        Err(\"type mismatch\")\n      }\n    }\n  }\n}\n\n///|\nfn typecheck_drop(st : TcState) -> TcResult {\n  match st.pop1() {\n    Err(e) => Err(e)\n    Ok((st2, _)) => Ok(st2)\n  }\n}\n\n///|\nfn TcState::push_types(st : TcState, ts : Array[ValType]) -> TcState {\n  let mut out = st\n  for t in ts {\n    out = out.push1(t)\n  }\n  out\n}\n\n///|\nfn TcState::pop_types(st : TcState, ts : Array[ValType]) -> TcResult {\n  let mut cur = st\n  for t in ts.rev_iter() {\n    cur = match cur.pop_expect(t) {\n      Err(e) => return Err(e)\n      Ok(s) => s\n    }\n  }\n  Ok(cur)\n}\n\n///|\nfn TcState::mem_at_of(st : TcState, mem : MemIdx) -> Result[ValType, String] {\n  match st.env.get_memtype(mem) {\n    None => Err(\"invalid memory index\")\n    Some(MemType(lim)) => Ok(lim.addr_valtype())\n  }\n}\n\n///|\nfn expect_ref_null_heaptype(v : ValType) -> Result[HeapType, String] {\n  match v {\n    RefTypeValType(rt) =>\n      match rt {\n        HeapTypeRefType(true, ht) => Ok(ht)\n        HeapTypeRefType(false, _) =>\n          Err(\"expected (ref null ht), got non-null ref\")\n        AbsHeapTypeRefType(_) =>\n          Err(\"expected (ref null ht), got abstract ref type\")\n      }\n    _ => Err(\"expected reference type\")\n  }\n}\n\n///|\nfn pop_types_rev(st : TcState, ts : Array[ValType]) -> TcResult {\n  let mut st = st\n  for t in ts.rev_iter() {\n    st = match st.pop_expect(t) {\n      Err(t) => return Err(t)\n      Ok(t) => t\n    }\n  }\n  Ok(st)\n}\n\n///|\npub impl Typecheck for Expr with typecheck(self, st0) {\n  let Expr(instrs) = self\n  let mut st = st0\n  for ins in instrs {\n    match Typecheck::typecheck(ins, st) {\n      Ok(stp) => st = stp\n      Err(err) => return Err(err)\n    }\n  }\n  Ok(st)\n}\n\n///|\nfn typecheck_select_typed(st : TcState, ts : Array[ValType]) -> TcResult {\n  if Validate::validate(ts, st.env) is Err(t) {\n    return Err(\"invalid select type annotation: \" + t)\n  }\n\n  // condition\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match pop_types_rev(st1, ts) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match pop_types_rev(st2, ts) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // push ts\n  let mut out = st3\n  for t in ts {\n    out = out.push1(t)\n  }\n  Ok(out)\n}\n\n///|\nfn typecheck_select_untyped(st : TcState) -> TcResult {\n  // pop condition (i32)\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop second operand\n  let (st2, t2) = match st1.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n\n  // pop first operand\n  let (st3, t1) = match st2.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n\n  // unreachable: stack is polymorphic, result type can be bot\n  if !st.reachable {\n    return Ok(st3.push1(BotValType))\n  }\n\n  // reachable: operands must have the same type (mutual match)\n  let same = Match::matches(t1, t2, st.env) && Match::matches(t2, t1, st.env)\n  if !same {\n    return Err(\"select requires both operands to have the same type\")\n  }\n  Ok(st3.push1(t1))\n}\n\n///|\nfn typecheck_local_get(st : TcState, idx : LocalIdx) -> TcResult {\n  match st.env.get_local_type(idx) {\n    None => Err(\"invalid local index\")\n    Some(vt) => Ok(st.push1(vt))\n  }\n}\n\n///|\nfn typecheck_local_set(st : TcState, idx : LocalIdx) -> TcResult {\n  match st.env.get_local_type(idx) {\n    None => Err(\"invalid local index\")\n    Some(vt) => st.pop_expect(vt)\n  }\n}\n\n///|\nfn typecheck_local_tee(st : TcState, idx : LocalIdx) -> TcResult {\n  match st.env.get_local_type(idx) {\n    None => Err(\"invalid local index\")\n    Some(vt) =>\n      // tee pops vt then pushes vt\n      match st.pop_expect(vt) {\n        Err(e) => Err(e)\n        Ok(st2) => Ok(st2.push1(vt))\n      }\n  }\n}\n\n///|\nfn typecheck_global_get(st : TcState, idx : GlobalIdx) -> TcResult {\n  match st.env.get_global_type(idx) {\n    None => Err(\"invalid global index\")\n    Some(GlobalType(vt, _mut)) => Ok(st.push1(vt))\n  }\n}\n\n///|\nfn typecheck_global_set(st : TcState, idx : GlobalIdx) -> TcResult {\n  match st.env.get_global_type(idx) {\n    None => Err(\"invalid global index\")\n    Some(GlobalType(vt, is_mut)) => {\n      if !is_mut {\n        return Err(\"global.set on immutable global\")\n      }\n      st.pop_expect(vt)\n    }\n  }\n}\n\n// table.get x : [i32] -> [t]\n\n///|\nfn typecheck_table_get(st : TcState, idx : TableIdx) -> TcResult {\n  let TableType(rt, _) = match st.env.get_table_type(idx) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n  let st1 = match st.pop_expect(i32_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(ref_valtype(rt)))\n}\n\n// table.set x : [i32, t] -> []\n\n///|\nfn typecheck_table_set(st : TcState, idx : TableIdx) -> TcResult {\n  let TableType(rt, _) = match st.env.get_table_type(idx) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n\n  // pop value (t)\n  let st1 = match st.pop_expect(ref_valtype(rt)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop index (i32)\n  let st2 = match st1.pop_expect(i32_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2)\n}\n\n// table.size x : [] -> [i32]\n\n///|\nfn typecheck_table_size(st : TcState, idx : TableIdx) -> TcResult {\n  match st.env.get_table_type(idx) {\n    None => Err(\"invalid table index\")\n    Some(_) => Ok(st.push1(i32_valtype()))\n  }\n}\n\n// table.grow x : [t, i32] -> [i32]\n\n///|\nfn typecheck_table_grow(st : TcState, idx : TableIdx) -> TcResult {\n  let TableType(rt, _) = match st.env.get_table_type(idx) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n\n  // pop delta (i32) — top of stack\n  let st1 = match st.pop_expect(i32_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop init value (t)\n  let st2 = match st1.pop_expect(ref_valtype(rt)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(i32_valtype()))\n}\n\n///|\nfn typecheck_br(st : TcState, l : LabelIdx) -> TcResult {\n  let ts = match st.env.get_label_types(l) {\n    None => return Err(\"invalid label index\")\n    Some(x) => x\n  }\n  let st1 = match st.pop_types(ts) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.set_unreachable())\n}\n\n///|\nfn typecheck_block(st : TcState, bt : BlockType, body : Expr) -> TcResult {\n  let (params, results) = match st.env.expand_blocktype(bt) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n\n  // Entry stack height after consuming params\n  let st1 = match st.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let base_len = st1.stack.length()\n\n  // Typecheck body with label = results\n  let env2 = st1.env.with_label(results)\n  let st_body0 = TcState::{ ..st1, env: env2 }\n  let st_body = match Typecheck::typecheck(body, st_body0) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // If reachable, enforce results on top\n  let st2 = if st_body.reachable {\n    match st_body.pop_types(results) {\n      Err(e) => return Err(e)\n      Ok(s) => s\n    }\n  } else {\n    st_body\n  }\n\n  // Now drop any extra stack above base_len (polymorphic details omitted for now)\n  let s = st2.stack.copy()\n  while s.length() > base_len {\n    // safe and ignorable because > base_len\n    ignore(s.pop())\n  }\n  let out = TcState::{ ..st, stack: s }\n  Ok( // reachability after block is same as entry unless you model merges\n    out.push_types(results),\n  )\n}\n\n///|\nfn typecheck_if(\n  st : TcState,\n  bt : BlockType,\n  then_instrs : Array[Instruction],\n  else_instrs_opt : Array[Instruction]?,\n) -> TcResult {\n  let (params, results) = match st.env.expand_blocktype(bt) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n\n  // pop condition\n  let st0 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop params\n  let st1 = match st0.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let base_len = st1.stack.length()\n  let else_instrs = match else_instrs_opt {\n    None => []\n    Some(xs) => xs\n  }\n\n  // typecheck then branch\n  let env_branch = st1.env.with_label(results)\n  let st_then0 = TcState::{ ..st1, env: env_branch }\n  let st_then = match Typecheck::typecheck(@lib.Expr(then_instrs), st_then0) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // typecheck else branch (same starting state!)\n  let st_else0 = TcState::{ ..st1, env: env_branch }\n  let st_else = match Typecheck::typecheck(@lib.Expr(else_instrs), st_else0) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // For each reachable branch: enforce results on top and truncate to base_len.\n  let norm_branch = fn(sb : TcState) -> Result[(Bool, Array[ValType]), String] {\n    let sb2 = if sb.reachable {\n      match sb.pop_types(results) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n    } else {\n      sb\n    }\n    let stack2 = sb2.stack.copy()\n    while stack2.length() > base_len {\n      ignore(stack2.pop())\n    }\n    Ok((sb2.reachable, stack2))\n  }\n  let (then_reach, then_stack) = match norm_branch(st_then) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let (else_reach, else_stack) = match norm_branch(st_else) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n\n  // Merge rule: if both reachable, stacks must be identical at merge point.\n  // If one unreachable, take the other.\n  let merged_stack = match (then_reach, else_reach) {\n    (true, true) => {\n      if then_stack != else_stack {\n        return Err(\"if branch stack mismatch\")\n      }\n      then_stack\n    }\n    (true, false) => then_stack\n    (false, true) => else_stack\n    (false, false) => st1.stack.copy() // both unreachable, base is fine\n  }\n  let merged_reachable = then_reach || else_reach\n  let out = TcState::{\n    env: st.env,\n    stack: merged_stack,\n    reachable: merged_reachable,\n  }\n  Ok(out.push_types(results))\n}\n\n///|\nfn typecheck_br_if(st : TcState, l : LabelIdx) -> TcResult {\n  let ts = match st.env.get_label_types(l) {\n    None => return Err(\"invalid label index\")\n    Some(x) => x\n  }\n\n  // Pop condition first\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // If unreachable, the stack is polymorphic; br_if is fine\n  if !st.reachable {\n    return Ok(st1)\n  }\n\n  // Check that branch arguments are present.\n  // Important: do NOT keep the popped state; this is only a type check.\n  let _ = match st1.pop_types(ts) {\n    Err(e) => return Err(e)\n    Ok(_) => ()\n  }\n\n  // Not-taken path continues with the stack after popping only the condition\n  Ok(st1)\n}\n\n///|\nfn typecheck_br_table(\n  st : TcState,\n  ls : Array[LabelIdx],\n  ldef : LabelIdx,\n) -> TcResult {\n  // pop selector\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let ts = match st.env.get_label_types(ldef) {\n    None => return Err(\"invalid default label index\")\n    Some(x) => x\n  }\n\n  // Every label in the table must have the same types as the default\n  for l in ls {\n    let ts_l = match st.env.get_label_types(l) {\n      None => return Err(\"invalid label index in br_table\")\n      Some(x) => x\n    }\n    let same = Match::matches(ts_l, ts, st.env) &&\n      Match::matches(ts, ts_l, st.env)\n    if !same {\n      return Err(\"br_table target labels have different argument types\")\n    }\n  }\n\n  // Pop the branch arguments (values that will be passed to the target label)\n  let st2 = match st1.pop_types(ts) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // br_table always branches - code after is unreachable\n  Ok({ ..st2, reachable: false })\n}\n\n///|\nfn typecheck_return(st : TcState) -> TcResult {\n  let ts = match st.env.return_type {\n    None => return Err(\"return used with no function return type in context\")\n    Some(t) => t\n  }\n  let st1 = match st.pop_types(ts) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.set_unreachable())\n}\n\n///|\nfn typecheck_call(st : TcState, fidx : FuncIdx) -> TcResult {\n  let FuncType(params, results) = match st.env.get_functype_by_funcidx(fidx) {\n    None => return Err(\"invalid function index\")\n    Some(ft) => ft\n  }\n  let st1 = match st.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push_types(results))\n}\n\n///|\nfn typecheck_call_indirect(\n  st : TcState,\n  tidx : TypeIdx,\n  tid : TableIdx,\n) -> TcResult {\n  // Resolve the function type from the type index\n  let FuncType(params, results) = match st.env.resolve_functype(tidx) {\n    None => return Err(\"call_indirect type index is not a function type\")\n    Some(ft) => ft\n  }\n\n  // Table must exist and have element type compatible with funcref\n  let TableType(elem_rt, _) = match st.env.get_table_type(tid) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n\n  // Require elem_rt <: funcref (spec requires the table contains functions)\n  let fr = funcref_valtype()\n  let elem_vt = @lib.RefTypeValType(elem_rt)\n  if !Match::matches(elem_vt, fr, st.env) {\n    return Err(\"call_indirect table element type is not funcref-compatible\")\n  }\n\n  // Pop table element index (i32)\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // Pop params\n  let st2 = match st1.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push_types(results))\n}\n\n///|\nfn typecheck_call_ref(st : TcState, tidx : TypeIdx) -> TcResult {\n  let FuncType(params, results) = match st.env.resolve_functype(tidx) {\n    None => return Err(\"call_ref type index is not a function type\")\n    Some(ft) => ft\n  }\n\n  // Pop funcref of type (ref null tidx)\n  // Your representation: HeapTypeRefType(nullable, HeapType(TypeIdx))\n  let fref = @lib.RefTypeValType(HeapTypeRefType(true, HeapType(tidx)))\n  let st1 = match st.pop_expect(fref) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // Pop params\n  let st2 = match st1.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push_types(results))\n}\n\n///|\nfn require_return_results(\n  st : TcState,\n  results : Array[ValType],\n) -> Result[Unit, String] {\n  match st.env.return_type {\n    None => Err(\"return_call used with no function return type in context\")\n    Some(rt) =>\n      if equals(results, rt) {\n        Ok(())\n      } else {\n        Err(\"tail call result mismatch\")\n      }\n  }\n}\n\n///|\nfn typecheck_return_call(st : TcState, fidx : FuncIdx) -> TcResult {\n  let FuncType(params, results) = match st.env.get_functype_by_funcidx(fidx) {\n    None => return Err(\"invalid function index\")\n    Some(ft) => ft\n  }\n  match require_return_results(st, results) {\n    Err(e) => return Err(e)\n    Ok(_) => ()\n  }\n  let st1 = match st.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.set_unreachable())\n}\n\n///|\nfn typecheck_return_call_indirect(\n  st : TcState,\n  tidx : TypeIdx,\n  t : TableIdx,\n) -> TcResult {\n  let FuncType(params, results) = match st.env.resolve_functype(tidx) {\n    None => return Err(\"return_call_indirect type index is not a function type\")\n    Some(ft) => ft\n  }\n  match require_return_results(st, results) {\n    Err(e) => return Err(e)\n    Ok(_) => ()\n  }\n  let TableType(elem_rt, _) = match st.env.get_table_type(t) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n\n  // elem_rt <: funcref\n  let fr = @lib.RefTypeValType(AbsHeapTypeRefType(FuncAbsHeapType))\n  let elem_vt = @lib.RefTypeValType(elem_rt)\n  if !Match::matches(elem_vt, fr, st.env) {\n    return Err(\n      \"return_call_indirect table element type is not funcref-compatible\",\n    )\n  }\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.set_unreachable())\n}\n\n///|\nfn typecheck_return_call_ref(st : TcState, tidx : TypeIdx) -> TcResult {\n  let FuncType(params, results) = match st.env.resolve_functype(tidx) {\n    None => return Err(\"return_call_ref type index is not a function type\")\n    Some(ft) => ft\n  }\n  match require_return_results(st, results) {\n    Err(e) => return Err(e)\n    Ok(_) => ()\n  }\n  let fref = @lib.RefTypeValType(HeapTypeRefType(true, HeapType(tidx)))\n  let st1 = match st.pop_expect(fref) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.set_unreachable())\n}\n\n///|\nfn expect_nullable_ref(v : ValType) -> Result[(HeapType, RefType), String] {\n  match v {\n    RefTypeValType(rt) => {\n      if !rt.is_nullable() {\n        return Err(\"expected a nullable reference type\")\n      }\n      Ok((rt.get_heap_type(), rt))\n    }\n    _ => Err(\"expected a reference type\")\n  }\n}\n\n///|\nfn typecheck_br_on_null(st : TcState, l : LabelIdx) -> TcResult {\n  let ts = match st.env.get_label_types(l) {\n    None => return Err(\"invalid label index\")\n    Some(x) => x\n  }\n\n  // Pop operand: must be exactly (ref null ht)\n  let (st1, v) = match st.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n  let ht = match expect_ref_null_heaptype(v) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  if Validate::validate(ht, st.env) is Err(t) {\n    return Err(\"Invalid heap type in br_on_null operand: \" + t)\n  }\n\n  // Branch target label has type t*\n  if st.reachable {\n    let _ = match st1.pop_types(ts) {\n      Err(e) => return Err(e)\n      Ok(_) => ()\n    }\n\n  }\n\n  // Fallthrough refines to non-null (ref ht)\n  Ok(st1.push1(RefTypeValType(HeapTypeRefType(false, ht))))\n}\n\n///|\nfn typecheck_br_on_non_null(st : TcState, l : LabelIdx) -> TcResult {\n  let label_ts = match st.env.get_label_types(l) {\n    None => return Err(\"invalid label index\")\n    Some(x) => x\n  }\n  let (st1, v) = match st.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n  let (ht, _rt_in) = match expect_nullable_ref(v) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  if Validate::validate(ht, st.env) is Err(t) {\n    return Err(\"Invalid heap type in br_on_non_null operand: \" + t)\n  }\n  if label_ts.length() == 0 {\n    return Err(\"br_on_non_null label type too short\")\n  }\n\n  // Label must end with NON-NULLABLE ref of same heap type\n  let non_null_rt = @lib.HeapTypeRefType(false, ht)\n  let want_last = @lib.RefTypeValType(non_null_rt)\n  let last = label_ts[label_ts.length() - 1]\n  if not(Match::matches(last, want_last, st.env)) {\n    return Err(\"br_on_non_null label must end with non-nullable ref type\")\n  }\n  if st.reachable {\n    let prefix = label_ts.sub(start=0, end=label_ts.length() - 1)\n    if st1.pop_types(prefix.to_array()) is Err(t) {\n      return Err(t)\n    }\n  }\n  Ok(st1)\n}\n\n///|\nfn typecheck_br_on_cast(\n  st : TcState,\n  l : LabelIdx,\n  op : CastOp,\n  ht1 : HeapType,\n  ht2 : HeapType,\n) -> TcResult {\n  let CastOp(n1, n2) = op\n  let rt1 = @lib.HeapTypeRefType(n1, ht1)\n  let rt2 = @lib.HeapTypeRefType(n2, ht2)\n  if Validate::validate(rt1, st.env) is Err(t) {\n    return Err(\"Invalid BrOnCast: \" + t)\n  }\n  if Validate::validate(rt2, st.env) is Err(t) {\n    return Err(\"Invalid BrOnCast: \" + t)\n  }\n  let label_ts = match st.check_branch_args_present(l) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  if label_ts.length() == 0 {\n    return Err(\"br_on_cast label type too short\")\n  }\n  let rt_label = match label_ts[label_ts.length() - 1] {\n    RefTypeValType(r) => r\n    _ => return Err(\"br_on_cast label must end with a reftype\")\n  }\n\n  // rt2 <: rt1 and rt2 <: rt_label\n  if !Match::matches(rt2, rt1, st.env) {\n    return Err(\"rt2 does not match rt1\")\n  }\n  if !Match::matches(rt2, rt_label, st.env) {\n    return Err(\"rt2 does not match label rt\")\n  }\n\n  // pop rt1\n  let st1 = match st.pop_expect(RefTypeValType(rt1)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  if st.reachable {\n    // Check label args excluding rt_label (because branch keeps rt2 / rt_label)\n    // Per spec, label is t* rt, so the remaining stack must have t*\n    let prefix = label_ts.sub(start=0, end=label_ts.length() - 1) // adjust if no slice\n    let _ = match st1.pop_types(prefix.to_array()) {\n      Err(e) => return Err(e)\n      Ok(_) => ()\n    }\n\n  }\n\n  // push (rt1 \\ rt2)\n  let rt_out = match diff(rt1, rt2) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  Ok(st1.push1(RefTypeValType(rt_out)))\n}\n\n///|\nfn typecheck_br_on_cast_fail(\n  st : TcState,\n  l : LabelIdx,\n  op : CastOp,\n  ht1 : HeapType,\n  ht2 : HeapType,\n) -> TcResult {\n  let CastOp(n1, n2) = op\n  let rt1 = @lib.HeapTypeRefType(n1, ht1)\n  let rt2 = @lib.HeapTypeRefType(n2, ht2)\n  if Validate::validate(rt1, st.env) is Err(t) {\n    return Err(\"Invalid RefType on BrOnCastFail: \" + t)\n  }\n  if Validate::validate(rt2, st.env) is Err(t) {\n    return Err(\"Invalid RefType on BrOnCastFail: \" + t)\n  }\n  let label_ts = match st.check_branch_args_present(l) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  if label_ts.length() == 0 {\n    return Err(\"br_on_cast_fail label type too short\")\n  }\n  let rt_label = match label_ts[label_ts.length() - 1] {\n    RefTypeValType(r) => r\n    _ => return Err(\"br_on_cast_fail label must end with a reftype\")\n  }\n  if !Match::matches(rt2, rt1, st.env) {\n    return Err(\"rt2 does not match rt1\")\n  }\n  let rt_diff = match diff(rt1, rt2) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  if !Match::matches(rt_diff, rt_label, st.env) {\n    return Err(\"rt1 \\\\ rt2 does not match label rt\")\n  }\n\n  // pop rt1\n  let st1 = match st.pop_expect(RefTypeValType(rt1)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  if st.reachable {\n    let prefix = label_ts.sub(start=0, end=label_ts.length() - 1)\n    let _ = match st1.pop_types(prefix.to_array()) {\n      Err(e) => return Err(e)\n      Ok(_) => ()\n    }\n\n  }\n  Ok(st1.push1(RefTypeValType(rt2)))\n}\n\n///|\nfn typecheck_throw(st : TcState, tag : TagIdx) -> TcResult {\n  // validate tag index\n  if Validate::validate(tag, st.env) is Err(e) {\n    return Err(e)\n  }\n\n  // get payload params\n  let TagType(tidx) = st.env.tags[tag.0.reinterpret_as_int()]\n  let params = match st.env.resolve_functype(tidx) {\n    Some(FuncType(ps, _)) => ps\n    None => return Err(\"throw: invalid tag type\")\n  }\n\n  // pop payload\n  let st1 = match st.pop_types(params) {\n    Ok(s) => s\n    Err(e) => return Err(e)\n  }\n\n  // throw always makes execution unreachable\n  Ok(st1.set_unreachable())\n}\n\n///|\nfn typecheck_throw_ref(st : TcState) -> TcResult {\n  let st1 = match st.pop_expect(ref_null_exn_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.set_unreachable())\n}\n\n///|\nfn typecheck_catch_clause(st : TcState, c : Catch) -> TcResult {\n  match c {\n    Catch(tag, lbl) => {\n      // label must expect tag's payload types\n      let label_idx = lbl.0.reinterpret_as_int()\n      let label_types = match st.env.labels.get(label_idx) {\n        Some(label_types) => label_types\n        None => return Err(\"Invalid catch label index\")\n      }\n      let payload = tag_payload_types(st.env, tag)\n      if not(Match::matches(payload, label_types, st.env)) {\n        return Err(\"catch types (payload) do not match label types\")\n      }\n      Ok(st)\n    }\n    CatchRef(tag, lbl) => {\n      // label must expect tag's payload types + exnref\n      let label_idx = lbl.0.reinterpret_as_int()\n      let label_types = match st.env.labels.get(label_idx) {\n        Some(label_types) => label_types\n        None => return Err(\"Invalid catch label index\")\n      }\n      let payload = tag_payload_types(st.env, tag)\n      let expected = payload.copy()\n      expected.push(\n        RefTypeValType(\n          HeapTypeRefType(false, AbsHeapTypeHeapType(ExnAbsHeapType)),\n        ),\n      )\n      if not(Match::matches(payload, label_types, st.env)) {\n        return Err(\n          \"catch_ref types (payload + exnref) do not match label types\",\n        )\n      }\n      Ok(st)\n    }\n    CatchAll(lbl) => {\n      // label must expect empty\n      let label_idx = lbl.0.reinterpret_as_int()\n      let label_types = match st.env.labels.get(label_idx) {\n        Some(label_types) => label_types\n        None => return Err(\"Invalid catch label index\")\n      }\n      if label_types.length() != 0 {\n        return Err(\"catch_all label must expect no values\")\n      }\n      Ok(st)\n    }\n    CatchAllRef(lbl) => {\n      // label must expect just exnref\n      let label_idx = lbl.0.reinterpret_as_int()\n      let label_types = match st.env.labels.get(label_idx) {\n        Some(label_types) => label_types\n        None => return Err(\"Invalid catch label index\")\n      }\n      let expected = [\n        @lib.RefTypeValType(\n          HeapTypeRefType(false, AbsHeapTypeHeapType(ExnAbsHeapType)),\n        ),\n      ]\n      if not(Match::matches(expected, label_types, st.env)) {\n        return Err(\"catch_all_ref label must expect exnref\")\n      }\n      Ok(st)\n    }\n  }\n}\n\n///|\nfn typecheck_try_table(\n  st : TcState,\n  bt : BlockType,\n  catches : Array[Catch],\n  body : Expr,\n) -> TcResult {\n  let (params, results) = match st.env.expand_blocktype(bt) { // assuming you made it a method\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n\n  // consume params\n  let st1 = match st.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let base_len = st1.stack.length()\n\n  // extend context with innermost label = results\n  let env2 = st1.env.with_label(results)\n  let st_body0 = TcState::{ ..st1, env: env2 }\n\n  // body must typecheck under extended env\n  let st_body = match Typecheck::typecheck(body, st_body0) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // validate all catch clauses under the SAME extended env (spec: C')\n  let st_catch_ctx = TcState::{ ..st1, env: env2 }\n  for c in catches {\n    match typecheck_catch_clause(st_catch_ctx, c) {\n      Err(e) => return Err(e)\n      Ok(_) => ()\n    }\n  }\n\n  // if reachable, enforce results on stack top\n  let st2 = if st_body.reachable {\n    match st_body.pop_types(results) {\n      Err(e) => return Err(e)\n      Ok(s) => s\n    }\n  } else {\n    st_body\n  }\n\n  // truncate back to base_len\n  let stack2 = st2.stack.copy()\n  while stack2.length() > base_len {\n    ignore(stack2.pop())\n  }\n\n  // restore outer env (pop the try_table label scope)\n  let out = TcState::{ env: st.env, stack: stack2, reachable: st2.reachable }\n  Ok(out.push_types(results))\n}\n\n///|\nfn typecheck_table_copy(st : TcState, x : TableIdx, y : TableIdx) -> TcResult {\n  let TableType(rt1, l1) = match st.env.get_table_type(x) {\n    None => return Err(\"invalid dest table index\")\n    Some(tt) => tt\n  }\n  let TableType(rt2, l2) = match st.env.get_table_type(y) {\n    None => return Err(\"invalid src table index\")\n    Some(tt) => tt\n  }\n\n  // require rt2 <: rt1\n  if !Match::matches(rt2, rt1, st.env) {\n    return Err(\"table.copy source elem type does not match dest elem type\")\n  }\n  let at_len = min_addr(l1, l2)\n\n  // Pop len, src, dst (LIFO), with types at_len, at2, at1\n  let st1 = match st.pop_expect(at_len.addr_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(l2.addr_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(l1.addr_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_table_init(st : TcState, y : ElemIdx, x : TableIdx) -> TcResult {\n  let TableType(rt1, l) = match st.env.get_table_type(x) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n  let elem = match st.env.get_elem(y) {\n    None => return Err(\"invalid elem segment index\")\n    Some(e) => e\n  }\n  let rt2 = elem_reftype(elem)\n  if !Match::matches(rt2, rt1, st.env) {\n    return Err(\"table.init elem segment type does not match table element type\")\n  }\n\n  // Pop: len:i32, src:i32, dst:at  (LIFO order)\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(l.addr_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_table_fill(st : TcState, x : TableIdx) -> TcResult {\n  let TableType(rt, lim) = match st.env.get_table_type(x) {\n    None => return Err(\"invalid table index\")\n    Some(tt) => tt\n  }\n\n  // pop len : i32\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop val : rt\n  let st2 = match st1.pop_expect(RefTypeValType(rt)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop start : at (derived from limits)\n  let st3 = match st2.pop_expect(lim.addr_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_elem_drop(st : TcState, y : ElemIdx) -> TcResult {\n  match st.env.get_elem(y) {\n    None => Err(\"invalid elem segment index\")\n    Some(_) => Ok(st)\n  }\n}\n\n// validates memarg and returns the chosen memory + its limits\n\n///|\nfn memarg_check(\n  st : TcState,\n  ma : MemArg,\n  default_mem : MemIdx,\n  nbits : Int,\n) -> Result[(MemIdx, Limits), String] {\n  let MemArg(U32(align_pow_u), mem_opt, U64(offset)) = ma\n  let mem = match mem_opt {\n    None => default_mem\n    Some(m) => m\n  }\n  let MemType(lim) = match st.env.get_memtype(mem) {\n    None => return Err(\"invalid memory index in memarg\")\n    Some(mt) => mt\n  }\n\n  // (1) alignment: 2^n <= N/8\n  let max_align_bytes = nbits / 8\n  if max_align_bytes <= 0 {\n    return Err(\"invalid access width\")\n  }\n  let align_pow = align_pow_u.reinterpret_as_int()\n  if align_pow < 0 {\n    return Err(\"negative alignment power\")\n  }\n  if align_pow >= 64 {\n    return Err(\"alignment too large\")\n  }\n  let align_bytes : UInt64 = 1 << align_pow\n  if align_bytes > max_align_bytes.to_uint64() {\n    return Err(\"memarg alignment too large for access width\")\n  }\n\n  // (2) offset: m < 2^|at|\n  let bits = lim.mem_addr_bits()\n  if bits == 32 {\n    if offset >= 1 << 32 {\n      return Err(\"memarg offset out of range for i32 memory\")\n    }\n  } else {\n    // i64 memory: offset is UInt64 so always < 2^64\n    ()\n  }\n  Ok((mem, lim))\n}\n\n///|\nfn typecheck_load(\n  st : TcState,\n  ma : MemArg,\n  nbits : Int,\n  result : ValType,\n) -> TcResult {\n  let (_mem, lim) = match memarg_check(st, ma, MemIdx(0), nbits) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let at = lim.addr_valtype()\n  let st1 = match st.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(result))\n}\n\n///|\nfn typecheck_store(\n  st : TcState,\n  ma : MemArg,\n  nbits : Int,\n  value : ValType,\n) -> TcResult {\n  let (_mem, lim) = match memarg_check(st, ma, MemIdx(0), nbits) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let at = lim.addr_valtype()\n\n  // pop value first (top of stack)\n  let st1 = match st.pop_expect(value) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop address\n  let st2 = match st1.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2)\n}\n\n///|\nfn typecheck_loop(st : TcState, bt : BlockType, body : Expr) -> TcResult {\n  let (params, results) = match st.env.expand_blocktype(bt) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n\n  // consume params\n  let st1 = match st.pop_types(params) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let base_len = st1.stack.length()\n\n  // loop label is params (not results)\n  let env2 = st1.env.with_label(params)\n  let st_body0 = TcState::{ ..st1, env: env2 }\n  let st_body = match Typecheck::typecheck(body, st_body0) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // if reachable, enforce results on top\n  let st2 = if st_body.reachable {\n    match st_body.pop_types(results) {\n      Err(e) => return Err(e)\n      Ok(s) => s\n    }\n  } else {\n    st_body\n  }\n\n  // truncate back to base_len\n  let stack2 = st2.stack.copy()\n  while stack2.length() > base_len {\n    ignore(stack2.pop())\n  }\n\n  // restore outer env (pop label scope)\n  let out = TcState::{ env: st.env, stack: stack2, reachable: st2.reachable }\n  Ok(out.push_types(results))\n}\n\n///|\nfn typecheck_ref_null(st : TcState, ht : HeapType) -> TcResult {\n  if Validate::validate(ht, st.env) is Err(t) {\n    return Err(t)\n  }\n  Ok(st.push1(ref_null_valtype(ht)))\n}\n\n///|\nfn typecheck_ref_is_null(st : TcState) -> TcResult {\n  let (st1, v) = match st.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n  match v {\n    RefTypeValType(rt) => {\n      if !rt.is_nullable() {\n        return Err(\"ref.is_null expects a nullable reference\")\n      }\n      Ok(st1.push1(NumTypeValType(I32NumType)))\n    }\n    _ => Err(\"ref.is_null expects a reference type\")\n  }\n}\n\n///|\nfn typecheck_ref_func(st : TcState, f : FuncIdx) -> TcResult {\n  if !st.env.has_func(f) {\n    return Err(\"invalid function index\")\n  }\n  Ok(st.push1(funcref_valtype()))\n}\n\n///|\nfn typecheck_ref_as_non_null(st : TcState) -> TcResult {\n  let (st1, v) = match st.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n  match v {\n    RefTypeValType(rt) =>\n      match rt {\n        HeapTypeRefType(true, ht) =>\n          Ok(st1.push1(RefTypeValType(HeapTypeRefType(false, ht))))\n        HeapTypeRefType(false, _) =>\n          Err(\"ref.as_non_null expects (ref null ht), got non-null ref\")\n        AbsHeapTypeRefType(_) =>\n          Err(\"ref.as_non_null expects (ref null ht), got abstract ref type\")\n      }\n    _ => Err(\"ref.as_non_null expects a reference type\")\n  }\n}\n\n///|\nfn typecheck_ref_eq(st : TcState) -> TcResult {\n  // pop second operand\n  let st1 = match st.pop_expect(eqref_null_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop first operand\n  let st2 = match st1.pop_expect(eqref_null_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(NumTypeValType(I32NumType)))\n}\n\n///|\nfn typecheck_ref_test(st : TcState, nullable : Bool, ht : HeapType) -> TcResult {\n  let rt = @lib.HeapTypeRefType(nullable, ht)\n  if Validate::validate(rt, st.env) is Err(t) {\n    return Err(\"invalid ref.test target reftype: \" + t)\n  }\n  let (st1, v) = match st.pop1() {\n    Err(e) => return Err(e)\n    Ok(pair) => pair\n  }\n  let rt_in = match v {\n    RefTypeValType(r) => r\n    _ => return Err(\"ref.test expects a reference operand\")\n  }\n\n  // Spec: rt <: rt_in OR rt_in <: rt (types must be in same hierarchy)\n  if not(Match::matches(rt, rt_in, st.env) || Match::matches(rt_in, rt, st.env)) {\n    return Err(\"ref.test target does not match operand type\")\n  }\n  Ok(st1.push1(NumTypeValType(I32NumType)))\n}\n\n///|\nfn typecheck_ref_cast(st : TcState, nullable : Bool, ht : HeapType) -> TcResult {\n  let rt = @lib.HeapTypeRefType(nullable, ht)\n  if Validate::validate(rt, st.env) is Err(t) {\n    return Err(\"invalid ref.cast target reftype: \" + t)\n  }\n  let (st1, rt_in_opt) = match st.pop_ref_or_bot() {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  match rt_in_opt {\n    None => ()\n    Some(rt_in) =>\n      if !Match::matches(rt, rt_in, st.env) {\n        return Err(\"ref.cast target does not match operand type\")\n      }\n  }\n  Ok(st1.push1(RefTypeValType(rt)))\n}\n\n///|\nfn typecheck_struct_new(st : TcState, x : TypeIdx) -> TcResult {\n  let fields = match st.env.resolve_struct_fields(x) {\n    Err(e) => return Err(e)\n    Ok(fs) => fs\n  }\n\n  // Compute expected argument types: unpack(storage) for each field, in order.\n  let args : Array[ValType] = []\n  for f in fields {\n    let FieldType(stor, _) = f\n    args.push(unpack_storage(stor))\n  }\n  let st1 = match st.pop_types(args) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // push (ref x)\n  Ok(st1.push1(RefTypeValType(HeapTypeRefType(false, HeapType(x)))))\n}\n\n///|\nfn typecheck_struct_new_default(st : TcState, x : TypeIdx) -> TcResult {\n  let fields = match st.env.resolve_struct_fields(x) {\n    Err(e) => return Err(e)\n    Ok(fs) => fs\n  }\n  for f in fields {\n    let FieldType(stor, _) = f\n    let vt = unpack_storage(stor)\n    if !has_default(vt) {\n      return Err(\"struct.new_default: no default for a non-null field type\")\n    }\n  }\n  Ok(st.push1(RefTypeValType(HeapTypeRefType(false, HeapType(x)))))\n}\n\n///|\nfn typecheck_struct_get(st : TcState, x : TypeIdx, i : U32) -> TcResult {\n  let fields = match st.env.resolve_struct_fields(x) {\n    Err(e) => return Err(e)\n    Ok(fs) => fs\n  }\n  let FieldType(stor, _) = match get_struct_field(fields, i) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  if is_packed(stor) {\n    return Err(\n      \"struct.get used on packed field; use struct.get_s or struct.get_u\",\n    )\n  }\n  let st1 = match\n    st.pop_expect(RefTypeValType(HeapTypeRefType(true, HeapType(x)))) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(unpack_storage(stor)))\n}\n\n///|\nfn typecheck_struct_get_s(st : TcState, x : TypeIdx, i : U32) -> TcResult {\n  let fields = match st.env.resolve_struct_fields(x) {\n    Err(e) => return Err(e)\n    Ok(fs) => fs\n  }\n  let FieldType(stor, _) = match get_struct_field(fields, i) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  if !is_packed(stor) {\n    return Err(\"struct.get_s requires packed field\")\n  }\n  let st1 = match\n    st.pop_expect(RefTypeValType(HeapTypeRefType(true, HeapType(x)))) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(NumTypeValType(I32NumType)))\n}\n\n///|\nfn typecheck_struct_get_u(st : TcState, x : TypeIdx, i : U32) -> TcResult {\n  // identical checks, only semantics differ at runtime\n  typecheck_struct_get_s(st, x, i)\n}\n\n///|\nfn typecheck_struct_set(st : TcState, x : TypeIdx, i : U32) -> TcResult {\n  let fields = match st.env.resolve_struct_fields(x) {\n    Err(e) => return Err(e)\n    Ok(fs) => fs\n  }\n  let ft = match get_struct_field(fields, i) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  if !field_is_mutable(ft) {\n    return Err(\"struct.set on immutable field\")\n  }\n  let FieldType(stor, _) = ft\n  let val_ty = unpack_storage(stor)\n\n  // pop value then ref\n  let st1 = match st.pop_expect(val_ty) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match\n    st1.pop_expect(RefTypeValType(HeapTypeRefType(true, HeapType(x)))) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2)\n}\n\n///|\nfn typecheck_unary(st : TcState, t_in : ValType, t_out : ValType) -> TcResult {\n  let st1 = match st.pop_expect(t_in) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(t_out))\n}\n\n///|\nfn typecheck_binary(st : TcState, t : ValType, out : ValType) -> TcResult {\n  let st1 = match st.pop_expect(t) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(t) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(out))\n}\n\n///|\nfn typecheck_v128_ternary(st : TcState) -> TcResult {\n  // v128 v128 v128 -> v128\n  let st1 = match st.pop_expect(vt_v128()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(vt_v128()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(vt_v128()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3.push1(vt_v128()))\n}\n\n///|\nfn typecheck_compare(st : TcState, t : ValType) -> TcResult {\n  typecheck_binary(st, t, NumTypeValType(I32NumType))\n}\n\n///|\nfn typecheck_v128_unary(st : TcState) -> TcResult {\n  typecheck_unary(st, vt_v128(), vt_v128())\n}\n\n///|\nfn typecheck_v128_binary(st : TcState) -> TcResult {\n  typecheck_binary(st, vt_v128(), vt_v128())\n}\n\n///|\nfn typecheck_v128_compare(st : TcState) -> TcResult {\n  // v128 v128 -> v128 (SIMD comparisons produce v128 masks)\n  typecheck_v128_binary(st)\n}\n\n///|\nfn typecheck_v128_shift(st : TcState) -> TcResult {\n  // v128 i32 -> v128 (shift count is i32)\n  let st1 = match st.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(vt_v128()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(vt_v128()))\n}\n\n///|\nfn typecheck_lane_extract(st : TcState, out : ValType) -> TcResult {\n  // v128 -> out (lane index is an immediate, not on stack)\n  let st1 = match st.pop_expect(vt_v128()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(out))\n}\n\n///|\nfn typecheck_lane_replace(st : TcState, in_v : ValType) -> TcResult {\n  // v128, in_v -> v128\n  let st1 = match st.pop_expect(in_v) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(vt_v128()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(vt_v128()))\n}\n\n///|\nfn typecheck_splat(st : TcState, in_v : ValType) -> TcResult {\n  // in_v -> v128\n  typecheck_unary(st, in_v, vt_v128())\n}\n\n///|\nfn typecheck_v128_const(st : TcState) -> TcResult {\n  Ok(st.push1(vt_v128()))\n}\n\n///|\nfn typecheck_v128_mem_load(st : TcState, ma : MemArg, nbits : Int) -> TcResult {\n  let (_mem, lim) = match memarg_check(st, ma, MemIdx(0), nbits) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let at = lim.addr_valtype()\n  let st1 = match st.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(VecTypeValType))\n}\n\n///|\nfn typecheck_v128_mem_store(st : TcState, ma : MemArg, nbits : Int) -> TcResult {\n  let (_mem, lim) = match memarg_check(st, ma, MemIdx(0), nbits) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let at = lim.addr_valtype()\n\n  // pop value first\n  let st1 = match st.pop_expect(VecTypeValType) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop address\n  let st2 = match st1.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2)\n}\n\n///|\nfn typecheck_v128_mem_load_zero(\n  st : TcState,\n  ma : MemArg,\n  nbits : Int,\n) -> TcResult {\n  typecheck_v128_mem_load(st, ma, nbits)\n}\n\n///|\nfn typecheck_v128_load_lane(st : TcState, ma : MemArg, nbits : Int) -> TcResult {\n  let (_mem, lim) = match memarg_check(st, ma, MemIdx(0), nbits) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let at = lim.addr_valtype()\n\n  // pop existing vector (top of stack)\n  let st1 = match st.pop_expect(VecTypeValType) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop address\n  let st2 = match st1.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(VecTypeValType))\n}\n\n///|\nfn typecheck_v128_store_lane(\n  st : TcState,\n  ma : MemArg,\n  nbits : Int,\n) -> TcResult {\n  let (_mem, lim) = match memarg_check(st, ma, MemIdx(0), nbits) {\n    Err(e) => return Err(e)\n    Ok(x) => x\n  }\n  let at = lim.addr_valtype()\n\n  // pop vector (top of stack)\n  let st1 = match st.pop_expect(VecTypeValType) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop address\n  let st2 = match st1.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2)\n}\n\n///|\nfn typecheck_v128_mem_load_splat(\n  st : TcState,\n  ma : MemArg,\n  nbits : Int,\n) -> TcResult {\n  typecheck_v128_mem_load(st, ma, nbits)\n}\n\n///|\nfn typecheck_v128_mem_load_extend64(st : TcState, ma : MemArg) -> TcResult {\n  typecheck_v128_mem_load(st, ma, 64)\n}\n\n///|\nfn typecheck_memory_size(st : TcState, mem : MemIdx) -> TcResult {\n  let at = match st.mem_at_of(mem) {\n    Err(e) => return Err(e)\n    Ok(t) => t\n  }\n  Ok(st.push1(at))\n}\n\n///|\nfn typecheck_memory_grow(st : TcState, mem : MemIdx) -> TcResult {\n  let at = match st.mem_at_of(mem) {\n    Err(e) => return Err(e)\n    Ok(t) => t\n  }\n  let st1 = match st.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(at))\n}\n\n///|\nfn typecheck_memory_init(\n  st : TcState,\n  data : DataIdx,\n  mem : MemIdx,\n) -> TcResult {\n  if !st.env.has_data(data) {\n    return Err(\"invalid data segment index\")\n  }\n  let at = match st.mem_at_of(mem) {\n    Err(e) => return Err(e)\n    Ok(t) => t\n  }\n\n  // pop len:i32, src:i32, dst:at\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_data_drop(st : TcState, data : DataIdx) -> TcResult {\n  if !st.env.has_data(data) {\n    return Err(\"invalid data segment index\")\n  }\n  Ok(st)\n}\n\n///|\nfn typecheck_memory_copy(st : TcState, dst : MemIdx, src : MemIdx) -> TcResult {\n  let MemType(lim1) = match st.env.get_memtype(dst) {\n    None => return Err(\"invalid dest memory index\")\n    Some(mt) => mt\n  }\n  let MemType(lim2) = match st.env.get_memtype(src) {\n    None => return Err(\"invalid src memory index\")\n    Some(mt) => mt\n  }\n  let at1 = lim1.addr_valtype()\n  let at2 = lim2.addr_valtype()\n  let at_len = min_addr_valtype(lim1, lim2)\n\n  // pop len, src, dst\n  let st1 = match st.pop_expect(at_len) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(at2) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(at1) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_memory_fill(st : TcState, mem : MemIdx) -> TcResult {\n  let at = match st.mem_at_of(mem) {\n    Err(e) => return Err(e)\n    Ok(t) => t\n  }\n\n  // pop len:i32, val:i32, dst:at\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(at) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_any_convert_extern(st : TcState) -> TcResult {\n  let st1 = match st.pop_expect(externref_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(anyref_valtype()))\n}\n\n///|\nfn typecheck_extern_convert_any(st : TcState) -> TcResult {\n  let st1 = match st.pop_expect(anyref_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(externref_valtype()))\n}\n\n///|\nfn typecheck_ref_i31(st : TcState) -> TcResult {\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(i31ref_valtype()))\n}\n\n///|\nfn typecheck_i31_get(st : TcState) -> TcResult {\n  let st1 = match st.pop_expect(i31ref_nullable_valtype()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(NumTypeValType(I32NumType)))\n}\n\n///|\nfn typecheck_array_new(st : TcState, x : TypeIdx) -> TcResult {\n  let FieldType(sto, _) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  let elem_vt = unpack_storage(sto)\n\n  // pop length : i32\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop init value : elem_vt\n  let st2 = match st1.pop_expect(elem_vt) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(ref_array_nonnull(x)))\n}\n\n///|\nfn typecheck_array_new_default(st : TcState, x : TypeIdx) -> TcResult {\n  let FieldType(sto, _) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  let elem_vt = unpack_storage(sto)\n  if !has_default(elem_vt) {\n    return Err(\"array.new_default: no default for element type\")\n  }\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(ref_array_nonnull(x)))\n}\n\n///|\nfn typecheck_array_new_fixed(st : TcState, x : TypeIdx, n : U32) -> TcResult {\n  let FieldType(sto, _) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  let elem_vt = unpack_storage(sto)\n  let U32(nu) = n\n  let count = nu.reinterpret_as_int()\n  if count < 0 {\n    return Err(\"array.new_fixed: negative length\")\n  }\n  let mut cur = st\n  // pop count times\n  for _ in 0..<count {\n    cur = match cur.pop_expect(elem_vt) {\n      Err(e) => return Err(e)\n      Ok(s) => s\n    }\n  }\n  Ok(cur.push1(ref_array_nonnull(x)))\n}\n\n///|\nfn typecheck_array_get(st : TcState, x : TypeIdx) -> TcResult {\n  let FieldType(sto, _) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  if is_packed(sto) {\n    return Err(\n      \"array.get used on packed element; use array.get_s or array.get_u\",\n    )\n  }\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(ref_array_nullable(x)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(unpack_storage(sto)))\n}\n\n///|\nfn typecheck_array_get_s(st : TcState, x : TypeIdx) -> TcResult {\n  let FieldType(sto, _) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  if !is_packed(sto) {\n    return Err(\"array.get_s requires packed element type\")\n  }\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(ref_array_nullable(x)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(NumTypeValType(I32NumType)))\n}\n\n///|\nfn typecheck_array_get_u(st : TcState, x : TypeIdx) -> TcResult {\n  // same typing as get_s\n  typecheck_array_get_s(st, x)\n}\n\n///|\nfn typecheck_array_set(st : TcState, x : TypeIdx) -> TcResult {\n  let ft = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  if !field_is_mutable(ft) {\n    return Err(\"array.set on immutable array element type\")\n  }\n  let FieldType(sto, _) = ft\n  let elem_vt = unpack_storage(sto)\n\n  // pop value\n  let st1 = match st.pop_expect(elem_vt) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop index\n  let st2 = match st1.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop array ref\n  let st3 = match st2.pop_expect(ref_array_nullable(x)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st3)\n}\n\n///|\nfn typecheck_array_len(st : TcState) -> TcResult {\n  let want = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ArrayAbsHeapType)),\n  )\n  let st1 = match st.pop_expect(want) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st1.push1(NumTypeValType(I32NumType)))\n}\n\n///|\nfn typecheck_array_fill(st : TcState, x : TypeIdx) -> TcResult {\n  let ft = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  if !field_is_mutable(ft) {\n    return Err(\"array.fill on immutable array element type\")\n  }\n  let FieldType(sto, _) = ft\n  let elem_vt = unpack_storage(sto)\n\n  // pop len\n  let st1 = match st.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop value\n  let st2 = match st1.pop_expect(elem_vt) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop start\n  let st3 = match st2.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop array ref\n  let st4 = match st3.pop_expect(ref_null_array_of(x)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st4)\n}\n\n///|\nfn typecheck_array_copy(st : TcState, x : TypeIdx, y : TypeIdx) -> TcResult {\n  let ft_x = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  let ft_y = match st.env.resolve_array_field(y) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  if !field_is_mutable(ft_x) {\n    return Err(\"array.copy requires destination array to be mutable\")\n  }\n  let FieldType(sto_x, _) = ft_x\n  let FieldType(sto_y, _) = ft_y\n  let vx = unpack_storage(sto_x)\n  let vy = unpack_storage(sto_y)\n  if !Match::matches(vy, vx, st.env) {\n    return Err(\n      \"array.copy source element type does not match destination element type\",\n    )\n  }\n\n  // pop len\n  let st = match st.pop_expect(vt_i32()) {\n    Err(t) => return Err(t)\n    Ok(t) => t\n  }\n\n  // pop src index\n  let st = match st.pop_expect(vt_i32()) {\n    Err(t) => return Err(t)\n    Ok(t) => t\n  }\n\n  // pop src array\n  let st = match st.pop_expect(ref_null_array_of(y)) {\n    Err(t) => return Err(t)\n    Ok(t) => t\n  }\n\n  // pop dst index\n  let st = match st.pop_expect(vt_i32()) {\n    Err(t) => return Err(t)\n    Ok(t) => t\n  }\n\n  // pop dst array\n  let st = match st.pop_expect(ref_null_array_of(x)) {\n    Err(t) => return Err(t)\n    Ok(t) => t\n  }\n  Ok(st)\n}\n\n///|\nfn typecheck_array_init_data(\n  st : TcState,\n  x : TypeIdx,\n  y : DataIdx,\n) -> TcResult {\n  if !st.env.has_data(y) {\n    return Err(\"invalid data segment index\")\n  }\n  let ft = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  if !field_is_mutable(ft) {\n    return Err(\"array.init_data requires array element to be mutable\")\n  }\n  let FieldType(sto, _) = ft\n  let vt = unpack_storage(sto)\n  match vt {\n    NumTypeValType(_) => ()\n    VecTypeValType => ()\n    _ =>\n      return Err(\n        \"array.init_data requires unpack(element) to be numtype or vectype\",\n      )\n  }\n\n  // Stack: (ref null x) i32 i32 i32 -> ε\n  // pop len, src, dst\n  let st1 = match st.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop array ref\n  let st4 = match st3.pop_expect(ref_null_array_of(x)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st4)\n}\n\n///|\nfn typecheck_array_init_elem(\n  st : TcState,\n  x : TypeIdx,\n  y : ElemIdx,\n) -> TcResult {\n  let elem = match st.env.get_elem(y) {\n    None => return Err(\"invalid elem segment index\")\n    Some(e) => e\n  }\n  let ft = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(f) => f\n  }\n  if !field_is_mutable(ft) {\n    return Err(\"array.init_elem requires array element to be mutable\")\n  }\n  let FieldType(sto, _) = ft\n\n  // Spec: C.elems[y] ≤ zt (storage type), so storage type must be a ref valtype.\n  let rt_array = match sto {\n    ValTypeStorageType(RefTypeValType(rt)) => rt\n    _ =>\n      return Err(\n        \"array.init_elem requires array storage type to be a reference type\",\n      )\n  }\n  let rt_seg = elem_reftype(elem)\n  if !Match::matches(rt_seg, rt_array, st.env) {\n    return Err(\n      \"array.init_elem elem segment type does not match array storage type\",\n    )\n  }\n\n  // Stack: (ref null x) i32 i32 i32 -> ε\n  // pop len, src, dst\n  let st1 = match st.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st3 = match st2.pop_expect(vt_i32()) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n\n  // pop array ref\n  let st4 = match st3.pop_expect(ref_null_array_of(x)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st4)\n}\n\n///|\nfn typecheck_array_new_elem(st : TcState, x : TypeIdx, y : ElemIdx) -> TcResult {\n  let elem = match st.env.get_elem(y) {\n    None => return Err(\"invalid elem segment index\")\n    Some(e) => e\n  }\n  let FieldType(sto, _mut) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  let rt_array = match sto {\n    ValTypeStorageType(RefTypeValType(rt)) => rt\n    _ =>\n      return Err(\n        \"array.new_elem requires array element storage type to be a reftype\",\n      )\n  }\n  let rt_seg = elem_reftype(elem)\n  if !Match::matches(rt_seg, rt_array, st.env) {\n    return Err(\n      \"array.new_elem elem segment type does not match array element reftype\",\n    )\n  }\n\n  // Stack: i32 i32 -> (ref x)\n  // (the two i32 are typically src and len; order doesn't matter for typing as both are i32)\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(ref_array_nonnull(x)))\n}\n\n///|\nfn typecheck_array_new_data(st : TcState, x : TypeIdx, y : DataIdx) -> TcResult {\n  if !st.env.has_data(y) {\n    return Err(\"invalid data segment index\")\n  }\n  let FieldType(sto, _mut) = match st.env.resolve_array_field(x) {\n    Err(e) => return Err(e)\n    Ok(ft) => ft\n  }\n  let vt = unpack_storage(sto)\n  match vt {\n    NumTypeValType(_) => ()\n    VecTypeValType => ()\n    _ =>\n      return Err(\n        \"array.new_data requires unpack(element) to be numtype or vectype\",\n      )\n  }\n\n  // Stack: i32 i32 -> (ref x)\n  let st1 = match st.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  let st2 = match st1.pop_expect(NumTypeValType(I32NumType)) {\n    Err(e) => return Err(e)\n    Ok(s) => s\n  }\n  Ok(st2.push1(ref_array_nonnull(x)))\n}\n\n///|\npub impl Typecheck for Instruction with typecheck(self, st) {\n  match self {\n    Unreachable => Ok(TcState::{ ..st, reachable: false })\n    Nop => Ok(st)\n    I32Const(_) => Ok(st.push1(NumTypeValType(I32NumType)))\n    I64Const(_) => Ok(st.push1(NumTypeValType(I64NumType)))\n    F32Const(_) => Ok(st.push1(NumTypeValType(F32NumType)))\n    F64Const(_) => Ok(st.push1(NumTypeValType(F64NumType)))\n    I32Load(ma) => typecheck_load(st, ma, 32, NumTypeValType(I32NumType))\n    I64Load(ma) => typecheck_load(st, ma, 64, NumTypeValType(I64NumType))\n    F32Load(ma) => typecheck_load(st, ma, 32, NumTypeValType(F32NumType))\n    F64Load(ma) => typecheck_load(st, ma, 64, NumTypeValType(F64NumType))\n    I32Load8S(ma) => typecheck_load(st, ma, 8, NumTypeValType(I32NumType))\n    I32Load8U(ma) => typecheck_load(st, ma, 8, NumTypeValType(I32NumType))\n    I32Load16S(ma) => typecheck_load(st, ma, 16, NumTypeValType(I32NumType))\n    I32Load16U(ma) => typecheck_load(st, ma, 16, NumTypeValType(I32NumType))\n    I64Load8S(ma) => typecheck_load(st, ma, 8, NumTypeValType(I64NumType))\n    I64Load8U(ma) => typecheck_load(st, ma, 8, NumTypeValType(I64NumType))\n    I64Load16S(ma) => typecheck_load(st, ma, 16, NumTypeValType(I64NumType))\n    I64Load16U(ma) => typecheck_load(st, ma, 16, NumTypeValType(I64NumType))\n    I64Load32S(ma) => typecheck_load(st, ma, 32, NumTypeValType(I64NumType))\n    I64Load32U(ma) => typecheck_load(st, ma, 32, NumTypeValType(I64NumType))\n    I32Store(ma) => typecheck_store(st, ma, 32, NumTypeValType(I32NumType))\n    I64Store(ma) => typecheck_store(st, ma, 64, NumTypeValType(I64NumType))\n    F32Store(ma) => typecheck_store(st, ma, 32, NumTypeValType(F32NumType))\n    F64Store(ma) => typecheck_store(st, ma, 64, NumTypeValType(F64NumType))\n    I32Store8(ma) => typecheck_store(st, ma, 8, NumTypeValType(I32NumType))\n    I32Store16(ma) => typecheck_store(st, ma, 16, NumTypeValType(I32NumType))\n    I64Store8(ma) => typecheck_store(st, ma, 8, NumTypeValType(I64NumType))\n    I64Store16(ma) => typecheck_store(st, ma, 16, NumTypeValType(I64NumType))\n    I64Store32(ma) => typecheck_store(st, ma, 32, NumTypeValType(I64NumType))\n    Drop => typecheck_drop(st)\n    Select(None) => typecheck_select_untyped(st)\n    Select(Some(ts)) => typecheck_select_typed(st, ts)\n    LocalGet(i) => typecheck_local_get(st, i)\n    LocalSet(i) => typecheck_local_set(st, i)\n    LocalTee(i) => typecheck_local_tee(st, i)\n    GlobalGet(i) => typecheck_global_get(st, i)\n    GlobalSet(i) => typecheck_global_set(st, i)\n    TableGet(i) => typecheck_table_get(st, i)\n    TableSet(i) => typecheck_table_set(st, i)\n    TableSize(i) => typecheck_table_size(st, i)\n    TableGrow(i) => typecheck_table_grow(st, i)\n    TableCopy(i0, i1) => typecheck_table_copy(st, i0, i1)\n    TableInit(x, y) => typecheck_table_init(st, x, y)\n    TableFill(x) => typecheck_table_fill(st, x)\n    ElemDrop(y) => typecheck_elem_drop(st, y)\n    MemorySize(m) => typecheck_memory_size(st, m)\n    MemoryGrow(m) => typecheck_memory_grow(st, m)\n    MemoryInit(d, m) => typecheck_memory_init(st, d, m)\n    DataDrop(d) => typecheck_data_drop(st, d)\n    MemoryCopy(d, s) => typecheck_memory_copy(st, d, s)\n    MemoryFill(m) => typecheck_memory_fill(st, m)\n    Br(l) => typecheck_br(st, l)\n    Block(bt, e) => typecheck_block(st, bt, e)\n    If(bt, th, el) => typecheck_if(st, bt, th, el)\n    BrIf(l) => typecheck_br_if(st, l)\n    BrTable(ls, ldef) => typecheck_br_table(st, ls, ldef)\n    BrOnNull(l) => typecheck_br_on_null(st, l)\n    BrOnNonNull(l) => typecheck_br_on_non_null(st, l)\n    BrOnCast(l, op, ht1, ht2) => typecheck_br_on_cast(st, l, op, ht1, ht2)\n    BrOnCastFail(l, op, ht1, ht2) =>\n      typecheck_br_on_cast_fail(st, l, op, ht1, ht2)\n    Return => typecheck_return(st)\n    Call(f) => typecheck_call(st, f)\n    CallIndirect(tidx, t) => typecheck_call_indirect(st, tidx, t)\n    CallRef(tidx) => typecheck_call_ref(st, tidx)\n    ReturnCall(fidx) => typecheck_return_call(st, fidx)\n    ReturnCallIndirect(tidx, t) => typecheck_return_call_indirect(st, tidx, t)\n    ReturnCallRef(tidx) => typecheck_return_call_ref(st, tidx)\n    Throw(t) => typecheck_throw(st, t)\n    ThrowRef => typecheck_throw_ref(st)\n    TryTable(bt, cs, e) => typecheck_try_table(st, bt, cs, e)\n    Loop(bt, e) => typecheck_loop(st, bt, e)\n    RefNull(ht) => typecheck_ref_null(st, ht)\n    RefIsNull => typecheck_ref_is_null(st)\n    RefFunc(f) => typecheck_ref_func(st, f)\n    RefAsNonNull => typecheck_ref_as_non_null(st)\n    RefEq => typecheck_ref_eq(st)\n    RefTest(nullable, ht) => typecheck_ref_test(st, nullable, ht)\n    RefCast(nullable, ht) => typecheck_ref_cast(st, nullable, ht)\n    AnyConvertExtern => typecheck_any_convert_extern(st)\n    ExternConvertAny => typecheck_extern_convert_any(st)\n    RefI31 => typecheck_ref_i31(st)\n    I31GetS => typecheck_i31_get(st)\n    I31GetU => typecheck_i31_get(st)\n    StructNew(x) => typecheck_struct_new(st, x)\n    StructNewDefault(x) => typecheck_struct_new_default(st, x)\n    StructGet(x, i) => typecheck_struct_get(st, x, i)\n    StructGetS(x, i) => typecheck_struct_get_s(st, x, i)\n    StructGetU(x, i) => typecheck_struct_get_u(st, x, i)\n    StructSet(x, i) => typecheck_struct_set(st, x, i)\n    ArrayNew(x) => typecheck_array_new(st, x)\n    ArrayNewDefault(x) => typecheck_array_new_default(st, x)\n    ArrayNewFixed(x, n) => typecheck_array_new_fixed(st, x, n)\n    ArrayGet(x) => typecheck_array_get(st, x)\n    ArrayGetS(x) => typecheck_array_get_s(st, x)\n    ArrayGetU(x) => typecheck_array_get_u(st, x)\n    ArraySet(x) => typecheck_array_set(st, x)\n    ArrayLen => typecheck_array_len(st)\n    ArrayFill(x) => typecheck_array_fill(st, x)\n    ArrayCopy(x, y) => typecheck_array_copy(st, x, y)\n    ArrayInitData(x, y) => typecheck_array_init_data(st, x, y)\n    ArrayInitElem(x, y) => typecheck_array_init_elem(st, x, y)\n    ArrayNewElem(x, y) => typecheck_array_new_elem(st, x, y)\n    ArrayNewData(x, y) => typecheck_array_new_data(st, x, y)\n\n    // ===== i32 relational =====\n    I32Eqz => typecheck_unary(st, vt_i32(), vt_i32())\n    I32Eq => typecheck_compare(st, vt_i32())\n    I32Ne => typecheck_compare(st, vt_i32())\n    I32LtS => typecheck_compare(st, vt_i32())\n    I32LtU => typecheck_compare(st, vt_i32())\n    I32GtS => typecheck_compare(st, vt_i32())\n    I32GtU => typecheck_compare(st, vt_i32())\n    I32LeS => typecheck_compare(st, vt_i32())\n    I32LeU => typecheck_compare(st, vt_i32())\n    I32GeS => typecheck_compare(st, vt_i32())\n    I32GeU => typecheck_compare(st, vt_i32())\n\n    // ===== i64 relational =====\n    I64Eqz => typecheck_unary(st, vt_i64(), vt_i32())\n    I64Eq => typecheck_compare(st, vt_i64())\n    I64Ne => typecheck_compare(st, vt_i64())\n    I64LtS => typecheck_compare(st, vt_i64())\n    I64LtU => typecheck_compare(st, vt_i64())\n    I64GtS => typecheck_compare(st, vt_i64())\n    I64GtU => typecheck_compare(st, vt_i64())\n    I64LeS => typecheck_compare(st, vt_i64())\n    I64LeU => typecheck_compare(st, vt_i64())\n    I64GeS => typecheck_compare(st, vt_i64())\n    I64GeU => typecheck_compare(st, vt_i64())\n\n    // ===== f32 relational =====\n    F32Eq => typecheck_compare(st, vt_f32())\n    F32Ne => typecheck_compare(st, vt_f32())\n    F32Lt => typecheck_compare(st, vt_f32())\n    F32Gt => typecheck_compare(st, vt_f32())\n    F32Le => typecheck_compare(st, vt_f32())\n    F32Ge => typecheck_compare(st, vt_f32())\n\n    // ===== f64 relational =====\n    F64Eq => typecheck_compare(st, vt_f64())\n    F64Ne => typecheck_compare(st, vt_f64())\n    F64Lt => typecheck_compare(st, vt_f64())\n    F64Gt => typecheck_compare(st, vt_f64())\n    F64Le => typecheck_compare(st, vt_f64())\n    F64Ge => typecheck_compare(st, vt_f64())\n\n    // ===== i32 unary =====\n    I32Clz => typecheck_unary(st, vt_i32(), vt_i32())\n    I32Ctz => typecheck_unary(st, vt_i32(), vt_i32())\n    I32Popcnt => typecheck_unary(st, vt_i32(), vt_i32())\n\n    // ===== i64 unary =====\n    I64Clz => typecheck_unary(st, vt_i64(), vt_i64())\n    I64Ctz => typecheck_unary(st, vt_i64(), vt_i64())\n    I64Popcnt => typecheck_unary(st, vt_i64(), vt_i64())\n\n    // ===== i32 binary =====\n    I32Add => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Sub => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Mul => typecheck_binary(st, vt_i32(), vt_i32())\n    I32DivS => typecheck_binary(st, vt_i32(), vt_i32())\n    I32DivU => typecheck_binary(st, vt_i32(), vt_i32())\n    I32RemS => typecheck_binary(st, vt_i32(), vt_i32())\n    I32RemU => typecheck_binary(st, vt_i32(), vt_i32())\n    I32And => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Or => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Xor => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Shl => typecheck_binary(st, vt_i32(), vt_i32())\n    I32ShrS => typecheck_binary(st, vt_i32(), vt_i32())\n    I32ShrU => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Rotl => typecheck_binary(st, vt_i32(), vt_i32())\n    I32Rotr => typecheck_binary(st, vt_i32(), vt_i32())\n\n    // ===== i64 binary =====\n    I64Add => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Sub => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Mul => typecheck_binary(st, vt_i64(), vt_i64())\n    I64DivS => typecheck_binary(st, vt_i64(), vt_i64())\n    I64DivU => typecheck_binary(st, vt_i64(), vt_i64())\n    I64RemS => typecheck_binary(st, vt_i64(), vt_i64())\n    I64RemU => typecheck_binary(st, vt_i64(), vt_i64())\n    I64And => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Or => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Xor => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Shl => typecheck_binary(st, vt_i64(), vt_i64())\n    I64ShrS => typecheck_binary(st, vt_i64(), vt_i64())\n    I64ShrU => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Rotl => typecheck_binary(st, vt_i64(), vt_i64())\n    I64Rotr => typecheck_binary(st, vt_i64(), vt_i64())\n\n    // ===== f32 unary =====\n    F32Abs => typecheck_unary(st, vt_f32(), vt_f32())\n    F32Neg => typecheck_unary(st, vt_f32(), vt_f32())\n    F32Ceil => typecheck_unary(st, vt_f32(), vt_f32())\n    F32Floor => typecheck_unary(st, vt_f32(), vt_f32())\n    F32Trunc => typecheck_unary(st, vt_f32(), vt_f32())\n    F32Nearest => typecheck_unary(st, vt_f32(), vt_f32())\n    F32Sqrt => typecheck_unary(st, vt_f32(), vt_f32())\n\n    // ===== f32 binary =====\n    F32Add => typecheck_binary(st, vt_f32(), vt_f32())\n    F32Sub => typecheck_binary(st, vt_f32(), vt_f32())\n    F32Mul => typecheck_binary(st, vt_f32(), vt_f32())\n    F32Div => typecheck_binary(st, vt_f32(), vt_f32())\n    F32Min => typecheck_binary(st, vt_f32(), vt_f32())\n    F32Max => typecheck_binary(st, vt_f32(), vt_f32())\n    F32Copysign => typecheck_binary(st, vt_f32(), vt_f32())\n\n    // ===== f64 unary =====\n    F64Abs => typecheck_unary(st, vt_f64(), vt_f64())\n    F64Neg => typecheck_unary(st, vt_f64(), vt_f64())\n    F64Ceil => typecheck_unary(st, vt_f64(), vt_f64())\n    F64Floor => typecheck_unary(st, vt_f64(), vt_f64())\n    F64Trunc => typecheck_unary(st, vt_f64(), vt_f64())\n    F64Nearest => typecheck_unary(st, vt_f64(), vt_f64())\n    F64Sqrt => typecheck_unary(st, vt_f64(), vt_f64())\n\n    // ===== f64 binary =====\n    F64Add => typecheck_binary(st, vt_f64(), vt_f64())\n    F64Sub => typecheck_binary(st, vt_f64(), vt_f64())\n    F64Mul => typecheck_binary(st, vt_f64(), vt_f64())\n    F64Div => typecheck_binary(st, vt_f64(), vt_f64())\n    F64Min => typecheck_binary(st, vt_f64(), vt_f64())\n    F64Max => typecheck_binary(st, vt_f64(), vt_f64())\n    F64Copysign => typecheck_binary(st, vt_f64(), vt_f64())\n\n    // ===== conversions / reinterprets =====\n\n    // i32.wrap_i64 : i64 -> i32\n    I32WrapI64 => typecheck_unary(st, vt_i64(), vt_i32())\n\n    // i32.trunc_f32/f64_{s,u} : f32/f64 -> i32\n    I32TruncF32S => typecheck_unary(st, vt_f32(), vt_i32())\n    I32TruncF32U => typecheck_unary(st, vt_f32(), vt_i32())\n    I32TruncF64S => typecheck_unary(st, vt_f64(), vt_i32())\n    I32TruncF64U => typecheck_unary(st, vt_f64(), vt_i32())\n\n    // i64.extend_i32_{s,u} : i32 -> i64\n    I64ExtendI32S => typecheck_unary(st, vt_i32(), vt_i64())\n    I64ExtendI32U => typecheck_unary(st, vt_i32(), vt_i64())\n\n    // i64.trunc_f32/f64_{s,u} : f32/f64 -> i64\n    I64TruncF32S => typecheck_unary(st, vt_f32(), vt_i64())\n    I64TruncF32U => typecheck_unary(st, vt_f32(), vt_i64())\n    I64TruncF64S => typecheck_unary(st, vt_f64(), vt_i64())\n    I64TruncF64U => typecheck_unary(st, vt_f64(), vt_i64())\n\n    // f32.convert_i32/i64_{s,u} : i32/i64 -> f32\n    F32ConvertI32S => typecheck_unary(st, vt_i32(), vt_f32())\n    F32ConvertI32U => typecheck_unary(st, vt_i32(), vt_f32())\n    F32ConvertI64S => typecheck_unary(st, vt_i64(), vt_f32())\n    F32ConvertI64U => typecheck_unary(st, vt_i64(), vt_f32())\n\n    // f32.demote_f64 : f64 -> f32\n    F32DemoteF64 => typecheck_unary(st, vt_f64(), vt_f32())\n\n    // f64.convert_i32/i64_{s,u} : i32/i64 -> f64\n    F64ConvertI32S => typecheck_unary(st, vt_i32(), vt_f64())\n    F64ConvertI32U => typecheck_unary(st, vt_i32(), vt_f64())\n    F64ConvertI64S => typecheck_unary(st, vt_i64(), vt_f64())\n    F64ConvertI64U => typecheck_unary(st, vt_i64(), vt_f64())\n\n    // f64.promote_f32 : f32 -> f64\n    F64PromoteF32 => typecheck_unary(st, vt_f32(), vt_f64())\n\n    // reinterprets\n    I32ReinterpretF32 => typecheck_unary(st, vt_f32(), vt_i32())\n    I64ReinterpretF64 => typecheck_unary(st, vt_f64(), vt_i64())\n    F32ReinterpretI32 => typecheck_unary(st, vt_i32(), vt_f32())\n    F64ReinterpretI64 => typecheck_unary(st, vt_i64(), vt_f64())\n\n    // sign-extension (unary)\n    I32Extend8S => typecheck_unary(st, vt_i32(), vt_i32())\n    I32Extend16S => typecheck_unary(st, vt_i32(), vt_i32())\n    I64Extend8S => typecheck_unary(st, vt_i64(), vt_i64())\n    I64Extend16S => typecheck_unary(st, vt_i64(), vt_i64())\n    I64Extend32S => typecheck_unary(st, vt_i64(), vt_i64())\n\n    // saturating trunc (same typing as trunc)\n    I32TruncSatF32S => typecheck_unary(st, vt_f32(), vt_i32())\n    I32TruncSatF32U => typecheck_unary(st, vt_f32(), vt_i32())\n    I32TruncSatF64S => typecheck_unary(st, vt_f64(), vt_i32())\n    I32TruncSatF64U => typecheck_unary(st, vt_f64(), vt_i32())\n    I64TruncSatF32S => typecheck_unary(st, vt_f32(), vt_i64())\n    I64TruncSatF32U => typecheck_unary(st, vt_f32(), vt_i64())\n    I64TruncSatF64S => typecheck_unary(st, vt_f64(), vt_i64())\n    I64TruncSatF64U => typecheck_unary(st, vt_f64(), vt_i64())\n    V128Not => typecheck_v128_unary(st)\n    V128And => typecheck_v128_binary(st)\n    V128Andnot => typecheck_v128_binary(st)\n    V128Or => typecheck_v128_binary(st)\n    V128Xor => typecheck_v128_binary(st)\n    V128Bitselect => typecheck_v128_ternary(st)\n    V128AnyTrue => typecheck_unary(st, vt_v128(), vt_i32())\n\n    // Plain v128 load/store\n    V128Load(ma) => typecheck_v128_mem_load(st, ma, 128)\n    V128Store(ma) => typecheck_v128_mem_store(st, ma, 128)\n\n    // Load and extend (64-bit loads)\n    V128Load8x8S(ma) => typecheck_v128_mem_load_extend64(st, ma)\n    V128Load8x8U(ma) => typecheck_v128_mem_load_extend64(st, ma)\n    V128Load16x4S(ma) => typecheck_v128_mem_load_extend64(st, ma)\n    V128Load16x4U(ma) => typecheck_v128_mem_load_extend64(st, ma)\n    V128Load32x2S(ma) => typecheck_v128_mem_load_extend64(st, ma)\n    V128Load32x2U(ma) => typecheck_v128_mem_load_extend64(st, ma)\n\n    // Splat loads\n    V128Load8Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 8)\n    V128Load16Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 16)\n    V128Load32Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 32)\n    V128Load64Splat(ma) => typecheck_v128_mem_load_splat(st, ma, 64)\n\n    // Lane loads\n    V128Load8Lane(ma, _) => typecheck_v128_load_lane(st, ma, 8)\n    V128Load16Lane(ma, _) => typecheck_v128_load_lane(st, ma, 16)\n    V128Load32Lane(ma, _) => typecheck_v128_load_lane(st, ma, 32)\n    V128Load64Lane(ma, _) => typecheck_v128_load_lane(st, ma, 64)\n\n    // Lane stores\n    V128Store8Lane(ma, _) => typecheck_v128_store_lane(st, ma, 8)\n    V128Store16Lane(ma, _) => typecheck_v128_store_lane(st, ma, 16)\n    V128Store32Lane(ma, _) => typecheck_v128_store_lane(st, ma, 32)\n    V128Store64Lane(ma, _) => typecheck_v128_store_lane(st, ma, 64)\n\n    // load*_zero\n    V128Load32Zero(ma) => typecheck_v128_mem_load_zero(st, ma, 32)\n    V128Load64Zero(ma) => typecheck_v128_mem_load_zero(st, ma, 64)\n    V128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>\n      typecheck_v128_const(st)\n    I8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>\n      // v128 v128 -> v128\n      typecheck_v128_binary(st)\n    I8x16Swizzle => typecheck_v128_binary(st) // v128 v128 -> v128\n    I8x16Splat => typecheck_splat(st, vt_i32()) // i32 -> v128 (only low 8 bits used)\n    I16x8Splat => typecheck_splat(st, vt_i32()) // i32 -> v128\n    I32x4Splat => typecheck_splat(st, vt_i32()) // i32 -> v128\n    I64x2Splat => typecheck_splat(st, vt_i64()) // i64 -> v128\n    F32x4Splat => typecheck_splat(st, vt_f32()) // f32 -> v128\n    F64x2Splat => typecheck_splat(st, vt_f64()) // f64 -> v128\n    I8x16ExtractLaneS(_) => typecheck_lane_extract(st, vt_i32())\n    I8x16ExtractLaneU(_) => typecheck_lane_extract(st, vt_i32())\n    I16x8ExtractLaneS(_) => typecheck_lane_extract(st, vt_i32())\n    I16x8ExtractLaneU(_) => typecheck_lane_extract(st, vt_i32())\n    I32x4ExtractLane(_) => typecheck_lane_extract(st, vt_i32())\n    I64x2ExtractLane(_) => typecheck_lane_extract(st, vt_i64())\n    F32x4ExtractLane(_) => typecheck_lane_extract(st, vt_f32())\n    F64x2ExtractLane(_) => typecheck_lane_extract(st, vt_f64())\n    I8x16ReplaceLane(_) => typecheck_lane_replace(st, vt_i32())\n    I16x8ReplaceLane(_) => typecheck_lane_replace(st, vt_i32())\n    I32x4ReplaceLane(_) => typecheck_lane_replace(st, vt_i32())\n    I64x2ReplaceLane(_) => typecheck_lane_replace(st, vt_i64())\n    F32x4ReplaceLane(_) => typecheck_lane_replace(st, vt_f32())\n    F64x2ReplaceLane(_) => typecheck_lane_replace(st, vt_f64())\n    I8x16Eq => typecheck_v128_compare(st)\n    I8x16Ne => typecheck_v128_compare(st)\n    I8x16LtS => typecheck_v128_compare(st)\n    I8x16LtU => typecheck_v128_compare(st)\n    I8x16GtS => typecheck_v128_compare(st)\n    I8x16GtU => typecheck_v128_compare(st)\n    I8x16LeS => typecheck_v128_compare(st)\n    I8x16LeU => typecheck_v128_compare(st)\n    I8x16GeS => typecheck_v128_compare(st)\n    I8x16GeU => typecheck_v128_compare(st)\n    I16x8Eq => typecheck_v128_compare(st)\n    I16x8Ne => typecheck_v128_compare(st)\n    I16x8LtS => typecheck_v128_compare(st)\n    I16x8LtU => typecheck_v128_compare(st)\n    I16x8GtS => typecheck_v128_compare(st)\n    I16x8GtU => typecheck_v128_compare(st)\n    I16x8LeS => typecheck_v128_compare(st)\n    I16x8LeU => typecheck_v128_compare(st)\n    I16x8GeS => typecheck_v128_compare(st)\n    I16x8GeU => typecheck_v128_compare(st)\n    I32x4Eq => typecheck_v128_compare(st)\n    I32x4Ne => typecheck_v128_compare(st)\n    I32x4LtS => typecheck_v128_compare(st)\n    I32x4LtU => typecheck_v128_compare(st)\n    I32x4GtS => typecheck_v128_compare(st)\n    I32x4GtU => typecheck_v128_compare(st)\n    I32x4LeS => typecheck_v128_compare(st)\n    I32x4LeU => typecheck_v128_compare(st)\n    I32x4GeS => typecheck_v128_compare(st)\n    I32x4GeU => typecheck_v128_compare(st)\n    F32x4Eq => typecheck_v128_compare(st)\n    F32x4Ne => typecheck_v128_compare(st)\n    F32x4Lt => typecheck_v128_compare(st)\n    F32x4Gt => typecheck_v128_compare(st)\n    F32x4Le => typecheck_v128_compare(st)\n    F32x4Ge => typecheck_v128_compare(st)\n    F64x2Eq => typecheck_v128_compare(st)\n    F64x2Ne => typecheck_v128_compare(st)\n    F64x2Lt => typecheck_v128_compare(st)\n    F64x2Gt => typecheck_v128_compare(st)\n    F64x2Le => typecheck_v128_compare(st)\n    F64x2Ge => typecheck_v128_compare(st)\n    I8x16Abs => typecheck_v128_unary(st)\n    I8x16Neg => typecheck_v128_unary(st)\n    I8x16Popcnt => typecheck_v128_unary(st)\n    I8x16AllTrue => typecheck_unary(st, vt_v128(), vt_i32())\n    I8x16Bitmask => typecheck_unary(st, vt_v128(), vt_i32())\n    I8x16NarrowI16x8S => typecheck_v128_binary(st)\n    I8x16NarrowI16x8U => typecheck_v128_binary(st)\n    I8x16Shl => typecheck_v128_shift(st)\n    I8x16ShrS => typecheck_v128_shift(st)\n    I8x16ShrU => typecheck_v128_shift(st)\n    I8x16Add => typecheck_v128_binary(st)\n    I8x16AddSatS => typecheck_v128_binary(st)\n    I8x16AddSatU => typecheck_v128_binary(st)\n    I8x16Sub => typecheck_v128_binary(st)\n    I8x16SubSatS => typecheck_v128_binary(st)\n    I8x16SubSatU => typecheck_v128_binary(st)\n    I8x16MinS => typecheck_v128_binary(st)\n    I8x16MinU => typecheck_v128_binary(st)\n    I8x16MaxS => typecheck_v128_binary(st)\n    I8x16MaxU => typecheck_v128_binary(st)\n    I8x16AvgrU => typecheck_v128_binary(st)\n    I16x8Abs => typecheck_v128_unary(st)\n    I16x8Neg => typecheck_v128_unary(st)\n    I16x8Q15mulrSatS => typecheck_v128_binary(st)\n    I16x8AllTrue => typecheck_unary(st, vt_v128(), vt_i32())\n    I16x8Bitmask => typecheck_unary(st, vt_v128(), vt_i32())\n    I16x8NarrowI32x4S => typecheck_v128_binary(st)\n    I16x8NarrowI32x4U => typecheck_v128_binary(st)\n    I16x8ExtendLowI8x16S => typecheck_v128_unary(st)\n    I16x8ExtendHighI8x16S => typecheck_v128_unary(st)\n    I16x8ExtendLowI8x16U => typecheck_v128_unary(st)\n    I16x8ExtendHighI8x16U => typecheck_v128_unary(st)\n    I16x8Shl => typecheck_v128_shift(st)\n    I16x8ShrS => typecheck_v128_shift(st)\n    I16x8ShrU => typecheck_v128_shift(st)\n    I16x8Add => typecheck_v128_binary(st)\n    I16x8AddSatS => typecheck_v128_binary(st)\n    I16x8AddSatU => typecheck_v128_binary(st)\n    I16x8Sub => typecheck_v128_binary(st)\n    I16x8SubSatS => typecheck_v128_binary(st)\n    I16x8SubSatU => typecheck_v128_binary(st)\n    I16x8Mul => typecheck_v128_binary(st)\n    I16x8MinS => typecheck_v128_binary(st)\n    I16x8MinU => typecheck_v128_binary(st)\n    I16x8MaxS => typecheck_v128_binary(st)\n    I16x8MaxU => typecheck_v128_binary(st)\n    I16x8AvgrU => typecheck_v128_binary(st)\n    I32x4Abs => typecheck_v128_unary(st)\n    I32x4Neg => typecheck_v128_unary(st)\n    I32x4AllTrue => typecheck_unary(st, vt_v128(), vt_i32())\n    I32x4Bitmask => typecheck_unary(st, vt_v128(), vt_i32())\n    I32x4ExtendLowI16x8S => typecheck_v128_unary(st)\n    I32x4ExtendHighI16x8S => typecheck_v128_unary(st)\n    I32x4ExtendLowI16x8U => typecheck_v128_unary(st)\n    I32x4ExtendHighI16x8U => typecheck_v128_unary(st)\n    I32x4Shl => typecheck_v128_shift(st)\n    I32x4ShrS => typecheck_v128_shift(st)\n    I32x4ShrU => typecheck_v128_shift(st)\n    I32x4Add => typecheck_v128_binary(st)\n    I32x4Sub => typecheck_v128_binary(st)\n    I32x4Mul => typecheck_v128_binary(st)\n    I32x4MinS => typecheck_v128_binary(st)\n    I32x4MinU => typecheck_v128_binary(st)\n    I32x4MaxS => typecheck_v128_binary(st)\n    I32x4MaxU => typecheck_v128_binary(st)\n    I32x4DotI16x8S => typecheck_v128_binary(st)\n    I64x2Abs => typecheck_v128_unary(st)\n    I64x2Neg => typecheck_v128_unary(st)\n    I64x2AllTrue => typecheck_unary(st, vt_v128(), vt_i32())\n    I64x2Bitmask => typecheck_unary(st, vt_v128(), vt_i32())\n    I64x2Shl => typecheck_v128_shift(st)\n    I64x2ShrS => typecheck_v128_shift(st)\n    I64x2ShrU => typecheck_v128_shift(st)\n    I64x2Add => typecheck_v128_binary(st)\n    I64x2Sub => typecheck_v128_binary(st)\n    I64x2Mul => typecheck_v128_binary(st)\n    I64x2Eq => typecheck_v128_compare(st)\n    I64x2Ne => typecheck_v128_compare(st)\n    I64x2LtS => typecheck_v128_compare(st)\n    I64x2GtS => typecheck_v128_compare(st)\n    I64x2LeS => typecheck_v128_compare(st)\n    I64x2GeS => typecheck_v128_compare(st)\n    F32x4Abs => typecheck_v128_unary(st)\n    F32x4Neg => typecheck_v128_unary(st)\n    F32x4Sqrt => typecheck_v128_unary(st)\n    F32x4Add => typecheck_v128_binary(st)\n    F32x4Sub => typecheck_v128_binary(st)\n    F32x4Mul => typecheck_v128_binary(st)\n    F32x4Div => typecheck_v128_binary(st)\n    F32x4Min => typecheck_v128_binary(st)\n    F32x4Max => typecheck_v128_binary(st)\n    F32x4Pmin => typecheck_v128_binary(st)\n    F32x4Pmax => typecheck_v128_binary(st)\n    F32x4Ceil => typecheck_v128_unary(st)\n    F32x4Floor => typecheck_v128_unary(st)\n    F32x4Trunc => typecheck_v128_unary(st)\n    F32x4Nearest => typecheck_v128_unary(st)\n    F64x2Abs => typecheck_v128_unary(st)\n    F64x2Neg => typecheck_v128_unary(st)\n    F64x2Sqrt => typecheck_v128_unary(st)\n    F64x2Add => typecheck_v128_binary(st)\n    F64x2Sub => typecheck_v128_binary(st)\n    F64x2Mul => typecheck_v128_binary(st)\n    F64x2Div => typecheck_v128_binary(st)\n    F64x2Min => typecheck_v128_binary(st)\n    F64x2Max => typecheck_v128_binary(st)\n    F64x2Pmin => typecheck_v128_binary(st)\n    F64x2Pmax => typecheck_v128_binary(st)\n    F64x2Ceil => typecheck_v128_unary(st)\n    F64x2Floor => typecheck_v128_unary(st)\n    F64x2Trunc => typecheck_v128_unary(st)\n    F64x2Nearest => typecheck_v128_unary(st)\n    I32x4TruncSatF32x4S => typecheck_v128_unary(st)\n    I32x4TruncSatF32x4U => typecheck_v128_unary(st)\n    F32x4ConvertI32x4S => typecheck_v128_unary(st)\n    F32x4ConvertI32x4U => typecheck_v128_unary(st)\n    I32x4TruncSatF64x2SZero => typecheck_v128_unary(st)\n    I32x4TruncSatF64x2UZero => typecheck_v128_unary(st)\n    F64x2ConvertLowI32x4S => typecheck_v128_unary(st)\n    F64x2ConvertLowI32x4U => typecheck_v128_unary(st)\n    F32x4DemoteF64x2Zero => typecheck_v128_unary(st)\n    F64x2PromoteLowF32x4 => typecheck_v128_unary(st)\n    I8x16RelaxedSwizzle => typecheck_v128_binary(st)\n    I32x4RelaxedTruncF32x4S => typecheck_v128_unary(st)\n    I32x4RelaxedTruncF32x4U => typecheck_v128_unary(st)\n    I32x4RelaxedTruncZeroF64x2S => typecheck_v128_unary(st)\n    I32x4RelaxedTruncZeroF64x2U => typecheck_v128_unary(st)\n    F32x4RelaxedMadd => typecheck_v128_ternary(st)\n    F32x4RelaxedNmadd => typecheck_v128_ternary(st)\n    F64x2RelaxedMadd => typecheck_v128_ternary(st)\n    F64x2RelaxedNmadd => typecheck_v128_ternary(st)\n    I8x16RelaxedLaneselect => typecheck_v128_ternary(st)\n    I16x8RelaxedLaneselect => typecheck_v128_ternary(st)\n    I32x4RelaxedLaneselect => typecheck_v128_ternary(st)\n    I64x2RelaxedLaneselect => typecheck_v128_ternary(st)\n    F32x4RelaxedMin => typecheck_v128_binary(st)\n    F32x4RelaxedMax => typecheck_v128_binary(st)\n    F64x2RelaxedMin => typecheck_v128_binary(st)\n    F64x2RelaxedMax => typecheck_v128_binary(st)\n    I16x8RelaxedQ15mulrS => typecheck_v128_binary(st)\n    I16x8RelaxedDotI8x16I7x16S => typecheck_v128_binary(st)\n    I32x4RelaxedDotI8x16I7x16AddS => typecheck_v128_ternary(st)\n\n    // ===== extadd pairwise (unary) =====\n    I16x8ExtaddPairwiseI8x16S => typecheck_v128_unary(st)\n    I16x8ExtaddPairwiseI8x16U => typecheck_v128_unary(st)\n    I32x4ExtaddPairwiseI16x8S => typecheck_v128_unary(st)\n    I32x4ExtaddPairwiseI16x8U => typecheck_v128_unary(st)\n\n    // ===== extend (unary) =====\n    I64x2ExtendLowI32x4S => typecheck_v128_unary(st)\n    I64x2ExtendLowI32x4U => typecheck_v128_unary(st)\n    I64x2ExtendHighI32x4S => typecheck_v128_unary(st)\n    I64x2ExtendHighI32x4U => typecheck_v128_unary(st)\n\n    // ===== extmul low/high (binary) =====\n    I16x8ExtmulLowI8x16S => typecheck_v128_binary(st)\n    I16x8ExtmulLowI8x16U => typecheck_v128_binary(st)\n    I16x8ExtmulHighI8x16S => typecheck_v128_binary(st)\n    I16x8ExtmulHighI8x16U => typecheck_v128_binary(st)\n    I32x4ExtmulLowI16x8S => typecheck_v128_binary(st)\n    I32x4ExtmulLowI16x8U => typecheck_v128_binary(st)\n    I32x4ExtmulHighI16x8S => typecheck_v128_binary(st)\n    I32x4ExtmulHighI16x8U => typecheck_v128_binary(st)\n    I64x2ExtmulLowI32x4S => typecheck_v128_binary(st)\n    I64x2ExtmulLowI32x4U => typecheck_v128_binary(st)\n    I64x2ExtmulHighI32x4S => typecheck_v128_binary(st)\n    I64x2ExtmulHighI32x4U => typecheck_v128_binary(st)\n\n    // _ => Err(\"unimplemented\")\n  }\n}\n\n///|\npub impl Typecheck for TInstr with typecheck(self, st) {\n  match self {\n    // === Constants ===\n    TI32Const(_) => Ok(st.push1(NumTypeValType(I32NumType)))\n    TI64Const(_) => Ok(st.push1(NumTypeValType(I64NumType)))\n    TF32Const(_) => Ok(st.push1(NumTypeValType(F32NumType)))\n    TF64Const(_) => Ok(st.push1(NumTypeValType(F64NumType)))\n    TRefNull(ht) => typecheck_ref_null(st, ht)\n    TRefFunc(f) => typecheck_ref_func(st, f)\n    TV128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) =>\n      typecheck_v128_const(st)\n\n    // === Nullary ===\n    TUnreachable => Ok(TcState::{ ..st, reachable: false })\n    TNop => Ok(st)\n    TLocalGet(i) => typecheck_local_get(st, i)\n    TGlobalGet(i) => typecheck_global_get(st, i)\n    TMemorySize(m) => typecheck_memory_size(st, m)\n    TTableSize(t) => typecheck_table_size(st, t)\n\n    // === Unary ===\n    TUnary(op, child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      match op {\n        // Scalar\n        I32EqzOp => typecheck_unary(st1, vt_i32(), vt_i32())\n        I64EqzOp => typecheck_unary(st1, vt_i64(), vt_i32())\n        I32ClzOp => typecheck_unary(st1, vt_i32(), vt_i32())\n        I32CtzOp => typecheck_unary(st1, vt_i32(), vt_i32())\n        I32PopcntOp => typecheck_unary(st1, vt_i32(), vt_i32())\n        I64ClzOp => typecheck_unary(st1, vt_i64(), vt_i64())\n        I64CtzOp => typecheck_unary(st1, vt_i64(), vt_i64())\n        I64PopcntOp => typecheck_unary(st1, vt_i64(), vt_i64())\n        F32AbsOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F32NegOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F32CeilOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F32FloorOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F32TruncOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F32NearestOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F32SqrtOp => typecheck_unary(st1, vt_f32(), vt_f32())\n        F64AbsOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        F64NegOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        F64CeilOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        F64FloorOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        F64TruncOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        F64NearestOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        F64SqrtOp => typecheck_unary(st1, vt_f64(), vt_f64())\n        I32WrapI64Op => typecheck_unary(st1, vt_i64(), vt_i32())\n        I32TruncF32SOp => typecheck_unary(st1, vt_f32(), vt_i32())\n        I32TruncF32UOp => typecheck_unary(st1, vt_f32(), vt_i32())\n        I32TruncF64SOp => typecheck_unary(st1, vt_f64(), vt_i32())\n        I32TruncF64UOp => typecheck_unary(st1, vt_f64(), vt_i32())\n        I64ExtendI32SOp => typecheck_unary(st1, vt_i32(), vt_i64())\n        I64ExtendI32UOp => typecheck_unary(st1, vt_i32(), vt_i64())\n        I64TruncF32SOp => typecheck_unary(st1, vt_f32(), vt_i64())\n        I64TruncF32UOp => typecheck_unary(st1, vt_f32(), vt_i64())\n        I64TruncF64SOp => typecheck_unary(st1, vt_f64(), vt_i64())\n        I64TruncF64UOp => typecheck_unary(st1, vt_f64(), vt_i64())\n        F32ConvertI32SOp => typecheck_unary(st1, vt_i32(), vt_f32())\n        F32ConvertI32UOp => typecheck_unary(st1, vt_i32(), vt_f32())\n        F32ConvertI64SOp => typecheck_unary(st1, vt_i64(), vt_f32())\n        F32ConvertI64UOp => typecheck_unary(st1, vt_i64(), vt_f32())\n        F32DemoteF64Op => typecheck_unary(st1, vt_f64(), vt_f32())\n        F64ConvertI32SOp => typecheck_unary(st1, vt_i32(), vt_f64())\n        F64ConvertI32UOp => typecheck_unary(st1, vt_i32(), vt_f64())\n        F64ConvertI64SOp => typecheck_unary(st1, vt_i64(), vt_f64())\n        F64ConvertI64UOp => typecheck_unary(st1, vt_i64(), vt_f64())\n        F64PromoteF32Op => typecheck_unary(st1, vt_f32(), vt_f64())\n        I32ReinterpretF32Op => typecheck_unary(st1, vt_f32(), vt_i32())\n        I64ReinterpretF64Op => typecheck_unary(st1, vt_f64(), vt_i64())\n        F32ReinterpretI32Op => typecheck_unary(st1, vt_i32(), vt_f32())\n        F64ReinterpretI64Op => typecheck_unary(st1, vt_i64(), vt_f64())\n        I32Extend8SOp => typecheck_unary(st1, vt_i32(), vt_i32())\n        I32Extend16SOp => typecheck_unary(st1, vt_i32(), vt_i32())\n        I64Extend8SOp => typecheck_unary(st1, vt_i64(), vt_i64())\n        I64Extend16SOp => typecheck_unary(st1, vt_i64(), vt_i64())\n        I64Extend32SOp => typecheck_unary(st1, vt_i64(), vt_i64())\n        I32TruncSatF32SOp => typecheck_unary(st1, vt_f32(), vt_i32())\n        I32TruncSatF32UOp => typecheck_unary(st1, vt_f32(), vt_i32())\n        I32TruncSatF64SOp => typecheck_unary(st1, vt_f64(), vt_i32())\n        I32TruncSatF64UOp => typecheck_unary(st1, vt_f64(), vt_i32())\n        I64TruncSatF32SOp => typecheck_unary(st1, vt_f32(), vt_i64())\n        I64TruncSatF32UOp => typecheck_unary(st1, vt_f32(), vt_i64())\n        I64TruncSatF64SOp => typecheck_unary(st1, vt_f64(), vt_i64())\n        I64TruncSatF64UOp => typecheck_unary(st1, vt_f64(), vt_i64())\n\n        // SIMD: Unary\n        V128NotOp => typecheck_v128_unary(st1)\n        I8x16AbsOp => typecheck_v128_unary(st1)\n        I8x16NegOp => typecheck_v128_unary(st1)\n        I8x16PopcntOp => typecheck_v128_unary(st1)\n        I16x8AbsOp => typecheck_v128_unary(st1)\n        I16x8NegOp => typecheck_v128_unary(st1)\n        I32x4AbsOp => typecheck_v128_unary(st1)\n        I32x4NegOp => typecheck_v128_unary(st1)\n        I64x2AbsOp => typecheck_v128_unary(st1)\n        I64x2NegOp => typecheck_v128_unary(st1)\n        F32x4AbsOp => typecheck_v128_unary(st1)\n        F32x4NegOp => typecheck_v128_unary(st1)\n        F32x4SqrtOp => typecheck_v128_unary(st1)\n        F32x4CeilOp => typecheck_v128_unary(st1)\n        F32x4FloorOp => typecheck_v128_unary(st1)\n        F32x4TruncOp => typecheck_v128_unary(st1)\n        F32x4NearestOp => typecheck_v128_unary(st1)\n        F64x2AbsOp => typecheck_v128_unary(st1)\n        F64x2NegOp => typecheck_v128_unary(st1)\n        F64x2SqrtOp => typecheck_v128_unary(st1)\n        F64x2CeilOp => typecheck_v128_unary(st1)\n        F64x2FloorOp => typecheck_v128_unary(st1)\n        F64x2TruncOp => typecheck_v128_unary(st1)\n        F64x2NearestOp => typecheck_v128_unary(st1)\n\n        // SIMD: Unary (v128 -> i32)\n        V128AnyTrueOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I8x16AllTrueOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I8x16BitmaskOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I16x8AllTrueOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I16x8BitmaskOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I32x4AllTrueOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I32x4BitmaskOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I64x2AllTrueOp => typecheck_unary(st1, vt_v128(), vt_i32())\n        I64x2BitmaskOp => typecheck_unary(st1, vt_v128(), vt_i32())\n\n        // SIMD: Extend/narrow/pairwise\n        I16x8ExtendLowI8x16SOp => typecheck_v128_unary(st1)\n        I16x8ExtendHighI8x16SOp => typecheck_v128_unary(st1)\n        I16x8ExtendLowI8x16UOp => typecheck_v128_unary(st1)\n        I16x8ExtendHighI8x16UOp => typecheck_v128_unary(st1)\n        I32x4ExtendLowI16x8SOp => typecheck_v128_unary(st1)\n        I32x4ExtendHighI16x8SOp => typecheck_v128_unary(st1)\n        I32x4ExtendLowI16x8UOp => typecheck_v128_unary(st1)\n        I32x4ExtendHighI16x8UOp => typecheck_v128_unary(st1)\n        I64x2ExtendLowI32x4SOp => typecheck_v128_unary(st1)\n        I64x2ExtendHighI32x4SOp => typecheck_v128_unary(st1)\n        I64x2ExtendLowI32x4UOp => typecheck_v128_unary(st1)\n        I64x2ExtendHighI32x4UOp => typecheck_v128_unary(st1)\n        I16x8ExtaddPairwiseI8x16SOp => typecheck_v128_unary(st1)\n        I16x8ExtaddPairwiseI8x16UOp => typecheck_v128_unary(st1)\n        I32x4ExtaddPairwiseI16x8SOp => typecheck_v128_unary(st1)\n        I32x4ExtaddPairwiseI16x8UOp => typecheck_v128_unary(st1)\n\n        // SIMD: Conversions\n        F32x4DemoteF64x2ZeroOp => typecheck_v128_unary(st1)\n        F64x2PromoteLowF32x4Op => typecheck_v128_unary(st1)\n        I32x4TruncSatF32x4SOp => typecheck_v128_unary(st1)\n        I32x4TruncSatF32x4UOp => typecheck_v128_unary(st1)\n        F32x4ConvertI32x4SOp => typecheck_v128_unary(st1)\n        F32x4ConvertI32x4UOp => typecheck_v128_unary(st1)\n        I32x4TruncSatF64x2SZeroOp => typecheck_v128_unary(st1)\n        I32x4TruncSatF64x2UZeroOp => typecheck_v128_unary(st1)\n        F64x2ConvertLowI32x4SOp => typecheck_v128_unary(st1)\n        F64x2ConvertLowI32x4UOp => typecheck_v128_unary(st1)\n\n        // SIMD: Relaxed\n        I32x4RelaxedTruncF32x4SOp => typecheck_v128_unary(st1)\n        I32x4RelaxedTruncF32x4UOp => typecheck_v128_unary(st1)\n        I32x4RelaxedTruncZeroF64x2SOp => typecheck_v128_unary(st1)\n        I32x4RelaxedTruncZeroF64x2UOp => typecheck_v128_unary(st1)\n      }\n    }\n    TDrop(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_drop(st1)\n    }\n    TLocalSet(i, child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_local_set(st1, i)\n    }\n    TLocalTee(i, child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_local_tee(st1, i)\n    }\n    TGlobalSet(i, child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_global_set(st1, i)\n    }\n    TRefIsNull(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_ref_is_null(st1)\n    }\n    TRefAsNonNull(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_ref_as_non_null(st1)\n    }\n    TI31GetS(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_i31_get(st1)\n    }\n    TI31GetU(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_i31_get(st1)\n    }\n    TRefI31(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_ref_i31(st1)\n    }\n    TArrayLen(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_array_len(st1)\n    }\n    TAnyConvertExtern(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_any_convert_extern(st1)\n    }\n    TExternConvertAny(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_extern_convert_any(st1)\n    }\n    TThrowRef(child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      typecheck_throw_ref(st1)\n    }\n\n    // === Binary ===\n    TBinary(op, left, right) => {\n      let st1 = match Typecheck::typecheck(left, st) {\n        Ok(st1) => st1\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(right, st1) {\n        Ok(st2) => st2\n        Err(t) => return Err(t)\n      }\n      match op {\n        // Scalar Comparisons\n        I32EqOp => typecheck_compare(st2, vt_i32())\n        I32NeOp => typecheck_compare(st2, vt_i32())\n        I32LtSOp => typecheck_compare(st2, vt_i32())\n        I32LtUOp => typecheck_compare(st2, vt_i32())\n        I32GtSOp => typecheck_compare(st2, vt_i32())\n        I32GtUOp => typecheck_compare(st2, vt_i32())\n        I32LeSOp => typecheck_compare(st2, vt_i32())\n        I32LeUOp => typecheck_compare(st2, vt_i32())\n        I32GeSOp => typecheck_compare(st2, vt_i32())\n        I32GeUOp => typecheck_compare(st2, vt_i32())\n        I64EqOp => typecheck_compare(st2, vt_i64())\n        I64NeOp => typecheck_compare(st2, vt_i64())\n        I64LtSOp => typecheck_compare(st2, vt_i64())\n        I64LtUOp => typecheck_compare(st2, vt_i64())\n        I64GtSOp => typecheck_compare(st2, vt_i64())\n        I64GtUOp => typecheck_compare(st2, vt_i64())\n        I64LeSOp => typecheck_compare(st2, vt_i64())\n        I64LeUOp => typecheck_compare(st2, vt_i64())\n        I64GeSOp => typecheck_compare(st2, vt_i64())\n        I64GeUOp => typecheck_compare(st2, vt_i64())\n        F32EqOp => typecheck_compare(st2, vt_f32())\n        F32NeOp => typecheck_compare(st2, vt_f32())\n        F32LtOp => typecheck_compare(st2, vt_f32())\n        F32GtOp => typecheck_compare(st2, vt_f32())\n        F32LeOp => typecheck_compare(st2, vt_f32())\n        F32GeOp => typecheck_compare(st2, vt_f32())\n        F64EqOp => typecheck_compare(st2, vt_f64())\n        F64NeOp => typecheck_compare(st2, vt_f64())\n        F64LtOp => typecheck_compare(st2, vt_f64())\n        F64GtOp => typecheck_compare(st2, vt_f64())\n        F64LeOp => typecheck_compare(st2, vt_f64())\n        F64GeOp => typecheck_compare(st2, vt_f64())\n\n        // Scalar Arithmetic\n        I32AddOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32SubOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32MulOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32DivSOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32DivUOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32RemSOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32RemUOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32AndOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32OrOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32XorOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32ShlOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32ShrSOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32ShrUOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32RotlOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I32RotrOp => typecheck_binary(st2, vt_i32(), vt_i32())\n        I64AddOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64SubOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64MulOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64DivSOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64DivUOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64RemSOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64RemUOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64AndOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64OrOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64XorOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64ShlOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64ShrSOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64ShrUOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64RotlOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        I64RotrOp => typecheck_binary(st2, vt_i64(), vt_i64())\n        F32AddOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F32SubOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F32MulOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F32DivOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F32MinOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F32MaxOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F32CopysignOp => typecheck_binary(st2, vt_f32(), vt_f32())\n        F64AddOp => typecheck_binary(st2, vt_f64(), vt_f64())\n        F64SubOp => typecheck_binary(st2, vt_f64(), vt_f64())\n        F64MulOp => typecheck_binary(st2, vt_f64(), vt_f64())\n        F64DivOp => typecheck_binary(st2, vt_f64(), vt_f64())\n        F64MinOp => typecheck_binary(st2, vt_f64(), vt_f64())\n        F64MaxOp => typecheck_binary(st2, vt_f64(), vt_f64())\n        F64CopysignOp => typecheck_binary(st2, vt_f64(), vt_f64())\n\n        // SIMD Binary\n        V128AndOp => typecheck_v128_binary(st2)\n        V128AndnotOp => typecheck_v128_binary(st2)\n        V128OrOp => typecheck_v128_binary(st2)\n        V128XorOp => typecheck_v128_binary(st2)\n        I8x16EqOp => typecheck_v128_compare(st2)\n        I8x16NeOp => typecheck_v128_compare(st2)\n        I8x16LtSOp => typecheck_v128_compare(st2)\n        I8x16LtUOp => typecheck_v128_compare(st2)\n        I8x16GtSOp => typecheck_v128_compare(st2)\n        I8x16GtUOp => typecheck_v128_compare(st2)\n        I8x16LeSOp => typecheck_v128_compare(st2)\n        I8x16LeUOp => typecheck_v128_compare(st2)\n        I8x16GeSOp => typecheck_v128_compare(st2)\n        I8x16GeUOp => typecheck_v128_compare(st2)\n        I16x8EqOp => typecheck_v128_compare(st2)\n        I16x8NeOp => typecheck_v128_compare(st2)\n        I16x8LtSOp => typecheck_v128_compare(st2)\n        I16x8LtUOp => typecheck_v128_compare(st2)\n        I16x8GtSOp => typecheck_v128_compare(st2)\n        I16x8GtUOp => typecheck_v128_compare(st2)\n        I16x8LeSOp => typecheck_v128_compare(st2)\n        I16x8LeUOp => typecheck_v128_compare(st2)\n        I16x8GeSOp => typecheck_v128_compare(st2)\n        I16x8GeUOp => typecheck_v128_compare(st2)\n        I32x4EqOp => typecheck_v128_compare(st2)\n        I32x4NeOp => typecheck_v128_compare(st2)\n        I32x4LtSOp => typecheck_v128_compare(st2)\n        I32x4LtUOp => typecheck_v128_compare(st2)\n        I32x4GtSOp => typecheck_v128_compare(st2)\n        I32x4GtUOp => typecheck_v128_compare(st2)\n        I32x4LeSOp => typecheck_v128_compare(st2)\n        I32x4LeUOp => typecheck_v128_compare(st2)\n        I32x4GeSOp => typecheck_v128_compare(st2)\n        I32x4GeUOp => typecheck_v128_compare(st2)\n        I64x2EqOp => typecheck_v128_compare(st2)\n        I64x2NeOp => typecheck_v128_compare(st2)\n        I64x2LtSOp => typecheck_v128_compare(st2)\n        I64x2GtSOp => typecheck_v128_compare(st2)\n        I64x2LeSOp => typecheck_v128_compare(st2)\n        I64x2GeSOp => typecheck_v128_compare(st2)\n        F32x4EqOp => typecheck_v128_compare(st2)\n        F32x4NeOp => typecheck_v128_compare(st2)\n        F32x4LtOp => typecheck_v128_compare(st2)\n        F32x4GtOp => typecheck_v128_compare(st2)\n        F32x4LeOp => typecheck_v128_compare(st2)\n        F32x4GeOp => typecheck_v128_compare(st2)\n        F64x2EqOp => typecheck_v128_compare(st2)\n        F64x2NeOp => typecheck_v128_compare(st2)\n        F64x2LtOp => typecheck_v128_compare(st2)\n        F64x2GtOp => typecheck_v128_compare(st2)\n        F64x2LeOp => typecheck_v128_compare(st2)\n        F64x2GeOp => typecheck_v128_compare(st2)\n        I8x16AddOp => typecheck_v128_binary(st2)\n        I8x16AddSatSOp => typecheck_v128_binary(st2)\n        I8x16AddSatUOp => typecheck_v128_binary(st2)\n        I8x16SubOp => typecheck_v128_binary(st2)\n        I8x16SubSatSOp => typecheck_v128_binary(st2)\n        I8x16SubSatUOp => typecheck_v128_binary(st2)\n        I8x16MinSOp => typecheck_v128_binary(st2)\n        I8x16MinUOp => typecheck_v128_binary(st2)\n        I8x16MaxSOp => typecheck_v128_binary(st2)\n        I8x16MaxUOp => typecheck_v128_binary(st2)\n        I8x16AvgrUOp => typecheck_v128_binary(st2)\n        I8x16NarrowI16x8SOp => typecheck_v128_binary(st2)\n        I8x16NarrowI16x8UOp => typecheck_v128_binary(st2)\n        I16x8AddOp => typecheck_v128_binary(st2)\n        I16x8AddSatSOp => typecheck_v128_binary(st2)\n        I16x8AddSatUOp => typecheck_v128_binary(st2)\n        I16x8SubOp => typecheck_v128_binary(st2)\n        I16x8SubSatSOp => typecheck_v128_binary(st2)\n        I16x8SubSatUOp => typecheck_v128_binary(st2)\n        I16x8MulOp => typecheck_v128_binary(st2)\n        I16x8MinSOp => typecheck_v128_binary(st2)\n        I16x8MinUOp => typecheck_v128_binary(st2)\n        I16x8MaxSOp => typecheck_v128_binary(st2)\n        I16x8MaxUOp => typecheck_v128_binary(st2)\n        I16x8AvgrUOp => typecheck_v128_binary(st2)\n        I16x8Q15mulrSatSOp => typecheck_v128_binary(st2)\n        I16x8NarrowI32x4SOp => typecheck_v128_binary(st2)\n        I16x8NarrowI32x4UOp => typecheck_v128_binary(st2)\n        I16x8ExtmulLowI8x16SOp => typecheck_v128_binary(st2)\n        I16x8ExtmulHighI8x16SOp => typecheck_v128_binary(st2)\n        I16x8ExtmulLowI8x16UOp => typecheck_v128_binary(st2)\n        I16x8ExtmulHighI8x16UOp => typecheck_v128_binary(st2)\n        I32x4AddOp => typecheck_v128_binary(st2)\n        I32x4SubOp => typecheck_v128_binary(st2)\n        I32x4MulOp => typecheck_v128_binary(st2)\n        I32x4MinSOp => typecheck_v128_binary(st2)\n        I32x4MinUOp => typecheck_v128_binary(st2)\n        I32x4MaxSOp => typecheck_v128_binary(st2)\n        I32x4MaxUOp => typecheck_v128_binary(st2)\n        I32x4DotI16x8SOp => typecheck_v128_binary(st2)\n        I32x4ExtmulLowI16x8SOp => typecheck_v128_binary(st2)\n        I32x4ExtmulHighI16x8SOp => typecheck_v128_binary(st2)\n        I32x4ExtmulLowI16x8UOp => typecheck_v128_binary(st2)\n        I32x4ExtmulHighI16x8UOp => typecheck_v128_binary(st2)\n        I64x2AddOp => typecheck_v128_binary(st2)\n        I64x2SubOp => typecheck_v128_binary(st2)\n        I64x2MulOp => typecheck_v128_binary(st2)\n        I64x2ExtmulLowI32x4SOp => typecheck_v128_binary(st2)\n        I64x2ExtmulHighI32x4SOp => typecheck_v128_binary(st2)\n        I64x2ExtmulLowI32x4UOp => typecheck_v128_binary(st2)\n        I64x2ExtmulHighI32x4UOp => typecheck_v128_binary(st2)\n        F32x4AddOp => typecheck_v128_binary(st2)\n        F32x4SubOp => typecheck_v128_binary(st2)\n        F32x4MulOp => typecheck_v128_binary(st2)\n        F32x4DivOp => typecheck_v128_binary(st2)\n        F32x4MinOp => typecheck_v128_binary(st2)\n        F32x4MaxOp => typecheck_v128_binary(st2)\n        F32x4PminOp => typecheck_v128_binary(st2)\n        F32x4PmaxOp => typecheck_v128_binary(st2)\n        F64x2AddOp => typecheck_v128_binary(st2)\n        F64x2SubOp => typecheck_v128_binary(st2)\n        F64x2MulOp => typecheck_v128_binary(st2)\n        F64x2DivOp => typecheck_v128_binary(st2)\n        F64x2MinOp => typecheck_v128_binary(st2)\n        F64x2MaxOp => typecheck_v128_binary(st2)\n        F64x2PminOp => typecheck_v128_binary(st2)\n        F64x2PmaxOp => typecheck_v128_binary(st2)\n        F32x4RelaxedMinOp => typecheck_v128_binary(st2)\n        F32x4RelaxedMaxOp => typecheck_v128_binary(st2)\n        F64x2RelaxedMinOp => typecheck_v128_binary(st2)\n        F64x2RelaxedMaxOp => typecheck_v128_binary(st2)\n        I16x8RelaxedQ15mulrSOp => typecheck_v128_binary(st2)\n        I16x8RelaxedDotI8x16I7x16SOp => typecheck_v128_binary(st2)\n      }\n    }\n    TRefEq(left, right) => {\n      let st1 = match Typecheck::typecheck(left, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(right, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_ref_eq(st2)\n    }\n    TStore(op, ma, addr, val) => {\n      let st1 = match Typecheck::typecheck(addr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(val, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match op {\n        I32StoreOp => typecheck_store(st2, ma, 32, vt_i32())\n        I64StoreOp => typecheck_store(st2, ma, 64, vt_i64())\n        F32StoreOp => typecheck_store(st2, ma, 32, vt_f32())\n        F64StoreOp => typecheck_store(st2, ma, 64, vt_f64())\n        I32Store8Op => typecheck_store(st2, ma, 8, vt_i32())\n        I32Store16Op => typecheck_store(st2, ma, 16, vt_i32())\n        I64Store8Op => typecheck_store(st2, ma, 8, vt_i64())\n        I64Store16Op => typecheck_store(st2, ma, 16, vt_i64())\n        I64Store32Op => typecheck_store(st2, ma, 32, vt_i64())\n        V128StoreOp => typecheck_v128_mem_store(st2, ma, 128)\n      }\n    }\n\n    // === Load ===\n    TLoad(op, ma, addr) => {\n      let st1 = match Typecheck::typecheck(addr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match op {\n        I32LoadOp => typecheck_load(st1, ma, 32, vt_i32())\n        I64LoadOp => typecheck_load(st1, ma, 64, vt_i64())\n        F32LoadOp => typecheck_load(st1, ma, 32, vt_f32())\n        F64LoadOp => typecheck_load(st1, ma, 64, vt_f64())\n        I32Load8SOp => typecheck_load(st1, ma, 8, vt_i32())\n        I32Load8UOp => typecheck_load(st1, ma, 8, vt_i32())\n        I32Load16SOp => typecheck_load(st1, ma, 16, vt_i32())\n        I32Load16UOp => typecheck_load(st1, ma, 16, vt_i32())\n        I64Load8SOp => typecheck_load(st1, ma, 8, vt_i64())\n        I64Load8UOp => typecheck_load(st1, ma, 8, vt_i64())\n        I64Load16SOp => typecheck_load(st1, ma, 16, vt_i64())\n        I64Load16UOp => typecheck_load(st1, ma, 16, vt_i64())\n        I64Load32SOp => typecheck_load(st1, ma, 32, vt_i64())\n        I64Load32UOp => typecheck_load(st1, ma, 32, vt_i64())\n        V128LoadOp => typecheck_v128_mem_load(st1, ma, 128)\n        V128Load8x8SOp => typecheck_v128_mem_load_extend64(st1, ma)\n        V128Load8x8UOp => typecheck_v128_mem_load_extend64(st1, ma)\n        V128Load16x4SOp => typecheck_v128_mem_load_extend64(st1, ma)\n        V128Load16x4UOp => typecheck_v128_mem_load_extend64(st1, ma)\n        V128Load32x2SOp => typecheck_v128_mem_load_extend64(st1, ma)\n        V128Load32x2UOp => typecheck_v128_mem_load_extend64(st1, ma)\n        V128Load8SplatOp => typecheck_v128_mem_load_splat(st1, ma, 8)\n        V128Load16SplatOp => typecheck_v128_mem_load_splat(st1, ma, 16)\n        V128Load32SplatOp => typecheck_v128_mem_load_splat(st1, ma, 32)\n        V128Load64SplatOp => typecheck_v128_mem_load_splat(st1, ma, 64)\n        V128Load32ZeroOp => typecheck_v128_mem_load_zero(st1, ma, 32)\n        V128Load64ZeroOp => typecheck_v128_mem_load_zero(st1, ma, 64)\n      }\n    }\n\n    // === Memory ops ===\n    TMemoryGrow(m, delta) => {\n      let st1 = match Typecheck::typecheck(delta, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_memory_grow(st1, m)\n    }\n    TMemoryFill(m, dst, val, len) => {\n      let st1 = match Typecheck::typecheck(dst, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(val, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(len, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_memory_fill(st3, m)\n    }\n    TMemoryCopy(mi0, mi1, dst, src, len) => {\n      let st1 = match Typecheck::typecheck(dst, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(src, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(len, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_memory_copy(st3, mi0, mi1)\n    }\n    TMemoryInit(d, m, dst, src, len) => {\n      let st1 = match Typecheck::typecheck(dst, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(src, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(len, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_memory_init(st3, d, m)\n    }\n    TDataDrop(d) => typecheck_data_drop(st, d)\n\n    // === Table ops ===\n    TTableGet(t, idx) => {\n      let st1 = match Typecheck::typecheck(idx, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_table_get(st1, t)\n    }\n    TTableSet(t, idx, val) => {\n      let st1 = match Typecheck::typecheck(idx, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(val, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_table_set(st2, t)\n    }\n    TTableGrow(t, init, delta) => {\n      let st1 = match Typecheck::typecheck(init, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(delta, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_table_grow(st2, t)\n    }\n    TTableFill(t, idx, val, len) => {\n      let st1 = match Typecheck::typecheck(idx, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(val, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(len, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_table_fill(st3, t)\n    }\n    TTableCopy(t0, t1, dst, src, len) => {\n      let st1 = match Typecheck::typecheck(dst, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(src, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(len, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_table_copy(st3, t0, t1)\n    }\n    TTableInit(e, t, dst, src, len) => {\n      let st1 = match Typecheck::typecheck(dst, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(src, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(len, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_table_init(st3, e, t)\n    }\n    TElemDrop(e) => typecheck_elem_drop(st, e)\n\n    // === Calls ===\n    TCall(f, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_call(st_acc, f)\n    }\n    TCallIndirect(tidx, t, args, tab_expr) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_final = match Typecheck::typecheck(tab_expr, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_call_indirect(st_final, tidx, t)\n    }\n    TCallRef(tidx, args, funcref) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_final = match Typecheck::typecheck(funcref, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_call_ref(st_final, tidx)\n    }\n    TReturnCall(f, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_return_call(st_acc, f)\n    }\n    TReturnCallIndirect(tidx, t, args, tab_expr) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_final = match Typecheck::typecheck(tab_expr, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_return_call_indirect(st_final, tidx, t)\n    }\n    TReturnCallRef(tidx, args, funcref) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_final = match Typecheck::typecheck(funcref, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_return_call_ref(st_final, tidx)\n    }\n\n    // === Control Flow ===\n    TBlock(bt, body) => {\n      let (params, results) = match st.env.expand_blocktype(bt) {\n        Err(e) => return Err(e)\n        Ok(x) => x\n      }\n      let st1 = match st.pop_types(params) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n      let base_len = st1.stack.length()\n      let env2 = st1.env.with_label(results)\n      let mut st_body = TcState::{ ..st1, env: env2 }\n      let TExpr(body) = body\n      for instr in body {\n        st_body = match Typecheck::typecheck(instr, st_body) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      }\n      let st2 = if st_body.reachable {\n        match st_body.pop_types(results) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      } else {\n        st_body\n      }\n      let s = st2.stack.copy()\n      while s.length() > base_len {\n        ignore(s.pop())\n      }\n      let out = TcState::{ ..st, stack: s }\n      Ok(out.push_types(results))\n    }\n    TLoop(bt, body) => {\n      let (params, results) = match st.env.expand_blocktype(bt) {\n        Err(e) => return Err(e)\n        Ok(x) => x\n      }\n      let st1 = match st.pop_types(params) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n      let base_len = st1.stack.length()\n      let env2 = st1.env.with_label(params)\n      let mut st_body = TcState::{ ..st1, env: env2 }\n      let TExpr(body) = body\n      for instr in body {\n        st_body = match Typecheck::typecheck(instr, st_body) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      }\n      let st2 = if st_body.reachable {\n        match st_body.pop_types(results) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      } else {\n        st_body\n      }\n      let s = st2.stack.copy()\n      while s.length() > base_len {\n        ignore(s.pop())\n      }\n      let out = TcState::{ ..st, stack: s }\n      Ok(out.push_types(results))\n    }\n    TIf(bt, cond, then_instrs, else_instrs_opt) => {\n      let (params, results) = match st.env.expand_blocktype(bt) {\n        Err(e) => return Err(e)\n        Ok(x) => x\n      }\n      let st0 = match Typecheck::typecheck(cond, st) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n      let st0 = match st0.pop_expect(NumTypeValType(I32NumType)) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n      let st1 = match st0.pop_types(params) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n      let base_len = st1.stack.length()\n      let else_instrs = match else_instrs_opt {\n        None => []\n        Some(TExpr(xs)) => xs\n      }\n      let env_branch = st1.env.with_label(results)\n      let st_then0 = TcState::{ ..st1, env: env_branch }\n      let mut st_then = st_then0\n      let TExpr(then_instrs) = then_instrs\n      for instr in then_instrs {\n        st_then = match Typecheck::typecheck(instr, st_then) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      }\n      let st_else0 = TcState::{ ..st1, env: env_branch }\n      let mut st_else = st_else0\n      for instr in else_instrs {\n        st_else = match Typecheck::typecheck(instr, st_else) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      }\n      let norm_branch = fn(\n        sb : TcState,\n      ) -> Result[(Bool, Array[ValType]), String] {\n        let sb2 = if sb.reachable {\n          match sb.pop_types(results) {\n            Err(e) => return Err(e)\n            Ok(s) => s\n          }\n        } else {\n          sb\n        }\n        let stack2 = sb2.stack.copy()\n        while stack2.length() > base_len {\n          ignore(stack2.pop())\n        }\n        Ok((sb2.reachable, stack2))\n      }\n      let (then_reach, then_stack) = match norm_branch(st_then) {\n        Err(e) => return Err(e)\n        Ok(x) => x\n      }\n      let (else_reach, else_stack) = match norm_branch(st_else) {\n        Err(e) => return Err(e)\n        Ok(x) => x\n      }\n      let merged_stack = match (then_reach, else_reach) {\n        (true, true) => {\n          if then_stack != else_stack {\n            return Err(\"if branch stack mismatch\")\n          }\n          then_stack\n        }\n        (true, false) => then_stack\n        (false, true) => else_stack\n        (false, false) => st1.stack.copy()\n      }\n      let merged_reachable = then_reach || else_reach\n      let out = TcState::{\n        env: st.env,\n        stack: merged_stack,\n        reachable: merged_reachable,\n      }\n      Ok(out.push_types(results))\n    }\n    TTryTable(bt, catches, body) => {\n      let (params, results) = match st.env.expand_blocktype(bt) {\n        Err(e) => return Err(e)\n        Ok(x) => x\n      }\n      let st1 = match st.pop_types(params) {\n        Err(e) => return Err(e)\n        Ok(s) => s\n      }\n      let base_len = st1.stack.length()\n      let env2 = st1.env.with_label(results)\n      let st_body0 = TcState::{ ..st1, env: env2 }\n      let mut st_body = st_body0\n      let TExpr(body) = body\n      for instr in body {\n        st_body = match Typecheck::typecheck(instr, st_body) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      }\n      let st_catch_ctx = TcState::{ ..st1, env: env2 }\n      for c in catches {\n        match typecheck_catch_clause(st_catch_ctx, c) {\n          Err(e) => return Err(e)\n          Ok(_) => ()\n        }\n      }\n      let st2 = if st_body.reachable {\n        match st_body.pop_types(results) {\n          Err(e) => return Err(e)\n          Ok(s) => s\n        }\n      } else {\n        st_body\n      }\n      let stack2 = st2.stack.copy()\n      while stack2.length() > base_len {\n        ignore(stack2.pop())\n      }\n      let out = TcState::{\n        env: st.env,\n        stack: stack2,\n        reachable: st2.reachable,\n      }\n      Ok(out.push_types(results))\n    }\n    TThrow(tag, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_throw(st_acc, tag)\n    }\n\n    // === Branches ===\n    TBr(l, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_br(st_acc, l)\n    }\n    TBrIf(l, cond, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_cond = match Typecheck::typecheck(cond, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_br_if(st_cond, l)\n    }\n    TBrTable(ls, ldef, index, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_idx = match Typecheck::typecheck(index, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_br_table(st_idx, ls, ldef)\n    }\n    TBrOnNull(l, r, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_ref = match Typecheck::typecheck(r, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_br_on_null(st_ref, l)\n    }\n    TBrOnNonNull(l, r, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_ref = match Typecheck::typecheck(r, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_br_on_non_null(st_ref, l)\n    }\n    TBrOnCast(l, op, ht1, ht2, r, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_ref = match Typecheck::typecheck(r, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_br_on_cast(st_ref, l, op, ht1, ht2)\n    }\n    TBrOnCastFail(l, op, ht1, ht2, r, args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      let st_ref = match Typecheck::typecheck(r, st_acc) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_br_on_cast_fail(st_ref, l, op, ht1, ht2)\n    }\n    TReturn(args) => {\n      let mut st_acc = st\n      for arg in args {\n        st_acc = match Typecheck::typecheck(arg, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_return(st_acc)\n    }\n\n    // === Select ===\n    TSelect(ty_opt, cond, t, f) => {\n      let st_f = match Typecheck::typecheck(f, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st_t = match Typecheck::typecheck(t, st_f) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st_cond = match Typecheck::typecheck(cond, st_t) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match ty_opt {\n        None => typecheck_select_untyped(st_cond)\n        Some(ts) => typecheck_select_typed(st_cond, ts)\n      }\n    }\n\n    // === Structs ===\n    TStructNew(x, fields) => {\n      let mut st_acc = st\n      for f in fields {\n        st_acc = match Typecheck::typecheck(f, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_struct_new(st_acc, x)\n    }\n    TStructNewDefault(x) => typecheck_struct_new_default(st, x)\n    TStructGet(x, i, s) => {\n      let st1 = match Typecheck::typecheck(s, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_struct_get(st1, x, i)\n    }\n    TStructGetS(x, i, s) => {\n      let st1 = match Typecheck::typecheck(s, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_struct_get_s(st1, x, i)\n    }\n    TStructGetU(x, i, s) => {\n      let st1 = match Typecheck::typecheck(s, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_struct_get_u(st1, x, i)\n    }\n    TStructSet(x, i, s, val) => {\n      let st1 = match Typecheck::typecheck(s, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(val, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_struct_set(st2, x, i)\n    }\n\n    // === Arrays ===\n    TArrayNew(x, init, len) => {\n      let st1 = match Typecheck::typecheck(init, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(len, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_new(st2, x)\n    }\n    TArrayNewDefault(x, len) => {\n      let st1 = match Typecheck::typecheck(len, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_new_default(st1, x)\n    }\n    TArrayNewFixed(x, fields) => {\n      let mut st_acc = st\n      for f in fields {\n        st_acc = match Typecheck::typecheck(f, st_acc) {\n          Ok(st) => st\n          Err(t) => return Err(t)\n        }\n      }\n      typecheck_array_new_fixed(\n        st_acc,\n        x,\n        fields.length().reinterpret_as_uint(),\n      )\n    }\n    TArrayNewData(x, y, offset, len) => {\n      let st1 = match Typecheck::typecheck(offset, st) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(len, st1) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      typecheck_array_new_data(st2, x, y)\n    }\n    TArrayNewElem(x, y, offset, len) => {\n      let st1 = match Typecheck::typecheck(offset, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(len, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_new_elem(st2, x, y)\n    }\n    TArrayGet(x, arr, idx) => {\n      let st1 = match Typecheck::typecheck(arr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(idx, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_get(st2, x)\n    }\n    TArrayGetS(x, arr, idx) => {\n      let st1 = match Typecheck::typecheck(arr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(idx, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_get_s(st2, x)\n    }\n    TArrayGetU(x, arr, idx) => {\n      let st1 = match Typecheck::typecheck(arr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(idx, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_get_u(st2, x)\n    }\n    TArraySet(x, arr, idx, val) => {\n      let st1 = match Typecheck::typecheck(arr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(idx, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(val, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_set(st3, x)\n    }\n    TArrayFill(x, arr, offset, val, len) => {\n      let st1 = match Typecheck::typecheck(arr, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(offset, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(val, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st4 = match Typecheck::typecheck(len, st3) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_fill(st4, x)\n    }\n    TArrayCopy(x, y, arr2, idx2, arr1, idx1, len) => {\n      let st1 = match Typecheck::typecheck(arr2, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(idx2, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(arr1, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st4 = match Typecheck::typecheck(idx1, st3) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st5 = match Typecheck::typecheck(len, st4) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_copy(st5, x, y)\n    }\n    TArrayInitData(x, y, i0, i1, i2, i3) => {\n      let st1 = match Typecheck::typecheck(i0, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(i1, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(i2, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st4 = match Typecheck::typecheck(i3, st3) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_init_data(st4, x, y)\n    }\n    TArrayInitElem(x, y, i0, i1, i2, i3) => {\n      let st1 = match Typecheck::typecheck(i0, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(i1, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(i2, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st4 = match Typecheck::typecheck(i3, st3) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_array_init_elem(st4, x, y)\n    }\n\n    // === GC: Casts ===\n    TRefTest(nullable, ht, child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_ref_test(st1, nullable, ht)\n    }\n    TRefCast(nullable, ht, child) => {\n      let st1 = match Typecheck::typecheck(child, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_ref_cast(st1, nullable, ht)\n    }\n\n    // === SIMD: Splat ===\n    TI8x16Splat(x) => {\n      let st1 = match Typecheck::typecheck(x, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_splat(st1, vt_i32())\n    }\n    TI16x8Splat(x) => {\n      let st1 = match Typecheck::typecheck(x, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_splat(st1, vt_i32())\n    }\n    TI32x4Splat(x) => {\n      let st1 = match Typecheck::typecheck(x, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_splat(st1, vt_i32())\n    }\n    TI64x2Splat(x) => {\n      let st1 = match Typecheck::typecheck(x, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_splat(st1, vt_i64())\n    }\n    TF32x4Splat(x) => {\n      let st1 = match Typecheck::typecheck(x, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_splat(st1, vt_f32())\n    }\n    TF64x2Splat(x) => {\n      let st1 = match Typecheck::typecheck(x, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_splat(st1, vt_f64())\n    }\n\n    // === SIMD: Extract lane ===\n    TExtractLane(op, _, vec) => {\n      let st1 = match Typecheck::typecheck(vec, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match op {\n        I8x16ExtractLaneSOp => typecheck_lane_extract(st1, vt_i32())\n        I8x16ExtractLaneUOp => typecheck_lane_extract(st1, vt_i32())\n        I16x8ExtractLaneSOp => typecheck_lane_extract(st1, vt_i32())\n        I16x8ExtractLaneUOp => typecheck_lane_extract(st1, vt_i32())\n        I32x4ExtractLaneOp => typecheck_lane_extract(st1, vt_i32())\n        I64x2ExtractLaneOp => typecheck_lane_extract(st1, vt_i64())\n        F32x4ExtractLaneOp => typecheck_lane_extract(st1, vt_f32())\n        F64x2ExtractLaneOp => typecheck_lane_extract(st1, vt_f64())\n      }\n    }\n\n    // === SIMD: Replace lane ===\n    TReplaceLane(op, _, vec, val) => {\n      let st1 = match Typecheck::typecheck(vec, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(val, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match op {\n        I8x16ReplaceLaneOp => typecheck_lane_replace(st2, vt_i32())\n        I16x8ReplaceLaneOp => typecheck_lane_replace(st2, vt_i32())\n        I32x4ReplaceLaneOp => typecheck_lane_replace(st2, vt_i32())\n        I64x2ReplaceLaneOp => typecheck_lane_replace(st2, vt_i64())\n        F32x4ReplaceLaneOp => typecheck_lane_replace(st2, vt_f32())\n        F64x2ReplaceLaneOp => typecheck_lane_replace(st2, vt_f64())\n      }\n    }\n\n    // === SIMD: Shuffle ===\n    TI8x16Shuffle(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, v1, v2) => {\n      let st1 = match Typecheck::typecheck(v1, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(v2, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_v128_binary(st2)\n    }\n    TI8x16Swizzle(v1, v2) => {\n      let st1 = match Typecheck::typecheck(v1, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(v2, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_v128_binary(st2)\n    }\n    TI8x16RelaxedSwizzle(v1, v2) => {\n      let st1 = match Typecheck::typecheck(v1, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(v2, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_v128_binary(st2)\n    }\n\n    // === SIMD: Shift ===\n    TV128Shift(_, vec, shift) => {\n      let st1 = match Typecheck::typecheck(vec, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(shift, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_v128_shift(st2)\n    }\n\n    // === SIMD: Ternary ===\n    TV128Ternary(_, c, v1, v2) => {\n      let st1 = match Typecheck::typecheck(c, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(v1, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st3 = match Typecheck::typecheck(v2, st2) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      typecheck_v128_ternary(st3)\n    }\n\n    // === SIMD: Lane load/store ===\n    TV128LoadLane(op, ma, _, vec, addr) => {\n      let st1 = match Typecheck::typecheck(vec, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(addr, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match op {\n        V128Load8LaneOp => typecheck_v128_load_lane(st2, ma, 8)\n        V128Load16LaneOp => typecheck_v128_load_lane(st2, ma, 16)\n        V128Load32LaneOp => typecheck_v128_load_lane(st2, ma, 32)\n        V128Load64LaneOp => typecheck_v128_load_lane(st2, ma, 64)\n      }\n    }\n    TV128StoreLane(op, ma, _, vec, addr) => {\n      let st1 = match Typecheck::typecheck(vec, st) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      let st2 = match Typecheck::typecheck(addr, st1) {\n        Ok(st) => st\n        Err(t) => return Err(t)\n      }\n      match op {\n        V128Store8LaneOp => typecheck_v128_store_lane(st2, ma, 8)\n        V128Store16LaneOp => typecheck_v128_store_lane(st2, ma, 16)\n        V128Store32LaneOp => typecheck_v128_store_lane(st2, ma, 32)\n        V128Store64LaneOp => typecheck_v128_store_lane(st2, ma, 64)\n      }\n    }\n  }\n}\n\n///|\npub impl Typecheck for TExpr with typecheck(self, st0) {\n  let TExpr(instrs) = self\n  let mut st = st0\n  for instr in instrs {\n    match Typecheck::typecheck(instr, st) {\n      Ok(s) => st = s\n      Err(e) => return Err(e)\n    }\n  }\n  Ok(st)\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n///|\nfn assert_stack(state : TcState, expected : Array[ValType]) -> Unit {\n  if not(equals(state.stack, expected)) {\n    abort(\"Stack mismatch: expected \\{expected}, got \\{state.stack}\")\n  }\n}\n\n///|\nfn[T] assert_ok(result : Result[T, String]) -> T {\n  match result {\n    Ok(v) => v\n    Err(e) => abort(\"Expected Ok, got Err: \\{e}\")\n  }\n}\n\n///|\nfn[T : Show] assert_err(result : Result[T, String]) -> Unit {\n  match result {\n    Ok(v) => abort(\"Expected Err, got Ok: \\{v}\")\n    Err(_) => ()\n  }\n}\n\n///|\nfn i32_type() -> ValType {\n  NumTypeValType(I32NumType)\n}\n\n///|\nfn i64_type() -> ValType {\n  NumTypeValType(I64NumType)\n}\n\n///|\nfn f32_type() -> ValType {\n  NumTypeValType(F32NumType)\n}\n\n///|\nfn f64_type() -> ValType {\n  NumTypeValType(F64NumType)\n}\n\n///|\nfn v128_type() -> ValType {\n  VecTypeValType\n}\n\n///|\nfn anyref_type() -> ValType {\n  RefTypeValType(AbsHeapTypeRefType(AnyAbsHeapType))\n}\n\n///|\nfn eqref_type() -> ValType {\n  RefTypeValType(AbsHeapTypeRefType(EqAbsHeapType))\n}\n\n///|\nfn i31ref_type() -> ValType {\n  RefTypeValType(HeapTypeRefType(false, AbsHeapTypeHeapType(I31AbsHeapType)))\n}\n\n///|\nfn nullable_funcref() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)))\n}\n\n///|\nfn nullable_externref() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)))\n}\n\n///|\nfn non_nullable_funcref() -> ValType {\n  RefTypeValType(HeapTypeRefType(false, AbsHeapTypeHeapType(FuncAbsHeapType)))\n}\n\n///|\nfn non_nullable_externref() -> ValType {\n  RefTypeValType(HeapTypeRefType(false, AbsHeapTypeHeapType(ExternAbsHeapType)))\n}\n\n///|\nfn make_state(env : Env, stack : Array[ValType]) -> TcState {\n  { env, stack, reachable: true }\n}\n\n// =============================================================================\n// CONTROL INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck Unreachable\" {\n  let state = make_state(empty_env(), [])\n  let t = @lib.Unreachable\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck Nop\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let t = @lib.Nop\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck Block empty\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let block = @lib.Block(EmptyBlockType, Expr([]))\n  let new_state = assert_ok(Typecheck::typecheck(block, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck Block with result\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let block = @lib.Block(\n    ValTypeBlockType(i32_type()),\n    Expr([I32Const(I32(42))]),\n  )\n  let new_state = assert_ok(Typecheck::typecheck(block, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck Block preserves outer stack\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type()])\n  let block = @lib.Block(ValTypeBlockType(i32_type()), Expr([I32Const(I32(1))]))\n  let new_state = assert_ok(Typecheck::typecheck(block, state))\n  assert_stack(new_state, [i64_type(), i32_type()])\n}\n\n///|\ntest \"Typecheck Loop empty\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let loop_instr = @lib.Loop(EmptyBlockType, Expr([]))\n  let new_state = assert_ok(Typecheck::typecheck(loop_instr, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck If without else\" {\n  let env = empty_env()\n  let state = make_state(env, [i32_type()])\n  let if_instr = @lib.If(EmptyBlockType, [Nop], None)\n  let new_state = assert_ok(Typecheck::typecheck(if_instr, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck If with else\" {\n  let env = empty_env()\n  let state = make_state(env, [i32_type()])\n  let if_instr = @lib.If(\n    ValTypeBlockType(i32_type()),\n    [I32Const(I32(1))],\n    Some([I32Const(I32(2))]),\n  )\n  let new_state = assert_ok(Typecheck::typecheck(if_instr, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck If fails without condition\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let if_instr = @lib.If(EmptyBlockType, [Nop], None)\n  assert_err(Typecheck::typecheck(if_instr, state))\n}\n\n///|\ntest \"Typecheck Br\" {\n  let env = empty_env().with_labels([[]])\n  let state = make_state(env, [])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.Br(LabelIdx(0)), state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck Br with values\" {\n  let env = empty_env().with_labels([[i32_type()]])\n  let state = make_state(env, [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.Br(LabelIdx(0)), state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck Br invalid label\" {\n  let env = empty_env().with_labels([])\n  let state = make_state(env, [])\n  let t = @lib.Br(LabelIdx(0))\n  assert_err(Typecheck::typecheck(t, state))\n}\n\n///|\ntest \"Typecheck BrIf\" {\n  let env = empty_env().with_labels([[]])\n  let state = make_state(env, [i32_type()])\n  let t = @lib.BrIf(LabelIdx(0))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck BrIf with values\" {\n  let env = empty_env().with_labels([[i32_type()]])\n  let state = make_state(env, [i32_type(), i32_type()])\n  let t = @lib.BrIf(LabelIdx(0))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck BrTable\" {\n  let env = empty_env().with_labels([[], []])\n  let state = make_state(env, [i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  let new_state = assert_ok(Typecheck::typecheck(br_table, state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck BrTable with values\" {\n  // Labels expect an i32 value to be passed\n  let env = empty_env().with_labels([[i32_type()], [i32_type()]])\n  // Stack: [i32 (branch value), i32 (selector)]\n  let state = make_state(env, [i32_type(), i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  let new_state = assert_ok(Typecheck::typecheck(br_table, state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck BrTable with multiple values\" {\n  // Labels expect i32, i64 to be passed\n  let env = empty_env().with_labels([\n    [i32_type(), i64_type()],\n    [i32_type(), i64_type()],\n  ])\n  // Stack: [i32, i64 (branch values), i32 (selector)]\n  let state = make_state(env, [i32_type(), i64_type(), i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  let new_state = assert_ok(Typecheck::typecheck(br_table, state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck BrTable multiple targets\" {\n  let env = empty_env().with_labels([[], [], [], []])\n  let state = make_state(env, [i32_type()])\n  // Jump table with 3 entries plus default\n  let br_table = @lib.BrTable(\n    [LabelIdx(0), LabelIdx(1), LabelIdx(2)],\n    LabelIdx(3),\n  )\n  let new_state = assert_ok(Typecheck::typecheck(br_table, state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck BrTable invalid default label\" {\n  let env = empty_env().with_labels([[]])\n  let state = make_state(env, [i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(5)) // invalid default\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck BrTable invalid table label\" {\n  let env = empty_env().with_labels([[]])\n  let state = make_state(env, [i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0), LabelIdx(99)], LabelIdx(0)) // invalid in table\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck BrTable mismatched label types\" {\n  // Labels have different arities - this is invalid\n  let env = empty_env().with_labels([[i32_type()], []])\n  let state = make_state(env, [i32_type(), i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck BrTable mismatched label value types\" {\n  // Labels have same arity but different types\n  let env = empty_env().with_labels([[i32_type()], [i64_type()]])\n  let state = make_state(env, [i32_type(), i32_type()])\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck BrTable missing selector\" {\n  let env = empty_env().with_labels([[], []])\n  let state = make_state(env, []) // empty stack - no selector\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck BrTable missing branch values\" {\n  // Labels expect an i32 but stack only has the selector\n  let env = empty_env().with_labels([[i32_type()], [i32_type()]])\n  let state = make_state(env, [i32_type()]) // only selector, no branch value\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck BrTable wrong selector type\" {\n  let env = empty_env().with_labels([[], []])\n  let state = make_state(env, [i64_type()]) // wrong type for selector\n  let br_table = @lib.BrTable([LabelIdx(0)], LabelIdx(1))\n  assert_err(Typecheck::typecheck(br_table, state))\n}\n\n///|\ntest \"Typecheck Return\" {\n  let env = empty_env().with_return_type(Some([]))\n  let state = make_state(env, [])\n  let t = @lib.Return\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_eq(new_state.reachable, false)\n}\n\n///|\ntest \"Typecheck Return with value\" {\n  let env = empty_env().with_return_type(Some([i32_type()]))\n  let state = make_state(env, [i32_type()])\n  let t = @lib.Return\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_eq(new_state.reachable, false)\n}\n\n// =============================================================================\n// PARAMETRIC INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck Drop i32\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let t = @lib.Drop\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck Drop i64\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let t = @lib.Drop\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck Drop fails empty stack\" {\n  let state = make_state(empty_env(), [])\n  let t = @lib.Drop\n  assert_err(Typecheck::typecheck(t, state))\n}\n\n///|\ntest \"Typecheck Select without annotation\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type(), i32_type()])\n  let t = @lib.Select(None)\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck Select with annotation\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type(), i32_type()])\n  let t = @lib.Select(Some([i32_type()]))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck Select type mismatch fails\" {\n  let state = make_state(empty_env(), [i32_type(), i64_type(), i32_type()])\n  let t = @lib.Select(None)\n  assert_err(Typecheck::typecheck(t, state))\n}\n\n// =============================================================================\n// VARIABLE INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck LocalGet\" {\n  let env : Env = { ..empty_env(), locals: [i32_type()] }\n  let state = make_state(env, [])\n  let t = @lib.LocalGet(LocalIdx(0))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck LocalGet invalid index\" {\n  let env : Env = { ..empty_env(), locals: [] }\n  let state = make_state(env, [])\n  let t = @lib.LocalGet(LocalIdx(0))\n  assert_err(Typecheck::typecheck(t, state))\n}\n\n///|\ntest \"Typecheck LocalSet\" {\n  let env : Env = { ..empty_env(), locals: [i32_type()] }\n  let state = make_state(env, [i32_type()])\n  let t = @lib.LocalSet(LocalIdx(0))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck LocalSet type mismatch\" {\n  let env = Env::{ ..empty_env(), locals: [i32_type()] }\n  let state = make_state(env, [i64_type()])\n  let t = @lib.LocalSet(LocalIdx(0))\n  assert_err(Typecheck::typecheck(t, state))\n}\n\n///|\ntest \"Typecheck LocalTee\" {\n  let env : Env = { ..empty_env(), locals: [i32_type()] }\n  let state = make_state(env, [i32_type()])\n  let t = @lib.LocalTee(LocalIdx(0))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck GlobalGet\" {\n  let env : Env = { ..empty_env(), globals: [GlobalType(i32_type(), false)] }\n  let state = make_state(env, [])\n  let t = @lib.GlobalGet(GlobalIdx(0))\n  let new_state = assert_ok(Typecheck::typecheck(t, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck GlobalSet mutable\" {\n  let env : Env = { ..empty_env(), globals: [GlobalType(i32_type(), true)] }\n  let state = make_state(env, [i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.GlobalSet(GlobalIdx(0)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck GlobalSet immutable fails\" {\n  let env : Env = { ..empty_env(), globals: [GlobalType(i32_type(), false)] }\n  let state = make_state(env, [i32_type()])\n  assert_err(Typecheck::typecheck(@lib.GlobalSet(GlobalIdx(0)), state))\n}\n\n// =============================================================================\n// TABLE INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck TableGet\" {\n  let table_type = @lib.TableType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    I32Limits(0, None),\n  )\n  let env : Env = { ..empty_env(), tables: [table_type] }\n  let state = make_state(env, [i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.TableGet(TableIdx(0)), state),\n  )\n  assert_stack(new_state, [nullable_funcref()])\n}\n\n///|\ntest \"Typecheck TableSet\" {\n  let table_type = @lib.TableType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    I32Limits(0, None),\n  )\n  let env : Env = { ..empty_env(), tables: [table_type] }\n  let state = make_state(env, [i32_type(), nullable_funcref()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.TableSet(TableIdx(0)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck TableSize\" {\n  let table_type = @lib.TableType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    I32Limits(0, None),\n  )\n  let env : Env = { ..empty_env(), tables: [table_type] }\n  let state = make_state(env, [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.TableSize(TableIdx(0)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck TableGrow\" {\n  let table_type = @lib.TableType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    I32Limits(0, None),\n  )\n  let env : Env = { ..empty_env(), tables: [table_type] }\n  let state = make_state(env, [nullable_funcref(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.TableGrow(TableIdx(0)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck TableFill\" {\n  let table_type = @lib.TableType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    I32Limits(0, None),\n  )\n  let env : Env = { ..empty_env(), tables: [table_type] }\n  let state = make_state(env, [i32_type(), nullable_funcref(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.TableFill(TableIdx(0)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck TableCopy\" {\n  let table_type = @lib.TableType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    I32Limits(0, None),\n  )\n  let env : Env = { ..empty_env(), tables: [table_type, table_type] }\n  let state = make_state(env, [i32_type(), i32_type(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.TableCopy(TableIdx(0), TableIdx(1)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n// =============================================================================\n// MEMORY INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I32Load\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Load(mem_arg), state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Load\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Load(mem_arg), state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F32Load\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Load(mem_arg), state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F64Load\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Load(mem_arg), state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck I32Load8S\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32Load8S(mem_arg), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Load8U\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32Load8U(mem_arg), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Load16S\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32Load16S(mem_arg), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Load16U\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32Load16U(mem_arg), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Load8S\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I64Load8S(mem_arg), state),\n  )\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Load32S\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I64Load32S(mem_arg), state),\n  )\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I32Store\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Store(mem_arg), state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck I64Store\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), i64_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Store(mem_arg), state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck F32Store\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), f32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Store(mem_arg), state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck F64Store\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), f64_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Store(mem_arg), state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck I32Store8\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), i32_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32Store8(mem_arg), state),\n  )\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck I64Store32\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), i64_type()])\n  let mem_arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I64Store32(mem_arg), state),\n  )\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck MemorySize\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.MemorySize(MemIdx(0)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck MemoryGrow\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.MemoryGrow(MemIdx(0)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck MemoryCopy\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), i32_type(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.MemoryCopy(MemIdx(0), MemIdx(0)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck MemoryFill\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), i32_type(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.MemoryFill(MemIdx(0)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n// =============================================================================\n// NUMERIC CONSTANTS\n// =============================================================================\n\n///|\ntest \"Typecheck I32Const\" {\n  let state = make_state(empty_env(), [])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Const(I32(42)), state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Const\" {\n  let state = make_state(empty_env(), [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I64Const(I64(42L)), state),\n  )\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F32Const\" {\n  let state = make_state(empty_env(), [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.F32Const(F32(3.14)), state),\n  )\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F64Const\" {\n  let state = make_state(empty_env(), [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.F64Const(F64(3.14)), state),\n  )\n  assert_stack(new_state, [f64_type()])\n}\n\n// =============================================================================\n// I32 COMPARISON OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I32Eqz\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Eqz, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Eq\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Eq, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Ne\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Ne, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32LtS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32LtS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32LtU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32LtU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32GtS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32GtS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32GtU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32GtU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32LeS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32LeS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32LeU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32LeU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32GeS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32GeS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32GeU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32GeU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n// =============================================================================\n// I64 COMPARISON OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I64Eqz\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Eqz, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Eq\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Eq, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Ne\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Ne, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64LtS\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64LtS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64GtU\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64GtU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n// =============================================================================\n// F32 COMPARISON OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck F32Eq\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Eq, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F32Ne\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Ne, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F32Lt\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Lt, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F32Gt\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Gt, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F32Le\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Le, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F32Ge\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Ge, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n// =============================================================================\n// F64 COMPARISON OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck F64Eq\" {\n  let state = make_state(empty_env(), [f64_type(), f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Eq, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F64Lt\" {\n  let state = make_state(empty_env(), [f64_type(), f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Lt, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n// =============================================================================\n// I32 ARITHMETIC OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I32Clz\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Clz, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Ctz\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Ctz, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Popcnt\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Popcnt, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Add\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Add, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Sub\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Sub, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Mul\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Mul, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32DivS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32DivS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32DivU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32DivU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32RemS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32RemS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32RemU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32RemU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32And\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32And, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Or\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Or, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Xor\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Xor, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Shl\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Shl, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32ShrS\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32ShrS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32ShrU\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32ShrU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Rotl\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Rotl, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Rotr\" {\n  let state = make_state(empty_env(), [i32_type(), i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Rotr, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n// =============================================================================\n// I64 ARITHMETIC OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I64Clz\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Clz, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Add\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Add, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Sub\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Sub, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Mul\" {\n  let state = make_state(empty_env(), [i64_type(), i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Mul, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n// =============================================================================\n// F32 ARITHMETIC OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck F32Abs\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Abs, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Neg\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Neg, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Ceil\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Ceil, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Floor\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Floor, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Sqrt\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Sqrt, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Add\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Add, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Sub\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Sub, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Mul\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Mul, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Div\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Div, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Min\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Min, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Max\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Max, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Copysign\" {\n  let state = make_state(empty_env(), [f32_type(), f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32Copysign, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n// =============================================================================\n// F64 ARITHMETIC OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck F64Abs\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Abs, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Neg\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Neg, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Add\" {\n  let state = make_state(empty_env(), [f64_type(), f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Add, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Sub\" {\n  let state = make_state(empty_env(), [f64_type(), f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Sub, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Mul\" {\n  let state = make_state(empty_env(), [f64_type(), f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Mul, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Div\" {\n  let state = make_state(empty_env(), [f64_type(), f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64Div, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n// =============================================================================\n// CONVERSION OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I32WrapI64\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32WrapI64, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32TruncF32S\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncF32S, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32TruncF32U\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncF32U, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32TruncF64S\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncF64S, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32TruncF64U\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncF64U, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64ExtendI32S\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64ExtendI32S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64ExtendI32U\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64ExtendI32U, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64TruncF32S\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64TruncF32S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64TruncF64S\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64TruncF64S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F32ConvertI32S\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32ConvertI32S, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32ConvertI32U\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32ConvertI32U, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32ConvertI64S\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32ConvertI64S, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32DemoteF64\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32DemoteF64, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F64ConvertI32S\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64ConvertI32S, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64ConvertI64S\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64ConvertI64S, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64PromoteF32\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64PromoteF32, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck I32ReinterpretF32\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32ReinterpretF32, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64ReinterpretF64\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64ReinterpretF64, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F32ReinterpretI32\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32ReinterpretI32, state))\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F64ReinterpretI64\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64ReinterpretI64, state))\n  assert_stack(new_state, [f64_type()])\n}\n\n// =============================================================================\n// SIGN EXTENSION OPERATIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I32Extend8S\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Extend8S, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32Extend16S\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32Extend16S, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Extend8S\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Extend8S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Extend16S\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Extend16S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Extend32S\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64Extend32S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n// =============================================================================\n// SATURATING TRUNCATION\n// =============================================================================\n\n///|\ntest \"Typecheck I32TruncSatF32S\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncSatF32S, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32TruncSatF32U\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncSatF32U, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32TruncSatF64S\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32TruncSatF64S, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64TruncSatF32S\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64TruncSatF32S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64TruncSatF64S\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64TruncSatF64S, state))\n  assert_stack(new_state, [i64_type()])\n}\n\n// =============================================================================\n// REFERENCE INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck RefNull func\" {\n  let state = make_state(empty_env(), [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(\n      @lib.RefNull(AbsHeapTypeHeapType(FuncAbsHeapType)),\n      state,\n    ),\n  )\n  assert_stack(new_state, [nullable_funcref()])\n}\n\n///|\ntest \"Typecheck RefNull extern\" {\n  let state = make_state(empty_env(), [])\n  let new_state = assert_ok(\n    Typecheck::typecheck(\n      @lib.RefNull(AbsHeapTypeHeapType(ExternAbsHeapType)),\n      state,\n    ),\n  )\n  assert_stack(new_state, [nullable_externref()])\n}\n\n///|\ntest \"Typecheck RefIsNull\" {\n  let state = make_state(empty_env(), [nullable_funcref()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.RefIsNull, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefEq\" {\n  let eq_ref = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)),\n  )\n  let state = make_state(empty_env(), [eq_ref, eq_ref])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.RefEq, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefAsNonNull\" {\n  let state = make_state(empty_env(), [nullable_funcref()])\n  let result = Typecheck::typecheck(@lib.RefAsNonNull, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack.length(), 1)\n    Err(_) => ()\n  }\n}\n\n// BrOnNonNull tests\n\n///|\ntest \"Typecheck BrOnNonNull basic\" {\n  let env = empty_env().with_labels([[non_nullable_funcref()]])\n  let state = make_state(env, [nullable_funcref()])\n  let result = Typecheck::typecheck(@lib.BrOnNonNull(LabelIdx(0)), state)\n  let new_state = assert_ok(result)\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck BrOnNonNull with prefix types\" {\n  let env = empty_env().with_labels([[i32_type(), non_nullable_funcref()]])\n  let state = make_state(env, [i32_type(), nullable_funcref()])\n  let result = Typecheck::typecheck(@lib.BrOnNonNull(LabelIdx(0)), state)\n  let new_state = assert_ok(result)\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck BrOnNonNull with externref\" {\n  let env = empty_env().with_labels([[non_nullable_externref()]])\n  let state = make_state(env, [nullable_externref()])\n  let result = Typecheck::typecheck(@lib.BrOnNonNull(LabelIdx(0)), state)\n  let new_state = assert_ok(result)\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck BrOnNonNull fails with wrong label type\" {\n  let env = empty_env().with_labels([[i32_type()]])\n  let state = make_state(env, [nullable_funcref()])\n  let result = Typecheck::typecheck(@lib.BrOnNonNull(LabelIdx(0)), state)\n  assert_true(result is Err(_))\n}\n\n// BrOnNull tests\n\n///|\ntest \"Typecheck BrOnNull basic\" {\n  let env = empty_env().with_labels([[]]) // label takes no values\n  let state = make_state(env, [nullable_funcref()])\n  let result = Typecheck::typecheck(@lib.BrOnNull(LabelIdx(0)), state)\n  let new_state = assert_ok(result)\n  // Fallthrough pushes non-nullable ref\n  assert_stack(new_state, [non_nullable_funcref()])\n}\n\n///|\ntest \"Typecheck BrOnNull with prefix types\" {\n  let env = empty_env().with_labels([[i32_type()]])\n  let state = make_state(env, [i32_type(), nullable_funcref()])\n  let result = Typecheck::typecheck(@lib.BrOnNull(LabelIdx(0)), state)\n  let new_state = assert_ok(result)\n  assert_stack(new_state, [i32_type(), non_nullable_funcref()])\n}\n\n///|\ntest \"Typecheck BrOnNull with externref\" {\n  let env = empty_env().with_labels([[]])\n  let state = make_state(env, [nullable_externref()])\n  let result = Typecheck::typecheck(@lib.BrOnNull(LabelIdx(0)), state)\n  let new_state = assert_ok(result)\n  assert_stack(new_state, [non_nullable_externref()])\n}\n\n///|\ntest \"Typecheck RefI31\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.RefI31, state))\n  assert_eq(new_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck I31GetS\" {\n  let state = make_state(empty_env(), [i31ref_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I31GetS, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I31GetU\" {\n  let state = make_state(empty_env(), [i31ref_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I31GetU, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck AnyConvertExtern\" {\n  let state = make_state(empty_env(), [nullable_externref()])\n  let result = Typecheck::typecheck(@lib.AnyConvertExtern, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack.length(), 1)\n    Err(_) => ()\n  }\n}\n\n///|\ntest \"Typecheck ExternConvertAny\" {\n  let any_ref = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)),\n  )\n  let state = make_state(empty_env(), [any_ref])\n  let result = Typecheck::typecheck(@lib.ExternConvertAny, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack.length(), 1)\n    Err(_) => ()\n  }\n}\n\n// =============================================================================\n// VECTOR (SIMD) INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I32Const pushes i32\" {\n  let env = empty_env()\n  let state : TcState = { env, stack: [], reachable: true }\n  let result = Typecheck::typecheck(@lib.I32Const(I32(42)), state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack, [NumTypeValType(I32NumType)])\n    Err(e) => fail(\"I32Const should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck I32Add consumes two i32s and produces one\" {\n  let env = empty_env()\n  let state : TcState = {\n    env,\n    stack: [NumTypeValType(I32NumType), NumTypeValType(I32NumType)],\n    reachable: true,\n  }\n  let result = Typecheck::typecheck(@lib.I32Add, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack, [NumTypeValType(I32NumType)])\n    Err(e) => fail(\"I32Add should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck I32Add fails with insufficient stack\" {\n  let env = empty_env()\n  let state : TcState = { env, stack: [], reachable: true }\n  let result = Typecheck::typecheck(@lib.I32Add, state)\n  match result {\n    Ok(_) => fail(\"I32Add should fail with empty stack\")\n    Err(_) => ()\n  }\n}\n\n///|\ntest \"Typecheck Drop removes top of stack\" {\n  let env = empty_env()\n  let state : TcState = {\n    env,\n    stack: [NumTypeValType(I32NumType)],\n    reachable: true,\n  }\n  let result = Typecheck::typecheck(@lib.Drop, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack, [])\n    Err(e) => fail(\"Drop should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck Unreachable makes state unreachable\" {\n  let env = empty_env()\n  let state : TcState = { env, stack: [], reachable: true }\n  let result = Typecheck::typecheck(@lib.Unreachable, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.reachable, false)\n    Err(e) => fail(\"Unreachable should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck empty Expr\" {\n  let env = empty_env()\n  let state : TcState = { env, stack: [], reachable: true }\n  let expr = @lib.Expr([])\n  let result = Typecheck::typecheck(expr, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack, [])\n    Err(e) => fail(\"Empty Expr should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck Expr sequence\" {\n  let env = empty_env()\n  let state : TcState = { env, stack: [], reachable: true }\n  let expr = @lib.Expr([I32Const(I32(1)), I32Const(I32(2)), I32Add])\n  let result = Typecheck::typecheck(expr, state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack, [NumTypeValType(I32NumType)])\n    Err(e) => fail(\"Expr sequence should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck I64Const pushes i64\" {\n  let env = empty_env()\n  let state : TcState = { env, stack: [], reachable: true }\n  let result = Typecheck::typecheck(@lib.I64Const(I64(100L)), state)\n  match result {\n    Ok(new_state) => assert_eq(new_state.stack, [NumTypeValType(I64NumType)])\n    Err(e) => fail(\"I64Const should typecheck: \\{e}\")\n  }\n}\n\n///|\ntest \"Typecheck type mismatch fails\" {\n  let env = empty_env()\n  let state : TcState = {\n    env,\n    stack: [NumTypeValType(I64NumType), NumTypeValType(I32NumType)],\n    reachable: true,\n  }\n  let result = Typecheck::typecheck(@lib.I32Add, state)\n  match result {\n    Ok(_) => fail(\"I32Add should fail with mismatched types\")\n    Err(_) => ()\n  }\n}\n\n///|\ntest \"Typecheck V128Const\" {\n  let state = make_state(empty_env(), [])\n  let instr = @lib.V128Const(\n    b'\\x00', b'\\x01', b'\\x02', b'\\x03', b'\\x04', b'\\x05', b'\\x06', b'\\x07', b'\\x08',\n    b'\\x09', b'\\x0a', b'\\x0b', b'\\x0c', b'\\x0d', b'\\x0e', b'\\x0f',\n  )\n  let new_state = assert_ok(Typecheck::typecheck(instr, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type()])\n  let arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.V128Load(arg), state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Store\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), v128_type()])\n  let arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(Typecheck::typecheck(@lib.V128Store(arg), state))\n  assert_stack(new_state, [])\n}\n\n///|\ntest \"Typecheck I8x16Splat\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I8x16Splat, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8Splat\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I16x8Splat, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4Splat\" {\n  let state = make_state(empty_env(), [i32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32x4Splat, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Splat\" {\n  let state = make_state(empty_env(), [i64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I64x2Splat, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Splat\" {\n  let state = make_state(empty_env(), [f32_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32x4Splat, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Splat\" {\n  let state = make_state(empty_env(), [f64_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F64x2Splat, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16ExtractLaneS\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I8x16ExtractLaneS(LaneIdx(0)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtractLaneU\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I16x8ExtractLaneU(LaneIdx(3)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtractLane\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32x4ExtractLane(LaneIdx(1)), state),\n  )\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtractLane\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I64x2ExtractLane(LaneIdx(0)), state),\n  )\n  assert_stack(new_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F32x4ExtractLane\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.F32x4ExtractLane(LaneIdx(2)), state),\n  )\n  assert_stack(new_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F64x2ExtractLane\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.F64x2ExtractLane(LaneIdx(1)), state),\n  )\n  assert_stack(new_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck I8x16ReplaceLane\" {\n  let state = make_state(empty_env(), [v128_type(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I8x16ReplaceLane(LaneIdx(0)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ReplaceLane\" {\n  let state = make_state(empty_env(), [v128_type(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I16x8ReplaceLane(LaneIdx(2)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ReplaceLane\" {\n  let state = make_state(empty_env(), [v128_type(), i32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I32x4ReplaceLane(LaneIdx(1)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ReplaceLane\" {\n  let state = make_state(empty_env(), [v128_type(), i64_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.I64x2ReplaceLane(LaneIdx(0)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4ReplaceLane\" {\n  let state = make_state(empty_env(), [v128_type(), f32_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.F32x4ReplaceLane(LaneIdx(3)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2ReplaceLane\" {\n  let state = make_state(empty_env(), [v128_type(), f64_type()])\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.F64x2ReplaceLane(LaneIdx(1)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Not\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.V128Not, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Abs\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I8x16Abs, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8Neg\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I16x8Neg, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4AllTrue\" {\n  let state = make_state(empty_env(), [v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32x4AllTrue, state))\n  assert_stack(new_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck V128And\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.V128And, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Add\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I8x16Add, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8Mul\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I16x8Mul, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4Sub\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32x4Sub, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Div\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32x4Div, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Eq\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I8x16Eq, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8LtS\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I16x8LtS, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4GtU\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.I32x4GtU, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Le\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.F32x4Le, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Bitselect\" {\n  let state = make_state(empty_env(), [v128_type(), v128_type(), v128_type()])\n  let new_state = assert_ok(Typecheck::typecheck(@lib.V128Bitselect, state))\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load8Lane\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), v128_type()])\n  let arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.V128Load8Lane(arg, LaneIdx(0)), state),\n  )\n  assert_stack(new_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Store16Lane\" {\n  let env : Env = { ..empty_env(), mems: [MemType(I32Limits(1, None))] }\n  let state = make_state(env, [i32_type(), v128_type()])\n  let arg = @lib.MemArg(U32(0), None, U64(0))\n  let new_state = assert_ok(\n    Typecheck::typecheck(@lib.V128Store16Lane(arg, LaneIdx(2)), state),\n  )\n  assert_stack(new_state, [])\n}\n\n// =============================================================================\n// CALL INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck Call\" {\n  let func_type = @lib.FuncType([i32_type()], [i64_type()])\n  let env = empty_env().push_func(func_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.Call(FuncIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck Call no args no results\" {\n  let func_type = @lib.FuncType([], [])\n  let env = empty_env().push_func(func_type)\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.Call(FuncIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck Call invalid func index\" {\n  let env = empty_env()\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.Call(FuncIdx(0)), state)\n  assert_err(result)\n}\n\n///|\ntest \"Typecheck Call type mismatch\" {\n  let func_type = @lib.FuncType([i32_type()], [])\n  let env = empty_env().push_func(func_type)\n  let state = make_state(env, [i64_type()])\n  let result = Typecheck::typecheck(@lib.Call(FuncIdx(0)), state)\n  assert_err(result)\n}\n\n///|\ntest \"Typecheck CallIndirect\" {\n  let func_subtype = @lib.CompTypeSubType(\n    FuncCompType([i32_type()], [i64_type()]),\n  )\n  let table_type = @lib.TableType(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    I32Limits(1, None),\n  )\n  let env = { ..empty_env(), global_types: [func_subtype] }.push_table(\n    table_type,\n  )\n  let state = make_state(env, [i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.CallIndirect(TypeIdx(0), TableIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck ReturnCall\" {\n  let func_type = @lib.FuncType([i32_type()], [i64_type()])\n  let env = empty_env()\n    .push_func(func_type)\n    .with_return_type(Some([i64_type()]))\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.ReturnCall(FuncIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.reachable, false)\n}\n\n///|\ntest \"Typecheck ReturnCallIndirect\" {\n  let func_subtype = @lib.CompTypeSubType(\n    FuncCompType([i32_type()], [i64_type()]),\n  )\n  let table_type = @lib.TableType(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    I32Limits(1, None),\n  )\n  let env = { ..empty_env(), global_types: [func_subtype] }\n    .push_table(table_type)\n    .with_return_type(Some([i64_type()]))\n  let state = make_state(env, [i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.ReturnCallIndirect(TypeIdx(0), TableIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_eq(final_state.reachable, false)\n}\n\n///|\ntest \"Typecheck CallRef\" {\n  let func_subtype = @lib.CompTypeSubType(\n    FuncCompType([i32_type()], [i64_type()]),\n  )\n  let env = { ..empty_env(), global_types: [func_subtype] }\n  let ref_type = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [i32_type(), ref_type])\n  let result = Typecheck::typecheck(@lib.CallRef(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck ReturnCallRef\" {\n  let func_subtype = @lib.CompTypeSubType(\n    FuncCompType([i32_type()], [i64_type()]),\n  )\n  let env = { ..empty_env(), global_types: [func_subtype] }.with_return_type(\n    Some([i64_type()]),\n  )\n  let ref_type = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [i32_type(), ref_type])\n  let result = Typecheck::typecheck(@lib.ReturnCallRef(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.reachable, false)\n}\n\n// =============================================================================\n// REFERENCE INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck RefFunc\" {\n  let func_type = @lib.FuncType([], [])\n  let env = empty_env().push_func(func_type)\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.RefFunc(FuncIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck RefFunc invalid index\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.RefFunc(FuncIdx(0)), state)\n  assert_err(result)\n}\n\n///|\ntest \"Typecheck RefTest non-nullable\" {\n  let env = empty_env()\n  let state = make_state(env, [anyref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefTest(false, AbsHeapTypeHeapType(I31AbsHeapType)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefTest eq from any\" {\n  let env = empty_env()\n  let state = make_state(env, [anyref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefTest(true, AbsHeapTypeHeapType(EqAbsHeapType)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefTest struct from eq\" {\n  let env = empty_env()\n  let state = make_state(env, [eqref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefTest(true, AbsHeapTypeHeapType(StructAbsHeapType)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefTest fails when target not subtype of operand\" {\n  let env = empty_env()\n  // i31ref on stack, testing for funcref - these are incompatible hierarchies\n  let state = make_state(env, [i31ref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefTest(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n    state,\n  )\n  assert_true(result is Err(_))\n}\n\n///|\ntest \"Typecheck RefTest with concrete type recursive\" {\n  let struct_subtype = @lib.CompTypeSubType(StructCompType([]))\n  let env = empty_env().with_rectype(SingleRecType(struct_subtype))\n  let state = make_state(env, [anyref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefTest(true, HeapType(RecIdx(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefTest with concrete type in global types\" {\n  let struct_subtype = @lib.CompTypeSubType(StructCompType([]))\n  let env : Env = { ..empty_env(), global_types: [struct_subtype] }\n  let state = make_state(env, [anyref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefTest(true, HeapType(TypeIdx(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck RefCast non-nullable\" {\n  let env = empty_env()\n  let state = make_state(env, [anyref_type()])\n  let result = Typecheck::typecheck(\n    @lib.RefCast(false, AbsHeapTypeHeapType(I31AbsHeapType)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck BrOnCast\" {\n  let nullable_i31 = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(I31AbsHeapType)),\n  )\n  let env = empty_env().with_labels([[nullable_i31]])\n  let state = make_state(env, [anyref_type()])\n  let cast_op = @lib.CastOp(true, true)\n  let t = @lib.BrOnCast(\n    LabelIdx(0),\n    cast_op,\n    AbsHeapTypeHeapType(AnyAbsHeapType),\n    AbsHeapTypeHeapType(I31AbsHeapType),\n  )\n  let result = Typecheck::typecheck(t, state)\n  ignore(assert_ok(result))\n}\n\n///|\ntest \"Typecheck BrOnCastFail\" {\n  let env = empty_env().with_labels([[anyref_type()]])\n  let state = make_state(env, [anyref_type()])\n  let cast_op = @lib.CastOp(true, true)\n  let t = @lib.BrOnCastFail(\n    LabelIdx(0),\n    cast_op,\n    AbsHeapTypeHeapType(AnyAbsHeapType),\n    AbsHeapTypeHeapType(I31AbsHeapType),\n  )\n  let result = Typecheck::typecheck(t, state)\n  ignore(assert_ok(result))\n}\n\n// =============================================================================\n// EXCEPTION HANDLING INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck Throw\" {\n  let tag_subtype = @lib.CompTypeSubType(FuncCompType([i32_type()], []))\n  let env = { ..empty_env(), global_types: [tag_subtype] }.push_tag(\n    TagType(TypeIdx(0)),\n  )\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.Throw(TagIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.reachable, false)\n}\n\n///|\ntest \"Typecheck Throw invalid tag\" {\n  let env = empty_env()\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.Throw(TagIdx(0)), state)\n  assert_err(result)\n}\n\n///|\ntest \"Typecheck ThrowRef\" {\n  let exnref = @lib.RefTypeValType(\n    HeapTypeRefType(false, AbsHeapTypeHeapType(ExnAbsHeapType)),\n  )\n  let env = empty_env()\n  let state = make_state(env, [exnref])\n  let result = Typecheck::typecheck(@lib.ThrowRef, state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.reachable, false)\n}\n\n///|\ntest \"Typecheck TryTable empty\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(\n    @lib.TryTable(EmptyBlockType, [], Expr([])),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck TryTable with result\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let block_type = @lib.ValTypeBlockType(i32_type())\n  let result = Typecheck::typecheck(\n    @lib.TryTable(block_type, [], Expr([I32Const(I32(42))])),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n// =============================================================================\n// STRUCT INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck StructNew\" {\n  let struct_type = @lib.CompTypeSubType(\n    StructCompType([FieldType(ValTypeStorageType(i32_type()), Var)]),\n  )\n  let env = { ..empty_env(), global_types: [struct_type] }\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.StructNew(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck StructNewDefault\" {\n  let struct_type = @lib.CompTypeSubType(\n    StructCompType([FieldType(ValTypeStorageType(i32_type()), Var)]),\n  )\n  let env = { ..empty_env(), global_types: [struct_type] }\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.StructNewDefault(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck StructGet\" {\n  let struct_type = @lib.CompTypeSubType(\n    StructCompType([FieldType(ValTypeStorageType(i32_type()), Var)]),\n  )\n  let env = { ..empty_env(), global_types: [struct_type] }\n  let struct_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [struct_ref])\n  let result = Typecheck::typecheck(@lib.StructGet(TypeIdx(0), U32(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck StructGetS\" {\n  let struct_type = @lib.CompTypeSubType(\n    StructCompType([FieldType(PackTypeStorageType(I8PackType), Var)]),\n  )\n  let env = { ..empty_env(), global_types: [struct_type] }\n  let struct_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [struct_ref])\n  let result = Typecheck::typecheck(@lib.StructGetS(TypeIdx(0), U32(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck StructGetU\" {\n  let struct_type = @lib.CompTypeSubType(\n    StructCompType([FieldType(PackTypeStorageType(I16PackType), Var)]),\n  )\n  let env = { ..empty_env(), global_types: [struct_type] }\n  let struct_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [struct_ref])\n  let result = Typecheck::typecheck(@lib.StructGetU(TypeIdx(0), U32(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck StructSet\" {\n  let struct_type = @lib.CompTypeSubType(\n    StructCompType([FieldType(ValTypeStorageType(i32_type()), Var)]),\n  )\n  let env = { ..empty_env(), global_types: [struct_type] }\n  let struct_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [struct_ref, i32_type()])\n  let result = Typecheck::typecheck(@lib.StructSet(TypeIdx(0), U32(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n// =============================================================================\n// ARRAY INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck ArrayNew\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let state = make_state(env, [i32_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.ArrayNew(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck ArrayNewDefault\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.ArrayNewDefault(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck ArrayNewFixed\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let state = make_state(env, [i32_type(), i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.ArrayNewFixed(TypeIdx(0), U32(3)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck ArrayNewData\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let data = @lib.Data(Passive, b\"\")\n  let env = { ..empty_env(), global_types: [array_type] }.push_data(data)\n  let state = make_state(env, [i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.ArrayNewData(TypeIdx(0), DataIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck ArrayNewElem\" {\n  let funcref = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(RefTypeValType(funcref)), Var)),\n  )\n  let elem = @lib.Elem(Passive, FuncsElemKind([]))\n  let env = { ..empty_env(), global_types: [array_type] }.push_elem(elem)\n  let state = make_state(env, [i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.ArrayNewElem(TypeIdx(0), ElemIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_eq(final_state.stack.length(), 1)\n}\n\n///|\ntest \"Typecheck ArrayGet\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type()])\n  let result = Typecheck::typecheck(@lib.ArrayGet(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck ArrayGetS\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(PackTypeStorageType(I8PackType), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type()])\n  let result = Typecheck::typecheck(@lib.ArrayGetS(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck ArrayGetU\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(PackTypeStorageType(I16PackType), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type()])\n  let result = Typecheck::typecheck(@lib.ArrayGetU(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck ArraySet\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.ArraySet(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck ArrayLen\" {\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, AbsHeapTypeHeapType(ArrayAbsHeapType)),\n  )\n  let env = empty_env()\n  let state = make_state(env, [array_ref])\n  let result = Typecheck::typecheck(@lib.ArrayLen, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck ArrayFill\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type(), i32_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.ArrayFill(TypeIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck ArrayCopy\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let env = { ..empty_env(), global_types: [array_type] }\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [\n    array_ref,\n    i32_type(),\n    array_ref,\n    i32_type(),\n    i32_type(),\n  ])\n  let result = Typecheck::typecheck(\n    @lib.ArrayCopy(TypeIdx(0), TypeIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck ArrayInitData\" {\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(i32_type()), Var)),\n  )\n  let data = @lib.Data(Passive, b\"\")\n  let env = { ..empty_env(), global_types: [array_type] }.push_data(data)\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type(), i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.ArrayInitData(TypeIdx(0), DataIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck ArrayInitElem\" {\n  let funcref = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let array_type = @lib.CompTypeSubType(\n    ArrayCompType(FieldType(ValTypeStorageType(RefTypeValType(funcref)), Var)),\n  )\n  let elem = @lib.Elem(Passive, FuncsElemKind([]))\n  let env = { ..empty_env(), global_types: [array_type] }.push_elem(elem)\n  let array_ref = @lib.RefTypeValType(\n    HeapTypeRefType(false, HeapType(TypeIdx(0))),\n  )\n  let state = make_state(env, [array_ref, i32_type(), i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.ArrayInitElem(TypeIdx(0), ElemIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n// =============================================================================\n// MEMORY INIT/DATA INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck MemoryInit\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let data = @lib.Data(Passive, b\"\")\n  let env = empty_env().push_mem(mem_type).push_data(data)\n  let state = make_state(env, [i32_type(), i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.MemoryInit(DataIdx(0), MemIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck DataDrop\" {\n  let data = @lib.Data(Passive, b\"\")\n  let env = empty_env().push_data(data)\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.DataDrop(DataIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck DataDrop invalid index\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.DataDrop(DataIdx(0)), state)\n  assert_err(result)\n}\n\n// =============================================================================\n// TABLE INIT/ELEM INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck TableInit\" {\n  let table_type = @lib.TableType(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    I32Limits(1, None),\n  )\n  let elem = @lib.Elem(Passive, FuncsElemKind([]))\n  let env = empty_env().push_table(table_type).push_elem(elem)\n  let state = make_state(env, [i32_type(), i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.TableInit(ElemIdx(0), TableIdx(0)),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck ElemDrop\" {\n  let elem = @lib.Elem(Passive, FuncsElemKind([]))\n  let env = empty_env().push_elem(elem)\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.ElemDrop(ElemIdx(0)), state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck ElemDrop invalid index\" {\n  let env = empty_env()\n  let state = make_state(env, [])\n  let result = Typecheck::typecheck(@lib.ElemDrop(ElemIdx(0)), state)\n  assert_err(result)\n}\n\n// =============================================================================\n// ADDITIONAL NUMERIC INSTRUCTIONS (missing from original tests)\n// =============================================================================\n\n///|\ntest \"Typecheck I64LtU\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64LtU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64GtS\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64GtS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64LeS\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64LeS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64LeU\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64LeU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64GeS\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64GeS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64GeU\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64GeU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64Ctz\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Ctz, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Popcnt\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Popcnt, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64DivS\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64DivS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64DivU\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64DivU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64RemS\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64RemS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64RemU\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64RemU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64And\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64And, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Or\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Or, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Xor\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Xor, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Shl\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Shl, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64ShrS\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64ShrS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64ShrU\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64ShrU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Rotl\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Rotl, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Rotr\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type(), i64_type()])\n  let result = Typecheck::typecheck(@lib.I64Rotr, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F64Ne\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Ne, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F64Gt\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Gt, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F64Le\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Le, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F64Ge\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Ge, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck F64Ceil\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Ceil, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Floor\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Floor, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Trunc\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Trunc, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Nearest\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Nearest, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Sqrt\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Sqrt, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Min\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Min, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Max\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Max, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64Copysign\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type(), f64_type()])\n  let result = Typecheck::typecheck(@lib.F64Copysign, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F32Trunc\" {\n  let env = empty_env()\n  let state = make_state(env, [f32_type()])\n  let result = Typecheck::typecheck(@lib.F32Trunc, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F32Nearest\" {\n  let env = empty_env()\n  let state = make_state(env, [f32_type()])\n  let result = Typecheck::typecheck(@lib.F32Nearest, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck I64TruncF32U\" {\n  let env = empty_env()\n  let state = make_state(env, [f32_type()])\n  let result = Typecheck::typecheck(@lib.I64TruncF32U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64TruncF64U\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.I64TruncF64U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck F32ConvertI64U\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type()])\n  let result = Typecheck::typecheck(@lib.F32ConvertI64U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f32_type()])\n}\n\n///|\ntest \"Typecheck F64ConvertI32U\" {\n  let env = empty_env()\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(@lib.F64ConvertI32U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck F64ConvertI64U\" {\n  let env = empty_env()\n  let state = make_state(env, [i64_type()])\n  let result = Typecheck::typecheck(@lib.F64ConvertI64U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [f64_type()])\n}\n\n///|\ntest \"Typecheck I32TruncSatF64U\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.I32TruncSatF64U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64TruncSatF32U\" {\n  let env = empty_env()\n  let state = make_state(env, [f32_type()])\n  let result = Typecheck::typecheck(@lib.I64TruncSatF32U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64TruncSatF64U\" {\n  let env = empty_env()\n  let state = make_state(env, [f64_type()])\n  let result = Typecheck::typecheck(@lib.I64TruncSatF64U, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n// =============================================================================\n// ADDITIONAL LOAD/STORE INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I64Load8U\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.I64Load8U(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Load16S\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.I64Load16S(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Load16U\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.I64Load16U(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I64Load32U\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.I64Load32U(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i64_type()])\n}\n\n///|\ntest \"Typecheck I32Store16\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type(), i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.I32Store16(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck I64Store8\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type(), i64_type()])\n  let result = Typecheck::typecheck(\n    @lib.I64Store8(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n///|\ntest \"Typecheck I64Store16\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type(), i64_type()])\n  let result = Typecheck::typecheck(\n    @lib.I64Store16(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [])\n}\n\n// =============================================================================\n// ADDITIONAL SIMD INSTRUCTIONS\n// =============================================================================\n\n///|\ntest \"Typecheck I8x16Shuffle\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let t = @lib.I8x16Shuffle(\n    LaneIdx(0),\n    LaneIdx(1),\n    LaneIdx(2),\n    LaneIdx(3),\n    LaneIdx(4),\n    LaneIdx(5),\n    LaneIdx(6),\n    LaneIdx(7),\n    LaneIdx(8),\n    LaneIdx(9),\n    LaneIdx(10),\n    LaneIdx(11),\n    LaneIdx(12),\n    LaneIdx(13),\n    LaneIdx(14),\n    LaneIdx(15),\n  )\n  let result = Typecheck::typecheck(t, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Swizzle\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16Swizzle, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128AnyTrue\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.V128AnyTrue, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I8x16AllTrue\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16AllTrue, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I8x16Bitmask\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16Bitmask, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I16x8Bitmask\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8Bitmask, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I32x4Bitmask\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4Bitmask, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64x2Bitmask\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Bitmask, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [i32_type()])\n}\n\n///|\ntest \"Typecheck V128Or\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.V128Or, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Xor\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.V128Xor, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Andnot\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.V128Andnot, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Neg\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16Neg, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Popcnt\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16Popcnt, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Sub\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16Sub, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16AddSatS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16AddSatS, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16AddSatU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16AddSatU, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Add\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Add, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Sub\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Sub, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Mul\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Mul, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Add\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Add, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Sub\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Sub, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Mul\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Mul, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Add\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Add, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Sub\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Sub, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Mul\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Mul, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Div\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Div, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Abs\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Abs, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Neg\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Neg, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Sqrt\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Sqrt, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Abs\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Abs, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Neg\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Neg, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Sqrt\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Sqrt, state)\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load32Zero\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load32Zero(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load64Zero\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load64Zero(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load8x8S\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load8x8S(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load8x8U\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load8x8U(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load16x4S\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load16x4S(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load16x4U\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load16x4U(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load32x2S\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load32x2S(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load32x2U\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load32x2U(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load8Splat\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load8Splat(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load16Splat\" {\n  let mem_type = @lib.MemType(I32Limits(1, None))\n  let env = empty_env().push_mem(mem_type)\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load16Splat(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let final_state = assert_ok(result)\n  assert_stack(final_state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD LOAD TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck V128Load32Splat\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load32Splat(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load64Splat\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load64Splat(MemArg(U32(0), None, U64(0))),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load32Lane\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type(), v128_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load32Lane(MemArg(U32(0), None, U64(0)), LaneIdx(0)),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck V128Load64Lane\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type(), v128_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Load64Lane(MemArg(U32(0), None, U64(0)), LaneIdx(0)),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD STORE TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck V128Store8Lane\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type(), v128_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Store8Lane(MemArg(U32(0), None, U64(0)), LaneIdx(0)),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [])\n}\n\n///|\ntest \"Typecheck V128Store32Lane\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type(), v128_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Store32Lane(MemArg(U32(0), None, U64(0)), LaneIdx(0)),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [])\n}\n\n///|\ntest \"Typecheck V128Store64Lane\" {\n  let env = empty_env().push_mem(MemType(I32Limits(1, None)))\n  let state = make_state(env, [i32_type(), v128_type()])\n  let result = Typecheck::typecheck(\n    @lib.V128Store64Lane(MemArg(U32(0), None, U64(0)), LaneIdx(0)),\n    state,\n  )\n  let state = assert_ok(result)\n  assert_stack(state, [])\n}\n\n// =============================================================================\n// SIMD CONVERSION TESTS\n// =============================================================================\n\n///|\ntest \"Typecheck F32x4DemoteF64x2Zero\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4DemoteF64x2Zero, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2PromoteLowF32x4\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2PromoteLowF32x4, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4TruncSatF32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4TruncSatF32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4TruncSatF32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4TruncSatF32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4ConvertI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4ConvertI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4ConvertI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4ConvertI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4TruncSatF64x2SZero\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4TruncSatF64x2SZero, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4TruncSatF64x2UZero\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4TruncSatF64x2UZero, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2ConvertLowI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2ConvertLowI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2ConvertLowI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2ConvertLowI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD i8x16 TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck I8x16NarrowI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16NarrowI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16NarrowI16x8U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16NarrowI16x8U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16Shl\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I8x16Shl, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16ShrS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I8x16ShrS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16ShrU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I8x16ShrU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16SubSatS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16SubSatS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16SubSatU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16SubSatU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16MinS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16MinS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16MinU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16MinU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16MaxS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16MaxS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16MaxU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16MaxU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16AvgrU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16AvgrU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD i16x8 TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck I16x8Abs\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8Abs, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8AllTrue\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8AllTrue, state)\n  let state = assert_ok(result)\n  assert_stack(state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I16x8Q15mulrSatS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8Q15mulrSatS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8NarrowI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8NarrowI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8NarrowI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8NarrowI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtendLowI8x16S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtendLowI8x16S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtendHighI8x16S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtendHighI8x16S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtendLowI8x16U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtendLowI8x16U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtendHighI8x16U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtendHighI8x16U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8Shl\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I16x8Shl, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ShrS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ShrS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ShrU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ShrU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8Add\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8Add, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8AddSatS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8AddSatS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8AddSatU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8AddSatU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8Sub\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8Sub, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8SubSatS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8SubSatS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8SubSatU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8SubSatU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8MinS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8MinS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8MinU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8MinU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8MaxS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8MaxS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8MaxU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8MaxU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8AvgrU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8AvgrU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtmulLowI8x16S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtmulLowI8x16S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtmulHighI8x16S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtmulHighI8x16S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtmulLowI8x16U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtmulLowI8x16U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtmulHighI8x16U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtmulHighI8x16U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtaddPairwiseI8x16S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtaddPairwiseI8x16S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8ExtaddPairwiseI8x16U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8ExtaddPairwiseI8x16U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD i32x4 TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck I32x4Abs\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4Abs, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4Neg\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4Neg, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtendLowI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtendLowI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtendHighI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtendHighI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtendLowI16x8U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtendLowI16x8U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtendHighI16x8U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtendHighI16x8U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4Shl\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I32x4Shl, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ShrS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ShrS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ShrU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ShrU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4Add\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4Add, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4Mul\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4Mul, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4MinS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4MinS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4MinU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4MinU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4MaxS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4MaxS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4MaxU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4MaxU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4DotI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4DotI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtmulLowI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtmulLowI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtmulHighI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtmulHighI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtmulLowI16x8U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtmulLowI16x8U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtmulHighI16x8U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtmulHighI16x8U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtaddPairwiseI16x8S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtaddPairwiseI16x8S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4ExtaddPairwiseI16x8U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4ExtaddPairwiseI16x8U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD i64x2 TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck I64x2Abs\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Abs, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Neg\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Neg, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2AllTrue\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2AllTrue, state)\n  let state = assert_ok(result)\n  assert_stack(state, [i32_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtendLowI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtendLowI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtendHighI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtendHighI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtendLowI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtendLowI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtendHighI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtendHighI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Shl\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Shl, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ShrS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ShrS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ShrU\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), i32_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ShrU, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Eq\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Eq, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2Ne\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2Ne, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2LtS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2LtS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2GtS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2GtS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2LeS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2LeS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2GeS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2GeS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtmulLowI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtmulLowI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtmulHighI32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtmulHighI32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtmulLowI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtmulLowI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2ExtmulHighI32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2ExtmulHighI32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD f32x4 TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck F32x4Ceil\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Ceil, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Floor\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Floor, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Trunc\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Trunc, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Nearest\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Nearest, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Min\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Min, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Max\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Max, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Pmin\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Pmin, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4Pmax\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4Pmax, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD f64x2 TESTS (Missing)\n// =============================================================================\n\n///|\ntest \"Typecheck F64x2Ceil\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Ceil, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Floor\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Floor, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Trunc\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Trunc, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Nearest\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Nearest, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Min\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Min, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Max\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Max, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Pmin\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Pmin, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2Pmax\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2Pmax, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n// =============================================================================\n// SIMD RELAXED TESTS\n// =============================================================================\n\n///|\ntest \"Typecheck I8x16RelaxedSwizzle\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16RelaxedSwizzle, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4RelaxedTruncF32x4S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4RelaxedTruncF32x4S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4RelaxedTruncF32x4U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4RelaxedTruncF32x4U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4RelaxedTruncZeroF64x2S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4RelaxedTruncZeroF64x2S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4RelaxedTruncZeroF64x2U\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4RelaxedTruncZeroF64x2U, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4RelaxedMadd\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4RelaxedMadd, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4RelaxedNmadd\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4RelaxedNmadd, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2RelaxedMadd\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2RelaxedMadd, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2RelaxedNmadd\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2RelaxedNmadd, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I8x16RelaxedLaneselect\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I8x16RelaxedLaneselect, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8RelaxedLaneselect\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8RelaxedLaneselect, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4RelaxedLaneselect\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4RelaxedLaneselect, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I64x2RelaxedLaneselect\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I64x2RelaxedLaneselect, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4RelaxedMin\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4RelaxedMin, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F32x4RelaxedMax\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F32x4RelaxedMax, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2RelaxedMin\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2RelaxedMin, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck F64x2RelaxedMax\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.F64x2RelaxedMax, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8RelaxedQ15mulrS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8RelaxedQ15mulrS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I16x8RelaxedDotI8x16I7x16S\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I16x8RelaxedDotI8x16I7x16S, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n\n///|\ntest \"Typecheck I32x4RelaxedDotI8x16I7x16AddS\" {\n  let env = empty_env()\n  let state = make_state(env, [v128_type(), v128_type(), v128_type()])\n  let result = Typecheck::typecheck(@lib.I32x4RelaxedDotI8x16I7x16AddS, state)\n  let state = assert_ok(result)\n  assert_stack(state, [v128_type()])\n}\n","///|\npub fn diff(rt1 : RefType, rt2 : RefType) -> Result[RefType, String] {\n  let ht1 = rt1.get_heap_type()\n  let n1 = rt1.is_nullable()\n  let n2 = rt2.is_nullable()\n\n  // Result nullability: nullable only if rt1 was nullable AND rt2 was not\n  let null_out = n1 && not(n2)\n  Ok(HeapTypeRefType(null_out, ht1))\n}\n\n///|\npub trait Validate {\n  validate(Self, Env) -> Result[Unit, String]\n}\n\n///|\npub trait ValidateMax {\n  validate_max(Self, Env, UInt64) -> Result[Unit, String]\n}\n\n///|\npub impl Validate for NumType with validate(_, _) {\n  Ok(())\n}\n\n///|\npub impl Validate for TypeIdx with validate(self, env) {\n  if env.resolve_typeidx_subtype(self) is Some(_) {\n    Ok(())\n  } else {\n    Err(\"No type exists for TypeIdx\")\n  }\n}\n\n///|\npub impl Validate for HeapType with validate(self, env) {\n  match self {\n    AbsHeapTypeHeapType(abs) => Validate::validate(abs, env)\n    HeapType(tidx) => Validate::validate(tidx, env)\n    DefTypeHeapType(dt) => Validate::validate(dt, env)\n  }\n}\n\n///|\npub impl Validate for DefType with validate(self, env) {\n  let DefType(rt, _) = self\n  let env2 = env_with_rectype(env, rt)\n  match self.project() {\n    Some(st) => Validate::validate(st, env2)\n    None => Err(\"Invalid SubType Index\")\n  }\n}\n\n///|\npub impl Validate for AbsHeapType with validate(_, _) {\n  Ok(())\n}\n\n///|\npub impl Validate for ValType with validate(self, env) {\n  match self {\n    RefTypeValType(rt) => Validate::validate(rt, env)\n    VecTypeValType => Ok(())\n    NumTypeValType(nt) => Validate::validate(nt, env)\n    BotValType => Ok(())\n  }\n}\n\n///|\npub impl[T : Validate] Validate for Array[T] with validate(self, env) {\n  for v in self {\n    if Validate::validate(v, env) is Err(t) {\n      return Err(t)\n    }\n  }\n  Ok(())\n}\n\n///|\npub impl Validate for BlockType with validate(self, env) {\n  match self {\n    ValTypeBlockType(vt) => Validate::validate(vt, env)\n    EmptyBlockType => Ok(())\n    TypeIdxBlockType(tidx) =>\n      match env.resolve_typeidx_subtype(tidx) {\n        Some(st) =>\n          match st.get_comptype() {\n            FuncCompType(_, _) => Ok(())\n            _ => Err(\"Expected Func Type for block type\")\n          }\n        None => Err(\"Invalid TypeIdx for block type\")\n      }\n  }\n}\n\n///|\npub impl Validate for FuncType with validate(self, env) {\n  let FuncType(t0, t1) = self\n  match Validate::validate(t0, env) {\n    Ok(_) => Validate::validate(t1, env)\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Validate for CompType with validate(self, env) {\n  match self {\n    StructCompType(fts) => Validate::validate(fts, env)\n    ArrayCompType(ft) => Validate::validate(ft, env)\n    FuncCompType(v0, v1) =>\n      match Validate::validate(v0, env) {\n        Ok(_) => Validate::validate(v1, env)\n        Err(t) => Err(t)\n      }\n  }\n}\n\n///|\npub impl Validate for RefType with validate(self, env) {\n  match self {\n    HeapTypeRefType(_, ht) => Validate::validate(ht, env)\n    AbsHeapTypeRefType(abs) => Validate::validate(abs, env)\n  }\n}\n\n///|\npub impl Validate for FieldType with validate(self, env) {\n  let FieldType(st, _) = self\n  Validate::validate(st, env)\n}\n\n///|\npub impl Validate for StorageType with validate(self, env) {\n  match self {\n    ValTypeStorageType(vt) => Validate::validate(vt, env)\n    PackTypeStorageType(_) => Ok(())\n  }\n}\n\n///|\npub impl Validate for RecType with validate(self, env) {\n  match self {\n    SingleRecType(st) => Validate::validate(st, env)\n    GroupRecType(sts) => Validate::validate(sts, env)\n  }\n}\n\n///|\npub impl Validate for SubType with validate(self, env) {\n  match self {\n    SubType(_, matches, ct) => {\n      for m in matches {\n        match Validate::validate(m, env) {\n          Ok(_) if env.resolve_subtype(m) is Some(t) &&\n            Match::matches(ct, t.get_comptype(), env) => ()\n          Ok(_) => return Err(\"Invalid subtype\")\n          Err(t) => return Err(t)\n        }\n      }\n      Ok(())\n    }\n    CompTypeSubType(ct) => Validate::validate(ct, env)\n  }\n}\n\n///|\npub impl ValidateMax for Limits with validate_max(self, _, k) {\n  match self {\n    I32Limits(n, m) => {\n      let n = n.to_uint64()\n      if n <= k &&\n        (\n          m is None ||\n          (m is Some(m) && n <= m.to_uint64() && m.to_uint64() <= k)\n        ) {\n        Ok(())\n      } else {\n        Err(\"Invalid range for limits\")\n      }\n    }\n    I64Limits(n, m) =>\n      if n <= k && (m is None || (m is Some(m) && n <= m && m <= k)) {\n        Ok(())\n      } else {\n        Err(\"Invalid range for limits\")\n      }\n  }\n}\n\n///|\npub impl Validate for LabelIdx with validate(self, env) {\n  let LabelIdx(i) = self\n  if i < env.labels.length().reinterpret_as_uint() {\n    Ok(())\n  } else {\n    Err(\"Invalid LabelIdx\")\n  }\n}\n\n///|\npub impl Validate for TagIdx with validate(self, env) {\n  let TagIdx(i) = self\n  if i < env.tags.length().reinterpret_as_uint() {\n    Ok(())\n  } else {\n    Err(\"Invalid TagIdx\")\n  }\n}\n\n///|\npub impl Validate for TagType with validate(self, env) {\n  let TagType(tidx) = self\n  if Validate::validate(tidx, env) is Err(t) {\n    return Err(t)\n  }\n  match env.resolve_comptype(tidx) {\n    Some(FuncCompType(params, results)) => {\n      if results.length() != 0 {\n        return Err(\"Tag type must have empty result list\")\n      }\n      Validate::validate(params, env)\n    }\n    _ => Err(\"TagType not found or not a function type\")\n  }\n}\n\n///|\npub impl Validate for TagSec with validate(self, env) {\n  let TagSec(t) = self\n  Validate::validate(t, env)\n}\n\n///|\npub impl Validate for Catch with validate(self, env) {\n  match self {\n    Catch(t, l) =>\n      match Validate::validate(t, env) {\n        Ok(_) => Validate::validate(l, env)\n        Err(t) => Err(t)\n      }\n    CatchRef(t, l) =>\n      match Validate::validate(t, env) {\n        Ok(_) => Validate::validate(l, env)\n        Err(t) => Err(t)\n      }\n    CatchAll(l) => Validate::validate(l, env)\n    CatchAllRef(l) => Validate::validate(l, env)\n  }\n}\n\n///|\npub impl Validate for GlobalType with validate(self, env) {\n  let GlobalType(vt, _) = self\n  Validate::validate(vt, env)\n}\n\n///|\npub impl Validate for MemType with validate(self, env) {\n  let MemType(lim) = self\n  ValidateMax::validate_max(lim, env, 65536)\n}\n\n///|\npub impl Validate for TableType with validate(self, env) {\n  let TableType(rt, lim) = self\n  match Validate::validate(rt, env) {\n    Ok(_) => ValidateMax::validate_max(lim, env, 4294967295)\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Validate for ExternType with validate(self, env) {\n  match self {\n    TagExternType(tt) => Validate::validate(tt, env)\n    GlobalExternType(gt) => Validate::validate(gt, env)\n    MemExternType(mt) => Validate::validate(mt, env)\n    TableExternType(tt) => Validate::validate(tt, env)\n    FuncExternType(tidx) =>\n      match env.resolve_functype(tidx) {\n        Some(_) => Ok(())\n        None => Err(\"Invalid ExternType: Func extern type not found\")\n      }\n  }\n}\n\n///|\nfn is_const_instr(ins : Instruction) -> Bool {\n  match ins {\n    I32Const(_) => true\n    I64Const(_) => true\n    F32Const(_) => true\n    F64Const(_) => true\n    V128Const(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) => true\n    RefNull(_) => true\n    RefFunc(_) => true\n    GlobalGet(_) => true\n\n    // Optional: enable later if desired/confirmed by spec subset you target\n    // RefI31 => true\n    _ => false\n  }\n}\n\n///|\nfn validate_const_expr(\n  env : Env,\n  expr : Expr,\n  want : ValType,\n) -> Result[Unit, String] {\n  let Expr(instrs) = expr\n\n  // syntactic const restriction\n  for ins in instrs {\n    if !is_const_instr(ins) {\n      return Err(\"initializer expression is not constant\")\n    }\n  }\n\n  // typecheck it under an empty stack/locals/labels context\n  // (but with access to env globals, funcs, etc)\n  let env_tc = Env::{ ..env, locals: [], labels: [], return_type: None }\n  let st0 = TcState::{ env: env_tc, stack: [], reachable: true }\n  let st1 = match Typecheck::typecheck(expr, st0) {\n    Ok(s) => s\n    Err(e) => return Err(e)\n  }\n  if !st1.reachable {\n    return Err(\"const expr is unreachable\")\n  }\n  if st1.stack.length() != 1 {\n    return Err(\"const expr must leave exactly one value on the stack\")\n  }\n  let actual = st1.stack[0]\n  if Match::matches(actual, want, env_tc) {\n    Ok(())\n  } else {\n    Err(\"const expr result type mismatch\")\n  }\n}\n\n///|\nfn validate_global(env : Env, g : Global) -> Result[GlobalType, String] {\n  let Global(gt, init) = g\n  if Validate::validate(gt, env) is Err(t) {\n    return Err(t) // checks vt validity\n  }\n  let GlobalType(vt, _mut) = gt\n  match validate_const_expr(env, init, vt) {\n    Ok(_) => Ok(gt)\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub fn validate_globalsec(\n  globalsec : GlobalSec?,\n  env0 : Env,\n) -> Result[Env, String] {\n  match globalsec {\n    None => Ok(env0)\n    Some(GlobalSec(gs)) => {\n      let mut env = env0\n      let out = env.globals.copy()\n      for g in gs {\n        // Validate under env that includes *previous* globals only\n        let gt = match validate_global(env, g) {\n          Ok(gt) => gt\n          Err(t) => return Err(t)\n        }\n\n        // Extend global index space\n        out.push(gt)\n        env = env.with_globals(out)\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\npub fn validate_tagsec(tagsec : TagSec?, env0 : Env) -> Result[Env, String] {\n  match tagsec {\n    None => Ok(env0)\n    Some(TagSec(tags)) => {\n      let mut env = env0\n      let out = env.tags.copy()\n      for t in tags {\n        // validate tag type under current env\n        if Validate::validate(t, env) is Err(t) {\n          return Err(t)\n        }\n\n        // extend tag index space incrementally\n        out.push(t)\n        env = Env::{\n          global_types: env.global_types,\n          rec_stack: env.rec_stack,\n          funcs: env.funcs,\n          tables: env.tables,\n          mems: env.mems,\n          globals: env.globals,\n          elems: env.elems,\n          datas: env.datas,\n          tags: out,\n          locals: env.locals,\n          labels: env.labels,\n          return_type: env.return_type,\n        }\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\npub fn validate_memsec(memsec : MemSec?, env0 : Env) -> Result[Env, String] {\n  match memsec {\n    None => Ok(env0)\n    Some(MemSec(ms)) => {\n      let mut env = env0\n      for mt in ms {\n        match Validate::validate(mt, env) {\n          Ok(_) => ()\n          Err(e) => return Err(e)\n        }\n        env = env.push_mem(mt)\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\nfn validate_table(env : Env, t : Table) -> Result[TableType, String] {\n  let Table(tt, init_opt) = t\n  match Validate::validate(tt, env) {\n    Ok(_) => ()\n    Err(e) => return Err(e)\n  }\n  let TableType(rt, _lim) = tt\n  match init_opt {\n    None => Ok(tt)\n    Some(init) => {\n      // init expr must be const and produce value type rt\n      let want = @lib.RefTypeValType(rt)\n      match validate_const_expr(env, init, want) {\n        Ok(_) => Ok(tt)\n        Err(e) => Err(e)\n      }\n    }\n  }\n}\n\n///|\npub fn validate_tablesec(\n  tablesec : TableSec?,\n  env0 : Env,\n) -> Result[Env, String] {\n  match tablesec {\n    None => Ok(env0)\n    Some(TableSec(ts)) => {\n      let mut env = env0\n      for t in ts {\n        let tt = match validate_table(env, t) {\n          Ok(x) => x\n          Err(e) => return Err(e)\n        }\n        env = env.push_table(tt)\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\nfn validate_locals_decls(\n  env : Env,\n  decls : Array[Locals],\n) -> Result[Unit, String] {\n  for d in decls {\n    let Locals(n, vt) = d\n    if Validate::validate(vt, env) is Err(e) {\n      return Err(e)\n    }\n    let count = n.reinterpret_as_int()\n    if count < 0 {\n      return Err(\"locals: negative count\")\n    }\n    if !has_default(vt) {\n      return Err(\"locals: type has no default value\")\n    }\n  }\n  Ok(())\n}\n\n///|\nfn validate_func_body_against_functype(\n  env : Env,\n  ft : FuncType,\n  f : Func,\n) -> Result[Unit, String] {\n  let FuncType(params, results) = ft\n  match f {\n    Func(local_decls, body) => {\n      // Validate local declarations\n      if validate_locals_decls(env, local_decls) is Err(e) {\n        return Err(e)\n      }\n\n      // Expand locals vector = params ++ expanded locals\n      let locals_extra = match expand_locals(local_decls) {\n        Ok(xs) => xs\n        Err(e) => return Err(e)\n      }\n      let all_locals = params.copy()\n      for vt in locals_extra {\n        all_locals.push(vt)\n      }\n\n      // Extend context:\n      // - locals\n      // - labels appended by results (function label)\n      // - return appended by results\n      let env1 = env\n        .with_locals(all_locals)\n        .with_labels(\n          {\n            let ls = env.labels.copy()\n            ls.push(results)\n            ls\n          },\n        )\n        .with_return_type(Some(results))\n      let st0 = TcState::{ env: env1, stack: [], reachable: true }\n      let st1 = match Typecheck::typecheck(body, st0) {\n        Ok(s) => s\n        Err(e) => return Err(e)\n      }\n\n      // Enforce results at end if reachable\n      if st1.reachable {\n        if st1.stack.length() != results.length() {\n          return Err(\"function body leaves extra values on stack\")\n        }\n        // Check types match\n        for i in 0..<results.length() {\n          if !Match::matches(st1.stack[i], results[i], env1) {\n            return Err(\"function body result type mismatch\")\n          }\n        }\n      }\n      Ok(())\n    }\n    TFunc(local_vals, texpr) => {\n      // TFunc(Array[ValType], TExpr) - local_vals contains the full local signature (params + extra locals)\n      // Wait, does it contain params?\n      // Given FuncType has params, and TFunc is the definition.\n      // If TFunc matches the structure of Func (replacing Array[Locals] with Array[ValType]),\n      // then local_vals are the EXTRA locals.\n      // But TFunc is usually \"fully typed\". Let's assume local_vals = extra_locals flattened.\n\n      let all_locals = params.copy()\n      for vt in local_vals {\n        all_locals.push(vt)\n      }\n      let env1 = env\n        .with_locals(all_locals)\n        .with_labels(\n          {\n            let ls = env.labels.copy()\n            ls.push(results)\n            ls\n          },\n        )\n        .with_return_type(Some(results))\n      let st0 = TcState::{ env: env1, stack: [], reachable: true }\n      let st1 = match Typecheck::typecheck(texpr, st0) {\n        Ok(s) => s\n        Err(e) => return Err(e)\n      }\n      if st1.reachable {\n        if st1.stack.length() != results.length() {\n          return Err(\"typed function body leaves extra values on stack\")\n        }\n        for i in 0..<results.length() {\n          if !Match::matches(st1.stack[i], results[i], env1) {\n            return Err(\"typed function body result type mismatch\")\n          }\n        }\n      }\n      Ok(())\n    }\n  }\n}\n\n///|\npub fn validate_codesec(\n  codesec : CodeSec?,\n  funcsec : FuncSec?,\n  env : Env,\n) -> Result[Unit, String] {\n  match (codesec, funcsec) {\n    (None, None) => Ok(())\n    (Some(CodeSec(_)), None) => Err(\"codesec present without funcsec\")\n    (None, Some(FuncSec(ts))) =>\n      if ts.length() == 0 {\n        Ok(())\n      } else {\n        Err(\"funcsec present without codesec\")\n      }\n    (Some(CodeSec(bodies)), Some(FuncSec(type_idxs))) => {\n      if bodies.length() != type_idxs.length() {\n        return Err(\"codesec length does not match funcsec length\")\n      }\n      let n_defined = bodies.length()\n      let n_total = env.funcs.length()\n      let n_imported = n_total - n_defined\n      if n_imported < 0 {\n        return Err(\"internal: negative imported func count\")\n      }\n      for i in 0..<bodies.length() {\n        let ft = match env.funcs.get(n_imported + i) {\n          Some(x) => x\n          None => return Err(\"internal: missing functype for code body\")\n        }\n        if validate_func_body_against_functype(env, ft, bodies[i]) is Err(e) {\n          return Err(e)\n        }\n      }\n      Ok(())\n    }\n  }\n}\n\n///|\npub fn validate_funcsec(funcsec : FuncSec?, env0 : Env) -> Result[Env, String] {\n  match funcsec {\n    None => Ok(env0)\n    Some(FuncSec(type_idxs)) => {\n      let mut env = env0\n      for tidx in type_idxs {\n        // Each TypeIdx must resolve to a function type\n        let ft = match env.resolve_functype(tidx) {\n          Some(x) => x\n          None => return Err(\"funcsec: typeidx does not resolve to functype\")\n        }\n        env = env.push_func(ft)\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\npub impl Validate for DataMode with validate(self, env) {\n  match self {\n    Passive => Ok(())\n    Active(memidx, offset_expr) => {\n      // memory must exist\n      let MemType(lim) = match env.get_memtype(memidx) {\n        None => return Err(\"data.active: invalid memory index\")\n        Some(mt) => mt\n      }\n\n      // address type at depends on limits (i32 or i64)\n      let at = lim.addr_valtype()\n\n      // expr : at const\n      validate_const_expr(env, offset_expr, at)\n    }\n  }\n}\n\n///|\npub impl Validate for Data with validate(self, env) {\n  let Data(mode, _) = self\n  Validate::validate(mode, env)\n}\n\n///|\npub fn validate_datasec(datasec : DataSec?, env0 : Env) -> Result[Env, String] {\n  match datasec {\n    None => Ok(env0)\n    Some(DataSec(ds)) => {\n      let mut env = env0\n      for d in ds {\n        // validate under env that includes previous data segments\n        if Validate::validate(d, env) is Err(e) {\n          return Err(e)\n        }\n        env = env.push_data(d)\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\nfn validate_elem_mode(\n  env : Env,\n  mode : ElemMode,\n  rt : RefType,\n) -> Result[Unit, String] {\n  match mode {\n    Passive => Ok(())\n    Declarative => Ok(())\n    Active(tidx, offset_expr) => {\n      // table must exist\n      let TableType(rt_table, lim) = match env.get_table_type(tidx) {\n        None => return Err(\"elem.active: invalid table index\")\n        Some(tt) => tt\n      }\n\n      // require rt ≤ rt_table\n      // If your Match::matches works on RefType, use that.\n      // Otherwise use ValType wrapper.\n      let ok = Match::matches(\n        @lib.RefTypeValType(rt),\n        RefTypeValType(rt_table),\n        env,\n      )\n      if !ok {\n        return Err(\"elem.active: elem type does not match table element type\")\n      }\n\n      // offset expr : at const\n      let at = lim.addr_valtype()\n      validate_const_expr(env, offset_expr, at)\n    }\n  }\n}\n\n///|\npub impl Validate for ElemKind with validate(self, env) {\n  match self {\n    // elemtype is funcref; initializers are function indices\n    FuncsElemKind(fs) => {\n      for f in fs {\n        if !env.has_func(f) {\n          return Err(\"elem.funcs: invalid function index\")\n        }\n      }\n      Ok(())\n    }\n\n    // legacy element expressions: elemtype is funcref; each expr must be const funcref\n    FuncExprsElemKind(exprs) => {\n      let want = funcref_valtype()\n      for e in exprs {\n        if validate_const_expr(env, e, want) is Err(t) {\n          return Err(t)\n        }\n      }\n      Ok(())\n    }\n\n    // typed element expressions: elemtype is provided; each expr must be const of that type\n    TypedExprsElemKind(rt, exprs) => {\n      if Validate::validate(rt, env) is Err(t) {\n        return Err(t)\n      }\n      let want = @lib.RefTypeValType(rt)\n      for e in exprs {\n        if validate_const_expr(env, e, want) is Err(t) {\n          return Err(t)\n        }\n      }\n      Ok(())\n    }\n  }\n}\n\n///|\npub impl Validate for Elem with validate(self, env) {\n  let Elem(mode, kind) = self\n\n  // kind validity (incl. elemtype and init exprs)\n  if Validate::validate(kind, env) is Err(t) {\n    return Err(t)\n  }\n\n  // derive elemtype from kind and validate it\n  let rt = elem_reftype(self)\n  if Validate::validate(rt, env) is Err(t) {\n    return Err(t)\n  }\n\n  // mode validity depends on elemtype\n  validate_elem_mode(env, mode, rt)\n}\n\n///|\npub fn validate_elemsec(elemsec : ElemSec?, env0 : Env) -> Result[Env, String] {\n  match elemsec {\n    None => Ok(env0)\n    Some(ElemSec(es)) => {\n      let mut env = env0\n      for e in es {\n        if Validate::validate(e, env) is Err(t) {\n          return Err(t)\n        }\n        let elems = env.elems.copy()\n        elems.push(e)\n        env = env.with_elems(elems)\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\npub impl Validate for Import with validate(self, env) {\n  let Import(_, _, xt) = self\n  Validate::validate(xt, env)\n}\n\n///|\npub fn validate_importsec(\n  importsec : ImportSec?,\n  env0 : Env,\n) -> Result[Env, String] {\n  match importsec {\n    None => Ok(env0)\n    Some(ImportSec(imps)) => {\n      let mut env = env0\n      for imp in imps {\n        if Validate::validate(imp, env) is Err(e) {\n          return Err(e)\n        }\n        let Import(_, _, et) = imp\n        match et {\n          FuncExternType(tidx) => {\n            let ft = match env.resolve_functype(tidx) {\n              Some(x) => x\n              None => return Err(\"import func: type index is not a functype\")\n            }\n            env = env.push_func(ft)\n          }\n          TableExternType(tt) => env = env.push_table(tt)\n          MemExternType(mt) => env = env.push_mem(mt)\n          GlobalExternType(gt) => env = env.push_global(gt)\n          TagExternType(tt) => env = env.push_tag(tt)\n        }\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\npub fn validate_startsec(\n  startsec : StartSec?,\n  env : Env,\n) -> Result[Unit, String] {\n  match startsec {\n    None => Ok(())\n    Some(StartSec(fidx)) => {\n      let FuncType(params, results) = match env.get_functype_by_funcidx(fidx) {\n        None => return Err(\"start: invalid function index\")\n        Some(ft) => ft\n      }\n      if params.length() != 0 {\n        return Err(\"start function must have empty parameter list\")\n      }\n      if results.length() != 0 {\n        return Err(\"start function must have empty result list\")\n      }\n      Ok(())\n    }\n  }\n}\n\n///|\npub impl Validate for FuncIdx with validate(self, env) {\n  if env.has_func(self) {\n    Ok(())\n  } else {\n    Err(\"invalid func index\")\n  }\n}\n\n///|\npub impl Validate for TableIdx with validate(self, env) {\n  match env.get_table_type(self) {\n    Some(_) => Ok(())\n    None => Err(\"invalid table index\")\n  }\n}\n\n///|\npub impl Validate for MemIdx with validate(self, env) {\n  let MemIdx(i) = self\n  match env.get_memtype(i) {\n    Some(_) => Ok(())\n    None => Err(\"invalid mem index\")\n  }\n}\n\n///|\npub impl Validate for GlobalIdx with validate(self, env) {\n  let GlobalIdx(i) = self\n  match env.get_global_type(i) {\n    Some(_) => Ok(())\n    None => Err(\"invalid global index\")\n  }\n}\n\n///|\npub impl Validate for ExternIdx with validate(self, env) {\n  match self {\n    FuncExternIdx(i) => Validate::validate(i, env)\n    TableExternIdx(i) => Validate::validate(i, env)\n    MemExternIdx(i) => Validate::validate(i, env)\n    GlobalExternIdx(i) => Validate::validate(i, env)\n    TagExternIdx(i) => Validate::validate(i, env)\n  }\n}\n\n///|\npub impl Validate for Export with validate(self, env) {\n  let Export(_, exi) = self\n  Validate::validate(exi, env)\n}\n\n///|\npub fn validate_exportsec(\n  exportsec : ExportSec?,\n  env : Env,\n) -> Result[Unit, String] {\n  match exportsec {\n    None => Ok(())\n    Some(ExportSec(es)) => Validate::validate(es, env)\n  }\n}\n\n///|\n/// Validates the type section incrementally and extends env.global_types.\npub fn validate_typesec(typesec : TypeSec?, env0 : Env) -> Result[Env, String] {\n  match typesec {\n    None => Ok(env0)\n    Some(TypeSec(rts)) => {\n      let mut env = env0\n      for rt in rts {\n        env = match validate_rectype_and_extend(env, rt) {\n          Ok(e) => e\n          Err(t) => return Err(t)\n        }\n      }\n      Ok(env)\n    }\n  }\n}\n\n///|\nfn validate_rectype_and_extend(env : Env, rt : RecType) -> Result[Env, String] {\n  // Validate rectype under recursive context (for RecIdx references)\n  let env_rec = env_with_rectype(env, rt)\n\n  // Validate rectype itself under env_rec\n  if Validate::validate(rt, env_rec) is Err(e) {\n    return Err(e)\n  }\n\n  // If ok, append its defined subtypes to env.global_types\n  Ok(env.append_rectype_types(rt))\n}\n\n///|\npub fn validate_datacnt(\n  datacnt_opt : DataCntSec?,\n  datasec_opt : DataSec?,\n) -> Result[Unit, String] {\n  match datacnt_opt {\n    None => Ok(())\n    Some(DataCntSec(U32(n))) => {\n      let actual : UInt = match datasec_opt {\n        None => return Err(\"datacount section present but no data section\")\n        Some(DataSec(ds)) => ds.length().reinterpret_as_uint()\n      }\n      if n == actual {\n        Ok(())\n      } else {\n        Err(\"datacount does not match number of data segments\")\n      }\n    }\n  }\n}\n\n///|\n/// Validates exports including name uniqueness requirement.\nfn validate_exportsec_unique(\n  exportsec : ExportSec?,\n  env : Env,\n) -> Result[Unit, String] {\n  match exportsec {\n    None => Ok(())\n    Some(ExportSec(es)) => {\n      // First validate all exports\n      if Validate::validate(es, env) is Err(t) {\n        return Err(t)\n      }\n      // Check for duplicate export names\n      let names : Array[Name] = []\n      for e in es {\n        let Export(name, _) = e\n        for existing in names {\n          if existing == name {\n            return Err(\"duplicate export name: \" + name.0.to_string())\n          }\n        }\n        names.push(name)\n      }\n      Ok(())\n    }\n  }\n}\n\n///|\n/// Validates a whole module from an empty context, building its Env incrementally.\npub fn validate_module(m : Module) -> Result[Unit, String] {\n  let Module(\n    _customs,\n    typesec_opt,\n    importsec_opt,\n    funcsec_opt,\n    tablesec_opt,\n    memsec_opt,\n    tagsec_opt,\n    globalsec_opt,\n    exportsec_opt,\n    startsec_opt,\n    elemsec_opt,\n    datacntsec_opt,\n    codesec_opt,\n    datasec_opt\n  ) = m\n\n  // Start from empty env (module validation does not take an external env)\n  let mut env = empty_env()\n\n  // (1) Types: defines global type index space\n  env = match validate_typesec(typesec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n\n  // (2) Imports: extend funcs/tables/mems/globals/tags index spaces\n  env = match validate_importsec(importsec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n\n  // (3) Function declarations (defined funcs): extend env.funcs\n  env = match validate_funcsec(funcsec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n\n  // (4) Tables / Memories / Tags / Globals: extend their index spaces\n  env = match validate_tablesec(tablesec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n  env = match validate_memsec(memsec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n  env = match validate_tagsec(tagsec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n  env = match validate_globalsec(globalsec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n\n  // (5) Elements / Data: extend elems/datas (needed by instructions)\n  env = match validate_elemsec(elemsec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n  env = match validate_datasec(datasec_opt, env) {\n    Ok(e) => e\n    Err(t) => return Err(t)\n  }\n\n  // (6) DataCount section cross-check\n  match validate_datacnt(datacntsec_opt, datasec_opt) {\n    Ok(_) => ()\n    Err(t) => return Err(t)\n  }\n\n  // (7) Start function validation\n  match validate_startsec(startsec_opt, env) {\n    Ok(_) => ()\n    Err(t) => return Err(t)\n  }\n\n  // (8) Exports: validate indices and check name uniqueness\n  match validate_exportsec_unique(exportsec_opt, env) {\n    Ok(_) => ()\n    Err(t) => return Err(t)\n  }\n\n  // (9) Code: typecheck each function body against env.funcs\n  match validate_codesec(codesec_opt, funcsec_opt, env) {\n    Ok(_) => ()\n    Err(t) => return Err(t)\n  }\n  Ok(())\n}\n\n///|\ntest \"Fuzz Modules\" {\n  let rnd = @quickcheck/splitmix.new()\n  loop 100000 {\n    0 => break ()\n    n => {\n      let ctx = gen_ctx_new(1000, rnd=Some(rnd))\n      let mod = gen_module_valid_full(ctx)\n      if mod is Err(t) {\n        assert_true(false, msg=t)\n      }\n      let (_, mod) = mod.unwrap()\n      let result = validate_module(mod)\n      if result is Err(t) {\n        assert_true(false, msg=t)\n      }\n      continue n - 1\n    }\n  }\n}\n\n// ============ NumType Tests ============\n\n///|\ntest \"NumType validates successfully\" {\n  let env = empty_env()\n  assert_eq(Validate::validate(@lib.F32NumType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.F64NumType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.I32NumType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.I64NumType, env), Ok(()))\n}\n\n// ============ AbsHeapType Tests ============\n\n///|\ntest \"AbsHeapType validates successfully\" {\n  let env = empty_env()\n  assert_eq(Validate::validate(@lib.ExnAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.ArrayAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.StructAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.I31AbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.EqAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.AnyAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.ExternAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.FuncAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.NoneAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.NoExternAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.NoFuncAbsHeapType, env), Ok(()))\n  assert_eq(Validate::validate(@lib.NoExnAbsHeapType, env), Ok(()))\n}\n\n// ============ HeapType Tests ============\n\n///|\ntest \"HeapType with AbsHeapType validates\" {\n  let env = empty_env()\n  let ht = @lib.AbsHeapTypeHeapType(FuncAbsHeapType)\n  assert_eq(Validate::validate(ht, env), Ok(()))\n}\n\n///|\ntest \"HeapType with invalid TypeIdx fails\" {\n  let env = empty_env()\n  let ht = @lib.HeapType(TypeIdx(0))\n  assert_eq(Validate::validate(ht, env), Err(\"No type exists for TypeIdx\"))\n}\n\n///|\ntest \"HeapType with valid TypeIdx succeeds\" {\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let env = empty_env().with_types([st])\n  let ht = @lib.HeapType(TypeIdx(0))\n  assert_eq(Validate::validate(ht, env), Ok(()))\n}\n\n// ============ ValType Tests ============\n\n///|\ntest \"ValType NumType validates\" {\n  let env = empty_env()\n  let vt = @lib.NumTypeValType(I32NumType)\n  assert_eq(Validate::validate(vt, env), Ok(()))\n}\n\n///|\ntest \"ValType VecType validates\" {\n  let env = empty_env()\n  let t = @lib.VecTypeValType\n  assert_eq(Validate::validate(t, env), Ok(()))\n}\n\n///|\ntest \"ValType BotType validates\" {\n  let env = empty_env()\n  let t = @lib.BotValType\n  assert_eq(Validate::validate(t, env), Ok(()))\n}\n\n///|\ntest \"ValType RefType with AbsHeapType validates\" {\n  let env = empty_env()\n  let rt = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let vt = @lib.RefTypeValType(rt)\n  assert_eq(Validate::validate(vt, env), Ok(()))\n}\n\n// ============ RefType Tests ============\n\n///|\ntest \"RefType HeapTypeRefType with valid AbsHeapType validates\" {\n  let env = empty_env()\n  let rt = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n  assert_eq(Validate::validate(rt, env), Ok(()))\n}\n\n///|\ntest \"RefType HeapTypeRefType nullable and non-nullable validate\" {\n  let env = empty_env()\n  let rt_null = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  let rt_non_null = @lib.HeapTypeRefType(\n    false,\n    AbsHeapTypeHeapType(FuncAbsHeapType),\n  )\n  assert_eq(Validate::validate(rt_null, env), Ok(()))\n  assert_eq(Validate::validate(rt_non_null, env), Ok(()))\n}\n\n// ============ TypeIdx Tests ============\n\n///|\ntest \"TypeIdx validates when type exists\" {\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let env = empty_env().with_types([st])\n  let tidx = @lib.TypeIdx(0)\n  assert_eq(Validate::validate(tidx, env), Ok(()))\n}\n\n///|\ntest \"TypeIdx fails when type does not exist\" {\n  let env = empty_env()\n  let tidx = @lib.TypeIdx(0)\n  assert_eq(Validate::validate(tidx, env), Err(\"No type exists for TypeIdx\"))\n}\n\n///|\ntest \"TypeIdx fails with out of bounds index\" {\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let env = empty_env().with_types([st])\n  let tidx = @lib.TypeIdx(5)\n  assert_eq(Validate::validate(tidx, env), Err(\"No type exists for TypeIdx\"))\n}\n\n// ============ LabelIdx Tests ============\n\n///|\ntest \"LabelIdx validates when label exists\" {\n  let env = empty_env().with_labels([[]])\n  let lidx = @lib.LabelIdx(0)\n  assert_eq(Validate::validate(lidx, env), Ok(()))\n}\n\n///|\ntest \"LabelIdx fails when label does not exist\" {\n  let env = empty_env()\n  let lidx = @lib.LabelIdx(0)\n  assert_eq(Validate::validate(lidx, env), Err(\"Invalid LabelIdx\"))\n}\n\n///|\ntest \"LabelIdx fails with out of bounds index\" {\n  let env = empty_env().with_labels([[]])\n  let lidx = @lib.LabelIdx(5)\n  assert_eq(Validate::validate(lidx, env), Err(\"Invalid LabelIdx\"))\n}\n\n// ============ TagIdx Tests ============\n\n///|\ntest \"TagIdx validates when tag exists\" {\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let env = empty_env().with_types([st]).with_tags([TagType(TypeIdx(0))])\n  let tidx = @lib.TagIdx(0)\n  assert_eq(Validate::validate(tidx, env), Ok(()))\n}\n\n///|\ntest \"TagIdx fails when tag does not exist\" {\n  let env = empty_env()\n  let tidx = @lib.TagIdx(0)\n  assert_eq(Validate::validate(tidx, env), Err(\"Invalid TagIdx\"))\n}\n\n// ============ FuncIdx Tests ============\n\n///|\ntest \"FuncIdx validates when func exists\" {\n  let env = empty_env().with_funcs([FuncType([], [])])\n  let fidx = @lib.FuncIdx(0)\n  assert_eq(Validate::validate(fidx, env), Ok(()))\n}\n\n///|\ntest \"FuncIdx fails when func does not exist\" {\n  let env = empty_env()\n  let fidx = @lib.FuncIdx(0)\n  assert_eq(Validate::validate(fidx, env), Err(\"invalid func index\"))\n}\n\n// ============ TableIdx Tests ============\n\n///|\ntest \"TableIdx validates when table exists\" {\n  let rt = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let tt = @lib.TableType(rt, I32Limits(0, None))\n  let env = empty_env().with_tables([tt])\n  let tidx = @lib.TableIdx(0)\n  assert_eq(Validate::validate(tidx, env), Ok(()))\n}\n\n///|\ntest \"TableIdx fails when table does not exist\" {\n  let env = empty_env()\n  let tidx = @lib.TableIdx(0)\n  assert_eq(Validate::validate(tidx, env), Err(\"invalid table index\"))\n}\n\n// ============ MemIdx Tests ============\n\n///|\ntest \"MemIdx validates when memory exists\" {\n  let mt = @lib.MemType(I32Limits(0, None))\n  let env = empty_env().with_mems([mt])\n  let midx = @lib.MemIdx(0)\n  assert_eq(Validate::validate(midx, env), Ok(()))\n}\n\n///|\ntest \"MemIdx fails when memory does not exist\" {\n  let env = empty_env()\n  let midx = @lib.MemIdx(0)\n  assert_eq(Validate::validate(midx, env), Err(\"invalid mem index\"))\n}\n\n// ============ GlobalIdx Tests ============\n\n///|\ntest \"GlobalIdx validates when global exists\" {\n  let gt = @lib.GlobalType(NumTypeValType(I32NumType), false)\n  let env = empty_env().with_globals([gt])\n  let gidx = @lib.GlobalIdx(0)\n  assert_eq(Validate::validate(gidx, env), Ok(()))\n}\n\n///|\ntest \"GlobalIdx fails when global does not exist\" {\n  let env = empty_env()\n  let gidx = @lib.GlobalIdx(0)\n  assert_eq(Validate::validate(gidx, env), Err(\"invalid global index\"))\n}\n\n// ============ Limits Tests (ValidateMax) ============\n\n///|\ntest \"I32Limits validates within max\" {\n  let env = empty_env()\n  let lim = @lib.I32Limits(10, Some(100))\n  assert_eq(ValidateMax::validate_max(lim, env, 1000), Ok(()))\n}\n\n///|\ntest \"I32Limits validates with no upper bound\" {\n  let env = empty_env()\n  let lim = @lib.I32Limits(10, None)\n  assert_eq(ValidateMax::validate_max(lim, env, 1000), Ok(()))\n}\n\n///|\ntest \"I32Limits fails when n exceeds k\" {\n  let env = empty_env()\n  let lim = @lib.I32Limits(2000, None)\n  assert_eq(\n    ValidateMax::validate_max(lim, env, 1000),\n    Err(\"Invalid range for limits\"),\n  )\n}\n\n///|\ntest \"I32Limits fails when m exceeds k\" {\n  let env = empty_env()\n  let lim = @lib.I32Limits(10, Some(2000))\n  assert_eq(\n    ValidateMax::validate_max(lim, env, 1000),\n    Err(\"Invalid range for limits\"),\n  )\n}\n\n///|\ntest \"I32Limits fails when n exceeds m\" {\n  let env = empty_env()\n  let lim = @lib.I32Limits(100, Some(10))\n  assert_eq(\n    ValidateMax::validate_max(lim, env, 1000),\n    Err(\"Invalid range for limits\"),\n  )\n}\n\n///|\ntest \"I64Limits validates within max\" {\n  let env = empty_env()\n  let lim = @lib.I64Limits(10, Some(100))\n  assert_eq(ValidateMax::validate_max(lim, env, 1000), Ok(()))\n}\n\n// ============ MemType Tests ============\n\n///|\ntest \"MemType validates with valid limits\" {\n  let env = empty_env()\n  let mt = @lib.MemType(I32Limits(0, Some(100)))\n  assert_eq(Validate::validate(mt, env), Ok(()))\n}\n\n///|\ntest \"MemType fails when limits exceed 65536\" {\n  let env = empty_env()\n  let mt = @lib.MemType(I32Limits(0, Some(100000)))\n  assert_eq(Validate::validate(mt, env), Err(\"Invalid range for limits\"))\n}\n\n// ============ TableType Tests ============\n\n///|\ntest \"TableType validates with valid ref type and limits\" {\n  let env = empty_env()\n  let rt = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let tt = @lib.TableType(rt, I32Limits(0, Some(100)))\n  assert_eq(Validate::validate(tt, env), Ok(()))\n}\n\n// ============ GlobalType Tests ============\n\n///|\ntest \"GlobalType validates with NumType\" {\n  let env = empty_env()\n  let gt = @lib.GlobalType(NumTypeValType(I32NumType), false)\n  assert_eq(Validate::validate(gt, env), Ok(()))\n}\n\n///|\ntest \"GlobalType validates mutable\" {\n  let env = empty_env()\n  let gt = @lib.GlobalType(NumTypeValType(I64NumType), true)\n  assert_eq(Validate::validate(gt, env), Ok(()))\n}\n\n// ============ StorageType Tests ============\n\n///|\ntest \"StorageType ValType validates\" {\n  let env = empty_env()\n  let st = @lib.ValTypeStorageType(NumTypeValType(I32NumType))\n  assert_eq(Validate::validate(st, env), Ok(()))\n}\n\n///|\ntest \"StorageType PackType validates\" {\n  let env = empty_env()\n  let st = @lib.PackTypeStorageType(I8PackType)\n  assert_eq(Validate::validate(st, env), Ok(()))\n}\n\n// ============ FieldType Tests ============\n\n///|\ntest \"FieldType validates\" {\n  let env = empty_env()\n  let ft = @lib.FieldType(ValTypeStorageType(NumTypeValType(I32NumType)), Const)\n  assert_eq(Validate::validate(ft, env), Ok(()))\n}\n\n// ============ FuncType Tests ============\n\n///|\ntest \"FuncType with empty params and results validates\" {\n  let env = empty_env()\n  let ft = @lib.FuncType([], [])\n  assert_eq(Validate::validate(ft, env), Ok(()))\n}\n\n///|\ntest \"FuncType with params and results validates\" {\n  let env = empty_env()\n  let ft = @lib.FuncType([NumTypeValType(I32NumType)], [\n    NumTypeValType(I64NumType),\n  ])\n  assert_eq(Validate::validate(ft, env), Ok(()))\n}\n\n// ============ CompType Tests ============\n\n///|\ntest \"CompType FuncCompType validates\" {\n  let env = empty_env()\n  let ct = @lib.FuncCompType([], [])\n  assert_eq(Validate::validate(ct, env), Ok(()))\n}\n\n///|\ntest \"CompType ArrayCompType validates\" {\n  let env = empty_env()\n  let ft = @lib.FieldType(ValTypeStorageType(NumTypeValType(I32NumType)), Const)\n  let ct = @lib.ArrayCompType(ft)\n  assert_eq(Validate::validate(ct, env), Ok(()))\n}\n\n///|\ntest \"CompType StructCompType validates\" {\n  let env = empty_env()\n  let ft = @lib.FieldType(ValTypeStorageType(NumTypeValType(I32NumType)), Const)\n  let ct = @lib.StructCompType([ft])\n  assert_eq(Validate::validate(ct, env), Ok(()))\n}\n\n///|\ntest \"CompType StructCompType empty validates\" {\n  let env = empty_env()\n  let ct = @lib.StructCompType([])\n  assert_eq(Validate::validate(ct, env), Ok(()))\n}\n\n// ============ SubType Tests ============\n\n///|\ntest \"SubType CompTypeSubType validates\" {\n  let env = empty_env()\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  assert_eq(Validate::validate(st, env), Ok(()))\n}\n\n// ============ RecType Tests ============\n\n///|\ntest \"RecType SingleRecType validates\" {\n  let env = empty_env()\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let rt = @lib.SingleRecType(st)\n  assert_eq(Validate::validate(rt, env), Ok(()))\n}\n\n///|\ntest \"RecType GroupRecType validates\" {\n  let env = empty_env()\n  let st1 = @lib.CompTypeSubType(FuncCompType([], []))\n  let st2 = @lib.CompTypeSubType(\n    ArrayCompType(\n      FieldType(ValTypeStorageType(NumTypeValType(I32NumType)), Const),\n    ),\n  )\n  let rt = @lib.GroupRecType([st1, st2])\n  assert_eq(Validate::validate(rt, env), Ok(()))\n}\n\n// ============ Array[T] Validate Tests ============\n\n///|\ntest \"Array of ValType validates\" {\n  let env = empty_env()\n  let arr : Array[ValType] = [\n    NumTypeValType(I32NumType),\n    NumTypeValType(I64NumType),\n  ]\n  assert_eq(Validate::validate(arr, env), Ok(()))\n}\n\n///|\ntest \"Empty array validates\" {\n  let env = empty_env()\n  let arr : Array[ValType] = []\n  assert_eq(Validate::validate(arr, env), Ok(()))\n}\n\n// ============ BlockType Tests ============\n\n///|\ntest \"BlockType EmptyBlockType validates\" {\n  let env = empty_env()\n  assert_eq(Validate::validate(@lib.EmptyBlockType, env), Ok(()))\n}\n\n///|\ntest \"BlockType ValTypeBlockType validates\" {\n  let env = empty_env()\n  let bt = @lib.ValTypeBlockType(NumTypeValType(I32NumType))\n  assert_eq(Validate::validate(bt, env), Ok(()))\n}\n\n///|\ntest \"BlockType TypeIdxBlockType with valid func type validates\" {\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let env = empty_env().with_types([st])\n  let bt = @lib.TypeIdxBlockType(TypeIdx(0))\n  assert_eq(Validate::validate(bt, env), Ok(()))\n}\n\n///|\ntest \"BlockType TypeIdxBlockType with invalid index fails\" {\n  let env = empty_env()\n  let bt = @lib.TypeIdxBlockType(TypeIdx(0))\n  assert_eq(Validate::validate(bt, env), Err(\"Invalid TypeIdx for block type\"))\n}\n\n///|\ntest \"BlockType TypeIdxBlockType with non-func type fails\" {\n  let st = @lib.CompTypeSubType(\n    ArrayCompType(\n      FieldType(ValTypeStorageType(NumTypeValType(I32NumType)), Const),\n    ),\n  )\n  let env = empty_env().with_types([st])\n  let bt = @lib.TypeIdxBlockType(TypeIdx(0))\n  assert_eq(\n    Validate::validate(bt, env),\n    Err(\"Expected Func Type for block type\"),\n  )\n}\n\n// ============ ExternType Tests ============\n\n///|\ntest \"ExternType GlobalExternType validates\" {\n  let env = empty_env()\n  let gt = @lib.GlobalType(NumTypeValType(I32NumType), false)\n  let et = @lib.GlobalExternType(gt)\n  assert_eq(Validate::validate(et, env), Ok(()))\n}\n\n///|\ntest \"ExternType MemExternType validates\" {\n  let env = empty_env()\n  let mt = @lib.MemType(I32Limits(0, Some(10)))\n  let et = @lib.MemExternType(mt)\n  assert_eq(Validate::validate(et, env), Ok(()))\n}\n\n///|\ntest \"ExternType TableExternType validates\" {\n  let env = empty_env()\n  let rt = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let tt = @lib.TableType(rt, I32Limits(0, Some(100)))\n  let et = @lib.TableExternType(tt)\n  assert_eq(Validate::validate(et, env), Ok(()))\n}\n\n///|\ntest \"ExternType FuncExternType validates when func type exists\" {\n  let st = @lib.CompTypeSubType(FuncCompType([], []))\n  let env = empty_env().with_types([st])\n  let et = @lib.FuncExternType(TypeIdx(0))\n  assert_eq(Validate::validate(et, env), Ok(()))\n}\n\n///|\ntest \"ExternType FuncExternType fails when func type missing\" {\n  let env = empty_env()\n  let et = @lib.FuncExternType(TypeIdx(0))\n  assert_eq(\n    Validate::validate(et, env),\n    Err(\"Invalid ExternType: Func extern type not found\"),\n  )\n}\n\n// ============ ExternIdx Tests ============\n\n///|\ntest \"ExternIdx FuncExternIdx validates\" {\n  let env = empty_env().with_funcs([FuncType([], [])])\n  let ei = @lib.FuncExternIdx(FuncIdx(0))\n  assert_eq(Validate::validate(ei, env), Ok(()))\n}\n\n///|\ntest \"ExternIdx TableExternIdx validates\" {\n  let rt = @lib.AbsHeapTypeRefType(FuncAbsHeapType)\n  let tt = @lib.TableType(rt, I32Limits(0, None))\n  let env = empty_env().with_tables([tt])\n  let ei = @lib.TableExternIdx(TableIdx(0))\n  assert_eq(Validate::validate(ei, env), Ok(()))\n}\n\n///|\ntest \"ExternIdx MemExternIdx validates\" {\n  let mt = @lib.MemType(I32Limits(0, None))\n  let env = empty_env().with_mems([mt])\n  let ei = @lib.MemExternIdx(MemIdx(0))\n  assert_eq(Validate::validate(ei, env), Ok(()))\n}\n\n///|\ntest \"ExternIdx GlobalExternIdx validates\" {\n  let gt = @lib.GlobalType(NumTypeValType(I32NumType), false)\n  let env = empty_env().with_globals([gt])\n  let ei = @lib.GlobalExternIdx(GlobalIdx(0))\n  assert_eq(Validate::validate(ei, env), Ok(()))\n}\n\n// ============ Export Tests ============\n\n///|\ntest \"Export with valid FuncExternIdx validates\" {\n  let env = empty_env().with_funcs([FuncType([], [])])\n  let exp = @lib.Export(Name(\"test\"), FuncExternIdx(FuncIdx(0)))\n  assert_eq(Validate::validate(exp, env), Ok(()))\n}\n\n///|\ntest \"Export with invalid index fails\" {\n  let env = empty_env()\n  let exp = @lib.Export(Name(\"test\"), FuncExternIdx(FuncIdx(0)))\n  assert_eq(Validate::validate(exp, env), Err(\"invalid func index\"))\n}\n\n// ============ Import Tests ============\n\n///|\ntest \"Import with valid GlobalExternType validates\" {\n  let env = empty_env()\n  let gt = @lib.GlobalType(NumTypeValType(I32NumType), false)\n  let imp = @lib.Import(Name(\"mod\"), Name(\"name\"), GlobalExternType(gt))\n  assert_eq(Validate::validate(imp, env), Ok(()))\n}\n\n// ============ DataMode Tests ============\n\n///|\ntest \"DataMode Passive validates\" {\n  let env = empty_env()\n  assert_eq(Validate::validate(DataMode::Passive, env), Ok(()))\n}\n\n// ============ Data Tests ============\n\n///|\ntest \"Data with Passive mode validates\" {\n  let env = empty_env()\n  let d = @lib.Data(Passive, b\"hello\")\n  assert_eq(Validate::validate(d, env), Ok(()))\n}\n\n// ============ Catch Tests ============\n\n///|\ntest \"Catch CatchAll validates with valid label\" {\n  let env = empty_env().with_labels([[]])\n  let c = @lib.CatchAll(LabelIdx(0))\n  assert_eq(Validate::validate(c, env), Ok(()))\n}\n\n///|\ntest \"Catch CatchAllRef validates with valid label\" {\n  let env = empty_env().with_labels([[]])\n  let c = @lib.CatchAllRef(LabelIdx(0))\n  assert_eq(Validate::validate(c, env), Ok(()))\n}\n\n///|\ntest \"Catch CatchAll fails with invalid label\" {\n  let env = empty_env()\n  let c = @lib.CatchAll(LabelIdx(0))\n  assert_eq(Validate::validate(c, env), Err(\"Invalid LabelIdx\"))\n}\n","///|\nusing @lib {\n  type FuncType,\n  type Locals,\n  type Data,\n  type DataMode,\n  type Elem,\n  type ElemMode,\n  type ImportSec,\n  type Import,\n  type Mut,\n  type Module,\n  vt_i32,\n  expand_locals,\n  expr_to_texpr,\n}\n\n///|\npub trait GenValid {\n  gen_valid(Self, GenCtx) -> Result[Self, String]\n}\n\n///|\npub struct GenCtx {\n  rnd : @quickcheck/splitmix.RandomState\n  fuel : Int\n  env : Env\n}\n\n///|\nfn out_of_fuel(ctx : GenCtx) -> Bool {\n  ctx.fuel <= 0\n}\n\n///|\npub fn gen_ctx_new(\n  fuel : Int,\n  rnd? : @quickcheck/splitmix.RandomState? = None,\n) -> GenCtx {\n  let rnd = rnd.unwrap_or(@quickcheck/splitmix.new())\n  GenCtx::{ rnd, fuel, env: empty_env() }\n}\n\n///|\npub fn GenCtx::with_env(ctx : GenCtx, env : Env) -> GenCtx {\n  GenCtx::{ ..ctx, env, }\n}\n\n///|\npub fn GenCtx::with_fuel_only(ctx : GenCtx, fuel : Int) -> GenCtx {\n  GenCtx::{ ..ctx, fuel, }\n}\n\n///|\npub fn GenCtx::dec_fuel(ctx : GenCtx, n : Int) -> GenCtx {\n  GenCtx::{ ..ctx, fuel: ctx.fuel - n }\n}\n\n///|\nfn gen_value_of_type(\n  ctx : GenCtx,\n  st : TcState,\n  vt : ValType,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  if out_of_fuel(ctx) {\n    return Err(\"gen_value_of_type: out of fuel\")\n  }\n  match vt {\n    NumTypeValType(nt) =>\n      match nt {\n        I32NumType => {\n          let ins = @lib.I32Const(I32(ctx.rnd.next_int()))\n          match Typecheck::typecheck(ins, st) {\n            Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n            Err(e) => Err(e)\n          }\n        }\n        I64NumType => {\n          let ins = @lib.I64Const(I64(ctx.rnd.next_int64()))\n          match Typecheck::typecheck(ins, st) {\n            Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n            Err(e) => Err(e)\n          }\n        }\n        F32NumType => {\n          let ins = @lib.F32Const(F32(ctx.rnd.next_float()))\n          match Typecheck::typecheck(ins, st) {\n            Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n            Err(e) => Err(e)\n          }\n        }\n        F64NumType => {\n          let ins = @lib.F64Const(F64(ctx.rnd.next_double()))\n          match Typecheck::typecheck(ins, st) {\n            Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n            Err(e) => Err(e)\n          }\n        }\n      }\n    VecTypeValType => {\n      // emit a random V128Const\n      let ins = @lib.V128Const(\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n      )\n      match Typecheck::typecheck(ins, st) {\n        Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n        Err(e) => Err(e)\n      }\n    }\n    RefTypeValType(rt) =>\n      // If nullable: ref.null is easiest\n      if rt.is_nullable() {\n        let ht = rt.get_heap_type()\n        let ins = @lib.RefNull(ht)\n        match Typecheck::typecheck(ins, st) {\n          Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n          Err(e) => Err(e)\n        }\n      } else {\n        // non-null cases we can construct\n        let ht = rt.get_heap_type()\n        match ht {\n          HeapType(x) => gen_nonnull_ref_of_typeidx(ctx, st, x)\n          AbsHeapTypeHeapType(I31AbsHeapType) => {\n            // i32.const; ref.i31\n            let (ctx1, st1, is1) = match gen_value_of_type(ctx, st, vt_i32()) {\n              Ok(x) => x\n              Err(e) => return Err(e)\n            }\n            let ins2 = @lib.RefI31\n            match Typecheck::typecheck(ins2, st1) {\n              Ok(st2) => {\n                let out = is1.copy()\n                out.push(ins2)\n                Ok((ctx1.dec_fuel(1), st2, out))\n              }\n              Err(e) => Err(e)\n            }\n          }\n          AbsHeapTypeHeapType(FuncAbsHeapType) => {\n            // ref.func if possible\n            if ctx.env.funcs.length() == 0 {\n              return Err(\"cannot construct non-null funcref: no funcs in env\")\n            }\n            let idx = @lib.FuncIdx(\n              ctx.rnd.next_uint() % ctx.env.funcs.length().reinterpret_as_uint(),\n            )\n            let ins = @lib.RefFunc(idx)\n            match Typecheck::typecheck(ins, st) {\n              Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n              Err(e) => Err(e)\n            }\n          }\n\n          // If you want: for defined struct/array types you can use\n          // struct.new_default/array.new_default when defaults exist, but that\n          // requires choosing a valid TypeIdx and checking defaults. Add later.\n          _ => Err(\"cannot construct non-null ref for this heap type yet\")\n        }\n      }\n    BotValType =>\n      // shouldn't be requested as a target\n      Err(\"gen_value_of_type: requested BotValType\")\n  }\n}\n\n///|\nfn emit_finish_return(\n  ctx : GenCtx,\n  st : TcState,\n  want : Array[ValType],\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  let mut ctx = ctx\n  let mut st = st\n  let out : Array[Instruction] = []\n\n  // push each wanted value (in order)\n  for vt in want {\n    let (ctx2, st2, insns) = match gen_value_of_type(ctx, st, vt) {\n      Ok(x) => x\n      Err(e) => return Err(e)\n    }\n    ctx = ctx2\n    st = st2\n    for i in insns {\n      out.push(i)\n    }\n  }\n\n  // now return (consumes want values)\n  let ret = @lib.Return\n  match Typecheck::typecheck(ret, st) {\n    Ok(st2) => {\n      out.push(ret)\n      Ok((ctx.dec_fuel(1), st2, out))\n    }\n    Err(e) => Err(e)\n  }\n}\n\n///|\npub fn gen_expr_valid(\n  ctx : GenCtx,\n  st0 : TcState,\n  want : Array[ValType],\n) -> Result[Expr, String] {\n  let mut ctx = ctx\n  let mut st = st0\n  let insns : Array[Instruction] = []\n\n  // keep some fuel for finishing\n  while ctx.fuel > 10 {\n    // Occasionally decide to finish early\n    if ctx.rnd.next_uint() % 10 == 0 {\n      break\n    }\n    let mut accepted = false\n\n    // try multiple candidates; accept the first that typechecks\n    for _ in 0..<30 {\n      let cand = gen_candidate_instruction(ctx, st)\n      match Typecheck::typecheck(cand, st) {\n        Ok(st2) => {\n          insns.push(cand)\n          st = st2\n          ctx = ctx.dec_fuel(1)\n          accepted = true\n          break\n        }\n        Err(_) => ()\n      }\n    }\n    if !accepted {\n      // If we can't find anything, stop and finish\n      break\n    }\n\n    // If we became unreachable, we can stop and finish by just ending the Expr\n    // BUT: your function validator expects a Return at end in many cases.\n    // We'll still finish with return to be safe.\n    if !st.reachable {\n      break\n    }\n  }\n\n  // Finish with required results + return\n  let (ctx2, _st2, fin) = match emit_finish_return(ctx, st, want) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  ctx = ctx2\n  for i in fin {\n    insns.push(i)\n  }\n  Ok(Expr(insns))\n}\n\n///|\nfn gen_nonnull_ref_of_typeidx(\n  ctx : GenCtx,\n  st : TcState,\n  x : TypeIdx,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  // Determine if x is struct or array and defaultable\n  let ct = match st.env.resolve_comptype(x) {\n    None => return Err(\"cannot resolve comptype for typeidx\")\n    Some(c) => c\n  }\n  match ct {\n    StructCompType(_) => {\n      let ins = @lib.StructNewDefault(x)\n      match Typecheck::typecheck(ins, st) {\n        Ok(st2) => Ok((ctx.dec_fuel(1), st2, [ins]))\n        Err(e) => Err(e)\n      }\n    }\n    ArrayCompType(_) => {\n      // Need i32 length first, then array.new_default\n      let (ctx1, st1, is1) = match gen_value_of_type(ctx, st, vt_i32()) {\n        Ok(x) => x\n        Err(e) => return Err(e)\n      }\n      let ins2 = @lib.ArrayNewDefault(x)\n      match Typecheck::typecheck(ins2, st1) {\n        Ok(st2) => {\n          let out = is1.copy()\n          out.push(ins2)\n          Ok((ctx1.dec_fuel(1), st2, out))\n        }\n        Err(e) => Err(e)\n      }\n    }\n    _ => Err(\"typeidx is not struct or array\")\n  }\n}\n\n///|\nfn gen_defaultable_valtype(rnd : @quickcheck/splitmix.RandomState) -> ValType {\n  match rnd.next_uint() % 6 {\n    0 => NumTypeValType(I32NumType)\n    1 => NumTypeValType(I64NumType)\n    2 => NumTypeValType(F32NumType)\n    3 => NumTypeValType(F64NumType)\n    4 => VecTypeValType\n    _ => {\n      // nullable refs only (default is ref.null)\n      let abs = match rnd.next_uint() % 6 {\n        0 => @lib.AnyAbsHeapType\n        1 => EqAbsHeapType\n        2 => StructAbsHeapType\n        3 => ArrayAbsHeapType\n        4 => FuncAbsHeapType\n        _ => ExternAbsHeapType\n      }\n      RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(abs)))\n    }\n  }\n}\n\n///|\nfn gen_defaultable_field(rnd : @quickcheck/splitmix.RandomState) -> FieldType {\n  let vt = gen_defaultable_valtype(rnd)\n  let st = @lib.ValTypeStorageType(vt)\n  let m = if (rnd.next_uint() & 1) == 1 { @lib.Var } else { Const }\n  FieldType(st, m)\n}\n\n///|\nfn gen_defaultable_array_field(\n  rnd : @quickcheck/splitmix.RandomState,\n) -> FieldType {\n  // element mutability matters for set/copy later, but not for new_default\n  gen_defaultable_field(rnd)\n}\n\n///|\nfn gen_defaultable_struct_rectype(\n  rnd : @quickcheck/splitmix.RandomState,\n) -> RecType {\n  let fields : Array[FieldType] = []\n  let n = (rnd.next_uint() % 4).reinterpret_as_int() + 1 // 1..4 fields\n  for _ in 0..<n {\n    fields.push(gen_defaultable_field(rnd))\n  }\n  let ct = @lib.StructCompType(fields)\n  // keep simple: no supertypes, non-final or final randomly\n  let is_final = (rnd.next_uint() & 1) == 1\n  SingleRecType(SubType(is_final, [], ct))\n}\n\n///|\nfn gen_defaultable_array_rectype(\n  rnd : @quickcheck/splitmix.RandomState,\n) -> RecType {\n  let ft = gen_defaultable_array_field(rnd)\n  let ct = @lib.ArrayCompType(ft)\n  let is_final = (rnd.next_uint() & 1) == 1\n  SingleRecType(SubType(is_final, [], ct))\n}\n\n///|\nfn gen_small_valtype(rnd : @quickcheck/splitmix.RandomState) -> ValType {\n  // allow refs too, but keep mostly defaultable for now\n  gen_defaultable_valtype(rnd)\n}\n\n///|\nfn gen_func_rectype(rnd : @quickcheck/splitmix.RandomState) -> RecType {\n  let ps : Array[ValType] = []\n  let rs : Array[ValType] = []\n  let pn = (rnd.next_uint() % 3).reinterpret_as_int() // 0..2 params\n  let rn = (rnd.next_uint() % 3).reinterpret_as_int() // 0..2 results\n  for _ in 0..<pn {\n    ps.push(gen_small_valtype(rnd))\n  }\n  for _ in 0..<rn {\n    rs.push(gen_small_valtype(rnd))\n  }\n  let ct = @lib.FuncCompType(ps, rs)\n  let is_final = true // functions are typically final-ish; keep true to simplify\n  SingleRecType(SubType(is_final, [], ct))\n}\n\n///|\npub fn gen_typesec_valid(ctx : GenCtx) -> Result[(GenCtx, TypeSec), String] {\n  let rnd = ctx.rnd\n\n  // Decide how many guaranteed GC types\n  let pattern = rnd.next_uint() % 2\n  let rectypes : Array[RecType] = []\n  if pattern == 0 {\n    // 2 structs + 1 array\n    rectypes.push(gen_defaultable_struct_rectype(rnd))\n    rectypes.push(gen_defaultable_struct_rectype(rnd))\n    rectypes.push(gen_defaultable_array_rectype(rnd))\n  } else {\n    // 1 struct + 2 arrays\n    rectypes.push(gen_defaultable_struct_rectype(rnd))\n    rectypes.push(gen_defaultable_array_rectype(rnd))\n    rectypes.push(gen_defaultable_array_rectype(rnd))\n  }\n\n  // Add some function types too (so we can generate calls/ref.func etc)\n  let extra_funcs = (rnd.next_uint() % 4).reinterpret_as_int() + 1 // 1..4\n  for _ in 0..<extra_funcs {\n    rectypes.push(gen_func_rectype(rnd))\n  }\n\n  // Add some more random struct/array types (still defaultable for now)\n  let extra_gc = (rnd.next_uint() % 4).reinterpret_as_int() // 0..3\n  for _ in 0..<extra_gc {\n    if (rnd.next_uint() & 1) == 1 {\n      rectypes.push(gen_defaultable_struct_rectype(rnd))\n    } else {\n      rectypes.push(gen_defaultable_array_rectype(rnd))\n    }\n  }\n\n  // Return updated ctx (consume some fuel proportional to types)\n  let ctx2 = ctx.dec_fuel(rectypes.length())\n  Ok((ctx2, TypeSec(rectypes)))\n}\n\n///|\nfn collect_functype_typeidxs(env : Env) -> Array[TypeIdx] {\n  let out : Array[TypeIdx] = []\n  for i in 0..<env.global_types.length() {\n    let tidx = @lib.TypeIdx(i.reinterpret_as_uint())\n    if env.resolve_functype(tidx) is Some(_) {\n      out.push(tidx)\n    }\n  }\n  out\n}\n\n///|\nfn env_for_func_body(\n  env : Env,\n  ft : FuncType,\n  decls : Array[Locals],\n) -> Result[Env, String] {\n  let FuncType(params, results) = ft\n  let locals_expanded = match expand_locals(decls) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let locals_all = params.copy()\n  for vt in locals_expanded {\n    locals_all.push(vt)\n  }\n  let labels2 = env.labels.copy()\n  labels2.push(results)\n  Ok(Env::{\n    global_types: env.global_types,\n    rec_stack: env.rec_stack,\n    funcs: env.funcs,\n    tables: env.tables,\n    mems: env.mems,\n    globals: env.globals,\n    elems: env.elems,\n    datas: env.datas,\n    tags: env.tags,\n    locals: locals_all,\n    labels: labels2,\n    return_type: Some(results),\n  })\n}\n\n///|\nfn gen_locals_decls(\n  rnd : @quickcheck/splitmix.RandomState,\n  max_groups : Int,\n) -> Array[Locals] {\n  let decls : Array[Locals] = []\n  let groups = (rnd.next_uint() % max_groups.reinterpret_as_uint() + 1).reinterpret_as_int() // 1..max_groups\n  for _ in 0..<groups {\n    let vt = gen_defaultable_valtype(rnd)\n    let count = rnd.next_uint() % 3 + 1 // 1..3 locals of this type\n    decls.push(Locals(count, vt))\n  }\n  decls\n}\n\n///|\nfn gen_limits_i32(\n  rnd : @quickcheck/splitmix.RandomState,\n  max_val : UInt,\n) -> Limits {\n  let min = rnd.next_uint() % (max_val + 1)\n  let has_max = (rnd.next_uint() & 1) == 1\n  if has_max {\n    let max = min + rnd.next_uint() % (max_val - min + 1)\n    I32Limits(min, Some(max))\n  } else {\n    I32Limits(min, None)\n  }\n}\n\n///|\nfn gen_tabletype(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> TableType {\n  // Choose element type - prefer funcref for compatibility with elem segments\n  let rt = match rnd.next_uint() % 5 {\n    0 => @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n    1 => HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType))\n    2 => HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType))\n    3 => HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType))\n    _ => HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  }\n  let lim = gen_limits_i32(rnd, 100)\n  ignore(env) // env available for future type-index references\n  TableType(rt, lim)\n}\n\n///|\nfn gen_memtype(rnd : @quickcheck/splitmix.RandomState) -> MemType {\n  let min = rnd.next_uint() % 4 // small memory (0-3 pages)\n  let has_max = (rnd.next_uint() & 1) == 1\n  let lim = if has_max {\n    let max = min + rnd.next_uint() % 4\n    @lib.I32Limits(min, Some(max))\n  } else {\n    I32Limits(min, None)\n  }\n  MemType(lim)\n}\n\n///|\npub fn gen_tablesec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, TableSec, Env), String] {\n  let rnd = ctx.rnd\n  let count = (rnd.next_uint() % 3).reinterpret_as_int() + 1 // 1..3 tables\n  let tables : Array[Table] = []\n  let mut env = env\n  for _ in 0..<count {\n    let tt = gen_tabletype(rnd, env)\n    // No init expr for simplicity\n    tables.push(Table(tt, None))\n    env = env.push_table(tt)\n  }\n  let ctx2 = ctx.dec_fuel(count)\n  Ok((ctx2, TableSec(tables), env))\n}\n\n///|\npub fn gen_memsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, MemSec, Env), String] {\n  let rnd = ctx.rnd\n  // MVP allows only 1 memory; keep simple\n  let count = 1\n  let mems : Array[MemType] = []\n  let mut env = env\n  for _ in 0..<count {\n    let mt = gen_memtype(rnd)\n    mems.push(mt)\n    env = env.push_mem(mt)\n  }\n  let ctx2 = ctx.dec_fuel(count)\n  Ok((ctx2, MemSec(mems), env))\n}\n\n///|\npub fn gen_datasec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, DataSec, Env), String] {\n  let rnd = ctx.rnd\n  let count = (rnd.next_uint() % 3).reinterpret_as_int() // 0..2 data segments\n  let datas : Array[Data] = []\n  let mut env = env\n  for _ in 0..<count {\n    let has_mem = env.mems.length() > 0\n    let is_active = has_mem && (rnd.next_uint() & 1) == 1\n    let mode = if is_active {\n      let mem_idx = rnd.next_uint() % env.mems.length().reinterpret_as_uint()\n      // Get address type from memory limits\n      let MemType(lim) = match env.get_memtype(MemIdx(mem_idx)) {\n        Some(mt) => mt\n        None => return Err(\"gen_datasec_valid: invalid mem index\")\n      }\n      // Generate const offset expression with correct address type\n      let offset_expr = match lim {\n        I32Limits(_, _) => {\n          let offset_val = (rnd.next_uint() % 256).reinterpret_as_int()\n          @lib.Expr([I32Const(I32(offset_val))])\n        }\n        I64Limits(_, _) => {\n          let offset_val = (rnd.next_uint64() % 256UL).reinterpret_as_int64()\n          Expr([I64Const(I64(offset_val))])\n        }\n      }\n      DataMode::Active(MemIdx(mem_idx), offset_expr)\n    } else {\n      Passive\n    }\n\n    // Generate some random bytes\n    let byte_count = (rnd.next_uint() % 32).reinterpret_as_int()\n    let bytes = []\n    for i in 0..<byte_count {\n      bytes.push((rnd.next_uint() % 256).to_byte())\n    }\n    let d = @lib.Data(mode, Bytes::from_array(bytes))\n    datas.push(d)\n    env = env.push_data(d)\n  }\n  let ctx2 = ctx.dec_fuel(count)\n  Ok((ctx2, DataSec(datas), env))\n}\n\n///|\nfn gen_elem_kind_funcs(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> ElemKind {\n  let elem_count = (rnd.next_uint() % 5).reinterpret_as_int()\n  let func_indices : Array[FuncIdx] = []\n  if env.funcs.length() > 0 {\n    for _ in 0..<elem_count {\n      let fidx = rnd.next_uint() % env.funcs.length().reinterpret_as_uint()\n      func_indices.push(FuncIdx(fidx))\n    }\n  }\n  FuncsElemKind(func_indices)\n}\n\n///|\nfn gen_elem_kind_func_exprs(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> ElemKind {\n  let elem_count = (rnd.next_uint() % 5).reinterpret_as_int()\n  let exprs : Array[Expr] = []\n  for _ in 0..<elem_count {\n    if env.funcs.length() > 0 && (rnd.next_uint() & 1) == 1 {\n      let fidx = rnd.next_uint() % env.funcs.length().reinterpret_as_uint()\n      exprs.push(Expr([RefFunc(FuncIdx(fidx))]))\n    } else {\n      // ref.null func\n      exprs.push(Expr([RefNull(AbsHeapTypeHeapType(FuncAbsHeapType))]))\n    }\n  }\n  FuncExprsElemKind(exprs)\n}\n\n///|\nfn gen_elem_kind_typed_exprs(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n  rt : RefType,\n) -> ElemKind {\n  let elem_count = (rnd.next_uint() % 5).reinterpret_as_int()\n  let exprs : Array[Expr] = []\n  let ht = rt.get_heap_type()\n  for _ in 0..<elem_count {\n    // For nullable refs, we can always use ref.null\n    if rt.is_nullable() {\n      exprs.push(Expr([RefNull(ht)]))\n    } else {\n      // Non-null: need ref.func for func types\n      match ht {\n        AbsHeapTypeHeapType(FuncAbsHeapType) =>\n          if env.funcs.length() > 0 {\n            let fidx = rnd.next_uint() %\n              env.funcs.length().reinterpret_as_uint()\n            exprs.push(Expr([RefFunc(FuncIdx(fidx))]))\n          }\n        _ =>\n          // For other non-null types, skip (harder to generate)\n          ()\n      }\n    }\n  }\n  TypedExprsElemKind(rt, exprs)\n}\n\n///|\nfn find_compatible_table_for_funcref(env : Env) -> TableIdx? {\n  for i in 0..<env.tables.length() {\n    let tt = env.tables[i]\n    let TableType(rt, _) = tt\n    // funcref is compatible with funcref tables\n    let funcref = @lib.HeapTypeRefType(\n      true,\n      AbsHeapTypeHeapType(FuncAbsHeapType),\n    )\n    if Match::matches(funcref, rt, env) {\n      return Some(TableIdx(i.reinterpret_as_uint()))\n    }\n  }\n  None\n}\n\n///|\npub fn gen_elemsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, ElemSec, Env), String] {\n  let rnd = ctx.rnd\n  let count = (rnd.next_uint() % 3).reinterpret_as_int() // 0..2 elem segments\n  let elems : Array[Elem] = []\n  let mut env = env\n  for _ in 0..<count {\n    // Choose mode\n    let mode_choice = rnd.next_uint() % 4\n    let (mode, use_funcref) = if mode_choice == 0 {\n      (ElemMode::Passive, true)\n    } else if mode_choice == 1 {\n      (Declarative, true)\n    } else {\n      // Try Active mode\n      match find_compatible_table_for_funcref(env) {\n        Some(tab_idx) => {\n          let TableType(_, lim) = env.tables[tab_idx.0.reinterpret_as_int()]\n          let offset_val = (rnd.next_uint() % 10).reinterpret_as_int()\n          let offset_expr = match lim {\n            I32Limits(_, _) => @lib.Expr([I32Const(I32(offset_val))])\n            I64Limits(_, _) => Expr([I64Const(I64(offset_val.to_int64()))])\n          }\n          (Active(tab_idx, offset_expr), true)\n        }\n        None => (Passive, true)\n      }\n    }\n\n    // Generate element kind (funcref-based for compatibility)\n    let kind = if use_funcref {\n      match rnd.next_uint() % 3 {\n        0 => gen_elem_kind_funcs(rnd, env)\n        1 => gen_elem_kind_func_exprs(rnd, env)\n        _ => {\n          let rt = @lib.HeapTypeRefType(\n            true,\n            AbsHeapTypeHeapType(FuncAbsHeapType),\n          )\n          gen_elem_kind_typed_exprs(rnd, env, rt)\n        }\n      }\n    } else {\n      gen_elem_kind_funcs(rnd, env)\n    }\n    let elem = @lib.Elem(mode, kind)\n    elems.push(elem)\n    // Update env with new elem\n    let elems_arr = env.elems.copy()\n    elems_arr.push(elem)\n    env = Env::{\n      global_types: env.global_types,\n      rec_stack: env.rec_stack,\n      funcs: env.funcs,\n      tables: env.tables,\n      mems: env.mems,\n      globals: env.globals,\n      elems: elems_arr,\n      datas: env.datas,\n      tags: env.tags,\n      locals: env.locals,\n      labels: env.labels,\n      return_type: env.return_type,\n    }\n  }\n  let ctx2 = ctx.dec_fuel(count)\n  Ok((ctx2, ElemSec(elems), env))\n}\n\n///|\nfn gen_globaltype(rnd : @quickcheck/splitmix.RandomState) -> GlobalType {\n  let vt = gen_defaultable_valtype(rnd)\n  let m = (rnd.next_uint() & 1) == 1\n  GlobalType(vt, m)\n}\n\n///|\nfn collect_tag_functype_typeidxs(env : Env) -> Array[TypeIdx] {\n  let out : Array[TypeIdx] = []\n  for i in 0..<env.global_types.length() {\n    let tidx = @lib.TypeIdx(i.reinterpret_as_uint())\n    match env.resolve_functype(tidx) {\n      Some(FuncType(_, results)) if results.length() == 0 => out.push(tidx)\n      _ => ()\n    }\n  }\n  out\n}\n\n///|\nfn gen_tagtype(rnd : @quickcheck/splitmix.RandomState, env : Env) -> TagType? {\n  // Tags reference a function type (for exception parameters)\n  let func_tidxs = collect_tag_functype_typeidxs(env)\n  if func_tidxs.length() == 0 {\n    return None\n  }\n  let pick = (rnd.next_uint() % func_tidxs.length().reinterpret_as_uint()).reinterpret_as_int()\n  Some(TagType(func_tidxs[pick]))\n}\n\n///|\npub fn gen_importsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, ImportSec?, Env), String] {\n  let rnd = ctx.rnd\n\n  // Decide whether to have imports at all\n  if rnd.next_uint() % 3 == 0 {\n    return Ok((ctx, None, env))\n  }\n  let imports : Array[Import] = []\n  let mut env = env\n  let mut func_idx = 0\n  let mut table_idx = 0\n  let mut mem_idx = 0\n  let mut global_idx = 0\n  let mut tag_idx = 0\n\n  // Generate 1-4 imports\n  let count = (rnd.next_uint() % 4).reinterpret_as_int() + 1\n  for i in 0..<count {\n    let mod_names = [\"env\", \"wasi\", \"host\"]\n    let mod_pick = (rnd.next_uint() % mod_names.length().reinterpret_as_uint()).reinterpret_as_int()\n    let mod_name = mod_names[mod_pick]\n\n    // Choose import type\n    let import_type = rnd.next_uint() % 5\n    let (name, desc) = match import_type {\n      0 => {\n        // Import a function\n        let func_tidxs = collect_functype_typeidxs(env)\n        if func_tidxs.length() > 0 {\n          let pick = (rnd.next_uint() %\n          func_tidxs.length().reinterpret_as_uint()).reinterpret_as_int()\n          let tidx = func_tidxs[pick]\n          let name = \"func_\" + func_idx.to_string()\n          func_idx = func_idx + 1\n          // Update env with imported function\n          let ft = match env.resolve_functype(tidx) {\n            Some(f) => f\n            None => continue\n          }\n          env = env.push_func(ft)\n          (name, @lib.FuncExternType(tidx))\n        } else {\n          continue\n        }\n      }\n      1 => {\n        // Import a table\n        let tt = gen_tabletype(rnd, env)\n        let name = \"table_\" + table_idx.to_string()\n        table_idx = table_idx + 1\n        env = env.push_table(tt)\n        (name, TableExternType(tt))\n      }\n      2 =>\n        // Import a memory (only if we don't have one yet - MVP limit)\n        if env.mems.length() == 0 {\n          let mt = gen_memtype(rnd)\n          let name = \"memory_\" + mem_idx.to_string()\n          mem_idx = mem_idx + 1\n          env = env.push_mem(mt)\n          (name, MemExternType(mt))\n        } else {\n          continue\n        }\n      3 => {\n        // Import a global\n        let gt = gen_globaltype(rnd)\n        let name = \"global_\" + global_idx.to_string()\n        global_idx = global_idx + 1\n        env = env.push_global(gt)\n        (name, GlobalExternType(gt))\n      }\n      _ =>\n        // Import a tag\n        match gen_tagtype(rnd, env) {\n          Some(tt) => {\n            let name = \"tag_\" + tag_idx.to_string()\n            tag_idx = tag_idx + 1\n            env = env.push_tag(tt)\n            (name, TagExternType(tt))\n          }\n          None => continue\n        }\n    }\n    imports.push(\n      Import(Name(mod_name.to_string_view()), Name(name.to_string_view()), desc),\n    )\n  }\n  let ctx2 = ctx.dec_fuel(imports.length())\n  if imports.length() > 0 {\n    Ok((ctx2, Some(ImportSec(imports)), env))\n  } else {\n    Ok((ctx2, None, env))\n  }\n}\n\n///|\nfn gen_const_expr_for_valtype(\n  rnd : @quickcheck/splitmix.RandomState,\n  vt : ValType,\n  env : Env,\n) -> Expr {\n  match vt {\n    NumTypeValType(I32NumType) => Expr([I32Const(I32(rnd.next_int()))])\n    NumTypeValType(I64NumType) => Expr([I64Const(I64(rnd.next_int64()))])\n    NumTypeValType(F32NumType) => Expr([F32Const(F32(rnd.next_float()))])\n    NumTypeValType(F64NumType) => Expr([F64Const(F64(rnd.next_double()))])\n    VecTypeValType =>\n      Expr([\n        V128Const(\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n          (rnd.next_uint() % 256).to_byte(),\n        ),\n      ])\n    RefTypeValType(rt) =>\n      if rt.is_nullable() {\n        Expr([RefNull(rt.get_heap_type())])\n      } else {\n        // For non-null refs, try ref.func if it's a func type\n        let ht = rt.get_heap_type()\n        match ht {\n          AbsHeapTypeHeapType(FuncAbsHeapType) =>\n            if env.funcs.length() > 0 {\n              let fidx = rnd.next_uint() %\n                env.funcs.length().reinterpret_as_uint()\n              Expr([RefFunc(FuncIdx(fidx))])\n            } else {\n              // Fallback to null (will fail validation for non-null, but safer)\n              Expr([RefNull(ht)])\n            }\n          _ => Expr([RefNull(ht)])\n        }\n      }\n    BotValType => Expr([Unreachable])\n  }\n}\n\n///|\npub fn gen_globalsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, GlobalSec?, Env), String] {\n  let rnd = ctx.rnd\n\n  // Decide whether to have globals\n  if rnd.next_uint() % 3 == 0 {\n    return Ok((ctx, None, env))\n  }\n  let globals : Array[Global] = []\n  let mut env = env\n\n  // Generate 1-4 globals\n  let count = (rnd.next_uint() % 4).reinterpret_as_int() + 1\n  for _ in 0..<count {\n    let gt = gen_globaltype(rnd)\n    let GlobalType(vt, _) = gt\n    let init_expr = gen_const_expr_for_valtype(rnd, vt, env)\n    globals.push(Global(gt, init_expr))\n    env = env.push_global(gt)\n  }\n  let ctx2 = ctx.dec_fuel(count)\n  Ok((ctx2, Some(GlobalSec(globals)), env))\n}\n\n///|\npub fn gen_tagsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, TagSec?, Env), String] {\n  let rnd = ctx.rnd\n\n  // Tags are less common, lower probability\n  if rnd.next_uint() % 4 != 0 {\n    return Ok((ctx, None, env))\n  }\n  let tags : Array[TagType] = []\n  let mut env = env\n\n  // Generate 1-2 tags\n  let count = (rnd.next_uint() % 2).reinterpret_as_int() + 1\n  for _ in 0..<count {\n    match gen_tagtype(rnd, env) {\n      Some(tt) => {\n        tags.push(tt)\n        env = env.push_tag(tt)\n      }\n      None => break\n    }\n  }\n  let ctx2 = ctx.dec_fuel(tags.length())\n  if tags.length() > 0 {\n    Ok((ctx2, Some(TagSec(tags)), env))\n  } else {\n    Ok((ctx2, None, env))\n  }\n}\n\n///|\npub fn gen_exportsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, ExportSec?), String] {\n  let rnd = ctx.rnd\n  let exports : Array[Export] = []\n\n  // Helper to generate unique name\n  fn make_unique_name(base : String, idx : Int) -> String {\n    let name = base + \"_\" + idx.to_string()\n    // Simple uniqueness - in practice collision is rare with index suffix\n    name\n  }\n\n  // Export some functions\n  if env.funcs.length() > 0 {\n    let func_export_count = (rnd.next_uint() %\n    (env.funcs.length().reinterpret_as_uint() + 1)).reinterpret_as_int()\n    for i in 0..<func_export_count {\n      if rnd.next_uint() % 2 == 0 {\n        let name = make_unique_name(\"func\", i)\n        let fidx = rnd.next_uint() % env.funcs.length().reinterpret_as_uint()\n        exports.push(\n          Export(Name(name.to_string_view()), FuncExternIdx(FuncIdx(fidx))),\n        )\n      }\n    }\n  }\n\n  // Export some tables\n  if env.tables.length() > 0 && rnd.next_uint() % 3 == 0 {\n    let name = make_unique_name(\"table\", 0)\n    let tidx = rnd.next_uint() % env.tables.length().reinterpret_as_uint()\n    exports.push(\n      Export(Name(name.to_string_view()), TableExternIdx(TableIdx(tidx))),\n    )\n  }\n\n  // Export memory (common for WASI compatibility)\n  if env.mems.length() > 0 && rnd.next_uint() % 2 == 0 {\n    let name = \"memory\"\n    exports.push(Export(Name(name.to_string_view()), MemExternIdx(MemIdx(0))))\n  }\n\n  // Export some globals\n  if env.globals.length() > 0 && rnd.next_uint() % 3 == 0 {\n    for i in 0..<env.globals.length() {\n      if rnd.next_uint() % 3 == 0 {\n        let name = make_unique_name(\"global\", i)\n        exports.push(\n          Export(\n            Name(name.to_string_view()),\n            GlobalExternIdx(GlobalIdx(i.reinterpret_as_uint())),\n          ),\n        )\n      }\n    }\n  }\n\n  // Export some tags\n  if env.tags.length() > 0 && rnd.next_uint() % 4 == 0 {\n    let name = make_unique_name(\"tag\", 0)\n    let tidx = rnd.next_uint() % env.tags.length().reinterpret_as_uint()\n    exports.push(\n      Export(Name(name.to_string_view()), TagExternIdx(TagIdx(tidx))),\n    )\n  }\n  let ctx2 = ctx.dec_fuel(exports.length())\n  if exports.length() > 0 {\n    Ok((ctx2, Some(ExportSec(exports))))\n  } else {\n    Ok((ctx2, None))\n  }\n}\n\n///|\nfn find_start_func_candidate(env : Env) -> FuncIdx? {\n  // Start function must have type [] -> []\n  for i in 0..<env.funcs.length() {\n    let ft = env.funcs[i]\n    let FuncType(params, results) = ft\n    if params.length() == 0 && results.length() == 0 {\n      return Some(FuncIdx(i.reinterpret_as_uint()))\n    }\n  }\n  None\n}\n\n///|\npub fn gen_startsec_valid(\n  ctx : GenCtx,\n  env : Env,\n) -> Result[(GenCtx, StartSec?), String] {\n  let rnd = ctx.rnd\n\n  // Only generate start function ~25% of the time\n  if rnd.next_uint() % 4 != 0 {\n    return Ok((ctx, None))\n  }\n  match find_start_func_candidate(env) {\n    Some(fidx) => {\n      let ctx2 = ctx.dec_fuel(1)\n      Ok((ctx2, Some(StartSec(fidx))))\n    }\n    None => Ok((ctx, None))\n  }\n}\n\n///|\nfn collect_struct_typeidxs(env : Env) -> Array[TypeIdx] {\n  let out : Array[TypeIdx] = []\n  for i in 0..<env.global_types.length() {\n    let tidx = @lib.TypeIdx(i.reinterpret_as_uint())\n    match env.resolve_comptype(tidx) {\n      Some(StructCompType(_)) => out.push(tidx)\n      _ => ()\n    }\n  }\n  out\n}\n\n///|\nfn collect_array_typeidxs(env : Env) -> Array[TypeIdx] {\n  let out : Array[TypeIdx] = []\n  for i in 0..<env.global_types.length() {\n    let tidx = @lib.TypeIdx(i.reinterpret_as_uint())\n    match env.resolve_comptype(tidx) {\n      Some(ArrayCompType(_)) => out.push(tidx)\n      _ => ()\n    }\n  }\n  out\n}\n\n///|\nfn get_struct_field_count(env : Env, tidx : TypeIdx) -> Int {\n  match env.resolve_comptype(tidx) {\n    Some(StructCompType(fields)) => fields.length()\n    _ => 0\n  }\n}\n\n///|\nfn get_struct_field_mutability(env : Env, tidx : TypeIdx, fidx : Int) -> Mut? {\n  match env.resolve_comptype(tidx) {\n    Some(StructCompType(fields)) =>\n      if fidx < fields.length() {\n        let FieldType(_, m) = fields[fidx]\n        Some(m)\n      } else {\n        None\n      }\n    _ => None\n  }\n}\n\n///|\nfn get_array_elem_mutability(env : Env, tidx : TypeIdx) -> Mut? {\n  match env.resolve_comptype(tidx) {\n    Some(ArrayCompType(FieldType(_, m))) => Some(m)\n    _ => None\n  }\n}\n\n///|\nfn is_packed_storage_type(st : StorageType) -> Bool {\n  st is PackTypeStorageType(_)\n}\n\n///|\nfn get_struct_field_storage_type(\n  env : Env,\n  tidx : TypeIdx,\n  fidx : Int,\n) -> StorageType? {\n  match env.resolve_comptype(tidx) {\n    Some(StructCompType(fields)) =>\n      if fidx < fields.length() {\n        let FieldType(st, _) = fields[fidx]\n        Some(st)\n      } else {\n        None\n      }\n    _ => None\n  }\n}\n\n///|\nfn get_array_storage_type(env : Env, tidx : TypeIdx) -> StorageType? {\n  match env.resolve_comptype(tidx) {\n    Some(ArrayCompType(FieldType(st, _))) => Some(st)\n    _ => None\n  }\n}\n\n///|\nfn gen_struct_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  let struct_idxs = collect_struct_typeidxs(env)\n  if struct_idxs.length() == 0 {\n    return None\n  }\n  let tidx_pick = (rnd.next_uint() % struct_idxs.length().reinterpret_as_uint()).reinterpret_as_int()\n  let tidx = struct_idxs[tidx_pick]\n  let field_count = get_struct_field_count(env, tidx)\n  if field_count == 0 {\n    return Some(StructNewDefault(tidx))\n  }\n  let fidx = (rnd.next_uint() % field_count.reinterpret_as_uint()).reinterpret_as_int()\n  let field_idx = @lib.U32(fidx.reinterpret_as_uint())\n  let choice = rnd.next_uint() % 6\n  match choice {\n    0 => Some(StructNewDefault(tidx))\n    1 => Some(StructNew(tidx))\n    2 =>\n      // struct.get - check if packed\n      match get_struct_field_storage_type(env, tidx, fidx) {\n        Some(st) =>\n          if is_packed_storage_type(st) {\n            // Use signed or unsigned variant\n            if (rnd.next_uint() & 1) == 1 {\n              Some(StructGetS(tidx, field_idx))\n            } else {\n              Some(StructGetU(tidx, field_idx))\n            }\n          } else {\n            Some(StructGet(tidx, field_idx))\n          }\n        None => Some(StructGet(tidx, field_idx))\n      }\n    3 =>\n      // struct.get_s for packed fields\n      match get_struct_field_storage_type(env, tidx, fidx) {\n        Some(st) =>\n          if is_packed_storage_type(st) {\n            Some(StructGetS(tidx, field_idx))\n          } else {\n            Some(StructGet(tidx, field_idx))\n          }\n        None => Some(StructGet(tidx, field_idx))\n      }\n    4 =>\n      // struct.set - only if mutable\n      match get_struct_field_mutability(env, tidx, fidx) {\n        Some(Var) => Some(StructSet(tidx, field_idx))\n        _ => Some(StructNewDefault(tidx))\n      }\n    _ => Some(StructNewDefault(tidx))\n  }\n}\n\n///|\nfn gen_array_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  let array_idxs = collect_array_typeidxs(env)\n  if array_idxs.length() == 0 {\n    return None\n  }\n  let tidx_pick = (rnd.next_uint() % array_idxs.length().reinterpret_as_uint()).reinterpret_as_int()\n  let tidx = array_idxs[tidx_pick]\n  let choice = rnd.next_uint() % 10\n  match choice {\n    0 => Some(ArrayNewDefault(tidx))\n    1 => Some(ArrayNew(tidx))\n    2 => {\n      let n = (rnd.next_uint() % 5).reinterpret_as_int()\n      Some(ArrayNewFixed(tidx, U32(n.reinterpret_as_uint())))\n    }\n    3 =>\n      // array.get - check if packed\n      match get_array_storage_type(env, tidx) {\n        Some(st) =>\n          if is_packed_storage_type(st) {\n            if (rnd.next_uint() & 1) == 1 {\n              Some(ArrayGetS(tidx))\n            } else {\n              Some(ArrayGetU(tidx))\n            }\n          } else {\n            Some(ArrayGet(tidx))\n          }\n        None => Some(ArrayGet(tidx))\n      }\n    4 =>\n      // array.get_s for packed\n      match get_array_storage_type(env, tidx) {\n        Some(st) =>\n          if is_packed_storage_type(st) {\n            Some(ArrayGetS(tidx))\n          } else {\n            Some(ArrayGet(tidx))\n          }\n        None => Some(ArrayGet(tidx))\n      }\n    5 =>\n      // array.set - only if mutable\n      match get_array_elem_mutability(env, tidx) {\n        Some(Var) => Some(ArraySet(tidx))\n        _ => Some(ArrayNewDefault(tidx))\n      }\n    6 => Some(ArrayLen)\n    7 =>\n      // array.fill - only if mutable\n      match get_array_elem_mutability(env, tidx) {\n        Some(Var) => Some(ArrayFill(tidx))\n        _ => Some(ArrayLen)\n      }\n    8 => {\n      // array.copy - need two compatible array types, both mutable dest\n      let dest_tidx = tidx\n      match get_array_elem_mutability(env, dest_tidx) {\n        Some(Var) => {\n          // Find a compatible source array\n          for src_tidx in array_idxs {\n            // For simplicity, use same type\n            if src_tidx == dest_tidx {\n              return Some(ArrayCopy(dest_tidx, src_tidx))\n            }\n          }\n          Some(ArrayLen)\n        }\n        _ => Some(ArrayLen)\n      }\n    }\n    _ => Some(ArrayNewDefault(tidx))\n  }\n}\n\n///|\nfn gen_tag_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  if env.tags.length() == 0 {\n    return None\n  }\n  let tag_pick = (rnd.next_uint() % env.tags.length().reinterpret_as_uint()).reinterpret_as_int()\n  let tag_idx = @lib.TagIdx(tag_pick.reinterpret_as_uint())\n\n  // throw is the main instruction we can generate simply\n  Some(Throw(tag_idx))\n}\n\n///|\nfn gen_ref_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  let choice = rnd.next_uint() % 10\n  match choice {\n    0 => {\n      // ref.null with random heap type\n      let abs = match rnd.next_uint() % 8 {\n        0 => @lib.AnyAbsHeapType\n        1 => EqAbsHeapType\n        2 => I31AbsHeapType\n        3 => StructAbsHeapType\n        4 => ArrayAbsHeapType\n        5 => FuncAbsHeapType\n        6 => ExternAbsHeapType\n        _ => NoneAbsHeapType\n      }\n      Some(RefNull(AbsHeapTypeHeapType(abs)))\n    }\n    1 => Some(RefIsNull)\n    2 => Some(RefAsNonNull)\n    3 => Some(RefEq)\n    4 => Some(RefI31)\n    5 => Some(I31GetS)\n    6 => Some(I31GetU)\n    7 => {\n      // ref.test with a type\n      let struct_idxs = collect_struct_typeidxs(env)\n      if struct_idxs.length() > 0 {\n        let pick = (rnd.next_uint() % struct_idxs.length().reinterpret_as_uint()).reinterpret_as_int()\n        Some(RefTest(false, HeapType(struct_idxs[pick])))\n      } else {\n        Some(RefIsNull)\n      }\n    }\n    8 => {\n      // ref.cast with a type\n      let struct_idxs = collect_struct_typeidxs(env)\n      if struct_idxs.length() > 0 {\n        let pick = (rnd.next_uint() % struct_idxs.length().reinterpret_as_uint()).reinterpret_as_int()\n        let nullable = (rnd.next_uint() & 1) == 1\n        Some(RefCast(nullable, HeapType(struct_idxs[pick])))\n      } else {\n        Some(RefIsNull)\n      }\n    }\n    _ =>\n      // ref.func if we have functions\n      if env.funcs.length() > 0 {\n        let fidx = rnd.next_uint() % env.funcs.length().reinterpret_as_uint()\n        Some(RefFunc(FuncIdx(fidx)))\n      } else {\n        Some(RefIsNull)\n      }\n  }\n}\n\n///|\nfn gen_numeric_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n) -> Instruction {\n  let choice = rnd.next_uint() % 40\n  match choice {\n    // i32 operations\n    0 => I32Add\n    1 => I32Sub\n    2 => I32Mul\n    3 => I32DivS\n    4 => I32DivU\n    5 => I32RemS\n    6 => I32RemU\n    7 => I32And\n    8 => I32Or\n    9 => I32Xor\n    10 => I32Shl\n    11 => I32ShrS\n    12 => I32ShrU\n    13 => I32Eqz\n    14 => I32Eq\n    15 => I32Ne\n    16 => I32LtS\n    17 => I32LtU\n    18 => I32GtS\n    19 => I32GtU\n    // i64 operations\n    20 => I64Add\n    21 => I64Sub\n    22 => I64Mul\n    23 => I64Eqz\n    24 => I64Eq\n    25 => I64Ne\n    // f32 operations\n    26 => F32Add\n    27 => F32Sub\n    28 => F32Mul\n    29 => F32Div\n    30 => F32Eq\n    31 => F32Ne\n    // f64 operations\n    32 => F64Add\n    33 => F64Sub\n    34 => F64Mul\n    35 => F64Div\n    // conversions\n    36 => I32WrapI64\n    37 => I64ExtendI32S\n    38 => I64ExtendI32U\n    _ => I32Const(I32(rnd.next_int()))\n  }\n}\n\n///|\n\n///|\nfn gen_memory_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  if env.mems.length() == 0 {\n    return None\n  }\n  let mem_idx_val = rnd.next_uint() % env.mems.length().reinterpret_as_uint()\n  let mem_idx = @lib.MemIdx(mem_idx_val)\n\n  // Generate alignment (must be power of 2, encoded as log2)\n  // For i32 load/store: max align is 2 (4 bytes)\n  // For i64 load/store: max align is 3 (8 bytes)\n  // For i8 load/store: max align is 0 (1 byte)\n  fn make_memarg(\n    rnd : @quickcheck/splitmix.RandomState,\n    max_align : UInt,\n    env : Env,\n    mem_idx : MemIdx,\n  ) -> MemArg {\n    let align = rnd.next_uint() % (max_align + 1)\n    let offset = rnd.next_uint64() % 256 // small offset\n    let mem_idx_opt = if env.mems.length() == 1 { None } else { Some(mem_idx) }\n    MemArg(U32(align), mem_idx_opt, U64(offset))\n  }\n\n  let choice = rnd.next_uint() % 16\n  match choice {\n    0 => Some(I32Load(make_memarg(rnd, 2, env, mem_idx)))\n    1 => Some(I64Load(make_memarg(rnd, 3, env, mem_idx)))\n    2 => Some(F32Load(make_memarg(rnd, 2, env, mem_idx)))\n    3 => Some(F64Load(make_memarg(rnd, 3, env, mem_idx)))\n    4 => Some(I32Load8S(make_memarg(rnd, 0, env, mem_idx)))\n    5 => Some(I32Load8U(make_memarg(rnd, 0, env, mem_idx)))\n    6 => Some(I32Load16S(make_memarg(rnd, 1, env, mem_idx)))\n    7 => Some(I32Load16U(make_memarg(rnd, 1, env, mem_idx)))\n    8 => Some(I32Store(make_memarg(rnd, 2, env, mem_idx)))\n    9 => Some(I64Store(make_memarg(rnd, 3, env, mem_idx)))\n    10 => Some(F32Store(make_memarg(rnd, 2, env, mem_idx)))\n    11 => Some(F64Store(make_memarg(rnd, 3, env, mem_idx)))\n    12 => Some(I32Store8(make_memarg(rnd, 0, env, mem_idx)))\n    13 => Some(I32Store16(make_memarg(rnd, 1, env, mem_idx)))\n    14 => Some(MemorySize(mem_idx))\n    _ => Some(MemoryGrow(mem_idx))\n  }\n}\n\n///|\nfn gen_local_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  if env.locals.length() == 0 {\n    return None\n  }\n  let idx = rnd.next_uint() % env.locals.length().reinterpret_as_uint()\n  let local_idx = @lib.LocalIdx(idx)\n  match rnd.next_uint() % 3 {\n    0 => Some(LocalGet(local_idx))\n    1 => Some(LocalSet(local_idx))\n    _ => Some(LocalTee(local_idx))\n  }\n}\n\n///|\nfn gen_global_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  if env.globals.length() == 0 {\n    return None\n  }\n  let idx = rnd.next_uint() % env.globals.length().reinterpret_as_uint()\n  let global_idx = @lib.GlobalIdx(idx)\n\n  // Check mutability for global.set\n  let gt = env.globals[idx.reinterpret_as_int()]\n  let GlobalType(_, is_mut) = gt\n  if is_mut && (rnd.next_uint() & 1) == 1 {\n    Some(GlobalSet(global_idx))\n  } else {\n    Some(GlobalGet(global_idx))\n  }\n}\n\n///|\nfn gen_call_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  if env.funcs.length() == 0 {\n    return None\n  }\n  let fidx = rnd.next_uint() % env.funcs.length().reinterpret_as_uint()\n  match rnd.next_uint() % 2 {\n    0 => Some(Call(FuncIdx(fidx)))\n    _ =>\n      // call_indirect needs a table with funcref\n      if env.tables.length() > 0 {\n        // Find a funcref table\n        for i in 0..<env.tables.length() {\n          let TableType(rt, _) = env.tables[i]\n          let funcref = @lib.HeapTypeRefType(\n            true,\n            AbsHeapTypeHeapType(FuncAbsHeapType),\n          )\n          if Match::matches(funcref, rt, env) {\n            // Need to find the function type index\n            let func_tidxs = collect_functype_typeidxs(env)\n            if func_tidxs.length() > 0 {\n              let tidx_pick = (rnd.next_uint() %\n              func_tidxs.length().reinterpret_as_uint()).reinterpret_as_int()\n              return Some(\n                CallIndirect(\n                  func_tidxs[tidx_pick],\n                  TableIdx(i.reinterpret_as_uint()),\n                ),\n              )\n            }\n          }\n        }\n        Some(Call(FuncIdx(fidx)))\n      } else {\n        Some(Call(FuncIdx(fidx)))\n      }\n  }\n}\n\n///|\nfn gen_table_instruction(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Instruction? {\n  if env.tables.length() == 0 {\n    return None\n  }\n  let tidx = rnd.next_uint() % env.tables.length().reinterpret_as_uint()\n  let table_idx = @lib.TableIdx(tidx)\n  match rnd.next_uint() % 4 {\n    0 => Some(TableGet(table_idx))\n    1 => Some(TableSet(table_idx))\n    2 => Some(TableSize(table_idx))\n    _ => Some(TableGrow(table_idx))\n  }\n}\n\n///|\nfn gen_candidate_instruction(ctx : GenCtx, st : TcState) -> Instruction {\n  // Weighted selection to ensure variety\n  let choice = (ctx.rnd.next_uint() % 100).reinterpret_as_int()\n  match choice {\n    // Constants (10%)\n    0 | 1 => I32Const(I32(ctx.rnd.next_int()))\n    2 | 3 => I64Const(I64(ctx.rnd.next_int64()))\n    4 => F32Const(F32(ctx.rnd.next_float()))\n    5 => F64Const(F64(ctx.rnd.next_double()))\n    6 | 7 | 8 | 9 =>\n      V128Const(\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n        (ctx.rnd.next_uint() % 256).to_byte(),\n      )\n\n    // Struct operations (15%)\n    10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 =>\n      match gen_struct_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => I32Const(I32(ctx.rnd.next_int()))\n      }\n\n    // Array operations (15%)\n    25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 =>\n      match gen_array_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => I32Const(I32(ctx.rnd.next_int()))\n      }\n\n    // Tag/exception operations (5%)\n    40 | 41 | 42 | 43 | 44 =>\n      match gen_tag_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Reference operations (10%)\n    45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 =>\n      match gen_ref_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Numeric operations (20%)\n    55\n    | 56\n    | 57\n    | 58\n    | 59\n    | 60\n    | 61\n    | 62\n    | 63\n    | 64\n    | 65\n    | 66\n    | 67\n    | 68\n    | 69\n    | 70\n    | 71\n    | 72\n    | 73\n    | 74 => gen_numeric_instruction(ctx.rnd)\n\n    // Local operations (8%)\n    75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 =>\n      match gen_local_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Global operations (5%)\n    83 | 84 | 85 | 86 | 87 =>\n      match gen_global_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Memory operations (5%)\n    88 | 89 | 90 | 91 | 92 =>\n      match gen_memory_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Call operations (5%)\n    93 | 94 | 95 | 96 | 97 =>\n      match gen_call_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Table operations (3%)\n    98 | 99 =>\n      match gen_table_instruction(ctx.rnd, st.env) {\n        Some(ins) => ins\n        None => Nop\n      }\n\n    // Misc\n    _ =>\n      match ctx.rnd.next_uint() % 3 {\n        0 => Nop\n        1 => Drop\n        _ => Select(None)\n      }\n  }\n}\n\n///|\nfn gen_try_table_robust(\n  ctx : GenCtx,\n  st : TcState,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  if st.env.tags.length() == 0 {\n    return Err(\"no tags for try_table\")\n  }\n  let rnd = ctx.rnd\n\n  // Choose strategy\n  let strategy = rnd.next_uint() % 4\n  match strategy {\n    0 => gen_try_catch_all(ctx, st, rnd)\n    1 => gen_try_catch_all_ref(ctx, st, rnd)\n    2 => gen_try_catch(ctx, st, rnd)\n    3 => gen_try_catch_ref(ctx, st, rnd)\n    _ => gen_try_catch_all(ctx, st, rnd)\n  }\n}\n\n///|\nfn gen_try_catch_all(\n  ctx : GenCtx,\n  st : TcState,\n  rnd : @quickcheck/splitmix.RandomState,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  // Structure: block (result) { try_table { catch_all 0; <body> } }\n  // catch_all branches with empty values, outer block has empty result\n\n  let try_body = gen_simple_try_body(rnd, st.env)\n  let catch_clause = @lib.CatchAll(LabelIdx(0))\n  let try_table = @lib.TryTable(EmptyBlockType, [catch_clause], try_body)\n  let block_ins = @lib.Block(EmptyBlockType, [try_table])\n  match Typecheck::typecheck(block_ins, st) {\n    Ok(st2) => Ok((ctx.dec_fuel(3), st2, [block_ins]))\n    Err(e) => Err(e)\n  }\n}\n\n///|\nfn gen_try_catch_all_ref(\n  ctx : GenCtx,\n  st : TcState,\n  rnd : @quickcheck/splitmix.RandomState,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  // catch_all_ref branches with [exnref]\n  // After try_table completes normally, we need to produce an exnref\n  // Since we can't easily produce a non-null exnref, use nullable\n\n  let exnref_nullable = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ExnAbsHeapType)),\n  )\n  let outer_bt = @lib.ValTypeBlockType(exnref_nullable)\n  let try_body = gen_simple_try_body(rnd, st.env)\n  let catch_clause = @lib.CatchAllRef(LabelIdx(0))\n  let try_table = @lib.TryTable(EmptyBlockType, [catch_clause], try_body)\n\n  // After try_table, produce null exnref for fallthrough\n  let fallthrough = @lib.RefNull(AbsHeapTypeHeapType(ExnAbsHeapType))\n  let block_ins = @lib.Block(outer_bt, [try_table, fallthrough])\n  match Typecheck::typecheck(block_ins, st) {\n    Ok(st2) => Ok((ctx.dec_fuel(4), st2, [block_ins]))\n    Err(e) => Err(e)\n  }\n}\n\n///|\nfn gen_try_catch(\n  ctx : GenCtx,\n  st : TcState,\n  rnd : @quickcheck/splitmix.RandomState,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  // catch tag L branches with tag's payload types\n  // Outer block result = payload types\n\n  let tag_idx = @lib.TagIdx(\n    rnd.next_uint() % st.env.tags.length().reinterpret_as_uint(),\n  )\n  let payload = tag_payload_types(st.env, tag_idx)\n\n  // Build block type - only support empty or single-value for simplicity\n  let outer_bt = match payload.length() {\n    0 => @lib.EmptyBlockType\n    1 => ValTypeBlockType(payload[0])\n    _ => return Err(\"multi-value catch payload not supported yet\")\n  }\n\n  // Generate fallthrough values for when try completes normally\n  let fallthrough = match gen_fallthrough_values(rnd, payload) {\n    Ok(ins) => ins\n    Err(e) => return Err(e)\n  }\n  let try_body = gen_simple_try_body(rnd, st.env)\n  let catch_clause = @lib.Catch(tag_idx, LabelIdx(0))\n  let try_table = @lib.TryTable(EmptyBlockType, [catch_clause], try_body)\n  let block_body : Array[Instruction] = [try_table]\n  for ins in fallthrough {\n    block_body.push(ins)\n  }\n  let block_ins = @lib.Block(outer_bt, block_body)\n  match Typecheck::typecheck(block_ins, st) {\n    Ok(st2) => Ok((ctx.dec_fuel(4 + fallthrough.length()), st2, [block_ins]))\n    Err(e) => Err(e)\n  }\n}\n\n///|\nfn gen_try_catch_ref(\n  ctx : GenCtx,\n  st : TcState,\n  rnd : @quickcheck/splitmix.RandomState,\n) -> Result[(GenCtx, TcState, Array[Instruction]), String] {\n  // catch_ref tag L branches with payload + exnref\n  // For simplicity, only handle tags with empty payload\n\n  let tag_idx = @lib.TagIdx(\n    rnd.next_uint() % st.env.tags.length().reinterpret_as_uint(),\n  )\n  let payload = tag_payload_types(st.env, tag_idx)\n\n  // Only support empty payload for catch_ref (result is just exnref)\n  if payload.length() != 0 {\n    // Fall back to catch_all\n    return gen_try_catch_all(ctx, st, rnd)\n  }\n\n  // catch_ref with empty payload produces non-null exnref\n  // We use nullable outer block since fallthrough can only produce ref.null\n  // (non-null exnref from catch is subtype of nullable)\n  let exnref_nullable = @lib.RefTypeValType(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ExnAbsHeapType)),\n  )\n  let outer_bt = @lib.ValTypeBlockType(exnref_nullable)\n  let try_body = gen_simple_try_body(rnd, st.env)\n  let catch_clause = @lib.CatchRef(tag_idx, LabelIdx(0))\n  let try_table = @lib.TryTable(EmptyBlockType, [catch_clause], try_body)\n\n  // Fallthrough: produce null exnref\n  let fallthrough = @lib.RefNull(AbsHeapTypeHeapType(ExnAbsHeapType))\n  let block_ins = @lib.Block(outer_bt, [try_table, fallthrough])\n  match Typecheck::typecheck(block_ins, st) {\n    Ok(st2) => Ok((ctx.dec_fuel(4), st2, [block_ins]))\n    Err(e) => Err(e)\n  }\n}\n\n///|\nfn gen_simple_try_body(\n  rnd : @quickcheck/splitmix.RandomState,\n  env : Env,\n) -> Array[Instruction] {\n  let body : Array[Instruction] = []\n\n  // Sometimes just nop\n  if rnd.next_uint() % 3 == 0 {\n    body.push(Nop)\n    return body\n  }\n\n  // Sometimes throw\n  if env.tags.length() > 0 && rnd.next_uint() % 2 == 0 {\n    let tag_idx = @lib.TagIdx(\n      rnd.next_uint() % env.tags.length().reinterpret_as_uint(),\n    )\n    let payload = tag_payload_types(env, tag_idx)\n\n    // Push values for throw payload\n    for p in payload {\n      match p {\n        NumTypeValType(I32NumType) => body.push(I32Const(I32(rnd.next_int())))\n        NumTypeValType(I64NumType) => body.push(I64Const(I64(rnd.next_int64())))\n        NumTypeValType(F32NumType) => body.push(F32Const(F32(rnd.next_float())))\n        NumTypeValType(F64NumType) =>\n          body.push(F64Const(F64(rnd.next_double())))\n        VecTypeValType =>\n          body.push(\n            V128Const(\n              0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0,\n              0b0, 0b0,\n            ),\n          )\n        RefTypeValType(rt) =>\n          if rt.is_nullable() {\n            body.push(RefNull(rt.get_heap_type()))\n          } else {\n            // Can't easily produce non-null ref, skip throw\n            body.push(Nop)\n            return body\n          }\n        BotValType => ()\n      }\n    }\n    body.push(Throw(tag_idx))\n  } else {\n    body.push(Nop)\n  }\n  body\n}\n\n///|\nfn gen_fallthrough_values(\n  rnd : @quickcheck/splitmix.RandomState,\n  types : Array[ValType],\n) -> Result[Array[Instruction], String] {\n  let out : Array[Instruction] = []\n  for vt in types {\n    match vt {\n      NumTypeValType(I32NumType) => out.push(I32Const(I32(rnd.next_int())))\n      NumTypeValType(I64NumType) => out.push(I64Const(I64(rnd.next_int64())))\n      NumTypeValType(F32NumType) => out.push(F32Const(F32(rnd.next_float())))\n      NumTypeValType(F64NumType) => out.push(F64Const(F64(rnd.next_double())))\n      VecTypeValType =>\n        out.push(\n          V128Const(\n            0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0,\n          ),\n        )\n      RefTypeValType(rt) =>\n        if rt.is_nullable() {\n          out.push(RefNull(rt.get_heap_type()))\n        } else {\n          return Err(\"cannot produce non-null ref for fallthrough\")\n        }\n      BotValType => return Err(\"cannot produce bot value\")\n    }\n  }\n  Ok(out)\n}\n\n///|\nfn tag_payload_types(env : Env, tag : TagIdx) -> Array[ValType] {\n  let idx = tag.0\n  // Guard against overflow - if idx >= 2^31, it would become negative when cast to Int\n  if idx > 0x7FFFFFFF {\n    return []\n  }\n  match env.tags.get(idx.reinterpret_as_int()) {\n    Some(TagType(tidx)) =>\n      match env.resolve_functype(tidx) {\n        Some(FuncType(params, _)) => params\n        None => []\n      }\n    None => []\n  }\n}\n\n///|\npub fn gen_expr_valid_with_blocks(\n  ctx : GenCtx,\n  st0 : TcState,\n  want : Array[ValType],\n) -> Result[Expr, String] {\n  let mut ctx = ctx\n  let mut st = st0\n  let insns : Array[Instruction] = []\n\n  // Keep some fuel for finishing\n  while ctx.fuel > 15 {\n    // Occasionally decide to finish early\n    if ctx.rnd.next_uint() % 10 == 0 {\n      break\n    }\n\n    // Occasionally try to generate a try_table block\n    if ctx.rnd.next_uint() % 20 == 0 && st.env.tags.length() > 0 {\n      match gen_try_table_robust(ctx, st) {\n        Ok((ctx2, st2, block_insns)) => {\n          for ins in block_insns {\n            insns.push(ins)\n          }\n          ctx = ctx2\n          st = st2\n          continue\n        }\n        Err(_) => ()\n      }\n    }\n    let mut accepted = false\n\n    // Try multiple candidates; accept the first that typechecks\n    for _ in 0..<50 {\n      let cand = gen_candidate_instruction(ctx, st)\n      match Typecheck::typecheck(cand, st) {\n        Ok(st2) => {\n          insns.push(cand)\n          st = st2\n          ctx = ctx.dec_fuel(1)\n          accepted = true\n          break\n        }\n        Err(_) => ()\n      }\n    }\n    if not(accepted) {\n      break\n    }\n    if not(st.reachable) {\n      break\n    }\n  }\n\n  // Finish with required results + return\n  let (ctx2, _st2, fin) = match emit_finish_return(ctx, st, want) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  ctx = ctx2\n  for i in fin {\n    insns.push(i)\n  }\n  Ok(Expr(insns))\n}\n\n///|\npub fn gen_tfunc_entry(ctx : GenCtx, tidx : TypeIdx) -> Result[Func, String] {\n  // 1) Resolve the function type\n  let ft = match ctx.env.resolve_functype(tidx) {\n    Some(x) => x\n    None => return Err(\"gen_tfunc_entry: Func type not found\")\n  }\n  let FuncType(_, results) = ft\n\n  // 2) Generate local declarations\n  let locals_decls = gen_locals_decls(ctx.rnd, 3)\n\n  // 3) Prepare environment and state for the body\n  let env_body = match env_for_func_body(ctx.env, ft, locals_decls) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let st0 = TcState::{ env: env_body, stack: [], reachable: true }\n\n  // 4) Generate a valid flat expression\n  let expr = match gen_expr_valid_with_blocks(ctx, st0, results) {\n    Ok(e) => e\n    Err(e) => return Err(e)\n  }\n\n  // 5) Try to convert to TExpr, fall back to Func if it fails\n  match expr_to_texpr(expr, env_body) {\n    Ok(texpr) => {\n      // 6) Expand Locals to Array[ValType] for the TFunc signature\n      let local_types : Array[ValType] = []\n      for l in locals_decls {\n        let Locals(c, t) = l\n        for _ in 0..<c.reinterpret_as_int() {\n          local_types.push(t)\n        }\n      }\n      Ok(TFunc(local_types, texpr))\n    }\n    Err(_) =>\n      // Fall back to regular Func if tree conversion fails\n      Ok(Func(locals_decls, expr))\n  }\n}\n\n///|\npub fn gen_func_entry(ctx : GenCtx, tidx : TypeIdx) -> Result[Func, String] {\n  // Resolve the function type from the environment\n  let ft = match ctx.env.resolve_functype(tidx) {\n    Some(x) => x\n    None => return Err(\"gen_func_entry: Func type not found\")\n  }\n  let FuncType(_, results) = ft\n\n  // Generate local declarations\n  let locals_decls = gen_locals_decls(ctx.rnd, 3)\n\n  // Create the environment and typechecking state for the function body\n  let env_body = match env_for_func_body(ctx.env, ft, locals_decls) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let st0 = TcState::{ env: env_body, stack: [], reachable: true }\n\n  // Generate a valid expression using the block-enabled generator\n  let expr = match gen_expr_valid_with_blocks(ctx, st0, results) {\n    Ok(e) => e\n    Err(e) => return Err(e)\n  }\n\n  // Return the Func variant. \n  // To produce TFunc, you would convert expr to TExpr using expr_to_texpr,\n  // extract ValTypes from params and locals_decls, and use the TFunc constructor.\n  Ok(Func(locals_decls, expr))\n}\n\n///|\npub fn gen_module_valid_full(ctx0 : GenCtx) -> Result[(GenCtx, Module), String] {\n  // 1) Generate TypeSec\n  let (ctx1, typesec) = match gen_typesec_valid(ctx0) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n\n  // 2) Build env with typesec\n  let env1 = match validate_typesec(Some(typesec), empty_env()) {\n    Ok(e) => e\n    Err(e) => return Err(e)\n  }\n  let ctx2 = GenCtx::{ ..ctx1, env: env1 }\n\n  // 3) Generate ImportSec (before FuncSec - imports come first)\n  let (ctx3, importsec, env2) = match gen_importsec_valid(ctx2, ctx2.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx3 = GenCtx::{ ..ctx3, env: env2 }\n\n  // 4) Choose functype TypeIdxs for FuncSec\n  let choices = collect_functype_typeidxs(ctx3.env)\n  if choices.length() == 0 {\n    return Err(\"gen_module_valid: no function types available\")\n  }\n  let func_count = (ctx3.rnd.next_uint() % 3 + 1).reinterpret_as_int()\n  let func_tidxs : Array[TypeIdx] = []\n  for _ in 0..<func_count {\n    let pick = (ctx3.rnd.next_uint() % choices.length().reinterpret_as_uint()).reinterpret_as_int()\n    func_tidxs.push(choices[pick])\n  }\n  let funcsec = @lib.FuncSec(func_tidxs)\n\n  // 5) Extend env.funcs\n  let env3 = match validate_funcsec(Some(funcsec), ctx3.env) {\n    Ok(e) => e\n    Err(e) => return Err(e)\n  }\n  let ctx4 = GenCtx::{ ..ctx3, env: env3 }\n\n  // 6) Generate TableSec\n  let (ctx5, tablesec, env4) = match gen_tablesec_valid(ctx4, ctx4.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx5 = GenCtx::{ ..ctx5, env: env4 }\n\n  // 7) Generate MemSec\n  let (ctx6, memsec, env5) = match gen_memsec_valid(ctx5, ctx5.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx6 = GenCtx::{ ..ctx6, env: env5 }\n\n  // 8) Generate TagSec\n  let (ctx7, tagsec, env6) = match gen_tagsec_valid(ctx6, ctx6.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx7 = GenCtx::{ ..ctx7, env: env6 }\n\n  // 9) Generate GlobalSec\n  let (ctx8, globalsec, env7) = match gen_globalsec_valid(ctx7, ctx7.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx8 = GenCtx::{ ..ctx8, env: env7 }\n\n  // 10) Generate ExportSec\n  let (ctx9, exportsec) = match gen_exportsec_valid(ctx8, ctx8.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n\n  // 11) Generate StartSec\n  let (ctx10, startsec) = match gen_startsec_valid(ctx9, ctx8.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n\n  // 12) Generate ElemSec\n  let (ctx11, elemsec, env8) = match gen_elemsec_valid(ctx10, ctx8.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx11 = GenCtx::{ ..ctx11, env: env8 }\n\n  // 13) Generate DataSec\n  let (ctx12, datasec, env9) = match gen_datasec_valid(ctx11, ctx11.env) {\n    Ok(x) => x\n    Err(e) => return Err(e)\n  }\n  let ctx12 = GenCtx::{ ..ctx12, env: env9 }\n\n  // 14) Generate DataCntSec\n  let DataSec(data_arr) = datasec\n  let datacntsec = @lib.DataCntSec(U32(data_arr.length().reinterpret_as_uint()))\n\n  // 15) Generate function bodies for CodeSec\n  let code_funcs : Array[Func] = []\n  let FuncSec(tidxs2) = funcsec\n  for tidx in tidxs2 {\n    // Randomly decide between generating a Func or a TFunc\n    let func = if ctx12.rnd.next_uint() % 2 == 0 {\n      gen_func_entry(ctx12, tidx)\n    } else {\n      gen_tfunc_entry(ctx12, tidx)\n    }\n    let f = match func {\n      Ok(f) => f\n      Err(e) => return Err(e)\n    }\n    code_funcs.push(f)\n  }\n  let codesec = @lib.CodeSec(code_funcs)\n\n  // 16) Assemble module\n  let m = @lib.Module(\n    [], // customs\n    Some(typesec),\n    importsec,\n    Some(funcsec),\n    Some(tablesec),\n    Some(memsec),\n    tagsec,\n    globalsec,\n    exportsec,\n    startsec,\n    Some(elemsec),\n    Some(datacntsec),\n    Some(codesec),\n    Some(datasec),\n  )\n  Ok((ctx12, m))\n}\n","///|\npub fn Env::resolve_subtype(env : Env, idx : TypeIdx) -> SubType? {\n  match idx {\n    TypeIdx(i) => env.global_types.get(i.reinterpret_as_int())\n    RecIdx(j) => {\n      let n = env.rec_stack.length()\n      if n == 0 {\n        return None\n      }\n      match env.rec_stack.get(n - 1) {\n        None => None\n        Some(group) => group.get(j.reinterpret_as_int())\n      }\n    }\n  }\n}\n\n///|\npub fn Env::resolve_heaptype_subtype(env : Env, ht : HeapType) -> SubType? {\n  match ht {\n    AbsHeapTypeHeapType(_) => None\n    HeapType(ti) => env.resolve_subtype(ti)\n    DefTypeHeapType(dt) => dt.project()\n  }\n}\n\n///|\npub fn Env::get_label(env : Env, idx : LabelIdx) -> Array[ValType]? {\n  let LabelIdx(i) = idx\n  env.labels.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::get_tag(env : Env, idx : TagIdx) -> TagType? {\n  let TagIdx(i) = idx\n  env.tags.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::resolve_comptype(env : Env, idx : TypeIdx) -> CompType? {\n  match env.resolve_subtype(idx) {\n    None => None\n    Some(st) => Some(st.get_comptype())\n  }\n}\n\n///|\npub fn Env::resolve_functype(env : Env, idx : TypeIdx) -> FuncType? {\n  match env.resolve_comptype(idx) {\n    Some(FuncCompType(ps, rs)) => Some(FuncType(ps, rs))\n    _ => None\n  }\n}\n\n///|\npub fn Env::resolve_tag_functype(env : Env, tagidx : TagIdx) -> FuncType? {\n  match env.get_tag(tagidx) {\n    None => None\n    Some(TagType(tidx)) => env.resolve_functype(tidx)\n  }\n}\n\n///|\npub fn Env::resolve_typeidx_subtype(env : Env, tidx : TypeIdx) -> SubType? {\n  match tidx {\n    TypeIdx(i) => env.global_types.get(i.reinterpret_as_int())\n    RecIdx(j) => {\n      let n = env.rec_stack.length()\n      if n == 0 {\n        return None\n      }\n      match env.rec_stack.get(n - 1) {\n        None => None\n        Some(group) => group.get(j.reinterpret_as_int())\n      }\n    }\n  }\n}\n\n///|\npub fn Env::get_local_type(env : Env, idx : LocalIdx) -> ValType? {\n  let LocalIdx(i) = idx\n  env.locals.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::get_global_type(env : Env, idx : GlobalIdx) -> GlobalType? {\n  let GlobalIdx(i) = idx\n  env.globals.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::get_table_type(env : Env, idx : TableIdx) -> TableType? {\n  let TableIdx(i) = idx\n  env.tables.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::with_label(env : Env, ts : Array[ValType]) -> Env {\n  let ls = env.labels.copy()\n  ls.push(ts)\n  Env::{ ..env, labels: ls }\n}\n\n///|\npub fn Env::with_labels(env : Env, labels : Stack[Array[ValType]]) -> Env {\n  Env::{ ..env, labels, }\n}\n\n///|\npub fn Env::with_return_type(env : Env, rt : Array[ValType]?) -> Env {\n  Env::{ ..env, return_type: rt }\n}\n\n///|\npub fn Env::with_rectype(env : Env, rt : RecType) -> Env {\n  let rs = env.rec_stack.copy()\n  match rt {\n    SingleRecType(st) => rs.push([st])\n    GroupRecType(sts) => rs.push(sts)\n  }\n  Env::{ ..env, rec_stack: rs }\n}\n\n///|\npub fn Env::append_rectype_types(env : Env, rt : RecType) -> Env {\n  let gts = env.global_types.copy()\n  match rt {\n    SingleRecType(st) => gts.push(st)\n    GroupRecType(sts) =>\n      for st in sts {\n        gts.push(st)\n      }\n  }\n  Env::{ ..env, global_types: gts }\n}\n\n///|\npub fn empty_env() -> Env {\n  Env::{\n    global_types: [],\n    rec_stack: [],\n    funcs: [],\n    tables: [],\n    mems: [],\n    globals: [],\n    elems: [],\n    datas: [],\n    tags: [],\n    locals: [],\n    labels: [],\n    return_type: None,\n  }\n}\n\n///|\npub fn Env::new() -> Env {\n  empty_env()\n}\n\n///|\npub fn Env::get_label_types(env : Env, idx : LabelIdx) -> Array[ValType]? {\n  let LabelIdx(i) = idx\n  let n = env.labels.length() // Int\n  let ii = n - 1 - i.reinterpret_as_int()\n  if ii < 0 {\n    return None\n  }\n  env.labels.get(ii)\n}\n\n///|\npub fn Env::expand_blocktype(\n  env : Env,\n  bt : BlockType,\n) -> Result[(Array[ValType], Array[ValType]), String] {\n  match bt {\n    EmptyBlockType => Ok(([], []))\n    ValTypeBlockType(vt) => Ok(([], [vt]))\n    TypeIdxBlockType(tidx) =>\n      match env.resolve_functype(tidx) {\n        None => Err(\"blocktype type index is not a function type\")\n        Some(FuncType(params, results)) => Ok((params, results))\n      }\n  }\n}\n\n///|\npub fn Env::get_functype_by_funcidx(env : Env, idx : FuncIdx) -> FuncType? {\n  let FuncIdx(i) = idx\n  env.funcs.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::get_elem(env : Env, i : ElemIdx) -> Elem? {\n  let ElemIdx(i) = i\n  env.elems.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::get_memtype(env : Env, idx : MemIdx) -> MemType? {\n  let MemIdx(i) = idx\n  env.mems.get(i.reinterpret_as_int())\n}\n\n///|\npub fn Env::has_func(env : Env, idx : FuncIdx) -> Bool {\n  let FuncIdx(i) = idx\n  i < env.funcs.length().reinterpret_as_uint()\n}\n\n///|\npub fn Env::resolve_struct_fields(\n  env : Env,\n  x : TypeIdx,\n) -> Result[Array[FieldType], String] {\n  match env.resolve_comptype(x) {\n    None => Err(\"unknown type index\")\n    Some(ct) =>\n      match ct {\n        StructCompType(fs) => Ok(fs)\n        _ => Err(\"type is not a struct\")\n      }\n  }\n}\n\n///|\npub fn Env::has_data(env : Env, idx : DataIdx) -> Bool {\n  let DataIdx(i) = idx\n  i < env.datas.length().reinterpret_as_uint()\n}\n\n///|\npub fn Env::resolve_array_field(\n  env : Env,\n  x : TypeIdx,\n) -> Result[FieldType, String] {\n  match env.resolve_comptype(x) {\n    None => Err(\"unknown type index\")\n    Some(ct) =>\n      match ct {\n        ArrayCompType(ft) => Ok(ft)\n        _ => Err(\"type is not an array\")\n      }\n  }\n}\n\n///|\npub fn Env::push_tag(env : Env, t : TagType) -> Env {\n  let tags = env.tags.copy()\n  tags.push(t)\n  Env::{ ..env, tags, }\n}\n\n///|\npub fn Env::push_global(env : Env, gt : GlobalType) -> Env {\n  let globals = env.globals.copy()\n  globals.push(gt)\n  Env::{ ..env, globals, }\n}\n\n///|\npub fn Env::push_func(env : Env, ft : FuncType) -> Env {\n  let funcs = env.funcs.copy()\n  funcs.push(ft)\n  Env::{ ..env, funcs, }\n}\n\n///|\npub fn Env::push_mem(env : Env, mt : MemType) -> Env {\n  let mems = env.mems.copy()\n  mems.push(mt)\n  Env::{ ..env, mems, }\n}\n\n///|\npub fn Env::push_table(env : Env, tt : TableType) -> Env {\n  let tables = env.tables.copy()\n  tables.push(tt)\n  Env::{ ..env, tables, }\n}\n\n///|\npub fn Env::with_locals(env : Env, locals : Array[ValType]) -> Env {\n  Env::{ ..env, locals, }\n}\n\n///|\npub fn Env::with_funcs(env : Env, funcs : Array[FuncType]) -> Env {\n  Env::{ ..env, funcs, }\n}\n\n///|\npub fn Env::with_types(env : Env, global_types : Array[SubType]) -> Env {\n  Env::{ ..env, global_types, }\n}\n\n///|\npub fn Env::with_tables(env : Env, tables : Array[TableType]) -> Env {\n  Env::{ ..env, tables, }\n}\n\n///|\npub fn Env::with_globals(env : Env, globals : Array[GlobalType]) -> Env {\n  Env::{ ..env, globals, }\n}\n\n///|\npub fn Env::with_mems(env : Env, mems : Array[MemType]) -> Env {\n  Env::{ ..env, mems, }\n}\n\n///|\npub fn Env::with_tags(env : Env, tags : Array[TagType]) -> Env {\n  Env::{ ..env, tags, }\n}\n\n///|\npub fn Env::push_data(env : Env, d : Data) -> Env {\n  let datas = env.datas.copy()\n  datas.push(d)\n  Env::{ ..env, datas, }\n}\n\n///|\npub fn Env::push_elem(env : Env, e : Elem) -> Env {\n  let elems = env.elems.copy()\n  elems.push(e)\n  Env::{ ..env, elems, }\n}\n\n///|\npub fn Env::with_elems(env : Env, elems : Array[Elem]) -> Env {\n  Env::{ ..env, elems, }\n}\n","///|\npub impl Eq for Module with equal(l, r) {\n  let l_custom = l.0\n  let r_custom = r.0\n  if l_custom.length() != r_custom.length() {\n    return false\n  }\n  for lc in l_custom {\n    if !r_custom.contains(lc) {\n      return false\n    }\n  }\n  for rc in r_custom {\n    if !l_custom.contains(rc) {\n      return false\n    }\n  }\n  l.1 == r.1 &&\n  l.2 == r.2 &&\n  l.3 == r.3 &&\n  l.4 == r.4 &&\n  l.5 == r.5 &&\n  l.6 == r.6 &&\n  l.7 == r.7 &&\n  l.8 == r.8 &&\n  l.9 == r.9 &&\n  l.10 == r.10 &&\n  l.11 == r.11 &&\n  l.12 == r.12 &&\n  l.13 == r.13\n}\n\n///|\npub impl Eq for RecType with equal(l, r) {\n  match (l, r) {\n    (SingleRecType(stl), GroupRecType([str])) => stl == str\n    (GroupRecType([stl]), SingleRecType(str)) => stl == str\n    (SingleRecType(stl), SingleRecType(str)) => stl == str\n    (GroupRecType(stl), GroupRecType(str)) => stl == str\n    _ => false\n  }\n}\n\n///|\npub impl Eq for RefType with equal(l, r) {\n  match (l, r) {\n    (HeapTypeRefType(l0, l1), HeapTypeRefType(r0, r1)) => l0 == r0 && l1 == r1\n    (AbsHeapTypeRefType(l0), AbsHeapTypeRefType(r0)) => l0 == r0\n    (AbsHeapTypeRefType(l0), HeapTypeRefType(true, AbsHeapTypeHeapType(r0))) =>\n      l0 == r0\n    (HeapTypeRefType(true, AbsHeapTypeHeapType(l0)), AbsHeapTypeRefType(r0)) =>\n      l0 == r0\n    _ => false\n  }\n}\n\n///|\npub impl Eq for MemArg with equal(l, r) {\n  l.0 == r.0 &&\n  l.1.unwrap_or(MemIdx(0)) == r.1.unwrap_or(MemIdx(0)) &&\n  l.2 == r.2\n}\n\n///|\ntest \"RecType equality edge cases\" {\n  let st = CompTypeSubType(FuncCompType([], []))\n\n  // SingleRecType should equal GroupRecType with single element\n  assert_eq(SingleRecType(st), GroupRecType([st]))\n  assert_eq(GroupRecType([st]), SingleRecType(st))\n\n  // But different subtypes should not be equal\n  let st2 = CompTypeSubType(FuncCompType([NumTypeValType(I32NumType)], []))\n  assert_not_eq(SingleRecType(st), SingleRecType(st2))\n  assert_not_eq(SingleRecType(st), GroupRecType([st2]))\n\n  // Multiple elements should not equal single\n  assert_not_eq(GroupRecType([st, st]), SingleRecType(st))\n}\n\n///|\ntest \"RefType equality edge cases\" {\n  // AbsHeapTypeRefType should equal HeapTypeRefType with nullable + AbsHeapTypeHeapType\n  assert_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n  )\n  assert_eq(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)),\n    AbsHeapTypeRefType(ExternAbsHeapType),\n  )\n\n  // Non-nullable should NOT equal AbsHeapTypeRefType\n  assert_not_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    HeapTypeRefType(false, AbsHeapTypeHeapType(FuncAbsHeapType)),\n  )\n\n  // Different heap types should not be equal\n  assert_not_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    AbsHeapTypeRefType(ExternAbsHeapType),\n  )\n  assert_not_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)),\n  )\n}\n\n///|\ntest \"MemArg equality edge cases\" {\n  // None memidx should equal Some(MemIdx(0))\n  assert_eq(\n    MemArg(U32(0), None, U64(0)),\n    MemArg(U32(0), Some(MemIdx(0)), U64(0)),\n  )\n  assert_eq(\n    MemArg(U32(4), None, U64(8)),\n    MemArg(U32(4), Some(MemIdx(0)), U64(8)),\n  )\n\n  // But Some(MemIdx(1)) should NOT equal None\n  assert_not_eq(\n    MemArg(U32(0), None, U64(0)),\n    MemArg(U32(0), Some(MemIdx(1)), U64(0)),\n  )\n\n  // Different align/offset should not be equal\n  assert_not_eq(MemArg(U32(0), None, U64(0)), MemArg(U32(1), None, U64(0)))\n  assert_not_eq(MemArg(U32(0), None, U64(0)), MemArg(U32(0), None, U64(1)))\n}\n\n///|\ntest \"HeapType equality - verify transformer changes are detected\" {\n  // These should NOT be equal - this is what HeapTypeSwap produces\n  let before : HeapType = AbsHeapTypeHeapType(FuncAbsHeapType)\n  let after : HeapType = AbsHeapTypeHeapType(ExternAbsHeapType)\n  assert_not_eq(before, after)\n\n  // TypeIdx changes should be detected\n  let idx_before : HeapType = HeapType(TypeIdx(0))\n  let idx_after : HeapType = HeapType(TypeIdx(1000))\n  assert_not_eq(idx_before, idx_after)\n}\n\n///|\ntest \"RefType with transformed HeapType should not be equal\" {\n  // The transformer changes HeapType inside RefType\n  let before = HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  let after = HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType))\n  assert_not_eq(before, after)\n\n  // But AbsHeapTypeRefType doesn't contain HeapType - verify these are different\n  let abs_func = AbsHeapTypeRefType(FuncAbsHeapType)\n  let abs_extern = AbsHeapTypeRefType(ExternAbsHeapType)\n  assert_not_eq(abs_func, abs_extern)\n}\n","///|\npub impl Show for S33 with output(self, logger) {\n  let S33(t) = self\n  logger.write_string(\"S33(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for I32 with output(self, logger) {\n  let I32(t) = self\n  logger.write_string(\"I32(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for I64 with output(self, logger) {\n  let I64(t) = self\n  logger.write_string(\"I64(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for F32 with output(self, logger) {\n  let F32(t) = self\n  logger.write_string(\"F32(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for F64 with output(self, logger) {\n  let F64(t) = self\n  logger.write_string(\"F64(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for U32 with output(self, logger) {\n  let U32(t) = self\n  logger.write_string(\"U32(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for U64 with output(self, logger) {\n  let U64(t) = self\n  logger.write_string(\"U64(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for NumType with output(self, logger) {\n  match self {\n    F32NumType => logger.write_string(\"(NumType F32)\")\n    F64NumType => logger.write_string(\"(NumType F64)\")\n    I32NumType => logger.write_string(\"(NumType I32)\")\n    I64NumType => logger.write_string(\"(NumType I64)\")\n  }\n}\n\n///|\npub impl Show for AbsHeapType with output(self, logger) {\n  match self {\n    ExnAbsHeapType => logger.write_string(\"(AbsHeapType Exn)\")\n    ArrayAbsHeapType => logger.write_string(\"(AbsHeapType Array)\")\n    StructAbsHeapType => logger.write_string(\"(AbsHeapType Struct)\")\n    I31AbsHeapType => logger.write_string(\"(AbsHeapType I31)\")\n    EqAbsHeapType => logger.write_string(\"(AbsHeapType Eq)\")\n    AnyAbsHeapType => logger.write_string(\"(AbsHeapType Any)\")\n    ExternAbsHeapType => logger.write_string(\"(AbsHeapType Extern)\")\n    FuncAbsHeapType => logger.write_string(\"(AbsHeapType Func)\")\n    NoneAbsHeapType => logger.write_string(\"(AbsHeapType None)\")\n    NoExternAbsHeapType => logger.write_string(\"(AbsHeapType NoExtern)\")\n    NoFuncAbsHeapType => logger.write_string(\"(AbsHeapType NoFunc)\")\n    NoExnAbsHeapType => logger.write_string(\"(AbsHeapType NoExn)\")\n  }\n}\n\n///|\npub impl Show for HeapType with output(self, logger) {\n  match self {\n    AbsHeapTypeHeapType(ht) => {\n      logger.write_string(\"(HeapType \")\n      ht.output(logger)\n      logger.write_char(')')\n    }\n    HeapType(TypeIdx(t)) => {\n      logger.write_string(\"(HeapType Idx \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    HeapType(RecIdx(t)) => {\n      logger.write_string(\"(HeapType Rec \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    DefTypeHeapType(d) => {\n      logger.write_string(\"(HeapType \")\n      d.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for DefType with output(self, logger) {\n  logger.write_string(\"(DefType \")\n  self.0.output(logger)\n  logger.write_char(' ')\n  self.1.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for RefType with output(self, logger) {\n  match self {\n    HeapTypeRefType(n, ht) => {\n      logger.write_string(\"(RefType \")\n      if !n {\n        logger.write_string(\"Not \")\n      }\n      logger.write_string(\"Null \")\n      ht.output(logger)\n      logger.write_char(')')\n    }\n    AbsHeapTypeRefType(aht) => {\n      logger.write_string(\"(RefType Null \")\n      aht.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for ValType with output(self, logger) {\n  match self {\n    VecTypeValType => logger.write_string(\"(V128)\")\n    NumTypeValType(nt) => nt.output(logger)\n    RefTypeValType(rt) => rt.output(logger)\n    BotValType => logger.write_string(\"(Bot)\")\n  }\n}\n\n///|\npub impl Show for PackType with output(self, logger) {\n  match self {\n    I16PackType => logger.write_string(\"(I16)\")\n    I8PackType => logger.write_string(\"(I8)\")\n  }\n}\n\n///|\npub impl Show for StorageType with output(self, logger) {\n  match self {\n    ValTypeStorageType(vt) => vt.output(logger)\n    PackTypeStorageType(pt) => pt.output(logger)\n  }\n}\n\n///|\npub impl Show for FieldType with output(self, logger) {\n  let FieldType(st, m) = self\n  logger.write_string(\"(Field \")\n  m.output(logger)\n  logger.write_char(' ')\n  st.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Mut with output(self, logger) {\n  match self {\n    Var => logger.write_string(\"Mut\")\n    Const => logger.write_string(\"Const\")\n  }\n}\n\n///|\npub impl Show for TypeIdx with output(self, logger) {\n  match self {\n    TypeIdx(val) => {\n      logger.write_string(\"(Type \")\n      val.output(logger)\n      logger.write_char(')')\n    }\n    RecIdx(i) => {\n      logger.write_string(\"(Rec \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for FuncIdx with output(self, logger) {\n  let FuncIdx(val) = self\n  logger.write_string(\"(Func \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for TableIdx with output(self, logger) {\n  let TableIdx(val) = self\n  logger.write_string(\"(Table \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for MemIdx with output(self, logger) {\n  let MemIdx(val) = self\n  logger.write_string(\"(Mem \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for GlobalIdx with output(self, logger) {\n  let GlobalIdx(val) = self\n  logger.write_string(\"(Global \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for TagIdx with output(self, logger) {\n  let TagIdx(val) = self\n  logger.write_string(\"(Tag \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for ElemIdx with output(self, logger) {\n  let ElemIdx(val) = self\n  logger.write_string(\"(Elem \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for DataIdx with output(self, logger) {\n  let DataIdx(val) = self\n  logger.write_string(\"(Data \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for LocalIdx with output(self, logger) {\n  let LocalIdx(val) = self\n  logger.write_string(\"(Local \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for LabelIdx with output(self, logger) {\n  let LabelIdx(val) = self\n  logger.write_string(\"(Label \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for LaneIdx with output(self, logger) {\n  let LaneIdx(val) = self\n  logger.write_string(\"(Lane \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for CompType with output(self, logger) {\n  match self {\n    StructCompType(st) => {\n      logger.write_string(\"(Struct \")\n      for f in st {\n        f.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n    ArrayCompType(at) => {\n      logger.write_string(\"(Array \")\n      at.output(logger)\n      logger.write_char(')')\n    }\n    FuncCompType(p, r) => {\n      logger.write_string(\"(Func (Props \")\n      match p {\n        [] => logger.write_string(\"(Void)\")\n        _ =>\n          for pm in p {\n            pm.output(logger)\n            logger.write_char(' ')\n          }\n      }\n      logger.write_string(\") (Ret \")\n      match r {\n        [] => logger.write_string(\"(Void)\")\n        _ =>\n          for pm in r {\n            pm.output(logger)\n            logger.write_char(' ')\n          }\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for SubType with output(self, logger) {\n  match self {\n    SubType(f, sts, ct) => {\n      logger.write_string(\"(Sub \")\n      if f {\n        logger.write_string(\"Final \")\n      }\n      for st in sts {\n        st.output(logger)\n        logger.write_char(' ')\n      }\n      ct.output(logger)\n      logger.write_char(')')\n    }\n    CompTypeSubType(ct) => {\n      logger.write_string(\"(Sub Final \")\n      ct.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for RecType with output(self, logger) {\n  match self {\n    SingleRecType(st) => {\n      logger.write_string(\"(Rec \")\n      st.output(logger)\n      logger.write_char(')')\n    }\n    GroupRecType(sts) => {\n      logger.write_string(\"(Rec \")\n      for st in sts {\n        st.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for Limits with output(self, logger) {\n  match self {\n    I32Limits(min, max) => {\n      logger.write_string(\"(Lim I32 \")\n      min.output(logger)\n      if max is Some(max) {\n        logger.write_char(' ')\n        max.output(logger)\n      }\n      logger.write_char(')')\n    }\n    I64Limits(min, max) => {\n      logger.write_string(\"(Lim I64 \")\n      min.output(logger)\n      if max is Some(max) {\n        logger.write_char(' ')\n        max.output(logger)\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for TagType with output(self, logger) {\n  let TagType(t) = self\n  t.output(logger)\n}\n\n///|\npub impl Show for GlobalType with output(self, logger) {\n  let GlobalType(vt, m) = self\n  logger.write_string(\"(GlobalType \")\n  if m {\n    logger.write_string(\"Mut \")\n  }\n  vt.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for MemType with output(self, logger) {\n  let MemType(l) = self\n  l.output(logger)\n}\n\n///|\npub impl Show for TableType with output(self, logger) {\n  let TableType(rt, l) = self\n  logger.write_string(\"(TableType \")\n  rt.output(logger)\n  logger.write_char(' ')\n  l.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for ExternType with output(self, logger) {\n  match self {\n    GlobalExternType(gt) => gt.output(logger)\n    MemExternType(mt) => mt.output(logger)\n    TableExternType(tt) => tt.output(logger)\n    FuncExternType(t) => t.output(logger)\n    TagExternType(t) => t.output(logger)\n  }\n}\n\n///|\npub impl Show for ExternIdx with output(self, logger) {\n  match self {\n    GlobalExternIdx(g) => g.output(logger)\n    MemExternIdx(m) => m.output(logger)\n    TableExternIdx(t) => t.output(logger)\n    FuncExternIdx(f) => f.output(logger)\n    TagExternIdx(t) => t.output(logger)\n  }\n}\n\n///|\npub impl Show for ElemMode with output(self, logger) {\n  match self {\n    Active(t, e) => {\n      logger.write_string(\"(Active \")\n      t.output(logger)\n      logger.write_char(' ')\n      e.output(logger)\n      logger.write_char(')')\n    }\n    Passive => logger.write_string(\"Passive\")\n    Declarative => logger.write_string(\"Declarative\")\n  }\n}\n\n///|\npub impl Show for ElemKind with output(self, logger) {\n  match self {\n    FuncExprsElemKind(exprs) => {\n      logger.write_string(\"(Funcs \")\n      for expr in exprs {\n        expr.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n    FuncsElemKind(idxs) => {\n      logger.write_string(\"(Funcs Indexes \")\n      for idx in idxs {\n        idx.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n    TypedExprsElemKind(rt, exprs) => {\n      logger.write_string(\"(Exprs \")\n      rt.output(logger)\n      logger.write_char(' ')\n      for expr in exprs {\n        expr.output(logger)\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for Elem with output(self, logger) {\n  let Elem(m, k) = self\n  logger.write_string(\"(Elem \")\n  m.output(logger)\n  logger.write_char(' ')\n  k.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Expr with output(self, logger) {\n  let Expr(insts) = self\n  for inst in insts {\n    inst.output(logger)\n  }\n  logger.write_string(\"(end)\")\n}\n\n///|\npub impl Show for Import with output(self, logger) {\n  let Import(ns, n, et) = self\n  logger.write_char('(')\n  ns.output(logger)\n  logger.write_char(' ')\n  n.output(logger)\n  logger.write_char(' ')\n  et.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Table with output(self, logger) {\n  let Table(tt, e) = self\n  logger.write_string(\"(Table \")\n  tt.output(logger)\n  if e is Some(e) {\n    logger.write_char(' ')\n    e.output(logger)\n  }\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Global with output(self, logger) {\n  let Global(gt, e) = self\n  logger.write_string(\"(Global \")\n  gt.output(logger)\n  logger.write_char(' ')\n  e.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Export with output(self, logger) {\n  let Export(n, idx) = self\n  logger.write_string(\"(Export \")\n  n.output(logger)\n  logger.write_char(' ')\n  idx.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Locals with output(self, logger) {\n  let Locals(i, vt) = self\n  loop i {\n    0 => break\n    n => {\n      vt.output(logger)\n      logger.write_char(' ')\n      continue n - 1\n    }\n  }\n}\n\n///|\npub impl Show for Func with output(self, logger) {\n  match self {\n    Func(ls, expr) => {\n      logger.write_string(\"(Func \")\n      ls.output(logger)\n      logger.write_char(' ')\n      expr.output(logger)\n      logger.write_char(')')\n    }\n    TFunc(ls, texpr) => {\n      logger.write_string(\"(Func \")\n      ls.output(logger)\n      logger.write_char(' ')\n      texpr.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for DataMode with output(self, logger) {\n  match self {\n    Active(m, e) => {\n      logger.write_string(\"(Active \")\n      m.output(logger)\n      logger.write_char(' ')\n      e.output(logger)\n      logger.write_char(')')\n    }\n    Passive => logger.write_string(\"Passive\")\n  }\n}\n\n///|\npub impl Show for Data with output(self, logger) {\n  let Data(dm, b) = self\n  logger.write_string(\"(Data \")\n  dm.output(logger)\n  logger.write_char(' ')\n  b.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Name with output(self, logger) {\n  let Name(sv) = self\n  logger.write_char('\"')\n  sv.to_string().output(logger)\n  logger.write_char('\"')\n}\n\n///|\npub impl Show for BlockType with output(self, logger) {\n  match self {\n    ValTypeBlockType(vt) => vt.output(logger)\n    EmptyBlockType => logger.write_string(\"(Void)\")\n    TypeIdxBlockType(t) => t.output(logger)\n  }\n}\n\n///|\npub impl Show for Catch with output(self, logger) {\n  match self {\n    CatchAll(l) => {\n      logger.write_string(\"(catch_all \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    CatchRef(t, l) => {\n      logger.write_string(\"(catch_ref \")\n      t.output(logger)\n      logger.write_char(' ')\n      l.output(logger)\n      logger.write_char(')')\n    }\n    Catch(t, l) => {\n      logger.write_string(\"(catch \")\n      t.output(logger)\n      logger.write_char(' ')\n      l.output(logger)\n      logger.write_char(')')\n    }\n    CatchAllRef(l) => {\n      logger.write_string(\"(catch_all_ref \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for MemArg with output(self, logger) {\n  let MemArg(a, m, o) = self\n  logger.write_string(\"align=\")\n  a.output(logger)\n  if m is Some(m) {\n    logger.write_string(\" mem=\")\n    m.output(logger)\n  }\n  logger.write_string(\" offset=\")\n  o.output(logger)\n}\n\n///|\npub impl Show for Instruction with output(self, logger) {\n  match self {\n    Unreachable => logger.write_string(\"unreachable\")\n    Nop => logger.write_string(\"nop\")\n    Block(bt, expr) => {\n      logger.write_string(\"(block \")\n      bt.output(logger)\n      logger.write_char(' ')\n      expr.output(logger)\n      logger.write_char(')')\n    }\n    Loop(bt, expr) => {\n      logger.write_string(\"(loop \")\n      bt.output(logger)\n      logger.write_char(' ')\n      expr.output(logger)\n      logger.write_char(')')\n    }\n    If(bt, i, e) => {\n      logger.write_string(\"(if \")\n      bt.output(logger)\n      logger.write_char(' ')\n      for n in i {\n        n.output(logger)\n        logger.write_char(' ')\n      }\n      if e is Some(e) {\n        logger.write_string(\"else \")\n        for n in e {\n          n.output(logger)\n          logger.write_char(' ')\n        }\n        logger.write_char(')')\n      }\n    }\n    Throw(t) => {\n      logger.write_string(\"(throw \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    ThrowRef => logger.write_string(\"throw_ref\")\n    Br(l) => {\n      logger.write_string(\"(br \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    BrIf(l) => {\n      logger.write_string(\"(br_if \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    BrTable(ls, l) => {\n      logger.write_string(\"(br_table \")\n      for n in ls {\n        n.output(logger)\n        logger.write_char(' ')\n      }\n      l.output(logger)\n      logger.write_char(')')\n    }\n    Return => logger.write_string(\"return\")\n    Call(f) => {\n      logger.write_string(\"(call \")\n      f.output(logger)\n      logger.write_char(')')\n    }\n    CallIndirect(ty, tbl) => {\n      logger.write_string(\"(call_indirect \")\n      ty.output(logger)\n      logger.write_char(' ')\n      tbl.output(logger)\n      logger.write_char(')')\n    }\n    ReturnCall(f) => {\n      logger.write_string(\"(return_call \")\n      f.output(logger)\n      logger.write_char(')')\n    }\n    ReturnCallIndirect(ty, tbl) => {\n      logger.write_string(\"(return_call_indirect \")\n      ty.output(logger)\n      logger.write_char(' ')\n      tbl.output(logger)\n      logger.write_char(')')\n    }\n    CallRef(t) => {\n      logger.write_string(\"(call_ref \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    ReturnCallRef(t) => {\n      logger.write_string(\"(return_call_ref \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    Drop => logger.write_string(\"drop\")\n    Select(None) => logger.write_string(\"select\")\n    Select(Some(vts)) => {\n      logger.write_string(\"(select\")\n      for vt in vts {\n        logger.write_char(' ')\n        vt.output(logger)\n      }\n      logger.write_char(')')\n    }\n    TryTable(bt, c, e) => {\n      logger.write_string(\"(try_table \")\n      bt.output(logger)\n      logger.write_char(' ')\n      c.output(logger)\n      logger.write_char(' ')\n      e.output(logger)\n      logger.write_char(')')\n    }\n    LocalGet(l) => {\n      logger.write_string(\"(local.get \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    LocalSet(l) => {\n      logger.write_string(\"(local.set \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    LocalTee(l) => {\n      logger.write_string(\"(local.tee \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    GlobalGet(g) => {\n      logger.write_string(\"(global.get \")\n      g.output(logger)\n      logger.write_char(')')\n    }\n    GlobalSet(g) => {\n      logger.write_string(\"(global.set \")\n      g.output(logger)\n      logger.write_char(')')\n    }\n    TableGet(t) => {\n      logger.write_string(\"(table.get \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    TableSet(t) => {\n      logger.write_string(\"(table.set \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    I32Load(m) => {\n      logger.write_string(\"(i32.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load(m) => {\n      logger.write_string(\"(i64.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F32Load(m) => {\n      logger.write_string(\"(f32.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F64Load(m) => {\n      logger.write_string(\"(f64.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load8S(m) => {\n      logger.write_string(\"(i32.load8s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load8U(m) => {\n      logger.write_string(\"(i32.load8u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load16S(m) => {\n      logger.write_string(\"(i32.load16s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load16U(m) => {\n      logger.write_string(\"(i32.load16u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load8S(m) => {\n      logger.write_string(\"(i64.load8s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load8U(m) => {\n      logger.write_string(\"(i64.load8u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load16S(m) => {\n      logger.write_string(\"(i64.load16s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load16U(m) => {\n      logger.write_string(\"(i64.load16u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load32S(m) => {\n      logger.write_string(\"(i64.load32s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load32U(m) => {\n      logger.write_string(\"(i64.load32u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Store(m) => {\n      logger.write_string(\"(i32.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store(m) => {\n      logger.write_string(\"(i64.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F32Store(m) => {\n      logger.write_string(\"(f32.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F64Store(m) => {\n      logger.write_string(\"(f64.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Store8(m) => {\n      logger.write_string(\"(i32.store8 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Store16(m) => {\n      logger.write_string(\"(i32.store16 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store8(m) => {\n      logger.write_string(\"(i64.store8 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store16(m) => {\n      logger.write_string(\"(i64.store16 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store32(m) => {\n      logger.write_string(\"(i64.store32 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    MemorySize(m) => {\n      logger.write_string(\"(memory.size \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    MemoryGrow(m) => {\n      logger.write_string(\"(memory.grow \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Const(c) => {\n      logger.write_string(\"(i32.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    I64Const(c) => {\n      logger.write_string(\"(i64.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    F32Const(c) => {\n      logger.write_string(\"(f32.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    F64Const(c) => {\n      logger.write_string(\"(f64.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    I32Eqz => logger.write_string(\"i32.eqz\")\n    I32Eq => logger.write_string(\"i32.eq\")\n    I32Ne => logger.write_string(\"i32.ne\")\n    I32LtS => logger.write_string(\"i32.lt_s\")\n    I32LtU => logger.write_string(\"i32.lt_u\")\n    I32GtS => logger.write_string(\"i32.gt_s\")\n    I32GtU => logger.write_string(\"i32.gt_u\")\n    I32LeS => logger.write_string(\"i32.le_s\")\n    I32LeU => logger.write_string(\"i32.le_u\")\n    I32GeS => logger.write_string(\"i32.ge_s\")\n    I32GeU => logger.write_string(\"i32.ge_u\")\n    I64Eqz => logger.write_string(\"i64.eqz\")\n    I64Eq => logger.write_string(\"i64.eq\")\n    I64Ne => logger.write_string(\"i64.ne\")\n    I64LtS => logger.write_string(\"i64.lt_s\")\n    I64LtU => logger.write_string(\"i64.lt_u\")\n    I64GtS => logger.write_string(\"i64.gt_s\")\n    I64GtU => logger.write_string(\"i64.gt_u\")\n    I64LeS => logger.write_string(\"i64.le_s\")\n    I64LeU => logger.write_string(\"i64.le_u\")\n    I64GeS => logger.write_string(\"i64.ge_s\")\n    I64GeU => logger.write_string(\"i64.ge_u\")\n    F32Eq => logger.write_string(\"f32.eq\")\n    F32Ne => logger.write_string(\"f32.ne\")\n    F32Lt => logger.write_string(\"f32.lt\")\n    F32Gt => logger.write_string(\"f32.gt\")\n    F32Le => logger.write_string(\"f32.le\")\n    F32Ge => logger.write_string(\"f32.ge\")\n    F64Eq => logger.write_string(\"f64.eq\")\n    F64Ne => logger.write_string(\"f64.ne\")\n    F64Lt => logger.write_string(\"f64.lt\")\n    F64Gt => logger.write_string(\"f64.gt\")\n    F64Le => logger.write_string(\"f64.le\")\n    F64Ge => logger.write_string(\"f64.ge\")\n    I32Clz => logger.write_string(\"i32.clz\")\n    I32Ctz => logger.write_string(\"i32.ctz\")\n    I32Popcnt => logger.write_string(\"i32.popcnt\")\n    I32Add => logger.write_string(\"i32.add\")\n    I32Sub => logger.write_string(\"i32.sub\")\n    I32Mul => logger.write_string(\"i32.mul\")\n    I32DivS => logger.write_string(\"i32.div_s\")\n    I32DivU => logger.write_string(\"i32.div_u\")\n    I32RemS => logger.write_string(\"i32.rem_s\")\n    I32RemU => logger.write_string(\"i32.rem_u\")\n    I32And => logger.write_string(\"i32.and\")\n    I32Or => logger.write_string(\"i32.or\")\n    I32Xor => logger.write_string(\"i32.xor\")\n    I32Shl => logger.write_string(\"i32.shl\")\n    I32ShrS => logger.write_string(\"i32.shr_s\")\n    I32ShrU => logger.write_string(\"i32.shr_u\")\n    I32Rotl => logger.write_string(\"i32.rotl\")\n    I32Rotr => logger.write_string(\"i32.rotr\")\n    I64Clz => logger.write_string(\"i64.clz\")\n    I64Ctz => logger.write_string(\"i64.ctz\")\n    I64Popcnt => logger.write_string(\"i64.popcnt\")\n    I64Add => logger.write_string(\"i64.add\")\n    I64Sub => logger.write_string(\"i64.sub\")\n    I64Mul => logger.write_string(\"i64.mul\")\n    I64DivS => logger.write_string(\"i64.div_s\")\n    I64DivU => logger.write_string(\"i64.div_u\")\n    I64RemS => logger.write_string(\"i64.rem_s\")\n    I64RemU => logger.write_string(\"i64.rem_u\")\n    I64And => logger.write_string(\"i64.and\")\n    I64Or => logger.write_string(\"i64.or\")\n    I64Xor => logger.write_string(\"i64.xor\")\n    I64Shl => logger.write_string(\"i64.shl\")\n    I64ShrS => logger.write_string(\"i64.shr_s\")\n    I64ShrU => logger.write_string(\"i64.shr_u\")\n    I64Rotl => logger.write_string(\"i64.rotl\")\n    I64Rotr => logger.write_string(\"i64.rotr\")\n    F32Abs => logger.write_string(\"f32.abs\")\n    F32Neg => logger.write_string(\"f32.neg\")\n    F32Ceil => logger.write_string(\"f32.ceil\")\n    F32Floor => logger.write_string(\"f32.floor\")\n    F32Trunc => logger.write_string(\"f32.trunc\")\n    F32Nearest => logger.write_string(\"f32.nearest\")\n    F32Sqrt => logger.write_string(\"f32.sqrt\")\n    F32Add => logger.write_string(\"f32.add\")\n    F32Sub => logger.write_string(\"f32.sub\")\n    F32Mul => logger.write_string(\"f32.mul\")\n    F32Div => logger.write_string(\"f32.div\")\n    F32Min => logger.write_string(\"f32.min\")\n    F32Max => logger.write_string(\"f32.max\")\n    F32Copysign => logger.write_string(\"f32.copysign\")\n    F64Abs => logger.write_string(\"f64.abs\")\n    F64Neg => logger.write_string(\"f64.neg\")\n    F64Ceil => logger.write_string(\"f64.ceil\")\n    F64Floor => logger.write_string(\"f64.floor\")\n    F64Trunc => logger.write_string(\"f64.trunc\")\n    F64Nearest => logger.write_string(\"f64.nearest\")\n    F64Sqrt => logger.write_string(\"f64.sqrt\")\n    F64Add => logger.write_string(\"f64.add\")\n    F64Sub => logger.write_string(\"f64.sub\")\n    F64Mul => logger.write_string(\"f64.mul\")\n    F64Div => logger.write_string(\"f64.div\")\n    F64Min => logger.write_string(\"f64.min\")\n    F64Max => logger.write_string(\"f64.max\")\n    F64Copysign => logger.write_string(\"f64.copysign\")\n    I32WrapI64 => logger.write_string(\"i32.wrap_i64\")\n    I32TruncF32S => logger.write_string(\"i32.trunc_f32s\")\n    I32TruncF32U => logger.write_string(\"i32.trunc_f32u\")\n    I32TruncF64S => logger.write_string(\"i32.trunc_f64s\")\n    I32TruncF64U => logger.write_string(\"i32.trunc_f64u\")\n    I64ExtendI32S => logger.write_string(\"i64.extend_i32s\")\n    I64ExtendI32U => logger.write_string(\"i64.extend_i32u\")\n    I64TruncF32S => logger.write_string(\"i64.trunc_f32s\")\n    I64TruncF32U => logger.write_string(\"i64.trunc_f32u\")\n    I64TruncF64S => logger.write_string(\"i64.trunc_f64s\")\n    I64TruncF64U => logger.write_string(\"i64.trunc_f64u\")\n    F32ConvertI32S => logger.write_string(\"f32.convert_i32s\")\n    F32ConvertI32U => logger.write_string(\"f32.convert_i32u\")\n    F32ConvertI64S => logger.write_string(\"f32.convert_i64s\")\n    F32ConvertI64U => logger.write_string(\"f32.convert_i64u\")\n    F32DemoteF64 => logger.write_string(\"f32.demote_f64\")\n    F64ConvertI32S => logger.write_string(\"f64.convert_i32s\")\n    F64ConvertI32U => logger.write_string(\"f64.convert_i32u\")\n    F64ConvertI64S => logger.write_string(\"f64.convert_i64s\")\n    F64ConvertI64U => logger.write_string(\"f64.convert_i64u\")\n    F64PromoteF32 => logger.write_string(\"f64.promote_f32\")\n    I32ReinterpretF32 => logger.write_string(\"i32.reinterpret_f32\")\n    I64ReinterpretF64 => logger.write_string(\"i64.reinterpret_f64\")\n    F32ReinterpretI32 => logger.write_string(\"f32.reinterpret_i32\")\n    F64ReinterpretI64 => logger.write_string(\"f64.reinterpret_i64\")\n    I32Extend8S => logger.write_string(\"i32.extend8s\")\n    I32Extend16S => logger.write_string(\"i32.extend16s\")\n    I64Extend8S => logger.write_string(\"i64.extend8s\")\n    I64Extend16S => logger.write_string(\"i64.extend16s\")\n    I64Extend32S => logger.write_string(\"i64.extend32s\")\n    RefNull(ht) => {\n      logger.write_string(\"(ref.null \")\n      ht.output(logger)\n      logger.write_char(')')\n    }\n    RefIsNull => logger.write_string(\"ref.null\")\n    RefFunc(i) => {\n      logger.write_string(\"(ref.func \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    RefEq => logger.write_string(\"ref.eq\")\n    RefAsNonNull => logger.write_string(\"ref.as_non_null\")\n    BrOnNull(l) => {\n      logger.write_string(\"(br_on_null \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    BrOnNonNull(l) => {\n      logger.write_string(\"(br_on_non_null \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    StructNew(i) => {\n      logger.write_string(\"(struct.new \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructNewDefault(i) => {\n      logger.write_string(\"(struct.new_default \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructGet(t, i) => {\n      logger.write_string(\"(struct.get \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructGetS(t, i) => {\n      logger.write_string(\"(struct.get_s \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructGetU(t, i) => {\n      logger.write_string(\"(struct.get_u \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructSet(t, i) => {\n      logger.write_string(\"(struct.set \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNew(i) => {\n      logger.write_string(\"(array.new \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewDefault(i) => {\n      logger.write_string(\"(array.new_default \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewFixed(i, n) => {\n      logger.write_string(\"(array.new_fixed \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewData(i, n) => {\n      logger.write_string(\"(array.new_data \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewElem(i, n) => {\n      logger.write_string(\"(array.new_elem \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayGet(i) => {\n      logger.write_string(\"(array.get \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayGetS(i) => {\n      logger.write_string(\"(array.get_s \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayGetU(i) => {\n      logger.write_string(\"(array.get_u \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArraySet(i) => {\n      logger.write_string(\"(array.set \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayLen => logger.write_string(\"array.len\")\n    ArrayFill(i) => {\n      logger.write_string(\"(array.fill \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayCopy(i, n) => {\n      logger.write_string(\"(array.copy \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayInitData(i, n) => {\n      logger.write_string(\"(array.init_data \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayInitElem(i, n) => {\n      logger.write_string(\"(array.init_elem \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    RefTest(n, ht) => {\n      logger.write_string(\"(ref.test \")\n      HeapTypeRefType(n, ht).output(logger)\n      logger.write_char(')')\n    }\n    RefCast(n, ht) => {\n      logger.write_string(\"(ref.cast \")\n      HeapTypeRefType(n, ht).output(logger)\n      logger.write_char(')')\n    }\n    BrOnCast(i, CastOp(l, r), lht, rht) => {\n      logger.write_string(\"(br_on_cast \")\n      i.output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(l, lht).output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(r, rht).output(logger)\n      logger.write_char(')')\n    }\n    BrOnCastFail(i, CastOp(l, r), lht, rht) => {\n      logger.write_string(\"(br_on_cast_fail \")\n      i.output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(l, lht).output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(r, rht).output(logger)\n      logger.write_char(')')\n    }\n    AnyConvertExtern => logger.write_string(\"any.convert_extern\")\n    ExternConvertAny => logger.write_string(\"extern.convert_any\")\n    RefI31 => logger.write_string(\"ref.i31\")\n    I31GetS => logger.write_string(\"i31.get_s\")\n    I31GetU => logger.write_string(\"i31.get_u\")\n    I32TruncSatF32S => logger.write_string(\"i32.trunc_sat_f32s\")\n    I32TruncSatF32U => logger.write_string(\"i32.trunc_sat_f32u\")\n    I32TruncSatF64S => logger.write_string(\"i32.trunc_sat_f64s\")\n    I32TruncSatF64U => logger.write_string(\"i32.trunc_sat_f64u\")\n    I64TruncSatF32S => logger.write_string(\"i64.trunc_sat_f32s\")\n    I64TruncSatF32U => logger.write_string(\"i64.trunc_sat_f32u\")\n    I64TruncSatF64S => logger.write_string(\"i64.trunc_sat_f64s\")\n    I64TruncSatF64U => logger.write_string(\"i64.trunc_sat_f64u\")\n    MemoryInit(i, m) => {\n      logger.write_string(\"(memory.init \")\n      i.output(logger)\n      logger.write_char(' ')\n      m.output(logger)\n      logger.write_char(')')\n    }\n    DataDrop(i) => {\n      logger.write_string(\"(data.drop \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    MemoryCopy(i0, i1) => {\n      logger.write_string(\"(memory.copy \")\n      i0.output(logger)\n      logger.write_char(' ')\n      i1.output(logger)\n      logger.write_char(')')\n    }\n    MemoryFill(i) => {\n      logger.write_string(\"(memory.fill \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableInit(i0, i1) => {\n      logger.write_string(\"(table.init \")\n      i0.output(logger)\n      logger.write_char(' ')\n      i1.output(logger)\n      logger.write_char(')')\n    }\n    ElemDrop(i) => {\n      logger.write_string(\"(elem.drop \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableCopy(i0, i1) => {\n      logger.write_string(\"(table.copy \")\n      i0.output(logger)\n      logger.write_char(' ')\n      i1.output(logger)\n      logger.write_char(')')\n    }\n    TableGrow(i) => {\n      logger.write_string(\"(table.grow \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableSize(i) => {\n      logger.write_string(\"(table.size \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableFill(i) => {\n      logger.write_string(\"(table.fill \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load(m) => {\n      logger.write_string(\"(v128.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load8x8S(m) => {\n      logger.write_string(\"(v128.load8x8s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load8x8U(m) => {\n      logger.write_string(\"(v128.load8x8u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16x4S(m) => {\n      logger.write_string(\"(v128.load16x4s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16x4U(m) => {\n      logger.write_string(\"(v128.load16x4u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32x2S(m) => {\n      logger.write_string(\"(v128.load32x2s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32x2U(m) => {\n      logger.write_string(\"(v128.load32x2u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load8Splat(m) => {\n      logger.write_string(\"(v128.load8_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16Splat(m) => {\n      logger.write_string(\"(v128.load16_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32Splat(m) => {\n      logger.write_string(\"(v128.load32_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load64Splat(m) => {\n      logger.write_string(\"(v128.load64_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Store(m) => {\n      logger.write_string(\"(v128.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Const(\n      l0,\n      l1,\n      l2,\n      l3,\n      l4,\n      l5,\n      l6,\n      l7,\n      l8,\n      l9,\n      l10,\n      l11,\n      l12,\n      l13,\n      l14,\n      l15\n    ) => {\n      logger.write_string(\"(v128.const \")\n      l0.to_hex().pad_start(2, '0').output(logger)\n      l1.to_hex().pad_start(2, '0').output(logger)\n      l2.to_hex().pad_start(2, '0').output(logger)\n      l3.to_hex().pad_start(2, '0').output(logger)\n      l4.to_hex().pad_start(2, '0').output(logger)\n      l5.to_hex().pad_start(2, '0').output(logger)\n      l6.to_hex().pad_start(2, '0').output(logger)\n      l7.to_hex().pad_start(2, '0').output(logger)\n      l8.to_hex().pad_start(2, '0').output(logger)\n      l9.to_hex().pad_start(2, '0').output(logger)\n      l10.to_hex().pad_start(2, '0').output(logger)\n      l11.to_hex().pad_start(2, '0').output(logger)\n      l12.to_hex().pad_start(2, '0').output(logger)\n      l13.to_hex().pad_start(2, '0').output(logger)\n      l14.to_hex().pad_start(2, '0').output(logger)\n      l15.to_hex().pad_start(2, '0').output(logger)\n      logger.write_char(')')\n    }\n    I8x16Shuffle(\n      l0,\n      l1,\n      l2,\n      l3,\n      l4,\n      l5,\n      l6,\n      l7,\n      l8,\n      l9,\n      l10,\n      l11,\n      l12,\n      l13,\n      l14,\n      l15\n    ) => {\n      logger.write_string(\"(i8x16.shuffle \")\n      l0.output(logger)\n      logger.write_char(' ')\n      l1.output(logger)\n      logger.write_char(' ')\n      l2.output(logger)\n      logger.write_char(' ')\n      l3.output(logger)\n      logger.write_char(' ')\n      l4.output(logger)\n      logger.write_char(' ')\n      l5.output(logger)\n      logger.write_char(' ')\n      l6.output(logger)\n      logger.write_char(' ')\n      l7.output(logger)\n      logger.write_char(' ')\n      l8.output(logger)\n      logger.write_char(' ')\n      l9.output(logger)\n      logger.write_char(' ')\n      l10.output(logger)\n      logger.write_char(' ')\n      l11.output(logger)\n      logger.write_char(' ')\n      l12.output(logger)\n      logger.write_char(' ')\n      l13.output(logger)\n      logger.write_char(' ')\n      l14.output(logger)\n      logger.write_char(' ')\n      l15.output(logger)\n      logger.write_char(')')\n    }\n    I8x16Swizzle => logger.write_string(\"i8x16.swizzle\")\n    I8x16Splat => logger.write_string(\"i8x16.splat\")\n    I16x8Splat => logger.write_string(\"i16x8.splat\")\n    I32x4Splat => logger.write_string(\"i32x4.splat\")\n    I64x2Splat => logger.write_string(\"i64x2.splat\")\n    F32x4Splat => logger.write_string(\"f32x4.splat\")\n    F64x2Splat => logger.write_string(\"f64x2.splat\")\n    I8x16ExtractLaneS(i) => {\n      logger.write_string(\"(i8x16.extract_lane_s \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I8x16ExtractLaneU(i) => {\n      logger.write_string(\"(i8x16.extract_lane_u \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I8x16ReplaceLane(i) => {\n      logger.write_string(\"(i8x16.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I16x8ExtractLaneS(i) => {\n      logger.write_string(\"(i16x8.extract_lane_s \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I16x8ExtractLaneU(i) => {\n      logger.write_string(\"(i16x8.extract_lane_u \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I16x8ReplaceLane(i) => {\n      logger.write_string(\"(i16x8.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I32x4ExtractLane(i) => {\n      logger.write_string(\"(i32x4.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I32x4ReplaceLane(i) => {\n      logger.write_string(\"(i32x4.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I64x2ExtractLane(i) => {\n      logger.write_string(\"(i64x2.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I64x2ReplaceLane(i) => {\n      logger.write_string(\"(i64x2.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F32x4ExtractLane(i) => {\n      logger.write_string(\"(f32x4.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F32x4ReplaceLane(i) => {\n      logger.write_string(\"(f32x4.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F64x2ExtractLane(i) => {\n      logger.write_string(\"(f64x2.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F64x2ReplaceLane(i) => {\n      logger.write_string(\"(f64x2.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I8x16Eq => logger.write_string(\"i8x16.eq\")\n    I8x16Ne => logger.write_string(\"i8x16.ne\")\n    I8x16LtS => logger.write_string(\"i8x16.lt_s\")\n    I8x16LtU => logger.write_string(\"i8x16.lt_u\")\n    I8x16GtS => logger.write_string(\"i8x16.gt_s\")\n    I8x16GtU => logger.write_string(\"i8x16.gt_u\")\n    I8x16LeS => logger.write_string(\"i8x16.le_s\")\n    I8x16LeU => logger.write_string(\"i8x16.le_u\")\n    I8x16GeS => logger.write_string(\"i8x16.ge_s\")\n    I8x16GeU => logger.write_string(\"i8x16.ge_u\")\n    I16x8Eq => logger.write_string(\"i16x8.eq\")\n    I16x8Ne => logger.write_string(\"i16x8.ne\")\n    I16x8LtS => logger.write_string(\"i16x8.lt_s\")\n    I16x8LtU => logger.write_string(\"i16x8.lt_u\")\n    I16x8GtS => logger.write_string(\"i16x8.gt_s\")\n    I16x8GtU => logger.write_string(\"i16x8.gt_u\")\n    I16x8LeS => logger.write_string(\"i16x8.le_s\")\n    I16x8LeU => logger.write_string(\"i16x8.le_u\")\n    I16x8GeS => logger.write_string(\"i16x8.ge_s\")\n    I16x8GeU => logger.write_string(\"i16x8.ge_u\")\n    I32x4Eq => logger.write_string(\"i32x4.eq\")\n    I32x4Ne => logger.write_string(\"i32x4.ne\")\n    I32x4LtS => logger.write_string(\"i32x4.lt_s\")\n    I32x4LtU => logger.write_string(\"i32x4.lt_u\")\n    I32x4GtS => logger.write_string(\"i32x4.gt_s\")\n    I32x4GtU => logger.write_string(\"i32x4.gt_u\")\n    I32x4LeS => logger.write_string(\"i32x4.le_s\")\n    I32x4LeU => logger.write_string(\"i32x4.le_u\")\n    I32x4GeS => logger.write_string(\"i32x4.ge_s\")\n    I32x4GeU => logger.write_string(\"i32x4.ge_u\")\n    F32x4Eq => logger.write_string(\"f32x4.eq\")\n    F32x4Ne => logger.write_string(\"f32x4.ne\")\n    F32x4Lt => logger.write_string(\"f32x4.lt\")\n    F32x4Gt => logger.write_string(\"f32x4.gt\")\n    F32x4Le => logger.write_string(\"f32x4.le\")\n    F32x4Ge => logger.write_string(\"f32x4.ge\")\n    F64x2Eq => logger.write_string(\"f64x2.eq\")\n    F64x2Ne => logger.write_string(\"f64x2.ne\")\n    F64x2Lt => logger.write_string(\"f64x2.lt\")\n    F64x2Gt => logger.write_string(\"f64x2.gt\")\n    F64x2Le => logger.write_string(\"f64x2.le\")\n    F64x2Ge => logger.write_string(\"f64x2.ge\")\n    V128Not => logger.write_string(\"v128.not\")\n    V128And => logger.write_string(\"v128.and\")\n    V128Andnot => logger.write_string(\"v128.andnot\")\n    V128Or => logger.write_string(\"v128.or\")\n    V128Xor => logger.write_string(\"v128.xor\")\n    V128Bitselect => logger.write_string(\"v128.bitselect\")\n    V128AnyTrue => logger.write_string(\"v128.any_true\")\n    V128Load8Lane(m, i) => {\n      logger.write_string(\"(v128.load8_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16Lane(m, i) => {\n      logger.write_string(\"(v128.load16_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32Lane(m, i) => {\n      logger.write_string(\"(v128.load32_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load64Lane(m, i) => {\n      logger.write_string(\"(v128.load64_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store8Lane(m, i) => {\n      logger.write_string(\"(v128.store8_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store16Lane(m, i) => {\n      logger.write_string(\"(v128.store16_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store32Lane(m, i) => {\n      logger.write_string(\"(v128.store32_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store64Lane(m, i) => {\n      logger.write_string(\"(v128.store64_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32Zero(m) => {\n      logger.write_string(\"(v128_load32_zero \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load64Zero(m) => {\n      logger.write_string(\"(v128_load64_zero \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F32x4DemoteF64x2Zero => logger.write_string(\"f32x4.demote_f64x2_zero\")\n    F64x2PromoteLowF32x4 => logger.write_string(\"f64x2.promote_low_f32x4\")\n    I8x16Abs => logger.write_string(\"i8x16.abs\")\n    I8x16Neg => logger.write_string(\"i8x16.neg\")\n    I8x16Popcnt => logger.write_string(\"i8x16.popcnt\")\n    I8x16AllTrue => logger.write_string(\"i8x16.all_true\")\n    I8x16Bitmask => logger.write_string(\"i8x16.bitmask\")\n    I8x16NarrowI16x8S => logger.write_string(\"i8x16.narrow_i16x8s\")\n    I8x16NarrowI16x8U => logger.write_string(\"i8x16.narrow_i16x8u\")\n    F32x4Ceil => logger.write_string(\"f32x4.ceil\")\n    F32x4Floor => logger.write_string(\"f32x4.floor\")\n    F32x4Trunc => logger.write_string(\"f32x4.trunc\")\n    F32x4Nearest => logger.write_string(\"f32x4.nearest\")\n    I8x16Shl => logger.write_string(\"i8x16.shl\")\n    I8x16ShrS => logger.write_string(\"i8x16.shr_s\")\n    I8x16ShrU => logger.write_string(\"i8x16.shr_u\")\n    I8x16Add => logger.write_string(\"i8x16.add\")\n    I8x16AddSatS => logger.write_string(\"i8x16.add_sat_s\")\n    I8x16AddSatU => logger.write_string(\"i8x16.add_sat_u\")\n    I8x16Sub => logger.write_string(\"i8x16.sub\")\n    I8x16SubSatS => logger.write_string(\"i8x16.sub_sat_s\")\n    I8x16SubSatU => logger.write_string(\"i8x16.sub_sat_u\")\n    F64x2Ceil => logger.write_string(\"f64x2.ceil\")\n    F64x2Floor => logger.write_string(\"f64x2.floor\")\n    I8x16MinS => logger.write_string(\"i8x16.min_s\")\n    I8x16MinU => logger.write_string(\"i8x16.min_u\")\n    I8x16MaxS => logger.write_string(\"i8x16.max_s\")\n    I8x16MaxU => logger.write_string(\"i8x16.max_u\")\n    F64x2Trunc => logger.write_string(\"f64x2.trunc\")\n    I8x16AvgrU => logger.write_string(\"i8x16.avgr_u\")\n    I16x8ExtaddPairwiseI8x16S =>\n      logger.write_string(\"i16x8.extadd_pairwise_i8x16s\")\n    I16x8ExtaddPairwiseI8x16U =>\n      logger.write_string(\"i16x8.extadd_pairwise_i8x16u\")\n    I32x4ExtaddPairwiseI16x8S =>\n      logger.write_string(\"i32x4.extadd_pairwise_i16x8s\")\n    I32x4ExtaddPairwiseI16x8U =>\n      logger.write_string(\"i32x4.extadd_pairwise_i16x8u\")\n    I16x8Abs => logger.write_string(\"i16x8.abs\")\n    I16x8Neg => logger.write_string(\"i16x8.neg\")\n    I16x8Q15mulrSatS => logger.write_string(\"i16x8.15mulr_sat_s\")\n    I16x8AllTrue => logger.write_string(\"i16x8.all_true\")\n    I16x8Bitmask => logger.write_string(\"i16x8.bitmask\")\n    I16x8NarrowI32x4S => logger.write_string(\"i16x8.narrow_i32x4s\")\n    I16x8NarrowI32x4U => logger.write_string(\"i16x8.narrow_i32x4u\")\n    I16x8ExtendLowI8x16S => logger.write_string(\"i16x8.extend_low_i8x16s\")\n    I16x8ExtendHighI8x16S => logger.write_string(\"i16x8.extend_high_i8x16s\")\n    I16x8ExtendLowI8x16U => logger.write_string(\"i16x8.extend_low_i8x16u\")\n    I16x8ExtendHighI8x16U => logger.write_string(\"i16x8.extend_high_i8x16u\")\n    I16x8Shl => logger.write_string(\"i16x8.shl\")\n    I16x8ShrS => logger.write_string(\"i16x8.shr_s\")\n    I16x8ShrU => logger.write_string(\"i16x8.shr_u\")\n    I16x8Add => logger.write_string(\"i16x8.add\")\n    I16x8AddSatS => logger.write_string(\"i16x8.add_sat_s\")\n    I16x8AddSatU => logger.write_string(\"i16x8.add_sat_u\")\n    I16x8Sub => logger.write_string(\"i16x8.sub\")\n    I16x8SubSatS => logger.write_string(\"i16x8.sub_sat_s\")\n    I16x8SubSatU => logger.write_string(\"i16x8.sub_sat_u\")\n    F64x2Nearest => logger.write_string(\"f64x2.nearest\")\n    I16x8Mul => logger.write_string(\"i16x8.mul\")\n    I16x8MinS => logger.write_string(\"i16x8.min_s\")\n    I16x8MinU => logger.write_string(\"i16x8.min_u\")\n    I16x8MaxS => logger.write_string(\"i16x8.max_s\")\n    I16x8MaxU => logger.write_string(\"i16x8.max_u\")\n    I16x8AvgrU => logger.write_string(\"i16x8.avgr_u\")\n    I16x8ExtmulLowI8x16S => logger.write_string(\"i16x8.extmul_low_i8x16s\")\n    I16x8ExtmulHighI8x16S => logger.write_string(\"i16x8.extmul_high_i8x16s\")\n    I16x8ExtmulLowI8x16U => logger.write_string(\"i16x8.extmul_low_i8x16u\")\n    I16x8ExtmulHighI8x16U => logger.write_string(\"i16x8.extmul_high_i8x16u\")\n    I32x4Abs => logger.write_string(\"i32x4.abs\")\n    I32x4Neg => logger.write_string(\"i32x4.neg\")\n    I32x4AllTrue => logger.write_string(\"i32x4.all_true\")\n    I32x4Bitmask => logger.write_string(\"i32x4.bitmask\")\n    I32x4ExtendLowI16x8S => logger.write_string(\"i32x4.extend_low_i16x8s\")\n    I32x4ExtendHighI16x8S => logger.write_string(\"i32x4.extend_high_i16x8s\")\n    I32x4ExtendLowI16x8U => logger.write_string(\"i32x4.extend_low_i16x8u\")\n    I32x4ExtendHighI16x8U => logger.write_string(\"i32x4.extend_high_i16x8u\")\n    I32x4Shl => logger.write_string(\"i32x4.shl\")\n    I32x4ShrS => logger.write_string(\"i32x4.shr_s\")\n    I32x4ShrU => logger.write_string(\"i32x4.shr_u\")\n    I32x4Add => logger.write_string(\"i32x4.add\")\n    I32x4Sub => logger.write_string(\"i32x4.sub\")\n    I32x4Mul => logger.write_string(\"i32x4.mul\")\n    I32x4MinS => logger.write_string(\"i32x4.min_s\")\n    I32x4MinU => logger.write_string(\"i32x4.min_u\")\n    I32x4MaxS => logger.write_string(\"i32x4.max_s\")\n    I32x4MaxU => logger.write_string(\"i32x4.max_u\")\n    I32x4DotI16x8S => logger.write_string(\"i32x4.dot_i16x8s\")\n    I32x4ExtmulLowI16x8S => logger.write_string(\"i32x4.extmul_low_i16x8s\")\n    I32x4ExtmulHighI16x8S => logger.write_string(\"i32x4.extmul_high_i16x8s\")\n    I32x4ExtmulLowI16x8U => logger.write_string(\"i32x4.extmul_low_i16x8u\")\n    I32x4ExtmulHighI16x8U => logger.write_string(\"i32x4.extmul_high_i16x8u\")\n    I64x2Abs => logger.write_string(\"i64x2.abs\")\n    I64x2Neg => logger.write_string(\"i64x2.neg\")\n    I64x2AllTrue => logger.write_string(\"i64x2.all_true\")\n    I64x2Bitmask => logger.write_string(\"i64x2.bitmask\")\n    I64x2ExtendLowI32x4S => logger.write_string(\"i64x2.extend_low_i32x4s\")\n    I64x2ExtendHighI32x4S => logger.write_string(\"i64x2.extend_high_i32x4s\")\n    I64x2ExtendLowI32x4U => logger.write_string(\"i64x2.extend_low_i32x4u\")\n    I64x2ExtendHighI32x4U => logger.write_string(\"i64x2.extend_high_i32x4u\")\n    I64x2Shl => logger.write_string(\"i64x2.shl\")\n    I64x2ShrS => logger.write_string(\"i64x2.shr_s\")\n    I64x2ShrU => logger.write_string(\"i64x2.shr_u\")\n    I64x2Add => logger.write_string(\"i64x2.add\")\n    I64x2Sub => logger.write_string(\"i64x2.sub\")\n    I64x2Mul => logger.write_string(\"i64x2.mul\")\n    I64x2Eq => logger.write_string(\"i64x2.eq\")\n    I64x2Ne => logger.write_string(\"i64x2.ne\")\n    I64x2LtS => logger.write_string(\"i64x2.lt_s\")\n    I64x2GtS => logger.write_string(\"i64x2.gt_s\")\n    I64x2LeS => logger.write_string(\"i64x2.le_s\")\n    I64x2GeS => logger.write_string(\"i64x2.ge_s\")\n    I64x2ExtmulLowI32x4S => logger.write_string(\"i64x2.extmul_low_i32x4s\")\n    I64x2ExtmulHighI32x4S => logger.write_string(\"i64x2.extmul_high_i32x4s\")\n    I64x2ExtmulLowI32x4U => logger.write_string(\"i64x2.extmul_low_i32x4u\")\n    I64x2ExtmulHighI32x4U => logger.write_string(\"i64x2.extmul_high_i32x4u\")\n    F32x4Abs => logger.write_string(\"f32x4.abs\")\n    F32x4Neg => logger.write_string(\"f32x4.neg\")\n    F32x4Sqrt => logger.write_string(\"f32x4.sqrt\")\n    F32x4Add => logger.write_string(\"f32x4.add\")\n    F32x4Sub => logger.write_string(\"f32x4.sub\")\n    F32x4Mul => logger.write_string(\"f32x4.mul\")\n    F32x4Div => logger.write_string(\"f32x4.div\")\n    F32x4Min => logger.write_string(\"f32x4.min\")\n    F32x4Max => logger.write_string(\"f32x4.max\")\n    F32x4Pmin => logger.write_string(\"f32x4.pmin\")\n    F32x4Pmax => logger.write_string(\"f32x4.pmax\")\n    F64x2Abs => logger.write_string(\"f64x2.abs\")\n    F64x2Neg => logger.write_string(\"f64x2.neg\")\n    F64x2Sqrt => logger.write_string(\"f64x2.sqrt\")\n    F64x2Add => logger.write_string(\"f64x2.add\")\n    F64x2Sub => logger.write_string(\"f64x2.sub\")\n    F64x2Mul => logger.write_string(\"f64x2.mul\")\n    F64x2Div => logger.write_string(\"f64x2.div\")\n    F64x2Min => logger.write_string(\"f64x2.min\")\n    F64x2Max => logger.write_string(\"f64x2.max\")\n    F64x2Pmin => logger.write_string(\"f64x2.pmin\")\n    F64x2Pmax => logger.write_string(\"f64x2.pmax\")\n    I32x4TruncSatF32x4S => logger.write_string(\"i32x4.trunc_sat_f32x4s\")\n    I32x4TruncSatF32x4U => logger.write_string(\"i32x4.trunc_sat_f32x4u\")\n    F32x4ConvertI32x4S => logger.write_string(\"f32x4.convert_i32x4s\")\n    F32x4ConvertI32x4U => logger.write_string(\"f32x4.convert_i32x4u\")\n    I32x4TruncSatF64x2SZero =>\n      logger.write_string(\"i32x4.trunc_sat_f64x2s_zero\")\n    I32x4TruncSatF64x2UZero =>\n      logger.write_string(\"i32x4.trunc_sat_f64x2u_zero\")\n    F64x2ConvertLowI32x4S => logger.write_string(\"f64x2.convert_low_i32x4s\")\n    F64x2ConvertLowI32x4U => logger.write_string(\"f64x2.convert_low_i32x4u\")\n    I8x16RelaxedSwizzle => logger.write_string(\"i8x16.relaxed_swizzle\")\n    I32x4RelaxedTruncF32x4S => logger.write_string(\"i32x4.relaxed_trunc_f32x4s\")\n    I32x4RelaxedTruncF32x4U => logger.write_string(\"i32x4.relaxed_trunc_f32x4u\")\n    I32x4RelaxedTruncZeroF64x2S =>\n      logger.write_string(\"i32x4.relaxed_trunc_zero_f64x2s\")\n    I32x4RelaxedTruncZeroF64x2U =>\n      logger.write_string(\"i32x4.relaxed_trunc_zero_f64x2u\")\n    F32x4RelaxedMadd => logger.write_string(\"f32x4.relaxed_madd\")\n    F32x4RelaxedNmadd => logger.write_string(\"f32x4.relaxed_nmadd\")\n    F64x2RelaxedMadd => logger.write_string(\"f64x2.relaxed_madd\")\n    F64x2RelaxedNmadd => logger.write_string(\"f64x2.relaxed_nmadd\")\n    I8x16RelaxedLaneselect => logger.write_string(\"i8x16.relaxed_laneselect\")\n    I16x8RelaxedLaneselect => logger.write_string(\"i16x8.relaxed_laneselect\")\n    I32x4RelaxedLaneselect => logger.write_string(\"i32x4.relaxed_laneselect\")\n    I64x2RelaxedLaneselect => logger.write_string(\"i64x2.relaxed_laneselect\")\n    F32x4RelaxedMin => logger.write_string(\"f32x4.relaxed_min\")\n    F32x4RelaxedMax => logger.write_string(\"f32x4.relaxed_max\")\n    F64x2RelaxedMin => logger.write_string(\"f64x2.relaxed_min\")\n    F64x2RelaxedMax => logger.write_string(\"f64x2.relaxed_max\")\n    I16x8RelaxedQ15mulrS => logger.write_string(\"i16x8.relaxed_q15mulr_s\")\n    I16x8RelaxedDotI8x16I7x16S =>\n      logger.write_string(\"i16x8.relaxed_dot_i8x16i7x16s\")\n    I32x4RelaxedDotI8x16I7x16AddS =>\n      logger.write_string(\"i32x4.relaxed_dot_i8x16i7x16_add_s\")\n  }\n}\n\n///|\npub impl Show for CustomSec with output(self, logger) {\n  let CustomSec(name, _) = self\n  logger.write_string(\"[Custom: \")\n  name.output(logger)\n  logger.write_char(']')\n}\n\n///|\npub impl Show for TypeSec with output(self, logger) {\n  let TypeSec(tys) = self\n  logger.write_string(\"[Types\")\n  if tys.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\":\\n\")\n  for ty in tys {\n    logger.write_string(\"  - \")\n    ty.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for ImportSec with output(self, logger) {\n  let ImportSec(imports) = self\n  logger.write_string(\"[Imports\")\n  if imports.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in imports {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for FuncSec with output(self, logger) {\n  let FuncSec(fns) = self\n  logger.write_string(\"[Funcs\")\n  if fns.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in fns {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for TableSec with output(self, logger) {\n  let TableSec(tbls) = self\n  logger.write_string(\"[Tables\")\n  if tbls.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in tbls {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for MemSec with output(self, logger) {\n  let MemSec(mems) = self\n  logger.write_string(\"[Memory\")\n  if mems.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in mems {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for TagSec with output(self, logger) {\n  let TagSec(mems) = self\n  logger.write_string(\"[Tags\")\n  if mems.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in mems {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for GlobalSec with output(self, logger) {\n  let GlobalSec(globals) = self\n  logger.write_string(\"[Globals\")\n  if globals.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in globals {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for ExportSec with output(self, logger) {\n  let ExportSec(exports) = self\n  logger.write_string(\"[Globals\")\n  if exports.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in exports {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for StartSec with output(self, logger) {\n  let StartSec(start) = self\n  logger.write_string(\"[Start \")\n  start.output(logger)\n  logger.write_char(']')\n}\n\n///|\npub impl Show for ElemSec with output(self, logger) {\n  let ElemSec(elems) = self\n  logger.write_string(\"[Elems\")\n  if elems.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in elems {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for DataCntSec with output(self, logger) {\n  let DataCntSec(start) = self\n  logger.write_string(\"[DataCount \")\n  start.output(logger)\n  logger.write_char(']')\n}\n\n///|\npub impl Show for CodeSec with output(self, logger) {\n  let CodeSec(codes) = self\n  logger.write_string(\"[Code\")\n  if codes.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in codes {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for DataSec with output(self, logger) {\n  let DataSec(datas) = self\n  logger.write_string(\"[Elems\")\n  if datas.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in datas {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for Module with output(self, logger) {\n  let Module(\n    customs,\n    type_sec,\n    import_sec,\n    func_sec,\n    table_sec,\n    mem_sec,\n    tag_sec,\n    global_sec,\n    export_sec,\n    start_sec,\n    elem_sec,\n    data_cnt_sec,\n    code_sec,\n    data_sec\n  ) = self\n  logger.write_string(\"Module[\\n\")\n  logger.write_string(\"customs: \")\n  customs.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"type_sec: \")\n  type_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"import_sec: \")\n  import_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"func_sec: \")\n  func_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"table_sec: \")\n  table_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"mem_sec: \")\n  mem_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"tag_sec: \")\n  tag_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"global_sec: \")\n  global_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"export_sec: \")\n  export_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"start_sec: \")\n  start_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"elem_sec: \")\n  elem_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"data_cnt_sec: \")\n  data_cnt_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"code_sec: \")\n  code_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"data_sec: \")\n  data_sec.output(logger)\n  logger.write_string(\"]\")\n}\n","///|\n/// Convert flat Expr to tree-based TExpr\npub fn expr_to_texpr(expr : Expr, env : Env) -> Result[TExpr, String] {\n  let stack : Array[TInstr] = []\n  for instr in expr.0 {\n    match instr_to_tinstr(instr, stack, env) {\n      Ok(_) => ()\n      Err(t) => return Err(t)\n    }\n  }\n  Ok(TExpr(stack))\n}\n\n///|\n/// Convert tree-based TExpr back to flat Expr\npub fn texpr_to_expr(texpr : TExpr) -> Expr {\n  let instrs : Array[Instruction] = []\n  for value in texpr.0 {\n    tinstr_to_instr(value, instrs)\n  }\n  Expr(instrs)\n}\n\n// ============================================================================\n// Expr -> TExpr helpers\n// ============================================================================\n\n///|\nfn pop(stack : Array[TInstr]) -> Result[TInstr, String] {\n  match stack.pop() {\n    Some(v) => Ok(v)\n    None => Err(\"Stack underflow during tree conversion\")\n  }\n}\n\n///|\nfn pop_n(stack : Array[TInstr], n : Int) -> Result[Array[TInstr], String] {\n  if stack.length() < n {\n    return Err(\n      \"Stack underflow: need \\{n} values but only \\{stack.length()} available\",\n    )\n  }\n  let result : Array[TInstr] = Array::make(n, TInstr::TNop)\n  // Pop in reverse order, then we have them in correct order\n  for i = n - 1; i >= 0; i = i - 1 {\n    result[i] = stack.pop().unwrap()\n  }\n  Ok(result)\n}\n\n///|\nfn block_type_inputs(bt : BlockType, env : Env) -> Int {\n  match bt {\n    EmptyBlockType => 0\n    ValTypeBlockType(_) => 0\n    TypeIdxBlockType(idx) =>\n      match env.resolve_functype(idx) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n  }\n}\n\n///|\nfn instr_to_tinstr(\n  instr : Instruction,\n  stack : Array[TInstr],\n  env : Env,\n) -> Result[Unit, String] {\n  match instr {\n    // === Constants ===\n    I32Const(v) => stack.push(TI32Const(v))\n    I64Const(v) => stack.push(TI64Const(v))\n    F32Const(v) => stack.push(TF32Const(v))\n    F64Const(v) => stack.push(TF64Const(v))\n    RefNull(ht) => stack.push(TRefNull(ht))\n    RefFunc(idx) => stack.push(TRefFunc(idx))\n    V128Const(\n      b0,\n      b1,\n      b2,\n      b3,\n      b4,\n      b5,\n      b6,\n      b7,\n      b8,\n      b9,\n      b10,\n      b11,\n      b12,\n      b13,\n      b14,\n      b15\n    ) =>\n      stack.push(\n        TV128Const(\n          b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,\n        ),\n      )\n\n    // === Nullary ===\n    Unreachable => stack.push(TUnreachable)\n    Nop => stack.push(TNop)\n    LocalGet(idx) => stack.push(TLocalGet(idx))\n    GlobalGet(idx) => stack.push(TGlobalGet(idx))\n    MemorySize(idx) => stack.push(TMemorySize(idx))\n    TableSize(idx) => stack.push(TTableSize(idx))\n\n    // === Unary numeric ===\n    I32Eqz => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32EqzOp, op))\n    }\n    I64Eqz => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64EqzOp, op))\n    }\n    I32Clz => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32ClzOp, op))\n    }\n    I32Ctz => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32CtzOp, op))\n    }\n    I32Popcnt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32PopcntOp, op))\n    }\n    I64Clz => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64ClzOp, op))\n    }\n    I64Ctz => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64CtzOp, op))\n    }\n    I64Popcnt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64PopcntOp, op))\n    }\n    F32Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32AbsOp, op))\n    }\n    F32Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32NegOp, op))\n    }\n    F32Ceil => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32CeilOp, op))\n    }\n    F32Floor => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32FloorOp, op))\n    }\n    F32Trunc => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32TruncOp, op))\n    }\n    F32Nearest => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32NearestOp, op))\n    }\n    F32Sqrt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32SqrtOp, op))\n    }\n    F64Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64AbsOp, op))\n    }\n    F64Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64NegOp, op))\n    }\n    F64Ceil => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64CeilOp, op))\n    }\n    F64Floor => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64FloorOp, op))\n    }\n    F64Trunc => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64TruncOp, op))\n    }\n    F64Nearest => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64NearestOp, op))\n    }\n    F64Sqrt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64SqrtOp, op))\n    }\n\n    // === Conversions ===\n    I32WrapI64 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32WrapI64Op, op))\n    }\n    I32TruncF32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncF32SOp, op))\n    }\n    I32TruncF32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncF32UOp, op))\n    }\n    I32TruncF64S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncF64SOp, op))\n    }\n    I32TruncF64U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncF64UOp, op))\n    }\n    I64ExtendI32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64ExtendI32SOp, op))\n    }\n    I64ExtendI32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64ExtendI32UOp, op))\n    }\n    I64TruncF32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncF32SOp, op))\n    }\n    I64TruncF32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncF32UOp, op))\n    }\n    I64TruncF64S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncF64SOp, op))\n    }\n    I64TruncF64U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncF64UOp, op))\n    }\n    F32ConvertI32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32ConvertI32SOp, op))\n    }\n    F32ConvertI32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32ConvertI32UOp, op))\n    }\n    F32ConvertI64S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32ConvertI64SOp, op))\n    }\n    F32ConvertI64U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32ConvertI64UOp, op))\n    }\n    F32DemoteF64 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32DemoteF64Op, op))\n    }\n    F64ConvertI32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64ConvertI32SOp, op))\n    }\n    F64ConvertI32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64ConvertI32UOp, op))\n    }\n    F64ConvertI64S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64ConvertI64SOp, op))\n    }\n    F64ConvertI64U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64ConvertI64UOp, op))\n    }\n    F64PromoteF32 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64PromoteF32Op, op))\n    }\n    I32ReinterpretF32 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32ReinterpretF32Op, op))\n    }\n    I64ReinterpretF64 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64ReinterpretF64Op, op))\n    }\n    F32ReinterpretI32 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32ReinterpretI32Op, op))\n    }\n    F64ReinterpretI64 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64ReinterpretI64Op, op))\n    }\n    I32Extend8S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32Extend8SOp, op))\n    }\n    I32Extend16S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32Extend16SOp, op))\n    }\n    I64Extend8S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64Extend8SOp, op))\n    }\n    I64Extend16S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64Extend16SOp, op))\n    }\n    I64Extend32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64Extend32SOp, op))\n    }\n    I32TruncSatF32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncSatF32SOp, op))\n    }\n    I32TruncSatF32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncSatF32UOp, op))\n    }\n    I32TruncSatF64S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncSatF64SOp, op))\n    }\n    I32TruncSatF64U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32TruncSatF64UOp, op))\n    }\n    I64TruncSatF32S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncSatF32SOp, op))\n    }\n    I64TruncSatF32U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncSatF32UOp, op))\n    }\n    I64TruncSatF64S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncSatF64SOp, op))\n    }\n    I64TruncSatF64U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64TruncSatF64UOp, op))\n    }\n\n    // === Binary numeric ===\n    I32Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32EqOp, lhs, rhs))\n    }\n    I32Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32NeOp, lhs, rhs))\n    }\n    I32LtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32LtSOp, lhs, rhs))\n    }\n    I32LtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32LtUOp, lhs, rhs))\n    }\n    I32GtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32GtSOp, lhs, rhs))\n    }\n    I32GtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32GtUOp, lhs, rhs))\n    }\n    I32LeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32LeSOp, lhs, rhs))\n    }\n    I32LeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32LeUOp, lhs, rhs))\n    }\n    I32GeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32GeSOp, lhs, rhs))\n    }\n    I32GeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32GeUOp, lhs, rhs))\n    }\n    I64Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64EqOp, lhs, rhs))\n    }\n    I64Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64NeOp, lhs, rhs))\n    }\n    I64LtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64LtSOp, lhs, rhs))\n    }\n    I64LtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64LtUOp, lhs, rhs))\n    }\n    I64GtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64GtSOp, lhs, rhs))\n    }\n    I64GtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64GtUOp, lhs, rhs))\n    }\n    I64LeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64LeSOp, lhs, rhs))\n    }\n    I64LeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64LeUOp, lhs, rhs))\n    }\n    I64GeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64GeSOp, lhs, rhs))\n    }\n    I64GeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64GeUOp, lhs, rhs))\n    }\n    F32Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32EqOp, lhs, rhs))\n    }\n    F32Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32NeOp, lhs, rhs))\n    }\n    F32Lt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32LtOp, lhs, rhs))\n    }\n    F32Gt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32GtOp, lhs, rhs))\n    }\n    F32Le => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32LeOp, lhs, rhs))\n    }\n    F32Ge => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32GeOp, lhs, rhs))\n    }\n    F64Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64EqOp, lhs, rhs))\n    }\n    F64Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64NeOp, lhs, rhs))\n    }\n    F64Lt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64LtOp, lhs, rhs))\n    }\n    F64Gt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64GtOp, lhs, rhs))\n    }\n    F64Le => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64LeOp, lhs, rhs))\n    }\n    F64Ge => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64GeOp, lhs, rhs))\n    }\n    I32Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32AddOp, lhs, rhs))\n    }\n    I32Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32SubOp, lhs, rhs))\n    }\n    I32Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32MulOp, lhs, rhs))\n    }\n    I32DivS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32DivSOp, lhs, rhs))\n    }\n    I32DivU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32DivUOp, lhs, rhs))\n    }\n    I32RemS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32RemSOp, lhs, rhs))\n    }\n    I32RemU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32RemUOp, lhs, rhs))\n    }\n    I32And => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32AndOp, lhs, rhs))\n    }\n    I32Or => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32OrOp, lhs, rhs))\n    }\n    I32Xor => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32XorOp, lhs, rhs))\n    }\n    I32Shl => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32ShlOp, lhs, rhs))\n    }\n    I32ShrS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32ShrSOp, lhs, rhs))\n    }\n    I32ShrU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32ShrUOp, lhs, rhs))\n    }\n    I32Rotl => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32RotlOp, lhs, rhs))\n    }\n    I32Rotr => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32RotrOp, lhs, rhs))\n    }\n    I64Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64AddOp, lhs, rhs))\n    }\n    I64Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64SubOp, lhs, rhs))\n    }\n    I64Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64MulOp, lhs, rhs))\n    }\n    I64DivS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64DivSOp, lhs, rhs))\n    }\n    I64DivU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64DivUOp, lhs, rhs))\n    }\n    I64RemS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64RemSOp, lhs, rhs))\n    }\n    I64RemU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64RemUOp, lhs, rhs))\n    }\n    I64And => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64AndOp, lhs, rhs))\n    }\n    I64Or => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64OrOp, lhs, rhs))\n    }\n    I64Xor => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64XorOp, lhs, rhs))\n    }\n    I64Shl => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64ShlOp, lhs, rhs))\n    }\n    I64ShrS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64ShrSOp, lhs, rhs))\n    }\n    I64ShrU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64ShrUOp, lhs, rhs))\n    }\n    I64Rotl => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64RotlOp, lhs, rhs))\n    }\n    I64Rotr => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64RotrOp, lhs, rhs))\n    }\n    F32Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32AddOp, lhs, rhs))\n    }\n    F32Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32SubOp, lhs, rhs))\n    }\n    F32Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32MulOp, lhs, rhs))\n    }\n    F32Div => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32DivOp, lhs, rhs))\n    }\n    F32Min => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32MinOp, lhs, rhs))\n    }\n    F32Max => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32MaxOp, lhs, rhs))\n    }\n    F32Copysign => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32CopysignOp, lhs, rhs))\n    }\n    F64Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64AddOp, lhs, rhs))\n    }\n    F64Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64SubOp, lhs, rhs))\n    }\n    F64Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64MulOp, lhs, rhs))\n    }\n    F64Div => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64DivOp, lhs, rhs))\n    }\n    F64Min => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64MinOp, lhs, rhs))\n    }\n    F64Max => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64MaxOp, lhs, rhs))\n    }\n    F64Copysign => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64CopysignOp, lhs, rhs))\n    }\n\n    // === Other unary ===\n    Drop => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TDrop(op))\n    }\n    LocalSet(idx) => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLocalSet(idx, op))\n    }\n    LocalTee(idx) => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLocalTee(idx, op))\n    }\n    GlobalSet(idx) => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TGlobalSet(idx, op))\n    }\n    RefIsNull => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TRefIsNull(op))\n    }\n    RefAsNonNull => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TRefAsNonNull(op))\n    }\n    RefEq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TRefEq(lhs, rhs))\n    }\n    RefI31 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TRefI31(op))\n    }\n    I31GetS => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI31GetS(op))\n    }\n    I31GetU => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI31GetU(op))\n    }\n    ArrayLen => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayLen(op))\n    }\n    AnyConvertExtern => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TAnyConvertExtern(op))\n    }\n    ExternConvertAny => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExternConvertAny(op))\n    }\n    ThrowRef => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TThrowRef(op))\n    }\n\n    // === Loads ===\n    I32Load(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I32LoadOp, memarg, addr))\n    }\n    I64Load(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64LoadOp, memarg, addr))\n    }\n    F32Load(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(F32LoadOp, memarg, addr))\n    }\n    F64Load(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(F64LoadOp, memarg, addr))\n    }\n    I32Load8S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I32Load8SOp, memarg, addr))\n    }\n    I32Load8U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I32Load8UOp, memarg, addr))\n    }\n    I32Load16S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I32Load16SOp, memarg, addr))\n    }\n    I32Load16U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I32Load16UOp, memarg, addr))\n    }\n    I64Load8S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64Load8SOp, memarg, addr))\n    }\n    I64Load8U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64Load8UOp, memarg, addr))\n    }\n    I64Load16S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64Load16SOp, memarg, addr))\n    }\n    I64Load16U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64Load16UOp, memarg, addr))\n    }\n    I64Load32S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64Load32SOp, memarg, addr))\n    }\n    I64Load32U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(I64Load32UOp, memarg, addr))\n    }\n\n    // === Stores ===\n    I32Store(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I32StoreOp, memarg, addr, value))\n    }\n    I64Store(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I64StoreOp, memarg, addr, value))\n    }\n    F32Store(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(F32StoreOp, memarg, addr, value))\n    }\n    F64Store(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(F64StoreOp, memarg, addr, value))\n    }\n    I32Store8(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I32Store8Op, memarg, addr, value))\n    }\n    I32Store16(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I32Store16Op, memarg, addr, value))\n    }\n    I64Store8(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I64Store8Op, memarg, addr, value))\n    }\n    I64Store16(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I64Store16Op, memarg, addr, value))\n    }\n    I64Store32(memarg) => {\n      let value = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(I64Store32Op, memarg, addr, value))\n    }\n\n    // === Memory operations ===\n    MemoryGrow(idx) => {\n      let pages = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TMemoryGrow(idx, pages))\n    }\n    MemoryFill(idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dest = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TMemoryFill(idx, dest, val, len))\n    }\n    MemoryCopy(dst, src) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let src_addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dst_addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TMemoryCopy(dst, src, dst_addr, src_addr, len))\n    }\n    MemoryInit(data_idx, mem_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let src = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dst = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TMemoryInit(data_idx, mem_idx, dst, src, len))\n    }\n    DataDrop(idx) => stack.push(TDataDrop(idx))\n\n    // === Table operations ===\n    TableGet(idx) => {\n      let i = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TTableGet(idx, i))\n    }\n    TableSet(idx) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let i = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TTableSet(idx, i, val))\n    }\n    TableGrow(idx) => {\n      let n = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TTableGrow(idx, val, n))\n    }\n    TableFill(idx) => {\n      let n = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let i = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TTableFill(idx, i, val, n))\n    }\n    TableCopy(dst, src) => {\n      let n = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let s = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let d = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TTableCopy(dst, src, d, s, n))\n    }\n    TableInit(elem_idx, table_idx) => {\n      let n = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let s = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let d = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TTableInit(elem_idx, table_idx, d, s, n))\n    }\n    ElemDrop(idx) => stack.push(TElemDrop(idx))\n\n    // === Select ===\n    Select(types) => {\n      let cond = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let val2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let val1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TSelect(types, cond, val1, val2))\n    }\n\n    // === Control flow ===\n    Block(bt, body) => {\n      let n_inputs = block_type_inputs(bt, env)\n      let inputs = match pop_n(stack, n_inputs) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      // Create a new stack with inputs for the block body\n      let body_stack : Array[TInstr] = []\n      for input in inputs {\n        body_stack.push(input)\n      }\n      for instr in body.0 {\n        match instr_to_tinstr(instr, body_stack, env) {\n          Ok(_) => ()\n          Err(t) => return Err(t)\n        }\n      }\n      stack.push(TBlock(bt, TExpr(body_stack)))\n    }\n    Loop(bt, body) => {\n      let n_inputs = block_type_inputs(bt, env)\n      let inputs = match pop_n(stack, n_inputs) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let body_stack = []\n      for input in inputs {\n        body_stack.push(input)\n      }\n      for instr in body.0 {\n        match instr_to_tinstr(instr, body_stack, env) {\n          Ok(_) => ()\n          Err(t) => return Err(t)\n        }\n      }\n      stack.push(TLoop(bt, TExpr(body_stack)))\n    }\n    If(bt, then_branch, else_branch) => {\n      let cond = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let n_inputs = block_type_inputs(bt, env)\n      let inputs = match pop_n(stack, n_inputs) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let then_stack : Array[TInstr] = []\n      for input in inputs {\n        then_stack.push(input)\n      }\n      for instr in then_branch {\n        match instr_to_tinstr(instr, then_stack, env) {\n          Ok(_) => ()\n          Err(t) => return Err(t)\n        }\n      }\n      let else_texpr : TExpr? = match else_branch {\n        Some(else_instrs) => {\n          let else_stack : Array[TInstr] = []\n          for input in inputs {\n            else_stack.push(input)\n          }\n          for instr in else_instrs {\n            match instr_to_tinstr(instr, else_stack, env) {\n              Ok(_) => ()\n              Err(t) => return Err(t)\n            }\n          }\n          Some(TExpr(else_stack))\n        }\n        None => None\n      }\n      stack.push(TIf(bt, cond, TExpr(then_stack), else_texpr))\n    }\n    TryTable(bt, catches, body) => {\n      let n_inputs = block_type_inputs(bt, env)\n      let inputs = match pop_n(stack, n_inputs) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let body_stack = []\n      for input in inputs {\n        body_stack.push(input)\n      }\n      for instr in body.0 {\n        match instr_to_tinstr(instr, body_stack, env) {\n          Ok(_) => ()\n          Err(t) => return Err(t)\n        }\n      }\n      stack.push(TTryTable(bt, catches, TExpr(body_stack)))\n    }\n    Throw(tag_idx) => {\n      let n_args = match env.resolve_tag_functype(tag_idx) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TThrow(tag_idx, args))\n    }\n\n    // === Branches ===\n    Br(label) => {\n      // Get the arity from label\n      let arity = match env.get_label(label) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBr(label, values))\n    }\n    BrIf(label) => {\n      let cond = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arity = match env.get_label(label) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBrIf(label, cond, values))\n    }\n    BrTable(labels, default) => {\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arity = match env.get_label(default) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBrTable(labels, default, idx, values))\n    }\n    BrOnNull(label) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arity = match env.get_label(label) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBrOnNull(label, ref_, values))\n    }\n    BrOnNonNull(label) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arity = match env.get_label(label) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBrOnNonNull(label, ref_, values))\n    }\n    BrOnCast(label, castop, ht1, ht2) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arity = match env.get_label(label) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBrOnCast(label, castop, ht1, ht2, ref_, values))\n    }\n    BrOnCastFail(label, castop, ht1, ht2) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arity = match env.get_label(label) {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBrOnCastFail(label, castop, ht1, ht2, ref_, values))\n    }\n    Return => {\n      let arity = match env.return_type {\n        Some(types) => types.length()\n        None => 0\n      }\n      let values = match pop_n(stack, arity) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReturn(values))\n    }\n\n    // === Calls ===\n    Call(func_idx) => {\n      let n_args = match env.funcs.get(func_idx.0.reinterpret_as_int()) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TCall(func_idx, args))\n    }\n    CallIndirect(type_idx, table_idx) => {\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let n_args = match env.resolve_functype(type_idx) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TCallIndirect(type_idx, table_idx, args, idx))\n    }\n    CallRef(type_idx) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let n_args = match env.resolve_functype(type_idx) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TCallRef(type_idx, args, ref_))\n    }\n    ReturnCall(func_idx) => {\n      let n_args = match env.funcs.get(func_idx.0.reinterpret_as_int()) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReturnCall(func_idx, args))\n    }\n    ReturnCallIndirect(type_idx, table_idx) => {\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let n_args = match env.resolve_functype(type_idx) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReturnCallIndirect(type_idx, table_idx, args, idx))\n    }\n    ReturnCallRef(type_idx) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let n_args = match env.resolve_functype(type_idx) {\n        Some(FuncType(params, _)) => params.length()\n        None => 0\n      }\n      let args = match pop_n(stack, n_args) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReturnCallRef(type_idx, args, ref_))\n    }\n\n    // === GC: Structs ===\n    StructNew(type_idx) => {\n      let n_fields = match env.resolve_comptype(type_idx) {\n        Some(StructCompType(fields)) => fields.length()\n        _ => 0\n      }\n      let fields = match pop_n(stack, n_fields) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStructNew(type_idx, fields))\n    }\n    StructNewDefault(type_idx) => stack.push(TStructNewDefault(type_idx))\n    StructGet(type_idx, field_idx) => {\n      let struct_ref = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStructGet(type_idx, field_idx, struct_ref))\n    }\n    StructGetS(type_idx, field_idx) => {\n      let struct_ref = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStructGetS(type_idx, field_idx, struct_ref))\n    }\n    StructGetU(type_idx, field_idx) => {\n      let struct_ref = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStructGetU(type_idx, field_idx, struct_ref))\n    }\n    StructSet(type_idx, field_idx) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let struct_ref = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStructSet(type_idx, field_idx, struct_ref, val))\n    }\n\n    // === GC: Arrays ===\n    ArrayNew(type_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let init = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayNew(type_idx, init, len))\n    }\n    ArrayNewDefault(type_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayNewDefault(type_idx, len))\n    }\n    ArrayNewFixed(type_idx, n) => {\n      let elems = match pop_n(stack, n.0.reinterpret_as_int()) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayNewFixed(type_idx, elems))\n    }\n    ArrayNewData(type_idx, data_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let offset = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayNewData(type_idx, data_idx, offset, len))\n    }\n    ArrayNewElem(type_idx, elem_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let offset = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayNewElem(type_idx, elem_idx, offset, len))\n    }\n    ArrayGet(type_idx) => {\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayGet(type_idx, arr, idx))\n    }\n    ArrayGetS(type_idx) => {\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayGetS(type_idx, arr, idx))\n    }\n    ArrayGetU(type_idx) => {\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayGetU(type_idx, arr, idx))\n    }\n    ArraySet(type_idx) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let idx = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArraySet(type_idx, arr, idx, val))\n    }\n    ArrayFill(type_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let offset = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayFill(type_idx, arr, offset, val, len))\n    }\n    ArrayCopy(dst_type, src_type) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let src_offset = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let src = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dst_offset = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dst = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(\n        TArrayCopy(dst_type, src_type, dst, dst_offset, src, src_offset, len),\n      )\n    }\n    ArrayInitData(type_idx, data_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let src = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dst = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayInitData(type_idx, data_idx, arr, dst, src, len))\n    }\n    ArrayInitElem(type_idx, elem_idx) => {\n      let len = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let src = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let dst = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let arr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TArrayInitElem(type_idx, elem_idx, arr, dst, src, len))\n    }\n\n    // === GC: Casts ===\n    RefTest(nullable, ht) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TRefTest(nullable, ht, ref_))\n    }\n    RefCast(nullable, ht) => {\n      let ref_ = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TRefCast(nullable, ht, ref_))\n    }\n\n    // === SIMD ===\n    V128Load(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128LoadOp, memarg, addr))\n    }\n    V128Load8x8S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load8x8SOp, memarg, addr))\n    }\n    V128Load8x8U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load8x8UOp, memarg, addr))\n    }\n    V128Load16x4S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load16x4SOp, memarg, addr))\n    }\n    V128Load16x4U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load16x4UOp, memarg, addr))\n    }\n    V128Load32x2S(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load32x2SOp, memarg, addr))\n    }\n    V128Load32x2U(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load32x2UOp, memarg, addr))\n    }\n    V128Load8Splat(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load8SplatOp, memarg, addr))\n    }\n    V128Load16Splat(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load16SplatOp, memarg, addr))\n    }\n    V128Load32Splat(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load32SplatOp, memarg, addr))\n    }\n    V128Load64Splat(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load64SplatOp, memarg, addr))\n    }\n    V128Load32Zero(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load32ZeroOp, memarg, addr))\n    }\n    V128Load64Zero(memarg) => {\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TLoad(V128Load64ZeroOp, memarg, addr))\n    }\n    V128Store(memarg) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TStore(V128StoreOp, memarg, addr, val))\n    }\n    V128Load8Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128LoadLane(V128Load8LaneOp, memarg, lane, addr, vec))\n    }\n    V128Load16Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128LoadLane(V128Load16LaneOp, memarg, lane, addr, vec))\n    }\n    V128Load32Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128LoadLane(V128Load32LaneOp, memarg, lane, addr, vec))\n    }\n    V128Load64Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128LoadLane(V128Load64LaneOp, memarg, lane, addr, vec))\n    }\n    V128Store8Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128StoreLane(V128Store8LaneOp, memarg, lane, addr, vec))\n    }\n    V128Store16Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128StoreLane(V128Store16LaneOp, memarg, lane, addr, vec))\n    }\n    V128Store32Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128StoreLane(V128Store32LaneOp, memarg, lane, addr, vec))\n    }\n    V128Store64Lane(memarg, lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let addr = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128StoreLane(V128Store64LaneOp, memarg, lane, addr, vec))\n    }\n\n    // === SIMD: Splat ===\n    I8x16Splat => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI8x16Splat(val))\n    }\n    I16x8Splat => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI16x8Splat(val))\n    }\n    I32x4Splat => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI32x4Splat(val))\n    }\n    I64x2Splat => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI64x2Splat(val))\n    }\n    F32x4Splat => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TF32x4Splat(val))\n    }\n    F64x2Splat => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TF64x2Splat(val))\n    }\n\n    // === SIMD: Extract lane ===\n    I8x16ExtractLaneS(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(I8x16ExtractLaneSOp, lane, vec))\n    }\n    I8x16ExtractLaneU(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(I8x16ExtractLaneUOp, lane, vec))\n    }\n    I16x8ExtractLaneS(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(I16x8ExtractLaneSOp, lane, vec))\n    }\n    I16x8ExtractLaneU(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(I16x8ExtractLaneUOp, lane, vec))\n    }\n    I32x4ExtractLane(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(I32x4ExtractLaneOp, lane, vec))\n    }\n    I64x2ExtractLane(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(I64x2ExtractLaneOp, lane, vec))\n    }\n    F32x4ExtractLane(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(F32x4ExtractLaneOp, lane, vec))\n    }\n    F64x2ExtractLane(lane) => {\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TExtractLane(F64x2ExtractLaneOp, lane, vec))\n    }\n\n    // === SIMD: Replace lane ===\n    I8x16ReplaceLane(lane) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReplaceLane(I8x16ReplaceLaneOp, lane, vec, val))\n    }\n    I16x8ReplaceLane(lane) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReplaceLane(I16x8ReplaceLaneOp, lane, vec, val))\n    }\n    I32x4ReplaceLane(lane) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReplaceLane(I32x4ReplaceLaneOp, lane, vec, val))\n    }\n    I64x2ReplaceLane(lane) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReplaceLane(I64x2ReplaceLaneOp, lane, vec, val))\n    }\n    F32x4ReplaceLane(lane) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReplaceLane(F32x4ReplaceLaneOp, lane, vec, val))\n    }\n    F64x2ReplaceLane(lane) => {\n      let val = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TReplaceLane(F64x2ReplaceLaneOp, lane, vec, val))\n    }\n\n    // === SIMD: Shuffle/Swizzle ===\n    I8x16Shuffle(\n      l0,\n      l1,\n      l2,\n      l3,\n      l4,\n      l5,\n      l6,\n      l7,\n      l8,\n      l9,\n      l10,\n      l11,\n      l12,\n      l13,\n      l14,\n      l15\n    ) => {\n      let v2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(\n        TI8x16Shuffle(\n          l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, v1,\n          v2,\n        ),\n      )\n    }\n    I8x16Swizzle => {\n      let indices = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI8x16Swizzle(vec, indices))\n    }\n    I8x16RelaxedSwizzle => {\n      let indices = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TI8x16RelaxedSwizzle(vec, indices))\n    }\n\n    // === SIMD: Unary v128 -> v128 ===\n    V128Not => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(V128NotOp, op))\n    }\n    I8x16Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I8x16AbsOp, op))\n    }\n    I8x16Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I8x16NegOp, op))\n    }\n    I8x16Popcnt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I8x16PopcntOp, op))\n    }\n    I16x8Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8AbsOp, op))\n    }\n    // === SIMD: Unary v128 -> v128 (continued) ===\n    I16x8Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8NegOp, op))\n    }\n    I32x4Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4AbsOp, op))\n    }\n    I32x4Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4NegOp, op))\n    }\n    I64x2Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2AbsOp, op))\n    }\n    I64x2Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2NegOp, op))\n    }\n    F32x4Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4AbsOp, op))\n    }\n    F32x4Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4NegOp, op))\n    }\n    F32x4Sqrt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4SqrtOp, op))\n    }\n    F32x4Ceil => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4CeilOp, op))\n    }\n    F32x4Floor => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4FloorOp, op))\n    }\n    F32x4Trunc => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4TruncOp, op))\n    }\n    F32x4Nearest => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4NearestOp, op))\n    }\n    F64x2Abs => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2AbsOp, op))\n    }\n    F64x2Neg => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2NegOp, op))\n    }\n    F64x2Sqrt => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2SqrtOp, op))\n    }\n    F64x2Ceil => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2CeilOp, op))\n    }\n    F64x2Floor => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2FloorOp, op))\n    }\n    F64x2Trunc => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2TruncOp, op))\n    }\n    F64x2Nearest => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2NearestOp, op))\n    }\n\n    // === SIMD: v128 -> i32 (bitmask/alltrue) ===\n    V128AnyTrue => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(V128AnyTrueOp, op))\n    }\n    I8x16AllTrue => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I8x16AllTrueOp, op))\n    }\n    I8x16Bitmask => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I8x16BitmaskOp, op))\n    }\n    I16x8AllTrue => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8AllTrueOp, op))\n    }\n    I16x8Bitmask => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8BitmaskOp, op))\n    }\n    I32x4AllTrue => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4AllTrueOp, op))\n    }\n    I32x4Bitmask => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4BitmaskOp, op))\n    }\n    I64x2AllTrue => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2AllTrueOp, op))\n    }\n    I64x2Bitmask => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2BitmaskOp, op))\n    }\n\n    // === SIMD: Extend (v128 -> v128) ===\n    I16x8ExtendLowI8x16S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8ExtendLowI8x16SOp, op))\n    }\n    I16x8ExtendHighI8x16S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8ExtendHighI8x16SOp, op))\n    }\n    I16x8ExtendLowI8x16U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8ExtendLowI8x16UOp, op))\n    }\n    I16x8ExtendHighI8x16U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8ExtendHighI8x16UOp, op))\n    }\n    I32x4ExtendLowI16x8S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4ExtendLowI16x8SOp, op))\n    }\n    I32x4ExtendHighI16x8S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4ExtendHighI16x8SOp, op))\n    }\n    I32x4ExtendLowI16x8U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4ExtendLowI16x8UOp, op))\n    }\n    I32x4ExtendHighI16x8U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4ExtendHighI16x8UOp, op))\n    }\n    I64x2ExtendLowI32x4S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2ExtendLowI32x4SOp, op))\n    }\n    I64x2ExtendHighI32x4S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2ExtendHighI32x4SOp, op))\n    }\n    I64x2ExtendLowI32x4U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2ExtendLowI32x4UOp, op))\n    }\n    I64x2ExtendHighI32x4U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I64x2ExtendHighI32x4UOp, op))\n    }\n\n    // === SIMD: Pairwise add (v128 -> v128) ===\n    I16x8ExtaddPairwiseI8x16S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8ExtaddPairwiseI8x16SOp, op))\n    }\n    I16x8ExtaddPairwiseI8x16U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I16x8ExtaddPairwiseI8x16UOp, op))\n    }\n    I32x4ExtaddPairwiseI16x8S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4ExtaddPairwiseI16x8SOp, op))\n    }\n    I32x4ExtaddPairwiseI16x8U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4ExtaddPairwiseI16x8UOp, op))\n    }\n\n    // === SIMD: Conversion (v128 -> v128) ===\n    F32x4DemoteF64x2Zero => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4DemoteF64x2ZeroOp, op))\n    }\n    F64x2PromoteLowF32x4 => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2PromoteLowF32x4Op, op))\n    }\n    I32x4TruncSatF32x4S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4TruncSatF32x4SOp, op))\n    }\n    I32x4TruncSatF32x4U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4TruncSatF32x4UOp, op))\n    }\n    F32x4ConvertI32x4S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4ConvertI32x4SOp, op))\n    }\n    F32x4ConvertI32x4U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F32x4ConvertI32x4UOp, op))\n    }\n    I32x4TruncSatF64x2SZero => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4TruncSatF64x2SZeroOp, op))\n    }\n    I32x4TruncSatF64x2UZero => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4TruncSatF64x2UZeroOp, op))\n    }\n    F64x2ConvertLowI32x4S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2ConvertLowI32x4SOp, op))\n    }\n    F64x2ConvertLowI32x4U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(F64x2ConvertLowI32x4UOp, op))\n    }\n\n    // === SIMD: Relaxed truncation (v128 -> v128) ===\n    I32x4RelaxedTruncF32x4S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4RelaxedTruncF32x4SOp, op))\n    }\n    I32x4RelaxedTruncF32x4U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4RelaxedTruncF32x4UOp, op))\n    }\n    I32x4RelaxedTruncZeroF64x2S => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4RelaxedTruncZeroF64x2SOp, op))\n    }\n    I32x4RelaxedTruncZeroF64x2U => {\n      let op = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TUnary(I32x4RelaxedTruncZeroF64x2UOp, op))\n    }\n\n    // === SIMD: Binary bitwise (v128, v128 -> v128) ===\n    V128And => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(V128AndOp, lhs, rhs))\n    }\n    V128Andnot => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(V128AndnotOp, lhs, rhs))\n    }\n    V128Or => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(V128OrOp, lhs, rhs))\n    }\n    V128Xor => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(V128XorOp, lhs, rhs))\n    }\n\n    // === SIMD: i8x16 comparisons ===\n    I8x16Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16EqOp, lhs, rhs))\n    }\n    I8x16Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16NeOp, lhs, rhs))\n    }\n    I8x16LtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16LtSOp, lhs, rhs))\n    }\n    I8x16LtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16LtUOp, lhs, rhs))\n    }\n    I8x16GtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16GtSOp, lhs, rhs))\n    }\n    I8x16GtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16GtUOp, lhs, rhs))\n    }\n    I8x16LeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16LeSOp, lhs, rhs))\n    }\n    I8x16LeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16LeUOp, lhs, rhs))\n    }\n    I8x16GeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16GeSOp, lhs, rhs))\n    }\n    I8x16GeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16GeUOp, lhs, rhs))\n    }\n\n    // === SIMD: i16x8 comparisons ===\n    I16x8Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8EqOp, lhs, rhs))\n    }\n    I16x8Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8NeOp, lhs, rhs))\n    }\n    I16x8LtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8LtSOp, lhs, rhs))\n    }\n    I16x8LtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8LtUOp, lhs, rhs))\n    }\n    I16x8GtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8GtSOp, lhs, rhs))\n    }\n    I16x8GtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8GtUOp, lhs, rhs))\n    }\n    I16x8LeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8LeSOp, lhs, rhs))\n    }\n    I16x8LeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8LeUOp, lhs, rhs))\n    }\n    I16x8GeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8GeSOp, lhs, rhs))\n    }\n    I16x8GeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8GeUOp, lhs, rhs))\n    }\n\n    // === SIMD: i32x4 comparisons ===\n    I32x4Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4EqOp, lhs, rhs))\n    }\n    I32x4Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4NeOp, lhs, rhs))\n    }\n    I32x4LtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4LtSOp, lhs, rhs))\n    }\n    I32x4LtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4LtUOp, lhs, rhs))\n    }\n    I32x4GtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4GtSOp, lhs, rhs))\n    }\n    I32x4GtU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4GtUOp, lhs, rhs))\n    }\n    I32x4LeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4LeSOp, lhs, rhs))\n    }\n    I32x4LeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4LeUOp, lhs, rhs))\n    }\n    I32x4GeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4GeSOp, lhs, rhs))\n    }\n    I32x4GeU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4GeUOp, lhs, rhs))\n    }\n\n    // === SIMD: i64x2 comparisons ===\n    I64x2Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2EqOp, lhs, rhs))\n    }\n    I64x2Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2NeOp, lhs, rhs))\n    }\n    I64x2LtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2LtSOp, lhs, rhs))\n    }\n    I64x2GtS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2GtSOp, lhs, rhs))\n    }\n    I64x2LeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2LeSOp, lhs, rhs))\n    }\n    I64x2GeS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2GeSOp, lhs, rhs))\n    }\n\n    // === SIMD: f32x4 comparisons ===\n    F32x4Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4EqOp, lhs, rhs))\n    }\n    F32x4Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4NeOp, lhs, rhs))\n    }\n    F32x4Lt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4LtOp, lhs, rhs))\n    }\n    F32x4Gt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4GtOp, lhs, rhs))\n    }\n    F32x4Le => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4LeOp, lhs, rhs))\n    }\n    F32x4Ge => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4GeOp, lhs, rhs))\n    }\n\n    // === SIMD: f64x2 comparisons ===\n    F64x2Eq => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2EqOp, lhs, rhs))\n    }\n    F64x2Ne => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2NeOp, lhs, rhs))\n    }\n    F64x2Lt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2LtOp, lhs, rhs))\n    }\n    F64x2Gt => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2GtOp, lhs, rhs))\n    }\n    F64x2Le => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2LeOp, lhs, rhs))\n    }\n    F64x2Ge => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2GeOp, lhs, rhs))\n    }\n\n    // === SIMD: i8x16 arithmetic ===\n    I8x16Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16AddOp, lhs, rhs))\n    }\n    I8x16AddSatS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16AddSatSOp, lhs, rhs))\n    }\n    I8x16AddSatU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16AddSatUOp, lhs, rhs))\n    }\n    I8x16Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16SubOp, lhs, rhs))\n    }\n    I8x16SubSatS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16SubSatSOp, lhs, rhs))\n    }\n    I8x16SubSatU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16SubSatUOp, lhs, rhs))\n    }\n    I8x16MinS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16MinSOp, lhs, rhs))\n    }\n    I8x16MinU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16MinUOp, lhs, rhs))\n    }\n    I8x16MaxS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16MaxSOp, lhs, rhs))\n    }\n    I8x16MaxU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16MaxUOp, lhs, rhs))\n    }\n    I8x16AvgrU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16AvgrUOp, lhs, rhs))\n    }\n    I8x16NarrowI16x8S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16NarrowI16x8SOp, lhs, rhs))\n    }\n    I8x16NarrowI16x8U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I8x16NarrowI16x8UOp, lhs, rhs))\n    }\n\n    // === SIMD: i16x8 arithmetic ===\n    I16x8Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8AddOp, lhs, rhs))\n    }\n    I16x8AddSatS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8AddSatSOp, lhs, rhs))\n    }\n    I16x8AddSatU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8AddSatUOp, lhs, rhs))\n    }\n    I16x8Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8SubOp, lhs, rhs))\n    }\n    I16x8SubSatS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8SubSatSOp, lhs, rhs))\n    }\n    I16x8SubSatU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8SubSatUOp, lhs, rhs))\n    }\n    I16x8Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8MulOp, lhs, rhs))\n    }\n    I16x8MinS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8MinSOp, lhs, rhs))\n    }\n    I16x8MinU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8MinUOp, lhs, rhs))\n    }\n    I16x8MaxS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8MaxSOp, lhs, rhs))\n    }\n    I16x8MaxU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8MaxUOp, lhs, rhs))\n    }\n    I16x8AvgrU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8AvgrUOp, lhs, rhs))\n    }\n    I16x8Q15mulrSatS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8Q15mulrSatSOp, lhs, rhs))\n    }\n    I16x8NarrowI32x4S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8NarrowI32x4SOp, lhs, rhs))\n    }\n    I16x8NarrowI32x4U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8NarrowI32x4UOp, lhs, rhs))\n    }\n    I16x8ExtmulLowI8x16S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8ExtmulLowI8x16SOp, lhs, rhs))\n    }\n    I16x8ExtmulHighI8x16S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8ExtmulHighI8x16SOp, lhs, rhs))\n    }\n    I16x8ExtmulLowI8x16U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8ExtmulLowI8x16UOp, lhs, rhs))\n    }\n    I16x8ExtmulHighI8x16U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8ExtmulHighI8x16UOp, lhs, rhs))\n    }\n\n    // === SIMD: i32x4 arithmetic ===\n    I32x4Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4AddOp, lhs, rhs))\n    }\n    I32x4Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4SubOp, lhs, rhs))\n    }\n    I32x4Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4MulOp, lhs, rhs))\n    }\n    I32x4MinS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4MinSOp, lhs, rhs))\n    }\n    I32x4MinU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4MinUOp, lhs, rhs))\n    }\n    I32x4MaxS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4MaxSOp, lhs, rhs))\n    }\n    I32x4MaxU => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4MaxUOp, lhs, rhs))\n    }\n    I32x4DotI16x8S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4DotI16x8SOp, lhs, rhs))\n    }\n    I32x4ExtmulLowI16x8S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4ExtmulLowI16x8SOp, lhs, rhs))\n    }\n    I32x4ExtmulHighI16x8S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4ExtmulHighI16x8SOp, lhs, rhs))\n    }\n    I32x4ExtmulLowI16x8U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4ExtmulLowI16x8UOp, lhs, rhs))\n    }\n    I32x4ExtmulHighI16x8U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I32x4ExtmulHighI16x8UOp, lhs, rhs))\n    }\n\n    // === SIMD: i64x2 arithmetic ===\n    I64x2Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2AddOp, lhs, rhs))\n    }\n    I64x2Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2SubOp, lhs, rhs))\n    }\n    I64x2Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2MulOp, lhs, rhs))\n    }\n    I64x2ExtmulLowI32x4S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2ExtmulLowI32x4SOp, lhs, rhs))\n    }\n    I64x2ExtmulHighI32x4S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2ExtmulHighI32x4SOp, lhs, rhs))\n    }\n    I64x2ExtmulLowI32x4U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2ExtmulLowI32x4UOp, lhs, rhs))\n    }\n    I64x2ExtmulHighI32x4U => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I64x2ExtmulHighI32x4UOp, lhs, rhs))\n    }\n\n    // === SIMD: f32x4 arithmetic ===\n    F32x4Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4AddOp, lhs, rhs))\n    }\n    F32x4Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4SubOp, lhs, rhs))\n    }\n    F32x4Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4MulOp, lhs, rhs))\n    }\n    F32x4Div => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4DivOp, lhs, rhs))\n    }\n    F32x4Min => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4MinOp, lhs, rhs))\n    }\n    F32x4Max => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4MaxOp, lhs, rhs))\n    }\n    F32x4Pmin => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4PminOp, lhs, rhs))\n    }\n    F32x4Pmax => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4PmaxOp, lhs, rhs))\n    }\n\n    // === SIMD: f64x2 arithmetic ===\n    F64x2Add => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2AddOp, lhs, rhs))\n    }\n    F64x2Sub => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2SubOp, lhs, rhs))\n    }\n    F64x2Mul => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2MulOp, lhs, rhs))\n    }\n    F64x2Div => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2DivOp, lhs, rhs))\n    }\n    F64x2Min => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2MinOp, lhs, rhs))\n    }\n    F64x2Max => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2MaxOp, lhs, rhs))\n    }\n    F64x2Pmin => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2PminOp, lhs, rhs))\n    }\n    F64x2Pmax => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2PmaxOp, lhs, rhs))\n    }\n\n    // === SIMD: Relaxed binary ===\n    F32x4RelaxedMin => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4RelaxedMinOp, lhs, rhs))\n    }\n    F32x4RelaxedMax => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F32x4RelaxedMaxOp, lhs, rhs))\n    }\n    F64x2RelaxedMin => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2RelaxedMinOp, lhs, rhs))\n    }\n    F64x2RelaxedMax => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(F64x2RelaxedMaxOp, lhs, rhs))\n    }\n    I16x8RelaxedQ15mulrS => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8RelaxedQ15mulrSOp, lhs, rhs))\n    }\n    I16x8RelaxedDotI8x16I7x16S => {\n      let rhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let lhs = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TBinary(I16x8RelaxedDotI8x16I7x16SOp, lhs, rhs))\n    }\n\n    // === SIMD: Shift (v128, i32 -> v128) ===\n    I8x16Shl => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I8x16ShlOp, vec, shift))\n    }\n    I8x16ShrS => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I8x16ShrSOp, vec, shift))\n    }\n    I8x16ShrU => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I8x16ShrUOp, vec, shift))\n    }\n    I16x8Shl => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I16x8ShlOp, vec, shift))\n    }\n    I16x8ShrS => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I16x8ShrSOp, vec, shift))\n    }\n    I16x8ShrU => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I16x8ShrUOp, vec, shift))\n    }\n    I32x4Shl => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I32x4ShlOp, vec, shift))\n    }\n    I32x4ShrS => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I32x4ShrSOp, vec, shift))\n    }\n    I32x4ShrU => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I32x4ShrUOp, vec, shift))\n    }\n    I64x2Shl => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I64x2ShlOp, vec, shift))\n    }\n    I64x2ShrS => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I64x2ShrSOp, vec, shift))\n    }\n    I64x2ShrU => {\n      let shift = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let vec = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Shift(I64x2ShrUOp, vec, shift))\n    }\n\n    // === SIMD: Ternary (v128, v128, v128 -> v128) ===\n    V128Bitselect => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(V128BitselectOp, v1, v2, c))\n    }\n    I8x16RelaxedLaneselect => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(I8x16RelaxedLaneselectOp, v1, v2, c))\n    }\n    I16x8RelaxedLaneselect => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(I16x8RelaxedLaneselectOp, v1, v2, c))\n    }\n    I32x4RelaxedLaneselect => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(I32x4RelaxedLaneselectOp, v1, v2, c))\n    }\n    I64x2RelaxedLaneselect => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v2 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let v1 = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(I64x2RelaxedLaneselectOp, v1, v2, c))\n    }\n    F32x4RelaxedMadd => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let b = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let a = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(F32x4RelaxedMaddOp, a, b, c))\n    }\n    F32x4RelaxedNmadd => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let b = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let a = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(F32x4RelaxedNmaddOp, a, b, c))\n    }\n    F64x2RelaxedMadd => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let b = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let a = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(F64x2RelaxedMaddOp, a, b, c))\n    }\n    F64x2RelaxedNmadd => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let b = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let a = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(F64x2RelaxedNmaddOp, a, b, c))\n    }\n    I32x4RelaxedDotI8x16I7x16AddS => {\n      let c = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let b = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      let a = match pop(stack) {\n        Ok(t) => t\n        Err(t) => return Err(t)\n      }\n      stack.push(TV128Ternary(I32x4RelaxedDotI8x16I7x16AddSOp, a, b, c))\n    }\n  }\n  Ok(())\n}\n\n// ============================================================================\n// TExpr -> Expr helpers\n// ============================================================================\n\n///|\nfn tinstr_to_instr(tinstr : TInstr, instrs : Array[Instruction]) -> Unit {\n  match tinstr {\n    // === Constants ===\n    TI32Const(v) => instrs.push(I32Const(v))\n    TI64Const(v) => instrs.push(I64Const(v))\n    TF32Const(v) => instrs.push(F32Const(v))\n    TF64Const(v) => instrs.push(F64Const(v))\n    TRefNull(ht) => instrs.push(RefNull(ht))\n    TRefFunc(idx) => instrs.push(RefFunc(idx))\n    TV128Const(\n      b0,\n      b1,\n      b2,\n      b3,\n      b4,\n      b5,\n      b6,\n      b7,\n      b8,\n      b9,\n      b10,\n      b11,\n      b12,\n      b13,\n      b14,\n      b15\n    ) =>\n      instrs.push(\n        V128Const(\n          b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,\n        ),\n      )\n\n    // === Nullary ===\n    TUnreachable => instrs.push(Unreachable)\n    TNop => instrs.push(Nop)\n    TLocalGet(idx) => instrs.push(LocalGet(idx))\n    TGlobalGet(idx) => instrs.push(GlobalGet(idx))\n    TMemorySize(idx) => instrs.push(MemorySize(idx))\n    TTableSize(idx) => instrs.push(TableSize(idx))\n\n    // === Unary ===\n    TUnary(op, child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(unary_op_to_instr(op))\n    }\n    TDrop(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(Drop)\n    }\n    TLocalSet(idx, child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(LocalSet(idx))\n    }\n    TLocalTee(idx, child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(LocalTee(idx))\n    }\n    TGlobalSet(idx, child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(GlobalSet(idx))\n    }\n    TRefIsNull(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(RefIsNull)\n    }\n    TRefAsNonNull(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(RefAsNonNull)\n    }\n    TI31GetS(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(I31GetS)\n    }\n    TI31GetU(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(I31GetU)\n    }\n    TRefI31(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(RefI31)\n    }\n    TArrayLen(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(ArrayLen)\n    }\n    TAnyConvertExtern(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(AnyConvertExtern)\n    }\n    TExternConvertAny(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(ExternConvertAny)\n    }\n    TThrowRef(child) => {\n      tinstr_to_instr(child, instrs)\n      instrs.push(ThrowRef)\n    }\n\n    // === Binary ===\n    TBinary(op, lhs, rhs) => {\n      tinstr_to_instr(lhs, instrs)\n      tinstr_to_instr(rhs, instrs)\n      instrs.push(binary_op_to_instr(op))\n    }\n    TRefEq(lhs, rhs) => {\n      tinstr_to_instr(lhs, instrs)\n      tinstr_to_instr(rhs, instrs)\n      instrs.push(RefEq)\n    }\n    TStore(op, memarg, addr, value) => {\n      tinstr_to_instr(addr, instrs)\n      tinstr_to_instr(value, instrs)\n      instrs.push(store_op_to_instr(op, memarg))\n    }\n\n    // === Load ===\n    TLoad(op, memarg, addr) => {\n      tinstr_to_instr(addr, instrs)\n      instrs.push(load_op_to_instr(op, memarg))\n    }\n\n    // === Memory operations ===\n    TMemoryGrow(idx, pages) => {\n      tinstr_to_instr(pages, instrs)\n      instrs.push(MemoryGrow(idx))\n    }\n    TMemoryFill(idx, dest, val, len) => {\n      tinstr_to_instr(dest, instrs)\n      tinstr_to_instr(val, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(MemoryFill(idx))\n    }\n    TMemoryCopy(dst, src, dst_addr, src_addr, len) => {\n      tinstr_to_instr(dst_addr, instrs)\n      tinstr_to_instr(src_addr, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(MemoryCopy(dst, src))\n    }\n    TMemoryInit(data_idx, mem_idx, dst, src, len) => {\n      tinstr_to_instr(dst, instrs)\n      tinstr_to_instr(src, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(MemoryInit(data_idx, mem_idx))\n    }\n    TDataDrop(idx) => instrs.push(DataDrop(idx))\n\n    // === Table operations ===\n    TTableGet(idx, i) => {\n      tinstr_to_instr(i, instrs)\n      instrs.push(TableGet(idx))\n    }\n    TTableSet(idx, i, val) => {\n      tinstr_to_instr(i, instrs)\n      tinstr_to_instr(val, instrs)\n      instrs.push(TableSet(idx))\n    }\n    TTableGrow(idx, val, n) => {\n      tinstr_to_instr(val, instrs)\n      tinstr_to_instr(n, instrs)\n      instrs.push(TableGrow(idx))\n    }\n    TTableFill(idx, i, val, n) => {\n      tinstr_to_instr(i, instrs)\n      tinstr_to_instr(val, instrs)\n      tinstr_to_instr(n, instrs)\n      instrs.push(TableFill(idx))\n    }\n    TTableCopy(dst, src, d, s, n) => {\n      tinstr_to_instr(d, instrs)\n      tinstr_to_instr(s, instrs)\n      tinstr_to_instr(n, instrs)\n      instrs.push(TableCopy(dst, src))\n    }\n    TTableInit(elem_idx, table_idx, d, s, n) => {\n      tinstr_to_instr(d, instrs)\n      tinstr_to_instr(s, instrs)\n      tinstr_to_instr(n, instrs)\n      instrs.push(TableInit(elem_idx, table_idx))\n    }\n    TElemDrop(idx) => instrs.push(ElemDrop(idx))\n\n    // === Calls ===\n    TCall(func_idx, args) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      instrs.push(Call(func_idx))\n    }\n    TCallIndirect(type_idx, table_idx, args, idx) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      tinstr_to_instr(idx, instrs)\n      instrs.push(CallIndirect(type_idx, table_idx))\n    }\n    TCallRef(type_idx, args, ref_) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(CallRef(type_idx))\n    }\n    TReturnCall(func_idx, args) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      instrs.push(ReturnCall(func_idx))\n    }\n    TReturnCallIndirect(type_idx, table_idx, args, idx) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      tinstr_to_instr(idx, instrs)\n      instrs.push(ReturnCallIndirect(type_idx, table_idx))\n    }\n    TReturnCallRef(type_idx, args, ref_) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(ReturnCallRef(type_idx))\n    }\n\n    // === Control flow ===\n    TBlock(bt, body) => {\n      let body_instrs : Array[Instruction] = []\n      for value in body.0 {\n        tinstr_to_instr(value, body_instrs)\n      }\n      instrs.push(Block(bt, Expr(body_instrs)))\n    }\n    TLoop(bt, body) => {\n      let body_instrs : Array[Instruction] = []\n      for value in body.0 {\n        tinstr_to_instr(value, body_instrs)\n      }\n      instrs.push(Loop(bt, Expr(body_instrs)))\n    }\n    TIf(bt, cond, then_branch, else_branch) => {\n      tinstr_to_instr(cond, instrs)\n      let then_instrs : Array[Instruction] = []\n      for value in then_branch.0 {\n        tinstr_to_instr(value, then_instrs)\n      }\n      let else_instrs : Array[Instruction]? = match else_branch {\n        Some(else_body) => {\n          let els : Array[Instruction] = []\n          for value in else_body.0 {\n            tinstr_to_instr(value, els)\n          }\n          Some(els)\n        }\n        None => None\n      }\n      instrs.push(If(bt, then_instrs, else_instrs))\n    }\n    TTryTable(bt, catches, body) => {\n      let body_instrs : Array[Instruction] = []\n      for value in body.0 {\n        tinstr_to_instr(value, body_instrs)\n      }\n      instrs.push(TryTable(bt, catches, Expr(body_instrs)))\n    }\n    TThrow(tag_idx, args) => {\n      for arg in args {\n        tinstr_to_instr(arg, instrs)\n      }\n      instrs.push(Throw(tag_idx))\n    }\n\n    // === Branches ===\n    TBr(label, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      instrs.push(Br(label))\n    }\n    TBrIf(label, cond, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      tinstr_to_instr(cond, instrs)\n      instrs.push(BrIf(label))\n    }\n    TBrTable(labels, default, idx, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      tinstr_to_instr(idx, instrs)\n      instrs.push(BrTable(labels, default))\n    }\n    TBrOnNull(label, ref_, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(BrOnNull(label))\n    }\n    TBrOnNonNull(label, ref_, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(BrOnNonNull(label))\n    }\n    TBrOnCast(label, castop, ht1, ht2, ref_, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(BrOnCast(label, castop, ht1, ht2))\n    }\n    TBrOnCastFail(label, castop, ht1, ht2, ref_, values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(BrOnCastFail(label, castop, ht1, ht2))\n    }\n    TReturn(values) => {\n      for value in values {\n        tinstr_to_instr(value, instrs)\n      }\n      instrs.push(Return)\n    }\n    // === Select ===\n    TSelect(types, cond, val1, val2) => {\n      tinstr_to_instr(val1, instrs)\n      tinstr_to_instr(val2, instrs)\n      tinstr_to_instr(cond, instrs)\n      instrs.push(Select(types))\n    }\n\n    // === GC: Structs ===\n    TStructNew(type_idx, fields) => {\n      for field in fields {\n        tinstr_to_instr(field, instrs)\n      }\n      instrs.push(StructNew(type_idx))\n    }\n    TStructNewDefault(type_idx) => instrs.push(StructNewDefault(type_idx))\n    TStructGet(type_idx, field_idx, struct_ref) => {\n      tinstr_to_instr(struct_ref, instrs)\n      instrs.push(StructGet(type_idx, field_idx))\n    }\n    TStructGetS(type_idx, field_idx, struct_ref) => {\n      tinstr_to_instr(struct_ref, instrs)\n      instrs.push(StructGetS(type_idx, field_idx))\n    }\n    TStructGetU(type_idx, field_idx, struct_ref) => {\n      tinstr_to_instr(struct_ref, instrs)\n      instrs.push(StructGetU(type_idx, field_idx))\n    }\n    TStructSet(type_idx, field_idx, struct_ref, val) => {\n      tinstr_to_instr(struct_ref, instrs)\n      tinstr_to_instr(val, instrs)\n      instrs.push(StructSet(type_idx, field_idx))\n    }\n\n    // === GC: Arrays ===\n    TArrayNew(type_idx, init, len) => {\n      tinstr_to_instr(init, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayNew(type_idx))\n    }\n    TArrayNewDefault(type_idx, len) => {\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayNewDefault(type_idx))\n    }\n    TArrayNewFixed(type_idx, elems) => {\n      for elem in elems {\n        tinstr_to_instr(elem, instrs)\n      }\n      instrs.push(\n        ArrayNewFixed(type_idx, U32(elems.length().reinterpret_as_uint())),\n      )\n    }\n    TArrayNewData(type_idx, data_idx, offset, len) => {\n      tinstr_to_instr(offset, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayNewData(type_idx, data_idx))\n    }\n    TArrayNewElem(type_idx, elem_idx, offset, len) => {\n      tinstr_to_instr(offset, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayNewElem(type_idx, elem_idx))\n    }\n    TArrayGet(type_idx, arr, idx) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(idx, instrs)\n      instrs.push(ArrayGet(type_idx))\n    }\n    TArrayGetS(type_idx, arr, idx) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(idx, instrs)\n      instrs.push(ArrayGetS(type_idx))\n    }\n    TArrayGetU(type_idx, arr, idx) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(idx, instrs)\n      instrs.push(ArrayGetU(type_idx))\n    }\n    TArraySet(type_idx, arr, idx, val) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(idx, instrs)\n      tinstr_to_instr(val, instrs)\n      instrs.push(ArraySet(type_idx))\n    }\n    TArrayFill(type_idx, arr, offset, val, len) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(offset, instrs)\n      tinstr_to_instr(val, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayFill(type_idx))\n    }\n    TArrayCopy(dst_type, src_type, dst, dst_offset, src, src_offset, len) => {\n      tinstr_to_instr(dst, instrs)\n      tinstr_to_instr(dst_offset, instrs)\n      tinstr_to_instr(src, instrs)\n      tinstr_to_instr(src_offset, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayCopy(dst_type, src_type))\n    }\n    TArrayInitData(type_idx, data_idx, arr, dst, src, len) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(dst, instrs)\n      tinstr_to_instr(src, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayInitData(type_idx, data_idx))\n    }\n    TArrayInitElem(type_idx, elem_idx, arr, dst, src, len) => {\n      tinstr_to_instr(arr, instrs)\n      tinstr_to_instr(dst, instrs)\n      tinstr_to_instr(src, instrs)\n      tinstr_to_instr(len, instrs)\n      instrs.push(ArrayInitElem(type_idx, elem_idx))\n    }\n\n    // === GC: Casts ===\n    TRefTest(nullable, ht, ref_) => {\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(RefTest(nullable, ht))\n    }\n    TRefCast(nullable, ht, ref_) => {\n      tinstr_to_instr(ref_, instrs)\n      instrs.push(RefCast(nullable, ht))\n    }\n\n    // === SIMD: Splat ===\n    TI8x16Splat(val) => {\n      tinstr_to_instr(val, instrs)\n      instrs.push(I8x16Splat)\n    }\n    TI16x8Splat(val) => {\n      tinstr_to_instr(val, instrs)\n      instrs.push(I16x8Splat)\n    }\n    TI32x4Splat(val) => {\n      tinstr_to_instr(val, instrs)\n      instrs.push(I32x4Splat)\n    }\n    TI64x2Splat(val) => {\n      tinstr_to_instr(val, instrs)\n      instrs.push(I64x2Splat)\n    }\n    TF32x4Splat(val) => {\n      tinstr_to_instr(val, instrs)\n      instrs.push(F32x4Splat)\n    }\n    TF64x2Splat(val) => {\n      tinstr_to_instr(val, instrs)\n      instrs.push(F64x2Splat)\n    }\n\n    // === SIMD: Extract lane ===\n    TExtractLane(op, lane, vec) => {\n      tinstr_to_instr(vec, instrs)\n      instrs.push(extract_lane_op_to_instr(op, lane))\n    }\n\n    // === SIMD: Replace lane ===\n    TReplaceLane(op, lane, vec, val) => {\n      tinstr_to_instr(vec, instrs)\n      tinstr_to_instr(val, instrs)\n      instrs.push(replace_lane_op_to_instr(op, lane))\n    }\n\n    // === SIMD: Shuffle ===\n    TI8x16Shuffle(\n      l0,\n      l1,\n      l2,\n      l3,\n      l4,\n      l5,\n      l6,\n      l7,\n      l8,\n      l9,\n      l10,\n      l11,\n      l12,\n      l13,\n      l14,\n      l15,\n      v1,\n      v2\n    ) => {\n      tinstr_to_instr(v1, instrs)\n      tinstr_to_instr(v2, instrs)\n      instrs.push(\n        I8x16Shuffle(\n          l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15,\n        ),\n      )\n    }\n\n    // === SIMD: Swizzle ===\n    TI8x16Swizzle(vec, indices) => {\n      tinstr_to_instr(vec, instrs)\n      tinstr_to_instr(indices, instrs)\n      instrs.push(I8x16Swizzle)\n    }\n    TI8x16RelaxedSwizzle(vec, indices) => {\n      tinstr_to_instr(vec, instrs)\n      tinstr_to_instr(indices, instrs)\n      instrs.push(I8x16RelaxedSwizzle)\n    }\n\n    // === SIMD: Shift ===\n    TV128Shift(op, vec, shift) => {\n      tinstr_to_instr(vec, instrs)\n      tinstr_to_instr(shift, instrs)\n      instrs.push(v128_shift_op_to_instr(op))\n    }\n\n    // === SIMD: Ternary ===\n    TV128Ternary(op, v1, v2, v3) => {\n      tinstr_to_instr(v1, instrs)\n      tinstr_to_instr(v2, instrs)\n      tinstr_to_instr(v3, instrs)\n      instrs.push(v128_ternary_op_to_instr(op))\n    }\n\n    // === SIMD: Lane load ===\n    TV128LoadLane(op, memarg, lane, addr, vec) => {\n      tinstr_to_instr(addr, instrs)\n      tinstr_to_instr(vec, instrs)\n      instrs.push(v128_load_lane_op_to_instr(op, memarg, lane))\n    }\n\n    // === SIMD: Lane store ===\n    TV128StoreLane(op, memarg, lane, addr, vec) => {\n      tinstr_to_instr(addr, instrs)\n      tinstr_to_instr(vec, instrs)\n      instrs.push(v128_store_lane_op_to_instr(op, memarg, lane))\n    }\n  }\n}\n\n// ============================================================================\n// Op to Instruction helpers\n// ============================================================================\n\n///|\nfn unary_op_to_instr(op : UnaryOp) -> Instruction {\n  match op {\n    I32EqzOp => I32Eqz\n    I64EqzOp => I64Eqz\n    I32ClzOp => I32Clz\n    I32CtzOp => I32Ctz\n    I32PopcntOp => I32Popcnt\n    I64ClzOp => I64Clz\n    I64CtzOp => I64Ctz\n    I64PopcntOp => I64Popcnt\n    F32AbsOp => F32Abs\n    F32NegOp => F32Neg\n    F32CeilOp => F32Ceil\n    F32FloorOp => F32Floor\n    F32TruncOp => F32Trunc\n    F32NearestOp => F32Nearest\n    F32SqrtOp => F32Sqrt\n    F64AbsOp => F64Abs\n    F64NegOp => F64Neg\n    F64CeilOp => F64Ceil\n    F64FloorOp => F64Floor\n    F64TruncOp => F64Trunc\n    F64NearestOp => F64Nearest\n    F64SqrtOp => F64Sqrt\n    I32WrapI64Op => I32WrapI64\n    I32TruncF32SOp => I32TruncF32S\n    I32TruncF32UOp => I32TruncF32U\n    I32TruncF64SOp => I32TruncF64S\n    I32TruncF64UOp => I32TruncF64U\n    I64ExtendI32SOp => I64ExtendI32S\n    I64ExtendI32UOp => I64ExtendI32U\n    I64TruncF32SOp => I64TruncF32S\n    I64TruncF32UOp => I64TruncF32U\n    I64TruncF64SOp => I64TruncF64S\n    I64TruncF64UOp => I64TruncF64U\n    F32ConvertI32SOp => F32ConvertI32S\n    F32ConvertI32UOp => F32ConvertI32U\n    F32ConvertI64SOp => F32ConvertI64S\n    F32ConvertI64UOp => F32ConvertI64U\n    F32DemoteF64Op => F32DemoteF64\n    F64ConvertI32SOp => F64ConvertI32S\n    F64ConvertI32UOp => F64ConvertI32U\n    F64ConvertI64SOp => F64ConvertI64S\n    F64ConvertI64UOp => F64ConvertI64U\n    F64PromoteF32Op => F64PromoteF32\n    I32ReinterpretF32Op => I32ReinterpretF32\n    I64ReinterpretF64Op => I64ReinterpretF64\n    F32ReinterpretI32Op => F32ReinterpretI32\n    F64ReinterpretI64Op => F64ReinterpretI64\n    I32Extend8SOp => I32Extend8S\n    I32Extend16SOp => I32Extend16S\n    I64Extend8SOp => I64Extend8S\n    I64Extend16SOp => I64Extend16S\n    I64Extend32SOp => I64Extend32S\n    I32TruncSatF32SOp => I32TruncSatF32S\n    I32TruncSatF32UOp => I32TruncSatF32U\n    I32TruncSatF64SOp => I32TruncSatF64S\n    I32TruncSatF64UOp => I32TruncSatF64U\n    I64TruncSatF32SOp => I64TruncSatF32S\n    I64TruncSatF32UOp => I64TruncSatF32U\n    I64TruncSatF64SOp => I64TruncSatF64S\n    I64TruncSatF64UOp => I64TruncSatF64U\n    // SIMD v128 -> v128\n    V128NotOp => V128Not\n    I8x16AbsOp => I8x16Abs\n    I8x16NegOp => I8x16Neg\n    I8x16PopcntOp => I8x16Popcnt\n    I16x8AbsOp => I16x8Abs\n    I16x8NegOp => I16x8Neg\n    I32x4AbsOp => I32x4Abs\n    I32x4NegOp => I32x4Neg\n    I64x2AbsOp => I64x2Abs\n    I64x2NegOp => I64x2Neg\n    F32x4AbsOp => F32x4Abs\n    F32x4NegOp => F32x4Neg\n    F32x4SqrtOp => F32x4Sqrt\n    F32x4CeilOp => F32x4Ceil\n    F32x4FloorOp => F32x4Floor\n    F32x4TruncOp => F32x4Trunc\n    F32x4NearestOp => F32x4Nearest\n    F64x2AbsOp => F64x2Abs\n    F64x2NegOp => F64x2Neg\n    F64x2SqrtOp => F64x2Sqrt\n    F64x2CeilOp => F64x2Ceil\n    F64x2FloorOp => F64x2Floor\n    F64x2TruncOp => F64x2Trunc\n    F64x2NearestOp => F64x2Nearest\n    // SIMD v128 -> i32\n    V128AnyTrueOp => V128AnyTrue\n    I8x16AllTrueOp => I8x16AllTrue\n    I8x16BitmaskOp => I8x16Bitmask\n    I16x8AllTrueOp => I16x8AllTrue\n    I16x8BitmaskOp => I16x8Bitmask\n    I32x4AllTrueOp => I32x4AllTrue\n    I32x4BitmaskOp => I32x4Bitmask\n    I64x2AllTrueOp => I64x2AllTrue\n    I64x2BitmaskOp => I64x2Bitmask\n    // SIMD extend\n    I16x8ExtendLowI8x16SOp => I16x8ExtendLowI8x16S\n    I16x8ExtendHighI8x16SOp => I16x8ExtendHighI8x16S\n    I16x8ExtendLowI8x16UOp => I16x8ExtendLowI8x16U\n    I16x8ExtendHighI8x16UOp => I16x8ExtendHighI8x16U\n    I32x4ExtendLowI16x8SOp => I32x4ExtendLowI16x8S\n    I32x4ExtendHighI16x8SOp => I32x4ExtendHighI16x8S\n    I32x4ExtendLowI16x8UOp => I32x4ExtendLowI16x8U\n    I32x4ExtendHighI16x8UOp => I32x4ExtendHighI16x8U\n    I64x2ExtendLowI32x4SOp => I64x2ExtendLowI32x4S\n    I64x2ExtendHighI32x4SOp => I64x2ExtendHighI32x4S\n    I64x2ExtendLowI32x4UOp => I64x2ExtendLowI32x4U\n    I64x2ExtendHighI32x4UOp => I64x2ExtendHighI32x4U\n    // SIMD pairwise add\n    I16x8ExtaddPairwiseI8x16SOp => I16x8ExtaddPairwiseI8x16S\n    I16x8ExtaddPairwiseI8x16UOp => I16x8ExtaddPairwiseI8x16U\n    I32x4ExtaddPairwiseI16x8SOp => I32x4ExtaddPairwiseI16x8S\n    I32x4ExtaddPairwiseI16x8UOp => I32x4ExtaddPairwiseI16x8U\n    // SIMD conversion\n    F32x4DemoteF64x2ZeroOp => F32x4DemoteF64x2Zero\n    F64x2PromoteLowF32x4Op => F64x2PromoteLowF32x4\n    I32x4TruncSatF32x4SOp => I32x4TruncSatF32x4S\n    I32x4TruncSatF32x4UOp => I32x4TruncSatF32x4U\n    F32x4ConvertI32x4SOp => F32x4ConvertI32x4S\n    F32x4ConvertI32x4UOp => F32x4ConvertI32x4U\n    I32x4TruncSatF64x2SZeroOp => I32x4TruncSatF64x2SZero\n    I32x4TruncSatF64x2UZeroOp => I32x4TruncSatF64x2UZero\n    F64x2ConvertLowI32x4SOp => F64x2ConvertLowI32x4S\n    F64x2ConvertLowI32x4UOp => F64x2ConvertLowI32x4U\n    // SIMD relaxed truncation\n    I32x4RelaxedTruncF32x4SOp => I32x4RelaxedTruncF32x4S\n    I32x4RelaxedTruncF32x4UOp => I32x4RelaxedTruncF32x4U\n    I32x4RelaxedTruncZeroF64x2SOp => I32x4RelaxedTruncZeroF64x2S\n    I32x4RelaxedTruncZeroF64x2UOp => I32x4RelaxedTruncZeroF64x2U\n  }\n}\n\n///|\nfn binary_op_to_instr(op : BinaryOp) -> Instruction {\n  match op {\n    I32EqOp => I32Eq\n    I32NeOp => I32Ne\n    I32LtSOp => I32LtS\n    I32LtUOp => I32LtU\n    I32GtSOp => I32GtS\n    I32GtUOp => I32GtU\n    I32LeSOp => I32LeS\n    I32LeUOp => I32LeU\n    I32GeSOp => I32GeS\n    I32GeUOp => I32GeU\n    I64EqOp => I64Eq\n    I64NeOp => I64Ne\n    I64LtSOp => I64LtS\n    I64LtUOp => I64LtU\n    I64GtSOp => I64GtS\n    I64GtUOp => I64GtU\n    I64LeSOp => I64LeS\n    I64LeUOp => I64LeU\n    I64GeSOp => I64GeS\n    I64GeUOp => I64GeU\n    F32EqOp => F32Eq\n    F32NeOp => F32Ne\n    F32LtOp => F32Lt\n    F32GtOp => F32Gt\n    F32LeOp => F32Le\n    F32GeOp => F32Ge\n    F64EqOp => F64Eq\n    F64NeOp => F64Ne\n    F64LtOp => F64Lt\n    F64GtOp => F64Gt\n    F64LeOp => F64Le\n    F64GeOp => F64Ge\n    I32AddOp => I32Add\n    I32SubOp => I32Sub\n    I32MulOp => I32Mul\n    I32DivSOp => I32DivS\n    I32DivUOp => I32DivU\n    I32RemSOp => I32RemS\n    I32RemUOp => I32RemU\n    I32AndOp => I32And\n    I32OrOp => I32Or\n    I32XorOp => I32Xor\n    I32ShlOp => I32Shl\n    I32ShrSOp => I32ShrS\n    I32ShrUOp => I32ShrU\n    I32RotlOp => I32Rotl\n    I32RotrOp => I32Rotr\n    I64AddOp => I64Add\n    I64SubOp => I64Sub\n    I64MulOp => I64Mul\n    I64DivSOp => I64DivS\n    I64DivUOp => I64DivU\n    I64RemSOp => I64RemS\n    I64RemUOp => I64RemU\n    I64AndOp => I64And\n    I64OrOp => I64Or\n    I64XorOp => I64Xor\n    I64ShlOp => I64Shl\n    I64ShrSOp => I64ShrS\n    I64ShrUOp => I64ShrU\n    I64RotlOp => I64Rotl\n    I64RotrOp => I64Rotr\n    F32AddOp => F32Add\n    F32SubOp => F32Sub\n    F32MulOp => F32Mul\n    F32DivOp => F32Div\n    F32MinOp => F32Min\n    F32MaxOp => F32Max\n    F32CopysignOp => F32Copysign\n    F64AddOp => F64Add\n    F64SubOp => F64Sub\n    F64MulOp => F64Mul\n    F64DivOp => F64Div\n    F64MinOp => F64Min\n    F64MaxOp => F64Max\n    F64CopysignOp => F64Copysign\n    // SIMD bitwise\n    V128AndOp => V128And\n    V128AndnotOp => V128Andnot\n    V128OrOp => V128Or\n    V128XorOp => V128Xor\n    // SIMD i8x16 comparisons\n    I8x16EqOp => I8x16Eq\n    I8x16NeOp => I8x16Ne\n    I8x16LtSOp => I8x16LtS\n    I8x16LtUOp => I8x16LtU\n    I8x16GtSOp => I8x16GtS\n    I8x16GtUOp => I8x16GtU\n    I8x16LeSOp => I8x16LeS\n    I8x16LeUOp => I8x16LeU\n    I8x16GeSOp => I8x16GeS\n    I8x16GeUOp => I8x16GeU\n    // SIMD i16x8 comparisons\n    I16x8EqOp => I16x8Eq\n    I16x8NeOp => I16x8Ne\n    I16x8LtSOp => I16x8LtS\n    I16x8LtUOp => I16x8LtU\n    I16x8GtSOp => I16x8GtS\n    I16x8GtUOp => I16x8GtU\n    I16x8LeSOp => I16x8LeS\n    I16x8LeUOp => I16x8LeU\n    I16x8GeSOp => I16x8GeS\n    I16x8GeUOp => I16x8GeU\n    // SIMD i32x4 comparisons\n    I32x4EqOp => I32x4Eq\n    I32x4NeOp => I32x4Ne\n    I32x4LtSOp => I32x4LtS\n    I32x4LtUOp => I32x4LtU\n    I32x4GtSOp => I32x4GtS\n    I32x4GtUOp => I32x4GtU\n    I32x4LeSOp => I32x4LeS\n    I32x4LeUOp => I32x4LeU\n    I32x4GeSOp => I32x4GeS\n    I32x4GeUOp => I32x4GeU\n    // SIMD i64x2 comparisons\n    I64x2EqOp => I64x2Eq\n    I64x2NeOp => I64x2Ne\n    I64x2LtSOp => I64x2LtS\n    I64x2GtSOp => I64x2GtS\n    I64x2LeSOp => I64x2LeS\n    I64x2GeSOp => I64x2GeS\n    // SIMD f32x4 comparisons\n    F32x4EqOp => F32x4Eq\n    F32x4NeOp => F32x4Ne\n    F32x4LtOp => F32x4Lt\n    F32x4GtOp => F32x4Gt\n    F32x4LeOp => F32x4Le\n    F32x4GeOp => F32x4Ge\n    // SIMD f64x2 comparisons\n    F64x2EqOp => F64x2Eq\n    F64x2NeOp => F64x2Ne\n    F64x2LtOp => F64x2Lt\n    F64x2GtOp => F64x2Gt\n    F64x2LeOp => F64x2Le\n    F64x2GeOp => F64x2Ge\n    // SIMD i8x16 arithmetic\n    I8x16AddOp => I8x16Add\n    I8x16AddSatSOp => I8x16AddSatS\n    I8x16AddSatUOp => I8x16AddSatU\n    I8x16SubOp => I8x16Sub\n    I8x16SubSatSOp => I8x16SubSatS\n    I8x16SubSatUOp => I8x16SubSatU\n    I8x16MinSOp => I8x16MinS\n    I8x16MinUOp => I8x16MinU\n    I8x16MaxSOp => I8x16MaxS\n    I8x16MaxUOp => I8x16MaxU\n    I8x16AvgrUOp => I8x16AvgrU\n    I8x16NarrowI16x8SOp => I8x16NarrowI16x8S\n    I8x16NarrowI16x8UOp => I8x16NarrowI16x8U\n    // SIMD i16x8 arithmetic\n    I16x8AddOp => I16x8Add\n    I16x8AddSatSOp => I16x8AddSatS\n    I16x8AddSatUOp => I16x8AddSatU\n    I16x8SubOp => I16x8Sub\n    I16x8SubSatSOp => I16x8SubSatS\n    I16x8SubSatUOp => I16x8SubSatU\n    I16x8MulOp => I16x8Mul\n    I16x8MinSOp => I16x8MinS\n    I16x8MinUOp => I16x8MinU\n    I16x8MaxSOp => I16x8MaxS\n    I16x8MaxUOp => I16x8MaxU\n    I16x8AvgrUOp => I16x8AvgrU\n    I16x8Q15mulrSatSOp => I16x8Q15mulrSatS\n    I16x8NarrowI32x4SOp => I16x8NarrowI32x4S\n    I16x8NarrowI32x4UOp => I16x8NarrowI32x4U\n    I16x8ExtmulLowI8x16SOp => I16x8ExtmulLowI8x16S\n    I16x8ExtmulHighI8x16SOp => I16x8ExtmulHighI8x16S\n    I16x8ExtmulLowI8x16UOp => I16x8ExtmulLowI8x16U\n    I16x8ExtmulHighI8x16UOp => I16x8ExtmulHighI8x16U\n    // SIMD i32x4 arithmetic\n    I32x4AddOp => I32x4Add\n    I32x4SubOp => I32x4Sub\n    I32x4MulOp => I32x4Mul\n    I32x4MinSOp => I32x4MinS\n    I32x4MinUOp => I32x4MinU\n    I32x4MaxSOp => I32x4MaxS\n    I32x4MaxUOp => I32x4MaxU\n    I32x4DotI16x8SOp => I32x4DotI16x8S\n    I32x4ExtmulLowI16x8SOp => I32x4ExtmulLowI16x8S\n    I32x4ExtmulHighI16x8SOp => I32x4ExtmulHighI16x8S\n    I32x4ExtmulLowI16x8UOp => I32x4ExtmulLowI16x8U\n    I32x4ExtmulHighI16x8UOp => I32x4ExtmulHighI16x8U\n    // SIMD i64x2 arithmetic\n    I64x2AddOp => I64x2Add\n    I64x2SubOp => I64x2Sub\n    I64x2MulOp => I64x2Mul\n    I64x2ExtmulLowI32x4SOp => I64x2ExtmulLowI32x4S\n    I64x2ExtmulHighI32x4SOp => I64x2ExtmulHighI32x4S\n    I64x2ExtmulLowI32x4UOp => I64x2ExtmulLowI32x4U\n    I64x2ExtmulHighI32x4UOp => I64x2ExtmulHighI32x4U\n    // SIMD f32x4 arithmetic\n    F32x4AddOp => F32x4Add\n    F32x4SubOp => F32x4Sub\n    F32x4MulOp => F32x4Mul\n    F32x4DivOp => F32x4Div\n    F32x4MinOp => F32x4Min\n    F32x4MaxOp => F32x4Max\n    F32x4PminOp => F32x4Pmin\n    F32x4PmaxOp => F32x4Pmax\n    // SIMD f64x2 arithmetic\n    F64x2AddOp => F64x2Add\n    F64x2SubOp => F64x2Sub\n    F64x2MulOp => F64x2Mul\n    F64x2DivOp => F64x2Div\n    F64x2MinOp => F64x2Min\n    F64x2MaxOp => F64x2Max\n    F64x2PminOp => F64x2Pmin\n    F64x2PmaxOp => F64x2Pmax\n    // SIMD relaxed\n    F32x4RelaxedMinOp => F32x4RelaxedMin\n    F32x4RelaxedMaxOp => F32x4RelaxedMax\n    F64x2RelaxedMinOp => F64x2RelaxedMin\n    F64x2RelaxedMaxOp => F64x2RelaxedMax\n    I16x8RelaxedQ15mulrSOp => I16x8RelaxedQ15mulrS\n    I16x8RelaxedDotI8x16I7x16SOp => I16x8RelaxedDotI8x16I7x16S\n  }\n}\n\n///|\nfn load_op_to_instr(op : LoadOp, memarg : MemArg) -> Instruction {\n  match op {\n    I32LoadOp => I32Load(memarg)\n    I64LoadOp => I64Load(memarg)\n    F32LoadOp => F32Load(memarg)\n    F64LoadOp => F64Load(memarg)\n    I32Load8SOp => I32Load8S(memarg)\n    I32Load8UOp => I32Load8U(memarg)\n    I32Load16SOp => I32Load16S(memarg)\n    I32Load16UOp => I32Load16U(memarg)\n    I64Load8SOp => I64Load8S(memarg)\n    I64Load8UOp => I64Load8U(memarg)\n    I64Load16SOp => I64Load16S(memarg)\n    I64Load16UOp => I64Load16U(memarg)\n    I64Load32SOp => I64Load32S(memarg)\n    I64Load32UOp => I64Load32U(memarg)\n    V128LoadOp => V128Load(memarg)\n    V128Load8x8SOp => V128Load8x8S(memarg)\n    V128Load8x8UOp => V128Load8x8U(memarg)\n    V128Load16x4SOp => V128Load16x4S(memarg)\n    V128Load16x4UOp => V128Load16x4U(memarg)\n    V128Load32x2SOp => V128Load32x2S(memarg)\n    V128Load32x2UOp => V128Load32x2U(memarg)\n    V128Load8SplatOp => V128Load8Splat(memarg)\n    V128Load16SplatOp => V128Load16Splat(memarg)\n    V128Load32SplatOp => V128Load32Splat(memarg)\n    V128Load64SplatOp => V128Load64Splat(memarg)\n    V128Load32ZeroOp => V128Load32Zero(memarg)\n    V128Load64ZeroOp => V128Load64Zero(memarg)\n  }\n}\n\n///|\nfn store_op_to_instr(op : StoreOp, memarg : MemArg) -> Instruction {\n  match op {\n    I32StoreOp => I32Store(memarg)\n    I64StoreOp => I64Store(memarg)\n    F32StoreOp => F32Store(memarg)\n    F64StoreOp => F64Store(memarg)\n    I32Store8Op => I32Store8(memarg)\n    I32Store16Op => I32Store16(memarg)\n    I64Store8Op => I64Store8(memarg)\n    I64Store16Op => I64Store16(memarg)\n    I64Store32Op => I64Store32(memarg)\n    V128StoreOp => V128Store(memarg)\n  }\n}\n\n///|\nfn extract_lane_op_to_instr(op : ExtractLaneOp, lane : LaneIdx) -> Instruction {\n  match op {\n    I8x16ExtractLaneSOp => I8x16ExtractLaneS(lane)\n    I8x16ExtractLaneUOp => I8x16ExtractLaneU(lane)\n    I16x8ExtractLaneSOp => I16x8ExtractLaneS(lane)\n    I16x8ExtractLaneUOp => I16x8ExtractLaneU(lane)\n    I32x4ExtractLaneOp => I32x4ExtractLane(lane)\n    I64x2ExtractLaneOp => I64x2ExtractLane(lane)\n    F32x4ExtractLaneOp => F32x4ExtractLane(lane)\n    F64x2ExtractLaneOp => F64x2ExtractLane(lane)\n  }\n}\n\n///|\nfn replace_lane_op_to_instr(op : ReplaceLaneOp, lane : LaneIdx) -> Instruction {\n  match op {\n    I8x16ReplaceLaneOp => I8x16ReplaceLane(lane)\n    I16x8ReplaceLaneOp => I16x8ReplaceLane(lane)\n    I32x4ReplaceLaneOp => I32x4ReplaceLane(lane)\n    I64x2ReplaceLaneOp => I64x2ReplaceLane(lane)\n    F32x4ReplaceLaneOp => F32x4ReplaceLane(lane)\n    F64x2ReplaceLaneOp => F64x2ReplaceLane(lane)\n  }\n}\n\n///|\nfn v128_shift_op_to_instr(op : V128ShiftOp) -> Instruction {\n  match op {\n    I8x16ShlOp => I8x16Shl\n    I8x16ShrSOp => I8x16ShrS\n    I8x16ShrUOp => I8x16ShrU\n    I16x8ShlOp => I16x8Shl\n    I16x8ShrSOp => I16x8ShrS\n    I16x8ShrUOp => I16x8ShrU\n    I32x4ShlOp => I32x4Shl\n    I32x4ShrSOp => I32x4ShrS\n    I32x4ShrUOp => I32x4ShrU\n    I64x2ShlOp => I64x2Shl\n    I64x2ShrSOp => I64x2ShrS\n    I64x2ShrUOp => I64x2ShrU\n  }\n}\n\n///|\nfn v128_ternary_op_to_instr(op : V128TernaryOp) -> Instruction {\n  match op {\n    V128BitselectOp => V128Bitselect\n    I8x16RelaxedLaneselectOp => I8x16RelaxedLaneselect\n    I16x8RelaxedLaneselectOp => I16x8RelaxedLaneselect\n    I32x4RelaxedLaneselectOp => I32x4RelaxedLaneselect\n    I64x2RelaxedLaneselectOp => I64x2RelaxedLaneselect\n    F32x4RelaxedMaddOp => F32x4RelaxedMadd\n    F32x4RelaxedNmaddOp => F32x4RelaxedNmadd\n    F64x2RelaxedMaddOp => F64x2RelaxedMadd\n    F64x2RelaxedNmaddOp => F64x2RelaxedNmadd\n    I32x4RelaxedDotI8x16I7x16AddSOp => I32x4RelaxedDotI8x16I7x16AddS\n  }\n}\n\n///|\nfn v128_load_lane_op_to_instr(\n  op : V128LoadLaneOp,\n  memarg : MemArg,\n  lane : LaneIdx,\n) -> Instruction {\n  match op {\n    V128Load8LaneOp => V128Load8Lane(memarg, lane)\n    V128Load16LaneOp => V128Load16Lane(memarg, lane)\n    V128Load32LaneOp => V128Load32Lane(memarg, lane)\n    V128Load64LaneOp => V128Load64Lane(memarg, lane)\n  }\n}\n\n///|\nfn v128_store_lane_op_to_instr(\n  op : V128StoreLaneOp,\n  memarg : MemArg,\n  lane : LaneIdx,\n) -> Instruction {\n  match op {\n    V128Store8LaneOp => V128Store8Lane(memarg, lane)\n    V128Store16LaneOp => V128Store16Lane(memarg, lane)\n    V128Store32LaneOp => V128Store32Lane(memarg, lane)\n    V128Store64LaneOp => V128Store64Lane(memarg, lane)\n  }\n}\n\n///|\npub fn tlocals_to_locals(tlocals : Array[ValType]) -> Array[Locals] {\n  if tlocals.length() == 0 {\n    return []\n  }\n  let end = tlocals.length()\n  let mut current = tlocals[0]\n  let mut count = 1U\n  let acc = []\n  loop 1 {\n    n if n == end => {\n      acc.push(Locals(count, current))\n      break acc\n    }\n    n => {\n      let next = tlocals[n]\n      if current == next {\n        count = count + 1\n      } else {\n        acc.push(Locals(count, current))\n        count = 1\n        current = next\n      }\n      continue n + 1\n    }\n  }\n}\n","///|\npub type TransformerResult[T, Elem] = Result[(T, Elem)?, String]\n\n///|\npub fn[T, Elem] change(t : T, elem : Elem) -> TransformerResult[T, Elem] {\n  Ok(Some((t, elem)))\n}\n\n///|\npub fn[T, Elem] unchanged() -> TransformerResult[T, Elem] {\n  Ok(None)\n}\n\n///|\npub fn[T, Elem] error(err : String) -> TransformerResult[T, Elem] {\n  Err(err)\n}\n\n// Transformer Definition\n\n///|\npub(all) struct ModuleTransformer[T] {\n  on_typesec : ((ModuleTransformer[T], T, TypeSec) -> TransformerResult[\n    T,\n    TypeSec,\n  ])?\n  on_funcsec : ((ModuleTransformer[T], T, FuncSec) -> TransformerResult[\n    T,\n    FuncSec,\n  ])?\n  on_tablesec : ((ModuleTransformer[T], T, TableSec) -> TransformerResult[\n    T,\n    TableSec,\n  ])?\n  on_memsec : ((ModuleTransformer[T], T, MemSec) -> TransformerResult[T, MemSec])?\n  on_tagsec : ((ModuleTransformer[T], T, TagSec) -> TransformerResult[T, TagSec])?\n  on_globalsec : ((ModuleTransformer[T], T, GlobalSec) -> TransformerResult[\n    T,\n    GlobalSec,\n  ])?\n  on_exportsec : ((ModuleTransformer[T], T, ExportSec) -> TransformerResult[\n    T,\n    ExportSec,\n  ])?\n  on_startsec : ((ModuleTransformer[T], T, StartSec) -> TransformerResult[\n    T,\n    StartSec,\n  ])?\n  on_elemsec : ((ModuleTransformer[T], T, ElemSec) -> TransformerResult[\n    T,\n    ElemSec,\n  ])?\n  on_elemkind : ((ModuleTransformer[T], T, ElemKind) -> TransformerResult[\n    T,\n    ElemKind,\n  ])?\n  on_datacntsec : ((ModuleTransformer[T], T, DataCntSec) -> TransformerResult[\n    T,\n    DataCntSec,\n  ])?\n  on_codesec : ((ModuleTransformer[T], T, CodeSec) -> TransformerResult[\n    T,\n    CodeSec,\n  ])?\n  on_datasec : ((ModuleTransformer[T], T, DataSec) -> TransformerResult[\n    T,\n    DataSec,\n  ])?\n  on_instruction : ((ModuleTransformer[T], T, Instruction) -> TransformerResult[\n    T,\n    Instruction,\n  ])?\n  on_tinstruction : ((ModuleTransformer[T], T, TInstr) -> TransformerResult[\n    T,\n    TInstr,\n  ])?\n  on_expr : ((ModuleTransformer[T], T, Expr) -> TransformerResult[T, Expr])?\n  on_texpr : ((ModuleTransformer[T], T, TExpr) -> TransformerResult[T, TExpr])?\n  on_table : ((ModuleTransformer[T], T, Table) -> TransformerResult[T, Table])?\n  on_valtype : ((ModuleTransformer[T], T, ValType) -> TransformerResult[\n    T,\n    ValType,\n  ])?\n  on_numtype : ((ModuleTransformer[T], T, NumType) -> TransformerResult[\n    T,\n    NumType,\n  ])?\n  on_rectype : ((ModuleTransformer[T], T, RecType) -> TransformerResult[\n    T,\n    RecType,\n  ])?\n  on_subtype : ((ModuleTransformer[T], T, SubType) -> TransformerResult[\n    T,\n    SubType,\n  ])?\n  on_comptype : ((ModuleTransformer[T], T, CompType) -> TransformerResult[\n    T,\n    CompType,\n  ])?\n  on_reftype : ((ModuleTransformer[T], T, RefType) -> TransformerResult[\n    T,\n    RefType,\n  ])?\n  on_heaptype : ((ModuleTransformer[T], T, HeapType) -> TransformerResult[\n    T,\n    HeapType,\n  ])?\n  on_blocktype : ((ModuleTransformer[T], T, BlockType) -> TransformerResult[\n    T,\n    BlockType,\n  ])?\n  on_funcidx : ((ModuleTransformer[T], T, FuncIdx) -> TransformerResult[\n    T,\n    FuncIdx,\n  ])?\n  on_typeidx : ((ModuleTransformer[T], T, TypeIdx) -> TransformerResult[\n    T,\n    TypeIdx,\n  ])?\n  on_laneidx : ((ModuleTransformer[T], T, LaneIdx) -> TransformerResult[\n    T,\n    LaneIdx,\n  ])?\n  on_localidx : ((ModuleTransformer[T], T, LocalIdx) -> TransformerResult[\n    T,\n    LocalIdx,\n  ])?\n  on_globalidx : ((ModuleTransformer[T], T, GlobalIdx) -> TransformerResult[\n    T,\n    GlobalIdx,\n  ])?\n  on_tableidx : ((ModuleTransformer[T], T, TableIdx) -> TransformerResult[\n    T,\n    TableIdx,\n  ])?\n  on_memidx : ((ModuleTransformer[T], T, MemIdx) -> TransformerResult[T, MemIdx])?\n  on_labelidx : ((ModuleTransformer[T], T, LabelIdx) -> TransformerResult[\n    T,\n    LabelIdx,\n  ])?\n  on_dataidx : ((ModuleTransformer[T], T, DataIdx) -> TransformerResult[\n    T,\n    DataIdx,\n  ])?\n  on_elemidx : ((ModuleTransformer[T], T, ElemIdx) -> TransformerResult[\n    T,\n    ElemIdx,\n  ])?\n  on_tagidx : ((ModuleTransformer[T], T, TagIdx) -> TransformerResult[T, TagIdx])?\n  on_name : ((ModuleTransformer[T], T, Name) -> TransformerResult[T, Name])?\n  on_externtype : ((ModuleTransformer[T], T, ExternType) -> TransformerResult[\n    T,\n    ExternType,\n  ])?\n  on_limits : ((ModuleTransformer[T], T, Limits) -> TransformerResult[T, Limits])?\n  on_memtype : ((ModuleTransformer[T], T, MemType) -> TransformerResult[\n    T,\n    MemType,\n  ])?\n  on_tagtype : ((ModuleTransformer[T], T, TagType) -> TransformerResult[\n    T,\n    TagType,\n  ])?\n  on_export : ((ModuleTransformer[T], T, Export) -> TransformerResult[T, Export])?\n  on_global : ((ModuleTransformer[T], T, Global) -> TransformerResult[T, Global])?\n  on_globaltype : ((ModuleTransformer[T], T, GlobalType) -> TransformerResult[\n    T,\n    GlobalType,\n  ])?\n  on_func : ((ModuleTransformer[T], T, Func) -> TransformerResult[T, Func])?\n  on_locals : ((ModuleTransformer[T], T, Array[Locals]) -> TransformerResult[\n    T,\n    Array[Locals],\n  ])?\n  on_externidx : ((ModuleTransformer[T], T, ExternIdx) -> TransformerResult[\n    T,\n    ExternIdx,\n  ])?\n  on_fieldtype : ((ModuleTransformer[T], T, FieldType) -> TransformerResult[\n    T,\n    FieldType,\n  ])?\n  on_storagetype : ((ModuleTransformer[T], T, StorageType) -> TransformerResult[\n    T,\n    StorageType,\n  ])?\n  on_unaryop : ((ModuleTransformer[T], T, UnaryOp) -> TransformerResult[\n    T,\n    UnaryOp,\n  ])?\n  on_binaryop : ((ModuleTransformer[T], T, BinaryOp) -> TransformerResult[\n    T,\n    BinaryOp,\n  ])?\n  on_storeop : ((ModuleTransformer[T], T, StoreOp) -> TransformerResult[\n    T,\n    StoreOp,\n  ])?\n  on_loadop : ((ModuleTransformer[T], T, LoadOp) -> TransformerResult[T, LoadOp])?\n  on_extractlaneop : ((ModuleTransformer[T], T, ExtractLaneOp) -> TransformerResult[\n    T,\n    ExtractLaneOp,\n  ])?\n  on_replacelaneop : ((ModuleTransformer[T], T, ReplaceLaneOp) -> TransformerResult[\n    T,\n    ReplaceLaneOp,\n  ])?\n  on_v128shiftop : ((ModuleTransformer[T], T, V128ShiftOp) -> TransformerResult[\n    T,\n    V128ShiftOp,\n  ])?\n  on_v128ternaryop : ((ModuleTransformer[T], T, V128TernaryOp) -> TransformerResult[\n    T,\n    V128TernaryOp,\n  ])?\n  on_v128loadlaneop : ((ModuleTransformer[T], T, V128LoadLaneOp) -> TransformerResult[\n    T,\n    V128LoadLaneOp,\n  ])?\n  on_v128storelaneop : ((ModuleTransformer[T], T, V128StoreLaneOp) -> TransformerResult[\n    T,\n    V128StoreLaneOp,\n  ])?\n  on_memarg : ((ModuleTransformer[T], T, MemArg) -> TransformerResult[T, MemArg])?\n}\n\n///|\npub fn[T] ModuleTransformer::new() -> ModuleTransformer[T] {\n  ModuleTransformer::{\n    on_typesec: None,\n    on_funcsec: None,\n    on_tablesec: None,\n    on_memsec: None,\n    on_tagsec: None,\n    on_globalsec: None,\n    on_exportsec: None,\n    on_startsec: None,\n    on_elemsec: None,\n    on_elemkind: None,\n    on_datacntsec: None,\n    on_codesec: None,\n    on_datasec: None,\n    on_instruction: None,\n    on_tinstruction: None,\n    on_expr: None,\n    on_texpr: None,\n    on_table: None,\n    on_valtype: None,\n    on_numtype: None,\n    on_rectype: None,\n    on_subtype: None,\n    on_comptype: None,\n    on_reftype: None,\n    on_heaptype: None,\n    on_blocktype: None,\n    on_funcidx: None,\n    on_typeidx: None,\n    on_laneidx: None,\n    on_localidx: None,\n    on_globalidx: None,\n    on_tableidx: None,\n    on_memidx: None,\n    on_labelidx: None,\n    on_dataidx: None,\n    on_elemidx: None,\n    on_tagidx: None,\n    on_name: None,\n    on_externtype: None,\n    on_limits: None,\n    on_memtype: None,\n    on_tagtype: None,\n    on_export: None,\n    on_global: None,\n    on_globaltype: None,\n    on_func: None,\n    on_locals: None,\n    on_externidx: None,\n    on_fieldtype: None,\n    on_storagetype: None,\n    on_unaryop: None,\n    on_binaryop: None,\n    on_storeop: None,\n    on_loadop: None,\n    on_extractlaneop: None,\n    on_replacelaneop: None,\n    on_v128shiftop: None,\n    on_v128ternaryop: None,\n    on_v128loadlaneop: None,\n    on_v128storelaneop: None,\n    on_memarg: None,\n  }\n}\n\n///|\npub fn[T, E] ModuleTransformer::walk_array(\n  self : ModuleTransformer[T],\n  t : T,\n  f : (ModuleTransformer[T], T, E) -> TransformerResult[T, E],\n  a : Array[E],\n) -> TransformerResult[T, Array[E]] {\n  let mut t = t\n  let mut changed = false\n  let a = a.copy()\n  let end = a.length()\n  loop 0 {\n    n if n == end => break\n    n => {\n      let item = a[n]\n      match f(self, t, item) {\n        Ok(None) => continue n + 1 // No change\n        Ok(Some((next_t, next_item))) => {\n          t = next_t\n          a[n] = next_item\n          changed = true\n          continue n + 1\n        }\n        Err(e) => return Err(e)\n      }\n    }\n  }\n  if changed {\n    Ok(Some((t, a)))\n  } else {\n    Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_name(\n  self : ModuleTransformer[T],\n  t : T,\n  name : Name,\n) -> TransformerResult[T, Name] {\n  match self.on_name {\n    Some(f) => f(self, t, name)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_expr(\n  self : ModuleTransformer[T],\n  t : T,\n  expr : Expr,\n) -> TransformerResult[T, Expr] {\n  match self.on_expr {\n    Some(f) =>\n      match f(self, t, expr) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_expr_default(t, expr)\n        ok => ok\n      }\n    None => self.walk_expr_default(t, expr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_texpr(\n  self : ModuleTransformer[T],\n  t : T,\n  texpr : TExpr,\n) -> TransformerResult[T, TExpr] {\n  match self.on_texpr {\n    Some(f) =>\n      match f(self, t, texpr) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_texpr_default(t, texpr)\n        ok => ok\n      }\n    None => self.walk_texpr_default(t, texpr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_expr_default(\n  self : ModuleTransformer[T],\n  t : T,\n  expr : Expr,\n) -> TransformerResult[T, Expr] {\n  let Expr(instructions) = expr\n  match self.walk_array(t, ModuleTransformer::walk_instruction, instructions) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, instructions))) => Ok(Some((t, Expr(instructions))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_texpr_default(\n  self : ModuleTransformer[T],\n  t : T,\n  expr : TExpr,\n) -> TransformerResult[T, TExpr] {\n  let TExpr(instructions) = expr\n  let (t, instructions) = match\n    self.walk_array(t, ModuleTransformer::walk_tinstruction, instructions) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, instructions)\n    Ok(Some(t)) => t\n  }\n  Ok(Some((t, TExpr(instructions))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tinstruction(\n  self : ModuleTransformer[T],\n  t : T,\n  tinstr : TInstr,\n) -> TransformerResult[T, TInstr] {\n  match self.on_tinstruction {\n    Some(f) =>\n      match f(self, t, tinstr) {\n        Ok(None) => self.walk_tinstruction_default(t, tinstr)\n        Ok(t) => Ok(t)\n        Err(t) => Err(t)\n      }\n    None => self.walk_tinstruction_default(t, tinstr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tinstruction_default(\n  self : ModuleTransformer[T],\n  t : T,\n  tinstr : TInstr,\n) -> TransformerResult[T, TInstr] {\n  match tinstr {\n    // === Constants (0 children, 1 result) ===\n\n    TRefNull(ht) => {\n      let (t, ht) = match self.walk_heaptype(t, ht) {\n        Ok(None) => (t, ht)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefNull(ht))))\n    }\n    TRefFunc(fi) => {\n      let (t, fi) = match self.walk_funcidx(t, fi) {\n        Ok(None) => (t, fi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefFunc(fi))))\n    }\n    // === Nullary (0 children) ===\n\n    TLocalGet(li) => {\n      let (t, li) = match self.walk_localidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLocalGet(li))))\n    }\n    TGlobalGet(gi) => {\n      let (t, gi) = match self.walk_globalidx(t, gi) {\n        Ok(None) => (t, gi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TGlobalGet(gi))))\n    }\n    TMemorySize(mi) => {\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemorySize(mi))))\n    }\n    TTableSize(ti) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableSize(ti))))\n    }\n\n    // === Unary (1 child) ===\n    TUnary(op, i) => {\n      let (t, op) = match self.walk_unaryop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TUnary(op, i))))\n    }\n    TDrop(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TDrop(i))))\n    }\n    TLocalSet(li, i) => {\n      let (t, li) = match self.walk_localidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLocalSet(li, i))))\n    }\n    TLocalTee(li, i) => {\n      let (t, li) = match self.walk_localidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLocalTee(li, i))))\n    }\n    TGlobalSet(gi, i) => {\n      let (t, gi) = match self.walk_globalidx(t, gi) {\n        Ok(None) => (t, gi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TGlobalSet(gi, i))))\n    }\n    TRefIsNull(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefIsNull(i))))\n    }\n    TRefAsNonNull(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefAsNonNull(i))))\n    }\n    TI31GetS(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI31GetS(i))))\n    }\n    TI31GetU(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI31GetU(i))))\n    }\n    TRefI31(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefI31(i))))\n    }\n    TArrayLen(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayLen(i))))\n    }\n    TAnyConvertExtern(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TAnyConvertExtern(i))))\n    }\n    TExternConvertAny(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TExternConvertAny(i))))\n    }\n    TThrowRef(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TThrowRef(i))))\n    }\n\n    // === Binary (2 children) ===\n    TBinary(op, i1, i2) => {\n      let (t, op) = match self.walk_binaryop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBinary(op, i1, i2))))\n    }\n    TRefEq(i1, i2) => {\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefEq(i1, i2))))\n    }\n    TStore(op, ma, i1, i2) => {\n      let (t, op) = match self.walk_storeop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStore(op, ma, i1, i2))))\n    }\n\n    // === Load (1 child - address) ===\n    TLoad(op, ma, i) => {\n      let (t, op) = match self.walk_loadop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLoad(op, ma, i))))\n    }\n\n    // === Memory operations ===\n    TMemoryGrow(mi, i) => {\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryGrow(mi, i))))\n    }\n    TMemoryFill(mi, i1, i2, i3) => {\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryFill(mi, i1, i2, i3))))\n    }\n    TMemoryCopy(mi1, mi2, i1, i2, i3) => {\n      let (t, mi1) = match self.walk_memidx(t, mi1) {\n        Ok(None) => (t, mi1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, mi2) = match self.walk_memidx(t, mi2) {\n        Ok(None) => (t, mi2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryCopy(mi1, mi2, i1, i2, i3))))\n    }\n    TMemoryInit(di, mi, i1, i2, i3) => {\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryInit(di, mi, i1, i2, i3))))\n    }\n    TDataDrop(di) => {\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TDataDrop(di))))\n    }\n\n    // === Table operations ===\n    TTableGet(ti, i) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableGet(ti, i))))\n    }\n    TTableSet(ti, i1, i2) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableSet(ti, i1, i2))))\n    }\n    TTableGrow(ti, i1, i2) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableGrow(ti, i1, i2))))\n    }\n    TTableFill(ti, i1, i2, i3) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableFill(ti, i1, i2, i3))))\n    }\n    TTableCopy(ti1, ti2, i1, i2, i3) => {\n      let (t, ti1) = match self.walk_tableidx(t, ti1) {\n        Ok(None) => (t, ti1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ti2) = match self.walk_tableidx(t, ti2) {\n        Ok(None) => (t, ti2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableCopy(ti1, ti2, i1, i2, i3))))\n    }\n    TTableInit(ei, ti, i1, i2, i3) => {\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableInit(ei, ti, i1, i2, i3))))\n    }\n    TElemDrop(ei) => {\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TElemDrop(ei))))\n    }\n\n    // === Calls (N children based on function type) ===\n    TCall(fi, i) => {\n      let (t, fi) = match self.walk_funcidx(t, fi) {\n        Ok(None) => (t, fi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TCall(fi, i))))\n    }\n    TCallIndirect(tyi, tai, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, tai) = match self.walk_tableidx(t, tai) {\n        Ok(None) => (t, tai)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TCallIndirect(tyi, tai, i0, i))))\n    }\n    TCallRef(tyi, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TCallRef(tyi, i0, i))))\n    }\n    TReturnCall(fi, i) => {\n      let (t, fi) = match self.walk_funcidx(t, fi) {\n        Ok(None) => (t, fi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturnCall(fi, i))))\n    }\n    TReturnCallIndirect(tyi, tai, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, tai) = match self.walk_tableidx(t, tai) {\n        Ok(None) => (t, tai)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturnCallIndirect(tyi, tai, i0, i))))\n    }\n    TReturnCallRef(tyi, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturnCallRef(tyi, i0, i))))\n    }\n\n    // === Control flow ===\n    TBlock(bt, e) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e) = match self.walk_texpr(t, e) {\n        Ok(None) => (t, e)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBlock(bt, e))))\n    }\n    TLoop(bt, e) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e) = match self.walk_texpr(t, e) {\n        Ok(None) => (t, e)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLoop(bt, e))))\n    }\n    TIf(bt, i_if, e_then, e_else_option) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i_if) = match self.walk_tinstruction(t, i_if) {\n        Ok(None) => (t, i_if)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e_then) = match self.walk_texpr(t, e_then) {\n        Ok(None) => (t, e_then)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e_else_option) = if e_else_option is Some(e_else) {\n        match self.walk_texpr(t, e_else) {\n          Ok(None) => (t, e_else_option)\n          Ok(Some((t, e_else))) => (t, Some(e_else))\n          Err(t) => return Err(t)\n        }\n      } else {\n        (t, e_else_option)\n      }\n      Ok(Some((t, TIf(bt, i_if, e_then, e_else_option))))\n    }\n    TTryTable(bt, c, e) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, c) = match self.walk_array(t, ModuleTransformer::walk_catch, c) {\n        Ok(None) => (t, c)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e) = match self.walk_texpr(t, e) {\n        Ok(None) => (t, e)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTryTable(bt, c, e))))\n    }\n    TThrow(ti, i) => {\n      let (t, ti) = match self.walk_tagidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TThrow(ti, i))))\n    }\n\n    // === Branches ===\n    TBr(li, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBr(li, i))))\n    }\n    TBrIf(li, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrIf(li, i0, i))))\n    }\n    TBrTable(ls, li, i0, i) => {\n      let (t, ls) = match\n        self.walk_array(t, ModuleTransformer::walk_labelidx, ls) {\n        Ok(None) => (t, ls)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrTable(ls, li, i0, i))))\n    }\n    TBrOnNull(li, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnNull(li, i0, i))))\n    }\n    TBrOnNonNull(li, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnNonNull(li, i0, i))))\n    }\n    TBrOnCast(li, co, ht0, ht1, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht0) = match self.walk_heaptype(t, ht0) {\n        Ok(None) => (t, ht0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Ok(None) => (t, ht1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnCast(li, co, ht0, ht1, i0, i))))\n    }\n    TBrOnCastFail(li, co, ht0, ht1, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht0) = match self.walk_heaptype(t, ht0) {\n        Ok(None) => (t, ht0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Ok(None) => (t, ht1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnCastFail(li, co, ht0, ht1, i0, i))))\n    }\n    TReturn(i) => {\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturn(i))))\n    }\n\n    // === Select ===\n    TSelect(vts_option, i0, i1, i2) => {\n      let (t, vts_option) = if vts_option is Some(vts) {\n        match self.walk_array(t, ModuleTransformer::walk_valtype, vts) {\n          Ok(None) => (t, vts_option)\n          Ok(Some((t, vts))) => (t, Some(vts))\n          Err(t) => return Err(t)\n        }\n      } else {\n        (t, vts_option)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TSelect(vts_option, i0, i1, i2))))\n    }\n\n    // === GC: Structs ===\n    TStructNew(ti, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructNew(ti, i))))\n    }\n    TStructNewDefault(ti) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructNewDefault(ti))))\n    }\n    TStructGet(ti, f, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructGet(ti, f, i))))\n    }\n    TStructGetS(ti, f, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructGetS(ti, f, i))))\n    }\n    TStructGetU(ti, f, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructGetU(ti, f, i))))\n    }\n    TStructSet(ti, f, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructSet(ti, f, i0, i1))))\n    }\n\n    // === GC: Arrays ===\n    TArrayNew(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNew(ti, i0, i1))))\n    }\n    TArrayNewDefault(ti, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewDefault(ti, i))))\n    }\n    TArrayNewFixed(ti, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewFixed(ti, i))))\n    }\n    TArrayNewData(ti, di, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewData(ti, di, i0, i1))))\n    }\n    TArrayNewElem(ti, ei, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewElem(ti, ei, i0, i1))))\n    }\n    TArrayGet(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayGet(ti, i0, i1))))\n    }\n    TArrayGetS(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayGetS(ti, i0, i1))))\n    }\n    TArrayGetU(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayGetU(ti, i0, i1))))\n    }\n    TArraySet(ti, i0, i1, i2) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArraySet(ti, i0, i1, i2))))\n    }\n    TArrayFill(ti, i0, i1, i2, i3) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayFill(ti, i0, i1, i2, i3))))\n    }\n    TArrayCopy(ti0, ti1, i0, i1, i2, i3, i4) => {\n      let (t, ti0) = match self.walk_typeidx(t, ti0) {\n        Ok(None) => (t, ti0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ti1) = match self.walk_typeidx(t, ti1) {\n        Ok(None) => (t, ti1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i4) = match self.walk_tinstruction(t, i4) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayCopy(ti0, ti1, i0, i1, i2, i3, i4))))\n    }\n    TArrayInitData(ti, di, i0, i1, i2, i3) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayInitData(ti, di, i0, i1, i2, i3))))\n    }\n    TArrayInitElem(ti, ei, i0, i1, i2, i3) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayInitElem(ti, ei, i0, i1, i2, i3))))\n    }\n\n    // === GC: Casts ===\n    TRefTest(b, ht, i) => {\n      let (t, ht) = match self.walk_heaptype(t, ht) {\n        Ok(None) => (t, ht)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefTest(b, ht, i))))\n    }\n    TRefCast(b, ht, i) => {\n      let (t, ht) = match self.walk_heaptype(t, ht) {\n        Ok(None) => (t, ht)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefCast(b, ht, i))))\n    }\n\n    // === SIMD: Splat (scalar -> v128) ===\n    TI8x16Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI8x16Splat(i))))\n    }\n    TI16x8Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI16x8Splat(i))))\n    }\n    TI32x4Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI32x4Splat(i))))\n    }\n    TI64x2Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI64x2Splat(i))))\n    }\n    TF32x4Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TF32x4Splat(i))))\n    }\n    TF64x2Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TF64x2Splat(i))))\n    }\n\n    // === SIMD: Extract lane (v128 -> scalar) ===\n    TExtractLane(op, li, i) => {\n      let (t, op) = match self.walk_extractlaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TExtractLane(op, li, i))))\n    }\n\n    // === SIMD: Replace lane (v128, scalar -> v128) ===\n    TReplaceLane(op, li, i0, i1) => {\n      let (t, op) = match self.walk_replacelaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReplaceLane(op, li, i0, i1))))\n    }\n\n    // === SIMD: Shuffle (v128, v128 -> v128 with 16 lane indices) ===\n    TI8x16Shuffle(\n      li0,\n      li1,\n      li2,\n      li3,\n      li4,\n      li5,\n      li6,\n      li7,\n      li8,\n      li9,\n      li10,\n      li11,\n      li12,\n      li13,\n      li14,\n      li15,\n      i0,\n      i1\n    ) => {\n      let (t, li0) = match self.walk_laneidx(t, li0) {\n        Ok(None) => (t, li0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li1) = match self.walk_laneidx(t, li1) {\n        Ok(None) => (t, li1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li2) = match self.walk_laneidx(t, li2) {\n        Ok(None) => (t, li2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li3) = match self.walk_laneidx(t, li3) {\n        Ok(None) => (t, li3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li4) = match self.walk_laneidx(t, li4) {\n        Ok(None) => (t, li4)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li5) = match self.walk_laneidx(t, li5) {\n        Ok(None) => (t, li5)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li6) = match self.walk_laneidx(t, li6) {\n        Ok(None) => (t, li6)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li7) = match self.walk_laneidx(t, li7) {\n        Ok(None) => (t, li7)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li8) = match self.walk_laneidx(t, li8) {\n        Ok(None) => (t, li8)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li9) = match self.walk_laneidx(t, li9) {\n        Ok(None) => (t, li9)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li10) = match self.walk_laneidx(t, li10) {\n        Ok(None) => (t, li10)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li11) = match self.walk_laneidx(t, li11) {\n        Ok(None) => (t, li11)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li12) = match self.walk_laneidx(t, li12) {\n        Ok(None) => (t, li12)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li13) = match self.walk_laneidx(t, li13) {\n        Ok(None) => (t, li13)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li14) = match self.walk_laneidx(t, li14) {\n        Ok(None) => (t, li14)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li15) = match self.walk_laneidx(t, li15) {\n        Ok(None) => (t, li15)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(\n        Some(\n          (\n            t,\n            TI8x16Shuffle(\n              li0, li1, li2, li3, li4, li5, li6, li7, li8, li9, li10, li11, li12,\n              li13, li14, li15, i0, i1,\n            ),\n          ),\n        ),\n      )\n    }\n\n    // === SIMD: Swizzle (v128, v128 -> v128) ===\n    TI8x16Swizzle(i0, i1) => {\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI8x16Swizzle(i0, i1))))\n    }\n    TI8x16RelaxedSwizzle(i0, i1) => {\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI8x16RelaxedSwizzle(i0, i1))))\n    }\n\n    // === SIMD: Shift (v128, i32 -> v128) ===\n    TV128Shift(op, i0, i1) => {\n      let (t, op) = match self.walk_v128shiftop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128Shift(op, i0, i1))))\n    }\n\n    // === SIMD: Ternary (v128, v128, v128 -> v128) ===\n    TV128Ternary(op, i0, i1, i2) => {\n      let (t, op) = match self.walk_v128ternaryop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128Ternary(op, i0, i1, i2))))\n    }\n\n    // === SIMD: Lane load (v128, addr -> v128) ===\n    TV128LoadLane(op, ma, li, i0, i1) => {\n      let (t, op) = match self.walk_v128loadlaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128LoadLane(op, ma, li, i0, i1))))\n    }\n\n    // === SIMD: Lane store (v128, addr -> void) ===\n    TV128StoreLane(op, ma, li, i0, i1) => {\n      let (t, op) = match self.walk_v128storelaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128StoreLane(op, ma, li, i0, i1))))\n    }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_instruction(\n  self : ModuleTransformer[T],\n  t : T,\n  instr : Instruction,\n) -> TransformerResult[T, Instruction] {\n  match self.on_instruction {\n    Some(f) =>\n      match f(self, t, instr) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_instruction_default(t, instr)\n        ok => ok\n      }\n    None => self.walk_instruction_default(t, instr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_instruction_default(\n  self : ModuleTransformer[T],\n  t : T,\n  instr : Instruction,\n) -> TransformerResult[T, Instruction] {\n  match instr {\n    // Control instructions\n    Block(bt, body) =>\n      match self.walk_blocktype(t, bt) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, body))) => Ok(Some((t, Block(bt, body))))\n          }\n        Ok(Some((t, bt))) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(Some((t, Block(bt, body))))\n            Ok(Some((t, body))) => Ok(Some((t, Block(bt, body))))\n          }\n      }\n    Loop(bt, body) =>\n      match self.walk_blocktype(t, bt) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, body))) => Ok(Some((t, Loop(bt, body))))\n          }\n        Ok(Some((t, bt))) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(Some((t, Loop(bt, body))))\n            Ok(Some((t, body))) => Ok(Some((t, Loop(bt, body))))\n          }\n      }\n    If(bt, then_body, else_body_opt) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, bt)\n        Ok(Some((t, bt))) => (t, bt)\n      }\n      let (t, then_body) = match\n        self.walk_array(t, ModuleTransformer::walk_instruction, then_body) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, then_body)\n        Ok(Some((t, arr))) => (t, arr)\n      }\n      let (t, else_body_opt) = match else_body_opt {\n        None => (t, None)\n        Some(else_body) =>\n          match\n            self.walk_array(t, ModuleTransformer::walk_instruction, else_body) {\n            Err(e) => return Err(e)\n            Ok(None) => (t, Some(else_body))\n            Ok(Some((t, arr))) => (t, Some(arr))\n          }\n      }\n      Ok(Some((t, If(bt, then_body, else_body_opt))))\n    }\n    TryTable(bt, catches, body) =>\n      match self.walk_blocktype(t, bt) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_array(t, ModuleTransformer::walk_catch, catches) {\n            Err(e) => Err(e)\n            Ok(None) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(None)\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n            Ok(Some((t, catches))) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(Some((t, TryTable(bt, catches, body))))\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n          }\n        Ok(Some((t, bt))) =>\n          match self.walk_array(t, ModuleTransformer::walk_catch, catches) {\n            Err(e) => Err(e)\n            Ok(None) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(Some((t, TryTable(bt, catches, body))))\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n            Ok(Some((t, catches))) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(Some((t, TryTable(bt, catches, body))))\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n          }\n      }\n\n    // Branch instructions\n    Br(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, Br(l))))\n      }\n    BrIf(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, BrIf(l))))\n      }\n    BrTable(labels, default) =>\n      match self.walk_array(t, ModuleTransformer::walk_labelidx, labels) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_labelidx(t, default) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, default))) => Ok(Some((t, BrTable(labels, default))))\n          }\n        Ok(Some((t, labels))) =>\n          match self.walk_labelidx(t, default) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(Some((t, BrTable(labels, default))))\n            Ok(Some((t, default))) => Ok(Some((t, BrTable(labels, default))))\n          }\n      }\n    BrOnNull(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, BrOnNull(l))))\n      }\n    BrOnNonNull(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, BrOnNonNull(l))))\n      }\n    BrOnCast(l, op, ht1, ht2) => {\n      let (t, l) = match self.walk_labelidx(t, l) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, l)\n        Ok(Some((t, l))) => (t, l)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht1)\n        Ok(Some((t, ht1))) => (t, ht1)\n      }\n      let (t, ht2) = match self.walk_heaptype(t, ht2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht2)\n        Ok(Some((t, ht2))) => (t, ht2)\n      }\n      Ok(Some((t, BrOnCast(l, op, ht1, ht2))))\n    }\n    BrOnCastFail(l, op, ht1, ht2) => {\n      let (t, l) = match self.walk_labelidx(t, l) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, l)\n        Ok(Some((t, l))) => (t, l)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht1)\n        Ok(Some((t, ht1))) => (t, ht1)\n      }\n      let (t, ht2) = match self.walk_heaptype(t, ht2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht2)\n        Ok(Some((t, ht2))) => (t, ht2)\n      }\n      Ok(Some((t, BrOnCastFail(l, op, ht1, ht2))))\n    }\n\n    // Call instructions\n    Call(f) =>\n      match self.walk_funcidx(t, f) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, f))) => Ok(Some((t, Call(f))))\n      }\n    CallIndirect(ty, tbl) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, tbl) = match self.walk_tableidx(t, tbl) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tbl)\n        Ok(Some((t, tbl))) => (t, tbl)\n      }\n      Ok(Some((t, CallIndirect(ty, tbl))))\n    }\n    ReturnCall(f) =>\n      match self.walk_funcidx(t, f) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, f))) => Ok(Some((t, ReturnCall(f))))\n      }\n    ReturnCallIndirect(ty, tbl) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, tbl) = match self.walk_tableidx(t, tbl) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tbl)\n        Ok(Some((t, tbl))) => (t, tbl)\n      }\n      Ok(Some((t, ReturnCallIndirect(ty, tbl))))\n    }\n    CallRef(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, CallRef(ty))))\n      }\n    ReturnCallRef(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ReturnCallRef(ty))))\n      }\n\n    // Variable instructions\n    LocalGet(l) =>\n      match self.walk_localidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, LocalGet(l))))\n      }\n    LocalSet(l) =>\n      match self.walk_localidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, LocalSet(l))))\n      }\n    LocalTee(l) =>\n      match self.walk_localidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, LocalTee(l))))\n      }\n    GlobalGet(g) =>\n      match self.walk_globalidx(t, g) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, g))) => Ok(Some((t, GlobalGet(g))))\n      }\n    GlobalSet(g) =>\n      match self.walk_globalidx(t, g) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, g))) => Ok(Some((t, GlobalSet(g))))\n      }\n\n    // Table instructions\n    TableGet(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableGet(tbl))))\n      }\n    TableSet(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableSet(tbl))))\n      }\n    TableGrow(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableGrow(tbl))))\n      }\n    TableSize(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableSize(tbl))))\n      }\n    TableFill(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableFill(tbl))))\n      }\n    TableCopy(t1, t2) => {\n      let (t, t1) = match self.walk_tableidx(t, t1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t1)\n        Ok(Some((t, t1))) => (t, t1)\n      }\n      let (t, t2) = match self.walk_tableidx(t, t2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t2)\n        Ok(Some((t, t2))) => (t, t2)\n      }\n      Ok(Some((t, TableCopy(t1, t2))))\n    }\n    TableInit(e, tbl) => {\n      let (t, e) = match self.walk_elemidx(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, e)\n        Ok(Some((t, e))) => (t, e)\n      }\n      let (t, tbl) = match self.walk_tableidx(t, tbl) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tbl)\n        Ok(Some((t, tbl))) => (t, tbl)\n      }\n      Ok(Some((t, TableInit(e, tbl))))\n    }\n    ElemDrop(e) =>\n      match self.walk_elemidx(t, e) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, e))) => Ok(Some((t, ElemDrop(e))))\n      }\n\n    // Reference instructions\n    RefNull(ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, RefNull(ht))))\n      }\n    RefFunc(f) =>\n      match self.walk_funcidx(t, f) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, f))) => Ok(Some((t, RefFunc(f))))\n      }\n    RefTest(nullable, ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, RefTest(nullable, ht))))\n      }\n    RefCast(nullable, ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, RefCast(nullable, ht))))\n      }\n\n    // Struct/Array instructions\n    StructNew(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructNew(ty))))\n      }\n    StructNewDefault(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructNewDefault(ty))))\n      }\n    StructGet(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructGet(ty, f))))\n      }\n    StructGetS(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructGetS(ty, f))))\n      }\n    StructGetU(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructGetU(ty, f))))\n      }\n    StructSet(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructSet(ty, f))))\n      }\n    ArrayNew(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNew(ty))))\n      }\n    ArrayNewDefault(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNewDefault(ty))))\n      }\n    ArrayNewFixed(ty, n) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNewFixed(ty, n))))\n      }\n    ArrayNewData(ty, n) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNewData(ty, n))))\n      }\n    ArrayNewElem(ty, e) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, e) = match self.walk_elemidx(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, e)\n        Ok(Some((t, e))) => (t, e)\n      }\n      Ok(Some((t, ArrayNewElem(ty, e))))\n    }\n    ArrayGet(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayGet(ty))))\n      }\n    ArrayGetS(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayGetS(ty))))\n      }\n    ArrayGetU(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayGetU(ty))))\n      }\n    ArraySet(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArraySet(ty))))\n      }\n    ArrayFill(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayFill(ty))))\n      }\n    ArrayCopy(t1, t2) => {\n      let (t, t1) = match self.walk_typeidx(t, t1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t1)\n        Ok(Some((t, t1))) => (t, t1)\n      }\n      let (t, t2) = match self.walk_typeidx(t, t2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t2)\n        Ok(Some((t, t2))) => (t, t2)\n      }\n      Ok(Some((t, ArrayCopy(t1, t2))))\n    }\n    ArrayInitData(ty, d) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, d) = match self.walk_dataidx(t, d) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, d)\n        Ok(Some((t, d))) => (t, d)\n      }\n      Ok(Some((t, ArrayInitData(ty, d))))\n    }\n    ArrayInitElem(ty, e) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, e) = match self.walk_elemidx(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, e)\n        Ok(Some((t, e))) => (t, e)\n      }\n      Ok(Some((t, ArrayInitElem(ty, e))))\n    }\n\n    // Memory instructions\n    MemorySize(m) =>\n      match self.walk_memidx(t, m) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, m))) => Ok(Some((t, MemorySize(m))))\n      }\n    MemoryGrow(m) =>\n      match self.walk_memidx(t, m) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, m))) => Ok(Some((t, MemoryGrow(m))))\n      }\n    MemoryFill(m) =>\n      match self.walk_memidx(t, m) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, m))) => Ok(Some((t, MemoryFill(m))))\n      }\n    MemoryCopy(m1, m2) => {\n      let (t, m1) = match self.walk_memidx(t, m1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, m1)\n        Ok(Some((t, m1))) => (t, m1)\n      }\n      let (t, m2) = match self.walk_memidx(t, m2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, m2)\n        Ok(Some((t, m2))) => (t, m2)\n      }\n      Ok(Some((t, MemoryCopy(m1, m2))))\n    }\n    MemoryInit(d, m) => {\n      let (t, d) = match self.walk_dataidx(t, d) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, d)\n        Ok(Some((t, d))) => (t, d)\n      }\n      let (t, m) = match self.walk_memidx(t, m) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, m)\n        Ok(Some((t, m))) => (t, m)\n      }\n      Ok(Some((t, MemoryInit(d, m))))\n    }\n    DataDrop(d) =>\n      match self.walk_dataidx(t, d) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, d))) => Ok(Some((t, DataDrop(d))))\n      }\n\n    // Exception instructions\n    Throw(ty) =>\n      match self.walk_tagidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, Throw(ty))))\n      }\n\n    // Select with types\n    Select(types) =>\n      match types {\n        None => Ok(None)\n        Some(types) =>\n          match self.walk_array(t, ModuleTransformer::walk_valtype, types) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, types))) => Ok(Some((t, Select(Some(types)))))\n          }\n      }\n\n    // All other instructions pass through unchanged\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_blocktype(\n  self : ModuleTransformer[T],\n  t : T,\n  bt : BlockType,\n) -> TransformerResult[T, BlockType] {\n  match self.on_blocktype {\n    Some(f) =>\n      match f(self, t, bt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_blocktype_default(t, bt)\n        ok => ok\n      }\n    None => self.walk_blocktype_default(t, bt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_blocktype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  bt : BlockType,\n) -> TransformerResult[T, BlockType] {\n  match bt {\n    ValTypeBlockType(vt) =>\n      match self.walk_valtype(t, vt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, vt))) => Ok(Some((t, ValTypeBlockType(vt))))\n      }\n    TypeIdxBlockType(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, TypeIdxBlockType(ty))))\n      }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_catch(\n  self : ModuleTransformer[T],\n  t : T,\n  c : Catch,\n) -> TransformerResult[T, Catch] {\n  match c {\n    Catch(tag, label) => {\n      let (t, tag) = match self.walk_tagidx(t, tag) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tag)\n        Ok(Some((t, tag))) => (t, tag)\n      }\n      let (t, label) = match self.walk_labelidx(t, label) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, label)\n        Ok(Some((t, label))) => (t, label)\n      }\n      Ok(Some((t, Catch(tag, label))))\n    }\n    CatchRef(tag, label) => {\n      let (t, tag) = match self.walk_tagidx(t, tag) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tag)\n        Ok(Some((t, tag))) => (t, tag)\n      }\n      let (t, label) = match self.walk_labelidx(t, label) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, label)\n        Ok(Some((t, label))) => (t, label)\n      }\n      Ok(Some((t, CatchRef(tag, label))))\n    }\n    CatchAll(label) =>\n      match self.walk_labelidx(t, label) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, label))) => Ok(Some((t, CatchAll(label))))\n      }\n    CatchAllRef(label) =>\n      match self.walk_labelidx(t, label) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, label))) => Ok(Some((t, CatchAllRef(label))))\n      }\n  }\n}\n\n// Index walkers - leaf nodes\n\n///|\npub fn[T] ModuleTransformer::walk_funcidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : FuncIdx,\n) -> TransformerResult[T, FuncIdx] {\n  match self.on_funcidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_typeidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : TypeIdx,\n) -> TransformerResult[T, TypeIdx] {\n  match self.on_typeidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_localidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : LocalIdx,\n) -> TransformerResult[T, LocalIdx] {\n  match self.on_localidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globalidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : GlobalIdx,\n) -> TransformerResult[T, GlobalIdx] {\n  match self.on_globalidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tableidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : TableIdx,\n) -> TransformerResult[T, TableIdx] {\n  match self.on_tableidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : MemIdx,\n) -> TransformerResult[T, MemIdx] {\n  match self.on_memidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_labelidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : LabelIdx,\n) -> TransformerResult[T, LabelIdx] {\n  match self.on_labelidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_laneidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : LaneIdx,\n) -> TransformerResult[T, LaneIdx] {\n  match self.on_laneidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_dataidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : DataIdx,\n) -> TransformerResult[T, DataIdx] {\n  match self.on_dataidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : ElemIdx,\n) -> TransformerResult[T, ElemIdx] {\n  match self.on_elemidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : TagIdx,\n) -> TransformerResult[T, TagIdx] {\n  match self.on_tagidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_valtype(\n  self : ModuleTransformer[T],\n  t : T,\n  vt : ValType,\n) -> TransformerResult[T, ValType] {\n  match self.on_valtype {\n    Some(f) =>\n      match f(self, t, vt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_valtype_default(t, vt)\n        ok => ok\n      }\n    None => self.walk_valtype_default(t, vt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_valtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  vt : ValType,\n) -> TransformerResult[T, ValType] {\n  match vt {\n    RefTypeValType(rt) =>\n      match self.walk_reftype(t, rt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, rt))) => Ok(Some((t, RefTypeValType(rt))))\n      }\n    NumTypeValType(nt) =>\n      match self.walk_numtype(t, nt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, nt))) => Ok(Some((t, NumTypeValType(nt))))\n      }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_numtype(\n  self : ModuleTransformer[T],\n  t : T,\n  nt : NumType,\n) -> TransformerResult[T, NumType] {\n  match self.on_numtype {\n    Some(f) => f(self, t, nt)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_reftype(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RefType,\n) -> TransformerResult[T, RefType] {\n  match self.on_reftype {\n    Some(f) =>\n      match f(self, t, rt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_reftype_default(t, rt)\n        ok => ok\n      }\n    None => self.walk_reftype_default(t, rt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_reftype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RefType,\n) -> TransformerResult[T, RefType] {\n  match rt {\n    HeapTypeRefType(nullable, ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, HeapTypeRefType(nullable, ht))))\n      }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_heaptype(\n  self : ModuleTransformer[T],\n  t : T,\n  ht : HeapType,\n) -> TransformerResult[T, HeapType] {\n  match self.on_heaptype {\n    Some(f) =>\n      match f(self, t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_heaptype_default(t, ht)\n        ok => ok\n      }\n    None => self.walk_heaptype_default(t, ht)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_heaptype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ht : HeapType,\n) -> TransformerResult[T, HeapType] {\n  match ht {\n    HeapType(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, HeapType(ty))))\n      }\n    _ => Ok(None)\n  }\n}\n\n// Sections\n\n///|\npub fn[T] ModuleTransformer::walk_customsec(\n  self : ModuleTransformer[T],\n  t : T,\n  sec : CustomSec,\n) -> TransformerResult[T, CustomSec] {\n  let CustomSec(n, d) = sec\n  match self.walk_name(t, n) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, n))) => Ok(Some((t, CustomSec(n, d))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_customsecs(\n  self : ModuleTransformer[T],\n  t : T,\n  secs : Array[CustomSec],\n) -> TransformerResult[T, Array[CustomSec]] {\n  self.walk_array(t, ModuleTransformer::walk_customsec, secs)\n}\n\n///|\npub fn[T] ModuleTransformer::walk_module(\n  self : ModuleTransformer[T],\n  t : T,\n  mod : Module,\n) -> TransformerResult[T, Module] {\n  let Module(\n    custom,\n    type_sec,\n    import_sec,\n    func_sec,\n    table_sec,\n    mem_sec,\n    tag_sec,\n    global_sec,\n    export_sec,\n    start_sec,\n    elem_sec,\n    datacnt_sec,\n    code_sec,\n    data_sec\n  ) = mod\n  let (t, custom) = match self.walk_customsecs(t, custom) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, custom)\n    Ok(Some(v)) => v\n  }\n  let (t, type_sec) = match type_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_typesec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, import_sec) = match import_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_importsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, func_sec) = match func_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_funcsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, table_sec) = match table_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_tablesec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, mem_sec) = match mem_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_memsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, tag_sec) = match tag_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_tagsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, global_sec) = match global_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_globalsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, export_sec) = match export_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_exportsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, start_sec) = match start_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_startsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, elem_sec) = match elem_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_elemsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, datacnt_sec) = match datacnt_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_datacntsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, code_sec) = match code_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_codesec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, data_sec) = match data_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_datasec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  Ok(\n    Some(\n      (\n        t,\n        Module(\n          custom, type_sec, import_sec, func_sec, table_sec, mem_sec, tag_sec, global_sec,\n          export_sec, start_sec, elem_sec, datacnt_sec, code_sec, data_sec,\n        ),\n      ),\n    ),\n  )\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datasec(\n  self : ModuleTransformer[T],\n  t : T,\n  ds : DataSec,\n) -> TransformerResult[T, DataSec] {\n  match self.on_datasec {\n    Some(f) =>\n      match f(self, t, ds) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_datasec_default(t, ds)\n        ok => ok\n      }\n    None => self.walk_datasec_default(t, ds)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datasec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ds : DataSec,\n) -> TransformerResult[T, DataSec] {\n  let DataSec(ds) = ds\n  match self.walk_array(t, ModuleTransformer::walk_data, ds) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, ds))) => Ok(Some((t, DataSec(ds))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_codesec(\n  self : ModuleTransformer[T],\n  t : T,\n  cs : CodeSec,\n) -> TransformerResult[T, CodeSec] {\n  match self.on_codesec {\n    Some(f) =>\n      match f(self, t, cs) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_codesec_default(t, cs)\n        ok => ok\n      }\n    None => self.walk_codesec_default(t, cs)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_codesec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  cs : CodeSec,\n) -> TransformerResult[T, CodeSec] {\n  let CodeSec(fs) = cs\n  match self.walk_array(t, ModuleTransformer::walk_func, fs) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, fs))) => Ok(Some((t, CodeSec(fs))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datacntsec(\n  self : ModuleTransformer[T],\n  t : T,\n  dcs : DataCntSec,\n) -> TransformerResult[T, DataCntSec] {\n  match self.on_datacntsec {\n    Some(f) => f(self, t, dcs)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemsec(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ElemSec,\n) -> TransformerResult[T, ElemSec] {\n  match self.on_elemsec {\n    Some(f) =>\n      match f(self, t, es) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_elemsec_default(t, es)\n        ok => ok\n      }\n    None => self.walk_elemsec_default(t, es)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ElemSec,\n) -> TransformerResult[T, ElemSec] {\n  let ElemSec(es) = es\n  match self.walk_array(t, ModuleTransformer::walk_elem, es) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, es))) => Ok(Some((t, ElemSec(es))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_startsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ss : StartSec,\n) -> TransformerResult[T, StartSec] {\n  match self.on_startsec {\n    Some(f) =>\n      match f(self, t, ss) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_startsec_default(t, ss)\n        ok => ok\n      }\n    None => self.walk_startsec_default(t, ss)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_startsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ss : StartSec,\n) -> TransformerResult[T, StartSec] {\n  let StartSec(fidx) = ss\n  match self.walk_funcidx(t, fidx) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, fidx))) => Ok(Some((t, StartSec(fidx))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_exportsec(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ExportSec,\n) -> TransformerResult[T, ExportSec] {\n  match self.on_exportsec {\n    Some(f) =>\n      match f(self, t, es) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_exportsec_default(t, es)\n        ok => ok\n      }\n    None => self.walk_exportsec_default(t, es)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_exportsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ExportSec,\n) -> TransformerResult[T, ExportSec] {\n  let ExportSec(es) = es\n  match self.walk_array(t, ModuleTransformer::walk_export, es) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, es))) => Ok(Some((t, ExportSec(es))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TagSec,\n) -> TransformerResult[T, TagSec] {\n  match self.on_tagsec {\n    Some(f) =>\n      match f(self, t, ts) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_tagsec_default(t, ts)\n        ok => ok\n      }\n    None => self.walk_tagsec_default(t, ts)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TagSec,\n) -> TransformerResult[T, TagSec] {\n  let TagSec(tags) = ts\n  match self.walk_array(t, ModuleTransformer::walk_tagtype, tags) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, tags))) => Ok(Some((t, TagSec(tags))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ms : MemSec,\n) -> TransformerResult[T, MemSec] {\n  match self.on_memsec {\n    Some(f) =>\n      match f(self, t, ms) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_memsec_default(t, ms)\n        ok => ok\n      }\n    None => self.walk_memsec_default(t, ms)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ms : MemSec,\n) -> TransformerResult[T, MemSec] {\n  let MemSec(m) = ms\n  match self.walk_array(t, ModuleTransformer::walk_memtype, m) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, m))) => Ok(Some((t, MemSec(m))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tablesec(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TableSec,\n) -> TransformerResult[T, TableSec] {\n  match self.on_tablesec {\n    Some(f) =>\n      match f(self, t, ts) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_tablesec_default(t, ts)\n        ok => ok\n      }\n    None => self.walk_tablesec_default(t, ts)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tablesec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TableSec,\n) -> TransformerResult[T, TableSec] {\n  let TableSec(tts) = ts\n  match self.walk_array(t, ModuleTransformer::walk_table, tts) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, tts))) => Ok(Some((t, TableSec(tts))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_func(\n  self : ModuleTransformer[T],\n  t : T,\n  func : Func,\n) -> TransformerResult[T, Func] {\n  match self.on_func {\n    Some(f) =>\n      match f(self, t, func) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_func_default(t, func)\n        ok => ok\n      }\n    None => self.walk_func_default(t, func)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_func_default(\n  self : ModuleTransformer[T],\n  t : T,\n  f : Func,\n) -> TransformerResult[T, Func] {\n  match f {\n    Func(locals, body) => {\n      let mut locals = locals\n      let t = match self.walk_locals(t, locals) {\n        Err(e) => return Err(e)\n        Ok(None) => t\n        Ok(Some((t, ls))) => {\n          locals = ls\n          t\n        }\n      }\n      match self.walk_expr(t, body) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, body))) => Ok(Some((t, Func(locals, body))))\n      }\n    }\n    TFunc(locals, tbody) => {\n      let (t, locals) = match\n        self.walk_array(t, ModuleTransformer::walk_valtype, locals) {\n        Ok(None) => (t, locals)\n        Ok(Some((t, locals))) => (t, locals)\n        Err(t) => return Err(t)\n      }\n      let (t, tbody) = match self.walk_texpr(t, tbody) {\n        Ok(None) => (t, tbody)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TFunc(locals, tbody))))\n    }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_locals(\n  self : ModuleTransformer[T],\n  t : T,\n  l : Array[Locals],\n) -> TransformerResult[T, Array[Locals]] {\n  match self.on_locals {\n    Some(f) => f(self, t, l)\n    None => self.walk_locals_default(t, l)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_locals_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ls : Array[Locals],\n) -> TransformerResult[T, Array[Locals]] {\n  self.walk_array(t, ModuleTransformer::walk_single_local, ls)\n}\n\n///|\npub fn[T] ModuleTransformer::walk_single_local(\n  self : ModuleTransformer[T],\n  t : T,\n  l : Locals,\n) -> TransformerResult[T, Locals] {\n  let Locals(count, vt) = l\n  match self.walk_valtype(t, vt) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, vt))) => Ok(Some((t, Locals(count, vt))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_importsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ims : ImportSec,\n) -> TransformerResult[T, ImportSec] {\n  let ImportSec(ims) = ims\n  match self.walk_array(t, ModuleTransformer::walk_import, ims) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, ims))) => Ok(Some((t, ImportSec(ims))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_export(\n  self : ModuleTransformer[T],\n  t : T,\n  expt : Export,\n) -> TransformerResult[T, Export] {\n  match self.on_export {\n    Some(f) =>\n      match f(self, t, expt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_export_default(t, expt)\n        ok => ok\n      }\n    None => self.walk_export_default(t, expt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_export_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : Export,\n) -> TransformerResult[T, Export] {\n  let Export(n, ei) = ex\n  let (t, n) = match self.walk_name(t, n) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, n)\n    Ok(Some((t, n))) => (t, n)\n  }\n  let (t, ei) = match self.walk_externidx(t, ei) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, ei)\n    Ok(Some((t, ei))) => (t, ei)\n  }\n  Ok(Some((t, Export(n, ei))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_externidx(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : ExternIdx,\n) -> TransformerResult[T, ExternIdx] {\n  match self.on_externidx {\n    Some(f) =>\n      match f(self, t, ex) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_externidx_default(t, ex)\n        ok => ok\n      }\n    None => self.walk_externidx_default(t, ex)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_externidx_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : ExternIdx,\n) -> TransformerResult[T, ExternIdx] {\n  match ex {\n    FuncExternIdx(fi) =>\n      match self.walk_funcidx(t, fi) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, fi))) => Ok(Some((t, FuncExternIdx(fi))))\n      }\n    TableExternIdx(ti) =>\n      match self.walk_tableidx(t, ti) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ti))) => Ok(Some((t, TableExternIdx(ti))))\n      }\n    MemExternIdx(mi) =>\n      match self.walk_memidx(t, mi) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, mi))) => Ok(Some((t, MemExternIdx(mi))))\n      }\n    GlobalExternIdx(gi) =>\n      match self.walk_globalidx(t, gi) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, gi))) => Ok(Some((t, GlobalExternIdx(gi))))\n      }\n    TagExternIdx(ti) =>\n      match self.walk_tagidx(t, ti) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ti))) => Ok(Some((t, TagExternIdx(ti))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_table(\n  self : ModuleTransformer[T],\n  t : T,\n  tbl : Table,\n) -> TransformerResult[T, Table] {\n  match self.on_table {\n    Some(f) =>\n      match f(self, t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_table_default(t, tbl)\n        ok => ok\n      }\n    None => self.walk_table_default(t, tbl)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_table_default(\n  self : ModuleTransformer[T],\n  t : T,\n  tbl : Table,\n) -> TransformerResult[T, Table] {\n  let Table(tt, e_option) = tbl\n  let (t, tt) = match self.walk_tabletype(t, tt) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, tt)\n    Ok(Some((t, tt))) => (t, tt)\n  }\n  let (t, e_option) = match e_option {\n    None => (t, None)\n    Some(e) =>\n      match self.walk_expr(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(e))\n        Ok(Some((t, e))) => (t, Some(e))\n      }\n  }\n  Ok(Some((t, Table(tt, e_option))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_import(\n  self : ModuleTransformer[T],\n  t : T,\n  im : Import,\n) -> TransformerResult[T, Import] {\n  let Import(n1, n2, ty) = im\n  let (t, n1) = match self.walk_name(t, n1) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, n1)\n    Ok(Some((t, n1))) => (t, n1)\n  }\n  let (t, n2) = match self.walk_name(t, n2) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, n2)\n    Ok(Some((t, n2))) => (t, n2)\n  }\n  let (t, ty) = match self.walk_externtype(t, ty) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, ty)\n    Ok(Some((t, ty))) => (t, ty)\n  }\n  Ok(Some((t, Import(n1, n2, ty))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_externtype(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : ExternType,\n) -> TransformerResult[T, ExternType] {\n  match self.on_externtype {\n    Some(f) => f(self, t, ex)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagtype(\n  self : ModuleTransformer[T],\n  t : T,\n  tt : TagType,\n) -> TransformerResult[T, TagType] {\n  match self.on_tagtype {\n    Some(f) =>\n      match f(self, t, tt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_tagtype_default(t, tt)\n        ok => ok\n      }\n    None => self.walk_tagtype_default(t, tt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  tt : TagType,\n) -> TransformerResult[T, TagType] {\n  let TagType(ti) = tt\n  match self.walk_typeidx(t, ti) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, ti))) => Ok(Some((t, TagType(ti))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memtype(\n  self : ModuleTransformer[T],\n  t : T,\n  mt : MemType,\n) -> TransformerResult[T, MemType] {\n  match self.on_memtype {\n    Some(f) =>\n      match f(self, t, mt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_memtype_default(t, mt)\n        ok => ok\n      }\n    None => self.walk_memtype_default(t, mt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  mt : MemType,\n) -> TransformerResult[T, MemType] {\n  let MemType(l) = mt\n  match self.walk_limits(t, l) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, l))) => Ok(Some((t, MemType(l))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tabletype(\n  self : ModuleTransformer[T],\n  t : T,\n  tt : TableType,\n) -> TransformerResult[T, TableType] {\n  let TableType(rt, l) = tt\n  let (t, rt) = match self.walk_reftype(t, rt) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, rt)\n    Ok(Some((t, rt))) => (t, rt)\n  }\n  let (t, l) = match self.walk_limits(t, l) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, l)\n    Ok(Some((t, l))) => (t, l)\n  }\n  Ok(Some((t, TableType(rt, l))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_limits(\n  self : ModuleTransformer[T],\n  t : T,\n  l : Limits,\n) -> TransformerResult[T, Limits] {\n  match self.on_limits {\n    Some(f) => f(self, t, l)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_typesec(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TypeSec,\n) -> TransformerResult[T, TypeSec] {\n  match self.on_typesec {\n    Some(f) =>\n      match f(self, t, ts) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_typesec_default(t, ts)\n        ok => ok\n      }\n    None => self.walk_typesec_default(t, ts)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_typesec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TypeSec,\n) -> TransformerResult[T, TypeSec] {\n  let TypeSec(rectypes) = ts\n  match self.walk_array(t, ModuleTransformer::walk_rectype, rectypes) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, rectypes))) => Ok(Some((t, TypeSec(rectypes))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_rectype(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RecType,\n) -> TransformerResult[T, RecType] {\n  match self.on_rectype {\n    Some(f) =>\n      match f(self, t, rt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_rectype_default(t, rt)\n        ok => ok\n      }\n    None => self.walk_rectype_default(t, rt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_rectype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RecType,\n) -> TransformerResult[T, RecType] {\n  match rt {\n    SingleRecType(st) =>\n      match self.walk_subtype(t, st) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, st))) => Ok(Some((t, SingleRecType(st))))\n      }\n    GroupRecType(sts) =>\n      match self.walk_array(t, ModuleTransformer::walk_subtype, sts) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, sts))) => Ok(Some((t, GroupRecType(sts))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_subtype(\n  self : ModuleTransformer[T],\n  t : T,\n  st : SubType,\n) -> TransformerResult[T, SubType] {\n  match self.on_subtype {\n    Some(f) =>\n      match f(self, t, st) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_subtype_default(t, st)\n        ok => ok\n      }\n    None => self.walk_subtype_default(t, st)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_subtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  st : SubType,\n) -> TransformerResult[T, SubType] {\n  match st {\n    SubType(f, supers, ct) => {\n      let (t, supers) = match\n        self.walk_array(t, ModuleTransformer::walk_typeidx, supers) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, supers)\n        Ok(Some((t, supers))) => (t, supers)\n      }\n      let (t, ct) = match self.walk_comptype(t, ct) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ct)\n        Ok(Some((t, ct))) => (t, ct)\n      }\n      Ok(Some((t, SubType(f, supers, ct))))\n    }\n    CompTypeSubType(ct) =>\n      match self.walk_comptype(t, ct) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ct))) => Ok(Some((t, CompTypeSubType(ct))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_comptype(\n  self : ModuleTransformer[T],\n  t : T,\n  ct : CompType,\n) -> TransformerResult[T, CompType] {\n  match self.on_comptype {\n    Some(f) =>\n      match f(self, t, ct) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_comptype_default(t, ct)\n        ok => ok\n      }\n    None => self.walk_comptype_default(t, ct)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_comptype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ct : CompType,\n) -> TransformerResult[T, CompType] {\n  match ct {\n    FuncCompType(params, results) => {\n      let (t, params) = match\n        self.walk_array(t, ModuleTransformer::walk_valtype, params) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, params)\n        Ok(Some((t, params))) => (t, params)\n      }\n      let (t, results) = match\n        self.walk_array(t, ModuleTransformer::walk_valtype, results) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, results)\n        Ok(Some((t, results))) => (t, results)\n      }\n      Ok(Some((t, FuncCompType(params, results))))\n    }\n    StructCompType(fields) =>\n      match self.walk_array(t, ModuleTransformer::walk_fieldtype, fields) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, fields))) => Ok(Some((t, StructCompType(fields))))\n      }\n    ArrayCompType(ft) =>\n      match self.walk_fieldtype(t, ft) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ft))) => Ok(Some((t, ArrayCompType(ft))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_fieldtype(\n  self : ModuleTransformer[T],\n  t : T,\n  ft : FieldType,\n) -> TransformerResult[T, FieldType] {\n  match self.on_fieldtype {\n    Some(f) =>\n      match f(self, t, ft) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_fieldtype_default(t, ft)\n        ok => ok\n      }\n    None => self.walk_fieldtype_default(t, ft)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_fieldtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ft : FieldType,\n) -> TransformerResult[T, FieldType] {\n  let FieldType(st, mut_) = ft\n  match self.walk_storagetype(t, st) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, st))) => Ok(Some((t, FieldType(st, mut_))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_storagetype(\n  self : ModuleTransformer[T],\n  t : T,\n  st : StorageType,\n) -> TransformerResult[T, StorageType] {\n  match self.on_storagetype {\n    Some(f) =>\n      match f(self, t, st) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_storagetype_default(t, st)\n        ok => ok\n      }\n    None => self.walk_storagetype_default(t, st)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_storagetype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  st : StorageType,\n) -> TransformerResult[T, StorageType] {\n  match st {\n    ValTypeStorageType(vt) =>\n      match self.walk_valtype(t, vt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, vt))) => Ok(Some((t, ValTypeStorageType(vt))))\n      }\n    PackTypeStorageType(_) => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globalsec(\n  self : ModuleTransformer[T],\n  t : T,\n  gs : GlobalSec,\n) -> TransformerResult[T, GlobalSec] {\n  match self.on_globalsec {\n    Some(f) =>\n      match f(self, t, gs) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_globalsec_default(t, gs)\n        ok => ok\n      }\n    None => self.walk_globalsec_default(t, gs)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globalsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  gs : GlobalSec,\n) -> TransformerResult[T, GlobalSec] {\n  let GlobalSec(gs) = gs\n  match self.walk_array(t, ModuleTransformer::walk_global, gs) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, gs))) => Ok(Some((t, GlobalSec(gs))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_global(\n  self : ModuleTransformer[T],\n  t : T,\n  g : Global,\n) -> TransformerResult[T, Global] {\n  match self.on_global {\n    Some(f) =>\n      match f(self, t, g) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_global_default(t, g)\n        ok => ok\n      }\n    None => self.walk_global_default(t, g)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_global_default(\n  self : ModuleTransformer[T],\n  t : T,\n  g : Global,\n) -> TransformerResult[T, Global] {\n  let Global(gt, init) = g\n  let (t, gt) = match self.walk_globaltype(t, gt) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, gt)\n    Ok(Some((t, gt))) => (t, gt)\n  }\n  let (t, init) = match self.walk_expr(t, init) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, init)\n    Ok(Some((t, init))) => (t, init)\n  }\n  Ok(Some((t, Global(gt, init))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globaltype(\n  self : ModuleTransformer[T],\n  t : T,\n  gt : GlobalType,\n) -> TransformerResult[T, GlobalType] {\n  match self.on_globaltype {\n    Some(f) =>\n      match f(self, t, gt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_globaltype_default(t, gt)\n        ok => ok\n      }\n    None => self.walk_globaltype_default(t, gt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globaltype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  gt : GlobalType,\n) -> TransformerResult[T, GlobalType] {\n  let GlobalType(vt, mutable) = gt\n  match self.walk_valtype(t, vt) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, vt))) => Ok(Some((t, GlobalType(vt, mutable))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elem(\n  self : ModuleTransformer[T],\n  t : T,\n  e : Elem,\n) -> TransformerResult[T, Elem] {\n  let Elem(mode, kind) = e\n  let (t, mode) = match self.walk_elemmode(t, mode) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, mode)\n    Ok(Some((t, mode))) => (t, mode)\n  }\n  let (t, kind) = match self.walk_elemkind(t, kind) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, kind)\n    Ok(Some((t, kind))) => (t, kind)\n  }\n  Ok(Some((t, Elem(mode, kind))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemmode(\n  self : ModuleTransformer[T],\n  t : T,\n  mode : ElemMode,\n) -> TransformerResult[T, ElemMode] {\n  match mode {\n    Active(tidx, offset) => {\n      let (t, tidx) = match self.walk_tableidx(t, tidx) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tidx)\n        Ok(Some((t, tidx))) => (t, tidx)\n      }\n      let (t, offset) = match self.walk_expr(t, offset) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, offset)\n        Ok(Some((t, offset))) => (t, offset)\n      }\n      Ok(Some((t, Active(tidx, offset))))\n    }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemkind(\n  self : ModuleTransformer[T],\n  t : T,\n  ek : ElemKind,\n) -> TransformerResult[T, ElemKind] {\n  match self.on_elemkind {\n    Some(f) =>\n      match f(self, t, ek) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_elemkind_default(t, ek)\n        ok => ok\n      }\n    None => self.walk_elemkind_default(t, ek)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemkind_default(\n  self : ModuleTransformer[T],\n  t : T,\n  kind : ElemKind,\n) -> TransformerResult[T, ElemKind] {\n  match kind {\n    FuncsElemKind(idxs) =>\n      match self.walk_array(t, ModuleTransformer::walk_funcidx, idxs) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, idxs))) => Ok(Some((t, FuncsElemKind(idxs))))\n      }\n    FuncExprsElemKind(exprs) =>\n      match self.walk_array(t, ModuleTransformer::walk_expr, exprs) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, exprs))) => Ok(Some((t, FuncExprsElemKind(exprs))))\n      }\n    TypedExprsElemKind(rt, exprs) => {\n      let (t, rt) = match self.walk_reftype(t, rt) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, rt)\n        Ok(Some((t, rt))) => (t, rt)\n      }\n      let (t, exprs) = match\n        self.walk_array(t, ModuleTransformer::walk_expr, exprs) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, exprs)\n        Ok(Some((t, exprs))) => (t, exprs)\n      }\n      Ok(Some((t, TypedExprsElemKind(rt, exprs))))\n    }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_data(\n  self : ModuleTransformer[T],\n  t : T,\n  d : Data,\n) -> TransformerResult[T, Data] {\n  let Data(mode, bytes) = d\n  let (t, mode) = match self.walk_datamode(t, mode) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, mode)\n    Ok(Some((t, mode))) => (t, mode)\n  }\n  Ok(Some((t, Data(mode, bytes))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datamode(\n  self : ModuleTransformer[T],\n  t : T,\n  mode : DataMode,\n) -> TransformerResult[T, DataMode] {\n  match mode {\n    Active(midx, offset) => {\n      let (t, midx) = match self.walk_memidx(t, midx) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, midx)\n        Ok(Some((t, midx))) => (t, midx)\n      }\n      let (t, offset) = match self.walk_expr(t, offset) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, offset)\n        Ok(Some((t, offset))) => (t, offset)\n      }\n      Ok(Some((t, Active(midx, offset))))\n    }\n    Passive => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_funcsec(\n  self : ModuleTransformer[T],\n  t : T,\n  fs : FuncSec,\n) -> TransformerResult[T, FuncSec] {\n  match self.on_funcsec {\n    Some(f) =>\n      match f(self, t, fs) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_funcsec_default(t, fs)\n        ok => ok\n      }\n    None => self.walk_funcsec_default(t, fs)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_funcsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  fs : FuncSec,\n) -> TransformerResult[T, FuncSec] {\n  let FuncSec(idxs) = fs\n  match self.walk_array(t, ModuleTransformer::walk_typeidx, idxs) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, idxs))) => Ok(Some((t, FuncSec(idxs))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_unaryop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : UnaryOp,\n) -> TransformerResult[T, UnaryOp] {\n  match self.on_unaryop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_binaryop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : BinaryOp,\n) -> TransformerResult[T, BinaryOp] {\n  match self.on_binaryop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_storeop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : StoreOp,\n) -> TransformerResult[T, StoreOp] {\n  match self.on_storeop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memarg(\n  self : ModuleTransformer[T],\n  t : T,\n  ma : MemArg,\n) -> TransformerResult[T, MemArg] {\n  match self.on_memarg {\n    Some(f) => f(self, t, ma)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_loadop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : LoadOp,\n) -> TransformerResult[T, LoadOp] {\n  match self.on_loadop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_extractlaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : ExtractLaneOp,\n) -> TransformerResult[T, ExtractLaneOp] {\n  match self.on_extractlaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_replacelaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : ReplaceLaneOp,\n) -> TransformerResult[T, ReplaceLaneOp] {\n  match self.on_replacelaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128shiftop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128ShiftOp,\n) -> TransformerResult[T, V128ShiftOp] {\n  match self.on_v128shiftop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128ternaryop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128TernaryOp,\n) -> TransformerResult[T, V128TernaryOp] {\n  match self.on_v128ternaryop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128loadlaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128LoadLaneOp,\n) -> TransformerResult[T, V128LoadLaneOp] {\n  match self.on_v128loadlaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128storelaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128StoreLaneOp,\n) -> TransformerResult[T, V128StoreLaneOp] {\n  match self.on_v128storelaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n","///|\npub(all) struct S33(UInt) derive(Eq, Hash)\n\n///|\npub(all) struct I32(Int) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct I64(Int64) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct F32(Float) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct F64(Double) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct U32(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct U64(UInt64) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum NumType {\n  F32NumType\n  F64NumType\n  I32NumType\n  I64NumType\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum AbsHeapType {\n  ExnAbsHeapType\n  ArrayAbsHeapType\n  StructAbsHeapType\n  I31AbsHeapType\n  EqAbsHeapType\n  AnyAbsHeapType\n  ExternAbsHeapType\n  FuncAbsHeapType\n  NoneAbsHeapType\n  NoExternAbsHeapType\n  NoFuncAbsHeapType\n  NoExnAbsHeapType\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum HeapType {\n  AbsHeapTypeHeapType(AbsHeapType)\n  HeapType(TypeIdx)\n  DefTypeHeapType(DefType)\n} derive(Eq, Hash)\n\n///|\npub(all) enum RefType {\n  HeapTypeRefType(Bool, HeapType)\n  AbsHeapTypeRefType(AbsHeapType)\n} derive(Arbitrary, Hash)\n\n///|\npub(all) enum ValType {\n  NumTypeValType(NumType)\n  VecTypeValType\n  RefTypeValType(RefType)\n  BotValType\n} derive(Eq, Hash)\n\n///|\npub type ResultType = Array[ValType]\n\n///|\npub(all) enum PackType {\n  I16PackType\n  I8PackType\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum StorageType {\n  ValTypeStorageType(ValType)\n  PackTypeStorageType(PackType)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct FieldType(StorageType, Mut) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum Mut {\n  Const\n  Var\n} derive(Arbitrary, Eq, Hash)\n\n///|\npub(all) enum TypeIdx {\n  TypeIdx(UInt)\n  RecIdx(UInt)\n} derive(Eq, Hash)\n\n///|\npub(all) struct FuncIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TableIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct GlobalIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TagIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ElemIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct DataIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct LocalIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct LabelIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct LaneIdx(Byte) derive(Eq, Hash)\n\n///|\npub(all) enum CompType {\n  ArrayCompType(FieldType)\n  StructCompType(Array[FieldType])\n  FuncCompType(ResultType, ResultType)\n} derive(Eq, Hash)\n\n///|\npub(all) enum SubType {\n  SubType(Bool, Array[TypeIdx], CompType)\n  CompTypeSubType(CompType)\n} derive(Eq, Hash)\n\n///|\npub(all) enum RecType {\n  SingleRecType(SubType)\n  GroupRecType(Array[SubType])\n} derive(Hash)\n\n///|\npub(all) struct DefType(RecType, UInt) derive(Eq, Hash)\n\n///|\npub(all) enum Limits {\n  I32Limits(UInt, UInt?)\n  I64Limits(UInt64, UInt64?)\n} derive(Eq, Hash)\n\n///|\npub(all) struct TagType(TypeIdx) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct GlobalType(ValType, Bool) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemType(Limits) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TableType(RefType, Limits) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ExternType {\n  FuncExternType(TypeIdx)\n  TableExternType(TableType)\n  MemExternType(MemType)\n  GlobalExternType(GlobalType)\n  TagExternType(TagType)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ExternIdx {\n  FuncExternIdx(FuncIdx)\n  TableExternIdx(TableIdx)\n  MemExternIdx(MemIdx)\n  GlobalExternIdx(GlobalIdx)\n  TagExternIdx(TagIdx)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ElemMode {\n  Passive\n  Active(TableIdx, Expr)\n  Declarative\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ElemKind {\n  FuncsElemKind(Array[FuncIdx])\n  FuncExprsElemKind(Array[Expr])\n  TypedExprsElemKind(RefType, Array[Expr])\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Elem(ElemMode, ElemKind) derive(Eq, Hash)\n\n///|\npub(all) struct Expr(Array[Instruction]) derive(Eq, Hash)\n\n///|\npub(all) struct Import(Name, Name, ExternType) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Table(TableType, Expr?) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Global(GlobalType, Expr) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Export(Name, ExternIdx) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Locals(UInt, ValType) derive(Eq, Hash)\n\n///|\npub(all) enum DataMode {\n  Active(MemIdx, Expr)\n  Passive\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Data(DataMode, Bytes) derive(Eq, Hash)\n\n///|\npub(all) struct Name(StringView) derive(Eq, Hash)\n\n///|\npub(all) struct Module(\n  Array[CustomSec],\n  TypeSec?,\n  ImportSec?,\n  FuncSec?,\n  TableSec?,\n  MemSec?,\n  TagSec?,\n  GlobalSec?,\n  ExportSec?,\n  StartSec?,\n  ElemSec?,\n  DataCntSec?,\n  CodeSec?,\n  DataSec?\n) derive(Hash)\n\n///|\npub(all) struct FuncType(Array[ValType], Array[ValType]) derive(Hash)\n\n///|\npub(all) struct Env {\n  global_types : Array[SubType]\n  rec_stack : Stack[Array[SubType]]\n  funcs : Array[FuncType]\n  tables : Array[TableType]\n  mems : Array[MemType]\n  globals : Array[GlobalType]\n  elems : Array[Elem]\n  datas : Array[Data]\n  tags : Array[TagType]\n  locals : Array[ValType]\n  labels : Stack[Array[ValType]]\n  return_type : Array[ValType]?\n} derive(Hash)\n\n///|\npub(all) enum Func {\n  Func(Array[Locals], Expr)\n  TFunc(Array[ValType], TExpr)\n} derive(Eq, Hash)\n\n///|\npub impl @quickcheck.Arbitrary for CompType with arbitrary(t, state) {\n  match state.next_uint() % 3 {\n    1 => StructCompType(array_of_arbitrary(5, t, state))\n    2 =>\n      FuncCompType(\n        array_of_arbitrary(5, t, state),\n        array_of_arbitrary(5, t, state),\n      )\n    _ => ArrayCompType(@quickcheck.Arbitrary::arbitrary(t, state))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for RecType with arbitrary(t, state) {\n  if (state.next_uint() & 1) == 1 {\n    SingleRecType(@quickcheck.Arbitrary::arbitrary(t, state))\n  } else {\n    GroupRecType(array_of_arbitrary(5, t, state))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for HeapType with arbitrary(size, st) {\n  if (st.next_uint() & 1) == 1 {\n    AbsHeapTypeHeapType(@quickcheck.Arbitrary::arbitrary(size, st))\n  } else {\n    HeapType(@quickcheck.Arbitrary::arbitrary(size, st))\n  }\n  // Def types are not arbitrary\n}\n\n///|\npub impl @quickcheck.Arbitrary for ValType with arbitrary(size, st) {\n  match st.next_uint() % 3 {\n    0 => NumTypeValType(@quickcheck.Arbitrary::arbitrary(size, st))\n    1 => VecTypeValType\n    2 => RefTypeValType(@quickcheck.Arbitrary::arbitrary(size, st))\n    _ => VecTypeValType\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for TypeIdx with arbitrary(_, st) {\n  TypeIdx(st.next_uint())\n  // recursive indexes are not arbitrary\n}\n\n///|\npub impl @quickcheck.Arbitrary for LaneIdx with arbitrary(_, state) {\n  let b : Byte = (state.next_uint() % 16).to_byte()\n  LaneIdx(b)\n}\n\n///|\npub impl @quickcheck.Arbitrary for SubType with arbitrary(t, st) {\n  if st.next_uint() % 2 == 1 {\n    SubType(\n      st.next_uint() % 2 == 1,\n      array_of_arbitrary(1, t, st),\n      @quickcheck.Arbitrary::arbitrary(t, st),\n    )\n  } else {\n    CompTypeSubType(@quickcheck.Arbitrary::arbitrary(t, st))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for DefType with arbitrary(t, state) {\n  let s = @quickcheck.Arbitrary::arbitrary(t, state)\n  match s {\n    SingleRecType(_) => DefType(s, 0)\n    GroupRecType(g) => {\n      let idx = state.next_uint() % g.length().reinterpret_as_uint()\n      DefType(s, idx)\n    }\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for Limits with arbitrary(_, state) {\n  if (state.next_uint() & 1) == 1 {\n    if (state.next_uint() & 1) == 1 {\n      I32Limits(state.next_uint(), None)\n    } else {\n      let a : UInt = state.next_uint()\n      let b : UInt = state.next_uint()\n      let min = if a > b { b } else { a }\n      let max = if a > b { a } else { b }\n      I32Limits(min, Some(max))\n    }\n  } else if (state.next_uint() & 1) == 1 {\n    I64Limits(state.next_uint64(), None)\n  } else {\n    let a : UInt64 = state.next_uint64()\n    let b : UInt64 = state.next_uint64()\n    let min = if a > b { b } else { a }\n    let max = if a > b { a } else { b }\n    I64Limits(min, Some(max))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for Elem with arbitrary(size, state) {\n  match state.next_uint() % 8 {\n    // 0x00: Active(table 0) + FuncsElemKind\n    0 => {\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Active(TableIdx(0), expr), FuncsElemKind(funcs))\n    }\n    // 0x01: Passive + FuncsElemKind\n    1 => {\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Passive, FuncsElemKind(funcs))\n    }\n    // 0x02: Active(any table) + FuncsElemKind\n    2 => {\n      let ti : TableIdx = @quickcheck.Arbitrary::arbitrary(size, state)\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Active(ti, expr), FuncsElemKind(funcs))\n    }\n    // 0x03: Declarative + FuncsElemKind\n    3 => {\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Declarative, FuncsElemKind(funcs))\n    }\n    // 0x04: Active(table 0) + FuncExprsElemKind\n    4 => {\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Active(TableIdx(0), expr), FuncExprsElemKind(exprs))\n    }\n    // 0x05: Passive + TypedExprsElemKind (covers FuncExprsElemKind too)\n    5 => {\n      let rt : RefType = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Passive, TypedExprsElemKind(rt, exprs))\n    }\n    // 0x06: Active(any table) + FuncExprsElemKind\n    6 => {\n      let ti : TableIdx = @quickcheck.Arbitrary::arbitrary(size, state)\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Active(ti, expr), FuncExprsElemKind(exprs))\n    }\n    // 0x07: Declarative + TypedExprsElemKind\n    _ => {\n      let rt : RefType = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Declarative, TypedExprsElemKind(rt, exprs))\n    }\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for Expr with arbitrary(t, state) {\n  Expr([\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n  ])\n}\n\n///|\npub impl @quickcheck.Arbitrary for Locals with arbitrary(t, state) {\n  let count = state.next_positive_int() % 3 + 1\n  Locals(\n    count.reinterpret_as_uint(),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n  )\n}\n\n///|\npub impl @quickcheck.Arbitrary for Func with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  Func(elems, @quickcheck.Arbitrary::arbitrary(t, state))\n}\n\n///|\npub impl @quickcheck.Arbitrary for Data with arbitrary(t, state) {\n  let size = state.next_positive_int() % 10 + 1\n  Data(\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(size, state),\n  )\n}\n\n///|\npub impl @quickcheck.Arbitrary for Name with arbitrary(_, state) {\n  let count = state.next_positive_int() % 5\n  let sb = StringBuilder::new(size_hint=count)\n  loop (count, state.next_positive_int() % 91799) {\n    (0, _) => break\n    (n, i) if (i >= 32 && i <= 126) ||\n      (i >= 160 && i <= 172) ||\n      (i >= 174 && i <= 887) ||\n      (i >= 890 && i <= 895) ||\n      (i >= 900 && i <= 906) ||\n      (i >= 908 && i <= 908) ||\n      (i >= 910 && i <= 929) ||\n      (i >= 931 && i <= 1327) ||\n      (i >= 1329 && i <= 1366) ||\n      (i >= 1369 && i <= 1418) ||\n      (i >= 1421 && i <= 1423) ||\n      (i >= 1425 && i <= 1479) ||\n      (i >= 1488 && i <= 1514) ||\n      (i >= 1519 && i <= 1524) ||\n      (i >= 1542 && i <= 1563) ||\n      (i >= 1565 && i <= 1756) ||\n      (i >= 1758 && i <= 1805) ||\n      (i >= 1808 && i <= 1866) ||\n      (i >= 1869 && i <= 1969) ||\n      (i >= 1984 && i <= 2042) ||\n      (i >= 2045 && i <= 2093) ||\n      (i >= 2096 && i <= 2110) ||\n      (i >= 2112 && i <= 2139) ||\n      (i >= 2142 && i <= 2142) ||\n      (i >= 2144 && i <= 2154) ||\n      (i >= 2160 && i <= 2191) ||\n      (i >= 2199 && i <= 2273) ||\n      (i >= 2275 && i <= 2435) ||\n      (i >= 2437 && i <= 2444) ||\n      (i >= 2447 && i <= 2448) ||\n      (i >= 2451 && i <= 2472) ||\n      (i >= 2474 && i <= 2480) ||\n      (i >= 2482 && i <= 2482) ||\n      (i >= 2486 && i <= 2489) ||\n      (i >= 2492 && i <= 2500) ||\n      (i >= 2503 && i <= 2504) ||\n      (i >= 2507 && i <= 2510) ||\n      (i >= 2519 && i <= 2519) ||\n      (i >= 2524 && i <= 2525) ||\n      (i >= 2527 && i <= 2531) ||\n      (i >= 2534 && i <= 2558) ||\n      (i >= 2561 && i <= 2563) ||\n      (i >= 2565 && i <= 2570) ||\n      (i >= 2575 && i <= 2576) ||\n      (i >= 2579 && i <= 2600) ||\n      (i >= 2602 && i <= 2608) ||\n      (i >= 2610 && i <= 2611) ||\n      (i >= 2613 && i <= 2614) ||\n      (i >= 2616 && i <= 2617) ||\n      (i >= 2620 && i <= 2620) ||\n      (i >= 2622 && i <= 2626) ||\n      (i >= 2631 && i <= 2632) ||\n      (i >= 2635 && i <= 2637) ||\n      (i >= 2641 && i <= 2641) ||\n      (i >= 2649 && i <= 2652) ||\n      (i >= 2654 && i <= 2654) ||\n      (i >= 2662 && i <= 2678) ||\n      (i >= 2689 && i <= 2691) ||\n      (i >= 2693 && i <= 2701) ||\n      (i >= 2703 && i <= 2705) ||\n      (i >= 2707 && i <= 2728) ||\n      (i >= 2730 && i <= 2736) ||\n      (i >= 2738 && i <= 2739) ||\n      (i >= 2741 && i <= 2745) ||\n      (i >= 2748 && i <= 2757) ||\n      (i >= 2759 && i <= 2761) ||\n      (i >= 2763 && i <= 2765) ||\n      (i >= 2768 && i <= 2768) ||\n      (i >= 2784 && i <= 2787) ||\n      (i >= 2790 && i <= 2801) ||\n      (i >= 2809 && i <= 2815) ||\n      (i >= 2817 && i <= 2819) ||\n      (i >= 2821 && i <= 2828) ||\n      (i >= 2831 && i <= 2832) ||\n      (i >= 2835 && i <= 2856) ||\n      (i >= 2858 && i <= 2864) ||\n      (i >= 2866 && i <= 2867) ||\n      (i >= 2869 && i <= 2873) ||\n      (i >= 2876 && i <= 2884) ||\n      (i >= 2887 && i <= 2888) ||\n      (i >= 2891 && i <= 2893) ||\n      (i >= 2901 && i <= 2903) ||\n      (i >= 2908 && i <= 2909) ||\n      (i >= 2911 && i <= 2915) ||\n      (i >= 2918 && i <= 2935) ||\n      (i >= 2946 && i <= 2947) ||\n      (i >= 2949 && i <= 2954) ||\n      (i >= 2958 && i <= 2960) ||\n      (i >= 2962 && i <= 2965) ||\n      (i >= 2969 && i <= 2970) ||\n      (i >= 2972 && i <= 2972) ||\n      (i >= 2974 && i <= 2975) ||\n      (i >= 2979 && i <= 2980) ||\n      (i >= 2984 && i <= 2986) ||\n      (i >= 2990 && i <= 3001) ||\n      (i >= 3006 && i <= 3010) ||\n      (i >= 3014 && i <= 3016) ||\n      (i >= 3018 && i <= 3021) ||\n      (i >= 3024 && i <= 3024) ||\n      (i >= 3031 && i <= 3031) ||\n      (i >= 3046 && i <= 3066) ||\n      (i >= 3072 && i <= 3084) ||\n      (i >= 3086 && i <= 3088) ||\n      (i >= 3090 && i <= 3112) ||\n      (i >= 3114 && i <= 3129) ||\n      (i >= 3132 && i <= 3140) ||\n      (i >= 3142 && i <= 3144) ||\n      (i >= 3146 && i <= 3149) ||\n      (i >= 3157 && i <= 3158) ||\n      (i >= 3160 && i <= 3162) ||\n      (i >= 3164 && i <= 3165) ||\n      (i >= 3168 && i <= 3171) ||\n      (i >= 3174 && i <= 3183) ||\n      (i >= 3191 && i <= 3212) ||\n      (i >= 3214 && i <= 3216) ||\n      (i >= 3218 && i <= 3240) ||\n      (i >= 3242 && i <= 3251) ||\n      (i >= 3253 && i <= 3257) ||\n      (i >= 3260 && i <= 3268) ||\n      (i >= 3270 && i <= 3272) ||\n      (i >= 3274 && i <= 3277) ||\n      (i >= 3285 && i <= 3286) ||\n      (i >= 3292 && i <= 3294) ||\n      (i >= 3296 && i <= 3299) ||\n      (i >= 3302 && i <= 3311) ||\n      (i >= 3313 && i <= 3315) ||\n      (i >= 3328 && i <= 3340) ||\n      (i >= 3342 && i <= 3344) ||\n      (i >= 3346 && i <= 3396) ||\n      (i >= 3398 && i <= 3400) ||\n      (i >= 3402 && i <= 3407) ||\n      (i >= 3412 && i <= 3427) ||\n      (i >= 3430 && i <= 3455) ||\n      (i >= 3457 && i <= 3459) ||\n      (i >= 3461 && i <= 3478) ||\n      (i >= 3482 && i <= 3505) ||\n      (i >= 3507 && i <= 3515) ||\n      (i >= 3517 && i <= 3517) ||\n      (i >= 3520 && i <= 3526) ||\n      (i >= 3530 && i <= 3530) ||\n      (i >= 3535 && i <= 3540) ||\n      (i >= 3542 && i <= 3542) ||\n      (i >= 3544 && i <= 3551) ||\n      (i >= 3558 && i <= 3567) ||\n      (i >= 3570 && i <= 3572) ||\n      (i >= 3585 && i <= 3642) ||\n      (i >= 3647 && i <= 3675) ||\n      (i >= 3713 && i <= 3714) ||\n      (i >= 3716 && i <= 3716) ||\n      (i >= 3718 && i <= 3722) ||\n      (i >= 3724 && i <= 3747) ||\n      (i >= 3749 && i <= 3749) ||\n      (i >= 3751 && i <= 3773) ||\n      (i >= 3776 && i <= 3780) ||\n      (i >= 3782 && i <= 3782) ||\n      (i >= 3784 && i <= 3790) ||\n      (i >= 3792 && i <= 3801) ||\n      (i >= 3804 && i <= 3807) ||\n      (i >= 3840 && i <= 3911) ||\n      (i >= 3913 && i <= 3948) ||\n      (i >= 3953 && i <= 3991) ||\n      (i >= 3993 && i <= 4028) ||\n      (i >= 4030 && i <= 4044) ||\n      (i >= 4046 && i <= 4058) ||\n      (i >= 4096 && i <= 4293) ||\n      (i >= 4295 && i <= 4295) ||\n      (i >= 4301 && i <= 4301) ||\n      (i >= 4304 && i <= 4680) ||\n      (i >= 4682 && i <= 4685) ||\n      (i >= 4688 && i <= 4694) ||\n      (i >= 4696 && i <= 4696) ||\n      (i >= 4698 && i <= 4701) ||\n      (i >= 4704 && i <= 4744) ||\n      (i >= 4746 && i <= 4749) ||\n      (i >= 4752 && i <= 4784) ||\n      (i >= 4786 && i <= 4789) ||\n      (i >= 4792 && i <= 4798) ||\n      (i >= 4800 && i <= 4800) ||\n      (i >= 4802 && i <= 4805) ||\n      (i >= 4808 && i <= 4822) ||\n      (i >= 4824 && i <= 4880) ||\n      (i >= 4882 && i <= 4885) ||\n      (i >= 4888 && i <= 4954) ||\n      (i >= 4957 && i <= 4988) ||\n      (i >= 4992 && i <= 5017) ||\n      (i >= 5024 && i <= 5109) ||\n      (i >= 5112 && i <= 5117) ||\n      (i >= 5120 && i <= 5788) ||\n      (i >= 5792 && i <= 5880) ||\n      (i >= 5888 && i <= 5909) ||\n      (i >= 5919 && i <= 5942) ||\n      (i >= 5952 && i <= 5971) ||\n      (i >= 5984 && i <= 5996) ||\n      (i >= 5998 && i <= 6000) ||\n      (i >= 6002 && i <= 6003) ||\n      (i >= 6016 && i <= 6109) ||\n      (i >= 6112 && i <= 6121) ||\n      (i >= 6128 && i <= 6137) ||\n      (i >= 6144 && i <= 6157) ||\n      (i >= 6159 && i <= 6169) ||\n      (i >= 6176 && i <= 6264) ||\n      (i >= 6272 && i <= 6314) ||\n      (i >= 6320 && i <= 6389) ||\n      (i >= 6400 && i <= 6430) ||\n      (i >= 6432 && i <= 6443) ||\n      (i >= 6448 && i <= 6459) ||\n      (i >= 6464 && i <= 6464) ||\n      (i >= 6468 && i <= 6509) ||\n      (i >= 6512 && i <= 6516) ||\n      (i >= 6528 && i <= 6571) ||\n      (i >= 6576 && i <= 6601) ||\n      (i >= 6608 && i <= 6618) ||\n      (i >= 6622 && i <= 6683) ||\n      (i >= 6686 && i <= 6750) ||\n      (i >= 6752 && i <= 6780) ||\n      (i >= 6783 && i <= 6793) ||\n      (i >= 6800 && i <= 6809) ||\n      (i >= 6816 && i <= 6829) ||\n      (i >= 6832 && i <= 6877) ||\n      (i >= 6880 && i <= 6891) ||\n      (i >= 6912 && i <= 6988) ||\n      (i >= 6990 && i <= 7155) ||\n      (i >= 7164 && i <= 7223) ||\n      (i >= 7227 && i <= 7241) ||\n      (i >= 7245 && i <= 7306) ||\n      (i >= 7312 && i <= 7354) ||\n      (i >= 7357 && i <= 7367) ||\n      (i >= 7376 && i <= 7418) ||\n      (i >= 7424 && i <= 7957) ||\n      (i >= 7960 && i <= 7965) ||\n      (i >= 7968 && i <= 8005) ||\n      (i >= 8008 && i <= 8013) ||\n      (i >= 8016 && i <= 8023) ||\n      (i >= 8025 && i <= 8025) ||\n      (i >= 8027 && i <= 8027) ||\n      (i >= 8029 && i <= 8029) ||\n      (i >= 8031 && i <= 8061) ||\n      (i >= 8064 && i <= 8116) ||\n      (i >= 8118 && i <= 8132) ||\n      (i >= 8134 && i <= 8147) ||\n      (i >= 8150 && i <= 8155) ||\n      (i >= 8157 && i <= 8175) ||\n      (i >= 8178 && i <= 8180) ||\n      (i >= 8182 && i <= 8190) ||\n      (i >= 8192 && i <= 8202) ||\n      (i >= 8208 && i <= 8233) ||\n      (i >= 8239 && i <= 8287) ||\n      (i >= 8304 && i <= 8305) ||\n      (i >= 8308 && i <= 8334) ||\n      (i >= 8336 && i <= 8348) ||\n      (i >= 8352 && i <= 8385) ||\n      (i >= 8400 && i <= 8432) ||\n      (i >= 8448 && i <= 8587) ||\n      (i >= 8592 && i <= 9257) ||\n      (i >= 9280 && i <= 9290) ||\n      (i >= 9312 && i <= 11123) ||\n      (i >= 11126 && i <= 11507) ||\n      (i >= 11513 && i <= 11557) ||\n      (i >= 11559 && i <= 11559) ||\n      (i >= 11565 && i <= 11565) ||\n      (i >= 11568 && i <= 11623) ||\n      (i >= 11631 && i <= 11632) ||\n      (i >= 11647 && i <= 11670) ||\n      (i >= 11680 && i <= 11686) ||\n      (i >= 11688 && i <= 11694) ||\n      (i >= 11696 && i <= 11702) ||\n      (i >= 11704 && i <= 11710) ||\n      (i >= 11712 && i <= 11718) ||\n      (i >= 11720 && i <= 11726) ||\n      (i >= 11728 && i <= 11734) ||\n      (i >= 11736 && i <= 11742) ||\n      (i >= 11744 && i <= 11869) ||\n      (i >= 11904 && i <= 11929) ||\n      (i >= 11931 && i <= 12019) ||\n      (i >= 12032 && i <= 12245) ||\n      (i >= 12272 && i <= 12351) ||\n      (i >= 12353 && i <= 12438) ||\n      (i >= 12441 && i <= 12543) ||\n      (i >= 12549 && i <= 12591) ||\n      (i >= 12593 && i <= 12686) ||\n      (i >= 12688 && i <= 12773) ||\n      (i >= 12783 && i <= 12830) ||\n      (i >= 12832 && i <= 42124) ||\n      (i >= 42128 && i <= 42182) ||\n      (i >= 42192 && i <= 42539) ||\n      (i >= 42560 && i <= 42743) ||\n      (i >= 42752 && i <= 42972) ||\n      (i >= 42993 && i <= 43052) ||\n      (i >= 43056 && i <= 43065) ||\n      (i >= 43072 && i <= 43127) ||\n      (i >= 43136 && i <= 43205) ||\n      (i >= 43214 && i <= 43225) ||\n      (i >= 43232 && i <= 43347) ||\n      (i >= 43359 && i <= 43388) ||\n      (i >= 43392 && i <= 43469) ||\n      (i >= 43471 && i <= 43481) ||\n      (i >= 43486 && i <= 43518) ||\n      (i >= 43520 && i <= 43574) ||\n      (i >= 43584 && i <= 43597) ||\n      (i >= 43600 && i <= 43609) ||\n      (i >= 43612 && i <= 43714) ||\n      (i >= 43739 && i <= 43766) ||\n      (i >= 43777 && i <= 43782) ||\n      (i >= 43785 && i <= 43790) ||\n      (i >= 43793 && i <= 43798) ||\n      (i >= 43808 && i <= 43814) ||\n      (i >= 43816 && i <= 43822) ||\n      (i >= 43824 && i <= 43883) ||\n      (i >= 43888 && i <= 44013) ||\n      (i >= 44016 && i <= 44025) ||\n      (i >= 44032 && i <= 55203) ||\n      (i >= 55216 && i <= 55238) ||\n      (i >= 55243 && i <= 55291) ||\n      (i >= 63744 && i <= 64109) ||\n      (i >= 64112 && i <= 64217) ||\n      (i >= 64256 && i <= 64262) ||\n      (i >= 64275 && i <= 64279) ||\n      (i >= 64285 && i <= 64310) ||\n      (i >= 64312 && i <= 64316) ||\n      (i >= 64318 && i <= 64318) ||\n      (i >= 64320 && i <= 64321) ||\n      (i >= 64323 && i <= 64324) ||\n      (i >= 64326 && i <= 64975) ||\n      (i >= 65008 && i <= 65049) ||\n      (i >= 65056 && i <= 65106) ||\n      (i >= 65108 && i <= 65126) ||\n      (i >= 65128 && i <= 65131) ||\n      (i >= 65136 && i <= 65140) ||\n      (i >= 65142 && i <= 65276) ||\n      (i >= 65281 && i <= 65470) ||\n      (i >= 65474 && i <= 65479) ||\n      (i >= 65482 && i <= 65487) ||\n      (i >= 65490 && i <= 65495) ||\n      (i >= 65498 && i <= 65500) ||\n      (i >= 65504 && i <= 65510) ||\n      (i >= 65512 && i <= 65518) ||\n      (i >= 65532 && i <= 65533) ||\n      (i >= 65536 && i <= 65547) ||\n      (i >= 65549 && i <= 65574) ||\n      (i >= 65576 && i <= 65594) ||\n      (i >= 65596 && i <= 65597) ||\n      (i >= 65599 && i <= 65613) ||\n      (i >= 65616 && i <= 65629) ||\n      (i >= 65664 && i <= 65786) ||\n      (i >= 65792 && i <= 65794) ||\n      (i >= 65799 && i <= 65843) ||\n      (i >= 65847 && i <= 65934) ||\n      (i >= 65936 && i <= 65948) ||\n      (i >= 65952 && i <= 65952) ||\n      (i >= 66000 && i <= 66045) ||\n      (i >= 66176 && i <= 66204) ||\n      (i >= 66208 && i <= 66256) ||\n      (i >= 66272 && i <= 66299) ||\n      (i >= 66304 && i <= 66339) ||\n      (i >= 66349 && i <= 66378) ||\n      (i >= 66384 && i <= 66426) ||\n      (i >= 66432 && i <= 66461) ||\n      (i >= 66463 && i <= 66499) ||\n      (i >= 66504 && i <= 66517) ||\n      (i >= 66560 && i <= 66717) ||\n      (i >= 66720 && i <= 66729) ||\n      (i >= 66736 && i <= 66771) ||\n      (i >= 66776 && i <= 66811) ||\n      (i >= 66816 && i <= 66855) ||\n      (i >= 66864 && i <= 66915) ||\n      (i >= 66927 && i <= 66938) ||\n      (i >= 66940 && i <= 66954) ||\n      (i >= 66956 && i <= 66962) ||\n      (i >= 66964 && i <= 66965) ||\n      (i >= 66967 && i <= 66977) ||\n      (i >= 66979 && i <= 66993) ||\n      (i >= 66995 && i <= 67001) ||\n      (i >= 67003 && i <= 67004) ||\n      (i >= 67008 && i <= 67059) ||\n      (i >= 67072 && i <= 67382) ||\n      (i >= 67392 && i <= 67413) ||\n      (i >= 67424 && i <= 67431) ||\n      (i >= 67456 && i <= 67461) ||\n      (i >= 67463 && i <= 67504) ||\n      (i >= 67506 && i <= 67514) ||\n      (i >= 67584 && i <= 67589) ||\n      (i >= 67592 && i <= 67592) ||\n      (i >= 67594 && i <= 67637) ||\n      (i >= 67639 && i <= 67640) ||\n      (i >= 67644 && i <= 67644) ||\n      (i >= 67647 && i <= 67669) ||\n      (i >= 67671 && i <= 67742) ||\n      (i >= 67751 && i <= 67759) ||\n      (i >= 67808 && i <= 67826) ||\n      (i >= 67828 && i <= 67829) ||\n      (i >= 67835 && i <= 67867) ||\n      (i >= 67871 && i <= 67897) ||\n      (i >= 67903 && i <= 67929) ||\n      (i >= 67968 && i <= 68023) ||\n      (i >= 68028 && i <= 68047) ||\n      (i >= 68050 && i <= 68099) ||\n      (i >= 68101 && i <= 68102) ||\n      (i >= 68108 && i <= 68115) ||\n      (i >= 68117 && i <= 68119) ||\n      (i >= 68121 && i <= 68149) ||\n      (i >= 68152 && i <= 68154) ||\n      (i >= 68159 && i <= 68168) ||\n      (i >= 68176 && i <= 68184) ||\n      (i >= 68192 && i <= 68255) ||\n      (i >= 68288 && i <= 68326) ||\n      (i >= 68331 && i <= 68342) ||\n      (i >= 68352 && i <= 68405) ||\n      (i >= 68409 && i <= 68437) ||\n      (i >= 68440 && i <= 68466) ||\n      (i >= 68472 && i <= 68497) ||\n      (i >= 68505 && i <= 68508) ||\n      (i >= 68521 && i <= 68527) ||\n      (i >= 68608 && i <= 68680) ||\n      (i >= 68736 && i <= 68786) ||\n      (i >= 68800 && i <= 68850) ||\n      (i >= 68858 && i <= 68903) ||\n      (i >= 68912 && i <= 68921) ||\n      (i >= 68928 && i <= 68965) ||\n      (i >= 68969 && i <= 68997) ||\n      (i >= 69006 && i <= 69007) ||\n      (i >= 69216 && i <= 69246) ||\n      (i >= 69248 && i <= 69289) ||\n      (i >= 69291 && i <= 69293) ||\n      (i >= 69296 && i <= 69297) ||\n      (i >= 69314 && i <= 69319) ||\n      (i >= 69328 && i <= 69336) ||\n      (i >= 69370 && i <= 69415) ||\n      (i >= 69424 && i <= 69465) ||\n      (i >= 69488 && i <= 69513) ||\n      (i >= 69552 && i <= 69579) ||\n      (i >= 69600 && i <= 69622) ||\n      (i >= 69632 && i <= 69709) ||\n      (i >= 69714 && i <= 69749) ||\n      (i >= 69759 && i <= 69820) ||\n      (i >= 69822 && i <= 69826) ||\n      (i >= 69840 && i <= 69864) ||\n      (i >= 69872 && i <= 69881) ||\n      (i >= 69888 && i <= 69940) ||\n      (i >= 69942 && i <= 69959) ||\n      (i >= 69968 && i <= 70006) ||\n      (i >= 70016 && i <= 70111) ||\n      (i >= 70113 && i <= 70132) ||\n      (i >= 70144 && i <= 70161) ||\n      (i >= 70163 && i <= 70209) ||\n      (i >= 70272 && i <= 70278) ||\n      (i >= 70280 && i <= 70280) ||\n      (i >= 70282 && i <= 70285) ||\n      (i >= 70287 && i <= 70301) ||\n      (i >= 70303 && i <= 70313) ||\n      (i >= 70320 && i <= 70378) ||\n      (i >= 70384 && i <= 70393) ||\n      (i >= 70400 && i <= 70403) ||\n      (i >= 70405 && i <= 70412) ||\n      (i >= 70415 && i <= 70416) ||\n      (i >= 70419 && i <= 70440) ||\n      (i >= 70442 && i <= 70448) ||\n      (i >= 70450 && i <= 70451) ||\n      (i >= 70453 && i <= 70457) ||\n      (i >= 70459 && i <= 70468) ||\n      (i >= 70471 && i <= 70472) ||\n      (i >= 70475 && i <= 70477) ||\n      (i >= 70480 && i <= 70480) ||\n      (i >= 70487 && i <= 70487) ||\n      (i >= 70493 && i <= 70499) ||\n      (i >= 70502 && i <= 70508) ||\n      (i >= 70512 && i <= 70516) ||\n      (i >= 70528 && i <= 70537) ||\n      (i >= 70539 && i <= 70539) ||\n      (i >= 70542 && i <= 70542) ||\n      (i >= 70544 && i <= 70581) ||\n      (i >= 70583 && i <= 70592) ||\n      (i >= 70594 && i <= 70594) ||\n      (i >= 70597 && i <= 70597) ||\n      (i >= 70599 && i <= 70602) ||\n      (i >= 70604 && i <= 70613) ||\n      (i >= 70615 && i <= 70616) ||\n      (i >= 70625 && i <= 70626) ||\n      (i >= 70656 && i <= 70747) ||\n      (i >= 70749 && i <= 70753) ||\n      (i >= 70784 && i <= 70855) ||\n      (i >= 70864 && i <= 70873) ||\n      (i >= 71040 && i <= 71093) ||\n      (i >= 71096 && i <= 71133) ||\n      (i >= 71168 && i <= 71236) ||\n      (i >= 71248 && i <= 71257) ||\n      (i >= 71264 && i <= 71276) ||\n      (i >= 71296 && i <= 71353) ||\n      (i >= 71360 && i <= 71369) ||\n      (i >= 71376 && i <= 71395) ||\n      (i >= 71424 && i <= 71450) ||\n      (i >= 71453 && i <= 71467) ||\n      (i >= 71472 && i <= 71494) ||\n      (i >= 71680 && i <= 71739) ||\n      (i >= 71840 && i <= 71922) ||\n      (i >= 71935 && i <= 71942) ||\n      (i >= 71945 && i <= 71945) ||\n      (i >= 71948 && i <= 71955) ||\n      (i >= 71957 && i <= 71958) ||\n      (i >= 71960 && i <= 71989) ||\n      (i >= 71991 && i <= 71992) ||\n      (i >= 71995 && i <= 72006) ||\n      (i >= 72016 && i <= 72025) ||\n      (i >= 72096 && i <= 72103) ||\n      (i >= 72106 && i <= 72151) ||\n      (i >= 72154 && i <= 72164) ||\n      (i >= 72192 && i <= 72263) ||\n      (i >= 72272 && i <= 72354) ||\n      (i >= 72368 && i <= 72440) ||\n      (i >= 72448 && i <= 72457) ||\n      (i >= 72544 && i <= 72551) ||\n      (i >= 72640 && i <= 72673) ||\n      (i >= 72688 && i <= 72697) ||\n      (i >= 72704 && i <= 72712) ||\n      (i >= 72714 && i <= 72758) ||\n      (i >= 72760 && i <= 72773) ||\n      (i >= 72784 && i <= 72812) ||\n      (i >= 72816 && i <= 72847) ||\n      (i >= 72850 && i <= 72871) ||\n      (i >= 72873 && i <= 72886) ||\n      (i >= 72960 && i <= 72966) ||\n      (i >= 72968 && i <= 72969) ||\n      (i >= 72971 && i <= 73014) ||\n      (i >= 73018 && i <= 73018) ||\n      (i >= 73020 && i <= 73021) ||\n      (i >= 73023 && i <= 73031) ||\n      (i >= 73040 && i <= 73049) ||\n      (i >= 73056 && i <= 73061) ||\n      (i >= 73063 && i <= 73064) ||\n      (i >= 73066 && i <= 73102) ||\n      (i >= 73104 && i <= 73105) ||\n      (i >= 73107 && i <= 73112) ||\n      (i >= 73120 && i <= 73129) ||\n      (i >= 73136 && i <= 73179) ||\n      (i >= 73184 && i <= 73193) ||\n      (i >= 73440 && i <= 73464) ||\n      (i >= 73472 && i <= 73488) ||\n      (i >= 73490 && i <= 73530) ||\n      (i >= 73534 && i <= 73562) ||\n      (i >= 73648 && i <= 73648) ||\n      (i >= 73664 && i <= 73713) ||\n      (i >= 73727 && i <= 74649) ||\n      (i >= 74752 && i <= 74862) ||\n      (i >= 74864 && i <= 74868) ||\n      (i >= 74880 && i <= 75075) ||\n      (i >= 77712 && i <= 77810) ||\n      (i >= 77824 && i <= 78895) ||\n      (i >= 78912 && i <= 78933) ||\n      (i >= 78944 && i <= 82938) ||\n      (i >= 82944 && i <= 83526) ||\n      (i >= 90368 && i <= 90425) ||\n      (i >= 92160 && i <= 92728) ||\n      (i >= 92736 && i <= 92766) ||\n      (i >= 92768 && i <= 92777) ||\n      (i >= 92782 && i <= 92862) ||\n      (i >= 92864 && i <= 92873) ||\n      (i >= 92880 && i <= 92909) ||\n      (i >= 92912 && i <= 92917) ||\n      (i >= 92928 && i <= 92997) ||\n      (i >= 93008 && i <= 93017) ||\n      (i >= 93019 && i <= 93025) ||\n      (i >= 93027 && i <= 93047) ||\n      (i >= 93053 && i <= 93071) ||\n      (i >= 93504 && i <= 93561) ||\n      (i >= 93760 && i <= 93850) ||\n      (i >= 93856 && i <= 93880) ||\n      (i >= 93883 && i <= 93907) ||\n      (i >= 93952 && i <= 94026) ||\n      (i >= 94031 && i <= 94087) ||\n      (i >= 94095 && i <= 94111) ||\n      (i >= 94176 && i <= 94180) ||\n      (i >= 94192 && i <= 94198) ||\n      (i >= 94208 && i <= 101589) ||\n      (i >= 101631 && i <= 101662) ||\n      (i >= 101760 && i <= 101874) ||\n      (i >= 110576 && i <= 110579) ||\n      (i >= 110581 && i <= 110587) ||\n      (i >= 110589 && i <= 110590) ||\n      (i >= 110592 && i <= 110882) ||\n      (i >= 110898 && i <= 110898) ||\n      (i >= 110928 && i <= 110930) ||\n      (i >= 110933 && i <= 110933) ||\n      (i >= 110948 && i <= 110951) ||\n      (i >= 110960 && i <= 111355) ||\n      (i >= 113664 && i <= 113770) ||\n      (i >= 113776 && i <= 113788) ||\n      (i >= 113792 && i <= 113800) ||\n      (i >= 113808 && i <= 113817) ||\n      (i >= 113820 && i <= 113823) ||\n      (i >= 117760 && i <= 118012) ||\n      (i >= 118016 && i <= 118451) ||\n      (i >= 118458 && i <= 118480) ||\n      (i >= 118496 && i <= 118512) ||\n      (i >= 118528 && i <= 118573) ||\n      (i >= 118576 && i <= 118598) ||\n      (i >= 118608 && i <= 118723) ||\n      (i >= 118784 && i <= 119029) ||\n      (i >= 119040 && i <= 119078) ||\n      (i >= 119081 && i <= 119154) ||\n      (i >= 119163 && i <= 119274) ||\n      (i >= 119296 && i <= 119365) ||\n      (i >= 119488 && i <= 119507) ||\n      (i >= 119520 && i <= 119539) ||\n      (i >= 119552 && i <= 119638) ||\n      (i >= 119648 && i <= 119672) ||\n      (i >= 119808 && i <= 119892) ||\n      (i >= 119894 && i <= 119964) ||\n      (i >= 119966 && i <= 119967) ||\n      (i >= 119970 && i <= 119970) ||\n      (i >= 119973 && i <= 119974) ||\n      (i >= 119977 && i <= 119980) ||\n      (i >= 119982 && i <= 119993) ||\n      (i >= 119995 && i <= 119995) ||\n      (i >= 119997 && i <= 120003) ||\n      (i >= 120005 && i <= 120069) ||\n      (i >= 120071 && i <= 120074) ||\n      (i >= 120077 && i <= 120084) ||\n      (i >= 120086 && i <= 120092) ||\n      (i >= 120094 && i <= 120121) ||\n      (i >= 120123 && i <= 120126) ||\n      (i >= 120128 && i <= 120132) ||\n      (i >= 120134 && i <= 120134) ||\n      (i >= 120138 && i <= 120144) ||\n      (i >= 120146 && i <= 120485) ||\n      (i >= 120488 && i <= 120779) ||\n      (i >= 120782 && i <= 121483) ||\n      (i >= 121499 && i <= 121503) ||\n      (i >= 121505 && i <= 121519) ||\n      (i >= 122624 && i <= 122654) ||\n      (i >= 122661 && i <= 122666) ||\n      (i >= 122880 && i <= 122886) ||\n      (i >= 122888 && i <= 122904) ||\n      (i >= 122907 && i <= 122913) ||\n      (i >= 122915 && i <= 122916) ||\n      (i >= 122918 && i <= 122922) ||\n      (i >= 122928 && i <= 122989) ||\n      (i >= 123023 && i <= 123023) ||\n      (i >= 123136 && i <= 123180) ||\n      (i >= 123184 && i <= 123197) ||\n      (i >= 123200 && i <= 123209) ||\n      (i >= 123214 && i <= 123215) ||\n      (i >= 123536 && i <= 123566) ||\n      (i >= 123584 && i <= 123641) ||\n      (i >= 123647 && i <= 123647) ||\n      (i >= 124112 && i <= 124153) ||\n      (i >= 124368 && i <= 124410) ||\n      (i >= 124415 && i <= 124415) ||\n      (i >= 124608 && i <= 124638) ||\n      (i >= 124640 && i <= 124661) ||\n      (i >= 124670 && i <= 124671) ||\n      (i >= 124896 && i <= 124902) ||\n      (i >= 124904 && i <= 124907) ||\n      (i >= 124909 && i <= 124910) ||\n      (i >= 124912 && i <= 124926) ||\n      (i >= 124928 && i <= 125124) ||\n      (i >= 125127 && i <= 125142) ||\n      (i >= 125184 && i <= 125259) ||\n      (i >= 125264 && i <= 125273) ||\n      (i >= 125278 && i <= 125279) ||\n      (i >= 126065 && i <= 126132) ||\n      (i >= 126209 && i <= 126269) ||\n      (i >= 126464 && i <= 126467) ||\n      (i >= 126469 && i <= 126495) ||\n      (i >= 126497 && i <= 126498) ||\n      (i >= 126500 && i <= 126500) ||\n      (i >= 126503 && i <= 126503) ||\n      (i >= 126505 && i <= 126514) ||\n      (i >= 126516 && i <= 126519) ||\n      (i >= 126521 && i <= 126521) ||\n      (i >= 126523 && i <= 126523) ||\n      (i >= 126530 && i <= 126530) ||\n      (i >= 126535 && i <= 126535) ||\n      (i >= 126537 && i <= 126537) ||\n      (i >= 126539 && i <= 126539) ||\n      (i >= 126541 && i <= 126543) ||\n      (i >= 126545 && i <= 126546) ||\n      (i >= 126548 && i <= 126548) ||\n      (i >= 126551 && i <= 126551) ||\n      (i >= 126553 && i <= 126553) ||\n      (i >= 126555 && i <= 126555) ||\n      (i >= 126557 && i <= 126557) ||\n      (i >= 126559 && i <= 126559) ||\n      (i >= 126561 && i <= 126562) ||\n      (i >= 126564 && i <= 126564) ||\n      (i >= 126567 && i <= 126570) ||\n      (i >= 126572 && i <= 126578) ||\n      (i >= 126580 && i <= 126583) ||\n      (i >= 126585 && i <= 126588) ||\n      (i >= 126590 && i <= 126590) ||\n      (i >= 126592 && i <= 126601) ||\n      (i >= 126603 && i <= 126619) ||\n      (i >= 126625 && i <= 126627) ||\n      (i >= 126629 && i <= 126633) ||\n      (i >= 126635 && i <= 126651) ||\n      (i >= 126704 && i <= 126705) ||\n      (i >= 126976 && i <= 127019) ||\n      (i >= 127024 && i <= 127123) ||\n      (i >= 127136 && i <= 127150) ||\n      (i >= 127153 && i <= 127167) ||\n      (i >= 127169 && i <= 127183) ||\n      (i >= 127185 && i <= 127221) ||\n      (i >= 127232 && i <= 127405) ||\n      (i >= 127462 && i <= 127490) ||\n      (i >= 127504 && i <= 127547) ||\n      (i >= 127552 && i <= 127560) ||\n      (i >= 127568 && i <= 127569) ||\n      (i >= 127584 && i <= 127589) ||\n      (i >= 127744 && i <= 128728) ||\n      (i >= 128732 && i <= 128748) ||\n      (i >= 128752 && i <= 128764) ||\n      (i >= 128768 && i <= 128985) ||\n      (i >= 128992 && i <= 129003) ||\n      (i >= 129008 && i <= 129008) ||\n      (i >= 129024 && i <= 129035) ||\n      (i >= 129040 && i <= 129095) ||\n      (i >= 129104 && i <= 129113) ||\n      (i >= 129120 && i <= 129159) ||\n      (i >= 129168 && i <= 129197) ||\n      (i >= 129200 && i <= 129211) ||\n      (i >= 129216 && i <= 129217) ||\n      (i >= 129232 && i <= 129240) ||\n      (i >= 129280 && i <= 129623) ||\n      (i >= 129632 && i <= 129645) ||\n      (i >= 129648 && i <= 129660) ||\n      (i >= 129664 && i <= 129674) ||\n      (i >= 129678 && i <= 129734) ||\n      (i >= 129736 && i <= 129736) ||\n      (i >= 129741 && i <= 129756) ||\n      (i >= 129759 && i <= 129770) ||\n      (i >= 129775 && i <= 129784) ||\n      (i >= 129792 && i <= 129938) ||\n      (i >= 129940 && i <= 130042) ||\n      (i >= 131072 && i <= 173791) ||\n      (i >= 173824 && i <= 178205) ||\n      (i >= 178208 && i <= 183981) ||\n      (i >= 183984 && i <= 191456) ||\n      (i >= 191472 && i <= 192093) ||\n      (i >= 194560 && i <= 195101) ||\n      (i >= 196608 && i <= 201546) ||\n      (i >= 201552 && i <= 210041) ||\n      (i >= 917760 && i <= 917999) => {\n      sb.write_char(i.unsafe_to_char())\n      continue (n - 1, state.next_positive_int() % 91799)\n    }\n    (n, _) => continue (n, state.next_positive_int() % 91799)\n  }\n  Name(sb.to_string().to_string_view())\n}\n\n///|\npub(all) struct CustomSec(Name, Bytes) derive(Eq, Hash)\n\n///|\npub(all) struct TypeSec(Array[RecType]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ImportSec(Array[Import]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct FuncSec(Array[TypeIdx]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TableSec(Array[Table]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemSec(Array[MemType]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct GlobalSec(Array[Global]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ExportSec(Array[Export]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct StartSec(FuncIdx) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ElemSec(Array[Elem]) derive(Eq, Hash)\n\n///|\npub(all) struct DataCntSec(U32) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TagSec(Array[TagType]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemArg(U32, MemIdx?, U64) derive(Hash)\n\n///|\npub(all) enum BlockType {\n  EmptyBlockType\n  ValTypeBlockType(ValType)\n  TypeIdxBlockType(TypeIdx)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum Catch {\n  Catch(TagIdx, LabelIdx)\n  CatchRef(TagIdx, LabelIdx)\n  CatchAll(LabelIdx)\n  CatchAllRef(LabelIdx)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct CodeSec(Array[Func]) derive(Eq, Hash)\n\n///|\npub(all) struct DataSec(Array[Data]) derive(Eq, Hash)\n\n///|\npub(all) struct CastOp(Bool, Bool) derive(Eq, Arbitrary, Show, Hash)\n\n///|\npub(all) enum Instruction {\n  Unreachable\n  Nop\n  Block(BlockType, Expr)\n  Loop(BlockType, Expr)\n  If(BlockType, Array[Instruction], Array[Instruction]?)\n  Throw(TagIdx)\n  ThrowRef\n  Br(LabelIdx)\n  BrIf(LabelIdx)\n  BrTable(Array[LabelIdx], LabelIdx)\n  Return\n  Call(FuncIdx)\n  CallIndirect(TypeIdx, TableIdx)\n  ReturnCall(FuncIdx)\n  ReturnCallIndirect(TypeIdx, TableIdx)\n  CallRef(TypeIdx)\n  ReturnCallRef(TypeIdx)\n  Drop\n  Select(Array[ValType]?)\n  TryTable(BlockType, Array[Catch], Expr)\n  LocalGet(LocalIdx)\n  LocalSet(LocalIdx)\n  LocalTee(LocalIdx)\n  GlobalGet(GlobalIdx)\n  GlobalSet(GlobalIdx)\n  TableGet(TableIdx)\n  TableSet(TableIdx)\n  I32Load(MemArg)\n  I64Load(MemArg)\n  F32Load(MemArg)\n  F64Load(MemArg)\n  I32Load8S(MemArg)\n  I32Load8U(MemArg)\n  I32Load16S(MemArg)\n  I32Load16U(MemArg)\n  I64Load8S(MemArg)\n  I64Load8U(MemArg)\n  I64Load16S(MemArg)\n  I64Load16U(MemArg)\n  I64Load32S(MemArg)\n  I64Load32U(MemArg)\n  I32Store(MemArg)\n  I64Store(MemArg)\n  F32Store(MemArg)\n  F64Store(MemArg)\n  I32Store8(MemArg)\n  I32Store16(MemArg)\n  I64Store8(MemArg)\n  I64Store16(MemArg)\n  I64Store32(MemArg)\n  MemorySize(MemIdx)\n  MemoryGrow(MemIdx)\n  I32Const(I32)\n  I64Const(I64)\n  F32Const(F32)\n  F64Const(F64)\n  I32Eqz\n  I32Eq\n  I32Ne\n  I32LtS\n  I32LtU\n  I32GtS\n  I32GtU\n  I32LeS\n  I32LeU\n  I32GeS\n  I32GeU\n  I64Eqz\n  I64Eq\n  I64Ne\n  I64LtS\n  I64LtU\n  I64GtS\n  I64GtU\n  I64LeS\n  I64LeU\n  I64GeS\n  I64GeU\n  F32Eq\n  F32Ne\n  F32Lt\n  F32Gt\n  F32Le\n  F32Ge\n  F64Eq\n  F64Ne\n  F64Lt\n  F64Gt\n  F64Le\n  F64Ge\n  I32Clz\n  I32Ctz\n  I32Popcnt\n  I32Add\n  I32Sub\n  I32Mul\n  I32DivS\n  I32DivU\n  I32RemS\n  I32RemU\n  I32And\n  I32Or\n  I32Xor\n  I32Shl\n  I32ShrS\n  I32ShrU\n  I32Rotl\n  I32Rotr\n  I64Clz\n  I64Ctz\n  I64Popcnt\n  I64Add\n  I64Sub\n  I64Mul\n  I64DivS\n  I64DivU\n  I64RemS\n  I64RemU\n  I64And\n  I64Or\n  I64Xor\n  I64Shl\n  I64ShrS\n  I64ShrU\n  I64Rotl\n  I64Rotr\n  F32Abs\n  F32Neg\n  F32Ceil\n  F32Floor\n  F32Trunc\n  F32Nearest\n  F32Sqrt\n  F32Add\n  F32Sub\n  F32Mul\n  F32Div\n  F32Min\n  F32Max\n  F32Copysign\n  F64Abs\n  F64Neg\n  F64Ceil\n  F64Floor\n  F64Trunc\n  F64Nearest\n  F64Sqrt\n  F64Add\n  F64Sub\n  F64Mul\n  F64Div\n  F64Min\n  F64Max\n  F64Copysign\n  I32WrapI64\n  I32TruncF32S\n  I32TruncF32U\n  I32TruncF64S\n  I32TruncF64U\n  I64ExtendI32S\n  I64ExtendI32U\n  I64TruncF32S\n  I64TruncF32U\n  I64TruncF64S\n  I64TruncF64U\n  F32ConvertI32S\n  F32ConvertI32U\n  F32ConvertI64S\n  F32ConvertI64U\n  F32DemoteF64\n  F64ConvertI32S\n  F64ConvertI32U\n  F64ConvertI64S\n  F64ConvertI64U\n  F64PromoteF32\n  I32ReinterpretF32\n  I64ReinterpretF64\n  F32ReinterpretI32\n  F64ReinterpretI64\n  I32Extend8S\n  I32Extend16S\n  I64Extend8S\n  I64Extend16S\n  I64Extend32S\n  RefNull(HeapType)\n  RefIsNull\n  RefFunc(FuncIdx)\n  RefEq\n  RefAsNonNull\n  BrOnNull(LabelIdx)\n  BrOnNonNull(LabelIdx)\n  StructNew(TypeIdx)\n  StructNewDefault(TypeIdx)\n  StructGet(TypeIdx, U32)\n  StructGetS(TypeIdx, U32)\n  StructGetU(TypeIdx, U32)\n  StructSet(TypeIdx, U32)\n  ArrayNew(TypeIdx)\n  ArrayNewDefault(TypeIdx)\n  ArrayNewFixed(TypeIdx, U32)\n  ArrayNewData(TypeIdx, DataIdx)\n  ArrayNewElem(TypeIdx, ElemIdx)\n  ArrayGet(TypeIdx)\n  ArrayGetS(TypeIdx)\n  ArrayGetU(TypeIdx)\n  ArraySet(TypeIdx)\n  ArrayLen\n  ArrayFill(TypeIdx)\n  ArrayCopy(TypeIdx, TypeIdx)\n  ArrayInitData(TypeIdx, DataIdx)\n  ArrayInitElem(TypeIdx, ElemIdx)\n  RefTest(Bool, HeapType)\n  RefCast(Bool, HeapType)\n  BrOnCast(LabelIdx, CastOp, HeapType, HeapType)\n  BrOnCastFail(LabelIdx, CastOp, HeapType, HeapType)\n  AnyConvertExtern\n  ExternConvertAny\n  RefI31\n  I31GetS\n  I31GetU\n  I32TruncSatF32S\n  I32TruncSatF32U\n  I32TruncSatF64S\n  I32TruncSatF64U\n  I64TruncSatF32S\n  I64TruncSatF32U\n  I64TruncSatF64S\n  I64TruncSatF64U\n  MemoryInit(DataIdx, MemIdx)\n  DataDrop(DataIdx)\n  MemoryCopy(MemIdx, MemIdx)\n  MemoryFill(MemIdx)\n  TableInit(ElemIdx, TableIdx)\n  ElemDrop(ElemIdx)\n  TableCopy(TableIdx, TableIdx)\n  TableGrow(TableIdx)\n  TableSize(TableIdx)\n  TableFill(TableIdx)\n  V128Load(MemArg)\n  V128Load8x8S(MemArg)\n  V128Load8x8U(MemArg)\n  V128Load16x4S(MemArg)\n  V128Load16x4U(MemArg)\n  V128Load32x2S(MemArg)\n  V128Load32x2U(MemArg)\n  V128Load8Splat(MemArg)\n  V128Load16Splat(MemArg)\n  V128Load32Splat(MemArg)\n  V128Load64Splat(MemArg)\n  V128Store(MemArg)\n  V128Const(\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte\n  )\n  I8x16Shuffle(\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx\n  )\n  I8x16Swizzle\n  I8x16Splat\n  I16x8Splat\n  I32x4Splat\n  I64x2Splat\n  F32x4Splat\n  F64x2Splat\n  I8x16ExtractLaneS(LaneIdx)\n  I8x16ExtractLaneU(LaneIdx)\n  I8x16ReplaceLane(LaneIdx)\n  I16x8ExtractLaneS(LaneIdx)\n  I16x8ExtractLaneU(LaneIdx)\n  I16x8ReplaceLane(LaneIdx)\n  I32x4ExtractLane(LaneIdx)\n  I32x4ReplaceLane(LaneIdx)\n  I64x2ExtractLane(LaneIdx)\n  I64x2ReplaceLane(LaneIdx)\n  F32x4ExtractLane(LaneIdx)\n  F32x4ReplaceLane(LaneIdx)\n  F64x2ExtractLane(LaneIdx)\n  F64x2ReplaceLane(LaneIdx)\n  I8x16Eq\n  I8x16Ne\n  I8x16LtS\n  I8x16LtU\n  I8x16GtS\n  I8x16GtU\n  I8x16LeS\n  I8x16LeU\n  I8x16GeS\n  I8x16GeU\n  I16x8Eq\n  I16x8Ne\n  I16x8LtS\n  I16x8LtU\n  I16x8GtS\n  I16x8GtU\n  I16x8LeS\n  I16x8LeU\n  I16x8GeS\n  I16x8GeU\n  I32x4Eq\n  I32x4Ne\n  I32x4LtS\n  I32x4LtU\n  I32x4GtS\n  I32x4GtU\n  I32x4LeS\n  I32x4LeU\n  I32x4GeS\n  I32x4GeU\n  F32x4Eq\n  F32x4Ne\n  F32x4Lt\n  F32x4Gt\n  F32x4Le\n  F32x4Ge\n  F64x2Eq\n  F64x2Ne\n  F64x2Lt\n  F64x2Gt\n  F64x2Le\n  F64x2Ge\n  V128Not\n  V128And\n  V128Andnot\n  V128Or\n  V128Xor\n  V128Bitselect\n  V128AnyTrue\n  V128Load8Lane(MemArg, LaneIdx)\n  V128Load16Lane(MemArg, LaneIdx)\n  V128Load32Lane(MemArg, LaneIdx)\n  V128Load64Lane(MemArg, LaneIdx)\n  V128Store8Lane(MemArg, LaneIdx)\n  V128Store16Lane(MemArg, LaneIdx)\n  V128Store32Lane(MemArg, LaneIdx)\n  V128Store64Lane(MemArg, LaneIdx)\n  V128Load32Zero(MemArg)\n  V128Load64Zero(MemArg)\n  F32x4DemoteF64x2Zero\n  F64x2PromoteLowF32x4\n  I8x16Abs\n  I8x16Neg\n  I8x16Popcnt\n  I8x16AllTrue\n  I8x16Bitmask\n  I8x16NarrowI16x8S\n  I8x16NarrowI16x8U\n  F32x4Ceil\n  F32x4Floor\n  F32x4Trunc\n  F32x4Nearest\n  I8x16Shl\n  I8x16ShrS\n  I8x16ShrU\n  I8x16Add\n  I8x16AddSatS\n  I8x16AddSatU\n  I8x16Sub\n  I8x16SubSatS\n  I8x16SubSatU\n  F64x2Ceil\n  F64x2Floor\n  I8x16MinS\n  I8x16MinU\n  I8x16MaxS\n  I8x16MaxU\n  F64x2Trunc\n  I8x16AvgrU\n  I16x8ExtaddPairwiseI8x16S\n  I16x8ExtaddPairwiseI8x16U\n  I32x4ExtaddPairwiseI16x8S\n  I32x4ExtaddPairwiseI16x8U\n  I16x8Abs\n  I16x8Neg\n  I16x8Q15mulrSatS\n  I16x8AllTrue\n  I16x8Bitmask\n  I16x8NarrowI32x4S\n  I16x8NarrowI32x4U\n  I16x8ExtendLowI8x16S\n  I16x8ExtendHighI8x16S\n  I16x8ExtendLowI8x16U\n  I16x8ExtendHighI8x16U\n  I16x8Shl\n  I16x8ShrS\n  I16x8ShrU\n  I16x8Add\n  I16x8AddSatS\n  I16x8AddSatU\n  I16x8Sub\n  I16x8SubSatS\n  I16x8SubSatU\n  F64x2Nearest\n  I16x8Mul\n  I16x8MinS\n  I16x8MinU\n  I16x8MaxS\n  I16x8MaxU\n  I16x8AvgrU\n  I16x8ExtmulLowI8x16S\n  I16x8ExtmulHighI8x16S\n  I16x8ExtmulLowI8x16U\n  I16x8ExtmulHighI8x16U\n  I32x4Abs\n  I32x4Neg\n  I32x4AllTrue\n  I32x4Bitmask\n  I32x4ExtendLowI16x8S\n  I32x4ExtendHighI16x8S\n  I32x4ExtendLowI16x8U\n  I32x4ExtendHighI16x8U\n  I32x4Shl\n  I32x4ShrS\n  I32x4ShrU\n  I32x4Add\n  I32x4Sub\n  I32x4Mul\n  I32x4MinS\n  I32x4MinU\n  I32x4MaxS\n  I32x4MaxU\n  I32x4DotI16x8S\n  I32x4ExtmulLowI16x8S\n  I32x4ExtmulHighI16x8S\n  I32x4ExtmulLowI16x8U\n  I32x4ExtmulHighI16x8U\n  I64x2Abs\n  I64x2Neg\n  I64x2AllTrue\n  I64x2Bitmask\n  I64x2ExtendLowI32x4S\n  I64x2ExtendHighI32x4S\n  I64x2ExtendLowI32x4U\n  I64x2ExtendHighI32x4U\n  I64x2Shl\n  I64x2ShrS\n  I64x2ShrU\n  I64x2Add\n  I64x2Sub\n  I64x2Mul\n  I64x2Eq\n  I64x2Ne\n  I64x2LtS\n  I64x2GtS\n  I64x2LeS\n  I64x2GeS\n  I64x2ExtmulLowI32x4S\n  I64x2ExtmulHighI32x4S\n  I64x2ExtmulLowI32x4U\n  I64x2ExtmulHighI32x4U\n  F32x4Abs\n  F32x4Neg\n  F32x4Sqrt\n  F32x4Add\n  F32x4Sub\n  F32x4Mul\n  F32x4Div\n  F32x4Min\n  F32x4Max\n  F32x4Pmin\n  F32x4Pmax\n  F64x2Abs\n  F64x2Neg\n  F64x2Sqrt\n  F64x2Add\n  F64x2Sub\n  F64x2Mul\n  F64x2Div\n  F64x2Min\n  F64x2Max\n  F64x2Pmin\n  F64x2Pmax\n  I32x4TruncSatF32x4S\n  I32x4TruncSatF32x4U\n  F32x4ConvertI32x4S\n  F32x4ConvertI32x4U\n  I32x4TruncSatF64x2SZero\n  I32x4TruncSatF64x2UZero\n  F64x2ConvertLowI32x4S\n  F64x2ConvertLowI32x4U\n  I8x16RelaxedSwizzle\n  I32x4RelaxedTruncF32x4S\n  I32x4RelaxedTruncF32x4U\n  I32x4RelaxedTruncZeroF64x2S\n  I32x4RelaxedTruncZeroF64x2U\n  F32x4RelaxedMadd\n  F32x4RelaxedNmadd\n  F64x2RelaxedMadd\n  F64x2RelaxedNmadd\n  I8x16RelaxedLaneselect\n  I16x8RelaxedLaneselect\n  I32x4RelaxedLaneselect\n  I64x2RelaxedLaneselect\n  F32x4RelaxedMin\n  F32x4RelaxedMax\n  F64x2RelaxedMin\n  F64x2RelaxedMax\n  I16x8RelaxedQ15mulrS\n  I16x8RelaxedDotI8x16I7x16S\n  I32x4RelaxedDotI8x16I7x16AddS\n} derive(Eq, Hash)\n\n///|\npub impl @quickcheck.Arbitrary for MemArg with arbitrary(t, state) {\n  MemArg(\n    U32(state.next_uint() % 64),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n  )\n}\n\n///|\npub impl @quickcheck.Arbitrary for Instruction with arbitrary(t, state) {\n  match state.next_uint() % 494 {\n    0 => Unreachable\n    1 => Nop\n    2 =>\n      Block(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    3 =>\n      Loop(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    4 =>\n      If(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        array_of_arbitrary(5, t, state),\n        if (state.next_uint() & 1) == 1 {\n          Some(array_of_arbitrary(5, t, state))\n        } else {\n          None\n        },\n      )\n    5 => Throw(@quickcheck.Arbitrary::arbitrary(t, state))\n    6 => ThrowRef\n    7 => Br(@quickcheck.Arbitrary::arbitrary(t, state))\n    8 => BrIf(@quickcheck.Arbitrary::arbitrary(t, state))\n    9 =>\n      BrTable(\n        array_of_arbitrary(3, t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    10 => Return\n    11 => Call(@quickcheck.Arbitrary::arbitrary(t, state))\n    12 =>\n      CallIndirect(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    13 => ReturnCall(@quickcheck.Arbitrary::arbitrary(t, state))\n    14 =>\n      ReturnCallIndirect(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    15 => CallRef(@quickcheck.Arbitrary::arbitrary(t, state))\n    16 => ReturnCallRef(@quickcheck.Arbitrary::arbitrary(t, state))\n    17 => Drop\n    18 =>\n      TryTable(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        array_of_arbitrary(4, t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    19 =>\n      Select(\n        if @quickcheck.Arbitrary::arbitrary(t, state) {\n          Some(array_of_arbitrary(4, t, state))\n        } else {\n          None\n        },\n      )\n    20 => LocalGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    21 => LocalSet(@quickcheck.Arbitrary::arbitrary(t, state))\n    22 => LocalTee(@quickcheck.Arbitrary::arbitrary(t, state))\n    23 => GlobalGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    24 => GlobalSet(@quickcheck.Arbitrary::arbitrary(t, state))\n    25 => TableGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    26 => TableSet(@quickcheck.Arbitrary::arbitrary(t, state))\n    27 => I32Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    28 => I64Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    29 => F32Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    30 => F64Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    31 => I32Load8S(@quickcheck.Arbitrary::arbitrary(t, state))\n    32 => I32Load8U(@quickcheck.Arbitrary::arbitrary(t, state))\n    33 => I32Load16S(@quickcheck.Arbitrary::arbitrary(t, state))\n    34 => I32Load16U(@quickcheck.Arbitrary::arbitrary(t, state))\n    35 => I64Load8S(@quickcheck.Arbitrary::arbitrary(t, state))\n    36 => I64Load8U(@quickcheck.Arbitrary::arbitrary(t, state))\n    37 => I64Load16S(@quickcheck.Arbitrary::arbitrary(t, state))\n    38 => I64Load16U(@quickcheck.Arbitrary::arbitrary(t, state))\n    39 => I64Load32S(@quickcheck.Arbitrary::arbitrary(t, state))\n    40 => I64Load32U(@quickcheck.Arbitrary::arbitrary(t, state))\n    41 => I32Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    42 => I64Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    43 => F32Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    44 => F64Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    45 => I32Store8(@quickcheck.Arbitrary::arbitrary(t, state))\n    46 => I32Store16(@quickcheck.Arbitrary::arbitrary(t, state))\n    47 => I64Store8(@quickcheck.Arbitrary::arbitrary(t, state))\n    48 => I64Store16(@quickcheck.Arbitrary::arbitrary(t, state))\n    49 => I64Store32(@quickcheck.Arbitrary::arbitrary(t, state))\n    50 => MemorySize(@quickcheck.Arbitrary::arbitrary(t, state))\n    51 => MemoryGrow(@quickcheck.Arbitrary::arbitrary(t, state))\n    52 => I32Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    53 => I64Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    54 => F32Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    55 => F64Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    56 => I32Eqz\n    57 => I32Eq\n    58 => I32Ne\n    59 => I32LtS\n    60 => I32LtU\n    61 => I32GtS\n    62 => I32GtU\n    63 => I32LeS\n    64 => I32LeU\n    65 => I32GeS\n    66 => I32GeU\n    67 => I64Eqz\n    68 => I64Eq\n    69 => I64Ne\n    70 => I64LtS\n    71 => I64LtU\n    72 => I64GtS\n    73 => I64GtU\n    74 => I64LeS\n    75 => I64LeU\n    76 => I64GeS\n    77 => I64GeU\n    78 => F32Eq\n    79 => F32Ne\n    80 => F32Lt\n    81 => F32Gt\n    82 => F32Le\n    83 => F32Ge\n    84 => F64Eq\n    85 => F64Ne\n    86 => F64Lt\n    87 => F64Gt\n    88 => F64Le\n    89 => F64Ge\n    90 => I32Clz\n    91 => I32Ctz\n    92 => I32Popcnt\n    93 => I32Add\n    94 => I32Sub\n    95 => I32Mul\n    96 => I32DivS\n    97 => I32DivU\n    98 => I32RemS\n    99 => I32RemU\n    100 => I32And\n    101 => I32Or\n    102 => I32Xor\n    103 => I32Shl\n    104 => I32ShrS\n    105 => I32ShrU\n    106 => I32Rotl\n    107 => I32Rotr\n    108 => I64Clz\n    109 => I64Ctz\n    110 => I64Popcnt\n    111 => I64Add\n    112 => I64Sub\n    113 => I64Mul\n    114 => I64DivS\n    115 => I64DivU\n    116 => I64RemS\n    117 => I64RemU\n    118 => I64And\n    119 => I64Or\n    120 => I64Xor\n    121 => I64Shl\n    122 => I64ShrS\n    123 => I64ShrU\n    124 => I64Rotl\n    125 => I64Rotr\n    126 => F32Abs\n    127 => F32Neg\n    128 => F32Ceil\n    129 => F32Floor\n    130 => F32Trunc\n    131 => F32Nearest\n    132 => F32Sqrt\n    133 => F32Add\n    134 => F32Sub\n    135 => F32Mul\n    136 => F32Div\n    137 => F32Min\n    138 => F32Max\n    139 => F32Copysign\n    140 => F64Abs\n    141 => F64Neg\n    142 => F64Ceil\n    143 => F64Floor\n    144 => F64Trunc\n    145 => F64Nearest\n    146 => F64Sqrt\n    147 => F64Add\n    148 => F64Sub\n    149 => F64Mul\n    150 => F64Div\n    151 => F64Min\n    152 => F64Max\n    153 => F64Copysign\n    154 => I32WrapI64\n    155 => I32TruncF32S\n    156 => I32TruncF32U\n    157 => I32TruncF64S\n    158 => I32TruncF64U\n    159 => I64ExtendI32S\n    160 => I64ExtendI32U\n    161 => I64TruncF32S\n    162 => I64TruncF32U\n    163 => I64TruncF64S\n    164 => I64TruncF64U\n    165 => F32ConvertI32S\n    166 => F32ConvertI32U\n    167 => F32ConvertI64S\n    168 => F32ConvertI64U\n    169 => F32DemoteF64\n    170 => F64ConvertI32S\n    171 => F64ConvertI32U\n    172 => F64ConvertI64S\n    173 => F64ConvertI64U\n    174 => F64PromoteF32\n    175 => I32ReinterpretF32\n    176 => I64ReinterpretF64\n    177 => F32ReinterpretI32\n    178 => F64ReinterpretI64\n    179 => I32Extend8S\n    180 => I32Extend16S\n    181 => I64Extend8S\n    182 => I64Extend16S\n    183 => I64Extend32S\n    184 => RefNull(@quickcheck.Arbitrary::arbitrary(t, state))\n    185 => RefIsNull\n    186 => RefFunc(@quickcheck.Arbitrary::arbitrary(t, state))\n    187 => RefEq\n    188 => RefAsNonNull\n    189 => BrOnNull(@quickcheck.Arbitrary::arbitrary(t, state))\n    190 => BrOnNonNull(@quickcheck.Arbitrary::arbitrary(t, state))\n    191 => StructNew(@quickcheck.Arbitrary::arbitrary(t, state))\n    192 => StructNewDefault(@quickcheck.Arbitrary::arbitrary(t, state))\n    193 =>\n      StructGet(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    194 =>\n      StructGetS(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    195 =>\n      StructGetU(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    196 =>\n      StructSet(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    197 => ArrayNew(@quickcheck.Arbitrary::arbitrary(t, state))\n    198 => ArrayNewDefault(@quickcheck.Arbitrary::arbitrary(t, state))\n    199 =>\n      ArrayNewFixed(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    200 =>\n      ArrayNewData(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    201 =>\n      ArrayNewElem(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    202 => ArrayGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    203 => ArrayGetS(@quickcheck.Arbitrary::arbitrary(t, state))\n    204 => ArrayGetU(@quickcheck.Arbitrary::arbitrary(t, state))\n    205 => ArraySet(@quickcheck.Arbitrary::arbitrary(t, state))\n    206 => ArrayLen\n    207 => ArrayFill(@quickcheck.Arbitrary::arbitrary(t, state))\n    208 =>\n      ArrayCopy(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    209 =>\n      ArrayInitData(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    210 =>\n      ArrayInitElem(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    211 =>\n      RefTest(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    212 =>\n      RefCast(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    213 =>\n      BrOnCast(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    214 =>\n      BrOnCastFail(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    215 => AnyConvertExtern\n    216 => ExternConvertAny\n    217 => RefI31\n    218 => I31GetS\n    219 => I31GetU\n    220 => I32TruncSatF32S\n    221 => I32TruncSatF32U\n    222 => I32TruncSatF64S\n    223 => I32TruncSatF64U\n    224 => I64TruncSatF32S\n    225 => I64TruncSatF32U\n    226 => I64TruncSatF64S\n    227 => I64TruncSatF64U\n    228 =>\n      MemoryInit(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    229 => DataDrop(@quickcheck.Arbitrary::arbitrary(t, state))\n    230 =>\n      MemoryCopy(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    231 => MemoryFill(@quickcheck.Arbitrary::arbitrary(t, state))\n    232 =>\n      TableInit(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    233 => ElemDrop(@quickcheck.Arbitrary::arbitrary(t, state))\n    234 =>\n      TableCopy(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    235 => TableGrow(@quickcheck.Arbitrary::arbitrary(t, state))\n    236 => TableSize(@quickcheck.Arbitrary::arbitrary(t, state))\n    237 => TableFill(@quickcheck.Arbitrary::arbitrary(t, state))\n    238 => V128Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    239 => V128Load8x8S(@quickcheck.Arbitrary::arbitrary(t, state))\n    240 => V128Load8x8U(@quickcheck.Arbitrary::arbitrary(t, state))\n    241 => V128Load16x4S(@quickcheck.Arbitrary::arbitrary(t, state))\n    242 => V128Load16x4U(@quickcheck.Arbitrary::arbitrary(t, state))\n    243 => V128Load32x2S(@quickcheck.Arbitrary::arbitrary(t, state))\n    244 => V128Load32x2U(@quickcheck.Arbitrary::arbitrary(t, state))\n    245 => V128Load8Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    246 => V128Load16Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    247 => V128Load32Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    248 => V128Load64Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    249 => V128Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    250 =>\n      V128Const(\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n      )\n    251 =>\n      I8x16Shuffle(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    252 => I8x16Swizzle\n    253 => I8x16Splat\n    254 => I16x8Splat\n    255 => I32x4Splat\n    256 => I64x2Splat\n    257 => F32x4Splat\n    258 => F64x2Splat\n    259 => I8x16ExtractLaneS(@quickcheck.Arbitrary::arbitrary(t, state))\n    260 => I8x16ExtractLaneU(@quickcheck.Arbitrary::arbitrary(t, state))\n    261 => I8x16ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    262 => I16x8ExtractLaneS(@quickcheck.Arbitrary::arbitrary(t, state))\n    263 => I16x8ExtractLaneU(@quickcheck.Arbitrary::arbitrary(t, state))\n    264 => I16x8ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    265 => I32x4ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    266 => I32x4ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    267 => I64x2ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    268 => I64x2ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    269 => F32x4ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    270 => F32x4ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    271 => F64x2ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    272 => F64x2ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    273 => I8x16Eq\n    274 => I8x16Ne\n    275 => I8x16LtS\n    276 => I8x16LtU\n    277 => I8x16GtS\n    278 => I8x16GtU\n    279 => I8x16LeS\n    280 => I8x16LeU\n    281 => I8x16GeS\n    282 => I8x16GeU\n    283 => I16x8Eq\n    284 => I16x8Ne\n    285 => I16x8LtS\n    286 => I16x8LtU\n    287 => I16x8GtS\n    288 => I16x8GtU\n    289 => I16x8LeS\n    290 => I16x8LeU\n    291 => I16x8GeS\n    292 => I16x8GeU\n    293 => I32x4Eq\n    294 => I32x4Ne\n    295 => I32x4LtS\n    296 => I32x4LtU\n    297 => I32x4GtS\n    298 => I32x4GtU\n    299 => I32x4LeS\n    300 => I32x4LeU\n    301 => I32x4GeS\n    302 => I32x4GeU\n    303 => F32x4Eq\n    304 => F32x4Ne\n    305 => F32x4Lt\n    306 => F32x4Gt\n    307 => F32x4Le\n    308 => F32x4Ge\n    309 => F64x2Eq\n    310 => F64x2Ne\n    311 => F64x2Lt\n    312 => F64x2Gt\n    313 => F64x2Le\n    314 => F64x2Ge\n    315 => V128Not\n    316 => V128And\n    317 => V128Andnot\n    318 => V128Or\n    319 => V128Xor\n    320 => V128Bitselect\n    321 => V128AnyTrue\n    322 =>\n      V128Load8Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    323 =>\n      V128Load16Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    324 =>\n      V128Load32Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    325 =>\n      V128Load64Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    326 =>\n      V128Store8Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    327 =>\n      V128Store16Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    328 =>\n      V128Store32Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    329 =>\n      V128Store64Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    330 => V128Load32Zero(@quickcheck.Arbitrary::arbitrary(t, state))\n    331 => V128Load64Zero(@quickcheck.Arbitrary::arbitrary(t, state))\n    332 => F32x4DemoteF64x2Zero\n    333 => F64x2PromoteLowF32x4\n    334 => I8x16Abs\n    335 => I8x16Neg\n    336 => I8x16Popcnt\n    337 => I8x16AllTrue\n    338 => I8x16Bitmask\n    339 => I8x16NarrowI16x8S\n    340 => I8x16NarrowI16x8U\n    341 => F32x4Ceil\n    342 => F32x4Floor\n    343 => F32x4Trunc\n    344 => F32x4Nearest\n    345 => I8x16Shl\n    346 => I8x16ShrS\n    347 => I8x16ShrU\n    348 => I8x16Add\n    349 => I8x16AddSatS\n    350 => I8x16AddSatU\n    351 => I8x16Sub\n    352 => I8x16SubSatS\n    353 => I8x16SubSatU\n    354 => F64x2Ceil\n    355 => F64x2Floor\n    356 => I8x16MinS\n    357 => I8x16MinU\n    358 => I8x16MaxS\n    359 => I8x16MaxU\n    360 => F64x2Trunc\n    361 => I8x16AvgrU\n    362 => I16x8ExtaddPairwiseI8x16S\n    363 => I16x8ExtaddPairwiseI8x16U\n    364 => I32x4ExtaddPairwiseI16x8S\n    365 => I32x4ExtaddPairwiseI16x8U\n    366 => I16x8Abs\n    367 => I16x8Neg\n    368 => I16x8Q15mulrSatS\n    369 => I16x8AllTrue\n    370 => I16x8Bitmask\n    371 => I16x8NarrowI32x4S\n    372 => I16x8NarrowI32x4U\n    373 => I16x8ExtendLowI8x16S\n    374 => I16x8ExtendHighI8x16S\n    375 => I16x8ExtendLowI8x16U\n    376 => I16x8ExtendHighI8x16U\n    377 => I16x8Shl\n    378 => I16x8ShrS\n    379 => I16x8ShrU\n    380 => I16x8Add\n    381 => I16x8AddSatS\n    382 => I16x8AddSatU\n    383 => I16x8Sub\n    384 => I16x8SubSatS\n    385 => I16x8SubSatU\n    386 => F64x2Nearest\n    387 => I16x8Mul\n    388 => I16x8MinS\n    389 => I16x8MinU\n    390 => I16x8MaxS\n    391 => I16x8MaxU\n    392 => I16x8AvgrU\n    393 => I16x8ExtmulLowI8x16S\n    394 => I16x8ExtmulHighI8x16S\n    395 => I16x8ExtmulLowI8x16U\n    396 => I16x8ExtmulHighI8x16U\n    397 => I32x4Abs\n    398 => I32x4Neg\n    399 => I32x4AllTrue\n    400 => I32x4Bitmask\n    401 => I32x4ExtendLowI16x8S\n    402 => I32x4ExtendHighI16x8S\n    403 => I32x4ExtendLowI16x8U\n    404 => I32x4ExtendHighI16x8U\n    405 => I32x4Shl\n    406 => I32x4ShrS\n    407 => I32x4ShrU\n    408 => I32x4Add\n    409 => I32x4Sub\n    410 => I32x4Mul\n    411 => I32x4MinS\n    412 => I32x4MinU\n    413 => I32x4MaxS\n    414 => I32x4MaxU\n    415 => I32x4DotI16x8S\n    416 => I32x4ExtmulLowI16x8S\n    417 => I32x4ExtmulHighI16x8S\n    418 => I32x4ExtmulLowI16x8U\n    419 => I32x4ExtmulHighI16x8U\n    420 => I64x2Abs\n    421 => I64x2Neg\n    422 => I64x2AllTrue\n    423 => I64x2Bitmask\n    424 => I64x2ExtendLowI32x4S\n    425 => I64x2ExtendHighI32x4S\n    426 => I64x2ExtendLowI32x4U\n    427 => I64x2ExtendHighI32x4U\n    428 => I64x2Shl\n    429 => I64x2ShrS\n    430 => I64x2ShrU\n    431 => I64x2Add\n    432 => I64x2Sub\n    433 => I64x2Mul\n    434 => I64x2Eq\n    435 => I64x2Ne\n    436 => I64x2LtS\n    437 => I64x2GtS\n    438 => I64x2LeS\n    439 => I64x2GeS\n    440 => I64x2ExtmulLowI32x4S\n    441 => I64x2ExtmulHighI32x4S\n    442 => I64x2ExtmulLowI32x4U\n    443 => I64x2ExtmulHighI32x4U\n    444 => F32x4Abs\n    445 => F32x4Neg\n    446 => F32x4Sqrt\n    447 => F32x4Add\n    448 => F32x4Sub\n    449 => F32x4Mul\n    450 => F32x4Div\n    451 => F32x4Min\n    452 => F32x4Max\n    453 => F32x4Pmin\n    454 => F32x4Pmax\n    455 => F64x2Abs\n    456 => F64x2Neg\n    457 => F64x2Sqrt\n    458 => F64x2Add\n    459 => F64x2Sub\n    460 => F64x2Mul\n    461 => F64x2Div\n    462 => F64x2Min\n    463 => F64x2Max\n    464 => F64x2Pmin\n    465 => F64x2Pmax\n    466 => I32x4TruncSatF32x4S\n    467 => I32x4TruncSatF32x4U\n    468 => F32x4ConvertI32x4S\n    469 => F32x4ConvertI32x4U\n    470 => I32x4TruncSatF64x2SZero\n    471 => I32x4TruncSatF64x2UZero\n    472 => F64x2ConvertLowI32x4S\n    473 => F64x2ConvertLowI32x4U\n    474 => I8x16RelaxedSwizzle\n    475 => I32x4RelaxedTruncF32x4S\n    476 => I32x4RelaxedTruncF32x4U\n    477 => I32x4RelaxedTruncZeroF64x2S\n    478 => I32x4RelaxedTruncZeroF64x2U\n    479 => F32x4RelaxedMadd\n    480 => F32x4RelaxedNmadd\n    481 => F64x2RelaxedMadd\n    482 => F64x2RelaxedNmadd\n    483 => I8x16RelaxedLaneselect\n    484 => I16x8RelaxedLaneselect\n    485 => I32x4RelaxedLaneselect\n    486 => I64x2RelaxedLaneselect\n    487 => F32x4RelaxedMin\n    488 => F32x4RelaxedMax\n    489 => F64x2RelaxedMin\n    490 => F64x2RelaxedMax\n    491 => I16x8RelaxedQ15mulrS\n    492 => I16x8RelaxedDotI8x16I7x16S\n    493 => I32x4RelaxedDotI8x16I7x16AddS\n    _ => Nop\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for ElemSec with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  ElemSec(elems)\n}\n\n///|\npub impl @quickcheck.Arbitrary for CodeSec with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  CodeSec(elems)\n}\n\n///|\npub impl @quickcheck.Arbitrary for DataSec with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  DataSec(elems)\n}\n\n///|\npub impl @quickcheck.Arbitrary for CustomSec with arbitrary(size, st) {\n  let name = @quickcheck.Arbitrary::arbitrary(size, st)\n  let length = st.next_positive_int() % 19 + 1\n  let buf = @buffer.new()\n  let bytes = loop length {\n    0 => buf.to_bytes()\n    n => {\n      buf.write_byte((st.next_positive_int() % 256).to_byte())\n      continue n - 1\n    }\n  }\n  CustomSec(name, bytes)\n}\n\n///|\npub impl @quickcheck.Arbitrary for Module with arbitrary(t, state) {\n  Module(\n    array_of_arbitrary(5, t, state),\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n  )\n}\n\n///|\ntype Stack[T] = Array[T]\n\n///|\npub fn Limits::mem_addr_bits(lim : Limits) -> Int {\n  match lim {\n    I32Limits(_, _) => 32\n    I64Limits(_, _) => 64\n  }\n}\n\n///|\npub fn[T : @quickcheck.Arbitrary] array_of_arbitrary(\n  max : UInt,\n  t : Int,\n  state : @quickcheck/splitmix.RandomState,\n) -> Array[T] {\n  let count = state.next_uint() % max + 1\n  let a = []\n  loop count {\n    0 => break a\n    n => {\n      a.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n}\n\n///|\npub fn RefType::is_nullable(rt : RefType) -> Bool {\n  match rt {\n    HeapTypeRefType(b, _) => b\n    AbsHeapTypeRefType(_) => true\n  }\n}\n\n///|\npub fn RefType::get_heap_type(rt : RefType) -> HeapType {\n  match rt {\n    HeapTypeRefType(_, ht) => ht\n    AbsHeapTypeRefType(ahs) => AbsHeapTypeHeapType(ahs)\n  }\n}\n\n///|\npub fn SubType::super_types(self : SubType) -> Array[TypeIdx] {\n  match self {\n    SubType(_, sts, _) => sts\n    CompTypeSubType(_) => []\n  }\n}\n\n///|\npub fn SubType::get_comptype(self : SubType) -> CompType {\n  match self {\n    SubType(_, _, ct) => ct\n    CompTypeSubType(ct) => ct\n  }\n}\n\n///|\npub fn RecType::get_subtype(self : RecType, idx : UInt) -> SubType? {\n  match (self, idx) {\n    (SingleRecType(st), 0) => Some(st)\n    (GroupRecType(sts), i) => sts.get(i.reinterpret_as_int())\n    _ => None\n  }\n}\n\n///|\npub fn DefType::project(self : DefType) -> SubType? {\n  let DefType(rt, n) = self\n  match rt {\n    SingleRecType(st) => if n == 0 { Some(st) } else { None }\n    GroupRecType(sts) => sts.get(n.reinterpret_as_int())\n  }\n}\n\n///|\npub impl Show for FuncType with output(self, logger) {\n  let FuncType(props, results) = self\n  logger.write_string(\"FuncType {\\n  props : \")\n  props.output(logger)\n  logger.write_string(\"\\n  results : \")\n  results.output(logger)\n  logger.write_string(\"\\n}\")\n}\n\n///|\npub impl Show for Env with output(self, logger) {\n  logger.write_string(\"Env {\\n  global_types : \")\n  self.global_types.output(logger)\n  logger.write_string(\"\\n  rec_stack : \")\n  self.rec_stack.output(logger)\n  logger.write_string(\"\\n  funcs : \")\n  self.funcs.output(logger)\n  logger.write_string(\"\\n  tables : \")\n  self.tables.output(logger)\n  logger.write_string(\"\\n  mems : \")\n  self.mems.output(logger)\n  logger.write_string(\"\\n  globals : \")\n  self.globals.output(logger)\n  logger.write_string(\"\\n  elems : \")\n  self.elems.output(logger)\n  logger.write_string(\"\\n  datas : \")\n  self.datas.output(logger)\n  logger.write_string(\"\\n  tags : \")\n  self.tags.output(logger)\n  logger.write_string(\"\\n  locals : \")\n  self.locals.output(logger)\n  logger.write_string(\"\\n  labels : \")\n  self.labels.output(logger)\n  logger.write_string(\"\\n  return_type : \")\n  self.return_type.output(logger)\n  logger.write_string(\"\\n}\")\n}\n\n///|\npub fn i32_valtype() -> ValType {\n  NumTypeValType(I32NumType)\n}\n\n///|\npub fn i64_valtype() -> ValType {\n  NumTypeValType(I64NumType)\n}\n\n///|\npub fn ref_valtype(rt : RefType) -> ValType {\n  RefTypeValType(rt)\n}\n\n///|\npub fn ref_null_exn_valtype() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(ExnAbsHeapType)))\n}\n\n///|\npub fn funcref_valtype() -> ValType {\n  // In core Wasm, call_indirect uses funcref.\n  // Your encoding: AbsHeapTypeRefType(_) is nullable; funcref is (ref null func).\n  RefTypeValType(AbsHeapTypeRefType(FuncAbsHeapType))\n}\n\n///|\npub fn[T : Eq] equals(a : Array[T], b : Array[T]) -> Bool {\n  if a.length() != b.length() {\n    return false\n  }\n  for i in 0..<a.length() {\n    if a[i] != b[i] {\n      return false\n    }\n  }\n  true\n}\n\n///|\npub fn Limits::addr_valtype(at : Limits) -> ValType {\n  match at {\n    I32Limits(_) => NumTypeValType(I32NumType)\n    I64Limits(_) => NumTypeValType(I64NumType)\n  }\n}\n\n///|\npub fn min_addr(a : Limits, b : Limits) -> Limits {\n  match (a, b) {\n    (I32Limits(_), _) => a\n    (_, I32Limits(_)) => b\n    _ => a\n  }\n}\n\n///|\npub fn elem_reftype(e : Elem) -> RefType {\n  match e {\n    Elem(_, kind) =>\n      match kind {\n        FuncsElemKind(_) => AbsHeapTypeRefType(FuncAbsHeapType) // funcref\n        FuncExprsElemKind(_) => AbsHeapTypeRefType(FuncAbsHeapType) // funcref\n        TypedExprsElemKind(rt, _) => rt\n      }\n  }\n}\n\n///|\npub fn ref_null_valtype(ht : HeapType) -> ValType {\n  RefTypeValType(HeapTypeRefType(true, ht))\n}\n\n///|\npub fn eqref_null_valtype() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)))\n}\n\n///|\npub fn unpack_storage(st : StorageType) -> ValType {\n  match st {\n    ValTypeStorageType(vt) => vt\n    PackTypeStorageType(_) => NumTypeValType(I32NumType)\n  }\n}\n\n///|\npub fn is_packed(st : StorageType) -> Bool {\n  match st {\n    PackTypeStorageType(_) => true\n    _ => false\n  }\n}\n\n///|\npub fn u32_to_int(u : U32) -> Int {\n  let U32(i) = u\n  i.reinterpret_as_int()\n}\n\n///|\npub fn has_default(vt : ValType) -> Bool {\n  match vt {\n    NumTypeValType(_) => true\n    VecTypeValType => true\n    RefTypeValType(rt) => rt.is_nullable() // default is ref.null\n    BotValType => true\n  }\n}\n\n///|\npub fn get_struct_field(\n  fields : Array[FieldType],\n  i : U32,\n) -> Result[FieldType, String] {\n  let idx = u32_to_int(i)\n  match fields.get(idx) {\n    None => Err(\"struct field index out of range\")\n    Some(ft) => Ok(ft)\n  }\n}\n\n///|\npub fn field_is_mutable(ft : FieldType) -> Bool {\n  match ft {\n    FieldType(_, Var) => true\n    _ => false\n  }\n}\n\n///|\npub fn vt_i32() -> ValType {\n  NumTypeValType(I32NumType)\n}\n\n///|\npub fn vt_i64() -> ValType {\n  NumTypeValType(I64NumType)\n}\n\n///|\npub fn vt_f32() -> ValType {\n  NumTypeValType(F32NumType)\n}\n\n///|\npub fn vt_f64() -> ValType {\n  NumTypeValType(F64NumType)\n}\n\n///|\npub fn vt_v128() -> ValType {\n  VecTypeValType\n}\n\n///|\npub fn min_addr_valtype(l1 : Limits, l2 : Limits) -> ValType {\n  match (l1, l2) {\n    (I64Limits(_, _), I64Limits(_, _)) => NumTypeValType(I64NumType)\n    _ => NumTypeValType(I32NumType)\n  }\n}\n\n///|\npub fn anyref_valtype() -> ValType {\n  // (ref null any)\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)))\n}\n\n///|\npub fn externref_valtype() -> ValType {\n  // (ref null extern)\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)))\n}\n\n///|\npub fn i31ref_valtype() -> ValType {\n  // (ref i31) (non-null)\n  RefTypeValType(HeapTypeRefType(false, AbsHeapTypeHeapType(I31AbsHeapType)))\n}\n\n///|\npub fn i31ref_nullable_valtype() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(I31AbsHeapType)))\n}\n\n///|\npub fn ref_array_nonnull(x : TypeIdx) -> ValType {\n  RefTypeValType(HeapTypeRefType(false, HeapType(x)))\n}\n\n///|\npub fn ref_array_nullable(x : TypeIdx) -> ValType {\n  RefTypeValType(HeapTypeRefType(true, HeapType(x)))\n}\n\n///|\npub fn ref_null_array_of(x : TypeIdx) -> ValType {\n  RefTypeValType(HeapTypeRefType(true, HeapType(x)))\n}\n\n///|\n/// A tree-based expression where operands are explicit children rather than implicit stack values.\n/// Each TInstr node contains its consumed operands as children.\npub(all) struct TExpr(Array[TInstr]) derive(Eq, Show, Hash)\n\n///|\n/// A tree-based instruction with explicit operands\npub(all) enum TInstr {\n  // === Constants (0 children, 1 result) ===\n  TI32Const(I32)\n  TI64Const(I64)\n  TF32Const(F32)\n  TF64Const(F64)\n  TRefNull(HeapType)\n  TRefFunc(FuncIdx)\n  TV128Const(\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte\n  )\n\n  // === Nullary (0 children) ===\n  TUnreachable\n  TNop\n  TLocalGet(LocalIdx)\n  TGlobalGet(GlobalIdx)\n  TMemorySize(MemIdx)\n  TTableSize(TableIdx)\n\n  // === Unary (1 child) ===\n  TUnary(UnaryOp, TInstr)\n  TDrop(TInstr)\n  TLocalSet(LocalIdx, TInstr)\n  TLocalTee(LocalIdx, TInstr)\n  TGlobalSet(GlobalIdx, TInstr)\n  TRefIsNull(TInstr)\n  TRefAsNonNull(TInstr)\n  TI31GetS(TInstr)\n  TI31GetU(TInstr)\n  TRefI31(TInstr)\n  TArrayLen(TInstr)\n  TAnyConvertExtern(TInstr)\n  TExternConvertAny(TInstr)\n  TThrowRef(TInstr)\n\n  // === Binary (2 children) ===\n  TBinary(BinaryOp, TInstr, TInstr)\n  TRefEq(TInstr, TInstr)\n  TStore(StoreOp, MemArg, TInstr, TInstr) // addr, value\n\n  // === Load (1 child - address) ===\n  TLoad(LoadOp, MemArg, TInstr)\n\n  // === Memory operations ===\n  TMemoryGrow(MemIdx, TInstr)\n  TMemoryFill(MemIdx, TInstr, TInstr, TInstr) // dest, val, len\n  TMemoryCopy(MemIdx, MemIdx, TInstr, TInstr, TInstr) // dest, src, len\n  TMemoryInit(DataIdx, MemIdx, TInstr, TInstr, TInstr)\n  TDataDrop(DataIdx)\n\n  // === Table operations ===\n  TTableGet(TableIdx, TInstr)\n  TTableSet(TableIdx, TInstr, TInstr)\n  TTableGrow(TableIdx, TInstr, TInstr)\n  TTableFill(TableIdx, TInstr, TInstr, TInstr)\n  TTableCopy(TableIdx, TableIdx, TInstr, TInstr, TInstr)\n  TTableInit(ElemIdx, TableIdx, TInstr, TInstr, TInstr)\n  TElemDrop(ElemIdx)\n\n  // === Calls (N children based on function type) ===\n  TCall(FuncIdx, Array[TInstr])\n  TCallIndirect(TypeIdx, TableIdx, Array[TInstr], TInstr) // args, table index\n  TCallRef(TypeIdx, Array[TInstr], TInstr) // args, funcref\n  TReturnCall(FuncIdx, Array[TInstr])\n  TReturnCallIndirect(TypeIdx, TableIdx, Array[TInstr], TInstr)\n  TReturnCallRef(TypeIdx, Array[TInstr], TInstr)\n\n  // === Control flow ===\n  TBlock(BlockType, TExpr)\n  TLoop(BlockType, TExpr)\n  TIf(BlockType, TInstr, TExpr, TExpr?) // condition, then, else\n  TTryTable(BlockType, Array[Catch], TExpr)\n  TThrow(TagIdx, Array[TInstr])\n\n  // === Branches ===\n  TBr(LabelIdx, Array[TInstr]) // values to pass\n  TBrIf(LabelIdx, TInstr, Array[TInstr]) // condition, values\n  TBrTable(Array[LabelIdx], LabelIdx, TInstr, Array[TInstr]) // index, values\n  TBrOnNull(LabelIdx, TInstr, Array[TInstr])\n  TBrOnNonNull(LabelIdx, TInstr, Array[TInstr])\n  TBrOnCast(LabelIdx, CastOp, HeapType, HeapType, TInstr, Array[TInstr])\n  TBrOnCastFail(LabelIdx, CastOp, HeapType, HeapType, TInstr, Array[TInstr])\n  TReturn(Array[TInstr])\n\n  // === Select ===\n  TSelect(Array[ValType]?, TInstr, TInstr, TInstr) // cond, if_true, if_false\n\n  // === GC: Structs ===\n  TStructNew(TypeIdx, Array[TInstr])\n  TStructNewDefault(TypeIdx)\n  TStructGet(TypeIdx, U32, TInstr)\n  TStructGetS(TypeIdx, U32, TInstr)\n  TStructGetU(TypeIdx, U32, TInstr)\n  TStructSet(TypeIdx, U32, TInstr, TInstr) // struct, value\n\n  // === GC: Arrays ===\n  TArrayNew(TypeIdx, TInstr, TInstr) // init, len\n  TArrayNewDefault(TypeIdx, TInstr) // len\n  TArrayNewFixed(TypeIdx, Array[TInstr])\n  TArrayNewData(TypeIdx, DataIdx, TInstr, TInstr) // offset, len\n  TArrayNewElem(TypeIdx, ElemIdx, TInstr, TInstr)\n  TArrayGet(TypeIdx, TInstr, TInstr) // arr, idx\n  TArrayGetS(TypeIdx, TInstr, TInstr)\n  TArrayGetU(TypeIdx, TInstr, TInstr)\n  TArraySet(TypeIdx, TInstr, TInstr, TInstr) // arr, idx, val\n  TArrayFill(TypeIdx, TInstr, TInstr, TInstr, TInstr) // arr, offset, val, len\n  TArrayCopy(TypeIdx, TypeIdx, TInstr, TInstr, TInstr, TInstr, TInstr)\n  TArrayInitData(TypeIdx, DataIdx, TInstr, TInstr, TInstr, TInstr)\n  TArrayInitElem(TypeIdx, ElemIdx, TInstr, TInstr, TInstr, TInstr)\n\n  // === GC: Casts ===\n  TRefTest(Bool, HeapType, TInstr)\n  TRefCast(Bool, HeapType, TInstr)\n\n  // === SIMD: Splat (scalar -> v128) ===\n  TI8x16Splat(TInstr)\n  TI16x8Splat(TInstr)\n  TI32x4Splat(TInstr)\n  TI64x2Splat(TInstr)\n  TF32x4Splat(TInstr)\n  TF64x2Splat(TInstr)\n\n  // === SIMD: Extract lane (v128 -> scalar) ===\n  TExtractLane(ExtractLaneOp, LaneIdx, TInstr)\n\n  // === SIMD: Replace lane (v128, scalar -> v128) ===\n  TReplaceLane(ReplaceLaneOp, LaneIdx, TInstr, TInstr)\n\n  // === SIMD: Shuffle (v128, v128 -> v128 with 16 lane indices) ===\n  TI8x16Shuffle(\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    TInstr,\n    TInstr\n  )\n\n  // === SIMD: Swizzle (v128, v128 -> v128) ===\n  TI8x16Swizzle(TInstr, TInstr)\n  TI8x16RelaxedSwizzle(TInstr, TInstr)\n\n  // === SIMD: Shift (v128, i32 -> v128) ===\n  TV128Shift(V128ShiftOp, TInstr, TInstr)\n\n  // === SIMD: Ternary (v128, v128, v128 -> v128) ===\n  TV128Ternary(V128TernaryOp, TInstr, TInstr, TInstr)\n\n  // === SIMD: Lane load (v128, addr -> v128) ===\n  TV128LoadLane(V128LoadLaneOp, MemArg, LaneIdx, TInstr, TInstr)\n\n  // === SIMD: Lane store (v128, addr -> void) ===\n  TV128StoreLane(V128StoreLaneOp, MemArg, LaneIdx, TInstr, TInstr)\n} derive(Eq, Show, Hash)\n\n///|\n/// Unary operations\npub(all) enum UnaryOp {\n  // === Scalar ===\n  I32EqzOp\n  I64EqzOp\n  I32ClzOp\n  I32CtzOp\n  I32PopcntOp\n  I64ClzOp\n  I64CtzOp\n  I64PopcntOp\n  F32AbsOp\n  F32NegOp\n  F32CeilOp\n  F32FloorOp\n  F32TruncOp\n  F32NearestOp\n  F32SqrtOp\n  F64AbsOp\n  F64NegOp\n  F64CeilOp\n  F64FloorOp\n  F64TruncOp\n  F64NearestOp\n  F64SqrtOp\n  I32WrapI64Op\n  I32TruncF32SOp\n  I32TruncF32UOp\n  I32TruncF64SOp\n  I32TruncF64UOp\n  I64ExtendI32SOp\n  I64ExtendI32UOp\n  I64TruncF32SOp\n  I64TruncF32UOp\n  I64TruncF64SOp\n  I64TruncF64UOp\n  F32ConvertI32SOp\n  F32ConvertI32UOp\n  F32ConvertI64SOp\n  F32ConvertI64UOp\n  F32DemoteF64Op\n  F64ConvertI32SOp\n  F64ConvertI32UOp\n  F64ConvertI64SOp\n  F64ConvertI64UOp\n  F64PromoteF32Op\n  I32ReinterpretF32Op\n  I64ReinterpretF64Op\n  F32ReinterpretI32Op\n  F64ReinterpretI64Op\n  I32Extend8SOp\n  I32Extend16SOp\n  I64Extend8SOp\n  I64Extend16SOp\n  I64Extend32SOp\n  I32TruncSatF32SOp\n  I32TruncSatF32UOp\n  I32TruncSatF64SOp\n  I32TruncSatF64UOp\n  I64TruncSatF32SOp\n  I64TruncSatF32UOp\n  I64TruncSatF64SOp\n  I64TruncSatF64UOp\n\n  // === SIMD: v128 -> v128 ===\n  V128NotOp\n  I8x16AbsOp\n  I8x16NegOp\n  I8x16PopcntOp\n  I16x8AbsOp\n  I16x8NegOp\n  I32x4AbsOp\n  I32x4NegOp\n  I64x2AbsOp\n  I64x2NegOp\n  F32x4AbsOp\n  F32x4NegOp\n  F32x4SqrtOp\n  F32x4CeilOp\n  F32x4FloorOp\n  F32x4TruncOp\n  F32x4NearestOp\n  F64x2AbsOp\n  F64x2NegOp\n  F64x2SqrtOp\n  F64x2CeilOp\n  F64x2FloorOp\n  F64x2TruncOp\n  F64x2NearestOp\n\n  // === SIMD: v128 -> i32 (bitmask/alltrue) ===\n  V128AnyTrueOp\n  I8x16AllTrueOp\n  I8x16BitmaskOp\n  I16x8AllTrueOp\n  I16x8BitmaskOp\n  I32x4AllTrueOp\n  I32x4BitmaskOp\n  I64x2AllTrueOp\n  I64x2BitmaskOp\n\n  // === SIMD: Extend/narrow (v128 -> v128) ===\n  I16x8ExtendLowI8x16SOp\n  I16x8ExtendHighI8x16SOp\n  I16x8ExtendLowI8x16UOp\n  I16x8ExtendHighI8x16UOp\n  I32x4ExtendLowI16x8SOp\n  I32x4ExtendHighI16x8SOp\n  I32x4ExtendLowI16x8UOp\n  I32x4ExtendHighI16x8UOp\n  I64x2ExtendLowI32x4SOp\n  I64x2ExtendHighI32x4SOp\n  I64x2ExtendLowI32x4UOp\n  I64x2ExtendHighI32x4UOp\n\n  // === SIMD: Pairwise add (v128 -> v128) ===\n  I16x8ExtaddPairwiseI8x16SOp\n  I16x8ExtaddPairwiseI8x16UOp\n  I32x4ExtaddPairwiseI16x8SOp\n  I32x4ExtaddPairwiseI16x8UOp\n\n  // === SIMD: Conversion (v128 -> v128) ===\n  F32x4DemoteF64x2ZeroOp\n  F64x2PromoteLowF32x4Op\n  I32x4TruncSatF32x4SOp\n  I32x4TruncSatF32x4UOp\n  F32x4ConvertI32x4SOp\n  F32x4ConvertI32x4UOp\n  I32x4TruncSatF64x2SZeroOp\n  I32x4TruncSatF64x2UZeroOp\n  F64x2ConvertLowI32x4SOp\n  F64x2ConvertLowI32x4UOp\n\n  // === SIMD: Relaxed truncation (v128 -> v128) ===\n  I32x4RelaxedTruncF32x4SOp\n  I32x4RelaxedTruncF32x4UOp\n  I32x4RelaxedTruncZeroF64x2SOp\n  I32x4RelaxedTruncZeroF64x2UOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Binary operations\npub(all) enum BinaryOp {\n  // === Scalar ===\n  I32EqOp\n  I32NeOp\n  I32LtSOp\n  I32LtUOp\n  I32GtSOp\n  I32GtUOp\n  I32LeSOp\n  I32LeUOp\n  I32GeSOp\n  I32GeUOp\n  I64EqOp\n  I64NeOp\n  I64LtSOp\n  I64LtUOp\n  I64GtSOp\n  I64GtUOp\n  I64LeSOp\n  I64LeUOp\n  I64GeSOp\n  I64GeUOp\n  F32EqOp\n  F32NeOp\n  F32LtOp\n  F32GtOp\n  F32LeOp\n  F32GeOp\n  F64EqOp\n  F64NeOp\n  F64LtOp\n  F64GtOp\n  F64LeOp\n  F64GeOp\n  I32AddOp\n  I32SubOp\n  I32MulOp\n  I32DivSOp\n  I32DivUOp\n  I32RemSOp\n  I32RemUOp\n  I32AndOp\n  I32OrOp\n  I32XorOp\n  I32ShlOp\n  I32ShrSOp\n  I32ShrUOp\n  I32RotlOp\n  I32RotrOp\n  I64AddOp\n  I64SubOp\n  I64MulOp\n  I64DivSOp\n  I64DivUOp\n  I64RemSOp\n  I64RemUOp\n  I64AndOp\n  I64OrOp\n  I64XorOp\n  I64ShlOp\n  I64ShrSOp\n  I64ShrUOp\n  I64RotlOp\n  I64RotrOp\n  F32AddOp\n  F32SubOp\n  F32MulOp\n  F32DivOp\n  F32MinOp\n  F32MaxOp\n  F32CopysignOp\n  F64AddOp\n  F64SubOp\n  F64MulOp\n  F64DivOp\n  F64MinOp\n  F64MaxOp\n  F64CopysignOp\n\n  // === SIMD: Bitwise (v128, v128 -> v128) ===\n  V128AndOp\n  V128AndnotOp\n  V128OrOp\n  V128XorOp\n\n  // === SIMD: i8x16 comparisons ===\n  I8x16EqOp\n  I8x16NeOp\n  I8x16LtSOp\n  I8x16LtUOp\n  I8x16GtSOp\n  I8x16GtUOp\n  I8x16LeSOp\n  I8x16LeUOp\n  I8x16GeSOp\n  I8x16GeUOp\n\n  // === SIMD: i16x8 comparisons ===\n  I16x8EqOp\n  I16x8NeOp\n  I16x8LtSOp\n  I16x8LtUOp\n  I16x8GtSOp\n  I16x8GtUOp\n  I16x8LeSOp\n  I16x8LeUOp\n  I16x8GeSOp\n  I16x8GeUOp\n\n  // === SIMD: i32x4 comparisons ===\n  I32x4EqOp\n  I32x4NeOp\n  I32x4LtSOp\n  I32x4LtUOp\n  I32x4GtSOp\n  I32x4GtUOp\n  I32x4LeSOp\n  I32x4LeUOp\n  I32x4GeSOp\n  I32x4GeUOp\n\n  // === SIMD: i64x2 comparisons ===\n  I64x2EqOp\n  I64x2NeOp\n  I64x2LtSOp\n  I64x2GtSOp\n  I64x2LeSOp\n  I64x2GeSOp\n\n  // === SIMD: f32x4 comparisons ===\n  F32x4EqOp\n  F32x4NeOp\n  F32x4LtOp\n  F32x4GtOp\n  F32x4LeOp\n  F32x4GeOp\n\n  // === SIMD: f64x2 comparisons ===\n  F64x2EqOp\n  F64x2NeOp\n  F64x2LtOp\n  F64x2GtOp\n  F64x2LeOp\n  F64x2GeOp\n\n  // === SIMD: i8x16 arithmetic ===\n  I8x16AddOp\n  I8x16AddSatSOp\n  I8x16AddSatUOp\n  I8x16SubOp\n  I8x16SubSatSOp\n  I8x16SubSatUOp\n  I8x16MinSOp\n  I8x16MinUOp\n  I8x16MaxSOp\n  I8x16MaxUOp\n  I8x16AvgrUOp\n  I8x16NarrowI16x8SOp\n  I8x16NarrowI16x8UOp\n\n  // === SIMD: i16x8 arithmetic ===\n  I16x8AddOp\n  I16x8AddSatSOp\n  I16x8AddSatUOp\n  I16x8SubOp\n  I16x8SubSatSOp\n  I16x8SubSatUOp\n  I16x8MulOp\n  I16x8MinSOp\n  I16x8MinUOp\n  I16x8MaxSOp\n  I16x8MaxUOp\n  I16x8AvgrUOp\n  I16x8Q15mulrSatSOp\n  I16x8NarrowI32x4SOp\n  I16x8NarrowI32x4UOp\n  I16x8ExtmulLowI8x16SOp\n  I16x8ExtmulHighI8x16SOp\n  I16x8ExtmulLowI8x16UOp\n  I16x8ExtmulHighI8x16UOp\n\n  // === SIMD: i32x4 arithmetic ===\n  I32x4AddOp\n  I32x4SubOp\n  I32x4MulOp\n  I32x4MinSOp\n  I32x4MinUOp\n  I32x4MaxSOp\n  I32x4MaxUOp\n  I32x4DotI16x8SOp\n  I32x4ExtmulLowI16x8SOp\n  I32x4ExtmulHighI16x8SOp\n  I32x4ExtmulLowI16x8UOp\n  I32x4ExtmulHighI16x8UOp\n\n  // === SIMD: i64x2 arithmetic ===\n  I64x2AddOp\n  I64x2SubOp\n  I64x2MulOp\n  I64x2ExtmulLowI32x4SOp\n  I64x2ExtmulHighI32x4SOp\n  I64x2ExtmulLowI32x4UOp\n  I64x2ExtmulHighI32x4UOp\n\n  // === SIMD: f32x4 arithmetic ===\n  F32x4AddOp\n  F32x4SubOp\n  F32x4MulOp\n  F32x4DivOp\n  F32x4MinOp\n  F32x4MaxOp\n  F32x4PminOp\n  F32x4PmaxOp\n\n  // === SIMD: f64x2 arithmetic ===\n  F64x2AddOp\n  F64x2SubOp\n  F64x2MulOp\n  F64x2DivOp\n  F64x2MinOp\n  F64x2MaxOp\n  F64x2PminOp\n  F64x2PmaxOp\n\n  // === SIMD: Relaxed ===\n  F32x4RelaxedMinOp\n  F32x4RelaxedMaxOp\n  F64x2RelaxedMinOp\n  F64x2RelaxedMaxOp\n  I16x8RelaxedQ15mulrSOp\n  I16x8RelaxedDotI8x16I7x16SOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Load operations\npub(all) enum LoadOp {\n  // === Scalar ===\n  I32LoadOp\n  I64LoadOp\n  F32LoadOp\n  F64LoadOp\n  I32Load8SOp\n  I32Load8UOp\n  I32Load16SOp\n  I32Load16UOp\n  I64Load8SOp\n  I64Load8UOp\n  I64Load16SOp\n  I64Load16UOp\n  I64Load32SOp\n  I64Load32UOp\n\n  // === SIMD ===\n  V128LoadOp\n  V128Load8x8SOp\n  V128Load8x8UOp\n  V128Load16x4SOp\n  V128Load16x4UOp\n  V128Load32x2SOp\n  V128Load32x2UOp\n  V128Load8SplatOp\n  V128Load16SplatOp\n  V128Load32SplatOp\n  V128Load64SplatOp\n  V128Load32ZeroOp\n  V128Load64ZeroOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Store operations\npub(all) enum StoreOp {\n  // === Scalar ===\n  I32StoreOp\n  I64StoreOp\n  F32StoreOp\n  F64StoreOp\n  I32Store8Op\n  I32Store16Op\n  I64Store8Op\n  I64Store16Op\n  I64Store32Op\n\n  // === SIMD ===\n  V128StoreOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Extract lane operations (v128 -> scalar)\npub(all) enum ExtractLaneOp {\n  I8x16ExtractLaneSOp\n  I8x16ExtractLaneUOp\n  I16x8ExtractLaneSOp\n  I16x8ExtractLaneUOp\n  I32x4ExtractLaneOp\n  I64x2ExtractLaneOp\n  F32x4ExtractLaneOp\n  F64x2ExtractLaneOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Replace lane operations (v128, scalar -> v128)\npub(all) enum ReplaceLaneOp {\n  I8x16ReplaceLaneOp\n  I16x8ReplaceLaneOp\n  I32x4ReplaceLaneOp\n  I64x2ReplaceLaneOp\n  F32x4ReplaceLaneOp\n  F64x2ReplaceLaneOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 shift operations (v128, i32 -> v128)\npub(all) enum V128ShiftOp {\n  I8x16ShlOp\n  I8x16ShrSOp\n  I8x16ShrUOp\n  I16x8ShlOp\n  I16x8ShrSOp\n  I16x8ShrUOp\n  I32x4ShlOp\n  I32x4ShrSOp\n  I32x4ShrUOp\n  I64x2ShlOp\n  I64x2ShrSOp\n  I64x2ShrUOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 ternary operations (v128, v128, v128 -> v128)\npub(all) enum V128TernaryOp {\n  V128BitselectOp\n  I8x16RelaxedLaneselectOp\n  I16x8RelaxedLaneselectOp\n  I32x4RelaxedLaneselectOp\n  I64x2RelaxedLaneselectOp\n  F32x4RelaxedMaddOp\n  F32x4RelaxedNmaddOp\n  F64x2RelaxedMaddOp\n  F64x2RelaxedNmaddOp\n  I32x4RelaxedDotI8x16I7x16AddSOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 lane load operations\npub(all) enum V128LoadLaneOp {\n  V128Load8LaneOp\n  V128Load16LaneOp\n  V128Load32LaneOp\n  V128Load64LaneOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 lane store operations\npub(all) enum V128StoreLaneOp {\n  V128Store8LaneOp\n  V128Store16LaneOp\n  V128Store32LaneOp\n  V128Store64LaneOp\n} derive(Eq, Show, Hash)\n","///|\npub fn expand_locals(decls : Array[Locals]) -> Result[Array[ValType], String] {\n  let out : Array[ValType] = []\n  for d in decls {\n    let Locals(n, vt) = d\n    let count = n.reinterpret_as_int()\n    if count < 0 {\n      return Err(\"locals: negative count\")\n    }\n    for _ in 0..<count {\n      out.push(vt)\n    }\n  }\n  Ok(out)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct RandomState {\n  mut seed : UInt64\n  gamma : UInt64\n} derive(Show)\n\n///|\nlet golden_gamma : UInt64 = 0x9e3779b97f4a7c15\n\n///|\nlet double_ulp : Double = 1.0 / (1L << 53).to_double()\n\n///|\nlet float_ulp : Float = 1.0F / Float::from_int64(1L << 24)\n\n///|\n/// Create a new RandomState from an optional seed.\npub fn new(seed? : UInt64 = 37) -> RandomState {\n  { seed: mix64(seed), gamma: mix_gamma(seed + golden_gamma) }\n}\n\n///|\n/// Clone a RandomState.\npub fn RandomState::clone(self : RandomState) -> RandomState {\n  { ..self }\n}\n\n///|\n/// Skip the next random number.\npub fn RandomState::next(self : RandomState) -> Unit {\n  self.next_uint64() |> ignore\n}\n\n///|\n/// Get the next random number as a 64-bit unsigned integer.\npub fn RandomState::next_uint64(self : RandomState) -> UInt64 {\n  let { seed, gamma } = self\n  self.seed = seed + gamma\n  mix64(self.seed)\n}\n\n///|\n/// Get the next random number as a 32-bit unsigned integer.\npub fn RandomState::next_uint(self : RandomState) -> UInt {\n  self.next_uint64().to_uint()\n}\n\n///|\n/// Get the next random number as a 64-bit signed integer.\npub fn RandomState::next_int64(self : RandomState) -> Int64 {\n  self.next_uint64().reinterpret_as_int64()\n}\n\n///|\n/// Get the next two random number as 32-bit signed integers.\npub fn RandomState::next_two_uint(self : RandomState) -> (UInt, UInt) {\n  let g = self.next_uint64()\n  ((g >> 32).to_uint(), g.to_uint())\n}\n\n///|\n/// Get the next random number as a 32-bit signed integer.\npub fn RandomState::next_int(self : RandomState) -> Int {\n  self.next_uint().reinterpret_as_int()\n}\n\n///|\n/// Get the next random number as a positive 32-bit signed integer.\npub fn RandomState::next_positive_int(self : RandomState) -> Int {\n  let r = self.next_int()\n  match r {\n    -2147483648 => 2147483647\n    0 => 1\n    r if r < 0 => -r\n    r => r\n  }\n}\n\n///|\n/// Get the next random number as a float in [0, 1]\npub fn RandomState::next_float(self : RandomState) -> Float {\n  let u = self.next_uint64()\n  Float::from_uint64(u >> 40) * float_ulp\n}\n\n///|\n/// Get the next random number as a double in [0, 1]\npub fn RandomState::next_double(self : RandomState) -> Double {\n  let u = self.next_uint64()\n  (u >> 11).to_double() * double_ulp\n}\n\n///|\n/// Generates an independent random number generator.\npub fn RandomState::split(self : RandomState) -> RandomState {\n  let seed1 = self.seed + self.gamma\n  self.seed = seed1 + self.gamma\n  { seed: mix64(seed1), gamma: mix_gamma(self.seed) }\n}\n\n///|\nfn shift_xor(n : Int, w : UInt64) -> UInt64 {\n  w ^ (w >> n)\n}\n\n///|\nfn shift_xor_mul(n : Int, k : UInt64, w : UInt64) -> UInt64 {\n  shift_xor(n, w) * k\n}\n\n///|\nfn mix64(z0 : UInt64) -> UInt64 {\n  let z1 = shift_xor_mul(30, 0xff51afd7ed558ccd, z0)\n  let z2 = shift_xor_mul(33, 0xc4ceb9fe1a85ec53, z1)\n  shift_xor(33, z2)\n}\n\n///|\nfn mix64variant13(z0 : UInt64) -> UInt64 {\n  let z1 = shift_xor_mul(30, 0xbf58476d1ce4e5b9, z0)\n  let z2 = shift_xor_mul(27, 0x94d049bb133111eb, z1)\n  shift_xor(31, z2)\n}\n\n///|\nfn mix_gamma(z0 : UInt64) -> UInt64 {\n  let z1 = mix64variant13(z0 | 1)\n  let n = (z1 | (z1 >> 1)).popcnt()\n  if n >= 24 {\n    z1\n  } else {\n    z1 ^ 0xaaaaaaaaaaaaaaaa\n  }\n}\n\n///|\npub impl Default for RandomState with default() {\n  new()\n}\n\n///|\ntest \"non-zero default\" {\n  let rs = RandomState::default()\n  assert_not_eq(rs.seed, 0)\n  assert_not_eq(rs.gamma, 0)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts a floating-point number to its string representation.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be converted.\n/// * `logger` : The logger to write the string representation to.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f : Float = 3.14\n///   let s = f.to_double().to_string()\n///   inspect(s, content=\"3.140000104904175\")\n/// }\n/// ```\npub impl Show for Float with output(self, logger) {\n  logger.write_string(self.to_double().to_string())\n}\n\n///|\n/// Returns a default value for the `Float` type, which is `0.0`.\n///\n/// Returns a `Float` value initialized to zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Float::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Float with default() {\n  0\n}\n\n///|\n/// Combines the hash value of a floating-point number with an existing hasher.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be hashed.\n/// * `hasher` : The hasher object to combine the hash value with.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Float = 3.14\n///   let y : Float = 3.14\n///   // Same values should produce same hash combinations\n///   inspect(Hash::hash(x) == Hash::hash(y), content=\"true\")\n/// }\n/// ```\npub impl Hash for Float with hash_combine(self, hasher) {\n  hasher.combine_uint(self.reinterpret_as_uint())\n}\n\n///|\n/// Converts a floating-point number to a sequence of bytes in big-endian byte\n/// order. In big-endian order, the most significant byte is stored at the lowest\n/// memory address.\n///\n/// Parameters:\n///\n/// * `float` : The floating-point number to be converted.\n///\n/// Returns a sequence of 4 bytes representing the floating-point number in IEEE\n/// 754 single-precision format with big-endian byte order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Float = 1.0\n///   inspect(\n///     x.to_be_bytes(),\n///     content=(\n///       #|b\"?\\x80\\x00\\x00\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Float::to_be_bytes(self : Float) -> Bytes {\n  let uint = self.reinterpret_as_uint()\n  [\n    (uint >> 24).to_byte(),\n    (uint >> 16).to_byte(),\n    (uint >> 8).to_byte(),\n    uint.to_byte(),\n  ]\n}\n\n///|\n/// Converts a floating-point number to its binary representation in\n/// little-endian byte order.\n///\n/// Parameters:\n///\n/// * `float` : The floating-point number to be converted.\n///\n/// Returns a sequence of bytes representing the float value in little-endian\n/// order (least significant byte first).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f : Float = 1.0\n///   let bytes = f.to_le_bytes()\n///   inspect(bytes.length(), content=\"4\")\n/// }\n/// ```\npub fn Float::to_le_bytes(self : Float) -> Bytes {\n  let uint = self.reinterpret_as_uint()\n  [\n    uint.to_byte(),\n    (uint >> 8).to_byte(),\n    (uint >> 16).to_byte(),\n    (uint >> 24).to_byte(),\n  ]\n}\n\n///|\n/// Determines if the floating-point number is positive or negative infinity.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is positive or negative\n/// infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.infinity.is_inf(), content=\"true\")\n///   inspect(@float.neg_infinity.is_inf(), content=\"true\")\n///   inspect((1.0 : Float).is_inf(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_inf(self : Float) -> Bool {\n  self.is_pos_inf() || self.is_neg_inf()\n}\n\n///|\n/// Determines if the floating-point number is positive infinity.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is positive infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.infinity.is_pos_inf(), content=\"true\")\n///   inspect((1.0 : Float).is_pos_inf(), content=\"false\")\n///   inspect(@float.neg_infinity.is_pos_inf(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_pos_inf(self : Float) -> Bool {\n  self > max_value\n}\n\n///|\n/// Determines if the floating-point number is negative infinity.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is negative infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.neg_infinity.is_neg_inf(), content=\"true\")\n///   inspect((1.0 : Float).is_neg_inf(), content=\"false\")\n///   inspect(@float.infinity.is_neg_inf(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_neg_inf(self : Float) -> Bool {\n  self < min_value\n}\n\n///|\n/// Determines if the floating-point number is NaN (Not a Number).\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is NaN.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.not_a_number.is_nan(), content=\"true\")\n///   inspect((1.0 : Float).is_nan(), content=\"false\")\n///   inspect(@float.infinity.is_nan(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_nan(self : Float) -> Bool {\n  self != self\n}\n\n///|\n/// Determines whether two floating-point numbers are approximately equal within\n/// specified tolerances.\n/// The implementation follows the algorithm described in PEP 485 for Python's\n/// `math.isclose()`.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n/// * `relative_tolerance` : The relative tolerance for the comparison. Must be\n/// non-negative. Defaults to 1e-9.\n/// * `absolute_tolerance` : The absolute tolerance for the comparison. Must be\n/// non-negative. Defaults to 0.0.\n///\n/// Returns whether the two numbers are considered approximately equal. Returns\n/// `true` if the numbers are exactly equal or if they are within either the\n/// relative or absolute tolerance. Returns `false` if either number is infinite.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1.0\n///   let y = 1.000000001\n///   inspect(x.is_close(y), content=\"false\")\n///   inspect(x.is_close(y, relative_tolerance=1.0e-10), content=\"false\")\n///   inspect(@float.infinity.is_close(@float.infinity), content=\"true\")\n/// }\n/// ```\npub fn Float::is_close(\n  self : Self,\n  other : Self,\n  relative_tolerance? : Self = 1.0e-09,\n  absolute_tolerance? : Self = 0.0,\n) -> Bool {\n  if relative_tolerance < 0.0 || absolute_tolerance < 0.0 {\n    abort(\"Tolerances must be non-negative\")\n  }\n  if self == other {\n    return true\n  }\n  if self.is_inf() || other.is_inf() {\n    return false\n  }\n  let diff = (other - self).abs()\n  return (\n      diff <= (relative_tolerance * other).abs() ||\n      diff <= (relative_tolerance * self).abs()\n    ) ||\n    diff <= absolute_tolerance\n}\n\n///|\n/// Calculates the modulo operation between two floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The dividend floating-point number.\n/// * `other` : The divisor floating-point number.\n///\n/// Returns the remainder of the division of `self` by `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect((5.7 : Float).mod(2.0), content=\"1.6999998092651367\")\n///   inspect((-5.7 : Float).mod(2.0), content=\"-1.6999998092651367\")\n/// }\n/// ```\npub impl Mod for Float with mod(self : Float, other : Float) -> Float {\n  Float::from_double(self.to_double() % other.to_double())\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Float::upto(\n  self : Float,\n  end : Float,\n  inclusive? : Bool = false,\n) -> Iter[Float] {\n  let mut i = self\n  Iter::new(() => {\n    guard i < end || (inclusive && i == end) else { None }\n    let result = i\n    if i != end {\n      i += 1\n    }\n    Some(result)\n  })\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n/// To grow the range downward, set the `step` parameter to a negative value.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive by default).\n/// * `step` - The step size of the range (default 1.0).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\npub fn Float::until(\n  self : Float,\n  end : Float,\n  step? : Float = 1.0,\n  inclusive? : Bool = false,\n) -> Iter[Float] {\n  if step == 0.0 {\n    return Iter::empty()\n  }\n  let mut curr_value = Some(self)\n  Iter::new(() => {\n    guard curr_value is Some(i) else { None }\n    guard (step > 0.0 && i < end) ||\n      (step < 0.0 && i > end) ||\n      (inclusive && i == end) else {\n      None\n    }\n    let next = i + step\n    if (step > 0.0 && next >= i) || (step < 0.0 && next <= i) {\n      curr_value = Some(next)\n    } else {\n      // overflow\n      curr_value = None\n    }\n    Some(i)\n  })\n}\n\n///|\n/// Converts a 32-bit floating-point number to a double-precision (64-bit)\n/// floating-point number.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number to be converted.\n///\n/// Returns a double-precision floating-point number that preserves the exact\n/// value of the input. Since double-precision has more bits than\n/// single-precision, this conversion is always exact and never loses precision.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f = Float::from_double(3.14)\n///   inspect(f.to_double(), content=\"3.140000104904175\")\n/// }\n/// ```\npub fn Float::to_double(self : Float) -> Double = \"%f32.to_f64\"\n\n///|\npub impl ToJson for Float with to_json(self : Float) -> Json {\n  Json::number(self.to_double())\n}\n\n///|\n/// Calculates the square root of a floating-point number. For non-negative\n/// numbers, returns the principal square root. For negative numbers or NaN,\n/// returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number whose square root is to be calculated.\n///\n/// Returns a 32-bit floating-point number representing the square root of the\n/// input value:\n///\n/// * For a positive number, returns its principal square root\n/// * For zero (positive or negative), returns zero with the same sign\n/// * For NaN or negative numbers, returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Float::from_double(16.0)\n///   let root = x.sqrt()\n///   inspect(root.to_double(), content=\"4\")\n///   let neg = Float::from_double(-4.0)\n///   let neg_root = neg.sqrt()\n///   inspect(neg_root.to_double(), content=\"NaN\")\n/// }\n/// ```\npub fn Float::sqrt(self : Float) -> Float = \"%f32.sqrt\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as a 32-bit signed\n/// integer without performing any numeric conversion. The bit pattern is\n/// preserved exactly, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns a 32-bit signed integer that has the same bit pattern as the input\n/// floating-point number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f = Float::from_double(1.0)\n///   // IEEE 754 representation of 1.0 is 0x3F800000\n///   inspect(f.reinterpret_as_int(), content=\"1065353216\")\n/// }\n/// ```\npub fn Float::reinterpret_as_int(self : Float) -> Int = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Performs unary negation on a 32-bit floating-point number. Returns the\n/// arithmetic inverse of the operand.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to negate.\n///\n/// Returns a new floating-point number with the same magnitude but opposite sign\n/// as the input. Special cases:\n///\n/// * Negating NaN returns NaN\n/// * Negating +0.0 returns -0.0\n/// * Negating -0.0 returns +0.0\n/// * Negating +Infinity returns -Infinity\n/// * Negating -Infinity returns +Infinity\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f = Float::from_double(3.14)\n///   inspect((-f).to_double(), content=\"-3.140000104904175\")\n///   let zero = Float::from_double(0.0)\n///   inspect((-zero).to_double(), content=\"0\")\n/// }\n/// ```\npub impl Neg for Float with neg(self) = \"%f32.neg\"\n\n///|\n/// Performs addition between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point operand.\n/// * `other` : The second floating-point operand to be added to the first\n/// operand.\n///\n/// Returns a single-precision floating-point number representing the sum of the\n/// two operands.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = Float::from_double(3.14)\n///   let b = Float::from_double(2.86)\n///   let sum = a + b\n///   inspect(sum.to_double(), content=\"6\")\n/// }\n/// ```\npub impl Add for Float with add(self, other) = \"%f32.add\"\n\n///|\n/// Performs subtraction between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number (minuend).\n/// * `other` : The second floating-point number (subtrahend).\n///\n/// Returns a new floating-point number representing the difference between\n/// `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Float::from_double(3.14)\n///   let y = Float::from_double(1.0)\n///   let result = x - y\n///   inspect(result.to_double(), content=\"2.140000104904175\")\n/// }\n/// ```\npub impl Sub for Float with sub(self, other) = \"%f32.sub\"\n\n///|\n/// Performs multiplication between two single-precision floating-point numbers\n/// according to IEEE 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number operand.\n/// * `other` : The second floating-point number operand to multiply with the\n/// first.\n///\n/// Returns a single-precision floating-point number that is the product of the\n/// two operands.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Float::from_int(2)\n///   let y = Float::from_int(3)\n///   let z = x * y\n///   inspect(z.to_double(), content=\"6\")\n/// }\n/// ```\npub impl Mul for Float with mul(self, other) = \"%f32.mul\"\n\n///|\n/// Performs division between two 32-bit floating-point numbers according to IEEE\n/// 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The dividend floating-point number.\n/// * `other` : The divisor floating-point number.\n///\n/// Returns a new floating-point number representing the quotient of the\n/// division. Special cases follow IEEE 754 rules:\n///\n/// * Division by zero returns infinity (with the appropriate sign)\n/// * Division of zero by zero returns NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = Float::from_double(6.0)\n///   let b = Float::from_double(2.0)\n///   let result = (a / b).to_double()\n///   inspect(result, content=\"3\")\n///   inspect(\n///     (Float::from_double(0.0) / Float::from_double(0.0)).to_double(),\n///     content=\"NaN\",\n///   )\n/// }\n/// ```\npub impl Div for Float with div(self, other) = \"%f32.div\"\n\n///|\n/// Tests two floating-point numbers for equality. Follows IEEE 754 equality\n/// comparison rules, where NaN values are not equal to any value, including\n/// themselves.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise. Note that `-0.0`\n/// and `+0.0` are considered equal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 3.14\n///   let y = 3.14\n///   let z = 0.0 / 0.0 // NaN\n///   inspect(x == y, content=\"true\")\n///   inspect(z == z, content=\"false\") // NaN is not equal to itself\n/// }\n/// ```\npub impl Eq for Float with equal(self : Float, other : Float) -> Bool = \"%f32.eq\"\n\n///|\n/// Tests two floating-point numbers for inequality. Follows IEEE 754 inequality\n/// comparison rules, where NaN values are not equal to any value, including\n/// themselves.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if the numbers are not equal, `false` otherwise. Note that `-0.0`\n/// and `+0.0` are considered equal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 3.14\n///   let y = 3.14\n///   let z = 0.0 / 0.0 // NaN\n///   inspect(x != y, content=\"false\")\n///   inspect(z != z, content=\"true\") // NaN is not equal to itself\n/// }\n/// ```\npub impl Eq for Float with not_equal(self : Float, other : Float) -> Bool = \"%f32.ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Float::op_neq(self : Float, other : Float) -> Bool = \"%f32.ne\"\n\n///|\n/// Compares two 32-bit floating-point numbers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Float with compare(self, other) = \"%f32.compare\"\n\n///|\npub impl Compare for Float with op_lt(x, y) = \"%f32.lt\"\n\n///|\npub impl Compare for Float with op_le(x, y) = \"%f32.le\"\n\n///|\npub impl Compare for Float with op_gt(x, y) = \"%f32.gt\"\n\n///|\npub impl Compare for Float with op_ge(x, y) = \"%f32.ge\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as an unsigned 32-bit\n/// integer without performing any numeric conversion. Preserves the exact bit\n/// pattern of the input value, only changing how these bits are interpreted.\n///\n/// Parameters:\n///\n/// * `float` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns an unsigned 32-bit integer (`UInt`) that has the same bit pattern as\n/// the input floating-point number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Float = 1.0\n///   inspect(x.reinterpret_as_uint(), content=\"1065353216\") // Decimal representation of 0x3F800000\n/// }\n/// ```\npub fn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets the bits of a 32-bit integer as a single-precision\n/// floating-point number according to IEEE 754 standard. The bit pattern of the\n/// input is preserved, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be reinterpreted as a\n/// single-precision floating-point number.\n///\n/// Returns a 32-bit floating-point number (`Float`) that has the same bit\n/// pattern as the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   // 0x3F800000 represents 1.0 in IEEE 754 single-precision format\n///   let n = 1065353216 // 0x3F800000\n///   inspect(Float::reinterpret_from_int(n), content=\"1\")\n/// }\n/// ```\n// TODO(upstream): no test entry found\npub fn Float::reinterpret_from_int(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n/// Reinterprets the bits of an unsigned 32-bit integer as a single-precision\n/// floating-point number (IEEE 754). The bit pattern is preserved exactly, only\n/// the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be reinterpreted as\n/// a single-precision floating-point number.\n///\n/// Returns a single-precision floating-point number (`Float`) whose bit pattern\n/// is identical to the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 0x3F800000U // Bit pattern for 1.0f\n///   inspect(Float::reinterpret_from_uint(n), content=\"1\")\n/// }\n/// ```\n// TODO(upstream): no test entry found\npub fn Float::reinterpret_from_uint(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\ntest \"Float::reinterpret\" {\n  inspect(Float::reinterpret_from_int(1065353216), content=\"1\")\n  inspect(Float::reinterpret_from_uint(0x3F800000), content=\"1\")\n}\n\n///|\n/// Converts an integer to a 32-bit floating-point number. The conversion is\n/// exact for small integers, but may lose precision for large integers due to\n/// the limited precision of the floating-point format.\n///\n/// Parameters:\n///\n/// * `number` : The integer value to be converted to a floating-point number.\n///\n/// Returns a 32-bit floating-point number representing the same value as the\n/// input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   let f = Float::from_int(n)\n///   // Convert back to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"42\")\n/// }\n/// ```\npub fn Float::from_int(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n/// Converts a byte value to a 32-bit floating-point number (IEEE 754\n/// single-precision format). The byte value is treated as an unsigned 8-bit\n/// integer during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to a float.\n///\n/// Returns a 32-bit floating-point number representing the byte value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // 255 in decimal\n///   let f = Float::from_byte(b)\n///   // Convert to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"255\")\n/// }\n/// ```\npub fn Float::from_byte(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// Converts a double-precision floating-point number to a single-precision\n/// floating-point number. The conversion may result in a loss of precision due\n/// to the reduced number of bits available in the single-precision format.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns a single-precision floating-point number that represents the closest\n/// possible value to the input double-precision number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let d = 3.14159265359\n///   inspect(Float::from_double(d).to_double(), content=\"3.1415927410125732\") // Note the loss of precision\n/// }\n/// ```\npub fn Float::from_double(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n/// Converts an unsigned 32-bit integer to a single-precision floating-point\n/// number. Due to the limited precision of the 32-bit floating-point format,\n/// values above 16777216 (2^24) may lose precision during conversion.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the same numerical\n/// value as the input unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(Float::from_uint(n).to_double(), content=\"42\")\n///   let big = 16777216U // 2^24\n///   inspect(Float::from_uint(big).to_double(), content=\"16777216\") // Last precisely representable integer\n/// }\n/// ```\npub fn Float::from_uint(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n/// Converts an unsigned 64-bit integer to a 32-bit floating-point number. Due to\n/// floating-point precision limitations, the conversion may lose precision if\n/// the integer value is too large to be represented exactly as a float.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the input value. If\n/// the input value is too large to be represented exactly, the result will be\n/// rounded to the nearest representable float value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42UL\n///   inspect(Float::from_uint64(n).to_double(), content=\"42\")\n///   let big = 18446744073709551615UL // UInt64::max_value\n///   inspect(Float::from_uint64(big).to_double(), content=\"18446744073709552000\")\n/// }\n/// ```\n#cfg(not(target=\"js\"))\npub fn Float::from_uint64(self : UInt64) -> Float = \"%u64.to_f32\"\n\n///|\n#cfg(target=\"js\")\npub fn Float::from_uint64(self : UInt64) -> Float {\n  Float::from_double(self.to_double())\n}\n\n///|\ntest \"Float::from_uint64\" {\n  let n = 42UL\n  inspect(Float::from_uint64(n).to_double(), content=\"42\")\n  let big = 18446744073709551615UL // UInt64::max_value\n  inspect(Float::from_uint64(big).to_double(), content=\"18446744073709552000\")\n}\n\n///|\n/// Converts a 64-bit integer to a 32-bit floating-point number. The conversion\n/// may result in loss of precision due to the limited precision of the 32-bit\n/// floating-point format.\n///\n/// Parameters:\n///\n/// * `self` : The 64-bit integer value to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the input integer\n/// value. Note that for values outside the range of representable 32-bit\n/// floating-point numbers, the result will be rounded to the nearest\n/// representable value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42L\n///   let f = Float::from_int64(n)\n///   // Convert to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"42\")\n/// }\n/// ```\n#cfg(not(target=\"js\"))\npub fn Float::from_int64(self : Int64) -> Float = \"%i64.to_f32\"\n\n///|\n#cfg(target=\"js\")\npub fn Float::from_int64(self : Int64) -> Float {\n  Float::from_double(self.to_double())\n}\n\n///|\ntest \"Float::from_int64\" {\n  let n = 42L\n  let f = Float::from_int64(n)\n  inspect(f.to_double(), content=\"42\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts an integer to a double-precision floating-point number.\n///\n/// Parameters:\n///\n/// * `integer` : The integer value to be converted.\n///\n/// Returns a double-precision floating-point number representing the given\n/// integer value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Double::from_int(42), content=\"42\")\n///   inspect(Double::from_int(-1), content=\"-1\")\n/// }\n/// ```\n#as_free_fn(deprecated)\npub fn Double::from_int(i : Int) -> Double {\n  i.to_double()\n}\n\n///|\n/// Returns the absolute value of a double-precision floating-point number.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to compute the\n/// absolute value of.\n///\n/// Returns the absolute value of the input number. For any input `x`, the result\n/// is equivalent to `if x < 0.0 { -x } else { x }`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect((-2.5).abs(), content=\"2.5\")\n///   inspect(3.14.abs(), content=\"3.14\")\n///   inspect(0.0.abs(), content=\"0\")\n/// }\n/// ```\n#as_free_fn(deprecated)\npub fn Double::abs(self : Double) -> Double = \"%f64.abs\"\n\n///|\n/// Returns the sign of the double.\n/// - If the double is positive, returns 1.0.\n/// - If the double is negative, returns -1.0.\n/// - Otherwise, returns the double itself (0.0, -0.0 and NaN).\npub fn Double::signum(self : Double) -> Double {\n  if self < 0.0 {\n    -1.0\n  } else if self > 0.0 {\n    1.0\n  } else {\n    self // handles 0.0, -0.0, NaN\n  }\n}\n\n///|\n/// Checks whether a double-precision floating-point number represents a \"Not a\n/// Number\" (NaN) value.\n///\n/// Parameters:\n///\n/// * `number` : A double-precision floating-point value to be checked.\n///\n/// Returns `true` if the number is NaN, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@double.not_a_number.is_nan(), content=\"true\")\n///   inspect(42.0.is_nan(), content=\"false\")\n///   inspect((0.0 / 0.0).is_nan(), content=\"true\")\n/// }\n/// ```\npub fn Double::is_nan(self : Double) -> Bool {\n  // only NaNs satisfy f != f.\n  self != self\n}\n\n///|\n/// Checks whether a double-precision floating-point number represents positive\n/// or negative infinity.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to check.\n///\n/// Returns `true` if the value is either positive or negative infinity, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@double.infinity.is_inf(), content=\"true\")\n///   inspect(@double.neg_infinity.is_inf(), content=\"true\")\n///   inspect(42.0.is_inf(), content=\"false\")\n/// }\n/// ```\npub fn Double::is_inf(self : Double) -> Bool {\n  self > max_value || self < min_value\n}\n\n///|\n/// Checks whether a double-precision floating-point number is positive infinity.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to check.\n///\n/// Returns `true` if the number is positive infinity, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@double.infinity.is_pos_inf(), content=\"true\")\n///   inspect(@double.neg_infinity.is_pos_inf(), content=\"false\")\n///   inspect(42.0.is_pos_inf(), content=\"false\") // TODO: better formatter\n/// }\n/// ```\npub fn Double::is_pos_inf(self : Double) -> Bool {\n  self > max_value\n}\n\n///|\n/// Checks whether a double-precision floating-point number is negative infinity.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number to check.\n///\n/// Returns a boolean value indicating whether the number is negative infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect((-1.0 / 0.0).is_neg_inf(), content=\"true\")\n///   inspect(42.0.is_neg_inf(), content=\"false\")\n///   inspect((1.0 / 0.0).is_neg_inf(), content=\"false\") // positive infinity\n/// }\n/// ```\npub fn Double::is_neg_inf(self : Double) -> Bool {\n  self < min_value\n}\n\n///|\npub impl Hash for Double with hash_combine(self, hasher) {\n  hasher.combine_double(self)\n}\n\n///|\n/// Converts a double-precision floating-point number to its string\n/// representation.\n///\n/// Parameters:\n///\n/// * `self`: The double-precision floating-point number to be converted.\n///\n/// Returns a string representation of the double-precision floating-point\n/// number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42.0.to_string(), content=\"42\")\n///   inspect(3.14159.to_string(), content=\"3.14159\")\n///   inspect((-0.0).to_string(), content=\"0\")\n///   inspect(@double.not_a_number.to_string(), content=\"NaN\")\n/// }\n/// ```\n///\npub fn Double::to_string(self : Double) -> String {\n  @ryu.ryu_to_string(self)\n}\n\n// TODO:\n// #intrinsic(\"%f64.to_string\")\n// impl Show for Double with to_string(self) -> String{\n//   @ryu.ryu_to_string(self)\n// }\n\n///|\npub impl Show for Double with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\n/// Determines whether two floating-point numbers are approximately equal within\n/// specified tolerances.\n/// The implementation follows the algorithm described in PEP 485 for Python's\n/// `math.isclose()`.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n/// * `relative_tolerance` : The relative tolerance for the comparison. Must be\n/// non-negative. Defaults to 1e-9.\n/// * `absolute_tolerance` : The absolute tolerance for the comparison. Must be\n/// non-negative. Defaults to 0.0.\n///\n/// Returns whether the two numbers are considered approximately equal. Returns\n/// `true` if the numbers are exactly equal or if they are within either the\n/// relative or absolute tolerance. Returns `false` if either number is infinite.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1.0\n///   let y = 1.000000001\n///   inspect(x.is_close(y), content=\"false\")\n///   inspect(x.is_close(y, relative_tolerance=1.0e-10), content=\"false\")\n///   inspect(@double.infinity.is_close(@double.infinity), content=\"true\")\n/// }\n/// ```\n#as_free_fn(deprecated)\npub fn Double::is_close(\n  self : Self,\n  other : Self,\n  relative_tolerance? : Self = 1.0e-09,\n  absolute_tolerance? : Self = 0.0,\n) -> Bool {\n  if relative_tolerance < 0.0 || absolute_tolerance < 0.0 {\n    abort(\"Tolerances must be non-negative\")\n  }\n  if self == other {\n    return true\n  }\n  if self.is_inf() || other.is_inf() {\n    return false\n  }\n  let diff = (other - self).abs()\n  return (\n      diff <= (relative_tolerance * other).abs() ||\n      diff <= (relative_tolerance * self).abs()\n    ) ||\n    diff <= absolute_tolerance\n}\n\n///|\n/// Converts a double-precision floating-point number to a sequence of bytes in\n/// big-endian byte order (most significant byte first).\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number to be converted.\n///\n/// Returns a sequence of 8 bytes representing the double-precision\n/// floating-point number in big-endian byte order.\n///\n#deprecated\n#doc(hidden)\npub fn Double::to_be_bytes(self : Double) -> Bytes {\n  self.reinterpret_as_uint64().to_be_bytes()\n}\n\n///|\n/// Converts a double-precision floating-point number to a sequence of bytes in\n/// little-endian order (least significant byte first).\n///\n/// Parameters:\n///\n/// * `self` : A double-precision floating-point number to be converted.\n///\n/// Returns a sequence of 8 bytes representing the double-precision\n/// floating-point number in little-endian order.\n///\n#deprecated\n#doc(hidden)\npub fn Double::to_le_bytes(self : Double) -> Bytes {\n  self.reinterpret_as_uint64().to_le_bytes()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.\n\n///|\nfn pow5bits(e : Int) -> Int {\n  ((e * 1217359).reinterpret_as_uint() >> 19).reinterpret_as_int() + 1\n}\n\n///|\nfn copy_special_str(sign : Bool, exponent : Bool, mantissa : Bool) -> String {\n  if mantissa {\n    return \"NaN\"\n  }\n  let s = if sign { \"-\" } else { \"\" }\n  if exponent {\n    return s + \"Infinity\"\n  }\n  return s + \"0.0\"\n}\n\n// Returns floor(log_10(5^e)); requires 0 <= e <= 2620.\n\n///|\nfn log10Pow5(e : Int) -> Int {\n  ((e * 732923).reinterpret_as_uint() >> 20).reinterpret_as_int()\n}\n\n// Returns floor(log_10(2^e)); requires 0 <= e <= 1650.\n\n///|\nfn log10Pow2(e : Int) -> Int {\n  ((e * 78913).reinterpret_as_uint() >> 18).reinterpret_as_int()\n}\n\n// MoonBit implementation of Ryu, https://github.com/ulfjack/ryu\n// This is a fork of the ryu crate adjusted to comply to the ECMAScript number-to-string algorithm,\n\n///|\nfn string_from_bytes(bytes : FixedArray[Byte], from : Int, to : Int) -> String {\n  let buf = StringBuilder::new(size_hint=bytes.length())\n  for i in from..<to {\n    buf.write_char(bytes[i].to_char())\n  }\n  buf.to_string()\n}\n\n///|\n#valtype\npriv struct Umul128(UInt64, UInt64)\n\n///|\n#valtype\npriv struct Pow5Pair(UInt64, UInt64)\n\n///|\n#valtype\npriv struct MulShiftAll64Result(UInt64, UInt64, UInt64)\n\n///|\nfn umul128(a : UInt64, b : UInt64) -> Umul128 {\n  let aLo = a & 0xffffffff\n  let aHi = a >> 32\n  let bLo = b & 0xffffffff\n  let bHi = b >> 32\n  let x = aLo * bLo\n  let y = aHi * bLo + (x >> 32)\n  let z = aLo * bHi + (y & 0xffffffff)\n  let w = aHi * bHi + (y >> 32) + (z >> 32)\n  let lo = a * b\n  let hi = w\n  Umul128(lo, hi)\n}\n\n///|\nfn shiftright128(lo : UInt64, hi : UInt64, dist : Int) -> UInt64 {\n  (hi << (64 - dist)) | (lo >> dist)\n}\n\n///|\nfn pow5Factor(value : UInt64) -> Int {\n  // We want to find the largest power of 5 that divides value.\n  if value % 5UL != 0UL {\n    return 0\n  }\n  if value % 25UL != 0UL {\n    return 1\n  }\n  if value % 125UL != 0UL {\n    return 2\n  }\n  if value % 625UL != 0UL {\n    return 3\n  }\n  let mut count = 4\n  let mut value = value / 625UL\n  while value > 0UL {\n    if value % 5UL != 0UL {\n      return count\n    }\n    value = value / 5UL\n    count = count + 1\n  }\n  abort(\"IllegalArgumentException \\{value}\")\n}\n\n///|\nfn multipleOfPowerOf5(value : UInt64, p : Int) -> Bool {\n  pow5Factor(value) >= p\n}\n\n///|\nfn multipleOfPowerOf2(value : UInt64, p : Int) -> Bool {\n  (value & ((1UL << p) - 1UL)) == 0UL\n}\n\n///|\nfn mulShiftAll64(\n  m : UInt64,\n  mul : Pow5Pair,\n  j : Int,\n  mmShift : Bool,\n) -> MulShiftAll64Result {\n  let Pow5Pair(mul0, mul1) = mul\n  let m = m << 1\n  let Umul128(lo, tmp) = umul128(m, mul0)\n  let Umul128(lo2, hi2) = umul128(m, mul1)\n  let mid = tmp + lo2\n  let hi = hi2 + (if mid < tmp { 1UL } else { 0UL })\n  let lo2 = lo + mul0\n  let mid2 = mid + mul1 + (if lo2 < lo { 1UL } else { 0UL })\n  let hi2 = hi + (if mid2 < mid { 1UL } else { 0UL })\n  let vp : UInt64 = shiftright128(mid2, hi2, j - 64 - 1)\n  let mut vm : UInt64 = 0UL\n  if mmShift {\n    let lo3 = lo - mul0\n    let mid3 = mid - mul1 - (if lo < lo3 { 1UL } else { 0UL })\n    let hi3 = hi - (if mid < mid3 { 1UL } else { 0UL })\n    vm = shiftright128(mid3, hi3, j - 64 - 1)\n  } else {\n    let lo3 : UInt64 = lo + lo\n    let mid3 : UInt64 = mid + mid + (if lo3 < lo { 1UL } else { 0UL })\n    let hi3 : UInt64 = hi + hi + (if mid3 < mid { 1UL } else { 0UL })\n    let lo4 : UInt64 = lo3 - mul0\n    let mid4 : UInt64 = mid3 - mul1 - (if lo3 < lo4 { 1UL } else { 0UL })\n    let hi4 : UInt64 = hi3 - (if mid3 < mid4 { 1UL } else { 0UL })\n    vm = shiftright128(mid4, hi4, j - 64)\n  }\n  let vr : UInt64 = shiftright128(mid, hi, j - 64 - 1)\n  MulShiftAll64Result(vr, vp, vm)\n}\n\n///|\nlet gPOW5_TABLE_SIZE = 26\n\n///|\nlet gDOUBLE_POW5_INV_SPLIT2 : ReadOnlyArray[UInt64] = [\n  1, 2305843009213693952, 5955668970331000884, 1784059615882449851, 8982663654677661702,\n  1380349269358112757, 7286864317269821294, 2135987035920910082, 7005857020398200553,\n  1652639921975621497, 17965325103354776697, 1278668206209430417, 8928596168509315048,\n  1978643211784836272, 10075671573058298858, 1530901034580419511, 597001226353042382,\n  1184477304306571148, 1527430471115325346, 1832889850782397517, 12533209867169019542,\n  1418129833677084982, 5577825024675947042, 2194449627517475473, 11006974540203867551,\n  1697873161311732311, 10313493231639821582, 1313665730009899186, 12701016819766672773,\n  2032799256770390445,\n]\n\n///|\nlet gPOW5_INV_OFFSETS : ReadOnlyArray[UInt] = [\n  0x54544554, 0x04055545, 0x10041000, 0x00400414, 0x40010000, 0x41155555, 0x00000454,\n  0x00010044, 0x40000000, 0x44000041, 0x50454450, 0x55550054, 0x51655554, 0x40004000,\n  0x01000001, 0x00010500, 0x51515411, 0x05555554, 0x00000000,\n]\n\n///|\nlet gDOUBLE_POW5_SPLIT2 : ReadOnlyArray[UInt64] = [\n  0, 1152921504606846976, 0, 1490116119384765625, 1032610780636961552, 1925929944387235853,\n  7910200175544436838, 1244603055572228341, 16941905809032713930, 1608611746708759036,\n  13024893955298202172, 2079081953128979843, 6607496772837067824, 1343575221513417750,\n  17332926989895652603, 1736530273035216783, 13037379183483547984, 2244412773384604712,\n  1605989338741628675, 1450417759929778918, 9630225068416591280, 1874621017369538693,\n  665883850346957067, 1211445438634777304, 14931890668723713708, 1565756531257009982,\n]\n\n///|\nlet gPOW5_OFFSETS : ReadOnlyArray[UInt] = [\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000000, 0x59695995, 0x55545555,\n  0x56555515, 0x41150504, 0x40555410, 0x44555145, 0x44504540, 0x45555550, 0x40004000,\n  0x96440440, 0x55565565, 0x54454045, 0x40154151, 0x55559155, 0x51405555, 0x00000105,\n]\n\n///|\nlet gDOUBLE_POW5_TABLE : ReadOnlyArray[UInt64] = [\n  1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625, 48828125, 244140625,\n  1220703125, 6103515625, 30517578125, 152587890625, 762939453125, 3814697265625,\n  19073486328125, 95367431640625, 476837158203125, 2384185791015625, 11920928955078125,\n  59604644775390625, 298023223876953125,\n]\n\n///|\n/// Computes 5^i in the form required by Ryū.\nfn double_computePow5(i : Int) -> Pow5Pair {\n  let base = i / gPOW5_TABLE_SIZE\n  let base2 = base * gPOW5_TABLE_SIZE\n  let offset = i - base2\n  let mul0 = gDOUBLE_POW5_SPLIT2[base * 2]\n  let mul1 = gDOUBLE_POW5_SPLIT2[base * 2 + 1]\n  if offset == 0 {\n    return Pow5Pair(mul0, mul1)\n  }\n  let m : UInt64 = gDOUBLE_POW5_TABLE[offset]\n  let Umul128(low1, high1) = umul128(m, mul1)\n  let Umul128(low0, high0) = umul128(m, mul0)\n  let sum : UInt64 = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1UL\n  }\n  let delta : Int = pow5bits(i) - pow5bits(base2)\n  let a : UInt64 = shiftright128(low0, sum, delta) +\n    ((gPOW5_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3).to_uint64()\n  let b : UInt64 = shiftright128(sum, high1, delta)\n  Pow5Pair(a, b)\n}\n\n///|\n/// Computes 5^-i in the form required by Ryū.\nfn double_computeInvPow5(i : Int) -> Pow5Pair {\n  let base = (i + gPOW5_TABLE_SIZE - 1) / gPOW5_TABLE_SIZE\n  let base2 = base * gPOW5_TABLE_SIZE\n  let offset = base2 - i\n  let mul0 = gDOUBLE_POW5_INV_SPLIT2[base * 2]\n  let mul1 = gDOUBLE_POW5_INV_SPLIT2[base * 2 + 1]\n  if offset == 0 {\n    return Pow5Pair(mul0, mul1)\n  }\n  let m = gDOUBLE_POW5_TABLE[offset]\n  let Umul128(low1, high1) = umul128(m, mul1)\n  let Umul128(low0, high0) = umul128(m, mul0)\n  let sum = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1UL\n  }\n  let delta : Int = pow5bits(base2) - pow5bits(i)\n  let a : UInt64 = shiftright128(low0, sum, delta) +\n    1UL +\n    ((gPOW5_INV_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3).to_uint64()\n  let b : UInt64 = shiftright128(sum, high1, delta)\n  Pow5Pair(a, b)\n}\n\n///|\nlet gDOUBLE_MANTISSA_BITS : Int = 52\n\n///|\nlet gDOUBLE_EXPONENT_BITS : Int = 11\n\n///|\nlet gDOUBLE_BIAS : Int = 1023\n\n///|\nlet gDOUBLE_POW5_INV_BITCOUNT : Int = 125\n\n///|\nlet gDOUBLE_POW5_BITCOUNT : Int = 125\n\n///|\nfn decimal_length17(v : UInt64) -> Int {\n  // This is slightly faster than a loop.\n  // The average output length is 16.38 digits, so we check high-to-low.\n  // Function precondition: v is not an 18, 19, or 20-digit number.\n  // (17 digits are sufficient for round-tripping.)\n  if v >= 10000000000000000 {\n    return 17\n  }\n  if v >= 1000000000000000 {\n    return 16\n  }\n  if v >= 100000000000000 {\n    return 15\n  }\n  if v >= 10000000000000 {\n    return 14\n  }\n  if v >= 1000000000000 {\n    return 13\n  }\n  if v >= 100000000000 {\n    return 12\n  }\n  if v >= 10000000000 {\n    return 11\n  }\n  if v >= 1000000000 {\n    return 10\n  }\n  if v >= 100000000 {\n    return 9\n  }\n  if v >= 10000000 {\n    return 8\n  }\n  if v >= 1000000 {\n    return 7\n  }\n  if v >= 100000 {\n    return 6\n  }\n  if v >= 10000 {\n    return 5\n  }\n  if v >= 1000 {\n    return 4\n  }\n  if v >= 100 {\n    return 3\n  }\n  if v >= 10 {\n    return 2\n  }\n  return 1\n}\n\n// A floating decimal representing m * 10^e.\n\n///|\npriv struct FloatingDecimal64 {\n  mantissa : UInt64\n  // Decimal exponent's range is -324 to 308\n  // inclusive, and can fit in a short if needed.\n  exponent : Int\n}\n\n///|\nfn d2d(ieeeMantissa : UInt64, ieeeExponent : UInt) -> FloatingDecimal64 {\n  let mut e2 : Int = 0\n  let mut m2 : UInt64 = 0\n  if ieeeExponent == 0 {\n    // Denormal number - no implicit leading 1, and the exponent is 1, not 0.\n    e2 = 1 - gDOUBLE_BIAS - gDOUBLE_MANTISSA_BITS - 2\n    m2 = ieeeMantissa\n  } else {\n    // Add implicit leading 1.\n    e2 = ieeeExponent.reinterpret_as_int() -\n      gDOUBLE_BIAS -\n      gDOUBLE_MANTISSA_BITS -\n      2\n    m2 = (1UL << gDOUBLE_MANTISSA_BITS) | ieeeMantissa\n  }\n  let even = (m2 & 1UL) == 0UL\n  let mv = 4UL *\n\n    // Step 2: Determine the interval of valid decimal representations.\n    m2\n  // Implicit bool -> int conversion. True is 1, false is 0.\n  let mmShift = ieeeMantissa != 0UL || ieeeExponent <= 1\n  // We would compute mp and mm like this:\n  // uint64_t mp = 4 * m2 + 2;\n  // uint64_t mm = mv - 1 - mmShift;\n\n  // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n  let mut vr = 0UL\n  let mut vp = 0UL\n  let mut vm = 0UL\n  let mut e10 : Int = 0\n  let mut vmIsTrailingZeros = false\n  let mut vrIsTrailingZeros = false\n  if e2 >= 0 {\n    // I tried special-casing q == 0, but there was no effect on performance.\n    // This expression is slightly faster than max(0, log10Pow2(e2) - 1).\n    let q : Int = log10Pow2(e2) - (e2 > 3).to_int()\n    e10 = q\n    let k = gDOUBLE_POW5_INV_BITCOUNT + pow5bits(q) - 1\n    let i = -e2 + q + k\n    let pow5 : Pow5Pair = double_computeInvPow5(q)\n    let MulShiftAll64Result(vrOut, vpOut, vmOut) = mulShiftAll64(\n      m2, pow5, i, mmShift,\n    )\n    vr = vrOut\n    vp = vpOut\n    vm = vmOut\n    if q <= 21 {\n      // This should use q <= 22, but I think 21 is also safe. Smaller values\n      // may still be safe, but it's more difficult to reason about them.\n      // Only one of mp, mv, and mm can be a multiple of 5, if any.\n      let mvMod5 : Int = mv.to_int() - 5 * (mv / 5UL).to_int()\n      if mvMod5 == 0 {\n        vrIsTrailingZeros = multipleOfPowerOf5(mv, q)\n      } else if even {\n        // Same as min(e2 + (~mm & 1), pow5Factor(mm)) >= q\n        // <=> e2 + (~mm & 1) >= q && pow5Factor(mm) >= q\n        // <=> true && pow5Factor(mm) >= q, since e2 >= q.\n        vmIsTrailingZeros = multipleOfPowerOf5(\n          mv - 1UL - mmShift.to_uint64(),\n          q,\n        )\n      } else {\n        vp = vp - multipleOfPowerOf5(mv + 2UL, q).to_uint64()\n      }\n    }\n  } else {\n    // This expression is slightly faster than max(0, log10Pow5(-e2) - 1).\n    let q : Int = log10Pow5(-e2) - (-e2 > 1).to_int()\n    e10 = q + e2\n    let i : Int = -e2 - q\n    let k = pow5bits(i) - gDOUBLE_POW5_BITCOUNT\n    let j = q - k\n    let pow5 : Pow5Pair = double_computePow5(i)\n    let MulShiftAll64Result(vrOut, vpOut, vmOut) = mulShiftAll64(\n      m2, pow5, j, mmShift,\n    )\n    vr = vrOut\n    vp = vpOut\n    vm = vmOut\n    if q <= 1 {\n      // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n      // mv = 4 * m2, so it always has at least two trailing 0 bits.\n      vrIsTrailingZeros = true\n      if even {\n        vmIsTrailingZeros = mmShift.to_int() == 1\n      } else {\n        vp = vp - 1\n      }\n    } else if q < 63 {\n      vrIsTrailingZeros = multipleOfPowerOf2(mv, q)\n    }\n  }\n\n  // Step 4: Find the shortest decimal representation in the interval of valid representations.\n  let mut removed : Int = 0\n  let mut lastRemovedDigit : Int = 0\n  let mut output : UInt64 = 0UL\n  // On average, we remove ~2 digits.\n  if vmIsTrailingZeros || vrIsTrailingZeros {\n    // General case, which happens rarely (~0.7%).\n    while true {\n      let vpDiv10 = vp / 10\n      let vmDiv10 = vm / 10\n      if vpDiv10 <= vmDiv10 {\n        break\n      }\n      let vmMod10 : Int = vm.to_int() - 10 * vmDiv10.to_int()\n      let vrDiv10 = vr / 10\n      let vrMod10 : Int = vr.to_int() - 10 * vrDiv10.to_int()\n      vmIsTrailingZeros = vmIsTrailingZeros && vmMod10 == 0\n      vrIsTrailingZeros = vrIsTrailingZeros && lastRemovedDigit == 0\n      lastRemovedDigit = vrMod10\n      vr = vrDiv10\n      vp = vpDiv10\n      vm = vmDiv10\n      removed = removed + 1\n    }\n    if vmIsTrailingZeros {\n      while true {\n        let vmDiv10 = vm / 10\n        let vmMod10 : Int = vm.to_int() - 10 * vmDiv10.to_int()\n        if vmMod10 != 0 {\n          break\n        }\n        let vpDiv10 = vp / 10\n        let vrDiv10 = vr / 10\n        let vrMod10 : Int = vr.to_int() - 10 * vrDiv10.to_int()\n        vrIsTrailingZeros = vrIsTrailingZeros && lastRemovedDigit == 0\n        lastRemovedDigit = vrMod10\n        vr = vrDiv10\n        vp = vpDiv10\n        vm = vmDiv10\n        removed = removed + 1\n      }\n    }\n    if vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0 {\n      lastRemovedDigit = 4\n    }\n    output = vr +\n      ((vr == vm && (!even || !vmIsTrailingZeros)) || lastRemovedDigit >= 5)\n      .to_int64()\n      .reinterpret_as_uint64()\n  } else {\n    // Specialized for the common case (~99.3%). Percentages below are relative to this.\n    let mut roundUp = false\n    let vpDiv100 = vp / 100\n    let vmDiv100 = vm / 100\n    if vpDiv100 > vmDiv100 {\n      let vrDiv100 = vr / 100\n      let vrMod100 : Int = vr.to_int() - 100 * vrDiv100.to_int()\n      roundUp = vrMod100 >= 50\n      vr = vrDiv100\n      vp = vpDiv100\n      vm = vmDiv100\n      removed = removed + 2\n    }\n    // Loop iterations below (approximately), without optimization above:\n    // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n    // Loop iterations below (approximately), with optimization above:\n    // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n    while true {\n      let vpDiv10 = vp / 10\n      let vmDiv10 = vm / 10\n      if vpDiv10 <= vmDiv10 {\n        break\n      }\n      let vrDiv10 = vr / 10\n      let vrMod10 : Int = vr.to_int() - 10 * vrDiv10.to_int()\n      roundUp = vrMod10 >= 5\n      vr = vrDiv10\n      vp = vpDiv10\n      vm = vmDiv10\n      removed = removed + 1\n    }\n    output = vr + (vr == vm || roundUp).to_uint64()\n  }\n  let exp : Int = e10 + removed\n  let fd : FloatingDecimal64 = { mantissa: output, exponent: exp }\n  fd\n}\n\n///|\nfn to_chars(v : FloatingDecimal64, sign : Bool) -> String {\n  // Step 5: Print the decimal representation.\n  let result = FixedArray::make(25, Byte::default())\n  let mut index : Int = 0\n  if sign {\n    result[index] = b'-'\n    index += 1\n  }\n  let mut output = v.mantissa\n  let olength = decimal_length17(output)\n  let mut exp : Int = v.exponent + olength - 1\n  let scientificNotation = !(exp >= -6 && exp < 21)\n  if scientificNotation {\n    // Print the decimal digits.\n    for i in 0..<(olength - 1) {\n      let c = output % 10\n      output /= 10\n      // 48 is ASCII '0', the same applies below.\n      result[index + olength - i] = (48 + c.to_int()).to_byte()\n    }\n    result[index] = (48 + output.to_int() % 10).to_byte()\n    if olength > 1 {\n      result[index + 1] = b'.'\n    } else {\n      // If there are no decimals, suppress .0\n      index -= 1\n    }\n    index += olength + 1\n\n    // Print the exponent.\n    result[index] = b'e'\n    index += 1\n    if exp < 0 {\n      result[index] = b'-'\n      index += 1\n      exp = -exp\n    } else {\n      result[index] = b'+'\n      index += 1\n    }\n    if exp >= 100 {\n      let a = exp / 100\n      let b = exp / 10 % 10\n      let c = exp % 10\n      result[index + 0] = (48 + a).to_byte()\n      result[index + 1] = (48 + b).to_byte()\n      result[index + 2] = (48 + c).to_byte()\n      index += 3\n    } else if exp >= 10 {\n      let a = exp / 10\n      let b = exp % 10\n      result[index + 0] = (48 + a).to_byte()\n      result[index + 1] = (48 + b).to_byte()\n      index += 2\n    } else {\n      result[index] = (48 + exp).to_byte()\n      index += 1\n    }\n    string_from_bytes(result, 0, index)\n  } else {\n    // Otherwise follow the ECMAScript spec.\n    if exp < 0 {\n      // Decimal dot is before any of the digits.\n      result[index] = b'0'\n      index += 1\n      result[index] = b'.'\n      index += 1\n      for i = -1; i > exp; i = i - 1 {\n        result[index] = b'0'\n        index += 1\n      }\n      let current = index\n      for i in 0..<olength {\n        result[current + olength - i - 1] = (48 + (output % 10).to_int()).to_byte()\n        output /= 10\n        index += 1\n      }\n    } else if exp + 1 >= olength {\n      // Decimal dot is after any of the digits.\n      for i in 0..<olength {\n        result[index + olength - i - 1] = (48 + (output % 10).to_int()).to_byte()\n        output /= 10\n      }\n      index += olength\n      for i in olength..<(exp + 1) {\n        result[index] = b'0'\n        index += 1\n      }\n    } else {\n      // Decimal dot is somewhere between the digits.\n      let mut current = index + 1\n      for i in 0..<olength {\n        if olength - i - 1 == exp {\n          result[current + olength - i - 1] = b'.'\n          current -= 1\n        }\n        result[current + olength - i - 1] = (48 + (output % 10).to_int()).to_byte()\n        output /= 10\n      }\n      index += olength + 1\n    }\n    return string_from_bytes(result, 0, index)\n  }\n}\n\n///|\nfn d2d_small_int(\n  ieeeMantissa : UInt64,\n  ieeeExponent : Int,\n) -> FloatingDecimal64? {\n  let m2 : UInt64 = (1UL << gDOUBLE_MANTISSA_BITS) | ieeeMantissa\n  let e2 : Int = ieeeExponent - gDOUBLE_BIAS - gDOUBLE_MANTISSA_BITS\n  if e2 > 0 {\n    return None\n  }\n  if e2 < -52 {\n    return None\n  }\n  let mask : UInt64 = (1UL << -e2) - 1UL\n  let fraction : UInt64 = m2 & mask\n  if fraction != 0UL {\n    return None\n  }\n  Some({ mantissa: m2 >> -e2, exponent: 0 })\n}\n\n///|\n/// TODO: ryu_to_logger[T:Logger](Double/Float, T) -> Unit\npub fn ryu_to_string(val : Double) -> String {\n  if val == 0.0 {\n    return \"0\"\n  }\n  // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.\n  let bits : UInt64 = val.reinterpret_as_uint64()\n\n  // Decode bits into sign, mantissa, and exponent.\n  let ieeeSign = (\n      (bits >> (gDOUBLE_MANTISSA_BITS + gDOUBLE_EXPONENT_BITS)) & 1UL\n    ) !=\n    0UL\n  let ieeeMantissa : UInt64 = bits & ((1UL << gDOUBLE_MANTISSA_BITS) - 1UL)\n  let ieeeExponent : Int = ((bits >> gDOUBLE_MANTISSA_BITS) &\n  ((1UL << gDOUBLE_EXPONENT_BITS) - 1UL)).to_int()\n  if ieeeExponent == (1 << gDOUBLE_EXPONENT_BITS) - 1 ||\n    (ieeeExponent == 0 && ieeeMantissa == 0UL) {\n    return copy_special_str(ieeeSign, ieeeExponent != 0, ieeeMantissa != 0UL)\n  }\n  let mut v : FloatingDecimal64 = { mantissa: 0UL, exponent: 0 }\n  let small = d2d_small_int(ieeeMantissa, ieeeExponent)\n  match small {\n    Some(f) => {\n      let mut x = f\n      while true {\n        let q : UInt64 = x.mantissa / 10\n        let r = x.mantissa - 10UL * q\n        if r != 0 {\n          break\n        }\n        x = { mantissa: q, exponent: x.exponent + 1 }\n      }\n      v = x\n    }\n    None => v = d2d(ieeeMantissa, ieeeExponent.reinterpret_as_uint())\n  }\n  to_chars(v, ieeeSign)\n}\n\n///|\ntest \"double/ryu.mbt:205\" {\n  let m = 123456789UL\n  let mul0 = 987654321UL\n  let Umul128(_, high0) = umul128(m, mul0)\n  let low1 = 111111111UL\n  let high1 = 222222222UL\n  let sum = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1\n  }\n  inspect(high1, content=\"222222222\")\n}\n\n///|\ntest \"double/ryu.mbt:230\" {\n  let m = 123456789UL\n  let mul0 = 987654321UL\n  let Umul128(_, high0) = umul128(m, mul0)\n  let low1 = 111111111UL\n  let high1 = 222222222UL\n  let sum = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1UL\n  }\n  assert_eq(high1, 222222222UL)\n}\n\n///|\ntest \"double/ryu.mbt:252\" {\n  inspect(gDOUBLE_POW5_BITCOUNT, content=\"125\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// }\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// }\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Creates a new array of the specified length, where each element is\n/// initialized using an index-based initialization function.\n///\n/// Parameters:\n///\n/// * `length` : The length of the new array. If `length` is less than or equal\n/// to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (starting from 0) and\n/// returns a value of type `T`. This function is called for each index to\n/// initialize the corresponding element.\n///\n/// Returns a new array of type `Array[T]` with the specified length, where each\n/// element is initialized using the provided function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::makei(3, i => i * 2)\n///   inspect(arr, content=\"[0, 2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::makei(length : Int, f : (Int) -> T raise?) -> Array[T] raise? {\n  if length <= 0 {\n    []\n  } else {\n    let array = Array::make_uninit(length)\n    for i in 0..<length {\n      array.unsafe_set(i, f(i))\n    }\n    array\n  }\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.get\")\n#alias(\"_[_]\")\npub fn[T] Array::at(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// }\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\npub fn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.set\")\n#alias(\"_[_]=_\")\npub fn[T] Array::set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// }\n/// ```\npub impl[T : Eq] Eq for Array[T] with equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// }\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// }\n/// ```\npub impl[T] Add for Array[T] with add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[T] Array::append(self : Array[T], other : ArrayView[T]) -> Unit {\n  other.blit_to(self, dst_offset=self.length())\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each(x => sum = sum - x)\n///   @json.inspect(sum, content=-12)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => sum = sum + x + i)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks whether all elements satisfy the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.all(x => x < 6))\n///   assert_false(arr.all(x => x < 5))\n/// }\n/// ```\n#alias(every)\npub fn[T] Array::all(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].all(f)\n}\n\n///|\n/// Checks whether any element satisfies the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.any(x => x < 6))\n///   assert_false(arr.any(x => x < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] Array::any(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].any(f)\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// }\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.map(x => x + 1)\n///   assert_eq(v2, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.map_in_place(x => x + 1)\n///   assert_eq(v, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\n#alias(map_inplace, deprecated)\npub fn[T] Array::map_in_place(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => x + i)\n///   assert_eq(v2, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.mapi_in_place((i, x) => x + i)\n///   assert_eq(v, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\n#alias(mapi_inplace, deprecated)\npub fn[T] Array::mapi_in_place(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter(x => x % 2 == 0)\n///   inspect(evens, content=\"[2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///   let arr : Array[Int] = []\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n#alias(rev_inplace, deprecated)\npub fn[T] Array::rev_in_place(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// }\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let (v1, v2) = (v[:1], v[1:])\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// }\n/// ```\n#deprecated(\"Use ArrayView instead, e.g, (a[:index], a[index:])\")\n#doc(hidden)\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  self[:].starts_with(prefix[:])\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  self[:].ends_with(suffix[:])\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// }\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// }\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  self[:].search(value)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by(x => x == 3) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// }\n/// ```\n#locals(f)\n#alias(find_index, deprecated)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// }\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  self[:].binary_search(value)\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by(x => x.compare(3))\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by(x => x.compare(4))\n///   inspect(find_4, content=\"Err(2)\")\n/// }\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self[:].binary_search_by(cmp)\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// }\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain(x => x % 2 == 0)\n///   inspect(arr, content=\"[2, 4]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(x => x > 10)\n///   inspect(arr, content=\"[]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// }\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens an array of arrays into an array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create an array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// }\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_left, deprecated)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_right, deprecated)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_lefti, deprecated)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_righti, deprecated)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if(x => x % 2 == 0)\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let removed = []\n  let mut write = 0\n  for read in 0..<self.length() {\n    let elem = self[read]\n    if f(elem) {\n      removed.push(elem)\n    } else {\n      if read != write {\n        self[write] = elem\n      }\n      write += 1\n    }\n  }\n  self.truncate(write)\n  removed\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length()\n  if len == 0 {\n    return []\n  }\n  let num_chunks = (len + size - 1) / size\n  Array::makei(num_chunks, i => {\n    let start = i * size\n    let end = Int::min(start + size, len)\n    self[start:end]\n  })\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => x <= y)\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => x <= y), content=\"[]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[ArrayView[T]] raise? {\n  let chunks = []\n  if self.is_empty() {\n    return chunks\n  }\n  let mut start = 0\n  for i in 1..<self.length() {\n    if !pred(self[i - 1], self[i]) {\n      chunks.push(self[start:i])\n      start = i\n    }\n  }\n  chunks.push(self[start:self.length()])\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  Array::makei(len, i => self[i:i + size])\n}\n\n///|\npub fn[T] Array::suffixes(\n  self : Array[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split(x => x == 0), content=\"[[1], [2], [3], [4]]\")\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split(x => x == 0), content=\"[[], [1], [], [2]]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  self[:].iter()\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each(x => result.push(x))\n///   inspect(result, content=\"[3, 2, 1]\")\n/// }\n/// ```\n#alias(rev_iterator, deprecated)\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  self[:].rev_iter()\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => sum = sum + i + x)\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  self[:].iter2()\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// }\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// }\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\n#doc(hidden)\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.truncate(3)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain_map(fn(x) { if x % 2 == 0 { Some(x * 2) } else { None } })\n///   inspect(arr, content=\"[4, 8]\")\n/// }\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(42)\n///   let arr = Array::from_iter(iter)\n///   inspect(arr, content=\"[42]\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] Array::from_iter(iter : Iter[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Adds all elements from an iterator to the end of the array.\n///\n/// This function iterates over each element in the provided iterator\n/// and adds them to the array using the `push` method.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let u = [1, 2, 3]\n///   let v = [4, 5, 6]\n///   u.push_iter(v.iter())\n///   assert_eq(u, [1, 2, 3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::push_iter(self : Self[T], iter : Iter[T]) -> Unit {\n  // This function used by [Array spread operator](https://docs.moonbitlang.com/en/latest/language/fundamentals.html#spread-operator)\n  // it can't be removed and deprecated\n  for x in iter {\n    self.push(x)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt check\n/// test {\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// Array::shuffle_in_place(arr, rand~)\n/// }\n/// ```\npub fn[T] Array::shuffle_in_place(\n  self : Array[T],\n  rand~ : (Int) -> Int,\n) -> Unit {\n  let n = self.length()\n  for i = n - 1; i > 0; i = i - 1 {\n    let j = rand(i + 1) % (i + 1)\n    // for safety, perf is not a concern here\n    // TODO: maybe return an error later\n    self.swap(i, j)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt\n/// let arr = [1, 2, 3, 4, 5]\n///\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// let _shuffled = Array::shuffle(arr, rand~)\n/// ```\npub fn[T] Array::shuffle(self : Array[T], rand~ : (Int) -> Int) -> Array[T] {\n  let new_arr = self.copy()\n  Array::shuffle_in_place(new_arr, rand~)\n  new_arr\n}\n\n///|\n/// Returns a new array containing the elements of the original array that satisfy the given predicate.\n///\n/// # Arguments\n///\n/// * `self` - The array to filter.\n/// * `f` - The predicate function.\n///\n/// # Returns\n///\npub fn[A, B] Array::filter_map(\n  self : Array[A],\n  f : (A) -> B? raise?,\n) -> Array[B] raise? {\n  let result = []\n  for x in self {\n    if f(x) is Some(x) {\n      result.push(x)\n    }\n  }\n  result\n}\n\n///|\n/// Returns the last element of the array, or `None` if the array is empty.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the last element from.\n///\n/// Returns an optional value containing the last element of the array. The\n/// result is `None` if the array is empty, or `Some(x)` where `x` is the last\n/// element of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.last(), content=\"Some(3)\")\n///   let empty : Array[Int] = []\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[A] Array::last(self : Array[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\n/// Zips two arrays into a single array of tuples.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an array of tuples, where each tuple contains corresponding elements\n/// from the two input arrays.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(arr1.zip(arr2), content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\")\n/// }\n/// ```\npub fn[A, B] Array::zip(self : Array[A], other : Array[B]) -> Array[(A, B)] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  Array::makei(length, i => (self[i], other[i]))\n}\n\n///|\n/// Splits an array of pairs into two arrays, separating the first and second elements.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n///   let (nums, strs) = arr.unzip()\n///   inspect(nums, content=\"[1, 2, 3]\")\n///   inspect(strs, content=\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\")\n/// }\n/// ```\npub fn[T1, T2] Array::unzip(self : Array[(T1, T2)]) -> (Array[T1], Array[T2]) {\n  let arr1 : Array[T1] = Array::new(capacity=self.length())\n  let arr2 : Array[T2] = Array::new(capacity=self.length())\n  for pair in self {\n    let (x, y) = pair\n    arr1.push(x)\n    arr2.push(y)\n  }\n  (arr1, arr2)\n}\n\n///|\n/// Zips two arrays into an iterator that yields corresponding elements.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an `Iter2` iterator that produces corresponding elements\n/// from both arrays. The iteration continues until the shorter array is exhausted.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(\n///     arr1.zip_to_iter2(arr2).to_array(),\n///     content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\",\n///   )\n/// }\n/// ```\npub fn[A, B] Array::zip_to_iter2(\n  self : Array[A],\n  other : Array[B],\n) -> Iter2[A, B] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  let mut i = 0\n  Iter2::new(() => {\n    guard i < length else { None }\n    let elem = (self[i], other[i])\n    i += 1\n    Some(elem)\n  }).iter2()\n}\n\n///|\n/// Join an array of strings using the provided `separator`.\n///\n/// Parameters:\n///   * `separator` : The string inserted between each element.\n///\n/// Returns a single concatenated `String`.\n/// # Example:\n/// ```mbt check\n/// test {\n///   let s = \"hello world\"\n///   inspect(s.split(\" \").to_array().join(\":\"), content=\"hello:world\")\n/// }\n/// ```\npub fn[A : ToStringView] Array::join(\n  self : Array[A],\n  separator : StringView,\n) -> String {\n  self[:].join(separator)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] UninitializedArray::set_null(self : UninitializedArray[T], index : Int) = \"%fixedarray.set_null\"\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\nstruct Array[T] {\n  mut buf : UninitializedArray[T]\n  mut len : Int\n}\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] {\n  { buf: UninitializedArray::make(len), len }\n}\n\n///|\n/// Creates a new empty array with an optional initial capacity.\n///\n/// Parameters:\n///\n/// * `capacity` : The initial capacity of the array. If 0 (default), creates an\n/// array with minimum capacity. Must be non-negative.\n///\n/// Returns a new empty array of type `Array[T]` with the specified initial\n/// capacity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::new(capacity=10)\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.capacity(), content=\"10\")\n///   let arr : Array[Int] = Array::new()\n///   inspect(arr.length(), content=\"0\")\n/// }\n/// ```\npub fn[T] Array::new(capacity? : Int = 0) -> Array[T] {\n  if capacity == 0 {\n    []\n  } else {\n    { buf: UninitializedArray::make(capacity), len: 0 }\n  }\n}\n\n///|\n/// Returns the number of elements in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array whose length is to be determined.\n///\n/// Returns the number of elements in the array as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.length(), content=\"3\")\n///   let empty : Array[Int] = []\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\n#intrinsic(\"%array.length\")\npub fn[T] Array::length(self : Array[T]) -> Int {\n  self.len\n}\n\n///|\n/// Truncates the array to the specified length. This function is marked as\n/// `unsafe` because it directly manipulates the internal buffer of the array,\n/// which can lead to undefined behavior if not used carefully.\n///\n/// # Parameters\n///\n/// - `self` : The array to be truncated.\n/// - `new_len` : The new length to which the array should be truncated. Must be\n/// less than or equal to the current length of the array.\n///\n/// # Returns\n///\n/// - `Unit` : This function does not return a value.\n///\n/// # Errors\n///\n/// - This function does not explicitly raise errors, but improper use (e.g.,\n/// setting `new_len` greater than the current length) can lead to undefined\n/// behavior.\n///\n/// TODO: this can be optimized by using the intrinsic to null out the range\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  let len = self.length()\n  guard new_len <= len\n  for i in new_len..<len {\n    self.buf.set_null(i)\n  }\n  self.len = new_len\n}\n\n///|\ntest \"unsafe_truncate_to_length\" {\n  let arr = [1, 2, 3, 4, 5]\n  arr.unsafe_truncate_to_length(3)\n  inspect(arr, content=\"[1, 2, 3]\")\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] {\n  self.buf\n}\n\n///|\nfn[T] Array::resize_buffer(self : Array[T], new_capacity : Int) -> Unit {\n  let new_buf = UninitializedArray::make(new_capacity)\n  let old_buf = self.buf\n  let old_cap = old_buf.0.length()\n  let copy_len = if old_cap < new_capacity { old_cap } else { new_capacity }\n  UninitializedArray::unsafe_blit(new_buf, 0, old_buf, 0, copy_len)\n  self.buf = new_buf\n}\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"Array::resize_buffer\" {\n  let arr = Array::new(capacity=2)\n  arr.push(1)\n  arr.push(2)\n  arr.resize_buffer(4)\n  assert_eq(arr.buffer().0.length() >= 4, true)\n  arr.push(3)\n  arr.push(4)\n  assert_eq(arr.length(), 4)\n  assert_eq(arr[0], 1)\n  assert_eq(arr[1], 2)\n  assert_eq(arr[2], 3)\n  assert_eq(arr[3], 4)\n}\n\n///|\n/// Reallocate the array with a new capacity.\nfn[T] Array::realloc(self : Array[T]) -> Unit {\n  let old_cap = self.length()\n  let new_cap = if old_cap == 0 { 8 } else { old_cap * 2 }\n  self.resize_buffer(new_cap)\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 10)\n/// }\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  if self.capacity() >= capacity {\n    return\n  }\n  self.resize_buffer(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// }\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  if self.capacity() <= self.length() {\n    return\n  }\n  self.resize_buffer(self.length())\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = []\n///   v.push(3)\n/// }\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  let length = self.length()\n  self.unsafe_set(length, value)\n  self.len = length + 1\n}\n\n///|\n/// Removes the last element from an array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3]\n///   assert_eq(v.pop(), Some(3))\n///   assert_eq(v, [1, 2])\n/// }\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    let index = len - 1\n    let v = self.unsafe_get(index)\n    self.buf.set_null(index)\n    self.len = index\n    Some(v)\n  }\n}\n\n///|\n/// Removes and returns the last element from the array.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to remove and return the last element.\n///\n/// Returns the last element of the array before removal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_pop(), content=\"3\")\n///   inspect(arr, content=\"[1, 2]\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if the array is empty.\")\n#doc(hidden)\n#alias(pop_exn, deprecated)\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  let len = self.length()\n  guard len != 0\n  let index = len - 1\n  let v = self.unsafe_get(index)\n  self.buf.set_null(index)\n  self.len = index\n  v\n}\n\n///|\n/// Removes and returns the element at position index within the array, \n/// shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   assert_eq(v.remove(1), 4)\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.unsafe_get(index)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index,\n    self.buffer(),\n    index + 1,\n    self.length() - index - 1,\n  )\n  self.unsafe_truncate_to_length(self.length() - 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns an array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end\n  let num = end - begin\n  let v = Array::make_uninit(num)\n  UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), begin, num)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    begin,\n    self.buffer(),\n    end,\n    self.length() - end,\n  )\n  self.unsafe_truncate_to_length(self.length() - num)\n  v\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   a.insert(1, 4)\n///   inspect(a, content=\"[1, 4, 2, 3]\")\n///   let b = [1, 2, 3]\n///   b.insert(0, 5)\n///   inspect(b, content=\"[5, 1, 2, 3]\")\n///   let c = [1, 2, 3]\n///   c.insert(3, 6)\n///   inspect(c, content=\"[1, 2, 3, 6]\")\n/// }\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index + 1,\n    self.buffer(),\n    index,\n    self.length() - index,\n  )\n  let length = self.length()\n  self.unsafe_set(index, value)\n  self.len = length + 1\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitialized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  let new_buf = UninitializedArray::make(new_len)\n  UninitializedArray::unsafe_blit(new_buf, 0, self.buf, 0, self.len)\n  self.len = new_len\n  self.buf = new_buf\n}\n\n///|\n/// Fills an Array with a specified value.\n/// \n/// This method fills all or part of an Array with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```mbt check\n/// test {\n///   // Fill entire array\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.fill(0)\n///   inspect(arr, content=\"[0, 0, 0, 0, 0]\")\n///\n///   // Fill from index 1 to 3 (exclusive)\n///   let arr2 = [1, 2, 3, 4, 5]\n///   arr2.fill(99, start=1, end=3)\n///   inspect(arr2, content=\"[1, 99, 99, 4, 5]\")\n///\n///   // Fill from index 2 to end\n///   let arr3 = [\"a\", \"b\", \"c\", \"d\"]\n///   arr3.fill(\"x\", start=2)\n///   inspect(\n///     arr3,\n///     content=(\n///       #|[\"a\", \"b\", \"x\", \"x\"]\n///     ),\n///   )\n/// }\n/// ```\npub fn[A] Array::fill(\n  self : Array[A],\n  value : A,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let length = match end {\n    None => array_length\n    Some(e) => {\n      guard e >= start && e <= array_length\n      e\n    }\n  }\n  self.buf.unchecked_fill(start, value, length - start)\n}\n\n///|\n/// Creates and returns a new array with a copy of all elements from the input\n/// array.\n///\n/// Parameters:\n///\n/// * `array` : The array to be copied.\n///\n/// Returns a new array containing all elements from the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let original = [1, 2, 3]\n///   let copied = original.copy()\n///   inspect(copied, content=\"[1, 2, 3]\")\n///   inspect(physical_equal(original, copied), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::copy(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    Array::unsafe_blit(arr, 0, self, 0, len)\n    arr\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Copies elements from one array to another array. Works correctly even when\n/// the source and destination arrays overlap.\n///\n/// Parameters:\n///\n/// * `dst` : The destination array where elements will be copied to.\n/// * `dst_offset` : The starting index in the destination array where elements\n/// should be copied.\n/// * `src` : The source array from which elements will be copied.\n/// * `src_offset` : The starting index in the source array from which elements\n/// should be copied.\n/// * `len` : The number of elements to copy.\n///\n/// The behavior is undefined if any of the following conditions are met:\n///\n/// * `len` is negative\n/// * `dst_offset` is negative\n/// * `src_offset` is negative\n/// * `dst_offset + len` exceeds the length of destination array\n/// * `src_offset + len` exceeds the length of source array\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = [1, 2, 3, 4, 5]\n///   let dst = [0, 0, 0, 0, 0]\n///   Array::unsafe_blit(dst, 1, src, 2, 2)\n///   inspect(dst, content=\"[0, 3, 4, 0, 0]\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if the indices or length are out of bounds\")\n#doc(hidden)\npub fn[A] Array::unsafe_blit(\n  dst : Array[A],\n  dst_offset : Int,\n  src : Array[A],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(\n    dst.buffer().0,\n    dst_offset,\n    src.buffer().0,\n    src_offset,\n    len,\n  )\n}\n\n///|\n/// Copies elements from a fixed-size array to a dynamic array. The arrays may\n/// overlap, in which case the copy is performed in a way that preserves the\n/// data.\n///\n/// Parameters:\n///\n/// * `dst` : The destination dynamic array where elements will be copied to.\n/// * `dst_offset` : The starting index in the destination array where copying\n/// begins.\n/// * `src` : The source fixed-size array from which elements will be copied.\n/// * `src_offset` : The starting index in the source array from which copying\n/// begins.\n/// * `len` : The number of elements to copy.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = FixedArray::make(5, 0)\n///   let dst = Array::make(5, 0)\n///   for i in 0..<5 {\n///     src[i] = i + 1\n///   }\n///   Array::unsafe_blit_fixed(dst, 1, src, 0, 2)\n///   inspect(dst, content=\"[0, 1, 2, 0, 0]\")\n/// }\n/// ```\npub fn[A] Array::unsafe_blit_fixed(\n  dst : Array[A],\n  dst_offset : Int,\n  src : FixedArray[A],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  UninitializedArray::unsafe_blit_fixed(\n    dst.buffer(),\n    dst_offset,\n    src,\n    src_offset,\n    len,\n  )\n}\n\n///|\n/// Copies elements from one array to another array, with support for growing the\n/// destination array if needed. The arrays may overlap, in which case the copy\n/// is performed in a way that preserves the data.\n///\n/// Parameters:\n///\n/// * `self` : The array to copy elements from.\n/// * `dst` : The array to copy elements to. Will be automatically grown\n/// if needed to accommodate the copied elements.\n/// * `len` : The number of elements to copy.\n/// * `src_offset` : Starting index in the source array. Defaults to 0.\n/// * `dst_offset` : Starting index in the destination array. Defaults to\n/// 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = [1, 2, 3, 4, 5]\n///   let dst = [0, 0]\n///   src[:3].blit_to(dst, dst_offset=1)\n///   inspect(dst, content=\"[0, 1, 2, 3]\")\n/// }\n/// ```\n///\n/// Panics if:\n///\n/// * `len` is negative\n/// * `src_offset` is negative\n/// * `dst_offset` is negative\n/// * `dst_offset` exceeds the length of destination array\n/// * `src_offset + len` exceeds the length of source array\n// TODO: make len optional and deprecate it\n#label_migration(src_offset, fill=false, msg=\"Use ArrayView::blit_to instead\")\n#label_migration(len, fill=false, msg=\"Use ArrayView::blit_to instead\")\npub fn[A] Array::blit_to(\n  self : Array[A],\n  dst : Array[A],\n  len? : Int = self.length(),\n  src_offset? : Int = 0,\n  dst_offset? : Int = 0,\n) -> Unit {\n  guard len >= 0 &&\n    dst_offset >= 0 &&\n    src_offset >= 0 &&\n    dst_offset <= dst.length() &&\n    src_offset + len <= self.length()\n  if dst_offset + len > dst.length() {\n    dst.unsafe_grow_to_length(dst_offset + len)\n  }\n  Array::unsafe_blit(dst, dst_offset, self, src_offset, len)\n}\n\n///|\n/// Copies all elements from an array view to a destination array, with support\n/// for growing the destination array if needed.\n///\n/// Parameters:\n///\n/// * `self` : The array view to copy elements from.\n/// * `dst` : The array to copy elements to. Will be automatically grown\n/// if needed to accommodate the copied elements.\n/// * `dst_offset` : Starting index in the destination array. Defaults to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = [1, 2, 3, 4, 5]\n///   let view = src[1:4] // view = [2, 3, 4]\n///   let dst = [0, 0]\n///   view.blit_to(dst, dst_offset=1)\n///   inspect(dst, content=\"[0, 2, 3, 4]\")\n/// }\n/// ```\n///\n/// Panics if:\n///\n/// * `dst_offset` is negative\n/// * `dst_offset` exceeds the length of destination array\npub fn[A] ArrayView::blit_to(\n  self : ArrayView[A],\n  dst : Array[A],\n  dst_offset? : Int = 0,\n) -> Unit {\n  let len = self.len()\n  guard dst_offset >= 0 && dst_offset <= dst.length()\n  if dst_offset + len > dst.length() {\n    dst.unsafe_grow_to_length(dst_offset + len)\n  }\n  UninitializedArray::unsafe_blit(\n    dst.buffer(),\n    dst_offset,\n    self.buf(),\n    self.start(),\n    len,\n  )\n}\n\n///|\ntest \"Array::blit_to/basic\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  src[1:4].blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 0, 2, 3, 4]\")\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  src[0:3].blit_to(dst)\n  inspect(dst, content=\"[1, 2, 3, 0, 0]\")\n}\n\n///|\ntest \"Array::blit_to/zero_length\" {\n  let src = [1, 2, 3]\n  let dst = [4, 5, 6]\n  src[0:0].blit_to(dst)\n  inspect(dst, content=\"[4, 5, 6]\")\n}\n\n///|\ntest \"Array::blit_to/grow_destination\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0]\n  src[0:3].blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 1, 2, 3]\")\n}\n\n///|\ntest \"Array::blit_to/edge_cases\" {\n  // Test with src_offset and dst_offset\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  src[1:3].blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 0, 2, 3, 0]\")\n\n  // Test when src and dst are the same array\n  src[0:2].blit_to(src, dst_offset=3)\n  inspect(src, content=\"[1, 2, 3, 1, 2]\")\n\n  // Test with len equal to 0\n  src[0:0].blit_to(dst, dst_offset=0)\n  inspect(dst, content=\"[0, 0, 2, 3, 0]\")\n\n  // Test with len equal to the length of src\n  src[0:5].blit_to(dst)\n  inspect(dst, content=\"[1, 2, 3, 1, 2]\")\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases1\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n\n  // Invalid range (start > end will panic)\n  ignore(src[3:1].blit_to(dst))\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases2\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  // Invalid src_offset (negative index in view creation will panic)\n  ignore(src[-1:1].blit_to(dst))\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases3\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  // len exceeding src length\n  ignore(src[0:6].blit_to(dst))\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases4\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  // dst offset exceeding dst length\n  ignore(src[0:5].blit_to(dst, dst_offset=6))\n}\n\n///|\n/// TODO\n/// 1. allow skip\n/// 2. verify test\n/// 3. concurrency test\ntest \"Array::blit_to - random cases\" {\n  let src = [10, 20, 30, 40, 50]\n  let dst = [0, 0, 0, 0, 0]\n\n  // Random len, src_offset, and dst_offset\n  src[2:4].blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 30, 40, 0, 0]\")\n\n  // Another random case\n  src[1:4].blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 30, 20, 30, 40]\")\n\n  // Yet another random case\n  src[4:5].blit_to(dst, dst_offset=4)\n  inspect(dst, content=\"[0, 30, 20, 30, 50]\")\n}\n\n///|\ntest \"Array::blit_to - boundary cases\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n\n  // Test with src_offset at the end of src\n  src[4:5].blit_to(dst, dst_offset=0)\n  inspect(dst, content=\"[5, 0, 0, 0, 0]\")\n\n  // Test with dst_offset at the end of dst\n  src[0:1].blit_to(dst, dst_offset=4)\n  inspect(dst, content=\"[5, 0, 0, 0, 1]\")\n\n  // Test with len equal to the remaining length of src\n  src[3:5].blit_to(dst, dst_offset=3)\n  inspect(dst, content=\"[5, 0, 0, 4, 5]\")\n}\n\n///|\ntest \"Array::unsafe_blit_fixed\" {\n  let src = FixedArray::make(3, 1) // Create a FixedArray with 3 elements of value 1\n  let dst = Array::make(5, 0) // Create an Array with 5 elements of value 0\n  Array::unsafe_blit_fixed(dst, 1, src, 0, 2) // Copy 2 elements from src[0] to dst[1]\n  inspect(dst, content=\"[0, 1, 1, 0, 0]\")\n}\n\n///|\ntest \"ArrayView::blit_to/basic\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4] // view = [2, 3, 4]\n  let dst = [0, 0, 0, 0, 0]\n  view.blit_to(dst)\n  inspect(dst, content=\"[2, 3, 4, 0, 0]\")\n}\n\n///|\ntest \"ArrayView::blit_to/with_offset\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4] // view = [2, 3, 4]\n  let dst = [0, 0, 0, 0, 0]\n  view.blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 0, 2, 3, 4]\")\n}\n\n///|\ntest \"ArrayView::blit_to/grow_destination\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4] // view = [2, 3, 4]\n  let dst = [0, 0]\n  view.blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 2, 3, 4]\")\n}\n\n///|\ntest \"ArrayView::blit_to/empty_view\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[2:2] // empty view\n  let dst = [0, 0, 0]\n  view.blit_to(dst)\n  inspect(dst, content=\"[0, 0, 0]\")\n}\n\n///|\ntest \"ArrayView::blit_to/nested_view\" {\n  let src = [1, 2, 3, 4, 5, 6, 7]\n  let view1 = src[1:6] // [2, 3, 4, 5, 6]\n  let view2 = view1[1:4] // [3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  view2.blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 3, 4, 5, 0]\")\n}\n\n///|\ntest \"panic ArrayView::blit_to/invalid_offset\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4]\n  let dst = [0, 0, 0]\n  ignore(view.blit_to(dst, dst_offset=-1))\n}\n\n///|\ntest \"panic ArrayView::blit_to/offset_exceeds_length\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4]\n  let dst = [0, 0, 0]\n  ignore(view.blit_to(dst, dst_offset=4))\n}\n\n// test \"Array::blit_to - invalid cases\" {\n//   let src = [1, 2, 3, 4, 5]\n//   let dst = [0, 0, 0, 0, 0]\n\n//   // Invalid len\n//   Array::blit_to(src, dst, len=-1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // Invalid src_offset\n//   Array::blit_to(src, dst, len=2, src_offset=-1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // Invalid dst_offset\n//   Array::blit_to(src, dst, len=2, dst_offset=-1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // len exceeding src length\n//   Array::blit_to(src, dst, len=6)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // len exceeding dst length\n//   Array::blit_to(src, dst, len=5, dst_offset=1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n// }\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// #region type definition and intrinsics\n\n///|\n/// An `ArrayView` represents a view into a section of an array without copying the data.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Creates a view of elements at indices 1,2,3\n///   assert_eq(view[0], 2)\n///   assert_eq(view.length(), 3)\n/// }\n/// ```\n#builtin.valtype\ntype ArrayView[T]\n\n///|\nfn[T] ArrayView::buf(self : ArrayView[T]) -> UninitializedArray[T] = \"%arrayview.buf\"\n\n///|\nfn[T] ArrayView::start(self : ArrayView[T]) -> Int = \"%arrayview.start\"\n\n///|\nfn[T] ArrayView::len(self : ArrayView[T]) -> Int = \"%arrayview.len\"\n\n///|\nfn[T] ArrayView::make(\n  buf : UninitializedArray[T],\n  start : Int,\n  len : Int,\n) -> ArrayView[T] = \"%arrayview.make\"\n\n// #endregion\n\n// #region methods\n\n///|\n/// Returns the length (number of elements) of an array view.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect(view.length(), content=\"2\")\n/// }\n/// ```\npub fn[T] ArrayView::length(self : ArrayView[T]) -> Int {\n  self.len()\n}\n\n///|\n/// Returns whether the array view is empty.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3][:]\n///   inspect(view.is_empty(), content=\"false\")\n///   let empty = [1, 2][0:0]\n///   inspect(empty.is_empty(), content=\"true\")\n/// }\n/// ```\npub fn[T] ArrayView::is_empty(self : ArrayView[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\npub fn[T] ArrayView::start_offset(self : Self[T]) -> Int {\n  self.start()\n}\n\n///|\n/// Retrieves an element at the specified index from the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to access.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array view).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect(view[0], content=\"3\")\n///   inspect(view[1], content=\"4\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] ArrayView::at(self : ArrayView[T], index : Int) -> T {\n  guard index >= 0 && index < self.len() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.len()} but the index is \\{index}\",\n    )\n  }\n  self.buf()[self.start() + index]\n}\n\n///|\n/// Retrieves an element from the array view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect(view.get(0), content=\"Some(2)\")\n///   inspect(view.get(1), content=\"Some(3)\")\n///   inspect(view.get(2), content=\"Some(4)\")\n///   inspect(view.get(5), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::get(self : ArrayView[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.buf()[self.start() + index])\n}\n\n///|\n/// Returns the last element of the array view, if any.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3][:]\n///   inspect(view.last(), content=\"Some(3)\")\n///   let empty = [1, 2][0:0]\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::last(self : ArrayView[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    Some(self.unsafe_get(len - 1))\n  }\n}\n\n///|\n/// Retrieves an element from the array view at the specified index without\n/// performing bounds checking.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect(view.unsafe_get(1), content=\"3\")\n/// }\n/// ```\n#intrinsic(\"%arrayview.unsafe_get\")\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] ArrayView::unsafe_get(self : ArrayView[T], index : Int) -> T {\n  self.buf()[self.start() + index]\n}\n\n///|\n/// Creates a view of a portion of the array. The view provides read-write access\n/// to the underlying array without copying the elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws a panic if the indices are invalid (i.e., `start` is negative, `end`\n/// is greater than the array length, or `start` is greater than `end`).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Create a view of elements at indices 1, 2, and 3\n///   inspect(view[0], content=\"2\") // First element of view is arr[1]\n///   inspect(view.length(), content=\"3\") // View contains 3 elements\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] Array::sub(\n  self : Array[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(self.buffer(), start, end - start)\n}\n\n///|\n/// Creates a new view into a portion of the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to create a new view from.\n/// * `start` : The starting index in the current view (inclusive). Defaults to\n/// 0.\n/// * `end` : The ending index in the current view (exclusive). Defaults to the\n/// length of the current view.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original array view. The indices are relative to the start of the\n/// current view.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the current view\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   let subview = view[1:2] // subview = [3]\n///   inspect(subview[0], content=\"3\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] ArrayView::sub(\n  self : ArrayView[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(self.buf(), self.start() + start, end - start)\n}\n\n///|\nfn[T] unsafe_cast_fixedarray_to_uninitializedarray(\n  arr : FixedArray[T],\n) -> UninitializedArray[T] = \"%identity\"\n\n///|\n/// Creates a new `ArrayView` from a `FixedArray`.\n///\n/// Parameters:\n///\n/// * `self` : The fixed array to create a new view from.\n/// * `start` : The starting index in the array (inclusive). Defaults to 0.\n/// * `end` : The ending index in the array (exclusive). Defaults to the\n/// length of the array.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original fixed array.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the array\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   inspect(view[0], content=\"2\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] FixedArray::sub(\n  self : FixedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(\n    unsafe_cast_fixedarray_to_uninitializedarray(self),\n    start,\n    end - start,\n  )\n}\n\n///|\npub fn[T] ArrayView::suffixes(\n  self : Self[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  let len = self.length()\n  let mut i = 0\n  Iter::new(fn() -> ArrayView[T]? {\n    if i < len {\n      let suffix = self[i:]\n      i += 1\n      Some(suffix)\n    } else if i == len {\n      i += 1\n      if include_empty {\n        Some(self[len:])\n      } else {\n        None\n      }\n    } else {\n      None\n    }\n  })\n}\n\n///|\n/// Returns an iterator that yields each element of the array view in sequence\n/// from start to end.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to iterate over.\n///\n/// Returns an iterator that yields elements of type `A` from the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   let mut sum = 0\n///   view.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"5\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[X] ArrayView::iter(self : ArrayView[X]) -> Iter[X] {\n  let mut i = 0\n  Iter::new(fn() {\n    guard i < self.length() else { None }\n    let elem = self.unsafe_get(i)\n    i += 1\n    Some(elem)\n  })\n}\n\n///|\n#alias(rev_iterator, deprecated)\npub fn[X] ArrayView::rev_iter(self : ArrayView[X]) -> Iter[X] {\n  let mut i = self.length()\n  Iter::new(fn() {\n    guard i > 0 else { None }\n    i -= 1\n    Some(self.unsafe_get(i))\n  })\n}\n\n///|\n/// Returns an iterator that yields tuples of index and value\n/// indices start from 0.\n/// \n/// Example:\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   let mut sum = 0\n///   let mut sum_keys = 0\n///   view\n///   .iter2()\n///   .each((i, x) => {\n///     sum = sum + x\n///     sum_keys = sum_keys + i\n///   })\n///   inspect(sum, content=\"5\")\n///   inspect(sum_keys, content=\"1\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[X] ArrayView::iter2(self : ArrayView[X]) -> Iter2[Int, X] {\n  let mut i = 0\n  Iter2::new(fn() {\n    guard i < self.length() else { None }\n    let result = Some((i, self.unsafe_get(i)))\n    i += 1\n    result\n  })\n}\n\n///|\n/// Iterates over each element in the array view and applies a function to it.\n///\n/// Parameters:\n///\n/// * `self` : The array view to iterate over.\n/// * `function` : A function that takes an element of type `T` and returns\n/// nothing. This function will be applied to each element in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3][:]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\npub fn[T] ArrayView::each(\n  self : ArrayView[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array view with index.\n///\n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5][:]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[T] ArrayView::eachi(\n  self : ArrayView[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks if all elements in the array view match the condition.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let v = [1, 4, 6, 8, 9]\n///   assert_false(v[:].all(elem => elem % 2 == 0))\n///   assert_true(v[1:4].all(elem => elem % 2 == 0))\n/// }\n/// ```\n#alias(every)\npub fn[T] ArrayView::all(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  for v in self {\n    if !f(v) {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Check if any of the elements in the array view match the condition.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5][:]\n///   assert_true(v.any(ele => ele < 6))\n///   assert_false(v.any(ele => ele < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] ArrayView::any(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  for v in self {\n    if f(v) {\n      return true\n    }\n  }\n  false\n}\n\n///|\n/// Checks whether the array view contains a specific element by comparing each\n/// element with the target value using the equality operator.\n///\n/// Parameters:\n///\n/// * `view` : The array view to search in.\n/// * `target` : The value to search for in the array view.\n///\n/// Returns a boolean value indicating whether the target value exists in the\n/// array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5][:]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::contains(self : ArrayView[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 2, 4][:]\n///   inspect(view.search(2), content=\"Some(1)\")\n///   inspect(view.search(5), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::search(self : ArrayView[T], value : T) -> Int? {\n  for i in 0..<self.length() {\n    if self.unsafe_get(i) == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Checks if the array view starts with the given prefix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5][:]\n///   inspect(view.starts_with([1, 2][:]), content=\"true\")\n///   inspect(view.starts_with([2, 3][:]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::starts_with(\n  self : ArrayView[T],\n  prefix : ArrayView[T],\n) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Checks if the array view ends with the given suffix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5][:]\n///   inspect(view.ends_with([4, 5][:]), content=\"true\")\n///   inspect(view.ends_with([3, 4][:]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::ends_with(\n  self : ArrayView[T],\n  suffix : ArrayView[T],\n) -> Bool {\n  let suffix_len = suffix.length()\n  let self_len = self.length()\n  if suffix_len > self_len {\n    return false\n  }\n  for i in 0..<suffix_len {\n    if self.unsafe_get(self_len - suffix_len + i) != suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 3, 5, 7, 9][:]\n///   inspect(view.binary_search(5), content=\"Ok(2)\")\n///   inspect(view.binary_search(6), content=\"Err(3)\")\n/// }\n/// ```\npub fn[T : Compare] ArrayView::binary_search(\n  self : ArrayView[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search using a custom comparison function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 3, 5, 7, 9][:]\n///   let result = view.binary_search_by(x => x.compare(5))\n///   inspect(result, content=\"Ok(2)\")\n/// }\n/// ```\n#locals(cmp)\npub fn[T] ArrayView::binary_search_by(\n  self : ArrayView[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ArrayView::fold(\n  self : ArrayView[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules in reversed turn.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].rev_fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ArrayView::rev_fold(\n  self : ArrayView[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].foldi(init=0, (index, sum, _elem) => sum + index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] ArrayView::foldi(\n  self : ArrayView[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules in reversed turn with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].rev_foldi(init=0, (index, sum, _elem) => sum +\n///     index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] ArrayView::rev_foldi(\n  self : ArrayView[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Maps a function over the elements of the array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v[1:].map(x => x + 1)\n///   assert_eq(v2, [5, 6])\n/// }\n/// ```\npub fn[T, U] ArrayView::map(\n  self : ArrayView[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  Array::makei(self.length(), i => f(self[i]))\n}\n\n///|\n/// Maps a function over the elements of the array view with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v[1:].mapi((i, x) => x + i)\n///   assert_eq(v2, [4, 6])\n/// }\n/// ```\npub fn[T, U] ArrayView::mapi(\n  self : ArrayView[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  Array::makei(self.length(), i => f(i, self[i]))\n}\n\n///|\n/// Filters the array view with a predicate function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5, 6]\n///   let v = arr[2:].filter(x => x % 2 == 0)\n///   assert_eq(v, [4, 6])\n/// }\n/// ```\npub fn[T] ArrayView::filter(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Copy the view elements to a new array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5, 6][2:4]\n///   let arr = view.to_array()\n///   assert_eq(arr, [3, 4])\n/// }\n/// ```\npub fn[T] ArrayView::to_array(self : ArrayView[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    for i, v in self {\n      arr[i] = v\n    }\n    arr\n  }\n}\n\n///|\n/// Concatenate strings within an array into a single complete string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a : Array[String] = [\"1\", \"2\", \"3\"]\n///   let array_view = a[:]\n///   inspect(array_view.join(\",\"), content=\"1,2,3\")\n/// }\n/// ```\npub fn[A : ToStringView] ArrayView::join(\n  self : ArrayView[A],\n  separator : StringView,\n) -> String {\n  match self {\n    [] => \"\"\n    [hd, .. tl] => {\n      let hd = hd.to_string_view()\n      let mut size_hint = hd.length()\n      for s in tl {\n        size_hint += s.to_string_view().length() + separator.length()\n      }\n      size_hint = size_hint << 1\n      let buf = StringBuilder::new(size_hint~)\n      // buf.write_string(hd)\n      buf.write_view(hd)\n      if separator is \"\" {\n        for s in tl {\n          // buf.write_string(s)\n          let s = s.to_string_view()\n          buf.write_view(s)\n        }\n      } else {\n        for s in tl {\n          let s = s.to_string_view()\n          buf.write_view(separator)\n          // buf.write_string(s)\n          buf.write_view(s)\n        }\n      }\n      buf.to_string()\n    }\n  }\n}\n\n// #endregion\n\n// #region trait impls\n\n///|\npub impl[X : Show] Show for ArrayView[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[T : Eq] Eq for ArrayView[T] with equal(self, other) -> Bool {\n  if self.length() != other.length() {\n    return false\n  }\n  for i in 0..<self.length() {\n    if !(self[i] == other[i]) {\n      return false\n    }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Compare] Compare for ArrayView[T] with compare(self, other) -> Int {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp == 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self[i].compare(other[i])\n    guard cmp == 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\npub impl[A : Hash] Hash for ArrayView[A] with hash_combine(self, hasher) {\n  for e in self {\n    hasher.combine(e)\n  }\n}\n\n// #endregion\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T : Show] debug_string(t : T) -> String {\n  let buf = StringBuilder::new(size_hint=50)\n  t.output(buf)\n  buf.to_string()\n}\n\n///|\n/// Asserts that two values are equal. If they are not equal, raises a failure\n/// with a message containing the source location and the values being compared.\n///\n/// Parameters:\n///\n/// * `a` : First value to compare.\n/// * `b` : Second value to compare.\n/// * `loc` : Source location information to include in failure messages. This is\n/// usually automatically provided by the compiler.\n///\n/// Throws a `Failure` error if the values are not equal, with a message showing\n/// the location of the failing assertion and the actual values that were\n/// compared.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_eq(1, 1)\n///   assert_eq(\"hello\", \"hello\")\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if a != b {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} != \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that two values of the same type are not equal. If the values are\n/// equal, raises a failure with a detailed error message including the source\n/// location and string representation of both values.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `location` : Source location information for error reporting. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error if the values are equal. The error message includes\n/// the source location and string representations of both values.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_not_eq(1, 2) // Passes\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_not_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if !(a != b) {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} == \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that the given boolean value is true. Throws an error with source\n/// location information if the assertion fails.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean value to be checked.\n/// * `location` : The source location where the assertion is made. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error with a descriptive message including the source\n/// location if the condition is false.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(true)\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_true(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if !x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not true\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Tests whether a boolean condition is false, throwing an error if the\n/// condition is true.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean condition to test.\n/// * `location` : The source location where the assertion is made. Used in error\n/// messages.\n///\n/// Throws a `Failure` error if the condition is true. The error message includes\n/// the source location and the value that was expected to be false.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_false(false)\n///   assert_false(1 > 2)\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_false(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not false\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"@package:file:start_line:start_column-end_line:end_column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\nfn SourceLoc::repr(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  SourceLocRepr::parse(self.repr()).output(logger)\n}\n\n///|\npriv struct SourceLocRepr {\n  pkg : StringView\n  filename : StringView\n  start_line : StringView\n  start_column : StringView\n  end_line : StringView\n  end_column : StringView\n}\n\n///|\nimpl Show for SourceLocRepr with output(self, logger) {\n  let pkg = self.pkg\n  let (module_name, package_name) = lexmatch pkg {\n    ((\"[^/]*/[^/]*\" as module_name) \"/\" (\".*\" as package_name)) =>\n      (module_name, Some(package_name))\n    _ => (pkg, None)\n  }\n  if package_name is Some(pkg_name) {\n    logger..write_view(pkg_name)..write_char('/')\n  }\n  logger\n  ..write_view(self.filename)\n  ..write_char(':')\n  ..write_view(self.start_line)\n  ..write_char(':')\n  ..write_view(self.start_column)\n  ..write_char('-')\n  ..write_view(self.end_line)\n  ..write_char(':')\n  ..write_view(self.end_column)\n  ..write_char('@')\n  ..write_view(module_name)\n}\n\n///|\nfn SourceLocRepr::parse(repr : String) -> SourceLocRepr {\n  lexmatch repr[:] {\n    (\n      \"@\"\n      (\"[^:]*\" as pkg)\n      \":\"\n      (\".+?\" as filename)\n      \":\"\n      (\"[[:digit:]]+\" as start_line)\n      \":\"\n      (\"[[:digit:]]+\" as start_column)\n      \"-\"\n      (\"[[:digit:]]+\" as end_line)\n      \":\"\n      (\"[[:digit:]]+\" as end_column)\n    ) => { pkg, filename, start_line, start_column, end_line, end_column }\n    _ => panic()\n  }\n}\n\n///|\nfn SourceLocRepr::to_json_string(self : SourceLocRepr) -> String {\n  StringBuilder::new()\n  ..write_string(\"{\\\"pkg\\\":\\\"\\{self.pkg}\\\"\")\n  ..write_string(\",\\\"filename\\\":\")\n  ..write_object(self.filename)\n  ..write_string(\",\\\"start_line\\\":\\{self.start_line}\")\n  ..write_string(\",\\\"start_column\\\":\\{self.start_column}\")\n  ..write_string(\",\\\"end_line\\\":\\{self.end_line}\")\n  ..write_string(\",\\\"end_column\\\":\\{self.end_column}}\")\n  .to_string()\n}\n\n///|\n/// Convert a source location to a JSON string\npub fn SourceLoc::to_json_string(self : SourceLoc) -> String {\n  SourceLocRepr::parse(self.repr()).to_json_string()\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => buf.write_string(loc.to_json_string())\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts a boolean value to its integer representation.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to convert.\n///\n/// Returns 1 if the boolean is `true`, 0 if it is `false`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_int(), content=\"1\")\n///   inspect(false.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_int(self : Bool) -> Int {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to a 64-bit integer. Returns 1 for `true` and 0 for\n/// `false`.\n///\n/// Parameters:\n///\n/// * `bool` : The boolean value to be converted.\n///\n/// Returns a 64-bit integer representation of the boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_int64(), content=\"1\")\n///   inspect(false.to_int64(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_int64(self : Bool) -> Int64 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to an unsigned integer.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to be converted.\n///\n/// Returns an unsigned integer, where `true` is converted to 1 and `false` is\n/// converted to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_uint(), content=\"1\")\n///   inspect(false.to_uint(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_uint(self : Bool) -> UInt {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to an unsigned 64-bit integer. Returns 1 for `true`\n/// and 0 for `false`.\n///\n/// Parameters:\n///\n/// * `bool` : The boolean value to convert.\n///\n/// Returns an unsigned 64-bit integer representation of the boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_uint64(), content=\"1\")\n///   inspect(false.to_uint64(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_uint64(self : Bool) -> UInt64 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\npub impl Hash for Bool with hash_combine(self, hasher) {\n  hasher.combine_bool(self)\n}\n\n///|\n/// Converts a boolean value to an unsigned 16-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to be converted.\n///\n/// Returns an unsigned 16-bit integer, where `true` is converted to 1 and\n/// `false` is converted to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_uint16(), content=\"1\")\n///   inspect(false.to_uint16(), content=\"0\")\n/// }\n/// ```\n///\npub fn Bool::to_uint16(self : Bool) -> UInt16 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to a 16-bit integer representation.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to be converted.\n///\n/// Returns a 16-bit integer, where `true` is converted to 1 and `false` is\n/// converted to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_int16(), content=\"1\")\n///   inspect(false.to_int16(), content=\"0\")\n/// }\n/// ```\n///\npub fn Bool::to_int16(self : Bool) -> Int16 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Reinterpret the byte sequence as Bytes.\n///\n/// Notice that this will make the `Bytes` object to be a view of the original\n/// byte sequence, so any modification to the original byte sequence will be\n/// reflected in the `Bytes` object.\n#internal(unsafe, \"Creating mutable Bytes\")\n#doc(hidden)\npub fn FixedArray::unsafe_reinterpret_as_bytes(\n  self : FixedArray[Byte],\n) -> Bytes = \"%identity\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized using a function that maps indices to bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. If `length` is less than or\n/// equal to 0, returns an empty byte sequence.\n/// * `value` : A function that takes an index (from 0 to `length - 1`) and\n/// returns a byte for that position.\n///\n/// Returns a new byte sequence containing the bytes produced by applying the\n/// value function to each index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::makei(3, i => (i + 65).to_byte())\n///   assert_eq(bytes, b\"ABC\")\n/// }\n/// ```\npub fn Bytes::makei(length : Int, value : (Int) -> Byte raise?) -> Bytes raise? {\n  if length <= 0 {\n    return []\n  }\n  let arr = FixedArray::make(length, value(0))\n  for i in 1..<length {\n    arr[i] = value(i)\n  }\n  FixedArray::unsafe_reinterpret_as_bytes(arr)\n}\n\n///|\n/// TODO: support local primitive declaration\n#owned(bytes)\nfn unsafe_sub_string(\n  bytes : Bytes,\n  byte_offset : Int,\n  byte_length : Int,\n) -> String = \"$moonbit.unsafe_bytes_sub_string\"\n\n///|\n/// Return an unchecked string, containing the subsequence of `self` that starts at\n/// `offset` and has length `length`. Both `offset` and `length`\n/// are indexed by byte.\n///\n/// Note this function does not validate the encoding of the byte sequence,\n/// it simply copy the bytes into a new String.\npub fn Bytes::to_unchecked_string(\n  self : Bytes,\n  offset? : Int = 0,\n  length? : Int,\n) -> String {\n  let len = self.length()\n  let length = if length is Some(l) { l } else { len - offset }\n  guard offset >= 0 && length >= 0 && offset + length <= len\n  unsafe_sub_string(self, offset, length)\n}\n\n///|\n/// Copies characters from a string to a byte sequence in UTF-16LE encoding. Each\n/// character is converted into two bytes, with the lower byte stored first.\n///\n/// Parameters:\n///\n/// * `self` : The destination byte array to copy the characters into.\n/// * `bytes_offset` : The starting position in the destination array where bytes\n/// will be written.\n/// * `str` : The source string containing the characters to copy.\n/// * `str_offset` : The starting position in the source string from which\n/// characters will be read.\n/// * `length` : The number of characters to copy.\n///\n/// Throws a runtime error if:\n///\n/// * `length` is negative\n/// * `bytes_offset` is negative\n/// * `str_offset` is negative\n/// * The range `[bytes_offset, bytes_offset + length * 2)` exceeds the length of\n/// the destination array\n/// * The range `[str_offset, str_offset + length)` exceeds the length of the\n/// source string\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = FixedArray::make(6, b'\\x00')\n///   bytes.blit_from_string(0, \"ABC\", 0, 3)\n///   @json.inspect(bytes, content=[65, 0, 66, 0, 67, 0]) // 'A'\n///   bytes.blit_from_string(0, \"你好啊\", 0, 3)\n///   @json.inspect(bytes, content=[96, 79, 125, 89, 74, 85]) // '你好啊'\n///   bytes.blit_from_string(0, \"😈\", 0, 2)\n///   @json.inspect(bytes, content=[61, 216, 8, 222, 74, 85]) // '😈'\n/// }\n/// ```\npub fn FixedArray::blit_from_string(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  str : String,\n  str_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = str_offset\n  let e1 = bytes_offset + length * 2 - 1\n  let e2 = str_offset + length - 1\n  let len1 = self.length()\n  let len2 = str.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  let end_str_offset = str_offset + length\n  for i = str_offset, j = bytes_offset; i < end_str_offset; i = i + 1, j = j + 2 {\n    let c = str.unsafe_charcode_at(i).reinterpret_as_uint()\n    self[j] = (c & 0xff).to_byte()\n    self[j + 1] = (c >> 8).to_byte()\n  }\n}\n\n///|\n/// TODO: specific copy\nfn unsafe_from_bytes(bytes : Bytes) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Copy `length` chars from byte sequence `src`, starting at `src_offset`,\n/// into byte sequence `self`, starting at `bytes_offset`.\npub fn FixedArray::blit_from_bytes(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : Bytes,\n  src_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = src_offset\n  let e1 = bytes_offset + length - 1\n  let e2 = src_offset + length - 1\n  let len1 = self.length()\n  let len2 = src.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  FixedArray::unsafe_blit(\n    self,\n    bytes_offset,\n    unsafe_from_bytes(src),\n    src_offset,\n    length,\n  )\n}\n\n///|\n/// Copy bytes from a BytesView into a fixed array of bytes.\n///\n/// Parameters:\n///\n/// * `self` : The destination fixed array of bytes.\n/// * `bytes_offset` : The starting position in the destination array where bytes will be copied.\n/// * `src` : The source View to copy from.\n///\n/// Throws a panic if:\n/// * `bytes_offset` is negative\n/// * The destination array is too small to hold all bytes from the source View\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(4, b'\\x00')\n///   let view = b\"\\x01\\x02\\x03\"[1:]\n///   arr.blit_from_bytesview(1, view)\n///   inspect(arr, content=\"[b'\\\\x00', b'\\\\x02', b'\\\\x03', b'\\\\x00']\")\n/// }\n/// ```\npub fn FixedArray::blit_from_bytesview(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : BytesView,\n) -> Unit {\n  FixedArray::blit_from_bytes(\n    self,\n    bytes_offset,\n    src.bytes(),\n    src.start(),\n    src.len(),\n  )\n}\n\n///|\n/// Encodes a Unicode character into UTF-8 bytes and writes them into a fixed\n/// array of bytes at the specified offset.\n///\n/// Parameters:\n///\n/// * `array` : The fixed array of bytes to write into.\n/// * `offset` : The starting position in the array where the encoded bytes will\n/// be written.\n/// * `char` : The Unicode character to be encoded.\n///\n/// Returns the number of bytes written (1 to 4 bytes depending on the\n/// character's code point).\n///\n/// Throws a panic if:\n///\n/// * The character's code point is greater than 0x10FFFF.\n/// ```mbt check\n/// test {\n///   let buf = FixedArray::make(4, b'\\x00')\n///   let written = buf.set_utf8_char(0, '€') // Euro symbol (U+20AC)\n///   inspect(written, content=\"3\") // UTF-8 encoding takes 3 bytes\n///   inspect(buf[0], content=\"b'\\\\xE2'\")\n///   inspect(buf[1], content=\"b'\\\\x82'\")\n///   inspect(buf[2], content=\"b'\\\\xAC'\")\n/// }\n/// ```\npub fn FixedArray::set_utf8_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  match code {\n    _..<0x80 => {\n      self[offset] = ((code & 0x7F) | 0x00).to_byte()\n      1\n    }\n    _..<0x0800 => {\n      self[offset] = (((code >> 6) & 0x1F) | 0xC0).to_byte()\n      self[offset + 1] = ((code & 0x3F) | 0x80).to_byte()\n      2\n    }\n    _..<0x010000 => {\n      self[offset] = (((code >> 12) & 0x0F) | 0xE0).to_byte()\n      self[offset + 1] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = ((code & 0x3F) | 0x80).to_byte()\n      3\n    }\n    _..<0x110000 => {\n      self[offset] = (((code >> 18) & 0x07) | 0xF0).to_byte()\n      self[offset + 1] = (((code >> 12) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 3] = ((code & 0x3F) | 0x80).to_byte()\n      4\n    }\n    _ => abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16LE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16le_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code & 0xFF).to_byte()\n    self[offset + 1] = (code >> 8).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo & 0xFF).to_byte()\n    self[offset + 1] = (lo >> 8).to_byte()\n    self[offset + 2] = (hi & 0xFF).to_byte()\n    self[offset + 3] = (hi >> 8).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16BE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16be_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code >> 8).to_byte()\n    self[offset + 1] = (code & 0xFF).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo >> 8).to_byte()\n    self[offset + 1] = (lo & 0xFF).to_byte()\n    self[offset + 2] = (hi >> 8).to_byte()\n    self[offset + 3] = (hi & 0xFF).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Compares two byte sequences for equality. Returns true only if both sequences\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes1 = b\"\\x01\\x02\\x03\"\n///   let bytes2 = b\"\\x01\\x02\\x03\"\n///   let bytes3 = b\"\\x01\\x02\\x04\"\n///   inspect(bytes1 == bytes2, content=\"true\")\n///   inspect(bytes1 == bytes3, content=\"false\")\n/// }\n/// ```\npub impl Eq for Bytes with equal(self : Bytes, other : Bytes) -> Bool {\n  if self.length() != other.length() {\n    false\n  } else {\n    let len = self.length()\n    for i in 0..<len {\n      if self[i] != other[i] {\n        break false\n      }\n    } else {\n      true\n    }\n  }\n}\n\n///|\n/// Compares two byte sequences based on shortlex order. First compares the lengths of\n/// the sequences, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b\"\\x01\\x02\\x03\"\n///   let b = b\"\\x01\\x02\\x04\"\n///   inspect(a.compare(b), content=\"-1\") // a < b\n///   inspect(b.compare(a), content=\"1\") // b > a\n///   inspect(a.compare(a), content=\"0\") // a = a\n///   let a = b\"\\x01\\x02\"\n///   let b = b\"\\x01\\x02\\x03\"\n///   inspect(a.compare(b), content=\"-1\") // shorter sequence is less\n///   inspect(b.compare(a), content=\"1\") // longer sequence is greater\n/// }\n/// ```\npub impl Compare for Bytes with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  if cmp != 0 {\n    return cmp\n  }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    if cmp != 0 {\n      break cmp\n    }\n  } else {\n    0\n  }\n}\n\n///|\n/// Creates a new bytes sequence from a byte array.\n///\n/// Parameters:\n///\n/// * `array` : An array of bytes to be converted.\n///\n/// Returns a new bytes sequence containing the same bytes as the input array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [b'h', b'i']\n///   let bytes = Bytes::from_array(arr)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hi\"\n///     ),\n///   )\n/// }\n///\n/// test {\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::from_array(arr)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hello\"\n///     ),\n///   )\n/// }\n/// ```\n// TODO: marked as intrinsic, inline if it is constant\n#alias(of, deprecated)\npub fn Bytes::from_array(arr : ArrayView[Byte]) -> Bytes {\n  Bytes::makei(arr.length(), i => arr[i])\n}\n\n///|\n/// Creates a new bytes sequence from a fixed-size array of bytes with an\n/// optional length parameter.\n///\n/// Parameters:\n///\n/// * `array` : A fixed-size array of bytes to be converted into a bytes\n/// sequence.\n/// * `length` : (Optional) The length of the resulting bytes sequence. If not\n/// provided, uses the full length of the input array.\n///\n/// Returns a new bytes sequence containing the bytes from the input array. If a\n/// length is specified, only includes up to that many bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::from_array(arr[0:3])\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hel\"\n///     ),\n///   )\n/// }\n/// ```\n/// \n/// Panics if the length is invalid\n#deprecated(\"Use Bytes::from_array instead\")\npub fn Bytes::from_fixedarray(arr : FixedArray[Byte], len? : Int) -> Bytes {\n  let len = match len {\n    None => arr.length()\n    Some(x) => {\n      guard 0 <= x && x <= arr.length()\n      x\n    }\n  }\n  let result = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_to(result, len~)\n  result.unsafe_reinterpret_as_bytes()\n}\n\n///|\n/// Converts a bytes sequence into a fixed-size array of bytes. If an optional\n/// length is provided, the resulting array will have exactly that length,\n/// otherwise it will match the length of the input bytes.\n///\n/// Parameters:\n///\n/// * `self` : The bytes sequence to convert.\n/// * `len` : Optional. The desired length of the output array. If specified, the\n/// resulting array will have this length. If not specified, the length of the\n/// input bytes sequence will be used.\n///\n/// Returns a fixed-size array containing the bytes from the input sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"hello\"\n///   let arr = bytes.to_fixedarray()\n///   inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n///   let arr2 = bytes[:3].to_fixedarray()\n///   inspect(arr2, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C']\")\n/// }\n/// ```\n/// \n/// Panics if the length is invalid\n#label_migration(len, fill=false)\npub fn Bytes::to_fixedarray(self : Bytes, len? : Int) -> FixedArray[Byte] {\n  let len = match len {\n    None => self.length()\n    Some(x) => {\n      guard 0 <= x && x <= self.length()\n      x\n    }\n  }\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self, 0, len)\n  arr\n}\n\n///|\npub fn BytesView::to_fixedarray(self : BytesView) -> FixedArray[Byte] {\n  let len = self.length()\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self.data(), self.start_offset(), len)\n  arr\n}\n\n///|\n/// Creates a new bytes sequence from an iterator of bytes.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator that yields bytes.\n///\n/// Returns a new bytes sequence containing all the bytes from the iterator.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(b'h')\n///   let bytes = Bytes::from_iter(iter)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"h\"\n///     ),\n///   )\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn Bytes::from_iter(iter : Iter[Byte]) -> Bytes {\n  Bytes::from_array(iter.collect())\n}\n\n///|\n/// Converts a bytes sequence into an array of bytes.\n///\n/// Parameters:\n///\n/// * `bytes` : A sequence of bytes to be converted into an array.\n///\n/// Returns an array containing the same bytes as the input sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"hello\"\n///   let arr = bytes.to_array()\n///   inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n/// }\n/// ```\npub fn Bytes::to_array(self : Bytes) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\npub fn BytesView::to_array(self : BytesView) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\n/// Creates an iterator over the bytes in the sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : A byte sequence to iterate over.\n///\n/// Returns an iterator that yields each byte in the sequence in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::from_array([b'h', b'i'])\n///   let mut sum = 0\n///   bytes.iter().each(b => sum = sum + b.to_int())\n///   inspect(sum, content=\"209\") // ASCII values: 'h'(104) + 'i'(105) = 209\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn Bytes::iter(self : Bytes) -> Iter[Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let c = self.unsafe_get(i)\n    i += 1\n    Some(c)\n  })\n}\n\n///|\n/// Creates an iterator that yields tuples of index and byte,\n/// indices start from 0.\n/// \n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = StringBuilder::new(size_hint=5)\n///   let keys = []\n///   let it = b\"abcde\".iter2()\n///   while it.next() is Some((i, x)) {\n///     buf.write_string(x.to_string())\n///     keys.push(i)\n///   }\n///   inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n///   inspect(keys, content=\"[0, 1, 2, 3, 4]\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn Bytes::iter2(self : Bytes) -> Iter2[Int, Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let result = (i, self.unsafe_get(i))\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Creates a new empty bytes sequence.\n///\n/// Returns an empty bytes sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::default()\n///   inspect(bytes, content=\"b\\\"\\\"\")\n///   inspect(bytes.length(), content=\"0\")\n/// }\n/// ```\npub impl Default for Bytes with default() {\n  b\"\"\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index, or None if the index is out of bounds.\n///\n/// Example:\n/// \n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   let byte = bytes.get(1)\n///   inspect(byte, content=\"Some(b'\\\\x02')\")\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   let byte = bytes.get(3)\n///   inspect(byte, content=\"None\")\n/// }\n/// ```\npub fn Bytes::get(self : Bytes, index : Int) -> Byte? {\n  guard index >= 0 && index < self.length() else { None }\n  Some(self[index])\n}\n\n///|\nfn unsafe_to_fixedarray(array : UninitializedArray[Byte]) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Concatenates two bytes sequences.\n///\n/// Parameters:\n///\n/// * `self` : The first bytes sequence.\n/// * `other` : The second bytes sequence.\n/// TODO: marked as intrinsic, inline if it is constant\npub impl Add for Bytes with add(self : Bytes, other : Bytes) -> Bytes {\n  let len_self = self.length()\n  let len_other = other.length()\n  let rv : FixedArray[Byte] = FixedArray::make(len_self + len_other, 0)\n  for i in 0..<len_self {\n    rv[i] = self[i]\n  }\n  for i in 0..<len_other {\n    rv[len_self + i] = other[i]\n  }\n  unsafe_to_bytes(rv)\n}\n\n///|\npub impl Hash for Bytes with hash_combine(self, hasher) {\n  hasher.combine(self[:])\n}\n\n///|\n/// Returns a new `Bytes` consisting of `self` repeated `count` times.\n///\n/// If `count <= 0` or `self` is empty, an empty `Bytes` is returned. When\n/// `count == 1`, `self` is returned directly without allocation.\n///\n/// This implementation performs a single allocation sized exactly to the\n/// result and fills it using an exponential copy (doubling) strategy so the\n/// number of blit operations is O(log count).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\n///     b\"ab\".repeat(3),\n///     content=(\n///       #|b\"ababab\"\n///     ),\n///   )\n///   inspect(\n///     b\"xyz\".repeat(0),\n///     content=(\n///       #|b\"\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Bytes::repeat(self : Self, count : Int) -> Bytes {\n  if count <= 0 || self.length() == 0 {\n    return []\n  }\n  if count == 1 {\n    return self\n  }\n  let len = self.length()\n  let total = len * count\n  // (Optional) detect overflow: if multiplication wrapped (best-effort)\n  guard total / count == len\n  let arr = FixedArray::make(total, (0 : Byte))\n  arr.blit_from_bytes(0, self, 0, len)\n  let mut filled = len\n  while filled < total {\n    let remaining = total - filled\n    let copy_len = if filled < remaining { filled } else { remaining }\n    let src = unsafe_to_bytes(arr)\n    arr.blit_from_bytes(filled, src, 0, copy_len)\n    filled = filled + copy_len\n  }\n  unsafe_to_bytes(arr)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn BytesView::bytes(self : BytesView) -> Bytes = \"%bytesview.bytes\"\n\n///|\nfn BytesView::start(self : BytesView) -> Int = \"%bytesview.start\"\n\n///|\nfn BytesView::len(self : BytesView) -> Int = \"%bytesview.len\"\n\n///|\nfn BytesView::make(b : Bytes, start : Int, len : Int) -> BytesView = \"%bytesview.make\"\n\n///|\n/// Returns the number of bytes in the view.\n///\n/// Parameters:\n///\n/// * `bytes_view` : The view of a byte sequence.\n///\n/// Returns an integer representing the length of the view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x00\\x01\\x02\\x03\\x04\"\n///   let view = bytes[2:4]\n///   inspect(view.length(), content=\"2\")\n/// }\n/// ```\npub fn BytesView::length(self : BytesView) -> Int {\n  self.len()\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index if the index is valid.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[1:4] // view contains [0x02, 0x03, 0x04]\n///   inspect(view[1], content=\"b'\\\\x03'\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn BytesView::at(self : BytesView, index : Int) -> Byte {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  self.bytes()[self.start() + index]\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index, or None if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[1:4]\n///   let result = view.get(1)\n///   inspect(result, content=\"Some(b'\\\\x03')\")\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[1:4]\n///   let result = view.get(5)\n///   inspect(result, content=\"None\")\n/// }\n/// ```\npub fn BytesView::get(self : BytesView, index : Int) -> Byte? {\n  guard index >= 0 && index < self.length() else { None }\n  Some(self.bytes().unsafe_get(self.start() + index))\n}\n\n///|\n/// Retrieves a byte at the specified index from a bytes view without performing\n/// bounds checking.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte. The\n/// index is relative to the start of the view, not the underlying bytes.\n///\n/// Returns a single byte from the specified position in the view.\n///\n/// Throws a panic if the index is out of bounds (less than 0 or greater than or\n/// equal to the length of the view).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[2:4] // view contains [0x03, 0x04]\n///   inspect(view.unsafe_get(0), content=\"b'\\\\x03'\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn BytesView::unsafe_get(self : BytesView, index : Int) -> Byte {\n  self.bytes()[self.start() + index]\n}\n\n///|\n/// Creates a new `View` from the given `Bytes`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let bs = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"\n///   let bv = bs[1:4]\n///   inspect(bv.length(), content=\"3\")\n///   assert_eq(bv[0], b'\\x01')\n///   assert_eq(bv[1], b'\\x02')\n///   assert_eq(bv[2], b'\\x03')\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn Bytes::sub(self : Bytes, start? : Int = 0, end? : Int) -> BytesView {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"Invalid index for View\")\n  }\n  BytesView::make(self, start, end - start)\n}\n\n///|\n/// Creates a new `View` from the given `View`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let bv = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"[:]\n///   let bv2 = bv[1:4]\n///   inspect(bv2.length(), content=\"3\")\n///   assert_eq(bv2[1], b'\\x02')\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn BytesView::sub(\n  self : BytesView,\n  start? : Int = 0,\n  end? : Int,\n) -> BytesView {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"Invalid index for View\")\n  }\n  BytesView::make(self.bytes(), self.start() + start, end - start)\n}\n\n///|\n/// Returns an iterator over the `View`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let bv = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"[:]\n///   let mut sum = 0\n///   bv.iter().each(x => sum = sum + x.to_int())\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn BytesView::iter(self : BytesView) -> Iter[Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let result = self.unsafe_get(i)\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the `View` with index.\n/// \n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = StringBuilder::new(size_hint=5)\n///   let keys = []\n///   let it = b\"abcde\"[:].iter2()\n///   while it.next() is Some((i, x)) {\n///     buf.write_string(x.to_string())\n///     keys.push(i)\n///   }\n///   inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n///   inspect(keys, content=\"[0, 1, 2, 3, 4]\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn BytesView::iter2(self : BytesView) -> Iter2[Int, Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter2::new(fn() {\n    guard i < len else { None }\n    let result = (i, self.unsafe_get(i))\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Converts a 4-byte sequence to an unsigned 32-bit integer using big-endian\n/// byte order. The first byte is treated as the most significant byte, and the\n/// last byte as the least significant byte.\n///\n/// Parameters:\n///\n/// * `self` : A byte view containing exactly 4 bytes to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x12\\x34\\x56\\x78\"\n///   guard bytes is [u32be(x), ..]\n///   inspect(x, content=\"305419896\") // 0x12345678\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint_be(self : BytesView) -> UInt {\n  (self[0].to_uint() << 24) +\n  (self[1].to_uint() << 16) +\n  (self[2].to_uint() << 8) +\n  self[3].to_uint()\n}\n\n///|\n/// Converts a sequence of 4 bytes into an unsigned 32-bit integer using\n/// little-endian byte order. Each byte in the view contributes 8 bits to the\n/// final integer, with the least significant byte at index 0.\n///\n/// Parameters:\n///\n/// * `view` : A `View` containing exactly 4 bytes to be interpreted as a\n/// little-endian unsigned integer.\n///\n/// Returns an unsigned 32-bit integer (`UInt`) formed by interpreting the bytes\n/// in little-endian order.\n///\n/// Throws a panic if the view does not contain exactly 4 bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\"\n///   guard bytes is [u32le(x), ..]\n///   inspect(x, content=\"67305985\") // 0x04030201\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint_le(self : BytesView) -> UInt {\n  self[0].to_uint() +\n  (self[1].to_uint() << 8) +\n  (self[2].to_uint() << 16) +\n  (self[3].to_uint() << 24)\n}\n\n///|\n/// Converts a sequence of 8 bytes into a 64-bit unsigned integer using\n/// big-endian byte order. The most significant byte is at index 0, and the least\n/// significant byte is at index 7.\n///\n/// Parameters:\n///\n/// * `bytes` : A view into a byte sequence that must be at least 8 bytes long.\n/// The bytes are interpreted in big-endian order, where the first byte is the\n/// most significant byte.\n///\n/// Returns a 64-bit unsigned integer constructed by concatenating the bytes in\n/// big-endian order.\n///\n/// Throws a runtime error if the byte sequence view is less than 8 bytes long or\n/// if attempting to access an index beyond the view's bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\"\n///   guard bytes is [u64be(x), ..]\n///   inspect(x, content=\"81985529216486895\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint64_be(self : BytesView) -> UInt64 {\n  (self[0].to_uint().to_uint64() << 56) +\n  (self[1].to_uint().to_uint64() << 48) +\n  (self[2].to_uint().to_uint64() << 40) +\n  (self[3].to_uint().to_uint64() << 32) +\n  (self[4].to_uint().to_uint64() << 24) +\n  (self[5].to_uint().to_uint64() << 16) +\n  (self[6].to_uint().to_uint64() << 8) +\n  self[7].to_uint().to_uint64()\n}\n\n///|\n/// Converts an 8-byte sequence to an unsigned 64-bit integer using little-endian\n/// byte order. Each byte in the view is treated as an 8-bit unsigned integer and\n/// combined to form the final 64-bit value, with the least significant byte\n/// first.\n///\n/// Parameters:\n///\n/// * `bytes_view` : A view into a byte sequence that must be exactly 8 bytes\n/// long. Each byte represents one byte of the resulting 64-bit integer, with the\n/// first byte being the least significant.\n///\n/// Returns an unsigned 64-bit integer assembled from the bytes in little-endian\n/// order.\n///\n/// Throws a panic if the View is less than 8 bytes long or if trying to\n/// access a byte beyond the view's bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n///   guard bytes is [u64le(x), ..]\n///   inspect(x, content=\"578437695752307201\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint64_le(self : BytesView) -> UInt64 {\n  self[0].to_uint().to_uint64() +\n  (self[1].to_uint().to_uint64() << 8) +\n  (self[2].to_uint().to_uint64() << 16) +\n  (self[3].to_uint().to_uint64() << 24) +\n  (self[4].to_uint().to_uint64() << 32) +\n  (self[5].to_uint().to_uint64() << 40) +\n  (self[6].to_uint().to_uint64() << 48) +\n  (self[7].to_uint().to_uint64() << 56)\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int_be(self : BytesView) -> Int {\n  guard self is [u32be(u32), ..]\n  u32.reinterpret_as_int()\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int_le(self : BytesView) -> Int {\n  guard self is [u32le(u32), ..]\n  u32.reinterpret_as_int()\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int64_be(self : BytesView) -> Int64 {\n  guard self is [u64be(u64), ..]\n  u64.reinterpret_as_int64()\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int64_le(self : BytesView) -> Int64 {\n  guard self is [u64le(u64), ..]\n  u64.reinterpret_as_int64()\n}\n\n///|\n/// Converts the bytes in a byte view to a double-precision floating-point number\n/// using big-endian byte order. The byte view must contain exactly 8 bytes,\n/// which represent the IEEE 754 double-precision format.\n///\n/// Parameters:\n///\n/// * `byte_view` : The byte view containing exactly 8 bytes to be interpreted as\n/// a double-precision floating-point number in big-endian order.\n///\n/// Returns a double-precision floating-point number reconstructed from the\n/// bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   // Bytes representing 1.0 in IEEE 754 double-precision format (big-endian)\n///   let bytes = b\"\\x3F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n///   guard bytes is [u64be(bits), ..]\n///   inspect(bits.reinterpret_as_double(), content=\"1\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_double_be(self : BytesView) -> Double {\n  guard self is [u64be(u64), ..]\n  u64.reinterpret_as_double()\n}\n\n///|\n/// Converts the bytes in the view to a double-precision floating-point number\n/// using little-endian byte order. Interprets the first 8 bytes as a IEEE 754\n/// double-precision binary floating-point format (binary64) value.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte view to be converted. Must contain at least 8 bytes.\n///\n/// Returns a `Double` value representing the bytes interpreted in little-endian\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x3F\" // represents 1.0 in little-endian\n///   guard bytes is [u64le(bits), ..]\n///   inspect(bits.reinterpret_as_double(), content=\"1\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_double_le(self : BytesView) -> Double {\n  guard self is [u64le(u64), ..]\n  u64.reinterpret_as_double()\n}\n\n///|\npub impl Show for BytesView with output(self, logger) {\n  logger.write_string(\"b\\\"\")\n  for byte in self {\n    if byte is (' '..='~') && byte != '\"' && byte != '\\\\' {\n      logger.write_char(byte.to_char())\n    } else {\n      logger..write_string(\"\\\\x\")..write_string(byte.to_hex())\n    }\n  }\n  logger.write_string(\"\\\"\")\n}\n\n///|\npub impl Show for Bytes with output(self, logger) {\n  BytesView::output(self[:], logger)\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first view to compare.\n/// * `other` : The second view to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   let bytes = b\"abcabc\"\n///   inspect(bytes[0:3] == bytes[3:6], content=\"true\")\n///   inspect(bytes[0:3] == bytes[2:5], content=\"false\")\n///   inspect(bytes[0:4] == bytes[3:6], content=\"false\")\n/// }\n/// ```\npub impl Eq for BytesView with equal(self, other) -> Bool {\n  guard self.length() == other.length() else { return false }\n  for i in 0..<self.length() {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { return false }\n  }\n  true\n}\n\n///|\n/// Compares two views based on shortlex order. First compares the lengths of\n/// the views, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first view to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"abcabc\"\n///   inspect(bytes[0:3].compare(bytes[3:6]), content=\"0\") // abc = abc\n///   inspect(bytes[0:3].compare(bytes[2:5]), content=\"-1\") // abc < cab\n///   inspect(bytes[1:4].compare(bytes[3:6]), content=\"1\") // bca > abc\n///   inspect(bytes[0:3].compare(bytes[0:4]), content=\"-1\") // abc < abca\n///   inspect(bytes[1:5].compare(bytes[2:5]), content=\"1\") // bcab > cab\n/// }\n/// ```\npub impl Compare for BytesView with compare(self, other) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Retrieves the underlying `Bytes` from a `View`.\npub fn BytesView::data(self : BytesView) -> Bytes {\n  self.bytes()\n}\n\n///|\n/// Retrieves the start index of the view.\npub fn BytesView::start_offset(self : BytesView) -> Int {\n  self.start()\n}\n\n///|\npub fn BytesView::to_bytes(self : BytesView) -> Bytes {\n  if self.length() == self.bytes().length() {\n    // If the view covers the entire bytes, return the original bytes to avoid copying\n    return self.bytes()\n  }\n  let bytes = FixedArray::make(self.length(), (0 : Byte))\n  bytes.blit_from_bytes(0, self.bytes(), self.start_offset(), self.length())\n  unsafe_to_bytes(bytes)\n}\n\n///|\npub impl ToJson for BytesView with to_json(self) -> Json {\n  let sb = StringBuilder::new()\n  for byte in self {\n    if byte is (' '..='~') && byte != '\"' && byte != '\\\\' {\n      sb.write_char(byte.to_char())\n    } else {\n      sb..write_string(\"\\\\x\")..write_string(byte.to_hex())\n    }\n  }\n  Json::string(sb.to_string())\n}\n\n///|\n/// Converts a `Bytes` value to a JSON representation.\n/// The representation is picked for easier debugging.\n/// Printable ASCII characters (from space to tilde, excluding '\"' and '\\') are output as-is.\n/// All other bytes are represented as \\xHH, where HH is the two-digit hexadecimal value of the byte.\npub impl ToJson for Bytes with to_json(self : Bytes) -> Json {\n  BytesView::to_json(self[:])\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   if false {\n///     println(42)\n///     println(\"Hello, World!\")\n///     println([1, 2, 3])\n///   }\n/// }\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = 42\n///   inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// }\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"a中\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣a\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣中\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42, content=\"42\")\n///   inspect(\"hello\", content=\"hello\")\n///   inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// }\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content? : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_json_string()\n    let args_loc = args_loc.to_json()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n///   match err {\n///     SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n///   }\n/// }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let h1 = Hasher::new(seed=0) // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// }\n/// ```\npub fn Hasher::new(seed? : Int = seed) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n#cfg(not(target=\"js\"))\nlet seed : Int = 0\n\n///|\n#cfg(target=\"js\")\nlet seed : Int = random_seed()\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn random_seed() -> Int =\n  #|() => {\n  #|  if (globalThis.crypto?.getRandomValues) {\n  #|    const array = new Uint32Array(1);\n  #|    globalThis.crypto.getRandomValues(array);\n  #|    return array[0] | 0; // Convert to signed 32\n  #|  } else {\n  #|    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random\n  #|  }\n  #|}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// }\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// }\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// }\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(3.14F)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// }\n/// ```\n#deprecated\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\nfn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// }\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// }\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// }\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// }\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\npub impl Hash for StringView with hash_combine(\n  self : StringView,\n  hasher : Hasher,\n) -> Unit {\n  let str = self.str()\n  for i in self.start()..<self.end() {\n    hasher.combine_uint(str.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new(seed=0)\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// }\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// }\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\npub impl Hash for BytesView with hash_combine(self : BytesView, hasher : Hasher) {\n  let mut start = self.start()\n  let data = self.bytes()\n  let mut rest = self.len()\n  while rest >= 4 {\n    let mut result : UInt = 0\n    for i in 0..=3 {\n      result = result | (data.unsafe_get(i + start).to_uint() << (8 * i))\n    }\n    hasher.combine_uint(result)\n    rest -= 4\n    start += 4\n  }\n  while rest >= 1 {\n    hasher.combine_byte(data.unsafe_get(start))\n    rest -= 1\n    start += 1\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// External iterator type.\n/// `Iterator[X]` is a mutable type: iterators internally maintain mutable state\n/// to advance iteration.\n/// All read operations on `Iterator` will advance the iterator,\n/// and would give different result when called multiple times.\n#alias(Iterator, deprecated=\"The name `Iterator` is deprecated, use `Iter` instead. Note that if you have defined `iterator()` method to support `for .. in` loop, you should also rename `iterator()` to `iter()`. See https://github.com/moonbitlang/core/pull/3127 for more details.\")\nstruct Iter[X](() -> X?)\n\n///|\n/// Get the next element from an iterator, or return `None` if no more element exists.\n/// The returned element will be consumed from the iterator.\n/// Calling `next` repeatedly will iterate through all elements in the iterator.\n#alias(peek, deprecated)\n#alias(head)\npub fn[X] Iter::next(self : Iter[X]) -> X? {\n  (self.0)()\n}\n\n///|\n#locals(f)\n#deprecated(\"write a loop instead.\")\npub fn[X] Iter::run(self : Iter[X], f : (X) -> IterResult) -> IterResult {\n  while self.next() is Some(x) {\n    guard f(x) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  }\n}\n\n///|\n#deprecated(\"write a loop instead.\")\npub fn[X] Iter::just_run(self : Iter[X], f : (X) -> IterResult) -> Unit {\n  while self.next() is Some(x) {\n    if f(x) is IterEnd {\n      break\n    }\n  }\n}\n\n///|\npub impl[X : Show] Show for Iter[X] with output(self, logger) {\n  logger.write_string(\"[\")\n  if self.next() is Some(x) {\n    logger.write_object(x)\n    while self.next() is Some(x) {\n      logger.write_string(\", \")\n      logger.write_object(x)\n    }\n  }\n  logger.write_string(\"]\")\n}\n\n///|\npub impl[X : ToJson] ToJson for Iter[X] with to_json(self) {\n  Json::array(self.map(_.to_json()).collect())\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an element of type `X` and returns `Unit`. This function is applied to each element of the iterator.\n#locals(f)\npub fn[X] Iter::each(self : Iter[X], f : (X) -> Unit raise?) -> Unit raise? {\n  while self.next() is Some(x) {\n    f(x)\n  }\n}\n\n///|\n#locals(f)\npub fn[X] Iter::any(self : Iter[X], f : (X) -> Bool) -> Bool {\n  while self.next() is Some(x) {\n    if f(x) {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n#locals(f)\npub fn[X] Iter::all(self : Iter[X], f : (X) -> Bool) -> Bool {\n  while self.next() is Some(x) {\n    guard f(x) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element with index.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an index of type `Int` and an element of type `X` and returns `Unit`. This function is applied to each element of the iterator.\n#locals(f)\npub fn[X] Iter::eachi(\n  self : Iter[X],\n  f : (Int, X) -> Unit raise?,\n) -> Unit raise? {\n  let mut i = 0\n  while self.next() is Some(x) {\n    f(i, x)\n    i += 1\n  }\n}\n\n///|\n/// Folds the elements of the iterator using the given function, starting with the given initial value.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `R`: The type of the accumulator (result) value.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an accumulator of type `R` and an element of type `X`, and returns a new accumulator value.\n/// - `init`: The initial value for the fold operation.\n///\n/// # Returns\n///\n/// Returns the final accumulator value after folding all elements of the iterator.\n#locals(f)\npub fn[X, R] Iter::fold(\n  self : Iter[X],\n  init~ : R,\n  f : (R, X) -> R raise?,\n) -> R raise? {\n  let mut acc = init\n  while self.next() is Some(x) {\n    acc = f(acc, x)\n  }\n  acc\n}\n\n///|\n/// Counts the number of elements in the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n///\n/// # Returns\n///\n/// Returns the number of elements in the iterator.\npub fn[X] Iter::count(self : Iter[X]) -> Int {\n  self.fold((acc, _) => acc + 1, init=0)\n}\n\n// Producers\n\n///|\n/// Create a new iterator by supplying a `next` function directly.\n/// The supplied function should output the next element being iterated\n/// everytime it is called.\n///\n/// This function is intended for use by data structure authors,\n/// and should not be called by end users in general.\npub fn[X] Iter::new(f : () -> X?) -> Iter[X] {\n  Iter(f)\n}\n\n///|\n/// Creates an empty iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Returns\n///\n/// Returns an empty iterator of type `Iter[X]`.\npub fn[X] Iter::empty() -> Iter[X] {\n  () => None\n}\n\n///|\n/// Creates an iterator that contains a single element.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the element in the iterator.\n///\n/// # Arguments\n///\n/// - `elem`: The single element to be contained in the iterator.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[X]` that contains the single element `a`.\npub fn[X] Iter::singleton(elem : X) -> Iter[X] {\n  let mut consumed = false\n  fn() {\n    if consumed {\n      None\n    } else {\n      consumed = true\n      Some(elem)\n    }\n  }\n}\n\n///|\n/// Creates an iterator that repeats the given element indefinitely.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `x`: The element to be repeated.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[X]` that repeats the element `x` indefinitely.\npub fn[X] Iter::repeat(x : X) -> Iter[X] {\n  () => Some(x)\n}\n\n///|\n/// Filters the elements of the iterator based on a predicate function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be included in the filtered iterator.\n///\n/// # Returns\n///\n/// A new iterator that only contains the elements for which the predicate function returns `IterContinue`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `filter`.\npub fn[X] Iter::filter(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  fn() {\n    while self.next() is Some(x) {\n      if f(x) {\n        break Some(x)\n      }\n    } else {\n      None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `map`.\npub fn[X, Y] Iter::map(self : Iter[X], f : (X) -> Y) -> Iter[Y] {\n  fn() {\n    match self.next() {\n      Some(x) => Some(f(x))\n      None => None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator with index.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `mapi`.\npub fn[X, Y] Iter::mapi(self : Iter[X], f : (Int, X) -> Y) -> Iter[Y] {\n  let mut i = 0\n  fn() {\n    match self.next() {\n      Some(x) => {\n        let result = f(i, x)\n        i += 1\n        Some(result)\n      }\n      None => None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function that returns an `Option`.\n/// The elements for which the function returns `None` are filtered out.\n///\n/// The old iterator `self` must not be used again after calling `filter_map`.\npub fn[X, Y] Iter::filter_map(self : Iter[X], f : (X) -> Y?) -> Iter[Y] {\n  fn() {\n    while self.next() is Some(x) {\n      match f(x) {\n        Some(_) as y => break y\n        None => ()\n      }\n    } else {\n      None\n    }\n  }\n}\n\n///|\n/// Transforms each element of the iterator into an iterator and flattens the resulting iterators into a single iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function that transforms each element of the iterator into an iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the flattened elements.\n///\n/// # Note\n/// The old iterator `self` and the iterators returned by `f`\n/// must not be used again after calling `flat_map`.\npub fn[X, Y] Iter::flat_map(self : Iter[X], f : (X) -> Iter[Y]) -> Iter[Y] {\n  let mut current_iter = Some(Iter::empty())\n  fn() {\n    guard current_iter is Some(iter) else { None }\n    loop iter.next() {\n      Some(_) as elem => elem\n      None => {\n        guard self.next() is Some(x) else { None }\n        let iter = f(x)\n        current_iter = Some(iter)\n        continue iter.next()\n      }\n    }\n  }\n}\n\n///|\n/// `iter.map(f).flatten() == iter.flat_map(f)`\npub fn[X] Iter::flatten(self : Iter[Iter[X]]) -> Iter[X] {\n  self.flat_map(it => it)\n}\n\n///|\n/// Collects the elements of the iterator into a string.\n/// The old iterator `self` must not be used again after calling `join`.\npub fn Iter::join(self : Iter[String], sep : String) -> String {\n  let result = StringBuilder::new()\n  if self.next() is Some(x) {\n    result.write_string(x)\n    while self.next() is Some(x) {\n      result.write_string(sep)\n      result.write_string(x)\n    }\n  }\n  result.to_string()\n}\n\n///|\n/// Applies a function to each element of the iterator without modifying the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function to apply to each element of the iterator.\n///\n/// # Returns\n///\n/// The same iterator.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `tap`.\npub fn[X] Iter::tap(self : Iter[X], f : (X) -> Unit) -> Iter[X] {\n  fn() {\n    let result = self.next()\n    if result is Some(x) {\n      f(x)\n    }\n    result\n  }\n}\n\n///|\n/// Takes the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to take.\n///\n/// # Returns\n///\n/// A new iterator that contains the first `n` elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `take`.\npub fn[X] Iter::take(self : Iter[X], n : Int) -> Iter[X] {\n  let mut remaining = n\n  fn() {\n    guard remaining > 0 else { None }\n    let result = self.next()\n    if result is Some(_) {\n      remaining -= 1\n    }\n    result\n  }\n}\n\n///|\n/// Takes elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be taken.\n///\n/// # Returns\n///\n/// A new iterator that contains the elements as long as the predicate function returns `true`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `take_while`.\npub fn[X] Iter::take_while(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  let mut still_running = true\n  fn() {\n    guard still_running else { None }\n    let result = self.next()\n    if result is Some(x) && !f(x) {\n      still_running = false\n      None\n    } else {\n      result\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function upto the function returns `None`.\n/// The old iterator `self` must not be used again after calling `map_while`.\npub fn[X, Y] Iter::map_while(self : Iter[X], f : (X) -> Y?) -> Iter[Y] {\n  let mut still_running = true\n  fn() {\n    guard still_running else { None }\n    let src = self.next()\n    guard src is Some(x) else { None }\n    let result = f(x)\n    if result is None {\n      still_running = false\n    }\n    result\n  }\n}\n\n///|\n/// Skips the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to skip.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the first `n` elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `drop`.\npub fn[X] Iter::drop(self : Iter[X], n : Int) -> Iter[X] {\n  let mut remaining = n\n  fn() {\n    while remaining > 0 {\n      guard self.next() is Some(_) else { break None }\n      remaining -= 1\n    } else {\n      self.next()\n    }\n  }\n}\n\n///|\n/// Skips elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be skipped.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the elements as long as the predicate function returns `true`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `drop_while`.\npub fn[X] Iter::drop_while(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  let mut dropped = false\n  fn() {\n    if !dropped {\n      dropped = true\n      loop self.next() {\n        Some(x) if f(x) => continue self.next()\n        result => result\n      }\n    } else {\n      self.next()\n    }\n  }\n}\n\n///|\n/// Finds the first element in the iterator that satisfies the predicate function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element is the first element to be found.\n///\n/// # Returns\n///\n/// An `Option` that contains the first element that satisfies the predicate function, or `None` if no such element is found.\n///\n/// # Note\n/// The iterator `self` will advance past the returned element.\npub fn[X] Iter::find_first(self : Iter[X], f : (X) -> Bool) -> X? {\n  while self.next() is Some(x) {\n    if f(x) {\n      break Some(x)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Combines two iterators into one by appending the elements of the second iterator to the first.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterators.\n///\n/// # Arguments\n///\n/// * `self` - The first input iterator.\n/// * `other` - The second input iterator to be appended to the first.\n///\n/// # Returns\n///\n/// Returns a new iterator that contains the elements of `self` followed by the elements of `other`.\n///\n/// # Note\n/// The old iterator `self` and `other` must not be used again after calling `tap`.\npub fn[X] Iter::concat(self : Iter[X], other : Iter[X]) -> Iter[X] {\n  let mut in_first = true\n  fn() {\n    if in_first {\n      let result = self.next()\n      if result is None {\n        in_first = false\n        other.next()\n      } else {\n        result\n      }\n    } else {\n      other.next()\n    }\n  }\n}\n\n///|\npub impl[T] Add for Iter[T] with add(self, other) {\n  self.concat(other)\n}\n\n///|\n/// Collects the elements of the iterator into an array.\n/// The old iterator `self` must not be used again.\n#alias(collect)\npub fn[X] Iter::to_array(self : Iter[X]) -> Array[X] {\n  let result = []\n  while self.next() is Some(x) {\n    result.push(x)\n  }\n  result\n}\n\n///|\n#alias(iterator)\npub fn[X] Iter::iter(self : Iter[X]) -> Iter[X] {\n  self\n}\n\n///|\n#alias(iterator2)\npub fn[X] Iter::iter2(self : Iter[X]) -> Iter2[Int, X] {\n  let mut i = 0\n  Iter(() => {\n    guard self.next() is Some(elem) else { None }\n    let result = Some((i, elem))\n    i += 1\n    result\n  })\n}\n\n///|\n/// Returns the last element of the iterator, or `None` if the iterator is empty.\n/// The old iterator `self` must not be used again after calling `last`.\npub fn[X] Iter::last(self : Iter[X]) -> X? {\n  loop (None, self.next()) {\n    (last, None) => last\n    (_, Some(_) as x) => continue (x, self.next())\n  }\n}\n\n///|\n/// Inserts a separator element `sep` between each element of the iterator.\n///\n/// # Parameters\n///\n/// - `self` : The iterator to intersperse the separator into.\n/// - `sep` : The separator element to insert between each element of the iterator.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3].iter().intersperse(0).each(i => arr.push(i))\n///   assert_eq(arr, [1, 0, 2, 0, 3])\n/// }\n/// ```\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `intersperse`.\npub fn[X] Iter::intersperse(self : Iter[X], sep : X) -> Iter[X] {\n  enum State {\n    Init\n    Output_Elem(X)\n    Output_Sep\n  }\n  let mut state = Init\n  fn() {\n    match state {\n      Init => {\n        let result = self.next()\n        state = Output_Sep\n        result\n      }\n      Output_Elem(x) => {\n        state = Output_Sep\n        Some(x)\n      }\n      Output_Sep =>\n        // make sure we only output the separator when there is remaining element\n        match self.next() {\n          Some(x) => {\n            state = Output_Elem(x)\n            Some(sep)\n          }\n          None => None\n        }\n    }\n  }\n}\n\n///|\n#alias(\"_[_:_]\")\npub fn[X] Iter::sub(self : Iter[X], start? : Int = 0, end? : Int) -> Iter[X] {\n  match (start, end) {\n    (_..=0, None) => self\n    (_..=0, Some(end)) => self.take(end)\n    (start, None) => self.drop(start)\n    (start, Some(end)) => {\n      let mut index = 0\n      fn() {\n        if index >= end {\n          return None\n        }\n        while index < start {\n          guard self.next() is Some(_) else { return None }\n          index += 1\n        }\n        if index >= end {\n          return None\n        }\n        let result = self.next()\n        if result is Some(_) {\n          index += 1\n        }\n        result\n      }\n    }\n  }\n}\n\n///|\n/// Checks if the iterator contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `self` : The iterator to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the iterator contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = [1, 2, 3, 4, 5].iter()\n///   inspect(iter.contains(3), content=\"true\")\n///   inspect(iter.contains(6), content=\"false\")\n///   let iter = Iter::empty()\n///   inspect(iter.contains(1), content=\"false\")\n/// }\n/// ```\n///\n/// # Note\n/// The old iterator `self` will advance past the searched element.\npub fn[X : Eq] Iter::contains(self : Iter[X], value : X) -> Bool {\n  while self.next() is Some(x) {\n    if x == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Returns the nth element of the iterator, or `None` if the iterator is\n/// shorter than `n` elements.\n/// The iterator `self` will advance past the returned element.\npub fn[X] Iter::nth(self : Iter[X], n : Int) -> X? {\n  guard n >= 0 else { None }\n  for i = 0; i < n; i = i + 1 {\n    guard self.next() is Some(_) else { break None }\n  } else {\n    self.next()\n  }\n}\n\n///|\npub fn[X : Compare] Iter::maximum(self : Iter[X]) -> X? {\n  guard self.next() is Some(x) else { return None }\n  let mut res = x\n  while self.next() is Some(x) {\n    if x > res {\n      res = x\n    }\n  }\n  Some(res)\n}\n\n///|\npub fn[X : Compare] Iter::minimum(self : Iter[X]) -> X? {\n  guard self.next() is Some(x) else { return None }\n  let mut res = x\n  while self.next() is Some(x) {\n    if x < res {\n      res = x\n    }\n  }\n  Some(res)\n}\n\n///|\n/// This type is used for `for _, _ in ..` loop\n/// (`for .. in` loop with two loop variables),\n/// and should not be used directly in general.\n#alias(Iterator2, deprecated=\"The name `Iterator2` is deprecated, use `Iter2` instead. Note that if you have defined `iterator2()` method to support `for .. in` loop, you should also rename `iterator2()` to `iter2()`. See https://github.com/moonbitlang/core/pull/3127 for more details.\")\npub(all) struct Iter2[X, Y](Iter[(X, Y)])\n\n///|\npub fn[X, Y] Iter2::new(f : () -> (X, Y)?) -> Iter2[X, Y] {\n  Iter2(Iter::new(f))\n}\n\n///|\n#alias(iterator)\npub fn[X, Y] Iter2::iter(self : Iter2[X, Y]) -> Iter[(X, Y)] {\n  self.0\n}\n\n///|\n#alias(iterator2)\npub fn[X, Y] Iter2::iter2(self : Iter2[X, Y]) -> Iter2[X, Y] {\n  self\n}\n\n///|\npub fn[X, Y] Iter2::next(self : Iter2[X, Y]) -> (X, Y)? {\n  self.0.next()\n}\n\n///|\npub impl[X : Show, Y : Show] Show for Iter2[X, Y] with output(self, logger) {\n  self.0.output(logger)\n}\n\n///|\npub fn[X, Y] Iter2::run(\n  self : Iter2[X, Y],\n  f : (X, Y) -> IterResult,\n) -> IterResult {\n  while self.0.next() is Some((x, y)) {\n    guard f(x, y) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  }\n}\n\n///|\npub fn[X, Y] Iter2::each(self : Iter2[X, Y], f : (X, Y) -> Unit) -> Unit {\n  self.0.each(pair => f(pair.0, pair.1))\n}\n\n///|\npub fn[X, Y] Iter2::concat(\n  self : Iter2[X, Y],\n  other : Iter2[X, Y],\n) -> Iter2[X, Y] {\n  Iter2(self.0.concat(other.0))\n}\n\n///|\npub fn[X, Y] Iter2::to_array(self : Iter2[X, Y]) -> Array[(X, Y)] {\n  self.0.to_array()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 42\n///   ignore(x) // Explicitly ignore the value\n///   let mut sum = 0\n///   ignore([1, 2, 3].iter().each(x => sum = sum + x)) // Ignore the Unit return value of each()\n/// }\n/// ```\npub fn[T] ignore(t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = arr1\n///   let arr3 = [1, 2, 3]\n///   inspect(physical_equal(arr1, arr2), content=\"true\") // Same object\n///   inspect(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// }\n/// ```\npub fn[T] physical_equal(a : T, b : T) -> Bool = \"%refeq\"\n\n///|\n#callsite(autofill(loc))\npub fn[T] abort(string : String, loc~ : SourceLoc) -> T {\n  @abort.abort(\n    (\n      $|\\{string}\n      $|  at \\{loc}\n      $|\n    ),\n  )\n}\n\n///|\npub fn[T] panic() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(not(true), content=\"false\")\n///   inspect(not(false), content=\"true\")\n/// }\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true == true, content=\"true\")\n///   inspect(false == true, content=\"false\")\n///   inspect(true == false, content=\"false\")\n///   inspect(false == false, content=\"true\")\n/// }\n/// ```\npub impl Eq for Bool with equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let t = true\n///   let f = false\n///   // This usage is deprecated, use compare() instead\n///   inspect(t.compare(f), content=\"1\")\n///   inspect(f.compare(t), content=\"-1\")\n///   inspect(t.compare(t), content=\"0\")\n/// }\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.compare(false), content=\"1\") // true > false\n///   inspect(false.compare(true), content=\"-1\") // false < true\n///   inspect(true.compare(true), content=\"0\") // true = true\n/// }\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b : Bool = Bool::default()\n///   inspect(b, content=\"false\")\n/// }\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42, content=\"-42\")\n///   inspect(42, content=\"42\")\n///   inspect(2147483647, content=\"2147483647\") // negating near min value\n/// }\n/// ```\npub impl Neg for Int with neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 + 1, content=\"43\")\n///   inspect(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// }\n/// ```\npub impl Add for Int with add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 10\n///   inspect(a - b, content=\"32\")\n///   let max = 2147483647 // Int maximum value\n///   inspect(max - -1, content=\"-2147483648\") // Overflow case\n/// }\n/// ```\npub impl Sub for Int with sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 * 2, content=\"84\")\n///   inspect(-10 * 3, content=\"-30\")\n///   let max = 2147483647 // Int.max_value\n///   inspect(max * 2, content=\"-2\") // Overflow wraps around\n/// }\n/// ```\npub impl Mul for Int with mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(10 / 3, content=\"3\") // truncates towards zero\n///   inspect(-10 / 3, content=\"-3\")\n///   inspect(10 / -3, content=\"-3\")\n/// }\n/// ```\npub impl Div for Int with div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(7 % 3, content=\"1\")\n///   inspect(-7 % 3, content=\"-1\")\n///   inspect(7 % -3, content=\"1\")\n/// }\n/// ```\npub impl Mod for Int with mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = -1 // All bits are 1\n///   let b = 0 // All bits are 0\n///   inspect(a.lnot(), content=\"0\")\n///   inspect(b.lnot(), content=\"-1\")\n/// }\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0 // 11110000\n///   let y = 0xAA // 10101010\n///   inspect(x & y, content=\"160\") // 10100000 = 160\n/// }\n/// ```\npub impl BitAnd for Int with land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// }\n/// ```\npub impl BitOr for Int with lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n///   inspect(x ^ x, content=\"0\") // XOR with self gives 0\n/// }\n/// ```\npub impl BitXOr for Int with lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = -4\n///   inspect(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// }\n/// ```\npub impl Shl for Int with shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -16\n///   inspect(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n///   let p = 16\n///   inspect(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// }\n/// ```\npub impl Shr for Int with shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 42\n///   inspect(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Equivalent to x << 3\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -4 // Binary: 11111...11100\n///   let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n///   inspect(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -16\n///   inspect(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -1024\n///   inspect(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0\n///   inspect(x.ctz(), content=\"32\") // All bits are zero\n///   let y = 1\n///   inspect(y.ctz(), content=\"0\") // No trailing zeros\n///   let z = 16\n///   inspect(z.ctz(), content=\"4\") // Binary: ...10000\n/// }\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0b1011 // Binary: 1011 (3 bits set)\n///   inspect(x.popcnt(), content=\"3\")\n///   let y = -1 // All bits set in two's complement\n///   inspect(y.popcnt(), content=\"32\")\n/// }\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 == 42, content=\"true\")\n///   inspect(42 == -42, content=\"false\")\n/// }\n/// ```\npub impl Eq for Int with equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 != 42, content=\"false\")\n///   inspect(42 != -42, content=\"true\")\n/// }\n/// ```\npub impl Eq for Int with not_equal(self : Int, other : Int) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 24\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub impl Compare for Int with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Int with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Int with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Int with op_ge(x, y) = \"%i32.ge\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let neg = -42\n///   let zero = 0\n///   let pos = 42\n///   inspect(neg.is_neg(), content=\"true\")\n///   inspect(zero.is_neg(), content=\"false\")\n///   inspect(pos.is_neg(), content=\"false\")\n/// }\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = Int::default()\n///   inspect(x, content=\"0\")\n/// }\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_double(), content=\"42\")\n///   let neg = -42\n///   inspect(neg.to_double(), content=\"-42\")\n/// }\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(UInt::trunc_double(42.75), content=\"42\")\n/// }\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   let neg = -1\n///   inspect(pos.reinterpret_as_uint(), content=\"42\")\n///   inspect(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   inspect(pos.to_uint64(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// }\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42.0, content=\"-42\")\n///   inspect(42.0, content=\"42\")\n///   inspect(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// }\n/// ```\npub impl Neg for Double with neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding +∞ and -∞, returns NaN\n/// * If adding ±∞ with any finite number, returns ±∞\n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 + 3.7, content=\"6.2\")\n///   inspect(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// }\n/// ```\npub impl Add for Double with add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5.0\n///   let b = 3.0\n///   inspect(a - b, content=\"2\")\n///   inspect(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// }\n/// ```\npub impl Sub for Double with sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 * 2.0, content=\"5\")\n///   inspect(-2.0 * 3.0, content=\"-6\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan * 1.0, content=\"NaN\")\n/// }\n/// ```\npub impl Mul for Double with mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(6.0 / 2.0, content=\"3\")\n///   inspect(-6.0 / 2.0, content=\"-3\")\n///   inspect(1.0 / 0.0, content=\"Infinity\")\n/// }\n/// ```\npub impl Div for Double with div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(4.0.sqrt(), content=\"2\")\n///   inspect(0.0.sqrt(), content=\"0\")\n///   inspect((-1.0).sqrt(), content=\"NaN\")\n/// }\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan == nan, content=\"false\") // NaN != NaN\n/// }\n/// ```\npub impl Eq for Double with equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n/// Compares two double-precision floating-point numbers for inequality following\n/// IEEE 754 rules. Returns `true` if the numbers are not equal.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if the numbers are not equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan != nan, content=\"true\") // NaN != NaN is true\n/// }\n/// ```\npub impl Eq for Double with not_equal(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\npub impl Compare for Double with op_lt(x, y) = \"%f64.lt\"\n\n///|\npub impl Compare for Double with op_le(x, y) = \"%f64.le\"\n\n///|\npub impl Compare for Double with op_gt(x, y) = \"%f64.gt\"\n\n///|\npub impl Compare for Double with op_ge(x, y) = \"%f64.ge\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Double::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(Double::convert_uint(n), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(Double::convert_uint(max), content=\"4294967295\")\n/// }\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('A'.to_int(), content=\"65\") // ASCII value of 'A'\n///   inspect('あ'.to_int(), content=\"12354\") // Unicode code point of 'あ'\n/// }\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let c = 'A'\n///   inspect(c.to_uint(), content=\"65\") // ASCII value of 'A'\n///   let emoji = '🤣'\n///   inspect(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// }\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n#deprecated(\"Use `Int::unsafe_to_char` instead, and use `Int::to_char` for safe conversion\")\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for Char with equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if the characters represent different Unicode code points,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for Char with not_equal(self : Char, other : Char) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('a'.compare('b'), content=\"-1\")\n///   inspect('b'.compare('a'), content=\"1\")\n///   inspect('a'.compare('a'), content=\"0\")\n/// }\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\npub impl Compare for Char with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Char with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Char with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Char with op_ge(x, y) = \"%i32.ge\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(Char::default().to_string() == \"\\u0000\")\n/// }\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes[1], content=\"b'\\\\x02'\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn Bytes::at(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes.unsafe_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.length(), content=\"3\")\n///   let empty = b\"\"\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::make(3, b'\\xFF')\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"\\xff\\xff\\xff\"\n///     ),\n///   )\n///   let empty = Bytes::make(0, b'\\x00')\n///   inspect(empty, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::new(3)\n///   inspect(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n///   let bytes = Bytes::new(0)\n///   inspect(bytes, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258 // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let neg = -1 // In binary: all 1's\n///   inspect(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\npub fn Int::unsafe_to_char(self : Int) -> Char = \"%char_from_int\"\n\n///|\npub fn Int::to_char(self : Int) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..=0x10FFFF) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258UL // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// }\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Panics if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] FixedArray::at(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.unsafe_get(1), content=\"42\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_set(\n  self : FixedArray[T],\n  idx : Int,\n  val : T,\n) -> Unit = \"%fixedarray.unsafe_set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 0)\n///   arr.set(1, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[T] FixedArray::set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn[T] FixedArray::length(self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[0], content=\"42\")\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\n/// \n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the FixedArray[Int] in this case). \n/// One should use makei() instead which creates an object for each index.\npub fn[T] FixedArray::make(len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello\".length(), content=\"5\")\n///   inspect(\"🤣\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n///   inspect(\"\".length(), content=\"0\") // Empty string\n/// }\n/// ```\n#alias(charcode_length, deprecated)\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n///\n/// Parameters:\n///\n/// * `string` : The string to access.\n/// * `index` : The position in the string from which to retrieve the code unit.\n///\n/// This method has O(1) complexity.\n#deprecated(\"Use `_[_]` instead which returns UInt16\")\npub fn String::charcode_at(self : String, idx : Int) -> Int = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn String::at(self : String, idx : Int) -> UInt16 = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str = \"B🤣🤣C\"\n///   inspect(str.unsafe_charcode_at(0), content=\"66\") // 'B'\n///   inspect(str.unsafe_charcode_at(1), content=\"55358\") // First surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(2), content=\"56611\") // Second surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(3), content=\"55358\") // First surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(4), content=\"56611\") // Second surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(5), content=\"67\") // 'C'\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\n#internal(unsafe, \"Panic if index is out of bounds.\")\n#doc(hidden)\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hello = \"Hello\"\n///   let world = \" World!\"\n///   inspect(hello + world, content=\"Hello World!\")\n///   inspect(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// }\n/// ```\npub impl Add for String with add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str1 = \"hello\"\n///   let str2 = \"hello\"\n///   let str3 = \"world\"\n///   inspect(str1 == str2, content=\"true\")\n///   inspect(str1 == str3, content=\"false\")\n/// }\n/// ```\npub impl Eq for String with equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s = \"hello\"\n///   inspect(s.to_string(), content=\"hello\")\n/// }\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n// For internal use only\n\n///|\npriv type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_int(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a character.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns the character corresponding to the byte value.\npub fn Byte::to_char(self : Byte) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_int64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   inspect(a.reinterpret_as_int(), content=\"42\")\n///   let b = 4294967295U // maximum value of UInt (2^32 - 1)\n///   inspect(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 100U\n///   inspect(a + b, content=\"142\")\n///\n///   // Demonstrate overflow behavior\n///   let max = 4294967295U // UInt::max_value\n///   inspect(max + 1U, content=\"0\")\n/// }\n/// ```\npub impl Add for UInt with add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5U\n///   let b = 3U\n///   inspect(a - b, content=\"2\")\n///   let c = 3U\n///   let d = 5U\n///   inspect(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// }\n/// ```\npub impl Sub for UInt with sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3U\n///   let b = 4U\n///   inspect(a * b, content=\"12\")\n///   let max = 4294967295U\n///   inspect(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// }\n/// ```\npub impl Mul for UInt with mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 5U\n///   inspect(a / b, content=\"8\") // Using infix operator\n/// }\n/// ```\npub impl Div for UInt with div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 17U\n///   let b = 5U\n///   inspect(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n///   inspect(7U % 4U, content=\"3\")\n/// }\n/// ```\npub impl Mod for UInt with mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for UInt with equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n/// Compares two unsigned 32-bit integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for UInt with not_equal(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 24U\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\npub impl Compare for UInt with op_lt(x, y) = \"%u32.lt\"\n\n///|\npub impl Compare for UInt with op_le(x, y) = \"%u32.le\"\n\n///|\npub impl Compare for UInt with op_gt(x, y) = \"%u32.gt\"\n\n///|\npub impl Compare for UInt with op_ge(x, y) = \"%u32.ge\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // 1111_0000_1111_0000\n///   let b = 0xFF00U // 1111_1111_0000_0000\n///   inspect(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// }\n/// ```\npub impl BitAnd for UInt with land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// }\n/// ```\npub impl BitOr for UInt with lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xFF00U // Binary: 1111_1111_0000_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// }\n/// ```\npub impl BitXOr for UInt with lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF00U // Binary: 1111_1111_0000_0000\n///   inspect(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// }\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Using the recommended operator\n///   let y = 8U\n///   inspect(y << 1, content=\"16\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0000000U\n///   inspect(x >> 4, content=\"251658240\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 0xFFFFFFFFU\n///   inspect(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// }\n/// ```\npub impl Shl for UInt with shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n///   inspect(x >> 24, content=\"255\") // 0x000000FF\n///   let x = 0xFF000000U\n///   inspect(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// }\n/// ```\npub impl Shr for UInt with shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(0U.clz(), content=\"32\")\n///   inspect(1U.clz(), content=\"31\")\n///   inspect(0x80000000U.clz(), content=\"0\")\n/// }\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 24U // Binary: ...011000\n///   inspect(x.ctz(), content=\"3\") // 3 trailing zeros\n///   let y = 0U\n///   inspect(y.ctz(), content=\"32\") // All bits are zero\n/// }\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n///   inspect(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// }\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint64(), content=\"42\")\n///   let max = 4294967295U // Maximum value of UInt\n///   inspect(max.to_uint64(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258U // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let big = 4294967295U // Maximum value of UInt\n///   inspect(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_double(), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(max.to_double(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n#deprecated(\"Use `Float::from_int` instead\")\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_int` instead\")\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_uint` instead\")\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::from_byte` instead\")\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// TODO: enable skip_current_package=false\n#deprecated(\"Use `Float::from_double` instead\", skip_current_package=true)\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n#deprecated(\"Use `Float::from_uint` instead\")\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n#deprecated(\"Use `Int16::from_int` instead\")\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n#deprecated(\"Use `Int16::from_byte` instead\")\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(42)\n///   inspect(x.to_int(), content=\"42\")\n///   let max = Int::to_uint16(65535) // maximum value of UInt16\n///   inspect(max.to_int(), content=\"65535\")\n/// }\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n///   inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// }\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit unsigned integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit unsigned integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint16(), content=\"42\")\n///   let max = 4294967295U\n///   inspect(max.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536U\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn UInt::to_uint16(self : UInt) -> UInt16 {\n  self.reinterpret_as_int().to_uint16()\n}\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_uint16(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_uint16(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_uint16(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Performs multiplication between two byte values. The result is truncated to\n/// fit within the byte range.\n///\n/// Parameters:\n///\n/// * `self` : The first byte operand in the multiplication.\n/// * `that` : The second byte operand in the multiplication.\n///\n/// Returns the product of the two bytes, truncated to fit within the byte range\n/// (0-255).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b'\\x02'\n///   let b = b'\\x03'\n///   inspect(a * b, content=\"b'\\\\x06'\") // 2 * 3 = 6\n///   let c = b'\\xFF'\n///   inspect(c * c, content=\"b'\\\\x01'\") // 255 * 255 = 65025, truncated to 1\n/// }\n/// ```\npub impl Mul for Byte with mul(self : Byte, that : Byte) -> Byte {\n  (self.to_int() * that.to_int()).to_byte()\n}\n\n///|\n/// Performs division operation between two bytes by converting them to integers,\n/// performing the division, and converting the result back to a byte.\n///\n/// Parameters:\n///\n/// * `self` : The dividend byte value.\n/// * `that` : The divisor byte value.\n///\n/// Returns the quotient of the division as a byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b'\\xFF' // 255\n///   let b = b'\\x03' // 3\n///   inspect(a / b, content=\"b'\\\\x55'\") // 255 / 3 = 85 (0x55)\n/// }\n/// ```\npub impl Div for Byte with div(self : Byte, that : Byte) -> Byte {\n  (self.to_int() / that.to_int()).to_byte()\n}\n\n///|\npub impl Mod for Byte with mod(self : Byte, that : Byte) -> Byte {\n  (self.to_int() % that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values for equality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are equal, otherwise `false`.\npub impl Eq for Byte with equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() == that.to_int()\n}\n\n///|\n/// Compares two `Byte` values for inequality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are not equal, otherwise `false`.\npub impl Eq for Byte with not_equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() != that.to_int()\n}\n\n///|\n/// Adds two `Byte` values together and returns the result as a `Byte`.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to be added.\n/// - `byte2` : The second `Byte` value to be added.\n///\n/// Returns the sum of `byte1` and `byte2` as a `Byte`.\npub impl Add for Byte with add(self : Byte, that : Byte) -> Byte {\n  (self.to_int() + that.to_int()).to_byte()\n}\n\n///|\n/// Subtracts the second byte from the first byte and returns the result as a\n/// byte.\n///\n/// Parameters:\n///\n/// - `self` : The byte from which the second byte will be subtracted.\n/// - `that` : The byte to subtract from the first byte.\n///\n/// Returns the result of the subtraction as a byte.\npub impl Sub for Byte with sub(self : Byte, that : Byte) -> Byte {\n  (self.to_int() - that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values and returns an integer indicating their relative\n/// order.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to compare.\n/// - `byte2` : The second `Byte` value to compare.\n///\n/// Returns an integer where:\n/// - A value less than 0 indicates that `byte1` is less than `byte2`.\n/// - A value of 0 indicates that `byte1` is equal to `byte2`.\n/// - A value greater than 0 indicates that `byte1` is greater than `byte2`.\npub impl Compare for Byte with compare(self : Byte, that : Byte) -> Int {\n  self.to_int().compare(that.to_int())\n}\n\n///|\npub impl Compare for Byte with op_lt(x, y) {\n  x.to_int() < y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_le(x, y) {\n  x.to_int() <= y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_gt(x, y) {\n  x.to_int() > y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_ge(x, y) {\n  x.to_int() >= y.to_int()\n}\n\n///|\nfn alphabet(x : Int) -> String {\n  match x {\n    0 => \"0\"\n    1 => \"1\"\n    2 => \"2\"\n    3 => \"3\"\n    4 => \"4\"\n    5 => \"5\"\n    6 => \"6\"\n    7 => \"7\"\n    8 => \"8\"\n    9 => \"9\"\n    10 => \"A\"\n    11 => \"B\"\n    12 => \"C\"\n    13 => \"D\"\n    14 => \"E\"\n    15 => \"F\"\n    _ => abort(\"impossible\")\n  }\n}\n\n///|\n/// Converts a `Byte` to its string representation in hexadecimal format.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns a `String` representing the `Byte` in the format `b'\\xHH'`, where\n/// `HH` is the hexadecimal representation of the byte.\npub fn Byte::to_string(self : Byte) -> String {\n  let i = self.to_int()\n  let hi = alphabet(i / 16)\n  let lo = alphabet(i % 16)\n  \"b'\\\\x\\{hi}\\{lo}'\"\n}\n\n///|\n/// Implements the `Hash` trait for `Byte` type by providing a `hash_combine`\n/// method that combines a byte value with a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The byte value to be hashed.\n/// * `hasher` : The hasher object that will be used to combine the byte value\n/// into its internal state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub impl Hash for Byte with hash_combine(self, hasher) {\n  hasher.combine_byte(self)\n}\n\n///|\n/// Returns the default value for a `Byte`, which is `b'\\x00'`.\n///\n/// Parameters:\n///\n/// - None\n///\n/// Returns the default `Byte` value, which is `b'\\x00'`.\npub impl Default for Byte with default() {\n  b'\\x00'\n}\n\n///|\n/// Performs a bitwise NOT operation on the given `Byte` value.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to apply the bitwise NOT operation on.\n///\n/// Returns the result of the bitwise NOT operation as a `Byte`.\npub fn Byte::lnot(self : Byte) -> Byte {\n  self.to_int().lnot().to_byte()\n}\n\n///|\n/// Performs a bitwise AND operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to perform the bitwise AND operation with.\n/// - `byte2` : The second `Byte` value to perform the bitwise AND operation\n///   with.\n///\n/// Returns the result of the bitwise AND operation as a `Byte`.\npub impl BitAnd for Byte with land(self : Byte, that : Byte) -> Byte {\n  (self.to_int() & that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise OR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns a new `Byte` value resulting from the bitwise OR operation.\npub impl BitOr for Byte with lor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() | that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise XOR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns the result of the bitwise XOR operation as a `Byte`.\npub impl BitXOr for Byte with lxor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() ^ that.to_int()).to_byte()\n}\n\n///|\n/// Converts a `Byte` to a `UInt`.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns the `UInt` representation of the `Byte`.\npub fn Byte::to_uint(self : Byte) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n/// Converts a byte value to an unsigned 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns an unsigned 64-bit integer representation of the byte value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_uint64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_uint64(self : Byte) -> UInt64 {\n  self.to_uint().to_uint64()\n}\n\n///|\n/// Counts the number of 1-bits (population count) in the byte using bitwise operations.\n///\n/// Parameters:\n///\n/// * `self` : The byte value whose 1-bits are to be counted.\n///\n/// Returns the number of 1-bits in the byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\x0F'\n///   inspect(b.popcnt(), content=\"4\")\n/// }\n/// ```\npub fn Byte::popcnt(self : Byte) -> Int {\n  let mut n = self\n  n = (n & 0x55) + ((n >> 1) & 0x55)\n  n = (n & 0x33) + ((n >> 2) & 0x33)\n  n = (n & 0x0F) + ((n >> 4) & 0x0F)\n  n.to_int()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the left by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the shift operation.\npub impl Shl for Byte with shl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the right by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value whose bits are to be shifted.\n/// - `count` : The number of bit positions to shift the `byte` value to the\n///   right.\n///\n/// Returns the resulting `Byte` value after the bitwise right shift operation.\npub impl Shr for Byte with shr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let map = { 3: \"three\", 8: \"eight\", 1: \"one\" }\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// }\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : ArrayView[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  for e in arr {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map : Map[String, Int] = Map::new()\n///   map.set(\"key\", 42)\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   map.set(\"key\", 24) // update existing key\n///   inspect(map.get(\"key\"), content=\"Some(24)\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"key\": 42 }\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   inspect(map.get(\"nonexistent\"), content=\"None\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n#alias(\"_[_]\")\npub fn[K : Hash + Eq, V] Map::at(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   map.remove(\"a\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.length(), content=\"1\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  self.remove_with_hash(key, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::remove_with_hash(\n  self : Map[K, V],\n  key : K,\n  hash : Int,\n) -> Unit {\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\n#alias(size, deprecated)\npub fn[K, V] Map::length(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\n#alias(iterator, deprecated)\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, value, next, .. }) => {\n        curr_entry = next\n        Some((key, value))\n      }\n      None => None\n    }\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  self.iter()\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, next, .. }) => {\n        curr_entry = next\n        Some(key)\n      }\n      None => None\n    }\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ value, next, .. }) => {\n        curr_entry = next\n        Some(value)\n      }\n      None => None\n    }\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n#alias(from_iterator, deprecated)\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  while iter.next() is Some((k, v)) {\n    m.set(k, v)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Merges two maps into a new map. Returns a new map containing all key-value\n/// pairs from both maps. When both maps contain the same key, the value from\n/// `other` takes precedence. The iteration order follows the order of `self`\n/// followed by new entries from `other`.\n///\n/// This is a pure operation - it does not modify either of the input maps.\n///\n/// Parameters:\n///\n/// * `self` : The first map.\n/// * `other` : The second map whose values take precedence in case of key\n/// conflicts.\n///\n/// Returns a new linked hash map containing all entries from both maps.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   let merged = map1.merge(map2)\n///   @json.inspect(merged, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge(self : Map[K, V], other : Map[K, V]) -> Map[K, V] {\n  let result = self.copy()\n  result.merge_in_place(other)\n  result\n}\n\n///|\n/// Merges another map into this map in-place. Updates the current map by adding\n/// all key-value pairs from `other`. When both maps contain the same key, the\n/// value from `other` overwrites the value in this map. New entries from `other`\n/// are added at the end, preserving the original order of `self` and appending\n/// new keys from `other`.\n///\n/// This is a mutating operation - it modifies the receiver map.\n///\n/// Parameters:\n///\n/// * `self` : The map to be modified.\n/// * `other` : The map whose entries will be added to `self`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   map1.merge_in_place(map2)\n///   @json.inspect(map1, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge_in_place(\n  self : Map[K, V],\n  other : Map[K, V],\n) -> Unit {\n  loop other.head {\n    Some({ key, value, next, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Retains only the key-value pairs that satisfy the given predicate function.\n/// This method modifies the map in-place, removing all entries for which\n/// the predicate returns `false`. The order of remaining elements is preserved.\n///\n/// Parameters:\n///\n/// * `self` : The map to be filtered.\n/// * `predicate` : A function that takes a key and value as arguments and returns\n/// `true` if the key-value pair should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 }\n///   map.retain((_k, v) => v % 2 == 0) // Keep only even values\n///   inspect(map.length(), content=\"2\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.get(\"b\"), content=\"Some(2)\")\n///   inspect(map.get(\"c\"), content=\"None\")\n///   inspect(map.get(\"d\"), content=\"Some(4)\")\n/// }\n/// ```\n#locals(f)\npub fn[K, V] Map::retain(self : Map[K, V], f : (K, V) -> Bool) -> Unit {\n  loop (self.head, false) {\n    (Some({ key, value, next, prev: idx, .. }), remove_prev) => {\n      if remove_prev {\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n      continue (next, !f(key, value))\n    }\n    (None, remove_prev) =>\n      if remove_prev {\n        let idx = self.tail\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n  }\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///\n///   // Update existing value\n///   map.update(\"a\", fn(v) {\n///     match v {\n///       Some(x) => Some(x + 10)\n///       None => Some(0)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2}\n///     ),\n///   )\n///\n///   // Insert new value\n///   map.update(\"c\", fn(v) {\n///     match v {\n///       Some(x) => Some(x)\n///       None => Some(3)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2, \"c\": 3}\n///     ),\n///   )\n///\n///   // Remove existing value\n///   map.update(\"b\", fn(_) { None })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"c\": 3}\n///     ),\n///   )\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n\n// Special handling for Views as accessors\n\n///|\nfn StringView::equal_to_string(self : Self, other : String) -> Bool {\n  let str = self.str()\n  let start = self.start()\n  let end = self.end()\n  let len = end - start\n  guard len == other.length() else { return false }\n  if physical_equal(str, other) && self.start() == 0 {\n    return true\n  }\n  for i in 0..<len {\n    guard str.unsafe_charcode_at(self.start() + i) ==\n      other.unsafe_charcode_at(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\nfn BytesView::equal_to_bytes(self : Self, other : Bytes) -> Bool {\n  let self_len = self.len()\n  let start = self.start()\n  guard self_len == other.length() else { return false }\n  for i in 0..<self_len {\n    guard self.bytes().unsafe_get(i + start) == other.unsafe_get(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Retrieves the value associated with a `BytesView` key in a map with `Bytes` keys.\n///\n/// This function allows efficient lookups using `BytesView` without creating a new `Bytes` object.\n/// It's particularly useful when working with byte slices or subranges of existing byte arrays.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `Bytes` keys to search in.\n/// * `key` : A `BytesView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { b\"hello\": 1, b\"world\": 2 }\n///   let bytes = b\"prefix_hello_suffix\"\n///   let view = bytes[7:12] // view of \"hello\"\n///   inspect(map.get_from_bytes(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_bytes(map : Self[Bytes, V], key : BytesView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_bytes(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n\n///|\n/// Retrieves the value associated with a `StringView` key in a map with `String` keys.\n///\n/// This function allows efficient lookups using `StringView` without creating a new `String` object.\n/// It's particularly useful when working with substrings or string slices.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `String` keys to search in.\n/// * `key` : A `StringView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"hello\": 1, \"world\": 2 }\n///   let str = \"say hello to everyone\"\n///   let view = str.view(start_offset=4, end_offset=9) // view of \"hello\"\n///   inspect(map.get_from_string(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_string(map : Self[String, V], key : StringView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_string(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// }\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// }\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// }\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// }\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n///   inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_surrogate(), content=\"true\") // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\") // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") // 😀 emoji codepoint\n/// }\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n\n///|\n/// Computes the absolute value of an integer.\n///\n/// Parameters:\n///\n/// * `self` : The integer whose absolute value is to be computed.\n///\n/// Returns the absolute value of the integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Int::abs(42), content=\"42\")\n///   inspect(Int::abs(-42), content=\"42\")\n///   inspect(Int::abs(0), content=\"0\")\n/// }\n/// ```\npub fn Int::abs(self : Int) -> Int {\n  if self < 0 {\n    -self\n  } else {\n    self\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n#alias(or, deprecated)\npub fn[T] Option::unwrap_or(self : T?, default : T) -> T {\n  match self {\n    None => default\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n///\n/// Default is lazily evaluated\n#alias(or_else, deprecated)\npub fn[T] Option::unwrap_or_else(\n  self : T?,\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    None => default()\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the result of the `T::default()`.\n#alias(or_default, deprecated)\npub fn[T : Default] Option::unwrap_or_default(self : T?) -> T {\n  match self {\n    None => T::default()\n    Some(t) => t\n  }\n}\n\n///|\npub impl[X : Compare] Compare for X? with compare(self, other) {\n  match (self, other) {\n    (Some(x), Some(y)) => x.compare(y)\n    (Some(_), None) => 1\n    (None, Some(_)) => -1\n    (None, None) => 0\n  }\n}\n\n///|\n#alias(or_error, deprecated)\npub fn[T, Err : Error] Option::unwrap_or_error(\n  self : T?,\n  err : Err,\n) -> T raise Err {\n  match self {\n    Some(v) => v\n    None => raise err\n  }\n}\n\n///|\n/// `None`\npub impl[X] Default for X? with default() {\n  None\n}\n\n///|\n#alias(iterator, deprecated)\npub fn[T] Option::iter(self : T?) -> Iter[T] {\n  match self {\n    Some(v) => Iter::singleton(v)\n    None => Iter::empty()\n  }\n}\n\n///|\n/// Maps the value of an `Option` using a provided function.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map(x => x * 2), Some(10))\n///   let b = None\n///   assert_eq(b.map(x => x * 2), None)\n/// }\n/// ```\npub fn[T, U] Option::map(self : T?, f : (T) -> U raise?) -> U? raise? {\n  match self {\n    Some(t) => Some(f(t))\n    None => None\n  }\n}\n\n///|\n/// Returns the provided default result (if none), or applies a function to the contained value (if any).\n/// Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or(3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or(\n  self : T?,\n  default : U,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Computes a default function result (if none), or applies a different function to the contained value (if any).\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or_else(() => 3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or_else(\n  self : T?,\n  default : () -> U raise?,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default()\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Binds an option to a function that returns another option.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Option::Some(5)\n///   let r1 = a.bind(x => Some(x * 2))\n///   assert_eq(r1, Some(10))\n///   let b : Int? = None\n///   let r2 = b.bind(x => Some(x * 2))\n///   assert_eq(r2, None)\n/// }\n/// ```\npub fn[T, U] Option::bind(self : T?, f : (T) -> U? raise?) -> U? raise? {\n  match self {\n    Some(t) => f(t)\n    None => None\n  }\n}\n\n///|\n#deprecated(\"use `option.bind(x => x)` instead\")\npub fn[T] Option::flatten(self : T??) -> T? {\n  match self {\n    Some(inner) => inner\n    None => None\n  }\n}\n\n///|\n/// Checks if the option is empty.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_empty(self : T?) -> Bool {\n  self is None\n}\n\n///|\n/// Filters the option by applying the given predicate function `f`.\n///\n/// If the predicate function `f` returns `true` for the value contained in the option,\n/// the same option is returned. Otherwise, `None` is returned.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let x = Some(3)\n///   assert_eq(x.filter(x => x > 5), None)\n///   assert_eq(x.filter(x => x < 5), Some(3))\n/// }\n/// ```\npub fn[T] Option::filter(self : T?, f : (T) -> Bool raise?) -> T? raise? {\n  match self {\n    Some(t) => if f(t) { self } else { None }\n    None => None\n  }\n}\n\n///|\n/// Checks if the option contains a value.\n#deprecated(\"use `x is Some(_)` instead\")\npub fn[T] Option::is_some(self : T?) -> Bool {\n  self is Some(_)\n}\n\n///|\n/// Checks if the option is None.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_none(self : T?) -> Bool {\n  self is None\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] ReadOnlyArray::unsafe_reinterpret_to_fixed_array(\n  self : ReadOnlyArray[T],\n) -> FixedArray[T] = \"%identity\"\n\n///|\nfn[T] unsafe_reinterpret_from_fixed_array(\n  arr : FixedArray[T],\n) -> ReadOnlyArray[T] = \"%identity\"\n\n///|\n#alias(\"_[_]\")\npub fn[T] ReadOnlyArray::at(self : ReadOnlyArray[T], index : Int) -> T {\n  self.unsafe_reinterpret_to_fixed_array()[index]\n}\n\n///|\n/// Creates an ReadOnlyArray from a dynamic Array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let dynamic_array = [1, 2, 3, 4, 5]\n///   let immut_array = ReadOnlyArray::from_array(dynamic_array)\n///   inspect(immut_array[0], content=\"1\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::from_array(array : ArrayView[T]) -> ReadOnlyArray[T] {\n  unsafe_reinterpret_from_fixed_array(FixedArray::from_array(array))\n}\n\n///|\n/// Creates an ReadOnlyArray from an iterator.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let iter = [1, 2, 3].iter()\n///   let immut_array = ReadOnlyArray::from_iter(iter)\n///   inspect(immut_array[0], content=\"1\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] ReadOnlyArray::from_iter(iter : Iter[T]) -> ReadOnlyArray[T] {\n  unsafe_reinterpret_from_fixed_array(FixedArray::from_iter(iter))\n}\n\n///|\n/// Creates an ReadOnlyArray by applying a function to each index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let immut_array = ReadOnlyArray::makei(3, fn(i) { i * 2 })\n///   inspect(immut_array[1], content=\"2\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::makei(\n  length : Int,\n  value : (Int) -> T raise?,\n) -> ReadOnlyArray[T] raise? {\n  unsafe_reinterpret_from_fixed_array(FixedArray::makei(length, value))\n}\n\n///|\n/// Safely retrieves an element at the specified index.\n/// Returns Some(element) if the index is valid, None otherwise.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.get(1), content=\"Some(2)\")\n///   inspect(arr.get(5), content=\"None\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::get(self : ReadOnlyArray[T], index : Int) -> T? {\n  self.unsafe_reinterpret_to_fixed_array().get(index)\n}\n\n///|\n/// Returns the length of the ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::length(self : ReadOnlyArray[T]) -> Int {\n  self.unsafe_reinterpret_to_fixed_array().length()\n}\n\n///|\n/// Checks if the ReadOnlyArray is empty.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let empty_arr : ReadOnlyArray[Int] = []\n///   inspect(empty_arr.is_empty(), content=\"true\")\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::is_empty(self : ReadOnlyArray[T]) -> Bool {\n  self.unsafe_reinterpret_to_fixed_array().is_empty()\n}\n\n///|\n/// Returns the last element of the ReadOnlyArray, if any.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.last(), content=\"Some(3)\")\n///   let empty_arr : ReadOnlyArray[Int] = []\n///   inspect(empty_arr.last(), content=\"None\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::last(self : ReadOnlyArray[T]) -> T? {\n  self.unsafe_reinterpret_to_fixed_array().last()\n}\n\n///|\n/// Creates an iterator over the elements of the ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each(fn(x) { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[T] ReadOnlyArray::iter(self : ReadOnlyArray[T]) -> Iter[T] {\n  self.unsafe_reinterpret_to_fixed_array().iter()\n}\n\n///|\n/// Creates an iterator that yields both indices and values.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each(fn(i, x) { sum = sum + i + x })\n///   inspect(sum, content=\"63\") // (0+10) + (1+20) + (2+30) = 63\n/// }\n/// ```\npub fn[T] ReadOnlyArray::iter2(self : ReadOnlyArray[T]) -> Iter2[Int, T] {\n  self.unsafe_reinterpret_to_fixed_array().iter2()\n}\n\n///|\n/// Iterates over each element in the ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let result = []\n///   arr.each(fn(x) { result.push(x * 2) })\n///   inspect(result, content=\"[2, 4, 6]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::each(\n  self : ReadOnlyArray[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().each(f)\n}\n\n///|\n/// Iterates over each element with its index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let result = []\n///   arr.eachi(fn(i, x) { result.push((i, x)) })\n///   inspect(result, content=\"[(0, 10), (1, 20), (2, 30)]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::eachi(\n  self : ReadOnlyArray[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().eachi(f)\n}\n\n///|\n/// Iterates over each element in reverse order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let result = []\n///   arr.rev_each(fn(x) { result.push(x) })\n///   inspect(result, content=\"[3, 2, 1]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::rev_each(\n  self : ReadOnlyArray[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_each(f)\n}\n\n///|\n/// Iterates over each element in reverse order with its index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let result = []\n///   arr.rev_eachi(fn(i, x) { result.push((i, x)) })\n///   inspect(result, content=\"[(0, 30), (1, 20), (2, 10)]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::rev_eachi(\n  self : ReadOnlyArray[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_eachi(f)\n}\n\n///|\n/// Creates a new ReadOnlyArray by applying a function to each element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let doubled = arr.map(fn(x) { x * 2 })\n///   inspect(doubled[0], content=\"2\")\n///   inspect(doubled[2], content=\"6\")\n/// }\n/// ```\npub fn[T, U] ReadOnlyArray::map(\n  self : ReadOnlyArray[T],\n  f : (T) -> U raise?,\n) -> ReadOnlyArray[U] raise? {\n  unsafe_reinterpret_from_fixed_array(\n    self.unsafe_reinterpret_to_fixed_array().map(f),\n  )\n}\n\n///|\n/// Creates a new ReadOnlyArray by applying a function to each element with its index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let result = arr.mapi(fn(i, x) { i + x })\n///   inspect(result[1], content=\"21\") // index 1 + value 20 = 21\n/// }\n/// ```\npub fn[T, U] ReadOnlyArray::mapi(\n  self : ReadOnlyArray[T],\n  f : (Int, T) -> U raise?,\n) -> ReadOnlyArray[U] raise? {\n  unsafe_reinterpret_from_fixed_array(\n    self.unsafe_reinterpret_to_fixed_array().mapi(f),\n  )\n}\n\n///|\n/// Folds the ReadOnlyArray from left to right.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let sum = arr.fold(init=0, fn(acc, x) { acc + x })\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::fold(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().fold(init~, f)\n}\n\n///|\n/// Folds the ReadOnlyArray from right to left.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let result = arr.rev_fold(init=\"\", fn(acc, x) { acc + x.to_string() })\n///   inspect(result, content=\"321\") // Processed in reverse order\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::rev_fold(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_fold(init~, f)\n}\n\n///|\n/// Folds the ReadOnlyArray from left to right with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [2, 3]\n///   let sum = arr.foldi(init=0, fn(i, acc, x) { acc + i * x })\n///   inspect(sum, content=\"3\") // 0 + (0*2) + (1*3) = 3\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::foldi(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().foldi(init~, f)\n}\n\n///|\n/// Folds the ReadOnlyArray from right to left with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [2, 3]\n///   let sum = arr.rev_foldi(init=0, fn(i, acc, x) { acc + i * x })\n///   inspect(sum, content=\"2\") // 0 + (1*3) + (0*2) = 3\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::rev_foldi(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_foldi(init~, f)\n}\n\n///|\n/// Returns a new ReadOnlyArray with elements in reverse order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let reversed = arr.rev()\n///   inspect(reversed[0], content=\"5\")\n///   inspect(reversed[4], content=\"1\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::rev(self : ReadOnlyArray[T]) -> ReadOnlyArray[T] {\n  unsafe_reinterpret_from_fixed_array(\n    self.unsafe_reinterpret_to_fixed_array().rev(),\n  )\n}\n\n///|\n/// Searches for an element and returns its index if found.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // Returns first occurrence\n///   inspect(arr.search(5), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::search(\n  self : ReadOnlyArray[T],\n  value : T,\n) -> Int? {\n  self.unsafe_reinterpret_to_fixed_array().search(value)\n}\n\n///|\n/// Checks if the ReadOnlyArray contains a specific value.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.contains(2), content=\"true\")\n///   inspect(arr.contains(4), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::contains(\n  self : ReadOnlyArray[T],\n  value : T,\n) -> Bool {\n  self.unsafe_reinterpret_to_fixed_array().contains(value)\n}\n\n///|\n/// Checks if the ReadOnlyArray is sorted in non-decreasing order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.is_sorted(), content=\"true\")\n///   let arr2 : ReadOnlyArray[Int] = [2, 1]\n///   inspect(arr2.is_sorted(), content=\"false\")\n/// }\n/// ```\npub fn[T : Compare] ReadOnlyArray::is_sorted(self : ReadOnlyArray[T]) -> Bool {\n  self.unsafe_reinterpret_to_fixed_array().is_sorted()\n}\n\n///|\n/// Checks if the ReadOnlyArray starts with the given prefix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let prefix : ReadOnlyArray[Int] = [1, 2]\n///   inspect(arr.starts_with(prefix), content=\"true\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::starts_with(\n  self : ReadOnlyArray[T],\n  prefix : ReadOnlyArray[T],\n) -> Bool {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .starts_with(prefix.unsafe_reinterpret_to_fixed_array())\n}\n\n///|\n/// Checks if the ReadOnlyArray ends with the given suffix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let suffix : ReadOnlyArray[Int] = [4, 5]\n///   inspect(arr.ends_with(suffix), content=\"true\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::ends_with(\n  self : ReadOnlyArray[T],\n  suffix : ReadOnlyArray[T],\n) -> Bool {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .ends_with(suffix.unsafe_reinterpret_to_fixed_array())\n}\n\n///|\n/// Checks if all elements satisfy the given predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [2, 4, 6]\n///   inspect(arr.all(fn(x) { x % 2 == 0 }), content=\"true\")\n///   let arr2 : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr2.all(fn(x) { x % 2 == 0 }), content=\"false\")\n/// }\n/// ```\n#alias(every)\npub fn[T] ReadOnlyArray::all(\n  self : ReadOnlyArray[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  self.unsafe_reinterpret_to_fixed_array().all(f)\n}\n\n///|\n/// Checks if any element satisfies the given predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 3, 5]\n///   inspect(arr.any(fn(x) { x % 2 == 0 }), content=\"false\")\n///   let arr2 : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr2.any(fn(x) { x % 2 == 0 }), content=\"true\")\n/// }\n/// ```\n#alias(exists)\npub fn[T] ReadOnlyArray::any(\n  self : ReadOnlyArray[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  self.unsafe_reinterpret_to_fixed_array().any(f)\n}\n\n///|\n/// Performs binary search on a sorted ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 3, 5, 7, 9]\n///   inspect(arr.binary_search(5), content=\"Ok(2)\")\n///   inspect(arr.binary_search(6), content=\"Err(3)\")\n/// }\n/// ```\npub fn[T : Compare] ReadOnlyArray::binary_search(\n  self : ReadOnlyArray[T],\n  value : T,\n) -> Result[Int, Int] {\n  self.unsafe_reinterpret_to_fixed_array().binary_search(value)\n}\n\n///|\n/// Performs binary search using a custom comparison function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 3, 5, 7, 9]\n///   let result = arr.binary_search_by(fn(x) { x.compare(5) })\n///   inspect(result, content=\"Ok(2)\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::binary_search_by(\n  self : ReadOnlyArray[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self.unsafe_reinterpret_to_fixed_array().binary_search_by(cmp)\n}\n\n///|\n/// Creates a view of a subarray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let view = arr.sub(start=1, end=4)\n///   inspect(view[0], content=\"2\")\n///   inspect(view[2], content=\"4\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] ReadOnlyArray::sub(\n  self : ReadOnlyArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  match end {\n    None => self.unsafe_reinterpret_to_fixed_array().sub(start~)\n    Some(e) => self.unsafe_reinterpret_to_fixed_array().sub(start~, end=e)\n  }\n}\n\n///|\n/// Joins string elements with a separator.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[String] = [\"hello\", \"world\", \"moon\"]\n///   inspect(arr.join(\",\"), content=\"hello,world,moon\")\n///   inspect(arr.join(\" \"), content=\"hello world moon\")\n/// }\n/// ```\npub fn ReadOnlyArray::join(\n  self : ReadOnlyArray[String],\n  separator : StringView,\n) -> String {\n  self.unsafe_reinterpret_to_fixed_array().join(separator)\n}\n\n///|\n/// Default implementation for ReadOnlyArray - returns empty array.\npub impl[T] Default for ReadOnlyArray[T] with default() {\n  unsafe_reinterpret_from_fixed_array(FixedArray::default())\n}\n\n///|\n/// Show implementation for ReadOnlyArray.\npub impl[T : Show] Show for ReadOnlyArray[T] with output(self, logger) {\n  self.unsafe_reinterpret_to_fixed_array().output(logger)\n}\n\n///|\n/// ToJson implementation for ReadOnlyArray.\npub impl[T : ToJson] ToJson for ReadOnlyArray[T] with to_json(self) {\n  self.unsafe_reinterpret_to_fixed_array().to_json()\n}\n\n///|\npub impl[T : Eq] Eq for ReadOnlyArray[T] with equal(self, other) {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .equal(other.unsafe_reinterpret_to_fixed_array())\n}\n\n///|\npub impl[T : Hash] Hash for ReadOnlyArray[T] with hash_combine(self, hasher) {\n  self.unsafe_reinterpret_to_fixed_array().hash_combine(hasher)\n}\n\n///|\npub impl[T : Compare] Compare for ReadOnlyArray[T] with compare(self, other) {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .compare(other.unsafe_reinterpret_to_fixed_array())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Maps the value of a Result if it is `Ok` into another, otherwise returns the `Err` value unchanged.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, Unit] = Ok(6)\n///   let y = x.map((v : Int) => v * 7)\n///   assert_eq(y, Ok(42))\n/// }\n/// ```\npub fn[T, E, U] Result::map(self : Result[T, E], f : (T) -> U) -> Result[U, E] {\n  match self {\n    Ok(value) => Ok(f(value))\n    Err(err) => Err(err)\n  }\n}\n\n///|\ntest \"map\" {\n  let x : Result[Int, Unit] = Ok(6)\n  let y = x.map((v : Int) => v * 7)\n  let z : Result[Int, Int] = Err(3)\n  let w = z.map((v : Int) => v * 7)\n  assert_eq(y, Ok(42))\n  assert_eq(w, Err(3))\n}\n\n///|\n/// Maps the value of a Result if it is `Err` into another, otherwise returns the `Ok` value unchanged.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Err(\"error\")\n///   let y = x.map_err((v : String) => v + \"!\")\n///   assert_eq(y, Err(\"error!\"))\n/// }\n/// ```\npub fn[T, E, F] Result::map_err(\n  self : Result[T, E],\n  f : (E) -> F,\n) -> Result[T, F] {\n  match self {\n    Ok(value) => Ok(value)\n    Err(err) => Err(f(err))\n  }\n}\n\n///|\ntest \"map_err\" {\n  let x : Result[Int, String] = Err(\"error\")\n  let y = x.map_err((v : String) => v + \"!\")\n  let z : Result[Int, Int] = Ok(6)\n  let w = z.map_err((v : Int) => v + 6)\n  assert_eq(y, Err(\"error!\"))\n  assert_eq(w, Ok(6))\n}\n\n///|\n/// Return the contained `Ok` value or the provided default.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(3)\n///   let y : Result[Int, String] = Err(\"error\")\n///   assert_eq(x.unwrap_or(5), 3)\n///   assert_eq(y.unwrap_or(5), 5)\n/// }\n/// ```\n#alias(or)\npub fn[T, E] Result::unwrap_or(self : Result[T, E], default : T) -> T {\n  match self {\n    Ok(value) => value\n    Err(_) => default\n  }\n}\n\n///|\ntest \"unwrap_or\" {\n  let x : Result[Int, String] = Ok(3)\n  let y : Result[Int, String] = Err(\"error\")\n  assert_eq(x.unwrap_or(5), 3)\n  assert_eq(y.unwrap_or(5), 5)\n}\n\n///|\n/// Return the contained `Ok` value or the provided default.\n///\n/// Default is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(3)\n///   let y : Result[Int, String] = Err(\"error\")\n///   assert_eq(x.unwrap_or_else(() => 5), 3)\n///   assert_eq(y.unwrap_or_else(() => 5), 5)\n/// }\n/// ```\n#alias(or_else)\npub fn[T, E] Result::unwrap_or_else(\n  self : Result[T, E],\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    Ok(value) => value\n    Err(_) => default()\n  }\n}\n\n///|\ntest \"unwrap_or_else\" {\n  let x : Result[Int, String] = Ok(3)\n  let y : Result[Int, String] = Err(\"error\")\n  assert_eq(x.unwrap_or_else(() => 5), 3)\n  assert_eq(y.unwrap_or_else(() => 5), 5)\n}\n\n///|\n/// Flatten a `Result` of `Result` into a single `Result`.\n///\n/// If the outer `Result` is an `Ok`, the inner `Result` is returned. If the outer `Result` is an `Err`, the inner `Result` is ignored and the `Err` is returned.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Result[Int, String], String] = Ok(Ok(6))\n///   let y = x.flatten()\n///   assert_eq(y, Ok(6))\n/// }\n/// ```\npub fn[T, E] Result::flatten(self : Result[Result[T, E], E]) -> Result[T, E] {\n  match self {\n    Ok(value) => value\n    Err(err) => Err(err)\n  }\n}\n\n///|\ntest \"flatten\" {\n  let x : Result[Result[Int, String], String] = Ok(Ok(6))\n  let y = x.flatten()\n  let z : Result[Result[Int, String], String] = Err(\"error\")\n  let w = z.flatten()\n  assert_eq(y, Ok(6))\n  assert_eq(w, Err(\"error\"))\n}\n\n///|\n/// Binds a result to a function that returns another result.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(6)\n///   let y = x.bind((v : Int) => Ok(v * 7))\n///   assert_eq(y, Ok(42))\n/// }\n/// ```\npub fn[T, E, U] Result::bind(\n  self : Result[T, E],\n  g : (T) -> Result[U, E],\n) -> Result[U, E] {\n  match self {\n    Ok(value) => g(value)\n    Err(err) => Err(err)\n  }\n}\n\n///|\ntest \"bind\" {\n  let x : Result[Int, String] = Ok(6)\n  let y = x.bind((v : Int) => Ok(v * 7))\n  assert_eq(y, Ok(42))\n}\n\n///|\n/// Converts a `Result` to an `Option`.\n///\n/// Converts `Ok` to `Some` and `Err` to `None`.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(6)\n///   let y = x.to_option()\n///   assert_eq(y, Some(6))\n/// }\n/// ```\npub fn[T, E] Result::to_option(self : Result[T, E]) -> T? {\n  match self {\n    Ok(value) => Some(value)\n    Err(_) => None\n  }\n}\n\n///|\ntest \"to_option\" {\n  let x : Result[Int, String] = Ok(6)\n  let y : Result[Int, String] = Err(\"error\")\n  let z = x.to_option()\n  let w = y.to_option()\n  assert_eq(z, Some(6))\n  assert_eq(w, None)\n}\n\n///|\npub impl[T : Compare, E : Compare] Compare for Result[T, E] with compare(\n  self : Result[T, E],\n  other : Result[T, E],\n) -> Int {\n  match (self, other) {\n    (Ok(x), Ok(y)) => x.compare(y)\n    (Ok(_), Err(_)) => -1\n    (Err(_), Ok(_)) => 1\n    (Err(x), Err(y)) => x.compare(y)\n  }\n}\n\n///|\ntest \"compare\" {\n  let ok1 = Result::Ok(1)\n  let ok2 = Result::Ok(2)\n  let err1 = Result::Err(1)\n  let err2 = Result::Err(2)\n  assert_eq(0, ok1.compare(ok1))\n  assert_eq(0, err2.compare(Result::Err(2)))\n  assert_eq(-1, ok1.compare(ok2))\n  assert_eq(1, ok2.compare(ok1))\n  assert_eq(-1, err1.compare(err2))\n  assert_eq(1, err2.compare(err1))\n  assert_eq(-1, ok2.compare(err1))\n  assert_eq(1, err1.compare(ok2))\n}\n\n///|\npub fn[T, E] Result::unwrap(self : Result[T, E]) -> T {\n  match self {\n    Ok(x) => x\n    Err(_) => abort(\"called `Result::unwrap()` on an `Err` value\")\n  }\n}\n\n///|\n/// Extracts the error value from a `Result[T, E]`. If the `Result` is `Ok`,\n/// aborts with a runtime error message.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to extract the error from.\n///\n/// Returns the error value of type `E` if `self` is `Err(e)`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : Result[Int, String] = Err(\"error message\")\n///   inspect(err.unwrap_err(), content=\"error message\")\n/// }\n/// ```\npub fn[T, E] Result::unwrap_err(self : Result[T, E]) -> E {\n  match self {\n    Ok(_) => abort(\"called `Result::unwrap_err()` on an `Ok` value\")\n    Err(e) => e\n  }\n}\n\n///|\ntest \"show\" {\n  let ok : Result[_, String] = Ok(\"hello\")\n  inspect(\n    ok,\n    content=(\n      #|Ok(\"hello\")\n    ),\n  )\n  let err : Result[String, _] = Err(\"world\")\n  inspect(\n    err,\n    content=(\n      #|Err(\"world\")\n    ),\n  )\n}\n\n///|\n/// Return the contained `Ok` value or the result of the `T::default()`.\npub fn[T : Default, E] Result::unwrap_or_default(self : Result[T, E]) -> T {\n  match self {\n    Ok(value) => value\n    Err(_) => T::default()\n  }\n}\n\n///|\ntest \"unwrap_or_default\" {\n  let x : Result[Int, String] = Ok(3)\n  let y : Result[Int, String] = Err(\"error\")\n  assert_eq(x.unwrap_or_default(), 3)\n  assert_eq(y.unwrap_or_default(), 0)\n}\n\n///|\npub fn[T, E : Error] Result::unwrap_or_error(self : Result[T, E]) -> T raise E {\n  match self {\n    Ok(x) => x\n    Err(e) => raise e\n  }\n}\n\n///|\ntest \"unwrap exn\" {\n  (try\n    (Err(Failure(\"This is serious\")) : Result[Unit, Failure]).unwrap_or_error()\n    |> Ok\n  catch {\n    Failure(msg) => Err(msg)\n  })\n  |> inspect(\n    content=(\n      #|Err(\"This is serious\")\n    ),\n  )\n}\n\n///|\npub impl[T : Eq, E : Eq] Eq for Result[T, E] with equal(self, other) {\n  match (self, other) {\n    (Ok(x), Ok(y)) => x == y\n    (Err(x), Err(y)) => x == y\n    _ => false\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub fn Byte::to_hex(b : Byte) -> String {\n  fn to_hex_digit(i : Byte) -> Char {\n    if i < 10 {\n      (i + '0').to_char()\n    } else {\n      (i + 'a' - 10).to_char()\n    }\n  }\n\n  [to_hex_digit(b / 16), to_hex_digit(b % 16)]\n}\n\n///|\ntest \"to_hex_digit\" {\n  inspect(Byte::to_hex(b'\\xee'), content=\"ee\")\n  inspect(Byte::to_hex(b'\\xf3'), content=\"f3\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          // has to be ascii  \n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_string(code.to_byte().to_hex())\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the offset (charcode index) of the first occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn StringView::find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_find(self, str)\n  } else {\n    boyer_moore_horspool_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack left to right, matching the needle at each position\nfn brute_force_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let forward_len = haystack_len - needle_len\n  let mut i = 0\n  while i <= forward_len {\n    // Skip positions where first charcode doesn't match\n    while i <= forward_len && haystack.unsafe_charcode_at(i) != needle_first {\n      i += 1\n    }\n    if i <= forward_len {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i += 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for string search (left to right)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  // Build skip table\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i in 0..<(needle_len - 1) {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = needle_len - 1 - i\n  }\n  for i = 0\n      i <= haystack_len - needle_len\n      i = i + skip_table[haystack.unsafe_charcode_at(i + needle_len - 1) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..=(needle_len - 1) {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\ntest \"boyer_moore_horspool_find edge cases\" {\n  inspect(boyer_moore_horspool_find(\"abc\"[:], \"\"[:]), content=\"Some(0)\")\n  inspect(boyer_moore_horspool_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\ntest \"boyer_moore_horspool_rev_find edge cases\" {\n  inspect(boyer_moore_horspool_rev_find(\"abc\"[:], \"\"[:]), content=\"Some(3)\")\n  inspect(boyer_moore_horspool_rev_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\n/// Returns the offset of the first occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn String::find(self : String, str : StringView) -> Int? {\n  self[:].find(str)\n}\n\n///|\ntest \"find\" {\n  inspect(\"hello\".find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".find(\"l\"), content=\"Some(2)\")\n  inspect(\"hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"world\"), content=\"None\")\n  inspect(\"\".find(\"\"), content=\"Some(0)\")\n  inspect(\"\".find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"aaa\".find(\"aa\"), content=\"Some(0)\")\n  inspect(\"😀😀\".find(\"😀\"), content=\"Some(0)\")\n  inspect(\n    (\"😀😀aa\".repeat(20) + \"😀😀😀😀\").find(\"😀😀😀😀\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"😀😀😀😀\" + \"😀😀aa\".repeat(20)).find(\"😀😀😀😀\"),\n    content=\"Some(0)\",\n  )\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn StringView::find_by(self : StringView, pred : (Char) -> Bool) -> Int? {\n  for i, c in self {\n    if pred(c) {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn String::find_by(self : String, pred : (Char) -> Bool) -> Int? {\n  self[:].find_by(pred)\n}\n\n///|\ntest \"find_by\" {\n  inspect(\"hello\".find_by(c => c == 'o'), content=\"Some(4)\")\n  inspect(\"hello\".find_by(c => c == 'l'), content=\"Some(2)\")\n  inspect(\"hello\".find_by(c => c == 'z'), content=\"None\")\n  inspect(\"\".find_by(c => c == 'a'), content=\"None\")\n  inspect(\"hello\".find_by(c => c is ('0'..='9')), content=\"None\")\n  inspect(\"hello123\".find_by(c => c is ('0'..='9')), content=\"Some(5)\")\n  inspect(\"hello\".find_by(c => c is ('A'..='Z')), content=\"None\")\n  inspect(\"Hello\".find_by(c => c is ('A'..='Z')), content=\"Some(0)\")\n  inspect(\"αβγ\".find_by(c => c == 'β'), content=\"Some(1)\")\n  inspect(\"😀😁😂\".find_by(c => c == '😂'), content=\"Some(2)\")\n}\n\n///|\n/// Returns the offset of the last occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn StringView::rev_find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_rev_find(self, str)\n  } else {\n    boyer_moore_horspool_rev_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack right to left, matching the needle at each position\nfn brute_force_rev_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let mut i = haystack_len - needle_len\n  while i >= 0 {\n    // Skip positions where first charcode doesn't match\n    while i >= 0 && haystack.unsafe_charcode_at(i) != needle_first {\n      i -= 1\n    }\n    if i >= 0 {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i -= 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for reverse string search (right to left)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_rev_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i = needle_len - 1; i > 0; i = i - 1 {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = i\n  }\n  for i = haystack_len - needle_len\n      i >= 0\n      i = i - skip_table[haystack.unsafe_charcode_at(i) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..<needle_len {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset (charcode index) of the last occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn String::rev_find(self : String, str : StringView) -> Int? {\n  self[:].rev_find(str)\n}\n\n///|\ntest \"rev_find\" {\n  inspect(\"hello\".rev_find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".rev_find(\"l\"), content=\"Some(3)\")\n  inspect(\"hello\".rev_find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"\"), content=\"Some(5)\")\n  inspect(\"hello\".rev_find(\"world\"), content=\"None\")\n  inspect(\"\".rev_find(\"\"), content=\"Some(0)\")\n  inspect(\"\".rev_find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".rev_find(\"hello\"), content=\"Some(6)\")\n  inspect(\"aaa\".rev_find(\"aa\"), content=\"Some(1)\")\n  inspect(\"😀😀\".rev_find(\"😀\"), content=\"Some(2)\")\n  inspect(\n    (\"😀😀aa\".repeat(20) + \"😀😀😀😀\").rev_find(\"😀😀😀😀\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"😀😀😀😀\" + \"😀😀aa\".repeat(20)).rev_find(\"😀😀😀😀\"),\n    content=\"Some(4)\",\n  )\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn StringView::has_suffix(self : StringView, str : StringView) -> Bool {\n  self.rev_find(str) is Some(i) && i == self.length() - str.length()\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn String::has_suffix(self : String, str : StringView) -> Bool {\n  self[:].has_suffix(str)\n}\n\n///|\ntest \"has_suffix\" {\n  inspect(\"hello\".has_suffix(\"lo\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"hello\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_suffix(\"hel\"), content=\"false\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n  inspect(\"\".has_suffix(\"a\"), content=\"false\")\n  inspect(\"hello world\".has_suffix(\"world\"), content=\"true\")\n  inspect(\"😀😀\".has_suffix(\"😀\"), content=\"true\")\n  inspect(\"😀😀\".has_suffix(\"😀😀\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn StringView::has_prefix(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(i) && i == 0\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn String::has_prefix(self : String, str : StringView) -> Bool {\n  self[:].has_prefix(str)\n}\n\n///|\ntest \"has_prefix\" {\n  inspect(\"hello\".has_prefix(\"h\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"he\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"lo\"), content=\"false\")\n  inspect(\"\".has_prefix(\"\"), content=\"true\")\n  inspect(\"\".has_prefix(\"a\"), content=\"false\")\n  inspect(\"😀hello\".has_prefix(\"😀\"), content=\"true\")\n  inspect(\"😀😃hello\".has_prefix(\"😀😃\"), content=\"true\")\n  inspect(\"😀hello\".has_prefix(\"😃\"), content=\"false\")\n  inspect(\"hello😀\".has_prefix(\"😀\"), content=\"false\")\n}\n\n///|\n/// Removes the given suffix from the string if it exists.\n///\n/// Returns `Some(prefix)` if the string ends with the given suffix,\n/// where `prefix` is the string without the suffix.\n/// Returns `None` if the string does not end with the suffix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n///   inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_suffix)\npub fn String::strip_suffix(self : String, suffix : StringView) -> StringView? {\n  self[:].strip_suffix(suffix)\n}\n\n///|\ntest \"strip_prefix\" {\n  inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n  inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_prefix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"😀hello\".strip_prefix(\"😀\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"😀😃hello\".strip_prefix(\"😀😃\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\ntest \"strip_suffix\" {\n  inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n  inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_suffix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"hello😀\".strip_suffix(\"😀\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello😀😃\".strip_suffix(\"😀😃\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\n/// Removes the given prefix from the string if it exists.\n///\n/// Returns `Some(suffix)` if the string starts with the given prefix,\n/// where `suffix` is the string without the prefix.\n/// Returns `None` if the string does not start with the prefix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n///   inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_prefix)\npub fn String::strip_prefix(self : String, prefix : StringView) -> StringView? {\n  self[:].strip_prefix(prefix)\n}\n\n///|\n/// Removes the given prefix from the view if it exists.\n///\n/// Returns `Some(suffix)` if the view starts with the given prefix,\n/// where `suffix` is the view without the prefix.\n/// Returns `None` if the view does not start with the prefix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(view.strip_prefix(\"hi \"), content=\"None\")\n///   inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_prefix)\npub fn StringView::strip_prefix(\n  self : StringView,\n  prefix : StringView,\n) -> StringView? {\n  let prefix_len = prefix.length()\n  if self.length() >= prefix_len && self.view(end_offset=prefix_len) == prefix {\n    Some(self.view(start_offset=prefix_len))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given suffix from the view if it exists.\n///\n/// Returns `Some(prefix)` if the view ends with the given suffix,\n/// where `prefix` is the view without the suffix.\n/// Returns `None` if the view does not end with the suffix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(view.strip_suffix(\" moon\"), content=\"None\")\n///   inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_suffix)\npub fn StringView::strip_suffix(\n  self : StringView,\n  suffix : StringView,\n) -> StringView? {\n  let self_len = self.length()\n  let suffix_len = suffix.length()\n  if self_len >= suffix_len &&\n    self.view(start_offset=self_len - suffix_len) == suffix {\n    Some(self.view(end_offset=self_len - suffix_len))\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts the View into an array of Chars.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"Hello🤣xa\"[1:-1]\n///   let chars = view.to_array()\n///   inspect(chars, content=\"['e', 'l', 'l', 'o', '🤣', 'x']\")\n/// }\n/// ```\npub fn StringView::to_array(self : StringView) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n#deprecated(\"Check `@encoding/utf8.encode`\")\n#coverage.skip\npub fn StringView::to_bytes(self : StringView) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self.data(), self.start_offset(), self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\ntest \"View::strip_prefix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(view.strip_prefix(\"hi \"), content=\"None\")\n  inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_prefix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_prefix(\"a\"), content=\"None\")\n  let unicode_view = \"😀hello😃\"[:]\n  inspect(unicode_view.strip_prefix(\"😀\"), content=\"Some(\\\"hello😃\\\")\")\n  inspect(unicode_view.strip_prefix(\"😃\"), content=\"None\")\n}\n\n///|\ntest \"View::strip_suffix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(view.strip_suffix(\" moon\"), content=\"None\")\n  inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_suffix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_suffix(\"a\"), content=\"None\")\n  let unicode_view = \"😀hello😃\"[:]\n  inspect(unicode_view.strip_suffix(\"😃\"), content=\"Some(\\\"😀hello\\\")\")\n  inspect(unicode_view.strip_suffix(\"😀\"), content=\"None\")\n}\n\n///|\ntest \"View::to_array\" {\n  let view = \"Hello🤣\"[:]\n  let chars = view.to_array()\n  assert_eq(chars, ['H', 'e', 'l', 'l', 'o', '🤣'])\n  let empty_view = \"\"[:]\n  let empty_chars = empty_view.to_array()\n  assert_eq(empty_chars, [])\n  let sub_view = \"Hello World\"[6:11] // \"World\"\n  let sub_chars = sub_view.to_array()\n  assert_eq(sub_chars, ['W', 'o', 'r', 'l', 'd'])\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn StringView::contains(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(_)\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn String::contains(self : String, str : StringView) -> Bool {\n  self[:].contains(str)\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn StringView::contains_any(self : StringView, chars~ : StringView) -> Bool {\n  match chars {\n    [] => false\n    [c] => self.contains_char(c) // specialize for single character\n    _ =>\n      for c in self {\n        if chars.contains_char(c) {\n          break true\n        }\n      } else {\n        false\n      }\n  }\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn String::contains_any(self : String, chars~ : StringView) -> Bool {\n  self[:].contains_any(chars~)\n}\n\n///|\ntest \"contains\" {\n  inspect(\"hello\".contains(\"o\"), content=\"true\")\n  inspect(\"hello\".contains(\"l\"), content=\"true\")\n  inspect(\"hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"hello\".contains(\"h\"), content=\"true\")\n  inspect(\"hello\".contains(\"\"), content=\"true\")\n  inspect(\"hello\".contains(\"world\"), content=\"false\")\n  inspect(\"\".contains(\"\"), content=\"true\")\n  inspect(\"\".contains(\"a\"), content=\"false\")\n  inspect(\"hello hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"aaa\".contains(\"aa\"), content=\"true\")\n  inspect(\"😀😀\".contains(\"😀\"), content=\"true\")\n}\n\n///|\ntest \"contains_any\" {\n  inspect(\"hello\".contains_any(chars=\"h\"), content=\"true\")\n  inspect(\"hello\".contains_any(chars=\"xyz\"), content=\"false\")\n  inspect(\"hello\".contains_any(chars=\"\"), content=\"false\")\n  inspect(\"\".contains_any(chars=\"abc\"), content=\"false\")\n  inspect(\"😀😃\".contains_any(chars=\"😄😀\"), content=\"true\")\n  inspect(\"hello\"[:].contains_any(chars=\"eo\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn StringView::contains_char(self : StringView, c : Char) -> Bool {\n  let len = self.length()\n  // Check empty\n  guard len > 0 else { return false }\n  let c = c.to_int()\n  if c <= 0xFFFF {\n    // Search BMP\n    for i in 0..<len {\n      if self.unsafe_charcode_at(i) == c {\n        return true\n      }\n    }\n  } else {\n    // Check insufficient\n    guard len >= 2 else { return false }\n    // Calc surrogate pair\n    let adj = c - 0x10000\n    let high = 0xD800 + (adj >> 10)\n    let low = 0xDC00 + (adj & 0x3FF)\n    // Search surrogate pair\n    let mut i = 0\n    while i < len - 1 {\n      if self.unsafe_charcode_at(i) == high {\n        i += 1\n        if self.unsafe_charcode_at(i) == low {\n          return true\n        }\n      }\n      i += 1\n    }\n  }\n  false\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn String::contains_char(self : String, c : Char) -> Bool {\n  self[:].contains_char(c)\n}\n\n///|\ntest \"contains_char\" {\n  inspect(\"hello\".contains_char('h'), content=\"true\")\n  inspect(\"hello\".contains_char('e'), content=\"true\")\n  inspect(\"hello\".contains_char('l'), content=\"true\")\n  inspect(\"hello\".contains_char('o'), content=\"true\")\n  inspect(\"hello\".contains_char('x'), content=\"false\")\n  inspect(\"\".contains_char('a'), content=\"false\")\n  inspect(\"hello world\".contains_char(' '), content=\"true\")\n  inspect(\"hello world\".contains_char('w'), content=\"true\")\n  inspect(\"😀😀\".contains_char('😀'), content=\"true\")\n  inspect(\"😀😀\".contains_char('😃'), content=\"false\")\n  inspect(\"hello\".contains_char((104).unsafe_to_char()), content=\"true\") // 'h' is 104 in ASCII\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_start(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [c, .. rest] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim_start(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_start(chars~)\n}\n\n///|\ntest \"trim_start\" {\n  inspect(\"hello\".trim_start(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim_start(chars=\"he\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"eh\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_start(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_start(chars=\"a\"), content=\"\")\n  inspect(\"   hello\".trim_start(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_start(chars=\"helo\"), content=\" world\")\n  inspect(\"😀😀hello\".trim_start(chars=\"😀\"), content=\"hello\")\n  inspect(\"😀😃hello\".trim_start(chars=\"😀😃\"), content=\"hello\")\n  inspect(\"aaaabc\".trim_start(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim_start(chars=\"a\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_end(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [.. rest, c] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n// TODO(upstream): label_migration warning does not apply to the current package\n// TODO: make chars optional with default value of whitespace characters\n#label_migration(chars, alias=char_set)\npub fn String::trim_end(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_end(chars~)\n}\n\n///|\ntest \"trim_end\" {\n  inspect(\"hello\".trim_end(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim_end(chars=\"lo\"), content=\"he\")\n  inspect(\"hello\".trim_end(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_end(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_end(chars=\"a\"), content=\"\")\n  inspect(\"hello   \".trim_end(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_end(chars=\"dlrow \"), content=\"he\")\n  inspect(\"hello😀😀\".trim_end(chars=\"😀\"), content=\"hello\")\n  inspect(\"hello😀😃\".trim_end(chars=\"😀😃\"), content=\"hello\")\n  inspect(\"abcccc\".trim_end(chars=\"c\"), content=\"ab\")\n  inspect(\"cccc\".trim_end(chars=\"c\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self.trim_start(chars~).trim_end(chars~)\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim(chars~)\n}\n\n///|\ntest \"trim\" {\n  inspect(\"hello\".trim(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim(chars=\"ho\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"oh\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim(chars=\"a\"), content=\"\")\n  inspect(\"   hello   \".trim(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim(chars=\"hd\"), content=\"ello worl\")\n  inspect(\"😀hello😀\".trim(chars=\"😀\"), content=\"hello\")\n  inspect(\"😀😃hello😀😃\".trim(chars=\"😀😃\"), content=\"hello\")\n  inspect(\"aaaabcaaa\".trim(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim(chars=\"a\"), content=\"\")\n  inspect(\"  hello world  \".trim(chars=\" \"), content=\"hello world\")\n  inspect(\"abcabc\".trim(chars=\"abc\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn StringView::trim_space(self : StringView) -> StringView {\n  self.trim()\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn String::trim_space(self : String) -> StringView {\n  self.trim()\n}\n\n///|\ntest \"trim whitespace for string\" {\n  inspect(\"hello\".trim(), content=\"hello\")\n  inspect(\"  hello  \".trim(), content=\"hello\")\n  inspect(\"hello  \".trim(), content=\"hello\")\n  inspect(\"  hello\".trim(), content=\"hello\")\n  inspect(\"\\t\\nhello\\r\\n\".trim(), content=\"hello\")\n  inspect(\"  hello world  \".trim(), content=\"hello world\")\n  inspect(\"  \".trim(), content=\"\")\n  inspect(\"\\n\\r\\t\".trim(), content=\"\")\n  inspect(\"\".trim(), content=\"\")\n  inspect(\"  hello\\nworld\\t\".trim(), content=\"hello\\nworld\")\n}\n\n///|\n/// Returns true if this string is empty.\npub fn StringView::is_empty(self : StringView) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Returns true if this string is empty.\npub fn String::is_empty(self : String) -> Bool {\n  self == \"\"\n}\n\n///|\ntest \"is_empty\" {\n  inspect(\"\".is_empty(), content=\"true\")\n  inspect(\"hello\".is_empty(), content=\"false\")\n  inspect(\" \".is_empty(), content=\"false\")\n  inspect(\"\\n\".is_empty(), content=\"false\")\n  inspect(\"\\t\".is_empty(), content=\"false\")\n  inspect(\"   \".is_empty(), content=\"false\")\n\n  // Test with string views\n  let s = \"hello\"\n  let empty_view = s[0:0]\n  let non_empty_view = s[0:3]\n  inspect(empty_view.is_empty(), content=\"true\")\n  inspect(non_empty_view.is_empty(), content=\"false\")\n}\n\n///|\n/// Returns true if this string is blank.\npub fn StringView::is_blank(self : StringView) -> Bool {\n  self.trim().is_empty()\n}\n\n///|\n/// Returns true if this string is blank.\npub fn String::is_blank(self : String) -> Bool {\n  self[:].is_blank()\n}\n\n///|\ntest \"is_blank\" {\n  inspect(\"\".is_blank(), content=\"true\")\n  inspect(\"hello\".is_blank(), content=\"false\")\n  inspect(\" \".is_blank(), content=\"true\")\n  inspect(\"\\n\".is_blank(), content=\"true\")\n  inspect(\"\\t\".is_blank(), content=\"true\")\n  inspect(\"   \".is_blank(), content=\"true\")\n  inspect(\" \\n\\t\\r \".is_blank(), content=\"true\")\n  inspect(\"hello world\".is_blank(), content=\"false\")\n  inspect(\"  hello  \".is_blank(), content=\"false\")\n\n  // Test with string views\n  let s = \"   hello  \"\n  let blank_view = s[0:3] // \"   \"\n  let non_blank_view = s[3:8] // \"hello\"\n  inspect(blank_view.is_blank(), content=\"true\")\n  inspect(non_blank_view.is_blank(), content=\"false\")\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_start(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_start(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\ntest \"pad_start\" {\n  // Test with regular strings\n  inspect(\"2\".pad_start(3, '0'), content=\"002\")\n  inspect(\"abc\".pad_start(5, 'x'), content=\"xxabc\")\n  inspect(\"hello\".pad_start(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_start(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_start(8, '*'), content=\"****test\")\n  inspect(\"123\".pad_start(6, '0'), content=\"000123\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_start(5, 'x'), content=\"xxllo\")\n\n  // Test with Unicode characters\n  inspect(\"🌟\".pad_start(3, '✨'), content=\"✨🌟\")\n\n  // Edge cases\n  inspect(\"abc\".pad_start(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_start(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_end(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_end(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\ntest \"pad_end\" {\n  // Test with regular strings\n  inspect(\"2\".pad_end(3, '0'), content=\"200\")\n  inspect(\"abc\".pad_end(5, 'x'), content=\"abcxx\")\n  inspect(\"hello\".pad_end(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_end(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_end(8, '*'), content=\"test****\")\n  inspect(\"123\".pad_end(6, '0'), content=\"123000\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_end(5, 'x'), content=\"lloxx\")\n\n  // Test with Unicode characters\n  inspect(\"🌟\".pad_end(3, '✨'), content=\"🌟✨\")\n\n  // Edge cases\n  inspect(\"abc\".pad_end(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_end(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn StringView::repeat(self : StringView, n : Int) -> StringView {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn String::repeat(self : String, n : Int) -> String {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\ntest \"repeat\" {\n  // Test with regular strings\n  inspect(\"abc\".repeat(3), content=\"abcabcabc\")\n  inspect(\"x\".repeat(5), content=\"xxxxx\")\n  inspect(\"hello \".repeat(2), content=\"hello hello \")\n\n  // Test with empty string\n  inspect(\"\".repeat(10), content=\"\")\n\n  // Test with string views\n  let s = \"hello world\"\n  let view = s[6:11] // \"world\"\n  inspect(view.repeat(2), content=\"worldworld\")\n\n  // Test with Unicode characters\n  inspect(\"🌟\".repeat(3), content=\"🌟🌟🌟\")\n  inspect(\"✨🌟\".repeat(2), content=\"✨🌟✨🌟\")\n\n  // Edge cases\n  inspect(\"abc\".repeat(0), content=\"\")\n  inspect(\"abc\".repeat(-5), content=\"\")\n  inspect(\"abc\".repeat(1), content=\"abc\")\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn StringView::rev(self : StringView) -> String {\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self.rev_iter() {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn String::rev(self : String) -> String {\n  self[:].rev()\n}\n\n///|\ntest \"rev\" {\n  inspect(\"hello\".rev(), content=\"olleh\")\n  inspect(\"\".rev(), content=\"\")\n  inspect(\"abc\".rev(), content=\"cba\")\n  inspect(\"😀😃\".rev(), content=\"😃😀\")\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn StringView::split(\n  self : StringView,\n  sep : StringView,\n) -> Iter[StringView] {\n  let sep_len = sep.length()\n  if sep_len == 0 {\n    return self.iter().map(c => c.to_string().view())\n  }\n  let mut remaining = Some(self)\n  Iter::new(() => {\n    guard remaining is Some(view) else { None }\n    guard view.find(sep) is Some(end) else {\n      remaining = None\n      Some(view)\n    }\n    remaining = Some(view.view(start_offset=end + sep_len))\n    Some(view.view(end_offset=end))\n  })\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn String::split(self : String, sep : StringView) -> Iter[StringView] {\n  self[:].split(sep)\n}\n\n///|\ntest \"split\" {\n  assert_eq(\"a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\n    \"apple::orange::banana\".split(\"::\").map(StringView::to_string).collect(),\n    [\"apple\", \"orange\", \"banana\"],\n  )\n  assert_eq(\"abc\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"hello\".split(\",\").map(StringView::to_string).collect(), [\"hello\"])\n  assert_eq(\",a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"\", \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c,\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\", \"\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\"\".split(\"\").map(StringView::to_string).collect(), [])\n  assert_eq(\"\".split(\",\").map(StringView::to_string).collect(), [\"\"])\n  assert_eq(\"😀,😃,😄\".split(\",\").map(StringView::to_string).collect(), [\n    \"😀\", \"😃\", \"😄\",\n  ])\n  assert_eq(\"a😀b😀c\".split(\"😀\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn StringView::replace(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn String::replace(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\ntest \"replace\" {\n  inspect(\"hello\".replace(old=\"o\", new=\"a\"), content=\"hella\")\n  inspect(\"hello\".replace(old=\"l\", new=\"a\"), content=\"healo\")\n  inspect(\"hello\".replace(old=\"hello\", new=\"a\"), content=\"a\")\n  inspect(\"hello\".replace(old=\"h\", new=\"a\"), content=\"aello\")\n  inspect(\"hello\".replace(old=\"\", new=\"a\"), content=\"ahello\")\n  inspect(\"hello\".replace(old=\"world\", new=\"a\"), content=\"hello\")\n  inspect(\"\".replace(old=\"\", new=\"a\"), content=\"a\")\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn StringView::replace_all(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self, end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn String::replace_all(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self[:], end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\ntest \"replace_all\" {\n  assert_eq(\"hello\".replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\".replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\".replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\".replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\"hello hello hello\".replace_all(old=\"hello\", new=\"hi\"), \"hi hi hi\")\n  assert_eq(\n    \"hello hello helloi\".replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\".replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\".replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\".replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\".replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\".replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\"🤣🤣🤣\".replace_all(old=\"🤣\", new=\"😊\"), \"😊😊😊\")\n  assert_eq(\"abc123abc\".replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"String::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1187: guard end + old_len <= len else { break }\n  // This happens when the pattern is found at the very end of the string\n\n  // Pattern at the end of string - should trigger the guard condition\n  assert_eq(\"helloworld\".replace_all(old=\"world\", new=\"X\"), \"helloX\")\n  assert_eq(\"abcdef\".replace_all(old=\"def\", new=\"XYZ\"), \"abcXYZ\")\n\n  // Multiple patterns where the last one is at the end\n  assert_eq(\"abcabc\".replace_all(old=\"abc\", new=\"X\"), \"XX\")\n\n  // Pattern that exactly matches the string length\n  assert_eq(\"test\".replace_all(old=\"test\", new=\"done\"), \"done\")\n\n  // Empty replacement at the end\n  assert_eq(\"remove_me\".replace_all(old=\"_me\", new=\"\"), \"remove\")\n}\n\n///|\ntest \"View::replace_all\" {\n  assert_eq(\"hello\"[:].replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\"[:].replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\"[:].replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\"[:].replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\n    \"hello hello hello\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hi\",\n  )\n  assert_eq(\n    \"hello hello helloi\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\"[:].replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\"[:].replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\"[:].replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\"[:].replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\n    \"🤣🤣🤣\"[:].replace_all(old=\"🤣\", new=\"😊\"),\n    \"😊😊😊\",\n  )\n  assert_eq(\"abc123abc\"[:].replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"View::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1141: guard end + old_len <= len else { break }\n  // This condition triggers when end + old_len > len, meaning we're at the boundary\n\n  // Let me trace through the algorithm more carefully...\n  // Actually, let me try a different approach - create a scenario where the view length changes\n\n  // Try with overlapping patterns or edge cases\n  assert_eq(\"abcabc\"[:].replace_all(old=\"abc\", new=\"X\"), \"XX\")\n  assert_eq(\"aaaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"bb\")\n\n  // Pattern at exact end\n  assert_eq(\"hello\"[:].replace_all(old=\"lo\", new=\"X\"), \"helX\")\n\n  // Test with empty string edge case\n  assert_eq(\"a\"[:].replace_all(old=\"a\", new=\"\"), \"\")\n\n  // Let me try to understand when end + old_len > len could happen...\n  // Maybe when we have a complex replacement scenario\n  inspect(\"Testing boundary condition\", content=\"Testing boundary condition\")\n}\n\n///|\n/// Converts this string to lowercase.\npub fn StringView::to_lower(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to lowercase.\npub fn String::to_lower(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_lower\" {\n  assert_eq(\"Hello\".to_lower(), \"hello\")\n  assert_eq(\"HELLO\".to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\".to_lower(), \"hello, world!\")\n}\n\n///|\ntest \"View::to_lower\" {\n  assert_eq(\"Hello\"[:].to_lower(), \"hello\")\n  assert_eq(\"HELLO\"[:].to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\"[:].to_lower(), \"hello, world!\")\n}\n\n///|\n/// Converts this string to uppercase.\npub fn StringView::to_upper(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to uppercase.\npub fn String::to_upper(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_upper\" {\n  assert_eq(\"hello\".to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\".to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\".to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\ntest \"View::to_upper\" {\n  assert_eq(\"hello\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\"[:].to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] StringView::fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] String::fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].fold(init~, f)\n}\n\n///|\ntest \"fold\" {\n  assert_eq(\n    \"hello\".fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['h', 'e', 'l', 'l', 'o'],\n  )\n  assert_eq(\n    \"hello\".fold(init=0, (acc, c) => acc + c.to_int()),\n    104 + 101 + 108 + 108 + 111,\n  )\n}\n\n///|\ntest \"fold with raise\" {\n  let result = try? \"hello\".fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\npub fn[A] StringView::rev_fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self.rev_iter() {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\npub fn[A] String::rev_fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].rev_fold(init~, f)\n}\n\n///|\ntest \"rev_fold\" {\n  assert_eq(\n    \"hello\".rev_fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['o', 'l', 'l', 'e', 'h'],\n  )\n  assert_eq(\n    \"hello\".rev_fold(init=0, (acc, c) => acc + c.to_int()),\n    111 + 108 + 108 + 101 + 104,\n  )\n}\n\n///|\ntest \"rev_fold with raise\" {\n  let result = try? \"hello\".rev_fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `String::code_unit_at` instead.\", skip_current_package=true)\npub fn String::get(self : String, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `StringView::code_unit_at` instead.\", skip_current_package=true)\npub fn StringView::get(self : StringView, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\ntest \"String::get supports emoji (surrogate pair)\" {\n  let s = \"hello\"\n  inspect(s.get(0), content=\"Some(104)\")\n  inspect(s.get(4), content=\"Some(111)\")\n  inspect(s.get(5), content=\"None\")\n  inspect(s.get(-1), content=\"None\")\n  let s = \"a🤣b\"\n  inspect(s.get(0), content=\"Some(97)\")\n  inspect(s.get(1), content=\"Some(55358)\")\n  inspect(s.get(2), content=\"Some(56611)\")\n  inspect(s.get(3), content=\"Some(98)\")\n  inspect(s.get(4), content=\"None\")\n}\n\n///|\ntest \"View::get basic cases\" {\n  let v = \"hello\"[1:-1]\n  inspect(v.get(0), content=\"Some(101)\")\n  inspect(v.get(2), content=\"Some(108)\")\n  inspect(v.get(3), content=\"None\")\n  inspect(v.get(-1), content=\"None\")\n  let v = \"ab🤣cd\"[1:-1]\n  inspect(v.get(0), content=\"Some(98)\")\n  inspect(v.get(1), content=\"Some(55358)\")\n  inspect(v.get(2), content=\"Some(56611)\")\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn String::get_char(self : String, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn StringView::get_char(self : StringView, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\ntest \"String::get_char basic cases\" {\n  // Basic ASCII characters\n  let s = \"hello\"\n  inspect(s.get_char(0), content=\"Some('h')\")\n  inspect(s.get_char(1), content=\"Some('e')\")\n  inspect(s.get_char(4), content=\"Some('o')\")\n  inspect(s.get_char(5), content=\"None\")\n  inspect(s.get_char(-1), content=\"None\")\n\n  // Contains emoji (surrogate pair)\n  let s = \"a🤣b\"\n  inspect(s.get_char(0), content=\"Some('a')\")\n  inspect(s.get_char(1), content=\"Some('🤣')\")\n  inspect(s.get_char(2), content=\"None\") // Second half of surrogate pair is not a valid char\n  inspect(s.get_char(3), content=\"Some('b')\")\n  inspect(s.get_char(4), content=\"None\")\n}\n\n///|\ntest \"View::get_char basic cases\" {\n  let s = \"a🤣b\"\n  let v = s[0:-1]\n  inspect(v.get_char(0), content=\"Some('a')\")\n  inspect(v.get_char(1), content=\"Some('🤣')\")\n  inspect(v.get_char(2), content=\"None\")\n  inspect(v.get_char(3), content=\"None\")\n  inspect(v.get_char(4), content=\"None\")\n\n  // Test substring view\n  let v2 = s[1:3] // Only contains the emoji surrogate pair\n  inspect(v2.get_char(0), content=\"Some('🤣')\")\n  inspect(v2.get_char(1), content=\"None\")\n  inspect(v2.get_char(2), content=\"None\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n///|\n/// Create new string of `length`, where each character is `value`\n///\n/// ```mbt check\n/// test {\n///   assert_eq(String::make(5, 'S'), \"SSSSS\")\n/// }\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  guard length >= 0 else { abort(\"invalid length\") }\n  if value.to_int() <= 0xFFFF {\n    unsafe_make_string(length, value)\n  } else {\n    let buf = StringBuilder::new(size_hint=2 * length)\n    for _ in 0..<length {\n      buf.write_char(value)\n    }\n    buf.to_string()\n  }\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  ((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000).unsafe_to_char()\n}\n\n///|\n/// Returns the number of Unicode code points (characters) in the string.\n///\n/// This method counts actual Unicode characters, properly handling surrogate pairs\n/// that represent single characters like emojis. For the raw UTF-16 code unit count,\n/// use `length()` instead.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let s = \"Hello🤣\"\n///   inspect(s.char_length(), content=\"6\") // 6 actual characters\n///   inspect(s.length(), content=\"7\")\n/// } // 5 ASCII chars + 2 surrogate pairs\n/// ```\n#alias(codepoint_length, deprecated)\npub fn String::char_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"invalid start or end index for String::codepoint_length\")\n  }\n  for utf16_index = start_offset, char_count = 0\n      utf16_index < end_offset\n      utf16_index = utf16_index + 1, char_count = char_count + 1 {\n    let c1 = self.unsafe_charcode_at(utf16_index)\n    if c1.is_leading_surrogate() && utf16_index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(utf16_index + 1)\n      if c2.is_trailing_surrogate() {\n        continue utf16_index + 2, char_count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    char_count\n  }\n}\n\n///|\n#intrinsic(\"%string.substring\")\npub fn String::unsafe_substring(\n  str : String,\n  start~ : Int,\n  end~ : Int,\n) -> String {\n  if start == 0 && end == str.length() {\n    return str\n  }\n  let len = end - start\n  let bytes = FixedArray::make(len * 2, Byte::default())\n  bytes.blit_from_string(0, str, start, len)\n  bytes.unsafe_reinterpret_as_bytes().to_unchecked_string()\n}\n\n///|\n/// Returns a new string containing characters from the original string starting\n/// at `start` index up to (but not including) `end` index.\n///\n/// Parameters:\n///\n/// * `string` : The source string from which to extract the substring.\n/// * `start` : The starting index of the substring (inclusive). Defaults to 0.\n/// * `end` : The ending index of the substring (exclusive). Defaults to the\n/// length of the string.\n///\n/// Returns a new string containing the specified substring.\n///\n#deprecated(\"Use `str[:]` or `str[:].to_string()` instead\", skip_current_package=true)\npub fn String::substring(self : String, start? : Int = 0, end? : Int) -> String {\n  let len = self.length()\n  let end = match end {\n    Some(end) => end\n    None => len\n  }\n  guard start >= 0 && start <= end && end <= len\n  self.unsafe_substring(start~, end~)\n}\n\n///|\n/// Iterates over all suffixes of the string as views that reuse the\n/// original storage. Surrogate pairs stay intact while advancing.\npub fn String::suffixes(\n  self : String,\n  include_empty? : Bool = false,\n) -> Iter[StringView] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\ntest \"substring/empty\" {\n  let s = \"test\"\n  inspect(s.substring(start=2, end=2), content=\"\")\n  inspect(s.substring(start=4, end=4), content=\"\")\n  inspect(\"\".substring(), content=\"\")\n}\n\n///|\ntest \"panic substring/invalid_range\" {\n  let s = \"test\"\n  ignore(s.substring(start=-1))\n  ignore(s.substring(end=5))\n  ignore(s.substring(start=3, end=2))\n}\n\n///|\ntest \"substring/basic\" {\n  inspect(\"Hello world\".substring(start=0, end=5), content=\"Hello\")\n  inspect(\"Hello world\".substring(start=6, end=11), content=\"world\")\n  inspect(\"Hello world\".substring(start=0), content=\"Hello world\")\n  inspect(\"Hello world\".substring(start=6), content=\"world\")\n}\n\n///|\ntest \"substring/boundary\" {\n  inspect(\"\".substring(start=0, end=0), content=\"\")\n  inspect(\"a\".substring(start=0, end=1), content=\"a\")\n  inspect(\"abc\".substring(start=0), content=\"abc\")\n  inspect(\"abc\".substring(start=1), content=\"bc\")\n  inspect(\"abc\".substring(start=0, end=3), content=\"abc\")\n}\n\n///|\ntest \"panic substring/out_of_bounds\" {\n  ignore(\"hello\".substring(start=-1, end=4))\n  ignore(\"hello\".substring(start=6, end=4))\n  ignore(\"hello\".substring(start=0, end=6))\n}\n\n///|\n/// Strings are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for String with compare(self, other) {\n  let len = self.length()\n  match len.compare(other.length()) {\n    0 => {\n      for i in 0..<len {\n        let order = self\n          .unsafe_charcode_at(i)\n          .compare(other.unsafe_charcode_at(i))\n        if order != 0 {\n          return order\n        }\n      }\n      0\n    }\n    order => order\n  }\n}\n\n///|\n/// The empty string\npub impl Default for String with default() {\n  \"\"\n}\n\n///|\n/// `String` holds a sequence of UTF-16 code units encoded in little endian format\n#deprecated(\"Check `@encoding/utf8.encode`\")\npub fn String::to_bytes(self : String) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self, 0, self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\nfn unsafe_to_bytes(array : FixedArray[Byte]) -> Bytes = \"%identity\"\n\n///|\n/// Converts the String into an array of Chars.\npub fn String::to_array(self : String) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string.\n///\n/// Note: This iterator yields Unicode characters, not Utf16 code units.\n/// As a result, the count of characters returned by `iterator().count()` may not be equal to the length of the string returned by `length()`.\n///\n/// ```mbt check\n/// test {\n///   let s = \"Hello, World!🤣\"\n///   assert_eq(s.iter().count(), 14) // Unicode characters\n///   assert_eq(s.length(), 15)\n/// } // Utf16 code units\n/// ```\n#alias(iterator, deprecated)\npub fn String::iter(self : String) -> Iter[Char] {\n  let len = self.length()\n  let mut index = 0\n  Iter::new(fn() {\n    guard index < len else { None }\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < len {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let c = code_point_of_surrogate_pair(c1, c2)\n        index += 2\n        return Some(c)\n      }\n    }\n    index += 1\n    //TODO: handle garbage input\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn String::iter2(self : String) -> Iter2[Int, Char] {\n  self.iter().iter2()\n}\n\n///|\n/// Returns an iterator that yields characters from the end to the start of the string. This function handles\n/// Unicode surrogate pairs correctly, ensuring that characters are not split across surrogate pairs.\n///\n/// # Parameters\n///\n/// - `self` : The input `String` to be iterated in reverse.\n///\n/// # Returns\n///\n/// - An `Iter[Char]` that yields characters from the end to the start of the string.\n///\n/// # Behavior\n///\n/// - The function iterates over the string in reverse order.\n/// - If a trailing surrogate is encountered, it checks for a preceding leading surrogate to form a complete Unicode code point.\n/// - Yields each character or combined code point to the iterator.\n/// - Stops iteration if the `yield_` function returns `IterEnd`.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let input = \"Hello, World!\"\n///   let reversed = input.rev_iter().collect()\n///   assert_eq(reversed, [\n///     '!', 'd', 'l', 'r', 'o', 'W', ' ', ',', 'o', 'l', 'l', 'e', 'H',\n///   ])\n/// }\n/// ```\n#alias(rev_iterator, deprecated)\npub fn String::rev_iter(self : String) -> Iter[Char] {\n  let len = self.length()\n  let mut index = len\n  Iter::new(fn() {\n    guard index > 0 else { None }\n    index -= 1\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2, c1))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\nfn String::offset_of_nth_char_forward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int,\n) -> Int? {\n  guard start_offset >= 0 && start_offset <= end_offset else {\n    abort(\"Invalid start index\")\n  }\n  let mut utf16_offset = start_offset\n  let mut char_count = 0\n  while utf16_offset < end_offset && char_count < n {\n    let c = self.unsafe_charcode_at(utf16_offset)\n    // check if this is a surrogate pair\n    if c.is_leading_surrogate() {\n      utf16_offset = utf16_offset + 2\n    } else {\n      utf16_offset = utf16_offset + 1\n    }\n    char_count = char_count + 1\n  }\n  // Return None if either:\n  // 1. We couldn't reach the requested character offset\n  // 2. The resulting offset is beyond the end of the string\n  // This handles the empty string case correctly.\n  if char_count < n || utf16_offset >= end_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\n/// self[end] is counted as the 0-th character (though it might not exist if end = self.length()).\nfn String::offset_of_nth_char_backward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int,\n) -> Int? {\n  let mut char_count = 0\n  let mut utf16_offset = end_offset\n  // Iterating backwards from the end of the string. \n  // Invariant: utf16_offset always points to the previous character\n  while utf16_offset - 1 >= start_offset && char_count < n {\n    let c = self.unsafe_charcode_at(utf16_offset - 1)\n    if c.is_trailing_surrogate() {\n      utf16_offset = utf16_offset - 2\n    } else {\n      utf16_offset = utf16_offset - 1\n    }\n    char_count = char_count + 1\n  }\n  if char_count < n || utf16_offset < start_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character \n/// within the range [start, end). If i is negative, it returns the index of \n/// the (n + i)-th character where n is the number of Unicode characters \n/// in the range [start, end).\n/// \n/// This functions assumes that the string is valid UTF-16.\npub fn String::offset_of_nth_char(\n  self : String,\n  i : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int? {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  if i >= 0 {\n    // forward case\n    self.offset_of_nth_char_forward(i, start_offset~, end_offset~)\n  } else {\n    // backward case\n    self.offset_of_nth_char_backward(-i, start_offset~, end_offset~)\n  }\n}\n\n///|\n/// Test if the length of the string is equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_eq(\n  self : String,\n  len : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Bool {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count == len && index == end_offset\n  }\n}\n\n///|\n/// Test if the length of the string is greater than or equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_ge(\n  self : String,\n  len : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Bool {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count >= len\n  }\n}\n\n///|\n/// Performs a lexicographical comparison of two strings.\n///\n/// This method compares the strings character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one string is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"ab\".lexical_compare(\"abc\"), content=\"-1\")\n///   inspect(\"abc\".lexical_compare(\"ab\"), content=\"1\")\n///   inspect(\"abc\".lexical_compare(\"abc\"), content=\"0\")\n///   inspect(\"abc\".lexical_compare(\"abd\"), content=\"-1\")\n/// }\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn String::lexical_compare(self : String, other : String) -> Int {\n  self[:].lexical_compare(other[:])\n}\n\n///|\n/// Convert char array to string.\n///\n/// ```mbt check\n/// test {\n///   let s = String::from_array(['H', 'e', 'l', 'l', 'o'])\n///   assert_eq(s, \"Hello\")\n/// }\n/// ```\n///\n/// Do not convert large data to `Array[Char]` and build a string with `String::from_array`.\n///\n/// For efficiency considerations, it's recommended to use `Buffer` instead.\npub fn String::from_array(chars : ArrayView[Char]) -> String {\n  let buf = StringBuilder::new(size_hint=chars.length() * 4)\n  for c in chars {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Convert char iterator to string,\n#alias(from_iterator, deprecated)\npub fn String::from_iter(iter : Iter[Char]) -> String {\n  let buf = StringBuilder::new()\n  for c in iter {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder {\n  mut data : FixedArray[Byte]\n  mut len : Int\n}\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  let initial = if size_hint < 1 { 1 } else { size_hint }\n  let data : FixedArray[Byte] = FixedArray::make(initial, 0)\n  { data, len: 0 }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.len == 0\n}\n\n///|\nfn StringBuilder::grow_if_necessary(\n  self : StringBuilder,\n  required : Int,\n) -> Unit {\n  let current_len = self.data.length()\n  if required <= current_len {\n    return\n  }\n  // current_len is at least 1\n  let mut enough_space = current_len\n  // double the enough_space until it larger than required\n  while enough_space < required {\n    enough_space = enough_space * 2\n  }\n  let new_data = FixedArray::make(enough_space, Byte::default())\n  new_data.unsafe_blit(0, self.data, 0, self.len)\n  self.data = new_data\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(self.len, str, 0, str.length())\n  self.len += str.length() * 2\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.grow_if_necessary(self.len + 4)\n  let inc = self.data.set_utf16le_char(self.len, ch)\n  self.len += inc\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sb = StringBuilder::new()\n///   sb.write_view(\"Hello, world!\"[:5])\n///   assert_eq(sb.to_string(), \"Hello\")\n/// }\n/// ```\npub impl Logger for StringBuilder with write_view(\n  self : StringBuilder,\n  str : StringView,\n) -> Unit {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(\n    self.len,\n    str.data(),\n    str.start_offset(),\n    str.length(),\n  )\n  self.len += str.length() * 2\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.data\n  .unsafe_reinterpret_as_bytes()\n  .to_unchecked_string(offset=0, length=self.len)\n}\n\n///|\n/// TODO: improve perf\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(\n    self.data\n    .unsafe_reinterpret_as_bytes()\n    .to_unchecked_string(offset=0, length=self.len),\n  )\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.len = 0\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Writes the string representation of an object to the StringBuilder.\npub fn[T : Show] StringBuilder::write_object(\n  self : StringBuilder,\n  obj : T,\n) -> Unit {\n  obj.output(self)\n}\n\n///|\n/// Writes characters from an iterator to the StringBuilder. \n///\n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `iter` : An iterator yielding characters to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sb = StringBuilder::new()\n///   let chars = \"Hello🤣\".iter()\n///   sb.write_iter(chars)\n///   assert_eq(sb.to_string(), \"Hello🤣\")\n/// }\n/// ```\npub fn StringBuilder::write_iter(\n  self : StringBuilder,\n  iter : Iter[Char],\n) -> Unit {\n  for ch in iter {\n    self.write_char(ch)\n  }\n}\n\n///|\n/// Writes a StringView to the StringBuilder.\n/// \n/// This is more efficient than converting the StringView to a String first,\n/// as it directly writes the viewed portion without creating intermediate strings.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `view` : The StringView to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sb = StringBuilder::new()\n///   let str = \"Hello, world!\"\n///   let view = str[7:12] // \"world\"\n///   sb.write_stringview(view)\n///   assert_eq(sb.to_string(), \"world\")\n/// }\n/// ```\npub fn StringBuilder::write_stringview(\n  self : StringBuilder,\n  view : StringView,\n) -> Unit {\n  let start = view.start()\n  let end = view.end()\n  self.write_substring(view.str(), start, end - start)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the source string being viewed.\nfn StringView::str(self : StringView) -> String = \"%stringview.str\"\n\n///|\n/// Returns the starting UTF-16 code unit index into the string.\nfn StringView::start(self : StringView) -> Int = \"%stringview.start\"\n\n///|\n/// Returns the ending UTF-16 code unit index into the string (not included).\nfn StringView::end(self : StringView) -> Int = \"%stringview.end\"\n\n///|\nfn StringView::make_view(str : String, start : Int, end : Int) -> StringView = \"%stringview.make\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn StringView::at(self : StringView, index : Int) -> UInt16 {\n  guard index >= 0 && index < self.length() else {\n    abort(\"Index out of bounds\")\n  }\n  self.str().code_unit_at(self.start() + index)\n}\n\n///|\n/// Returns the length of the view.\n/// \n/// This method counts the charcodes(code unit) in the view and has O(1) complexity.\npub fn StringView::length(self : StringView) -> Int {\n  self.end() - self.start()\n}\n\n///|\n/// Iterates over all suffixes of the view, advancing by a Unicode character at\n/// a time. Each yielded suffix is itself a view into the original string.\npub fn StringView::suffixes(\n  self : StringView,\n  include_empty? : Bool = false,\n) -> Iter[StringView] {\n  let str = self.str()\n  let end = self.end()\n  let mut next_start = self.start()\n  let mut finished = false\n  Iter::new(fn() -> StringView? {\n    if finished {\n      None\n    } else if next_start == end {\n      finished = true\n      if include_empty {\n        Some(StringView::make_view(str, next_start, end))\n      } else {\n        None\n      }\n    } else {\n      let suffix = StringView::make_view(str, next_start, end)\n      let code = str.unsafe_charcode_at(next_start)\n      if code.is_leading_surrogate() &&\n        next_start + 1 < end &&\n        str.unsafe_charcode_at(next_start + 1).is_trailing_surrogate() {\n        next_start += 2\n      } else {\n        next_start += 1\n      }\n      Some(suffix)\n    }\n  })\n}\n\n///|\n/// Returns the original string that is being viewed.\npub fn StringView::data(self : StringView) -> String {\n  self.str()\n}\n\n///|\n/// Returns the starting offset (in UTF-16 code units) of this view into its\n/// underlying string.\npub fn StringView::start_offset(self : StringView) -> Int {\n  self.start()\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn StringView::view(\n  self : StringView,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(\n    self.str(),\n    self.start() + start_offset,\n    self.start() + end_offset,\n  )\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\n/// #Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"B🤣🤣C\"\n///   let view = str[:]\n///   inspect(view.unsafe_charcode_at(0), content=\"66\")\n///   inspect(view.unsafe_charcode_at(1), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(2), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(3), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(4), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(5), content=\"67\")\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\npub fn StringView::unsafe_charcode_at(self : StringView, index : Int) -> Int {\n  self.str().unsafe_charcode_at(self.start() + index)\n}\n\n///|\n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn StringView::char_length(self : StringView) -> Int {\n  self.str().char_length(start_offset=self.start(), end_offset=self.end())\n}\n\n///|\npub impl Show for StringView with output(self, logger) {\n  let substr = self.str().unsafe_substring(start=self.start(), end=self.end())\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello World\"\n///   let view = str.view(\n///     start_offset=str.offset_of_nth_char(0).unwrap(),\n///     end_offset=str.offset_of_nth_char(5).unwrap(),\n///   ) // \"Hello\"\n///   inspect(view.to_string(), content=\"Hello\")\n/// }\n/// ```\npub impl Show for StringView with to_string(self) {\n  // when `self == self.str()`, `String::unsafe_substring` would return original string, which doesn't create a new copy.\n  self.str().unsafe_substring(start=self.start(), end=self.end())\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\n#alias(iterator, deprecated)\npub fn StringView::iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  Iter::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        index += 2\n        return Some(code_point_of_surrogate_pair(c1, c2))\n      }\n    }\n    index += 1\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn StringView::iter2(self : StringView) -> Iter2[Int, Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  let mut char_index = 0\n  Iter2::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let result = (char_index, code_point_of_surrogate_pair(c1, c2))\n        index += 2\n        char_index += 1\n        return Some(result)\n      }\n    }\n    let result = (char_index, c1.unsafe_to_char())\n    index += 1\n    char_index += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\n#alias(rev_iterator, deprecated)\npub fn StringView::rev_iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = end\n  Iter::new(fn() {\n    guard index > start else { None }\n    index -= 1\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.str().unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2, c1))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for StringView with equal(self, other) {\n  let len = self.length()\n  guard len == other.length() else { return false }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str().unsafe_charcode_at(self.start() + i) ==\n      other.str().unsafe_charcode_at(other.start() + i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Views are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for StringView with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self\n      .str()\n      .unsafe_charcode_at(self.start() + i)\n      .compare(other.str().unsafe_charcode_at(other.start() + i))\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Performs a lexicographical comparison of two string views.\n///\n/// This method compares the views character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one view is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let str = \"abc\"\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=0, end_offset=3)),\n///     content=\"-1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=3)\n///     .lexical_compare(str.view(start_offset=0, end_offset=2)),\n///     content=\"1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=1, end_offset=3)),\n///     content=\"-1\",\n///   )\n/// }\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn StringView::lexical_compare(\n  self : StringView,\n  other : StringView,\n) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let min_len = if self_len < other_len { self_len } else { other_len }\n\n  // Compare character by character up to the minimum length\n  for i in 0..<min_len {\n    let self_char = self.str().unsafe_charcode_at(self.start() + i)\n    let other_char = other.str().unsafe_charcode_at(other.start() + i)\n    let cmp = self_char.compare(other_char)\n    if cmp != 0 {\n      return cmp\n    }\n  }\n\n  // If all characters match up to min_len, the shorter one is lexicographically smaller\n  self_len.compare(other_len)\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello🤣🤣🤣\"\n///   let view1 = str.view()\n///   inspect(view1, content=\"Hello🤣🤣🤣\")\n///   let start_offset = str.offset_of_nth_char(1).unwrap()\n///   let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset~, end_offset~)\n///   inspect(view2, content=\"ello🤣\")\n/// }\n/// ```\npub fn String::view(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(self, start_offset, end_offset)\n}\n\n///|\n/// Convert char array to string view.\npub fn StringView::from_array(chars : ArrayView[Char]) -> StringView {\n  String::from_array(chars)\n}\n\n///|\n/// Convert char iterator to string view.\n#alias(from_iterator, deprecated)\npub fn StringView::from_iter(iter : Iter[Char]) -> StringView {\n  String::from_iter(iter)\n}\n\n///|\npub suberror CreatingViewError {\n  IndexOutOfBounds\n  InvalidIndex\n} derive(Show)\n\n///|\n/// Creates a view of a string with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index (default: 0)\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string (e.g., -1 means last position)\n/// - `end` : Ending UTF-16 code unit index (optional)\n///   - If `None`: extends to the end of the string\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified substring range\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of valid range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n/// let str = \"Hello🤣World\"\n/// let view1 =  str[0:5]\n/// inspect(\n///   view1,\n///   content=(\n///     \"Hello\"\n///   ),\n/// )\n/// let view2 = try? str[-5:]\n/// inspect(\n///   view2,\n///   content=(\n///     #|Ok(\"World\")\n///   ),\n/// )\n/// let view3 = try? str[:6]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\n#alias(\"_[_:_]\")\npub fn String::sub(\n  self : String,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { raise IndexOutOfBounds }\n  if start < len && self.unsafe_charcode_at(start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if end < len && self.unsafe_charcode_at(end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self, start, end)\n}\n\n///|\n/// Creates a subview of an existing view with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index relative to this view (default: 0)\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// - `end` : Ending UTF-16 code unit index relative to this view (optional)\n///   - If `None`: extends to the end of this view\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified subrange of this view\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of this view's range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello🤣World\"[1:-1] // \"ello🤣Worl\"\n///   let view1 = str[0:6]\n///   inspect(view1, content=\"ello🤣\")\n///   let view2 = str[-2:]\n///   inspect(view2, content=\"rl\")\n///   let view3 = try? str[:5]\n///   inspect(view3, content=\"Err(InvalidIndex)\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn StringView::sub(\n  self : StringView,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let str_len = self.str().length()\n\n  // Calculate absolute positions in the original string\n  let abs_end = match end {\n    None => self.end()\n    Some(end) => if end < 0 { self.end() + end } else { self.start() + end }\n  }\n  let abs_start = if start < 0 {\n    self.end() + start\n  } else {\n    self.start() + start\n  }\n\n  // Validate bounds against the original string\n  guard abs_start >= self.start() &&\n    abs_start <= abs_end &&\n    abs_end <= self.end() else {\n    raise IndexOutOfBounds\n  }\n\n  // Check for surrogate pair boundaries\n  if abs_start < str_len &&\n    self.str().unsafe_charcode_at(abs_start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if abs_end < str_len &&\n    self.str().unsafe_charcode_at(abs_end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self.str(), abs_start, abs_end)\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_eq(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_eq(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_ge(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_ge(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn StringView::offset_of_nth_char(self : StringView, i : Int) -> Int? {\n  if self\n    .str()\n    .offset_of_nth_char(i, start_offset=self.start(), end_offset=self.end())\n    is Some(index) {\n    Some(index - self.start())\n  } else {\n    None\n  }\n}\n\n///|\n/// The empty view of a string\npub impl Default for StringView with default() {\n  \"\"\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn StringView::make(length : Int, value : Char) -> StringView {\n  String::make(length, value)\n}\n\n///|\npub impl ToJson for StringView with to_json(self) {\n  String::to_json(self.to_string())\n}\n\n///|\npub impl Add for StringView with add(self, other) {\n  [..self, ..other]\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `suberror` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : Failure = Failure(\"Test assertion failed\")\n///   match err {\n///     Failure(msg) => inspect(msg, content=\"Test assertion failed\")\n///   }\n///   @json.inspect(err, content=[\"Failure\", \"Test assertion failed\"])\n/// }\n/// ```\npub(all) suberror Failure String derive(ToJson, Show)\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise Failure {\n  raise Failure(\"\\{loc} FAILED: \\{msg}\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#cfg(not(target=\"js\"))\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\n#cfg(not(target=\"js\"))\nfn unsafe_fixedarray_uint16_to_string(buffer : FixedArray[UInt16]) -> String = \"%string.unsafe_from_uint16_fixedarray\"\n\n//==========================================\n// Int and UInt (Non JS)\n//==========================================\n\n///|\n/// Converts an unsigned 32-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFU).reinterpret_as_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFU).reinterpret_as_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36\n#cfg(not(target=\"js\"))\nfn int_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.reinterpret_as_uint()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1U\n    while n > 0U {\n      offset = offset - 1\n      let digit = n.land(mask).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0U {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 32-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000U {\n    let t = num / 10000U\n    let r = (num % 10000U).reinterpret_as_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.reinterpret_as_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Calculates the number of decimal digits in a u32 value\n#cfg(not(target=\"js\"))\nfn dec_count32(value : UInt) -> Int {\n  // Binary search: split 1-10 digits into halves\n  if value >= 100000U { // >= 10^5 means 6+ digits\n    if value >= 10000000U { // >= 10^7 means 8+ digits\n      if value >= 1000000000U { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000U { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000U { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000U { // >= 10^3 means 4+ digits\n    if value >= 10000U { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100U { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10U { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u32 value\n#cfg(not(target=\"js\"))\nfn hex_count32(value : UInt) -> Int {\n  if value == 0U {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (31 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u32 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count32(value : UInt, radix : Int) -> Int {\n  if value == 0U {\n    return 1\n  }\n  let mut num = value\n  let base = radix.reinterpret_as_uint()\n  let mut count = 0\n  while num > 0U {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n/// Example:\n/// ```\n/// inspect((255).to_string(radix=16), content=\"ff\")\n/// inspect((-255).to_string(radix=16), content=\"-ff\")\n/// ```\n#cfg(not(target=\"js\"))\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0 {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0\n  let num : UInt = if is_negative {\n    // Negate and reinterpret as UInt\n    // Works correctly for Int::min_value due to two's complement:\n    // -Int::min_value wraps to itself, then reinterpreting gives 2147483648U\n    (-self).reinterpret_as_uint()\n  } else {\n    self.reinterpret_as_uint()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count32(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0U {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count32(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n//==========================================\n// Int and UInt (JS)\n//==========================================\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  int_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int_to_string_js(i : Int, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return x.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  uint_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint_to_string_js(i : UInt, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return (x >>> 0).toString(radix);\n  #|}\n\n//==========================================\n// Int64 and UInt64\n//==========================================\n\n///|\n/// Calculates the number of decimal digits in a u64 value\n#cfg(not(target=\"js\"))\nfn dec_count64(value : UInt64) -> Int {\n  // Binary search: split 1-20 digits into halves\n  if value >= 10000000000UL { // >= 10^10 means 11+ digits\n    if value >= 100000000000000UL { // >= 10^14 means 15+ digits\n      if value >= 10000000000000000UL { // >= 10^16 means 17+ digits\n        if value >= 1000000000000000000UL { // >= 10^18 means 19+ digits\n          if value >= 10000000000000000000UL { // >= 10^19 means 20 digits\n            20\n          } else {\n            19\n          }\n        } else if value >= 100000000000000000UL { // >= 10^17 means 18 digits\n          18\n        } else {\n          17\n        }\n      } else if value >= 1000000000000000UL { // >= 10^15 means 16 digits\n        16\n      } else {\n        15\n      }\n    } else if value >= 1000000000000UL { // >= 10^12 means 13+ digits\n      if value >= 10000000000000UL { // >= 10^13 means 14 digits\n        14\n      } else {\n        13\n      }\n    } else if value >= 100000000000UL { // >= 10^11 means 12 digits\n      12\n    } else {\n      11\n    }\n  } else if value >= 100000UL { // >= 10^5 means 6+ digits\n    if value >= 10000000UL { // >= 10^7 means 8+ digits\n      if value >= 1000000000UL { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000UL { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000UL { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000UL { // >= 10^3 means 4+ digits\n    if value >= 10000UL { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100UL { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10UL { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u64 value\n#cfg(not(target=\"js\"))\nfn hex_count64(value : UInt64) -> Int {\n  if value == 0UL {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (63 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u64 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count64(value : UInt64, radix : Int) -> Int {\n  if value == 0UL {\n    return 1\n  }\n  let mut num = value\n  let base = radix.to_uint64()\n  let mut count = 0\n  while num > 0UL {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an unsigned 64-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int64_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFUL).to_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFUL).to_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36 (64-bit)\n#cfg(not(target=\"js\"))\nfn int64_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.to_uint64()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1UL\n    while n > 0UL {\n      offset = offset - 1\n      let digit = n.land(mask).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0UL {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int64_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000UL {\n    let t = num / 10000UL\n    let r = (num % 10000UL).to_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.to_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0L {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0L\n  let num : UInt64 = if is_negative {\n    // Negate and reinterpret as UInt64\n    // Works correctly for Int64::min_value due to two's complement\n    (-self).reinterpret_as_uint64()\n  } else {\n    self.reinterpret_as_uint64()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count64(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0UL {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count64(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  int64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int64_to_string_js(num : Int64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  let val = (BigInt(num.hi >>> 0) << 32n) | BigInt(num.lo >>> 0);\n  #|  if (val & (1n << 63n)) {\n  #|    val = val - (1n << 64n);\n  #|  }\n  #|  return val.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  uint64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint64_to_string_js(num : UInt64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  return (BigInt(num.hi >>> 0) << 32n | BigInt(num.lo >>> 0)).toString(radix);\n  #|}\n\n//==========================================\n// Int16 and UInt16\n//==========================================\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n//==========================================\n// Test cases\n//==========================================\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  equal(Self, Self) -> Bool = _\n  #deprecated(\"use `equal` instead\", skip_current_package=true)\n  op_equal(Self, Self) -> Bool = _\n  not_equal(Self, Self) -> Bool = _\n}\n\n///|\nimpl Eq with not_equal(x, y) {\n  !(x == y)\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n  op_lt(Self, Self) -> Bool = _\n  op_gt(Self, Self) -> Bool = _\n  op_le(Self, Self) -> Bool = _\n  op_ge(Self, Self) -> Bool = _\n}\n\n///|\nimpl Compare with op_lt(x, y) {\n  x.compare(y).is_neg()\n}\n\n///|\nimpl Compare with op_gt(x, y) {\n  x.compare(y).is_pos()\n}\n\n///|\nimpl Compare with op_le(x, y) {\n  x.compare(y).is_non_pos()\n}\n\n///|\nimpl Compare with op_ge(x, y) {\n  x.compare(y).is_non_neg()\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit = _\n  #deprecated(\"use `write_view` instead\", skip_current_package=true)\n  write_substring(Self, String, Int, Int) -> Unit = _\n  write_view(Self, StringView) -> Unit = _\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_substring(self, value, start, len) {\n  self.write_view(try! value[start:start + len])\n}\n\n///|\nimpl Logger with write_string(self, value) {\n  self.write_view(value[:])\n}\n\n///|\n#deprecated(\"replace `impl write_substring` with `impl write_view`\")\nimpl Logger with write_view(self, value) {\n  self.write_substring(value.data(), value.start_offset(), value.length())\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n/// Default implementation for `Show::to_string`, uses a `StringBuilder`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n\n///|\n#deprecated(\"replace `impl op_equal` with `impl equal`\")\nimpl Eq with equal(self, other) {\n  Eq::op_equal(self, other)\n}\n\n///|\nimpl Eq with op_equal(self, other) {\n  Eq::equal(self, other)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\n#alias(\"_[_]\")\npub fn[T] UninitializedArray::at(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\n#alias(\"_[_]=_\")\npub fn[T] UninitializedArray::set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\n#alias(\"_[_:_]\")\npub fn[T] UninitializedArray::sub(\n  self : UninitializedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  self.0.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\n#doc(hidden)\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n\n///|\n#coverage.skip\n#intrinsic(\"%fixedarray.fill\")\n#cfg(not(target=\"js\"))\nfn[T] UninitializedArray::unchecked_fill(\n  self : UninitializedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Eq for Unit with equal(_ : Unit, _ : Unit) -> Bool {\n  true\n}\n\n///|\npub impl Compare for Unit with compare(_, _) {\n  0\n}\n\n///|\npub impl Default for Unit with default() -> Unit {\n  ()\n}\n\n///|\npub impl Hash for Unit with hash_combine(_, hasher) -> Unit {\n  hasher.combine_unit()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(not(target=\"native\"))\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\n#cfg(target=\"native\")\nfn println(s : String) -> Unit = \"%println\"\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(target=\"native\")\npub fn[T] abort(msg : String) -> T {\n  println(msg)\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n"],"mappings":"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"}