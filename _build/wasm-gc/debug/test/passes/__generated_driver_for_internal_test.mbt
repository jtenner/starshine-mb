// Generated by moon test.

type Moonbit_Test_Driver_Internal_No_Args_Map = @moonbitlang/core/builtin.Map[
  String,
  @moonbitlang/core/builtin.Map[
    Int,
    (() -> Unit raise, @moonbitlang/core/builtin.Array[String]),
  ],
]

type Moonbit_Test_Driver_Internal_TestDriver_With_Args_Map = @moonbitlang/core/builtin.Map[
  String,
  @moonbitlang/core/builtin.Map[
    Int,
    (
      (Moonbit_Test_Driver_Internal_Test_Arg) -> Unit raise,
      @moonbitlang/core/builtin.Array[String],
    ),
  ],
]

type Moonbit_Test_Driver_Internal_TestDriver_Async_Map = @moonbitlang/core/builtin.Map[
  String,
  @moonbitlang/core/builtin.Map[
    Int,
    (
      async () -> Unit raise,
      @moonbitlang/core/builtin.Array[String],
    ),
  ],
]

type Moonbit_Test_Driver_Internal_TestDriver_Async_With_Args_Map = @moonbitlang/core/builtin.Map[
  String,
  @moonbitlang/core/builtin.Map[
    Int,
    (
      async (Moonbit_Test_Driver_Internal_Test_Arg) -> Unit raise,
      @moonbitlang/core/builtin.Array[String],
    ),
  ],
]

let moonbit_test_driver_internal_no_args_tests : Moonbit_Test_Driver_Internal_No_Args_Map = {
  "util.mbt": {
  },
  "lift_to_texpr.mbt": {
  },
  "imports.mbt": {
  },
  "const_hoisting.mbt": {
    0: (__test_636f6e73745f686f697374696e672e6d6274_0, ["const hoisting: single use does nothing"]),
    1: (__test_636f6e73745f686f697374696e672e6d6274_1, ["const hoisting: large constant is hoisted"]),
    2: (__test_636f6e73745f686f697374696e672e6d6274_2, ["const hoisting: small constants are not hoisted"]),
    3: (__test_636f6e73745f686f697374696e672e6d6274_3, ["const hoisting: different literals are not merged"]),
    4: (__test_636f6e73745f686f697374696e672e6d6274_4, ["const hoisting: f64 hoisted when repeated"]),
  },
  "code_pushing.mbt": {
  },
  "code_folding.mbt": {
  },
  "coalesce_locals.mbt": {
  },
  "avoid_reinterprets.mbt": {
  },
  "asyncify.mbt": {
  },
  "alignment_lowering.mbt": {
    0: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_0, ["chunks: aligned 4-byte access produces single chunk"]),
    1: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_1, ["chunks: aligned 8-byte access produces single chunk"]),
    2: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_2, ["chunks: 4-byte access with 1-byte alignment produces 4 chunks"]),
    3: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_3, ["chunks: 4-byte access with 2-byte alignment produces 2 chunks"]),
    4: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_4, ["chunks: 8-byte access with 1-byte alignment produces 8 chunks"]),
    5: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_5, ["chunks: 8-byte access with 2-byte alignment produces 4 chunks"]),
    6: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_6, ["chunks: 8-byte access with 4-byte alignment produces 2 chunks"]),
    7: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_7, ["chunks: unaligned offset affects chunking"]),
    8: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_8, ["aligned i32 load passes through"]),
    9: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_9, ["aligned i64 load passes through"]),
    10: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_10, ["aligned f32 load passes through"]),
    11: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_11, ["aligned f64 load passes through"]),
    12: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_12, ["unaligned i32 load with align=1 is split"]),
    13: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_13, ["unaligned i32 load with align=2 is split into 2 loads"]),
    14: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_14, ["unaligned i64 load with align=1 is split"]),
    15: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_15, ["unaligned i64 load with align=4 is split into 2 loads"]),
    16: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_16, ["unaligned f32 load produces reinterpret wrapper"]),
    17: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_17, ["unaligned f64 load produces reinterpret wrapper"]),
    18: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_18, ["i32.load8 always passes through (naturally aligned)"]),
    19: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_19, ["i32.load16 with align=1 is split"]),
    20: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_20, ["i64.load32 with align=2 is split"]),
    21: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_21, ["aligned i32 store passes through"]),
    22: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_22, ["aligned i64 store passes through"]),
    23: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_23, ["aligned f32 store passes through"]),
    24: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_24, ["unaligned i32 store with align=1 produces block"]),
    25: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_25, ["unaligned i32 store with align=2 produces block"]),
    26: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_26, ["unaligned i64 store with align=1 produces block"]),
    27: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_27, ["unaligned f32 store produces block with reinterpret"]),
    28: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_28, ["unaligned f64 store produces block with reinterpret"]),
    29: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_29, ["unaligned i32 store block has correct structure"]),
    30: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_30, ["v128 load with size > 8 passes through"]),
    31: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_31, ["v128 store with size > 8 passes through"]),
    32: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_32, ["v128.load64_splat aligned passes through"]),
    33: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_33, ["v128.load64_splat unaligned produces splat wrapper"]),
    34: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_34, ["v128.load32_splat unaligned produces splat wrapper"]),
    35: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_35, ["v128.load64_zero unaligned produces replace_lane"]),
    36: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_36, ["v128.load32_zero unaligned produces replace_lane"]),
    37: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_37, ["v128.load8_lane aligned passes through"]),
    38: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_38, ["v128.load16_lane unaligned produces replace_lane"]),
    39: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_39, ["v128.load32_lane unaligned produces replace_lane"]),
    40: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_40, ["v128.load64_lane unaligned produces replace_lane"]),
    41: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_41, ["load with explicit memory index"]),
    42: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_42, ["store with explicit memory index"]),
    43: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_43, ["invalid memory index returns error"]),
    44: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_44, ["unaligned load allocates new local for pointer"]),
    45: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_45, ["unaligned store allocates locals for pointer and value"]),
    46: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_46, ["i64 store allocates i64 value local"]),
    47: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_47, ["i32.load8_s unaligned produces sign extension"]),
    48: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_48, ["i32.load16_s unaligned produces sign extension"]),
    49: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_49, ["i64.load32_s unaligned produces sign extension"]),
    50: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_50, ["load with non-zero offset"]),
    51: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_51, ["store with non-zero offset"]),
    52: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_52, ["nested instructions are transformed"]),
    53: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_53, ["size_of_load_op returns correct sizes"]),
    54: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_54, ["size_of_store_op returns correct sizes"]),
    55: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_55, ["ChunkSize::byte_count returns correct values"]),
    56: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_56, ["load_op_stack_size returns correct stack sizes"]),
    57: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_57, ["store_op_stack_size returns correct stack sizes"]),
    58: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_58, ["align clamped to op_size"]),
    59: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_59, ["other instructions pass through unchanged"]),
    60: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_60, ["nop passes through unchanged"]),
    61: (__test_616c69676e6d656e745f6c6f776572696e672e6d6274_61, ["unreachable passes through unchanged"]),
  },
  "abstract_type_refining.mbt": {
  },
}
let moonbit_test_driver_internal_with_args_tests : Moonbit_Test_Driver_Internal_TestDriver_With_Args_Map = { }  // WILL BE REPLACED
let moonbit_test_driver_internal_async_tests : Moonbit_Test_Driver_Internal_TestDriver_Async_Map = { }  // WILL BE REPLACED
let moonbit_test_driver_internal_async_tests_with_args : Moonbit_Test_Driver_Internal_TestDriver_Async_With_Args_Map = { }  // WILL BE REPLACED

///|
pub fn moonbit_test_driver_internal_do_execute(
  async_tests : Array[async () -> Unit],
  filename : String,
  index : Int,
) -> Unit {
  fn handle_result(
    testname : String,
    message : String,
    skipped : Bool,
  ) {
    // In WASM, this function is called by the external test driver, but here
    // in native mode there's nothing that calls it, so we call it manually.
    if not(skipped) && MOONBIT_TEST_DRIVER_INTERNAL_IS_NATIVE {
      
    }
    let file_name = filename.escape()
    let test_name = testname.escape()
    let message = message.escape()
    @moonbitlang/core/builtin.println("----- BEGIN MOON TEST RESULT -----")
    @moonbitlang/core/builtin.println(
      "{\"package\": \"jtenner/starshine/passes\", \"filename\": \{file_name}, \"index\": \"\{index}\", \"test_name\": \{test_name}, \"message\": \{message}}",
    )
    @moonbitlang/core/builtin.println("----- END MOON TEST RESULT -----")
  }

  fn test_should_be_skipped(name : String, attrs : Array[String]) -> Bool {
    guard MOONBIT_TEST_DRIVER_INTERNAL_IS_NATIVE else { false }
    for attr in attrs {
      if attr is [.."panic", ..] {
        @moonbitlang/core/builtin.println("skipped test block: \{filename}: \{name}")
        handle_result(name, "skipped test", true)
        return true
      }
    } else {
      false
    }
  }

  fn on_err(name : String, err : Error) {
    match err {
      @moonbitlang/core/builtin.Failure(e)
      | @moonbitlang/core/builtin.InspectError(e)
      | @moonbitlang/core/builtin.SnapshotError(e)
      | MoonBitTestDriverInternalJsError(e) => {
        handle_result(name, e, false)
      }
      e => {
        let message = moonbit_test_driver_internal_error_to_string(e)
        handle_result(name, message, false)
      }
    }
  }

  if (
    moonbit_test_driver_internal_no_args_tests.get(filename) is Some(index_map) &&
    index_map.get(index) is Some((f, attrs))
  ) {
    let name = if attrs is [name, ..] { name } else { "" }
    guard !test_should_be_skipped(name, attrs) else {}
    moonbit_test_driver_internal_catch_error(
      f,
      on_ok=() => handle_result(name, "", false),
      on_err=(err) => on_err(name, err),
    )
    return
  }

  if (
    moonbit_test_driver_internal_with_args_tests.get(filename) is Some(index_map) &&
    index_map.get(index) is Some((f, attrs))
  ) {
    let name = if attrs is [name, ..] { name } else { "" }
    guard !test_should_be_skipped(name, attrs) else {}
    moonbit_test_driver_internal_catch_error(
      () => f(moonbit_test_driver_internal_new_test_arg(name)),
      on_ok=() => handle_result(name, "", false),
      on_err=err => on_err(name, err),
    )
    return
  }

  if (
    moonbit_test_driver_internal_async_tests.get(filename) is Some(index_map) &&
    index_map.get(index) is Some((f, attrs))
  ) {
    let name = if attrs is [name, ..] { name } else { "" }
    guard !test_should_be_skipped(name, attrs) else {}
    async_tests.push(() => {
      try f() catch {
        err if moonbit_test_driver_internal_is_being_cancelled() => raise err
        err => on_err(name, err)
      } noraise {
        _ => handle_result(name, "", false)
      }
    })
    return
  }

  if (
    moonbit_test_driver_internal_async_tests_with_args.get(filename) is Some(index_map) &&
    index_map.get(index) is Some((f, attrs))
  ) {
    let name = if attrs is [name, ..] { name } else { "" }
    guard !test_should_be_skipped(name, attrs) else {}
    async_tests.push(() => {
      try f(moonbit_test_driver_internal_new_test_arg(name)) catch {
        err if moonbit_test_driver_internal_is_being_cancelled() => raise err
        err => on_err(name, err)
      } noraise {
        _ => handle_result(name, "", false)
      }
    })
    return
  }

  handle_result("", "skipped test", true)
}

///|
let moonbit_test_driver_internal_max_concurrent_tests : Int = 10

#cfg(target="native")
#test_entry
fn main {
  let async_tests = []
  for arg in moonbit_test_driver_internal_native_parse_args() {
    moonbit_test_driver_internal_do_execute(async_tests, arg.0, arg.1)
  }
  moonbit_test_driver_internal_run_async_tests(async_tests)
}

#cfg(not(target="native"))
#test_entry
fn main {
  ()
}

#cfg(target="js")
pub fn moonbit_test_driver_internal_execute(
  tests : Array[MoonBitTestDriverInternalTestEntry],
) -> Unit {
  let async_tests = []
  for i in 0..<tests.length() {
    let entry = tests[i]
    moonbit_test_driver_internal_do_execute(async_tests, entry.filename(), entry.index())
  }
  moonbit_test_driver_internal_run_async_tests(async_tests)
}

#cfg(any(target="wasm", target="wasm-gc"))
pub fn moonbit_test_driver_internal_execute(
  filename : MoonbitTestDriverInternalExternString,
  index : Int,
) -> Unit {
  let filename = moonbit_test_driver_internal_get_file_name(filename)
  let async_tests = []
  moonbit_test_driver_internal_do_execute(async_tests, filename, index)
  moonbit_test_driver_internal_run_async_tests(async_tests)
}

#cfg(not(target="native"))
pub fn moonbit_test_driver_finish() -> Unit {
  
}
type Moonbit_Test_Driver_Internal_Test_Arg = Int

fn moonbit_test_driver_internal_new_test_arg(
  _ : String,
) -> Moonbit_Test_Driver_Internal_Test_Arg {
  42
}
///|
fn moonbit_test_driver_internal_run_async_tests(
  _tests : @moonbitlang/core/builtin.Array[async () -> Unit],
) -> Unit {
  @moonbitlang/core/builtin.ignore(moonbit_test_driver_internal_max_concurrent_tests)
}

///|
fn moonbit_test_driver_internal_is_being_cancelled() -> Bool {
  false
}
fn moonbit_test_driver_internal_error_to_string(x : Error) -> String = "%error.to_string"

#cfg(target="native")
fn string_get(s: String, index: Int) -> Int = "%string_get"

#cfg(not(target="js"))
fn moonbit_unsafe_char_from_int(x : Int) -> Char = "%identity"

#cfg(target="native")
const MOONBIT_TEST_DRIVER_INTERNAL_IS_NATIVE = true

#cfg(not(target="native"))
const MOONBIT_TEST_DRIVER_INTERNAL_IS_NATIVE = false

// =========================================================
// ================== BEGIN WASM SPECIFIC ==================
// =========================================================

#cfg(any(target="wasm", target="wasm-gc"))
fn moonbit_test_driver_internal_get_file_name(file_name : MoonbitTestDriverInternalExternString) -> String {
  moonbit_test_driver_internal_string_from_extern(file_name)
}

#cfg(any(target="wasm", target="wasm-gc"))
#external
type MoonbitTestDriverInternalStringReadHandle

#cfg(any(target="wasm", target="wasm-gc"))
#external
type MoonbitTestDriverInternalExternString

#cfg(any(target="wasm", target="wasm-gc"))
fn moonbit_test_driver_internal_begin_read_string(s : MoonbitTestDriverInternalExternString) -> MoonbitTestDriverInternalStringReadHandle = "__moonbit_fs_unstable" "begin_read_string"

#cfg(any(target="wasm", target="wasm-gc"))
fn moonbit_test_driver_internal_string_read_char(handle : MoonbitTestDriverInternalStringReadHandle) -> Int = "__moonbit_fs_unstable" "string_read_char"

#cfg(any(target="wasm", target="wasm-gc"))
fn moonbit_test_driver_internal_finish_read_string(handle : MoonbitTestDriverInternalStringReadHandle) = "__moonbit_fs_unstable" "finish_read_string"

#cfg(any(target="wasm", target="wasm-gc"))
fn fixedarray_to_bytes(arr : FixedArray[Byte]) -> Bytes = "%identity"

#cfg(any(target="wasm", target="wasm-gc"))
fn moonbit_test_driver_internal_string_from_extern(e : MoonbitTestDriverInternalExternString) -> String {
  let buf = FixedArray::make(512, Byte::default())
  let mut len = 0
  let handle = moonbit_test_driver_internal_begin_read_string(e)
  while true {
    let ch = moonbit_test_driver_internal_string_read_char(handle)
    if ch == -1 {
      break
    } else {
      let written_bytes_len = buf.set_utf16le_char(len, moonbit_unsafe_char_from_int(ch))
      len += written_bytes_len
    }
  }
  moonbit_test_driver_internal_finish_read_string(handle)
  fixedarray_to_bytes(buf).to_unchecked_string(offset = 0, length = len).to_string()
}

// =========================================================
// =================== END WASM SPECIFIC ===================
// =========================================================

// =========================================================
// ================= BEGIN NATIVE SPECIFIC =================
// =========================================================
#cfg(target="native")
fn moonbit_test_driver_internal_native_parse_args() -> @moonbitlang/core/builtin.Array[(String, Int)] {
  fn moonbit_test_driver_internal_parse_int_(s : String) -> Int {
    let mut res = 0
    let len = s.length()
    for i = 0; i < len; i = i + 1 {
      res = res * 10 + (string_get(s, i) - '0')
    }
    res
  }

  fn moonbit_test_driver_internal_utf8_bytes_to_mbt_string(bytes : Bytes) -> String {
    let res = @moonbitlang/core/builtin.StringBuilder::new()
    let len = bytes.length()
    let mut i = 0
    while i < len {
      let mut c = bytes[i].to_int()
      if c < 0x80 {
        res.write_char(moonbit_unsafe_char_from_int(c))
        i += 1
      } else if c < 0xE0 {
        if i + 1 >= len {
          break
        }
        c = ((c & 0x1F) << 6) | (bytes[i + 1].to_int() & 0x3F)
        res.write_char(moonbit_unsafe_char_from_int(c))
        i += 2
      } else if c < 0xF0 {
        if i + 2 >= len {
          break
        }
        c = ((c & 0x0F) << 12) |
          ((bytes[i + 1].to_int() & 0x3F) << 6) |
          (bytes[i + 2].to_int() & 0x3F)
        res.write_char(moonbit_unsafe_char_from_int(c))
        i += 3
      } else {
        if i + 3 >= len {
          break
        }
        c = ((c & 0x07) << 18) |
          ((bytes[i + 1].to_int() & 0x3F) << 12) |
          ((bytes[i + 2].to_int() & 0x3F) << 6) |
          (bytes[i + 3].to_int() & 0x3F)
        c -= 0x10000
        res.write_char(moonbit_unsafe_char_from_int((c >> 10) + 0xD800))
        res.write_char(moonbit_unsafe_char_from_int((c & 0x3FF) + 0xDC00))
        i += 4
      }
    }
    res.to_string()
  }

  fn moonbit_test_driver_internal_get_cli_args_internal() -> @moonbitlang/core/builtin.Array[String] {
    let tmp = moonbit_test_driver_internal_get_cli_args_ffi()
    let res = @moonbitlang/core/builtin.Array::new(capacity=tmp.length())
    for i = 0; i < tmp.length(); i = i + 1 {
      res.push(moonbit_test_driver_internal_utf8_bytes_to_mbt_string(tmp[i]))
    }
    res
  }

  fn moonbit_test_driver_internal_split_mbt_string(s : String, sep : Char) -> @moonbitlang/core/builtin.Array[String] {
    let res = []
    let mut i = 0
    let mut start = 0
    while i < s.length() {
      if moonbit_unsafe_char_from_int(string_get(s, i)) == sep {
        res.push(s.unsafe_substring(start = start, end = i))
        start = i + 1
      }
      i += 1
    }
    if start < s.length() {
      res.push(s.unsafe_substring(start = start, end = s.length()))
    }
    res
  }

  let file_and_index = []

  let cli_args = moonbit_test_driver_internal_get_cli_args_internal()
  let test_args = moonbit_test_driver_internal_split_mbt_string(cli_args[1], '/')
  for arg in test_args {
    let file_and_range = moonbit_test_driver_internal_split_mbt_string(arg, ':')
    let file = file_and_range[0]
    let range = file_and_range[1]
    let start_and_end = moonbit_test_driver_internal_split_mbt_string(range, '-')
    let start = moonbit_test_driver_internal_parse_int_(start_and_end[0])
    let end = moonbit_test_driver_internal_parse_int_(start_and_end[1])
    for i = start; i < end; i = i + 1 {
      file_and_index.push((file, i))
    }
  }

  file_and_index
}

#cfg(target="native")
fn moonbit_test_driver_internal_get_cli_args_ffi() -> FixedArray[Bytes] = "$moonbit.get_cli_args"

// =========================================================
// ================== END NATIVE SPECIFIC ==================
// =========================================================

// =========================================================
// -================== BEGIN JS SPECIFIC ===================
// =========================================================

///|
#cfg(target="js")
#external
type MoonBitTestDriverInternalTestEntry

///|
#cfg(target="js")
extern "js" fn MoonBitTestDriverInternalTestEntry::filename(self : Self) -> String =
  #| (entry) => entry[0]

///|
#cfg(target="js")
extern "js" fn MoonBitTestDriverInternalTestEntry::index(self : Self) -> Int =
  #| (entry) => entry[1]

///|
pub(all) suberror MoonBitTestDriverInternalJsError { MoonBitTestDriverInternalJsError(String) }

///|
#cfg(target="js")
fn moonbit_test_driver_internal_catch_error(
  f : () -> Unit raise,
  on_ok~ : () -> Unit,
  on_err~ : (Error) -> Unit,
) -> Unit {
  moonbit_test_driver_internal_js_catch(
    on_err=(err_str) => on_err(MoonBitTestDriverInternalJsError(err_str)),
    () => {
      try f() catch {
        err => on_err(err)
      } noraise {
        _ => on_ok()
      }
    }
  )
}

///|
#cfg(target="js")
extern "js" fn moonbit_test_driver_internal_js_catch(
  f : () -> Unit,
  on_err~ : (String) -> Unit,
) =
  #| (f, on_err) => {
  #|   try {
  #|     f()
  #|   } catch (err) {
  #|     const msg = err.stack.toString()
  #|     on_err(msg)
  #|   }
  #| }

///|
#cfg(not(target="js"))
fn moonbit_test_driver_internal_catch_error(
  f : () -> Unit raise,
  on_ok~ : () -> Unit,
  on_err~ : (Error) -> Unit,
) -> Unit {
  try f() catch {
    err => on_err(err)
  } noraise {
    _ => on_ok()
  }
}

// =========================================================
// -=================== END JS SPECIFIC ====================
// =========================================================
