{"version":3,"sources":["/home/jtenner/Projects/starshine-mb/src/passes/__generated_driver_for_internal_test.mbt","/home/jtenner/Projects/starshine-mb/src/passes/alignment_lowering.mbt","/home/jtenner/Projects/starshine-mb/src/passes/const_hoisting.mbt","/home/jtenner/Projects/starshine-mb/src/binary/encode.mbt","/home/jtenner/Projects/starshine-mb/src/lib/eq.mbt","/home/jtenner/Projects/starshine-mb/src/lib/show.mbt","/home/jtenner/Projects/starshine-mb/src/lib/transformer.mbt","/home/jtenner/Projects/starshine-mb/src/lib/types.mbt","/home/jtenner/.moon/lib/core/cmp/cmp.mbt","/home/jtenner/.moon/lib/core/buffer/buffer.mbt","/home/jtenner/.moon/lib/core/float/methods.mbt","/home/jtenner/.moon/lib/core/double/double.mbt","/home/jtenner/.moon/lib/core/double/internal/ryu/ryu.mbt","/home/jtenner/.moon/lib/core/builtin/array.mbt","/home/jtenner/.moon/lib/core/builtin/arraycore_nonjs.mbt","/home/jtenner/.moon/lib/core/builtin/array_block.mbt","/home/jtenner/.moon/lib/core/builtin/autoloc.mbt","/home/jtenner/.moon/lib/core/builtin/bool.mbt","/home/jtenner/.moon/lib/core/builtin/bytes.mbt","/home/jtenner/.moon/lib/core/builtin/bytes_unsafe.mbt","/home/jtenner/.moon/lib/core/builtin/byte.mbt","/home/jtenner/.moon/lib/core/builtin/bytesview.mbt","/home/jtenner/.moon/lib/core/builtin/console.mbt","/home/jtenner/.moon/lib/core/builtin/assert.mbt","/home/jtenner/.moon/lib/core/builtin/hasher.mbt","/home/jtenner/.moon/lib/core/builtin/intrinsics.mbt","/home/jtenner/.moon/lib/core/builtin/linked_hash_map.mbt","/home/jtenner/.moon/lib/core/builtin/fixedarray.mbt","/home/jtenner/.moon/lib/core/builtin/int.mbt","/home/jtenner/.moon/lib/core/builtin/option.mbt","/home/jtenner/.moon/lib/core/builtin/arrayview.mbt","/home/jtenner/.moon/lib/core/builtin/readonlyarray.mbt","/home/jtenner/.moon/lib/core/builtin/result.mbt","/home/jtenner/.moon/lib/core/builtin/show.mbt","/home/jtenner/.moon/lib/core/builtin/iterator.mbt","/home/jtenner/.moon/lib/core/builtin/stringbuilder_buffer.mbt","/home/jtenner/.moon/lib/core/builtin/failure.mbt","/home/jtenner/.moon/lib/core/builtin/to_string.mbt","/home/jtenner/.moon/lib/core/builtin/traits.mbt","/home/jtenner/.moon/lib/core/builtin/stringview.mbt","/home/jtenner/.moon/lib/core/builtin/tuple_eq.mbt","/home/jtenner/.moon/lib/core/builtin/tuple_show.mbt","/home/jtenner/.moon/lib/core/builtin/uninitialized_array.mbt","/home/jtenner/.moon/lib/core/abort/abort.mbt"],"sourcesContent":[null,"///|\npub struct AlignmentLoweringContext {\n  mut locals : Array[ValType]\n  memories : Array[MemType]\n}\n\n///|\npub fn AlignmentLoweringContext::new(\n  memories : Array[MemType],\n) -> AlignmentLoweringContext {\n  AlignmentLoweringContext::{ locals: [], memories }\n}\n\n///|\npriv enum ChunkSize {\n  ChunkSize8\n  ChunkSize16\n  ChunkSize32\n  ChunkSize64\n} derive(Eq, Show)\n\n///|\npriv enum StackSize {\n  StackSize32\n  StackSize64\n} derive(Eq, Show)\n\n///|\nfn ChunkSize::byte_count(self : ChunkSize) -> UInt {\n  match self {\n    ChunkSize8 => 1\n    ChunkSize16 => 2\n    ChunkSize32 => 4\n    ChunkSize64 => 8\n  }\n}\n\n///|\nfn store_op_stack_size(op : StoreOp) -> StackSize {\n  match op {\n    I64StoreOp => StackSize64\n    I64Store32Op => StackSize64\n    I64Store16Op => StackSize64\n    I64Store8Op => StackSize64\n    F64StoreOp => StackSize64\n    _ => StackSize32\n  }\n}\n\n///|\nfn load_op_with_chunk_size(\n  stack_size : StackSize,\n  chunk_size : ChunkSize,\n) -> Result[LoadOp, String] {\n  match (stack_size, chunk_size) {\n    (StackSize32, ChunkSize8) => Ok(I32Load8UOp)\n    (StackSize32, ChunkSize16) => Ok(I32Load16UOp)\n    (StackSize64, ChunkSize8) => Ok(I64Load8UOp)\n    (StackSize64, ChunkSize16) => Ok(I64Load16UOp)\n    (StackSize64, ChunkSize32) => Ok(I64Load32UOp)\n    // Impossible!\n    _ => Err(\"Invalid chunk size for value\")\n  }\n}\n\n///|\nfn store_op_with_chunk_size(\n  stack_size : StackSize,\n  chunk_size : ChunkSize,\n) -> Result[StoreOp, String] {\n  match (stack_size, chunk_size) {\n    (StackSize32, ChunkSize8) => Ok(I32Store8Op)\n    (StackSize32, ChunkSize16) => Ok(I32Store16Op)\n    (StackSize64, ChunkSize8) => Ok(I64Store8Op)\n    (StackSize64, ChunkSize16) => Ok(I64Store16Op)\n    (StackSize64, ChunkSize32) => Ok(I64Store32Op)\n    _ => Err(\"Invalid chunk size for store\")\n  }\n}\n\n///|\nfn get_valid_chunksize(\n  remaining : UInt,\n  align : UInt,\n  addr : UInt64,\n) -> ChunkSize {\n  if remaining >= 8 && align >= 8 && addr % 8 == 0 {\n    ChunkSize64\n  } else if remaining >= 4 && align >= 4 && addr % 4 == 0 {\n    ChunkSize32\n  } else if remaining >= 2 && align >= 2 && addr % 2 == 0 {\n    ChunkSize16\n  } else {\n    ChunkSize8\n  }\n}\n\n///|\nfn load_op_stack_size(op : LoadOp) -> StackSize {\n  match op {\n    V128Load64SplatOp => StackSize64\n    I64Load32UOp => StackSize64\n    I64Load32SOp => StackSize64\n    I64Load16UOp => StackSize64\n    I64Load16SOp => StackSize64\n    I64Load8UOp => StackSize64\n    I64Load8SOp => StackSize64\n    F64LoadOp => StackSize64\n    I64LoadOp => StackSize64\n    V128Load64ZeroOp => StackSize64\n    V128Load8x8SOp => StackSize64\n    V128Load8x8UOp => StackSize64\n    V128Load16x4SOp => StackSize64\n    V128Load16x4UOp => StackSize64\n    V128Load32x2SOp => StackSize64\n    V128Load32x2UOp => StackSize64\n    _ => StackSize32\n  }\n}\n\n///|\nfn chunks(\n  op_size : UInt,\n  align : UInt,\n  offset : UInt64,\n) -> Array[(ChunkSize, UInt64)] {\n  let acc = []\n  loop 0U {\n    pos if pos < op_size => {\n      let addr = offset + pos.to_uint64()\n      let remaining = op_size - pos\n      let result = get_valid_chunksize(remaining, align, addr)\n      acc.push((result, pos.to_uint64()))\n      continue pos + result.byte_count()\n    }\n    _ => break acc\n  }\n}\n\n///|\nfn size_of_load_op(t : LoadOp) -> UInt {\n  match t {\n    V128Load32ZeroOp => 4\n    V128Load64SplatOp => 8\n    V128Load32SplatOp => 4\n    V128Load16SplatOp => 2\n    V128Load8SplatOp => 1\n    V128Load32x2UOp => 8\n    V128Load32x2SOp => 8\n    V128Load16x4UOp => 8\n    V128Load16x4SOp => 8\n    V128Load8x8UOp => 8\n    V128Load8x8SOp => 8\n    V128LoadOp => 16\n    I64Load32UOp => 4\n    I64Load32SOp => 4\n    I64Load16UOp => 2\n    I64Load16SOp => 2\n    I64Load8UOp => 1\n    I64Load8SOp => 1\n    I32Load16UOp => 2\n    I32Load16SOp => 2\n    I32Load8UOp => 1\n    I32Load8SOp => 1\n    F64LoadOp => 8\n    F32LoadOp => 4\n    I64LoadOp => 8\n    I32LoadOp => 4\n    V128Load64ZeroOp => 8\n  }\n}\n\n///|\nfn size_of_store_op(t : StoreOp) -> UInt {\n  match t {\n    I64Store32Op => 4\n    I64Store16Op => 2\n    I64Store8Op => 1\n    I32Store16Op => 2\n    I32Store8Op => 1\n    F64StoreOp => 8\n    F32StoreOp => 4\n    I64StoreOp => 8\n    I32StoreOp => 4\n    V128StoreOp => 16\n  }\n}\n\n///|\nfn size_of_v128_load_lane_op(t : V128LoadLaneOp) -> UInt {\n  match t {\n    V128Load32LaneOp => 4\n    V128Load16LaneOp => 2\n    V128Load8LaneOp => 1\n    V128Load64LaneOp => 8\n  }\n}\n\n///|\nfn load_shift_op(\n  stack_size : StackSize,\n  offset : UInt64,\n  op : TInstr,\n) -> TInstr {\n  match stack_size {\n    StackSize32 =>\n      TBinary(@lib.I32ShlOp, op, TI32Const(I32(offset.to_int() * 8)))\n    StackSize64 =>\n      TBinary(\n        @lib.I64ShlOp,\n        op,\n        TI64Const(I64(offset.reinterpret_as_int64() * 8)),\n      )\n  }\n}\n\n///|\nfn store_shift_op(\n  stack_size : StackSize,\n  offset : UInt64,\n  op : TInstr,\n) -> TInstr {\n  if offset == 0UL {\n    return op\n  }\n  match stack_size {\n    StackSize32 =>\n      TBinary(@lib.I32ShrUOp, op, TI32Const(I32(offset.to_int() * 8)))\n    StackSize64 =>\n      TBinary(\n        @lib.I64ShrUOp,\n        op,\n        TI64Const(I64(offset.reinterpret_as_int64() * 8)),\n      )\n  }\n}\n\n///|\nfn prepare_store_value(op : StoreOp, value : TInstr) -> TInstr {\n  match op {\n    F64StoreOp => TUnary(I64ReinterpretF64Op, value)\n    F32StoreOp => TUnary(I32ReinterpretF32Op, value)\n    _ => value\n  }\n}\n\n///|\nfn finalize_v128_extending_load(\n  op : LoadOp,\n  stack_size : StackSize,\n  i : TInstr,\n  is_signed : Bool,\n) -> TInstr {\n  let chunk_idx = match op {\n    V128Load8x8SOp | V128Load8x8UOp => 8U\n    V128Load16x4SOp | V128Load16x4UOp => 4U\n    V128Load32x2SOp | V128Load32x2UOp => 2U\n    _ => 0U // Should not happen\n  }\n\n  // The byte offset where the value is located\n  let byte_offset = chunk_idx * 8U - 8U\n  let shift = byte_offset.reinterpret_as_int() * 8\n\n  // Extract the value at the correct position\n  let extracted = @lib.TExtractLane(\n    I8x16ExtractLaneUOp,\n    LaneIdx(byte_offset.to_byte()),\n    i,\n  )\n  match stack_size {\n    StackSize32 => {\n      let shifted = @lib.TBinary(I32ShlOp, extracted, TI32Const(I32(shift)))\n      if is_signed {\n        let sign_mask = @lib.TBinary(\n          I32ShlOp,\n          TBinary(I32ShrSOp, extracted, TI32Const(I32(7))),\n          TI32Const(I32(shift)),\n        )\n        @lib.TBinary(I32OrOp, shifted, sign_mask)\n      } else {\n        shifted\n      }\n    }\n    StackSize64 => {\n      let extracted_i64 = @lib.TUnary(I64ExtendI32UOp, extracted)\n      let shifted = @lib.TBinary(\n        I64ShlOp,\n        extracted_i64,\n        TI64Const(I64(shift.to_int64())),\n      )\n      if is_signed {\n        let sign_mask = @lib.TBinary(\n          I64ShlOp,\n          TBinary(\n            I64ShrSOp,\n            TUnary(I64ExtendI32SOp, extracted),\n            TI64Const(I64(7)),\n          ),\n          TI64Const(I64(shift.to_int64())),\n        )\n        @lib.TBinary(I64OrOp, shifted, sign_mask)\n      } else {\n        shifted\n      }\n    }\n  }\n}\n\n///|\nfn finalize_load_op(op : LoadOp, i : TInstr) -> TInstr {\n  match op {\n    V128Load64SplatOp => TI64x2Splat(i)\n    V128Load32SplatOp => TI32x4Splat(i)\n    V128Load16SplatOp => TI16x8Splat(i)\n    V128Load8SplatOp => TI8x16Splat(i)\n    V128Load32ZeroOp =>\n      TReplaceLane(\n        I32x4ReplaceLaneOp,\n        LaneIdx(0),\n        TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n        i,\n      )\n    V128Load64ZeroOp =>\n      TReplaceLane(\n        I64x2ReplaceLaneOp,\n        LaneIdx(0),\n        TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n        i,\n      )\n    V128LoadOp => i\n    I64Load32UOp => i\n    I64Load32SOp => TUnary(I64Extend32SOp, i)\n    I64Load16UOp => i\n    I64Load16SOp => TUnary(I64Extend16SOp, i)\n    I64Load8UOp => i\n    I64Load8SOp => TUnary(I64Extend8SOp, i)\n    I32Load16UOp => i\n    I32Load16SOp => TUnary(I32Extend16SOp, i)\n    I32Load8UOp => i\n    I32Load8SOp => TUnary(I32Extend8SOp, i)\n    F64LoadOp => TUnary(F64ReinterpretI64Op, i)\n    F32LoadOp => TUnary(F32ReinterpretI32Op, i)\n    I64LoadOp => i\n    I32LoadOp => i\n    // TODO: V128 extending loads need more work\n    // Signed extending loads\n    V128Load32x2SOp =>\n      finalize_v128_extending_load(op, load_op_stack_size(op), i, true)\n    V128Load16x4SOp =>\n      finalize_v128_extending_load(op, load_op_stack_size(op), i, true)\n    V128Load8x8SOp =>\n      finalize_v128_extending_load(op, load_op_stack_size(op), i, true)\n    // Unsigned extending loads\n    V128Load32x2UOp =>\n      finalize_v128_extending_load(op, load_op_stack_size(op), i, false)\n    V128Load16x4UOp =>\n      finalize_v128_extending_load(op, load_op_stack_size(op), i, false)\n    V128Load8x8UOp =>\n      finalize_v128_extending_load(op, load_op_stack_size(op), i, false)\n  }\n}\n\n///|\nfn load_or_op(stack_size : StackSize, l : TInstr, r : TInstr) -> TInstr {\n  match stack_size {\n    StackSize32 => TBinary(I32OrOp, l, r)\n    StackSize64 => TBinary(I64OrOp, l, r)\n  }\n}\n\n///|\npub fn alignment_lowering_pass() -> ModuleTransformer[AlignmentLoweringContext] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_func: Some(fn(self, t, i) {\n      match i {\n        Func(_) => Err(\"Expected TFunc\")\n        TFunc(locals, b) => {\n          t.locals = locals\n          match self.walk_func_default(t, TFunc(locals, b)) {\n            Ok(Some((t, func))) =>\n              match func {\n                TFunc(_, b) => change(t, TFunc(t.locals, b))\n                _ => Err(\"Expected TFunc\")\n              }\n            Err(t) => Err(t)\n            Ok(None) => unchanged()\n          }\n        }\n      }\n    }),\n    on_tinstruction: Some(fn(self, t, i) {\n      match i {\n        TLoad(op, MemArg(U32(align), mem_option, U64(offset)), a) => {\n          let a = match self.walk_tinstruction_default(t, a) {\n            Ok(Some((_, a))) => a\n            Ok(None) => a\n            Err(e) => return Err(e)\n          }\n          let op_size = size_of_load_op(op)\n          if op_size > 8 {\n            return change(\n              t,\n              TLoad(op, MemArg(U32(align), mem_option, U64(offset)), a),\n            )\n          }\n          let effective_align = @cmp.minimum(align, op_size)\n          let c = chunks(op_size, effective_align, offset)\n          if c.length() == 1 {\n            return change(\n              t,\n              TLoad(op, MemArg(U32(align), mem_option, U64(offset)), a),\n            )\n          }\n          let mem_idx = match mem_option {\n            Some(MemIdx(mem_idx)) => mem_idx.reinterpret_as_int()\n            None => 0\n          }\n          let ptr_valtype = match t.memories.get(mem_idx) {\n            Some(mem_type) => mem_type.0.addr_valtype()\n            None => return Err(\"Invalid memory index\")\n          }\n          let next = t.locals.length().reinterpret_as_uint()\n          t.locals.push(ptr_valtype)\n          let local_idx = @lib.LocalIdx(next)\n          let ptr_start_set = @lib.TLocalTee(local_idx, a)\n          let value_stack_size = load_op_stack_size(op)\n          let first = c[0]\n          let chunk_byte_count = first.0.byte_count()\n          let load_op = match\n            load_op_with_chunk_size(value_stack_size, first.0) {\n            Ok(t) => t\n            Err(e) => return Err(e)\n          }\n          let first_load = @lib.TLoad(\n            load_op,\n            MemArg(U32(chunk_byte_count), mem_option, U64(offset + first.1)),\n            ptr_start_set,\n          )\n          let mut acc = load_shift_op(value_stack_size, first.1, first_load)\n          loop 1 {\n            n if c.get(n) is Some((chunk_size, relative_offset)) => {\n              let chunk_byte_count = chunk_size.byte_count()\n              let load_op = match\n                load_op_with_chunk_size(value_stack_size, chunk_size) {\n                Ok(t) => t\n                Err(e) => return Err(e)\n              }\n              let load_instr = @lib.TLoad(\n                load_op,\n                MemArg(\n                  U32(chunk_byte_count),\n                  mem_option,\n                  U64(relative_offset + offset),\n                ),\n                TLocalGet(local_idx),\n              )\n              let shift_op = load_shift_op(\n                value_stack_size, relative_offset, load_instr,\n              )\n              acc = load_or_op(value_stack_size, shift_op, acc)\n              continue n + 1\n            }\n            _ => break change(t, finalize_load_op(op, acc))\n          }\n        }\n        TStore(op, MemArg(U32(align), mem_option, U64(offset)), a, b) => {\n          let a = match self.walk_tinstruction(t, a) {\n            Ok(Some((_, a))) => a\n            Ok(None) => a\n            Err(e) => return Err(e)\n          }\n          let b = match self.walk_tinstruction(t, b) {\n            Ok(Some((_, b))) => b\n            Ok(None) => b\n            Err(e) => return Err(e)\n          }\n          let op_size = size_of_store_op(op)\n          if op_size > 8 {\n            return change(\n              t,\n              TStore(op, MemArg(U32(align), mem_option, U64(offset)), a, b),\n            )\n          }\n          let effective_align = @cmp.minimum(align, op_size)\n          let c = chunks(op_size, effective_align, offset)\n          if c.length() == 1 {\n            return change(\n              t,\n              TStore(op, MemArg(U32(align), mem_option, U64(offset)), a, b),\n            )\n          }\n\n          // Need locals for both pointer and value\n          let mem_idx = match mem_option {\n            Some(MemIdx(mem_idx)) => mem_idx.reinterpret_as_int()\n            None => 0\n          }\n          let ptr_valtype = match t.memories.get(mem_idx) {\n            Some(mem_type) => mem_type.0.addr_valtype()\n            None => return Err(\"Invalid memory index\")\n          }\n          let ptr_local_idx = t.locals.length().reinterpret_as_uint()\n          t.locals.push(ptr_valtype)\n          let ptr_local = @lib.LocalIdx(ptr_local_idx)\n          let value_stack_size = store_op_stack_size(op)\n          let value_valtype = match value_stack_size {\n            StackSize32 => @lib.vt_i32()\n            StackSize64 => @lib.vt_i64()\n          }\n          let value_local_idx = t.locals.length().reinterpret_as_uint()\n          t.locals.push(value_valtype)\n          let value_local = @lib.LocalIdx(value_local_idx)\n\n          // Prepare the value (reinterpret floats to ints)\n          let prepared_value = prepare_store_value(op, b)\n\n          // Build a block containing all the stores\n          let stores : Array[TInstr] = []\n\n          // First instruction: set both locals\n          // We'll use TLocalSet for ptr and TLocalTee for value, then drop\n          stores.push(@lib.TLocalSet(ptr_local, a))\n          stores.push(@lib.TLocalSet(value_local, prepared_value))\n          for i = 0; i < c.length(); i = i + 1 {\n            let (chunk_size, relative_offset) = c[i]\n            let chunk_byte_count = chunk_size.byte_count()\n            let store_op = match\n              store_op_with_chunk_size(value_stack_size, chunk_size) {\n              Ok(t) => t\n              Err(e) => return Err(e)\n            }\n            let shifted_value = store_shift_op(\n              value_stack_size,\n              relative_offset,\n              TLocalGet(value_local),\n            )\n            let store_instr = @lib.TStore(\n              store_op,\n              MemArg(\n                U32(chunk_byte_count),\n                mem_option,\n                U64(offset + relative_offset),\n              ),\n              TLocalGet(ptr_local),\n              shifted_value,\n            )\n            stores.push(store_instr)\n          }\n\n          // Wrap in a block with empty result type\n          change(t, TBlock(EmptyBlockType, TExpr(stores)))\n        }\n        TV128LoadLane(\n          op,\n          MemArg(U32(align), mem_option, U64(offset)),\n          lane,\n          a,\n          b\n        ) => {\n          let op_size = size_of_v128_load_lane_op(op)\n          let effective_align = @cmp.minimum(align, op_size)\n          let a = match self.walk_tinstruction_default(t, a) {\n            Ok(Some((_, a))) => a\n            Ok(None) => a\n            Err(e) => return Err(e)\n          }\n          let b = match self.walk_tinstruction_default(t, b) {\n            Ok(Some((_, b))) => b\n            Ok(None) => b\n            Err(e) => return Err(e)\n          }\n          let c = chunks(op_size, effective_align, offset)\n          if c.length() == 1 {\n            return change(\n              t,\n              TV128LoadLane(\n                op,\n                MemArg(U32(align), mem_option, U64(offset)),\n                lane,\n                a,\n                b,\n              ),\n            )\n          }\n\n          // For V128LoadLane with unaligned access, we load the value using\n          // regular unaligned load logic, then use replace_lane\n          let mem_idx = match mem_option {\n            Some(MemIdx(mem_idx)) => mem_idx.reinterpret_as_int()\n            None => 0\n          }\n          let ptr_valtype = match t.memories.get(mem_idx) {\n            Some(mem_type) => mem_type.0.addr_valtype()\n            None => return Err(\"Invalid memory index\")\n          }\n          let ptr_local_idx = t.locals.length().reinterpret_as_uint()\n          t.locals.push(ptr_valtype)\n          let ptr_local = @lib.LocalIdx(ptr_local_idx)\n\n          // Determine the load operation based on lane size\n          let (replace_op, stack_size) = match op {\n            V128Load8LaneOp => (@lib.I8x16ReplaceLaneOp, StackSize32)\n            V128Load16LaneOp => (@lib.I16x8ReplaceLaneOp, StackSize32)\n            V128Load32LaneOp => (@lib.I32x4ReplaceLaneOp, StackSize32)\n            V128Load64LaneOp => (@lib.I64x2ReplaceLaneOp, StackSize64)\n          }\n\n          // Build the chunked load\n          let first = c[0]\n          let chunk_byte_count = first.0.byte_count()\n          let chunk_load_op = match\n            load_op_with_chunk_size(stack_size, first.0) {\n            Ok(t) => t\n            Err(e) => return Err(e)\n          }\n          let first_load = @lib.TLoad(\n            chunk_load_op,\n            MemArg(U32(chunk_byte_count), mem_option, U64(offset + first.1)),\n            TLocalTee(ptr_local, a),\n          )\n          let mut acc = load_shift_op(stack_size, first.1, first_load)\n          for i = 1; i < c.length(); i = i + 1 {\n            let (chunk_size, relative_offset) = c[i]\n            let chunk_byte_count = chunk_size.byte_count()\n            let chunk_load_op = match\n              load_op_with_chunk_size(stack_size, chunk_size) {\n              Ok(t) => t\n              Err(e) => return Err(e)\n            }\n            let load_instr = @lib.TLoad(\n              chunk_load_op,\n              MemArg(\n                U32(chunk_byte_count),\n                mem_option,\n                U64(relative_offset + offset),\n              ),\n              TLocalGet(ptr_local),\n            )\n            let shift_op = load_shift_op(\n              stack_size, relative_offset, load_instr,\n            )\n            acc = load_or_op(stack_size, shift_op, acc)\n          }\n\n          // Use replace_lane to put the loaded value into the vector\n          change(t, TReplaceLane(replace_op, lane, b, acc))\n        }\n        _ => self.walk_tinstruction_default(t, i)\n      }\n    }),\n  }\n}\n\n// alignment_lowering_test.mbt\n\n///|\nfn make_ctx(memories : Array[MemType]) -> AlignmentLoweringContext {\n  AlignmentLoweringContext::new(memories)\n}\n\n///|\nfn make_i32_mem() -> Array[MemType] {\n  [MemType(I32Limits(1, None))]\n}\n\n///|\nfn make_i64_mem() -> Array[MemType] {\n  [MemType(I64Limits(1, None))]\n}\n\n///|\nfn run_pass(\n  ctx : AlignmentLoweringContext,\n  instr : TInstr,\n) -> Result[TInstr, String] {\n  let pass = alignment_lowering_pass()\n  match pass.walk_tinstruction(ctx, instr) {\n    Ok(Some((_, result))) => Ok(result)\n    Ok(None) => Ok(instr)\n    Err(e) => Err(e)\n  }\n}\n\n///|\nfn run_func_pass(\n  ctx : AlignmentLoweringContext,\n  locals : Array[ValType],\n  body : Array[TInstr],\n) -> Result[(Array[ValType], TExpr), String] {\n  let pass = alignment_lowering_pass()\n  let func = @lib.TFunc(locals, TExpr(body))\n  match pass.walk_func(ctx, func) {\n    Ok(Some((_, TFunc(new_locals, new_body)))) => Ok((new_locals, new_body))\n    Ok(None) =>\n      match func {\n        TFunc(l, b) => Ok((l, b))\n        _ => Err(\"Expected TFunc\")\n      }\n    Ok(Some((_, _))) => Err(\"Expected TFunc\")\n    Err(e) => Err(e)\n  }\n}\n\n// ============================================================\n// Tests for `chunks` function\n// ============================================================\n\n///|\ntest \"chunks: aligned 4-byte access produces single chunk\" {\n  let c = chunks(4, 4, 0)\n  assert_eq(c.length(), 1)\n  assert_eq(c[0], (ChunkSize32, 0UL))\n}\n\n///|\ntest \"chunks: aligned 8-byte access produces single chunk\" {\n  let c = chunks(8, 8, 0)\n  assert_eq(c.length(), 1)\n  assert_eq(c[0], (ChunkSize64, 0UL))\n}\n\n///|\ntest \"chunks: 4-byte access with 1-byte alignment produces 4 chunks\" {\n  let c = chunks(4, 1, 0)\n  assert_eq(c.length(), 4)\n  assert_eq(c[0], (ChunkSize8, 0UL))\n  assert_eq(c[1], (ChunkSize8, 1UL))\n  assert_eq(c[2], (ChunkSize8, 2UL))\n  assert_eq(c[3], (ChunkSize8, 3UL))\n}\n\n///|\ntest \"chunks: 4-byte access with 2-byte alignment produces 2 chunks\" {\n  let c = chunks(4, 2, 0)\n  assert_eq(c.length(), 2)\n  assert_eq(c[0], (ChunkSize16, 0UL))\n  assert_eq(c[1], (ChunkSize16, 2UL))\n}\n\n///|\ntest \"chunks: 8-byte access with 1-byte alignment produces 8 chunks\" {\n  let c = chunks(8, 1, 0)\n  assert_eq(c.length(), 8)\n  for i = 0; i < 8; i = i + 1 {\n    assert_eq(c[i], (ChunkSize8, i.to_uint64()))\n  }\n}\n\n///|\ntest \"chunks: 8-byte access with 2-byte alignment produces 4 chunks\" {\n  let c = chunks(8, 2, 0)\n  assert_eq(c.length(), 4)\n  assert_eq(c[0], (ChunkSize16, 0UL))\n  assert_eq(c[1], (ChunkSize16, 2UL))\n  assert_eq(c[2], (ChunkSize16, 4UL))\n  assert_eq(c[3], (ChunkSize16, 6UL))\n}\n\n///|\ntest \"chunks: 8-byte access with 4-byte alignment produces 2 chunks\" {\n  let c = chunks(8, 4, 0)\n  assert_eq(c.length(), 2)\n  assert_eq(c[0], (ChunkSize32, 0UL))\n  assert_eq(c[1], (ChunkSize32, 4UL))\n}\n\n///|\ntest \"chunks: unaligned offset affects chunking\" {\n  // Offset 1 with align 4 - first byte can only be 1-byte\n  let c = chunks(4, 4, 1)\n  // At offset 1, we can't use 4-byte aligned access\n  assert_true(c.length() > 1)\n}\n\n// ============================================================\n// Tests for aligned loads (should pass through unchanged)\n// ============================================================\n\n///|\ntest \"aligned i32 load passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(4), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(I32LoadOp, MemArg(U32(4), None, U64(0)), _)) => ()\n    _ => fail(\"Expected unchanged aligned load\")\n  }\n}\n\n///|\ntest \"aligned i64 load passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    I64LoadOp,\n    MemArg(U32(8), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(I64LoadOp, MemArg(U32(8), None, U64(0)), _)) => ()\n    _ => fail(\"Expected unchanged aligned load\")\n  }\n}\n\n///|\ntest \"aligned f32 load passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    F32LoadOp,\n    MemArg(U32(4), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(F32LoadOp, MemArg(U32(4), None, U64(0)), _)) => ()\n    _ => fail(\"Expected unchanged aligned load\")\n  }\n}\n\n///|\ntest \"aligned f64 load passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    F64LoadOp,\n    MemArg(U32(8), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(F64LoadOp, MemArg(U32(8), None, U64(0)), _)) => ()\n    _ => fail(\"Expected unchanged aligned load\")\n  }\n}\n\n// ============================================================\n// Tests for unaligned loads (should be split)\n// ============================================================\n\n///|\ntest \"unaligned i32 load with align=1 is split\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()] // One local for the address\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load, got single load\")\n    Ok(TBinary(I32OrOp, _, _)) => () // Should be OR'd together\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned i32 load with align=2 is split into 2 loads\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(2), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I32OrOp, _, _)) => ()\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned i64 load with align=1 is split\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I64LoadOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I64OrOp, _, _)) => ()\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned i64 load with align=4 is split into 2 loads\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I64LoadOp,\n    MemArg(U32(4), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I64OrOp, _, _)) => ()\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned f32 load produces reinterpret wrapper\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    F32LoadOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TUnary(F32ReinterpretI32Op, _)) => ()\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load with reinterpret\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned f64 load produces reinterpret wrapper\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    F64LoadOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TUnary(F64ReinterpretI64Op, _)) => ()\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load with reinterpret\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for partial loads (i32.load8, i32.load16, etc.)\n// ============================================================\n\n///|\ntest \"i32.load8 always passes through (naturally aligned)\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    I32Load8UOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(I32Load8UOp, _, _)) => ()\n    _ => fail(\"Expected unchanged i32.load8\")\n  }\n}\n\n///|\ntest \"i32.load16 with align=1 is split\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I32Load16UOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I32OrOp, _, _)) => ()\n    Ok(TLoad(I32Load16UOp, MemArg(U32(2), _, _), _)) =>\n      fail(\"Expected split load\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"i64.load32 with align=2 is split\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I64Load32UOp,\n    MemArg(U32(2), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I64OrOp, _, _)) => ()\n    Ok(TLoad(_, _, _)) => fail(\"Expected split load\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for aligned stores (should pass through unchanged)\n// ============================================================\n\n///|\ntest \"aligned i32 store passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(4), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI32Const(I32(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TStore(I32StoreOp, MemArg(U32(4), None, U64(0)), _, _)) => ()\n    _ => fail(\"Expected unchanged aligned store\")\n  }\n}\n\n///|\ntest \"aligned i64 store passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TStore(\n    I64StoreOp,\n    MemArg(U32(8), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI64Const(I64(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TStore(I64StoreOp, MemArg(U32(8), None, U64(0)), _, _)) => ()\n    _ => fail(\"Expected unchanged aligned store\")\n  }\n}\n\n///|\ntest \"aligned f32 store passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TStore(\n    F32StoreOp,\n    MemArg(U32(4), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TF32Const(F32(3.14)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TStore(F32StoreOp, MemArg(U32(4), None, U64(0)), _, _)) => ()\n    _ => fail(\"Expected unchanged aligned store\")\n  }\n}\n\n// ============================================================\n// Tests for unaligned stores (should be split into block)\n// ============================================================\n\n///|\ntest \"unaligned i32 store with align=1 produces block\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI32Const(I32(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, _)) => ()\n    Ok(TStore(_, _, _, _)) => fail(\"Expected block with split stores\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned i32 store with align=2 produces block\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(2), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI32Const(I32(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, _)) => ()\n    Ok(TStore(_, _, _, _)) => fail(\"Expected block with split stores\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned i64 store with align=1 produces block\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    I64StoreOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI64Const(I64(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, _)) => ()\n    Ok(TStore(_, _, _, _)) => fail(\"Expected block with split stores\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned f32 store produces block with reinterpret\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    F32StoreOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TF32Const(F32(3.14)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, TExpr(instrs))) =>\n      // Should have local sets followed by stores\n      assert_true(instrs.length() > 2)\n    Ok(TStore(_, _, _, _)) => fail(\"Expected block with split stores\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned f64 store produces block with reinterpret\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    F64StoreOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TF64Const(F64(3.14)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, TExpr(instrs))) =>\n      assert_true(instrs.length() > 2)\n    Ok(TStore(_, _, _, _)) => fail(\"Expected block with split stores\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for store block structure\n// ============================================================\n\n///|\ntest \"unaligned i32 store block has correct structure\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI32Const(I32(0x12345678)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, TExpr(instrs))) => {\n      // First two instructions should be local.set for ptr and value\n      match instrs[0] {\n        TLocalSet(_, _) => ()\n        other => fail(\"Expected TLocalSet, got \\{other}\")\n      }\n      match instrs[1] {\n        TLocalSet(_, _) => ()\n        other => fail(\"Expected TLocalSet, got \\{other}\")\n      }\n      // Remaining should be stores\n      for i = 2; i < instrs.length(); i = i + 1 {\n        match instrs[i] {\n          TStore(_, _, _, _) => ()\n          other => fail(\"Expected TStore at index \\{i}, got \\{other}\")\n        }\n      }\n      // Should have 4 byte stores for align=1\n      assert_eq(instrs.length(), 6) // 2 local.set + 4 stores\n    }\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for V128 operations\n// ============================================================\n\n///|\ntest \"v128 load with size > 8 passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    V128LoadOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(V128LoadOp, _, _)) => ()\n    _ => fail(\"Expected v128 load to pass through (size > 8)\")\n  }\n}\n\n///|\ntest \"v128 store with size > 8 passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TStore(\n    V128StoreOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TStore(V128StoreOp, _, _, _)) => ()\n    _ => fail(\"Expected v128 store to pass through (size > 8)\")\n  }\n}\n\n// ============================================================\n// Tests for V128 load splat operations\n// ============================================================\n\n///|\ntest \"v128.load64_splat aligned passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    V128Load64SplatOp,\n    MemArg(U32(8), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TLoad(V128Load64SplatOp, _, _)) => ()\n    _ => fail(\"Expected aligned v128.load64_splat to pass through\")\n  }\n}\n\n///|\ntest \"v128.load64_splat unaligned produces splat wrapper\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    V128Load64SplatOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TI64x2Splat(_)) => ()\n    Ok(TLoad(V128Load64SplatOp, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"v128.load32_splat unaligned produces splat wrapper\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    V128Load32SplatOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TI32x4Splat(_)) => ()\n    Ok(TLoad(V128Load32SplatOp, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for V128 load zero operations\n// ============================================================\n\n///|\ntest \"v128.load64_zero unaligned produces replace_lane\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    V128Load64ZeroOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TReplaceLane(I64x2ReplaceLaneOp, LaneIdx(0), _, _)) => ()\n    Ok(TLoad(V128Load64ZeroOp, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"v128.load32_zero unaligned produces replace_lane\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    V128Load32ZeroOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TReplaceLane(I32x4ReplaceLaneOp, LaneIdx(0), _, _)) => ()\n    Ok(TLoad(V128Load32ZeroOp, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for V128LoadLane operations\n// ============================================================\n\n///|\ntest \"v128.load8_lane aligned passes through\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TV128LoadLane(\n    V128Load8LaneOp,\n    MemArg(U32(1), None, U64(0)),\n    LaneIdx(0),\n    TLocalGet(LocalIdx(0)),\n    TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TV128LoadLane(V128Load8LaneOp, _, _, _, _)) => ()\n    _ => fail(\"Expected aligned v128.load8_lane to pass through\")\n  }\n}\n\n///|\ntest \"v128.load16_lane unaligned produces replace_lane\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TV128LoadLane(\n    V128Load16LaneOp,\n    MemArg(U32(1), None, U64(0)),\n    LaneIdx(0),\n    TLocalGet(LocalIdx(0)),\n    TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TReplaceLane(I16x8ReplaceLaneOp, LaneIdx(0), _, _)) => ()\n    Ok(TV128LoadLane(_, _, _, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"v128.load32_lane unaligned produces replace_lane\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TV128LoadLane(\n    V128Load32LaneOp,\n    MemArg(U32(1), None, U64(0)),\n    LaneIdx(0),\n    TLocalGet(LocalIdx(0)),\n    TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TReplaceLane(I32x4ReplaceLaneOp, LaneIdx(0), _, _)) => ()\n    Ok(TV128LoadLane(_, _, _, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"v128.load64_lane unaligned produces replace_lane\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TV128LoadLane(\n    V128Load64LaneOp,\n    MemArg(U32(1), None, U64(0)),\n    LaneIdx(0),\n    TLocalGet(LocalIdx(0)),\n    TV128Const(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TReplaceLane(I64x2ReplaceLaneOp, LaneIdx(0), _, _)) => ()\n    Ok(TV128LoadLane(_, _, _, _, _)) => fail(\"Expected unaligned to be split\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for memory index handling\n// ============================================================\n\n///|\ntest \"load with explicit memory index\" {\n  let ctx = make_ctx([MemType(I32Limits(1, None)), MemType(I64Limits(1, None))])\n  ctx.locals = [vt_i64()]\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(1), Some(MemIdx(1)), U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  // Should succeed and use i64 for pointer local (memory 1 is i64)\n  match result {\n    Ok(_) => ()\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"store with explicit memory index\" {\n  let ctx = make_ctx([MemType(I32Limits(1, None)), MemType(I64Limits(1, None))])\n  ctx.locals = [vt_i64()]\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(1), Some(MemIdx(1)), U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TI32Const(I32(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(_) => ()\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"invalid memory index returns error\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(1), Some(MemIdx(99)), U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Err(_) => ()\n    Ok(_) => fail(\"Expected error for invalid memory index\")\n  }\n}\n\n// ============================================================\n// Tests for local allocation in function context\n// ============================================================\n\n///|\ntest \"unaligned load allocates new local for pointer\" {\n  let ctx = make_ctx(make_i32_mem())\n  let initial_locals : Array[ValType] = [vt_i32()]\n  let body = [\n    @lib.TLoad(I32LoadOp, MemArg(U32(1), None, U64(0)), TLocalGet(LocalIdx(0))),\n  ]\n  let result = run_func_pass(ctx, initial_locals, body)\n  match result {\n    Ok((new_locals, _)) => {\n      // Should have added one local for pointer\n      assert_eq(new_locals.length(), 2)\n      assert_eq(new_locals[1], vt_i32())\n    }\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"unaligned store allocates locals for pointer and value\" {\n  let ctx = make_ctx(make_i32_mem())\n  let initial_locals : Array[ValType] = [vt_i32()]\n  let body = [\n    @lib.TStore(\n      I32StoreOp,\n      MemArg(U32(1), None, U64(0)),\n      TLocalGet(LocalIdx(0)),\n      TI32Const(I32(42)),\n    ),\n  ]\n  let result = run_func_pass(ctx, initial_locals, body)\n  match result {\n    Ok((new_locals, _)) =>\n      // Should have added two locals: one for pointer, one for value\n      assert_eq(new_locals.length(), 3)\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"i64 store allocates i64 value local\" {\n  let ctx = make_ctx(make_i32_mem())\n  let initial_locals : Array[ValType] = [vt_i32()]\n  let body = [\n    @lib.TStore(\n      I64StoreOp,\n      MemArg(U32(1), None, U64(0)),\n      TLocalGet(LocalIdx(0)),\n      TI64Const(I64(42)),\n    ),\n  ]\n  let result = run_func_pass(ctx, initial_locals, body)\n  match result {\n    Ok((new_locals, _)) => {\n      assert_eq(new_locals.length(), 3)\n      assert_eq(new_locals[1], vt_i32()) // pointer\n      assert_eq(new_locals[2], vt_i64()) // value\n    }\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for sign extension in loads\n// ============================================================\n\n///|\ntest \"i32.load8_s unaligned produces sign extension\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    I32Load8SOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TUnary(I32Extend8SOp, _)) => ()\n    Ok(TLoad(I32Load8SOp, _, _)) => () // Also valid - single byte is already aligned\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"i32.load16_s unaligned produces sign extension\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I32Load16SOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TUnary(I32Extend16SOp, _)) => ()\n    Ok(TLoad(I32Load16SOp, _, _)) => fail(\"Expected sign extension wrapper\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"i64.load32_s unaligned produces sign extension\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I64Load32SOp,\n    MemArg(U32(1), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TUnary(I64Extend32SOp, _)) => ()\n    Ok(TLoad(I64Load32SOp, _, _)) => fail(\"Expected sign extension wrapper\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for offset handling\n// ============================================================\n\n///|\ntest \"load with non-zero offset\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(1), None, U64(100)),\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I32OrOp, _, _)) => ()\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n///|\ntest \"store with non-zero offset\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32()]\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(1), None, U64(100)),\n    TLocalGet(LocalIdx(0)),\n    TI32Const(I32(42)),\n  )\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBlock(EmptyBlockType, _)) => ()\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for nested instruction transformation\n// ============================================================\n\n///|\ntest \"nested instructions are transformed\" {\n  let ctx = make_ctx(make_i32_mem())\n  ctx.locals = [vt_i32(), vt_i32()]\n  // Load inside a store\n  let instr = @lib.TStore(\n    I32StoreOp,\n    MemArg(U32(4), None, U64(0)),\n    TLocalGet(LocalIdx(0)),\n    TLoad(I32LoadOp, MemArg(U32(1), None, U64(0)), TLocalGet(LocalIdx(1))),\n  )\n  let result = run_pass(ctx, instr)\n  // The inner load should be transformed even if outer store is aligned\n  match result {\n    Ok(TStore(I32StoreOp, _, _, TBinary(I32OrOp, _, _))) => ()\n    Ok(TStore(I32StoreOp, _, _, TLoad(I32LoadOp, _, _))) =>\n      fail(\"Inner load should have been transformed\")\n    Ok(other) => fail(\"Unexpected result: \\{other}\")\n    Err(e) => fail(\"Error: \\{e}\")\n  }\n}\n\n// ============================================================\n// Tests for helper functions\n// ============================================================\n\n///|\ntest \"size_of_load_op returns correct sizes\" {\n  assert_eq(size_of_load_op(I32LoadOp), 4)\n  assert_eq(size_of_load_op(I64LoadOp), 8)\n  assert_eq(size_of_load_op(F32LoadOp), 4)\n  assert_eq(size_of_load_op(F64LoadOp), 8)\n  assert_eq(size_of_load_op(I32Load8UOp), 1)\n  assert_eq(size_of_load_op(I32Load8SOp), 1)\n  assert_eq(size_of_load_op(I32Load16UOp), 2)\n  assert_eq(size_of_load_op(I32Load16SOp), 2)\n  assert_eq(size_of_load_op(I64Load8UOp), 1)\n  assert_eq(size_of_load_op(I64Load16UOp), 2)\n  assert_eq(size_of_load_op(I64Load32UOp), 4)\n  assert_eq(size_of_load_op(V128LoadOp), 16)\n}\n\n///|\ntest \"size_of_store_op returns correct sizes\" {\n  assert_eq(size_of_store_op(I32StoreOp), 4)\n  assert_eq(size_of_store_op(I64StoreOp), 8)\n  assert_eq(size_of_store_op(F32StoreOp), 4)\n  assert_eq(size_of_store_op(F64StoreOp), 8)\n  assert_eq(size_of_store_op(I32Store8Op), 1)\n  assert_eq(size_of_store_op(I32Store16Op), 2)\n  assert_eq(size_of_store_op(I64Store8Op), 1)\n  assert_eq(size_of_store_op(I64Store16Op), 2)\n  assert_eq(size_of_store_op(I64Store32Op), 4)\n  assert_eq(size_of_store_op(V128StoreOp), 16)\n}\n\n///|\ntest \"ChunkSize::byte_count returns correct values\" {\n  assert_eq(ChunkSize8.byte_count(), 1)\n  assert_eq(ChunkSize16.byte_count(), 2)\n  assert_eq(ChunkSize32.byte_count(), 4)\n  assert_eq(ChunkSize64.byte_count(), 8)\n}\n\n///|\ntest \"load_op_stack_size returns correct stack sizes\" {\n  assert_eq(load_op_stack_size(I32LoadOp), StackSize32)\n  assert_eq(load_op_stack_size(I64LoadOp), StackSize64)\n  assert_eq(load_op_stack_size(F32LoadOp), StackSize32)\n  assert_eq(load_op_stack_size(F64LoadOp), StackSize64)\n  assert_eq(load_op_stack_size(I32Load8UOp), StackSize32)\n  assert_eq(load_op_stack_size(I64Load8UOp), StackSize64)\n}\n\n///|\ntest \"store_op_stack_size returns correct stack sizes\" {\n  assert_eq(store_op_stack_size(I32StoreOp), StackSize32)\n  assert_eq(store_op_stack_size(I64StoreOp), StackSize64)\n  assert_eq(store_op_stack_size(F32StoreOp), StackSize32)\n  assert_eq(store_op_stack_size(F64StoreOp), StackSize64)\n  assert_eq(store_op_stack_size(I32Store8Op), StackSize32)\n  assert_eq(store_op_stack_size(I64Store8Op), StackSize64)\n}\n\n// ============================================================\n// Tests for edge cases\n// ============================================================\n\n///|\ntest \"align clamped to op_size\" {\n  // If align > op_size, it should be clamped to op_size\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TLoad(\n    I32LoadOp,\n    MemArg(U32(8), None, U64(0)), // align=8 but i32 is only 4 bytes\n    TLocalGet(LocalIdx(0)),\n  )\n  let result = run_pass(ctx, instr)\n  // Should be treated as aligned (4 >= 4)\n  match result {\n    Ok(TLoad(I32LoadOp, MemArg(U32(8), _, _), _)) => ()\n    _ => fail(\"Expected load to pass through\")\n  }\n}\n\n///|\ntest \"other instructions pass through unchanged\" {\n  let ctx = make_ctx(make_i32_mem())\n  let instr = @lib.TBinary(I32AddOp, TI32Const(I32(1)), TI32Const(I32(2)))\n  let result = run_pass(ctx, instr)\n  match result {\n    Ok(TBinary(I32AddOp, TI32Const(I32(1)), TI32Const(I32(2)))) => ()\n    _ => fail(\"Expected binary op to pass through unchanged\")\n  }\n}\n\n///|\ntest \"nop passes through unchanged\" {\n  let ctx = make_ctx(make_i32_mem())\n  let result = run_pass(ctx, TNop)\n  match result {\n    Ok(TNop) => ()\n    _ => fail(\"Expected nop to pass through\")\n  }\n}\n\n///|\ntest \"unreachable passes through unchanged\" {\n  let ctx = make_ctx(make_i32_mem())\n  let result = run_pass(ctx, TUnreachable)\n  match result {\n    Ok(TUnreachable) => ()\n    _ => fail(\"Expected unreachable to pass through\")\n  }\n}\n","///|\nconst MIN_USES = 2\n\n///|\npub enum LiteralKind {\n  I32LiteralKind\n  I64LiteralKind\n  F32LiteralKind\n  F64LiteralKind\n  V128LiteralKind\n} derive(Eq, Hash, Show)\n\n///|\npub struct Literal(LiteralKind, Bytes) derive(Eq, Hash, Show)\n\n///|\nfn Literal::byte_size(self : Literal) -> Int {\n  match self {\n    Literal(I32LiteralKind, b) =>\n      size_signed(\n        b.unsafe_read_uint32_le(0).reinterpret_as_int().to_int64(),\n        32,\n      ).unwrap()\n    Literal(I64LiteralKind, b) =>\n      size_signed(b.unsafe_read_uint64_le(0).reinterpret_as_int64(), 64).unwrap()\n    Literal(F32LiteralKind, _) => 4\n    Literal(F64LiteralKind, _) => 8\n    Literal(V128LiteralKind, _) => 16\n  }\n}\n\n///|\nfn Literal::get_tinst(self : Literal) -> TInstr {\n  match self {\n    Literal(I32LiteralKind, b) =>\n      TI32Const(b.unsafe_read_uint32_le(0).reinterpret_as_int())\n    Literal(I64LiteralKind, b) =>\n      TI64Const(b.unsafe_read_uint64_le(0).reinterpret_as_int64())\n    Literal(F32LiteralKind, b) =>\n      TF32Const(F32(Float::reinterpret_from_uint(b.unsafe_read_uint32_le(0))))\n    Literal(F64LiteralKind, b) =>\n      TF64Const(b.unsafe_read_uint64_le(0).reinterpret_as_double())\n    Literal(V128LiteralKind, b) =>\n      TV128Const(\n        b.unsafe_get(0),\n        b.unsafe_get(1),\n        b.unsafe_get(2),\n        b.unsafe_get(3),\n        b.unsafe_get(4),\n        b.unsafe_get(5),\n        b.unsafe_get(6),\n        b.unsafe_get(7),\n        b.unsafe_get(8),\n        b.unsafe_get(9),\n        b.unsafe_get(10),\n        b.unsafe_get(11),\n        b.unsafe_get(12),\n        b.unsafe_get(13),\n        b.unsafe_get(14),\n        b.unsafe_get(15),\n      )\n  }\n}\n\n///|\nfn LiteralKind::rank(self : Self) -> Int {\n  match self {\n    I32LiteralKind => 0\n    I64LiteralKind => 1\n    F32LiteralKind => 2\n    F64LiteralKind => 3\n    V128LiteralKind => 4\n  }\n}\n\n///|\nfn LiteralKind::get_valtype(self : Self) -> ValType {\n  match self {\n    I32LiteralKind => @lib.NumTypeValType(@lib.I32NumType)\n    I64LiteralKind => @lib.NumTypeValType(@lib.I64NumType)\n    F32LiteralKind => @lib.NumTypeValType(@lib.F32NumType)\n    F64LiteralKind => @lib.NumTypeValType(@lib.F64NumType)\n    V128LiteralKind => @lib.VecTypeValType\n  }\n}\n\n///|\npub impl Compare for Literal with compare(l, r) {\n  let kind = l.0.compare(r.0)\n  if kind == 0 {\n    l.1.compare(r.1)\n  } else {\n    kind\n  }\n}\n\n///|\npub impl Compare for LiteralKind with compare(l, r) {\n  l.rank().compare(r.rank())\n}\n\n///|\npub struct ConstHoistingState {\n  usage : Map[Literal, Int]\n}\n\n///|\npub fn ConstHoistingState::new() -> ConstHoistingState {\n  ConstHoistingState::{ usage: Map::new() }\n}\n\n///|\nfn ConstHoistingState::uses(self : Self, literal : Literal) -> Unit {\n  let usage = self.usage\n  match usage.get(literal) {\n    Some(i) => usage.set(literal, i + 1)\n    None => usage.set(literal, 1)\n  }\n}\n\n///|\nfn i32_lit(val : Int) -> Literal {\n  let b = @buffer.new(size_hint=4)\n  b.write_int_le(val)\n  Literal(I32LiteralKind, b.to_bytes())\n}\n\n///|\nfn i64_lit(val : Int64) -> Literal {\n  let b = @buffer.new(size_hint=8)\n  b.write_int64_le(val)\n  Literal(I64LiteralKind, b.to_bytes())\n}\n\n///|\nfn f32_lit(val : Float) -> Literal {\n  let b = @buffer.new(size_hint=4)\n  b.write_float_le(val)\n  Literal(F32LiteralKind, b.to_bytes())\n}\n\n///|\nfn f64_lit(val : Double) -> Literal {\n  let b = @buffer.new(size_hint=8)\n  b.write_double_le(val)\n  Literal(F64LiteralKind, b.to_bytes())\n}\n\n///|\nfn v128_lit(\n  b0 : Byte,\n  b1 : Byte,\n  b2 : Byte,\n  b3 : Byte,\n  b4 : Byte,\n  b5 : Byte,\n  b6 : Byte,\n  b7 : Byte,\n  b8 : Byte,\n  b9 : Byte,\n  b10 : Byte,\n  b11 : Byte,\n  b12 : Byte,\n  b13 : Byte,\n  b14 : Byte,\n  b15 : Byte,\n) -> Literal {\n  let b = Bytes::from_array([\n    b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,\n  ])\n  Literal(V128LiteralKind, b)\n}\n\n///|\nfn replace_literal_pass() -> ModuleTransformer[Map[Literal, LocalIdx]] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_tinstruction: Some(fn(self, t, i) {\n      match i {\n        TI32Const(I32(val)) => {\n          let lit = i32_lit(val)\n          if t.get(lit) is Some(idx) {\n            change(t, @lib.TLocalGet(idx))\n          } else {\n            unchanged()\n          }\n        }\n        TI64Const(I64(val)) => {\n          let lit = i64_lit(val)\n          if t.get(lit) is Some(idx) {\n            change(t, @lib.TLocalGet(idx))\n          } else {\n            unchanged()\n          }\n        }\n        TF32Const(F32(val)) => {\n          let lit = f32_lit(val)\n          if t.get(lit) is Some(idx) {\n            change(t, @lib.TLocalGet(idx))\n          } else {\n            unchanged()\n          }\n        }\n        TF64Const(F64(val)) => {\n          let lit = f64_lit(val)\n          if t.get(lit) is Some(idx) {\n            change(t, @lib.TLocalGet(idx))\n          } else {\n            unchanged()\n          }\n        }\n\n        // this is likely not to be used because v128 consts are hardly worth hoisting\n        TV128Const(\n          b0,\n          b1,\n          b2,\n          b3,\n          b4,\n          b5,\n          b6,\n          b7,\n          b8,\n          b9,\n          b10,\n          b11,\n          b12,\n          b13,\n          b14,\n          b15\n        ) => {\n          let lit = v128_lit(\n            b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,\n          )\n          if t.get(lit) is Some(idx) {\n            change(t, @lib.TLocalGet(idx))\n          } else {\n            unchanged()\n          }\n        }\n        _ => self.walk_tinstruction_default(t, i)\n      }\n    }),\n  }\n}\n\n///|\npub fn const_hoisting_pass() -> ModuleTransformer[ConstHoistingState] {\n  ModuleTransformer::{\n    ..ModuleTransformer::new(),\n    on_func: Some(fn(self, t, func) {\n      // reset uses of consts per function\n      t.usage.clear()\n      let (t, func) = match self.walk_func_default(t, func) {\n        Ok(Some((t, func))) => (t, func)\n        Ok(None) => (t, func)\n        Err(t) => return Err(t)\n      }\n      let (locals, body) = match func {\n        Func(_) =>\n          return Err(\n            \"Invalid transformer state. Expected TFunc but received Func\",\n          )\n        TFunc(locals, body) => (locals, body)\n      }\n      let replacer_pass = replace_literal_pass()\n      let replacers = Map::new()\n      for k in t.usage.iter() {\n        let lit = k.0\n        let count = k.1\n        if count >= MIN_USES {\n          let size = lit.byte_size()\n          let before = count * (size + 1)\n          let after = size + 2 + 2 * count\n          if after < before {\n            let next = locals.length().reinterpret_as_uint()\n            locals.push(lit.0.get_valtype())\n            replacers.set(lit, @lib.LocalIdx(next))\n          }\n        }\n      }\n      let body = match replacer_pass.walk_texpr_default(replacers, body) {\n        Ok(Some((_, body))) => body\n        Ok(None) => body\n        Err(t) => return Err(t)\n      }\n      for k in replacers {\n        let lit = k.0\n        let idx = k.1\n        let con = lit.get_tinst()\n        body.0.insert(0, TLocalSet(idx, con))\n      }\n      change(t, TFunc(locals, body))\n    }),\n    on_tinstruction: Some(fn(self, t, i) {\n      match i {\n        TI32Const(I32(val)) => t.uses(i32_lit(val))\n        TI64Const(I64(val)) => t.uses(i64_lit(val))\n        TF32Const(F32(val)) => t.uses(f32_lit(val))\n        TF64Const(F64(val)) => t.uses(f64_lit(val))\n        // In the case of v128 constants, simd locals are expensive and encoding is tricky\n        // TV128Const(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15) => \n        //   t.uses(v128_lit(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15))\n        _ => ()\n      }\n      self.walk_tinstruction_default(t, i)\n    }),\n  }\n}\n\n///|\nfn run_hoist(f : Func) -> Func raise {\n  let pass = const_hoisting_pass()\n  let empty_state = ConstHoistingState::new()\n  match pass.walk_func(empty_state, f) {\n    Ok(Some((_, f))) => return f\n    Ok(None) => ()\n    Err(e) => assert_true(false, msg=e)\n  }\n  f\n}\n\n///|\ntest \"const hoisting: single use does nothing\" {\n  let f = @lib.TFunc([], [TI32Const(I32(7))])\n  let f2 = run_hoist(f)\n  match f2 {\n    TFunc(locals, TExpr(instrs)) => {\n      assert_eq(locals.length(), 0)\n      assert_eq(instrs.length(), 1)\n      assert_eq(instrs[0], TI32Const(7))\n    }\n    _ => fail(\"expected TFunc\")\n  }\n}\n\n///|\ntest \"const hoisting: large constant is hoisted\" {\n  let big = 100000\n  let f = @lib.TFunc([], [\n    TI32Const(I32(big)),\n    TI32Const(I32(big)),\n    TI32Const(I32(big)),\n  ])\n  let f2 = run_hoist(f)\n  match f2 {\n    TFunc(locals, TExpr(instrs)) => {\n      // One new local\n      assert_eq(locals.length(), 1)\n\n      // First instruction is local.set\n      assert_true(instrs[0] is TLocalSet(_))\n\n      // Remaining are local.get\n      assert_true(instrs[1] is TLocalGet(_))\n      assert_true(instrs[2] is TLocalGet(_))\n      assert_true(instrs[3] is TLocalGet(_))\n    }\n    _ => fail(\"expected TFunc\")\n  }\n}\n\n///|\ntest \"const hoisting: small constants are not hoisted\" {\n  let f = @lib.TFunc([], [\n    TI32Const(I32(0)),\n    TI32Const(I32(0)),\n    TI32Const(I32(0)),\n  ])\n  let f2 = run_hoist(f)\n  match f2 {\n    TFunc(locals, TExpr(instrs)) => {\n      assert_eq(locals.length(), 0)\n      assert_eq(instrs.length(), 3)\n      for i in instrs {\n        assert_true(i is @lib.TI32Const(_))\n      }\n    }\n    _ => fail(\"expected TFunc\")\n  }\n}\n\n///|\ntest \"const hoisting: different literals are not merged\" {\n  let f = @lib.TFunc([], [\n    TI32Const(I32(10)),\n    TI32Const(I32(20)),\n    TI32Const(I32(10)),\n  ])\n  let f2 = run_hoist(f)\n  match f2 {\n    TFunc(locals, TExpr(instrs)) => {\n      // 10 is small  not hoisted\n      assert_eq(locals.length(), 0)\n      assert_true(instrs[0] is TI32Const(_))\n      assert_true(instrs[1] is TI32Const(_))\n      assert_true(instrs[2] is TI32Const(_))\n    }\n    _ => fail(\"expected TFunc\")\n  }\n}\n\n///|\ntest \"const hoisting: f64 hoisted when repeated\" {\n  let pi = 3.141592653589793\n  let f = @lib.TFunc([], [\n    TF64Const(F64(pi)),\n    TF64Const(F64(pi)),\n    TF64Const(F64(pi)),\n  ])\n  let f2 = run_hoist(f)\n  match f2 {\n    TFunc(locals, TExpr(instrs)) => {\n      assert_eq(locals.length(), 1)\n      assert_true(instrs[0] is TLocalSet(_))\n      assert_true(instrs[1] is TLocalGet(_))\n      assert_true(instrs[2] is TLocalGet(_))\n      assert_true(instrs[3] is TLocalGet(_))\n    }\n    _ => fail(\"expected TFunc\")\n  }\n}\n","///|\npub trait Encode {\n  encode(Self, @buffer.Buffer) -> Result[Unit, String]\n}\n\n///|\npub trait Decode {\n  decode(Bytes, Int) -> Result[(Self, Int), String]\n}\n\n///|\nusing @lib {\n  type NumType,\n  type HeapType,\n  type S33,\n  type F32,\n  type F64,\n  type I32,\n  type I64,\n  type U32,\n  type U64,\n  type AbsHeapType,\n  type RefType,\n  type ValType,\n  type CompType,\n  type FieldType,\n  type Mut,\n  type StorageType,\n  type PackType,\n  type RecType,\n  type SubType,\n  type ExternIdx,\n  type TypeIdx,\n  type FuncIdx,\n  type TableIdx,\n  type MemIdx,\n  type GlobalIdx,\n  type TagIdx,\n  type ElemIdx,\n  type DataIdx,\n  type LocalIdx,\n  type LabelIdx,\n  type LaneIdx,\n  type Name,\n  type CustomSec,\n  type TypeSec,\n  type ImportSec,\n  type Import,\n  type ExternType,\n  type TableType,\n  type Limits,\n  type MemType,\n  type GlobalType,\n  type TagType,\n  type FuncSec,\n  type TableSec,\n  type Table,\n  type MemSec,\n  type GlobalSec,\n  type Global,\n  type ExportSec,\n  type Export,\n  type StartSec,\n  type ElemSec,\n  type Elem,\n  type CodeSec,\n  type Func,\n  type DataSec,\n  type Data,\n  type Locals,\n  type DataCntSec,\n  type TagSec,\n  type CastOp,\n  type Module,\n  type Expr,\n  type Instruction,\n  type ElemMode,\n  type DataMode,\n  type BlockType,\n  type Catch,\n  type MemArg,\n  tlocals_to_locals,\n  texpr_to_expr,\n  i32_valtype,\n  i64_valtype,\n}\n\n///|\npub impl Encode for NumType with encode(val, buf) {\n  match val {\n    F64NumType => buf.write_byte(0x7C)\n    F32NumType => buf.write_byte(0x7D)\n    I64NumType => buf.write_byte(0x7E)\n    I32NumType => buf.write_byte(0x7F)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for NumType with decode(buf, idx) {\n  match buf.get(idx) {\n    Some(0x7C) => Ok((F64NumType, idx + 1))\n    Some(0x7D) => Ok((F32NumType, idx + 1))\n    Some(0x7E) => Ok((I64NumType, idx + 1))\n    Some(0x7F) => Ok((I32NumType, idx + 1))\n    Some(_) => Err(\"Invalid NumType Byte\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Encode for HeapType with encode(val, buf) {\n  match val {\n    AbsHeapTypeHeapType(ht) => Encode::encode(ht, buf)\n    HeapType(TypeIdx(i)) => Encode::encode(@lib.S33(i), buf)\n    HeapType(RecIdx(_)) => Err(\"Cannot encode recursive indexes\")\n    DefTypeHeapType(_) => Err(\"Cannot encode deftypes\")\n  }\n}\n\n///|\npub impl Encode for AbsHeapType with encode(val, buf) {\n  match val {\n    ExnAbsHeapType => buf.write_byte(0x69)\n    ArrayAbsHeapType => buf.write_byte(0x6A)\n    StructAbsHeapType => buf.write_byte(0x6B)\n    I31AbsHeapType => buf.write_byte(0x6C)\n    EqAbsHeapType => buf.write_byte(0x6D)\n    AnyAbsHeapType => buf.write_byte(0x6E)\n    ExternAbsHeapType => buf.write_byte(0x6F)\n    FuncAbsHeapType => buf.write_byte(0x70)\n    NoneAbsHeapType => buf.write_byte(0x71)\n    NoExternAbsHeapType => buf.write_byte(0x72)\n    NoFuncAbsHeapType => buf.write_byte(0x73)\n    NoExnAbsHeapType => buf.write_byte(0x74)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for HeapType with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((abs, i)) => Ok((AbsHeapTypeHeapType(abs), i))\n    Err(_) =>\n      match Decode::decode(bytes, i) {\n        Ok((@lib.S33(s), i)) => Ok((HeapType(TypeIdx(s)), i))\n        Err(err) => Err(err)\n      }\n  }\n}\n\n///|\npub impl Decode for AbsHeapType with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x69) => Ok((ExnAbsHeapType, i + 1))\n    Some(0x6A) => Ok((ArrayAbsHeapType, i + 1))\n    Some(0x6B) => Ok((StructAbsHeapType, i + 1))\n    Some(0x6C) => Ok((I31AbsHeapType, i + 1))\n    Some(0x6D) => Ok((EqAbsHeapType, i + 1))\n    Some(0x6E) => Ok((AnyAbsHeapType, i + 1))\n    Some(0x6F) => Ok((ExternAbsHeapType, i + 1))\n    Some(0x70) => Ok((FuncAbsHeapType, i + 1))\n    Some(0x71) => Ok((NoneAbsHeapType, i + 1))\n    Some(0x72) => Ok((NoExternAbsHeapType, i + 1))\n    Some(0x73) => Ok((NoFuncAbsHeapType, i + 1))\n    Some(0x74) => Ok((NoExnAbsHeapType, i + 1))\n    Some(_) => Err(\"Invalid Abstract Heap Type\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Encode for RefType with encode(val, buf) {\n  match val {\n    HeapTypeRefType(true, ht) => {\n      buf.write_byte(0x63)\n      Encode::encode(ht, buf)\n    }\n    HeapTypeRefType(false, ht) => {\n      buf.write_byte(0x64)\n      Encode::encode(ht, buf)\n    }\n    AbsHeapTypeRefType(abs) => Encode::encode(abs, buf)\n  }\n}\n\n///|\npub impl Decode for RefType with decode(bytes, i) {\n  match bytes.get(i) {\n    None => Err(\"Index out of bounds\")\n    Some(0x63) =>\n      match Decode::decode(bytes, i + 1) {\n        Err(err) => Err(err)\n        Ok((ht, i)) => Ok((HeapTypeRefType(true, ht), i))\n      }\n    Some(0x64) =>\n      match Decode::decode(bytes, i + 1) {\n        Err(err) => Err(err)\n        Ok((ht, i)) => Ok((HeapTypeRefType(false, ht), i))\n      }\n    Some(_) =>\n      match Decode::decode(bytes, i) {\n        Err(err) => Err(err)\n        Ok((abs, i)) => Ok((AbsHeapTypeRefType(abs), i))\n      }\n  }\n}\n\n///|\npub impl Encode for ValType with encode(val, buf) {\n  match val {\n    VecTypeValType => {\n      buf.write_byte(0x7B)\n      Ok(())\n    }\n    NumTypeValType(num) => Encode::encode(num, buf)\n    RefTypeValType(rt) => Encode::encode(rt, buf)\n    BotValType => Err(\"Cannot encode bottom type.\")\n  }\n}\n\n///|\npub impl Decode for ValType with decode(bytes, i) {\n  match bytes.get(i) {\n    None => Err(\"Index out of bounds\")\n    Some(0x7B) => Ok((VecTypeValType, i + 1))\n    Some(_) =>\n      match Decode::decode(bytes, i) {\n        Ok((t, i)) => Ok((NumTypeValType(t), i))\n        _ =>\n          match Decode::decode(bytes, i) {\n            Ok((rt, i)) => Ok((RefTypeValType(rt), i))\n            _ => Err(\"Invalid ValType\")\n          }\n      }\n  }\n}\n\n///|\npub impl[T : Encode] Encode for @list.List[T] with encode(val, buf) {\n  if Encode::encode(@lib.U32(val.length().reinterpret_as_uint()), buf) is Err(t) {\n    return Err(t)\n  }\n  loop val {\n    Empty => Ok(())\n    More(val, tail~) => {\n      if Encode::encode(val, buf) is Err(t) {\n        break Err(t)\n      }\n      continue tail\n    }\n  }\n}\n\n///|\npub impl[T : Decode] Decode for @list.List[T] with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((@lib.U32(len), i)) =>\n      loop ([], len, i) {\n        (acc, left, i) if left > 0 =>\n          match T::decode(bytes, i) {\n            Ok((u, i)) => {\n              acc.push(u)\n              continue (acc, left - 1, i)\n            }\n            Err(err) => Err(err)\n          }\n        (acc, _, i) => Ok((@list.List::from_array(acc), i))\n      }\n    Err(err) => Err(err)\n  }\n}\n\n///|\npub impl Encode for CompType with encode(val, buf) {\n  match val {\n    StructCompType(fts) => {\n      buf.write_byte(0x5F)\n      Encode::encode(fts, buf)\n    }\n    ArrayCompType(ft) => {\n      buf.write_byte(0x5E)\n      Encode::encode(ft, buf)\n    }\n    FuncCompType(t1, t2) => {\n      buf.write_byte(0x60)\n      if Encode::encode(t1, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(t2, buf)\n    }\n  }\n}\n\n///|\npub impl Decode for CompType with decode(bytes, i) {\n  match bytes.get(i) {\n    None => Err(\"Index out of bounds\")\n    Some(0x5E) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((ft, i)) => Ok((ArrayCompType(ft), i))\n        Err(err) => Err(err)\n      }\n    Some(0x5F) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((fts, i)) => Ok((StructCompType(fts), i))\n        Err(err) => Err(err)\n      }\n    Some(0x60) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((props, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((rets, i)) => Ok((FuncCompType(props, rets), i))\n            Err(err) => Err(err)\n          }\n        Err(err) => Err(err)\n      }\n    Some(_) => Err(\"Invalid Comp Type\")\n  }\n}\n\n///|\npub impl Encode for FieldType with encode(val, buf) {\n  let FieldType(st, m) = val\n  if Encode::encode(st, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(m, buf) is Err(t) {\n    return Err(t)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for FieldType with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Err(err) => Err(err)\n    Ok((st, i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((m, i)) => Ok((FieldType(st, m), i))\n        Err(err) => Err(err)\n      }\n  }\n}\n\n///|\npub impl Encode for Mut with encode(val, buf) {\n  match val {\n    Const => buf.write_byte(0x00)\n    Var => buf.write_byte(0x01)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for Mut with decode(bytes, i) {\n  if i >= bytes.length() {\n    return Err(\"unexpected EOF decoding mut\")\n  }\n  let b = bytes[i]\n  match b {\n    0x00 => Ok((Const, i + 1))\n    0x01 => Ok((Var, i + 1))\n    _ => Err(\"invalid mut byte\")\n  }\n}\n\n///|\npub impl Encode for StorageType with encode(val, buf) {\n  match val {\n    ValTypeStorageType(vt) => Encode::encode(vt, buf)\n    PackTypeStorageType(pt) => Encode::encode(pt, buf)\n  }\n}\n\n///|\npub impl Decode for StorageType with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((vt, i)) => Ok((ValTypeStorageType(vt), i))\n    Err(_) =>\n      match Decode::decode(bytes, i) {\n        Ok((pt, i)) => Ok((PackTypeStorageType(pt), i))\n        Err(_) => Err(\"Invalid StorageType\")\n      }\n  }\n}\n\n///|\npub impl Encode for PackType with encode(val, buf) {\n  match val {\n    I16PackType => {\n      buf.write_byte(0x77)\n      Ok(())\n    }\n    I8PackType => {\n      buf.write_byte(0x78)\n      Ok(())\n    }\n  }\n}\n\n///|\npub impl Decode for PackType with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x77) => Ok((I16PackType, i + 1))\n    Some(0x78) => Ok((I8PackType, i + 1))\n    Some(_) => Err(\"Invalid Packed Type\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Encode for RecType with encode(val, buf) {\n  match val {\n    SingleRecType(st) => Encode::encode(st, buf)\n    GroupRecType(sts) => {\n      buf.write_byte(0x4E)\n      Encode::encode(sts, buf)\n    }\n  }\n}\n\n///|\npub impl Decode for RecType with decode(buf, i) {\n  match buf.get(i) {\n    None => Err(\"Index out of bounds\")\n    Some(0x4E) =>\n      match Decode::decode(buf, i + 1) {\n        Ok((sts, i)) => Ok((GroupRecType(sts), i))\n        Err(err) => Err(err)\n      }\n    Some(_) =>\n      match Decode::decode(buf, i) {\n        Ok((st, i)) => Ok((SingleRecType(st), i))\n        Err(err) => Err(err)\n      }\n  }\n}\n\n///|\npub impl Encode for SubType with encode(val, buf) {\n  match val {\n    SubType(f, indexes, ct) => {\n      match f {\n        true => buf.write_byte(0x4F)\n        false => buf.write_byte(0x50)\n      }\n      if Encode::encode(indexes, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(ct, buf)\n    }\n    CompTypeSubType(ct) => Encode::encode(ct, buf)\n  }\n}\n\n///|\npub impl Decode for SubType with decode(buf, i) {\n  match buf.get(i) {\n    // Final\n    Some(0x4F) =>\n      match Decode::decode(buf, i + 1) {\n        Ok((idxs, i)) =>\n          match Decode::decode(buf, i) {\n            Ok((ct, i)) => Ok((SubType(true, idxs, ct), i))\n            Err(err) => Err(err)\n          }\n        Err(err) => Err(err)\n      }\n    // Subtypes\n    Some(0x50) =>\n      match Decode::decode(buf, i + 1) {\n        Ok((idxs, i)) =>\n          match Decode::decode(buf, i) {\n            Ok((ct, i)) => Ok((SubType(false, idxs, ct), i))\n            Err(err) => Err(err)\n          }\n        Err(err) => Err(err)\n      }\n    // CompType, don't consume the character\n    Some(_) =>\n      match Decode::decode(buf, i) {\n        Ok((ct, i)) => Ok((CompTypeSubType(ct), i))\n        Err(err) => Err(err)\n      }\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Encode for ExternIdx with encode(val, buf) {\n  match val {\n    FuncExternIdx(idx) => {\n      buf.write_byte(0x00)\n      Encode::encode(idx, buf)\n    }\n    TableExternIdx(idx) => {\n      buf.write_byte(0x01)\n      Encode::encode(idx, buf)\n    }\n    MemExternIdx(idx) => {\n      buf.write_byte(0x02)\n      Encode::encode(idx, buf)\n    }\n    GlobalExternIdx(idx) => {\n      buf.write_byte(0x03)\n      Encode::encode(idx, buf)\n    }\n    TagExternIdx(idx) => {\n      buf.write_byte(0x04)\n      Encode::encode(idx, buf)\n    }\n  }\n}\n\n///|\npub fn size_unsigned(val : UInt64, nbits : Int) -> Result[Int, String] {\n  if nbits <= 0 || nbits > 64 {\n    return Err(\"invalid nbits for uleb\")\n  }\n  if nbits < 64 {\n    let max = (1UL << nbits) - 1UL\n    if val > max {\n      return Err(\"uleb value out of range\")\n    }\n  }\n  let mut x = val\n  let mut count = 0\n  while true {\n    x = x >> 7\n    count += 1\n    if x == 0 {\n      break\n    }\n  }\n  Ok(count)\n}\n\n///|\npub fn size_signed(val : Int64, nbits : Int) -> Result[Int, String] {\n  if nbits <= 0 || nbits > 64 {\n    return Err(\"invalid nbits for sleb\")\n  }\n  if nbits < 64 {\n    let min = -1L << (nbits - 1)\n    let max = (1L << (nbits - 1)) - 1\n    if val < min || val > max {\n      return Err(\"sleb value out of range\")\n    }\n  }\n  let rem = nbits % 7\n  let used_mask = if rem == 0 { 0UL } else { (1UL << rem) - 1UL }\n  let inv_used7 = UInt64::lnot(used_mask) & 0x7fUL\n  let mut x = val\n  let mut count = 0\n  while true {\n    let payload_u = (x & 0x7f).reinterpret_as_uint64()\n    let sign_bit = (payload_u & 0x40UL) != 0UL\n    x = x >> 7\n    let done_std = (x == 0 && !sign_bit) || (x == -1 && sign_bit)\n    let done_bits_ok = if nbits == 64 || rem == 0 {\n      true\n    } else if val >= 0 {\n      (payload_u & inv_used7) == 0UL\n    } else {\n      (payload_u & inv_used7) == inv_used7\n    }\n    let done = done_std && done_bits_ok\n    count += 1\n    if done {\n      break\n    }\n  }\n  Ok(count)\n}\n\n///|\nfn encode_unsigned(\n  val : UInt64,\n  buf : @buffer.Buffer,\n  nbits : Int,\n) -> Result[Unit, String] {\n  if nbits <= 0 || nbits > 64 {\n    return Err(\"invalid nbits for uleb\")\n  }\n  if nbits < 64 {\n    let max = (1UL << nbits) - 1UL\n    if val > max {\n      return Err(\"uleb value out of range\")\n    }\n  }\n  let max_bytes = max_leb_bytes(nbits)\n  let mut x = val\n  let mut count = 0\n  while true {\n    if count >= max_bytes {\n      return Err(\"uleb encode exceeds max bytes\")\n    }\n    let payload = x & 0x7fUL\n    x = x >> 7\n    let out = if x == 0UL { payload } else { payload | 0x80UL }\n    buf.write_byte(out.to_byte())\n    count += 1\n    if x == 0UL {\n      break\n    }\n  }\n  Ok(())\n}\n\n///|\nfn encode_signed(\n  val : Int64,\n  buf : @buffer.Buffer,\n  nbits : Int,\n) -> Result[Unit, String] {\n  if nbits <= 0 || nbits > 64 {\n    return Err(\"invalid nbits for sleb\")\n  }\n  if nbits < 64 {\n    let min = -1L << (nbits - 1)\n    let max = (1L << (nbits - 1)) - 1\n    if val < min || val > max {\n      return Err(\"sleb value out of range\")\n    }\n  }\n  let max_bytes = max_leb_bytes(nbits)\n  let rem = nbits % 7\n  let used_mask = if rem == 0 { 0UL } else { (1UL << rem) - 1UL }\n  let inv_used7 = UInt64::lnot(used_mask) & 0x7fUL\n  let mut x = val\n  let mut count = 0\n  while true {\n    if count >= max_bytes {\n      return Err(\"sleb encode exceeds max bytes\")\n    }\n    let payload_u = (x & 0x7f).reinterpret_as_uint64()\n    let sign_bit = (payload_u & 0x40UL) != 0UL\n    x = x >> 7\n    let done_std = (x == 0 && !sign_bit) || (x == -1 && sign_bit)\n    let done_bits_ok = if nbits == 64 || rem == 0 {\n      true\n    } else if val >= 0 {\n      (payload_u & inv_used7) == 0UL\n    } else {\n      (payload_u & inv_used7) == inv_used7\n    }\n    let done = done_std && done_bits_ok\n    let out = if done { payload_u } else { payload_u | 0x80UL }\n    buf.write_byte(out.to_byte())\n    count += 1\n    if done {\n      break\n    }\n  }\n  Ok(())\n}\n\n///|\nfn ceil_div(a : Int, b : Int) -> Int {\n  (a + b - 1) / b\n}\n\n///|\nfn max_leb_bytes(nbits : Int) -> Int {\n  ceil_div(nbits, 7)\n}\n\n///|\nfn decode_unsigned(\n  bytes : Bytes,\n  index : Int,\n  nbits : Int,\n) -> Result[(UInt64, Int), String] {\n  if nbits <= 0 || nbits > 64 {\n    return Err(\"invalid nbits for uleb\")\n  }\n  let max_bytes = max_leb_bytes(nbits)\n  let mut i = index\n  let mut shift = 0\n  let mut acc : UInt64 = 0UL\n  let mut count = 0\n  while true {\n    if i >= bytes.length() {\n      return Err(\"unexpected EOF in uleb\")\n    }\n    if count >= max_bytes {\n      return Err(\"uleb too many bytes\")\n    }\n    let byte_u : UInt64 = bytes[i].to_uint64()\n    i += 1\n    count += 1\n    let payload : UInt64 = byte_u & 0x7fUL\n    acc = acc | (payload << shift)\n    let cont = (byte_u & 0x80UL) != 0UL\n    shift = shift + 7\n    if !cont {\n      // range check\n      if nbits < 64 {\n        let max_val = (1UL << nbits) - 1UL\n        if acc > max_val {\n          return Err(\"uleb out of range for bit width\")\n        }\n      }\n\n      // terminal unused bits constraint - ONLY at max bytes\n      if count == max_bytes {\n        let rem = nbits % 7\n        if rem != 0 {\n          let limit = 1UL << rem\n          if payload >= limit {\n            return Err(\"uleb terminal byte has non-zero unused bits\")\n          }\n        }\n      }\n      return Ok((acc, i))\n    }\n  }\n  Err(\"unreachable\")\n}\n\n///|\nfn decode_signed(\n  bytes : Bytes,\n  index : Int,\n  nbits : Int,\n) -> Result[(Int64, Int), String] {\n  if nbits <= 0 || nbits > 64 {\n    return Err(\"invalid nbits for sleb\")\n  }\n  let max_bytes = max_leb_bytes(nbits)\n  let mut i = index\n  let mut shift = 0\n  let mut acc : Int64 = 0\n  let mut count = 0\n  let mut last_byte : UInt64 = 0\n  while true {\n    if i >= bytes.length() {\n      return Err(\"unexpected EOF in sleb\")\n    }\n    if count >= max_bytes {\n      return Err(\"sleb too many bytes\")\n    }\n    let byte_u = bytes[i].to_uint64()\n    last_byte = byte_u\n    i += 1\n    count += 1\n    let payload = (byte_u & 0x7f).reinterpret_as_int64()\n    acc = acc | (payload << shift)\n    let cont = (byte_u & 0x80) != 0\n    shift += 7\n    if !cont {\n      break\n    }\n  }\n\n  // sign extend to full int64 based on last byte's sign bit (0x40)\n  if (last_byte & 0x40) != 0 && shift < 64 {\n    acc = acc | ((-1 : Int64) << shift)\n  }\n\n  // range check for N bits signed\n  if nbits < 64 {\n    let min = (-1 : Int64) << (nbits - 1)\n    let max = ((1 : Int64) << (nbits - 1)) - 1\n    if acc < min || acc > max {\n      return Err(\"sleb out of range for bit width\")\n    }\n  }\n\n  // terminal-byte unused bits constraint - ONLY at max bytes\n  if count == max_bytes && nbits != 64 {\n    let rem = nbits % 7\n    if rem != 0 {\n      let payload_u = last_byte & 0x7f\n      let used_mask = (1UL << rem) - 1UL\n      let inv_used = UInt64::lnot(used_mask) & 0x7fUL\n      let unused = payload_u & inv_used\n      if acc >= 0 {\n        if unused != 0 {\n          return Err(\"sleb terminal byte has non-zero unused bits for positive\")\n        }\n      } else {\n        let want = inv_used\n        if unused != want {\n          return Err(\"sleb terminal byte has wrong sign-extension bits\")\n        }\n      }\n    }\n  }\n  Ok((acc, i))\n}\n\n///|\npub impl Encode for S33 with encode(val, buf) {\n  let S33(val) = val\n  encode_signed(val.to_int64(), buf, 33)\n}\n\n///|\npub impl Encode for I32 with encode(val, buf) {\n  let I32(val) = val\n  encode_signed(val.to_int64(), buf, 32)\n}\n\n///|\npub impl Encode for U32 with encode(val, buf) {\n  let @lib.U32(val) = val\n  encode_unsigned(val.to_uint64(), buf, 32)\n}\n\n///|\npub impl Encode for U64 with encode(val, buf) {\n  let @lib.U64(val) = val\n  encode_unsigned(val, buf, 64)\n}\n\n///|\npub impl Encode for I64 with encode(val, buf) {\n  let I64(val) = val\n  encode_signed(val, buf, 64)\n}\n\n///|\npub impl Encode for F32 with encode(val, buf) {\n  let F32(val) = val\n  buf.write_float_le(val)\n  Ok(())\n}\n\n///|\npub impl Encode for F64 with encode(val, buf) {\n  let F64(val) = val\n  buf.write_double_le(val)\n  Ok(())\n}\n\n///|\npub impl Decode for S33 with decode(bytes, i) {\n  match decode_signed(bytes, i, 33) {\n    Err(err) => Err(err)\n    Ok((val, i)) if val >= 0 && val < 4294967295 =>\n      Ok((S33(val.to_int().reinterpret_as_uint()), i))\n    Ok(_) => Err(\"Invalid S33 Range\")\n  }\n}\n\n///|\npub impl Decode for I32 with decode(bytes, i) {\n  match decode_signed(bytes, i, 32) {\n    Err(err) => Err(err)\n    Ok((val, i)) => Ok((I32(val.to_int()), i))\n  }\n}\n\n///|\npub impl Decode for @lib.U32 with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(err) => Err(err)\n    Ok((val, i)) => Ok((U32(val.to_uint()), i))\n  }\n}\n\n///|\npub impl Decode for I64 with decode(bytes, i) {\n  match decode_signed(bytes, i, 64) {\n    Err(err) => Err(err)\n    Ok((val, i)) => Ok((I64(val), i))\n  }\n}\n\n///|\npub impl Decode for @lib.U64 with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 64) {\n    Err(err) => Err(err)\n    Ok((val, i)) => Ok((U64(val), i))\n  }\n}\n\n///|\npub impl Decode for F32 with decode(bytes, i) {\n  if bytes.length() >= i + 4 {\n    let value : Int = (bytes.unsafe_get(i + 3).to_int() << 24) |\n      (bytes.unsafe_get(i + 2).to_int() << 16) |\n      (bytes.unsafe_get(i + 1).to_int() << 8) |\n      bytes.unsafe_get(i).to_int()\n    Ok((F32(Float::reinterpret_from_int(value)), i + 4))\n  } else {\n    Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Decode for F64 with decode(bytes, i) {\n  if bytes.length() >= i + 8 {\n    let value : Int64 = (bytes.unsafe_get(i + 7).to_int64() << 56) |\n      (bytes.unsafe_get(i + 6).to_int64() << 48) |\n      (bytes.unsafe_get(i + 5).to_int64() << 40) |\n      (bytes.unsafe_get(i + 4).to_int64() << 32) |\n      (bytes.unsafe_get(i + 3).to_int64() << 24) |\n      (bytes.unsafe_get(i + 2).to_int64() << 16) |\n      (bytes.unsafe_get(i + 1).to_int64() << 8) |\n      bytes.unsafe_get(i).to_int64()\n    Ok((F64(value.reinterpret_as_double()), i + 8))\n  } else {\n    Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Encode for Bool with encode(val, buf) {\n  if val {\n    buf.write_byte(0x01)\n  } else {\n    buf.write_byte(0x00)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for Bool with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) => Ok((false, i + 1))\n    Some(0x01) => Ok((true, i + 1))\n    Some(_) => Err(\"Invalid bool\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl[T : Decode] Decode for T? with decode(bytes, i) {\n  match T::decode(bytes, i) {\n    Err(_) => Ok((None, i))\n    Ok((val, i)) => Ok((Some(val), i))\n  }\n}\n\n///|\npub impl[T : Encode] Encode for T? with encode(val, buf) {\n  match val {\n    None => Ok(())\n    Some(val) => Encode::encode(val, buf)\n  }\n}\n\n///|\npub impl Encode for TypeIdx with encode(val, buf) {\n  match val {\n    TypeIdx(id) => encode_unsigned(id.to_uint64(), buf, 32)\n    _ => Err(\"Cannot encode non standard type index \")\n  }\n}\n\n///|\npub impl Decode for TypeIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((TypeIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for FuncIdx with encode(val, buf) {\n  let FuncIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for FuncIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((FuncIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for TableIdx with encode(val, buf) {\n  let TableIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for TableIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((TableIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for MemIdx with encode(val, buf) {\n  let MemIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for MemIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((MemIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for GlobalIdx with encode(val, buf) {\n  let GlobalIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for GlobalIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((GlobalIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for TagIdx with encode(val, buf) {\n  let TagIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for TagIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((TagIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for ElemIdx with encode(val, buf) {\n  let ElemIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for ElemIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((ElemIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for DataIdx with encode(val, buf) {\n  let DataIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for DataIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((DataIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for LocalIdx with encode(val, buf) {\n  let LocalIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for LocalIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((LocalIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for LabelIdx with encode(val, buf) {\n  let LabelIdx(id) = val\n  encode_unsigned(id.to_uint64(), buf, 32)\n}\n\n///|\npub impl Decode for LabelIdx with decode(bytes, i) {\n  match decode_unsigned(bytes, i, 32) {\n    Err(t) => Err(t)\n    Ok((n, i)) => Ok((LabelIdx(n.to_uint()), i))\n  }\n}\n\n///|\npub impl Encode for LaneIdx with encode(val, buf) {\n  buf.write_byte(val.0)\n  Ok(())\n}\n\n///|\npub impl Decode for LaneIdx with decode(bytes, i) {\n  if bytes.get(i) is Some(n) && n < 16 {\n    Ok((LaneIdx(n), i + 1))\n  } else {\n    Err(\"Invalid Lane Index\")\n  }\n}\n\n///|\npub impl Encode for Name with encode(val, buf) {\n  let Name(name) = val\n  let bytes = @encoding/utf8.encode(name)\n  let len = bytes.length()\n  match Encode::encode(@lib.U32(len.reinterpret_as_uint()), buf) {\n    Err(err) => Err(err)\n    Ok(_) => {\n      buf.write_bytes(bytes)\n      Ok(())\n    }\n  }\n}\n\n///|\npub impl Decode for Name with decode(bytes, i) {\n  let (@lib.U32(len_u), j) = match Decode::decode(bytes, i) {\n    Err(err) => return Err(err)\n    Ok(t) => t\n  }\n  let len = len_u.reinterpret_as_int()\n  if len < 0 {\n    return Err(\"negative name length\")\n  }\n  let end = j + len\n  if end > bytes.length() {\n    return Err(\"Index out of bounds\")\n  }\n  let name = @encoding/utf8.decode_lossy(bytes[j:end]).to_string_view()\n  Ok((Name(name), end))\n}\n\n///|\npub impl Encode for CustomSec with encode(val, buf) {\n  let CustomSec(name, bytes) = val\n  buf.write_byte(0)\n  let payload_buff = @buffer.new()\n  if Encode::encode(name, payload_buff) is Err(t) {\n    return Err(t)\n  }\n  payload_buff.write_bytes(bytes)\n  let payload_bytes = payload_buff.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for TypeSec with encode(val, buf) {\n  buf.write_byte(1)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for ImportSec with encode(val, buf) {\n  buf.write_byte(2)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for Import with encode(val, buf) {\n  let Import(ns, name, et) = val\n  match Encode::encode(ns, buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  match Encode::encode(name, buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  Encode::encode(et, buf)\n}\n\n///|\npub impl Encode for ExternType with encode(val, buf) {\n  match val {\n    FuncExternType(idx) => {\n      buf.write_byte(0x00)\n      Encode::encode(idx, buf)\n    }\n    TableExternType(tt) => {\n      buf.write_byte(0x01)\n      Encode::encode(tt, buf)\n    }\n    MemExternType(mt) => {\n      buf.write_byte(0x02)\n      Encode::encode(mt, buf)\n    }\n    GlobalExternType(gt) => {\n      buf.write_byte(0x03)\n      Encode::encode(gt, buf)\n    }\n    TagExternType(tt) => {\n      buf.write_byte(0x04)\n      Encode::encode(tt, buf)\n    }\n  }\n}\n\n///|\npub impl Encode for TableType with encode(val, buf) {\n  let TableType(rt, l) = val\n  match Encode::encode(rt, buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  Encode::encode(l, buf)\n}\n\n///|\npub impl Encode for Limits with encode(val, buf) {\n  match val {\n    I32Limits(min, None) => {\n      buf.write_byte(0x00)\n      Encode::encode(@lib.U64(min.to_uint64()), buf)\n    }\n    I32Limits(min, Some(max)) => {\n      buf.write_byte(0x01)\n      match Encode::encode(@lib.U64(min.to_uint64()), buf) {\n        Err(err) => return Err(err)\n        _ => ()\n      }\n      Encode::encode(@lib.U64(max.to_uint64()), buf)\n    }\n    I64Limits(min, None) => {\n      buf.write_byte(0x04)\n      Encode::encode(@lib.U64(min), buf)\n    }\n    I64Limits(min, Some(max)) => {\n      buf.write_byte(0x05)\n      match Encode::encode(@lib.U64(min), buf) {\n        Err(err) => return Err(err)\n        _ => ()\n      }\n      Encode::encode(@lib.U64(max), buf)\n    }\n  }\n}\n\n///|\npub impl Encode for MemType with encode(val, buf) {\n  Encode::encode(val.0, buf)\n}\n\n///|\npub impl Encode for GlobalType with encode(val, buf) {\n  let GlobalType(vt, m) = val\n  match Encode::encode(vt, buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  Encode::encode(m, buf)\n}\n\n///|\npub impl Encode for TagType with encode(val, buf) {\n  buf.write_byte(0x00)\n  Encode::encode(val.0, buf)\n}\n\n///|\npub impl Encode for FuncSec with encode(val, buf) {\n  buf.write_byte(3)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for TableSec with encode(val, buf) {\n  buf.write_byte(4)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for Table with encode(val, buf) {\n  match val {\n    Table(tt, None) => Encode::encode(tt, buf)\n    Table(tt, Some(e)) => {\n      buf.write_bytes(b\"\\x40\\x00\")\n      match Encode::encode(tt, buf) {\n        Err(err) => return Err(err)\n        Ok(_) => Encode::encode(e, buf)\n      }\n    }\n  }\n}\n\n///|\npub impl Encode for MemSec with encode(val, buf) {\n  buf.write_byte(5)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for GlobalSec with encode(val, buf) {\n  buf.write_byte(6)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for Global with encode(val, buf) {\n  let Global(gt, e) = val\n  match Encode::encode(gt, buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  Encode::encode(e, buf)\n}\n\n///|\npub impl Encode for ExportSec with encode(val, buf) {\n  buf.write_byte(7)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for Export with encode(val, buf) {\n  let Export(n, eidx) = val\n  match Encode::encode(n, buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  Encode::encode(eidx, buf)\n}\n\n///|\npub impl Encode for StartSec with encode(val, buf) {\n  buf.write_byte(0x08)\n  Encode::encode(val.0, buf)\n}\n\n///|\npub impl Encode for ElemSec with encode(val, buf) {\n  buf.write_byte(9)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for Elem with encode(val, buf) {\n  match val {\n    Elem(Active(TableIdx(0), e), FuncsElemKind(y)) => {\n      buf.write_byte(0x00)\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(y, buf)\n    }\n    Elem(Passive, FuncsElemKind(y)) => {\n      buf.write_bytes(b\"\\x01\\x00\")\n      Encode::encode(y, buf)\n    }\n    Elem(Active(ti, e), FuncsElemKind(y)) => {\n      buf.write_byte(0x02)\n      if Encode::encode(ti, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n      buf.write_byte(0x00)\n      Encode::encode(y, buf)\n    }\n    Elem(Declarative, FuncsElemKind(y)) => {\n      buf.write_bytes(b\"\\x03\\x00\")\n      Encode::encode(y, buf)\n    }\n    Elem(Active(TableIdx(0), e), FuncExprsElemKind(es)) => {\n      buf.write_byte(0x04)\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(es, buf)\n    }\n    // Encoder fixes - add funcref reftype\n    Elem(Passive, FuncExprsElemKind(es)) => {\n      buf.write_byte(0x05)\n      let rt = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n      if Encode::encode(rt, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(es, buf)\n    }\n    Elem(Active(ti, e), FuncExprsElemKind(es)) => {\n      buf.write_byte(0x06)\n      if Encode::encode(ti, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n      // DON'T encode reftype - format 6 has implicit (ref null func)\n      Encode::encode(es, buf)\n    }\n    Elem(Declarative, FuncExprsElemKind(es)) => {\n      let rt = @lib.HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n      buf.write_byte(0x07)\n      if Encode::encode(rt, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(es, buf)\n    }\n    Elem(Passive, TypedExprsElemKind(rt, es)) => {\n      buf.write_byte(0x05)\n      if Encode::encode(rt, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(es, buf)\n    }\n    Elem(Declarative, TypedExprsElemKind(rt, es)) => {\n      buf.write_byte(0x07)\n      if Encode::encode(rt, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(es, buf)\n    }\n    Elem(Active(_), TypedExprsElemKind(_)) => {\n      println(\"Hit problem active sequence.\")\n      Err(\n        \"Invalid Active Sequence. Active Sequences must be func refs or indicies.\",\n      )\n    }\n  }\n}\n\n///|\npub impl Encode for CodeSec with encode(val, buf) {\n  let CodeSec(fns) = val\n  buf.write_byte(0x0A)\n  Encode::encode(fns, buf)\n}\n\n///|\npub impl Encode for Func with encode(val, buf) {\n  let fn_body = @buffer.new()\n  let (locals, expr) = match val {\n    Func(locals, expr) => (locals, expr)\n    TFunc(tlocals, texpr) => {\n      let locals = tlocals_to_locals(tlocals)\n      let expr = texpr_to_expr(texpr)\n      (locals, expr)\n    }\n  }\n  if Encode::encode(locals, fn_body) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(expr, fn_body) is Err(t) {\n    return Err(t)\n  }\n  let fn_bytes = fn_body.to_bytes()\n  if Encode::encode(@lib.U32(fn_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(fn_bytes) // Don't use Encode::encode here - just write raw bytes\n  Ok(())\n}\n\n///|\npub impl Encode for DataSec with encode(val, buf) {\n  buf.write_byte(11)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for Data with encode(val, buf) {\n  match val {\n    Data(Active(MemIdx(0), e), bytes) => {\n      buf.write_byte(0x00)\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(bytes, buf)\n    }\n    Data(Passive, bytes) => {\n      buf.write_byte(0x01)\n      Encode::encode(bytes, buf)\n    }\n    Data(Active(idx, e), bytes) => {\n      buf.write_byte(0x02)\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n      Encode::encode(bytes, buf)\n    }\n  }\n}\n\n///|\npub impl Encode for Locals with encode(val, buf) {\n  let Locals(count, vt) = val\n  match Encode::encode(@lib.U32(count), buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  Encode::encode(vt, buf)\n}\n\n///|\npub impl Encode for DataCntSec with encode(val, buf) {\n  let DataCntSec(count) = val\n  buf.write_byte(12)\n  if Encode::encode(count, buf) is Err(t) {\n    return Err(t)\n  }\n  Ok(())\n}\n\n///|\npub impl Encode for TagSec with encode(val, buf) {\n  buf.write_byte(13)\n  let payload = @buffer.new()\n  if Encode::encode(val.0, payload) is Err(t) {\n    return Err(t)\n  }\n  let payload_bytes = payload.to_bytes()\n  if Encode::encode(@lib.U32(payload_bytes.length().reinterpret_as_uint()), buf)\n    is Err(t) {\n    return Err(t)\n  }\n  buf.write_bytes(payload_bytes)\n  Ok(())\n}\n\n///|\npub impl Encode for CastOp with encode(val, buf) {\n  match val {\n    CastOp(false, false) => buf.write_byte(0x00)\n    CastOp(true, false) => buf.write_byte(0x01)\n    CastOp(false, true) => buf.write_byte(0x02)\n    CastOp(true, true) => buf.write_byte(0x03)\n  }\n  Ok(())\n}\n\n///|\npub impl Encode for Module with encode(val, buf) {\n  buf.write_bytes(b\"\\x00\\x61\\x73\\x6D\\x01\\x00\\x00\\x00\")\n  // custom sections\n  for sec in val.0 {\n    if Encode::encode(sec, buf) is Err(t) {\n      return Err(t)\n    }\n  }\n  if Encode::encode(val.1, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.2, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.3, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.4, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.5, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.6, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.7, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.8, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.9, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.10, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.11, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.12, buf) is Err(t) {\n    return Err(t)\n  }\n  if Encode::encode(val.13, buf) is Err(t) {\n    return Err(t)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for Module with decode(bytes, i) {\n  let mut i = i\n  let custom = Array::new()\n  let mut type_sec = None\n  let mut import_sec = None\n  let mut func_sec = None\n  let mut table_sec = None\n  let mut mem_sec = None\n  let mut tag_sec = None\n  let mut global_sec = None\n  let mut export_sec = None\n  let mut start_sec = None\n  let mut elem_sec = None\n  let mut data_cnt_sec = None\n  let mut code_sec = None\n  let mut data_sec = None\n  for b in [0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00] {\n    if bytes.get(i) != Some(b.to_byte()) {\n      return Err(\"Invalid magic header\")\n    }\n    i = i + 1\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    type_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    import_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    func_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    table_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    mem_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    tag_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    global_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    export_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    start_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    elem_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    data_cnt_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    code_sec = Some(sec)\n    i = next\n  }\n  while Decode::decode(bytes, i) is Ok((sec, next)) {\n    custom.push(sec)\n    i = next\n  }\n  if Decode::decode(bytes, i) is Ok((sec, next)) {\n    data_sec = Some(sec)\n    i = next\n  }\n  if i == bytes.length() {\n    Ok(\n      (\n        Module(\n          custom, type_sec, import_sec, func_sec, table_sec, mem_sec, tag_sec, global_sec,\n          export_sec, start_sec, elem_sec, data_cnt_sec, code_sec, data_sec,\n        ),\n        i,\n      ),\n    )\n  } else {\n    Err(\"Invalid module\")\n  }\n}\n\n///|\npub impl Decode for Elem with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((expr, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((fidxs, i)) =>\n              Ok((Elem(ElemMode::Active(0, expr), FuncsElemKind(fidxs)), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x01) =>\n      match bytes.get(i + 1) {\n        Some(0x00) =>\n          match Decode::decode(bytes, i + 2) {\n            Ok((fidxs, i)) => Ok((Elem(Passive, FuncsElemKind(fidxs)), i))\n            Err(t) => Err(t)\n          }\n        _ => Err(\"Invalid elem header\")\n      }\n    Some(0x02) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.TableIdx(idx), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((expr, i)) =>\n              match bytes.get(i) {\n                Some(0x00) =>\n                  match Decode::decode(bytes, i + 1) {\n                    Ok((fidxs, i)) =>\n                      Ok(\n                        (\n                          Elem(\n                            ElemMode::Active(idx, expr),\n                            FuncsElemKind(fidxs),\n                          ),\n                          i,\n                        ),\n                      )\n                    Err(t) => Err(t)\n                  }\n                _ => Err(\"Invalid elem header\")\n              }\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x03) =>\n      match bytes.get(i + 1) {\n        Some(0x00) =>\n          match Decode::decode(bytes, i + 2) {\n            Ok((fidxs, i)) => Ok((Elem(Declarative, FuncsElemKind(fidxs)), i))\n            Err(t) => Err(t)\n          }\n        _ => Err(\"Invalid elem header\")\n      }\n    Some(0x04) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((expr, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((exprs, i)) =>\n              Ok(\n                (\n                  Elem(\n                    ElemMode::Active(TableIdx(0), expr),\n                    FuncExprsElemKind(exprs),\n                  ),\n                  i,\n                ),\n              )\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x05) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((rt, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((exprs, i)) =>\n              Ok((Elem(Passive, TypedExprsElemKind(rt, exprs)), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x06) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((expr, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((exprs, i)) =>\n                  Ok(\n                    (\n                      Elem(\n                        ElemMode::Active(idx, expr),\n                        FuncExprsElemKind(exprs),\n                      ),\n                      i,\n                    ),\n                  )\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x07) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((rt, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((exprs, i)) =>\n              Ok((Elem(Declarative, TypedExprsElemKind(rt, exprs)), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(_) => Err(\"Invalid elem header\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Decode for ElemSec with decode(bytes, i) {\n  if bytes.get(i) != Some(9) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((ElemSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for DataCntSec with decode(bytes, i) {\n  if bytes.get(i) != Some(12) {\n    return Err(\"Invalid section header\")\n  }\n  match Decode::decode(bytes, i + 1) {\n    Ok((@lib.U32(count), i)) => Ok((DataCntSec(count), i))\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for Locals with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((@lib.U32(count), i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((vt, i)) => Ok((Locals(count, vt), i))\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for Func with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((@lib.U32(_size), i)) => // Read the length prefix first\n      match Decode::decode(bytes, i) {\n        Ok((locals, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((expr, i)) => Ok((Func(locals, expr), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for CodeSec with decode(bytes, i) {\n  if bytes.get(i) != Some(10) {\n    return Err(\"Invalid section header\")\n  }\n  match Decode::decode(bytes, i + 1) {\n    Ok((funcs, i)) => Ok((CodeSec(funcs), i))\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for Data with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((expr, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((bytes, i)) =>\n              Ok((Data(DataMode::Active(MemIdx(0), expr), bytes), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x01) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((bytes, i)) => Ok((Data(DataMode::Passive, bytes), i))\n        Err(t) => Err(t)\n      }\n    Some(0x02) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((expr, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((bytes, i)) =>\n                  Ok((Data(DataMode::Active(idx, expr), bytes), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(_) => Err(\"Invalid data header\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Decode for DataSec with decode(bytes, i) {\n  if bytes.get(i) != Some(11) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((DataSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for CustomSec with decode(bytes, i) {\n  if bytes.get(i) != Some(0) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), i1) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let end = i1 + len\n  if end > bytes.length() {\n    return Err(\"Custom section payload length out of range\")\n  }\n  let view = bytes[i1:end].to_bytes()\n  let (name, j) = match Decode::decode(view, 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let bytes = view[j:].to_bytes()\n  Ok((CustomSec(name, bytes), end))\n}\n\n///|\npub impl Decode for TypeSec with decode(bytes, i) {\n  if bytes.get(i) != Some(1) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((TypeSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for Import with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((nm1, i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((nm2, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((et, i)) => Ok((Import(nm1, nm2, et), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for Limits with decode(bytes, i) {\n  match bytes.get(i) {\n    None => Err(\"Index out of bounds\")\n    Some(0x00) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U64(n), i)) => Ok((I32Limits(n.to_uint(), None), i))\n        Err(t) => Err(t)\n      }\n    Some(0x01) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U64(n), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((@lib.U64(m), i)) =>\n              Ok((I32Limits(n.to_uint(), Some(m.to_uint())), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x04) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U64(n), i)) => Ok((I64Limits(n, None), i))\n        Err(t) => Err(t)\n      }\n    Some(0x05) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U64(n), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((@lib.U64(m), i)) => Ok((I64Limits(n, Some(m)), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(_) => Err(\"Invalid Limits\")\n  }\n}\n\n///|\npub impl Decode for TableType with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((rt, i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((l, i)) => Ok((TableType(rt, l), i))\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for MemType with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((l, i)) => Ok((MemType(l), i))\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for GlobalType with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((vt, i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((m, i)) => Ok((GlobalType(vt, m), i))\n        Err(_) => Ok((GlobalType(vt, false), i))\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for TagType with decode(bytes, i) {\n  if bytes.get(i) != Some(0x00) {\n    return Err(\"Invalid TagType\")\n  }\n  match Decode::decode(bytes, i + 1) {\n    Ok((idx, i)) => Ok((TagType(idx), i))\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for ExternType with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((FuncExternType(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x01) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tt, i)) => Ok((TableExternType(tt), i))\n        Err(t) => Err(t)\n      }\n    Some(0x02) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((mt, i)) => Ok((MemExternType(mt), i))\n        Err(t) => Err(t)\n      }\n    Some(0x03) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((gt, i)) => Ok((GlobalExternType(gt), i))\n        Err(t) => Err(t)\n      }\n    Some(0x04) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tt, i)) => Ok((TagExternType(tt), i))\n        Err(t) => Err(t)\n      }\n    Some(_) => Err(\"Invalid ExternType Header\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n// General pattern for section decoding\n\n///|\npub impl Decode for ImportSec with decode(bytes, i) {\n  if bytes.get(i) != Some(2) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((ImportSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for FuncSec with decode(bytes, i) {\n  if bytes.get(i) != Some(3) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((FuncSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for BlockType with decode(bytes, i) {\n  if bytes.get(i) is Some(0x40) {\n    return Ok((EmptyBlockType, i + 1))\n  }\n  if Decode::decode(bytes, i) is Ok((vt, i)) {\n    return Ok((ValTypeBlockType(vt), i))\n  }\n  if Decode::decode(bytes, i) is Ok((@lib.S33(idx), i)) {\n    return Ok((TypeIdxBlockType(TypeIdx(idx)), i))\n  }\n  Err(\"Invalid block type\")\n}\n\n///|\npub impl Decode for Expr with decode(bytes, i) {\n  let a = Array::new()\n  let i = loop i {\n    i =>\n      match Decode::decode(bytes, i) {\n        Ok((inst, i)) => {\n          a.push(inst)\n          continue i\n        }\n        Err(_) if bytes.get(i) == Some(0x0B) => break i + 1\n        Err(t) => return Err(t)\n      }\n  }\n  Ok((Expr(a), i))\n}\n\n///|\npub impl Decode for Table with decode(bytes, i) {\n  match (bytes.get(i), bytes.get(i + 1)) {\n    (Some(0x40), Some(0x00)) =>\n      match Decode::decode(bytes, i + 2) {\n        Ok((tt, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((e, i)) => Ok((Table(tt, Some(e)), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    _ =>\n      match Decode::decode(bytes, i) {\n        Ok((tt, i)) => Ok((Table(tt, None), i))\n        Err(t) => Err(t)\n      }\n  }\n}\n\n///|\npub impl Decode for Global with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((gt, i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((expr, i)) => Ok((Global(gt, expr), i))\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for ExternIdx with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((FuncExternIdx(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x01) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((TableExternIdx(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x02) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((MemExternIdx(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x03) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((GlobalExternIdx(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x04) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((TagExternIdx(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(_) => Err(\"Invalid extern index\")\n    None => Err(\"Index out of bounds\")\n  }\n}\n\n///|\npub impl Decode for Export with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((n, i)) =>\n      match Decode::decode(bytes, i) {\n        Ok((idx, i)) => Ok((Export(n, idx), i))\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n  }\n}\n\n///|\npub impl Decode for TableSec with decode(bytes, i) {\n  if bytes.get(i) != Some(4) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((TableSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for MemSec with decode(bytes, i) {\n  if bytes.get(i) != Some(5) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((MemSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for TagSec with decode(bytes, i) {\n  if bytes.get(i) != Some(13) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((TagSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for GlobalSec with decode(bytes, i) {\n  if bytes.get(i) != Some(6) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((GlobalSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for ExportSec with decode(bytes, i) {\n  if bytes.get(i) != Some(7) {\n    return Err(\"Invalid section header\")\n  }\n  let (@lib.U32(len), payload_start) = match Decode::decode(bytes, i + 1) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  let len = len.reinterpret_as_int()\n  let payload_end = payload_start + len\n\n  // Decode from the payload slice (or directly with bounds checking)\n  let (content, j) = match\n    Decode::decode(bytes[payload_start:payload_end].to_bytes(), 0) {\n    Ok(t) => t\n    Err(t) => return Err(t)\n  }\n  if j == len {\n    Ok((ExportSec(content), payload_end))\n  } else {\n    Err(\"Invalid section - didn't consume all bytes\")\n  }\n}\n\n///|\npub impl Decode for StartSec with decode(bytes, i) {\n  if bytes.get(i) != Some(8) {\n    return Err(\"Invalid section header\")\n  }\n  match Decode::decode(bytes, i + 1) {\n    Err(t) => Err(t)\n    Ok((idx, i)) => Ok((StartSec(idx), i))\n  }\n}\n\n///|\npub impl Decode for Bytes with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Err(t) => Err(t)\n    Ok((@lib.U32(len), i)) if len + i.reinterpret_as_uint() <=\n      bytes.length().reinterpret_as_uint() => {\n      let next = i + len.reinterpret_as_int()\n      let val = bytes.sub(start=i, end=next).to_bytes()\n      Ok((val, next))\n    }\n    Ok(_) => Err(\"Invalid offset.\")\n  }\n}\n\n///|\npub impl Encode for Bytes with encode(val, buf) {\n  match Encode::encode(@lib.U32(val.length().reinterpret_as_uint()), buf) {\n    Err(err) => return Err(err)\n    Ok(_) => ()\n  }\n  buf.write_bytes(val)\n  Ok(())\n}\n\n///|\npub impl Encode for BlockType with encode(val, buf) {\n  match val {\n    EmptyBlockType => {\n      buf.write_byte(0x40)\n      Ok(())\n    }\n    ValTypeBlockType(vt) => Encode::encode(vt, buf)\n    TypeIdxBlockType(TypeIdx(idx)) => Encode::encode(@lib.S33(idx), buf)\n    _ => Err(\"Cannot encode recursive indexes\")\n  }\n}\n\n///|\npub impl Encode for Expr with encode(val, buf) {\n  for i in val.0.iter() {\n    if Encode::encode(i, buf) is Err(err) {\n      return Err(err)\n    }\n  }\n  buf.write_byte(0x0B)\n  Ok(())\n}\n\n///|\npub impl Encode for Catch with encode(val, buf) {\n  match val {\n    Catch(t, l) => {\n      buf.write_byte(0x00)\n      if Encode::encode(t, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    CatchRef(t, l) => {\n      buf.write_byte(0x01)\n      if Encode::encode(t, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    CatchAll(l) => {\n      buf.write_byte(0x02)\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    CatchAllRef(l) => {\n      buf.write_byte(0x03)\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n  }\n  Ok(())\n}\n\n///|\npub impl Encode for MemArg with encode(val, buf) {\n  match val {\n    MemArg(U32(n), Some(i), m) if n < 64 => {\n      if Encode::encode(@lib.U32(n + 64), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    MemArg(U32(n), None, m) if n < 64 => {\n      if Encode::encode(@lib.U32(n), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    _ => return Err(\"Invalid Memarg\")\n  }\n  Ok(())\n}\n\n///|\nfn simd_inst(id : UInt, buf : @buffer.Buffer) -> Result[Unit, String] {\n  buf.write_byte(0xFD)\n  if Encode::encode(@lib.U32(id), buf) is Err(t) {\n    return Err(t)\n  }\n  Ok(())\n}\n\n///|\npub impl Decode for Catch with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tidx, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((lidx, i)) => Ok((Catch(tidx, lidx), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x01) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tidx, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((lidx, i)) => Ok((CatchRef(tidx, lidx), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x02) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((CatchAll(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x03) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((CatchAllRef(idx), i))\n        Err(t) => Err(t)\n      }\n    _ => Err(\"Invalid catch\")\n  }\n}\n\n///|\npub impl Decode for CastOp with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) => Ok((CastOp(false, false), i + 1))\n    Some(0x01) => Ok((CastOp(true, false), i + 1))\n    Some(0x02) => Ok((CastOp(false, true), i + 1))\n    Some(0x03) => Ok((CastOp(true, true), i + 1))\n    _ => Err(\"Invalid castop\")\n  }\n}\n\n///|\npub impl Decode for MemArg with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Ok((@lib.U32(n), i)) if n >= 64 && n < 128 =>\n      match Decode::decode(bytes, i) {\n        Ok((x, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((@lib.U64(m), i)) => Ok((MemArg(n - 64, Some(x), m), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Ok((@lib.U32(n), i)) if n < 64 =>\n      match Decode::decode(bytes, i) {\n        Ok((@lib.U64(m), i)) => Ok((MemArg(n, None, m), i))\n        Err(t) => Err(t)\n      }\n    Err(t) => Err(t)\n    _ => Err(\"Invalid memarg\")\n  }\n}\n\n///|\npub impl Decode for Instruction with decode(bytes, i) {\n  match bytes.get(i) {\n    Some(0x00) => Ok((Unreachable, i + 1))\n    Some(0x01) => Ok((Nop, i + 1))\n    Some(0x1A) => Ok((Drop, i + 1))\n    Some(0x1B) => Ok((Select(None), i + 1))\n    Some(0x1C) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((vts, i)) => Ok((Select(Some(vts)), i))\n        Err(t) => Err(t)\n      }\n    Some(0x02) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((bt, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((expr, i)) => Ok((Block(bt, expr), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x03) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((bt, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((expr, i)) => Ok((Loop(bt, expr), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x04) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((bt, i)) => {\n          let (if_inst, i) = loop (i, [], None) {\n            (i, if_insts, Some(else_insts)) =>\n              match bytes.get(i) {\n                Some(0x0B) =>\n                  break (@lib.If(bt, if_insts, Some(else_insts)), i + 1)\n                _ =>\n                  match Decode::decode(bytes, i) {\n                    Ok((inst, i)) => {\n                      else_insts.push(inst)\n                      continue (i, if_insts, Some(else_insts))\n                    }\n                    Err(t) => return Err(t)\n                  }\n              }\n            (i, if_insts, None) =>\n              match bytes.get(i) {\n                Some(0x05) => continue (i + 1, if_insts, Some([]))\n                Some(0x0B) => break (If(bt, if_insts, None), i + 1)\n                _ =>\n                  match Decode::decode(bytes, i) {\n                    Ok((inst, i)) => {\n                      if_insts.push(inst)\n                      continue (i, if_insts, None)\n                    }\n                    Err(t) => return Err(t)\n                  }\n              }\n          }\n          Ok((if_inst, i))\n        }\n        Err(t) => Err(t)\n      }\n    Some(0x08) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tag, i)) => Ok((Throw(tag), i))\n        Err(t) => Err(t)\n      }\n    Some(0x0A) => Ok((ThrowRef, i + 1))\n    Some(0x0C) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((lbl, i)) => Ok((Br(lbl), i))\n        Err(t) => Err(t)\n      }\n    Some(0x0D) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((lbl, i)) => Ok((BrIf(lbl), i))\n        Err(t) => Err(t)\n      }\n    Some(0x0E) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((lbls, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((lbl, i)) => Ok((BrTable(lbls, lbl), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x0F) => Ok((Return, i + 1))\n    Some(0x10) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((Call(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x11) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tidx, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((tblidx, i)) => Ok((CallIndirect(tidx, tblidx), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x12) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((ReturnCall(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x13) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tidx, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((tblidx, i)) => Ok((ReturnCallIndirect(tidx, tblidx), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0x14) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tidx, i)) => Ok((CallRef(tidx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x15) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((tidx, i)) => Ok((ReturnCallRef(tidx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x1F) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((bt, i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((c, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((e, i)) => Ok((TryTable(bt, c, e), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n      }\n    Some(0xD5) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((BrOnNull(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0xD6) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((BrOnNonNull(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x20) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((LocalGet(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x21) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((LocalSet(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x22) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((LocalTee(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x23) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((GlobalGet(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x24) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((GlobalSet(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x25) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((TableGet(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x26) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((idx, i)) => Ok((TableSet(idx), i))\n        Err(t) => Err(t)\n      }\n    Some(0x28) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Load(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x29) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x2A) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((F32Load(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x2B) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((F64Load(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x2C) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Load8S(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x2D) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Load8U(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x2E) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Load16S(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x2F) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Load16U(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x30) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load8S(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x31) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load8U(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x32) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load16S(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x33) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load16U(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x34) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load32S(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x35) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Load32U(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x36) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Store(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x37) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Store(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x38) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((F32Store(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x39) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((F64Store(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x3A) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Store8(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x3B) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I32Store16(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x3C) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Store8(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x3D) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Store16(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x3E) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((m, i)) => Ok((I64Store32(m), i))\n        Err(t) => Err(t)\n      }\n    Some(0x3F) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((x, i)) => Ok((MemorySize(x), i))\n        Err(t) => Err(t)\n      }\n    Some(0x40) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((x, i)) => Ok((MemoryGrow(x), i))\n        Err(t) => Err(t)\n      }\n    Some(0xD0) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((ht, i)) => Ok((RefNull(ht), i))\n        Err(t) => Err(t)\n      }\n    Some(0xD1) => Ok((RefIsNull, i + 1))\n    Some(0xD2) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((x, i)) => Ok((RefFunc(x), i))\n        Err(t) => Err(t)\n      }\n    Some(0xD3) => Ok((RefEq, i + 1))\n    Some(0xD4) => Ok((RefAsNonNull, i + 1))\n    Some(0x45) => Ok((I32Eqz, i + 1))\n    Some(0x46) => Ok((I32Eq, i + 1))\n    Some(0x47) => Ok((I32Ne, i + 1))\n    Some(0x48) => Ok((I32LtS, i + 1))\n    Some(0x49) => Ok((I32LtU, i + 1))\n    Some(0x4A) => Ok((I32GtS, i + 1))\n    Some(0x4B) => Ok((I32GtU, i + 1))\n    Some(0x4C) => Ok((I32LeS, i + 1))\n    Some(0x4D) => Ok((I32LeU, i + 1))\n    Some(0x4E) => Ok((I32GeS, i + 1))\n    Some(0x4F) => Ok((I32GeU, i + 1))\n    Some(0x50) => Ok((I64Eqz, i + 1))\n    Some(0x51) => Ok((I64Eq, i + 1))\n    Some(0x52) => Ok((I64Ne, i + 1))\n    Some(0x53) => Ok((I64LtS, i + 1))\n    Some(0x54) => Ok((I64LtU, i + 1))\n    Some(0x55) => Ok((I64GtS, i + 1))\n    Some(0x56) => Ok((I64GtU, i + 1))\n    Some(0x57) => Ok((I64LeS, i + 1))\n    Some(0x58) => Ok((I64LeU, i + 1))\n    Some(0x59) => Ok((I64GeS, i + 1))\n    Some(0x5A) => Ok((I64GeU, i + 1))\n    Some(0x5B) => Ok((F32Eq, i + 1))\n    Some(0x5C) => Ok((F32Ne, i + 1))\n    Some(0x5D) => Ok((F32Lt, i + 1))\n    Some(0x5E) => Ok((F32Gt, i + 1))\n    Some(0x5F) => Ok((F32Le, i + 1))\n    Some(0x60) => Ok((F32Ge, i + 1))\n    Some(0x61) => Ok((F64Eq, i + 1))\n    Some(0x62) => Ok((F64Ne, i + 1))\n    Some(0x63) => Ok((F64Lt, i + 1))\n    Some(0x64) => Ok((F64Gt, i + 1))\n    Some(0x65) => Ok((F64Le, i + 1))\n    Some(0x66) => Ok((F64Ge, i + 1))\n    Some(0x67) => Ok((I32Clz, i + 1))\n    Some(0x68) => Ok((I32Ctz, i + 1))\n    Some(0x69) => Ok((I32Popcnt, i + 1))\n    Some(0x6A) => Ok((I32Add, i + 1))\n    Some(0x6B) => Ok((I32Sub, i + 1))\n    Some(0x6C) => Ok((I32Mul, i + 1))\n    Some(0x6D) => Ok((I32DivS, i + 1))\n    Some(0x6E) => Ok((I32DivU, i + 1))\n    Some(0x6F) => Ok((I32RemS, i + 1))\n    Some(0x70) => Ok((I32RemU, i + 1))\n    Some(0x71) => Ok((I32And, i + 1))\n    Some(0x72) => Ok((I32Or, i + 1))\n    Some(0x73) => Ok((I32Xor, i + 1))\n    Some(0x74) => Ok((I32Shl, i + 1))\n    Some(0x75) => Ok((I32ShrS, i + 1))\n    Some(0x76) => Ok((I32ShrU, i + 1))\n    Some(0x77) => Ok((I32Rotl, i + 1))\n    Some(0x78) => Ok((I32Rotr, i + 1))\n    Some(0x79) => Ok((I64Clz, i + 1))\n    Some(0x7A) => Ok((I64Ctz, i + 1))\n    Some(0x7B) => Ok((I64Popcnt, i + 1))\n    Some(0x7C) => Ok((I64Add, i + 1))\n    Some(0x7D) => Ok((I64Sub, i + 1))\n    Some(0x7E) => Ok((I64Mul, i + 1))\n    Some(0x7F) => Ok((I64DivS, i + 1))\n    Some(0x80) => Ok((I64DivU, i + 1))\n    Some(0x81) => Ok((I64RemS, i + 1))\n    Some(0x82) => Ok((I64RemU, i + 1))\n    Some(0x83) => Ok((I64And, i + 1))\n    Some(0x84) => Ok((I64Or, i + 1))\n    Some(0x85) => Ok((I64Xor, i + 1))\n    Some(0x86) => Ok((I64Shl, i + 1))\n    Some(0x87) => Ok((I64ShrS, i + 1))\n    Some(0x88) => Ok((I64ShrU, i + 1))\n    Some(0x89) => Ok((I64Rotl, i + 1))\n    Some(0x8A) => Ok((I64Rotr, i + 1))\n    Some(0x8B) => Ok((F32Abs, i + 1))\n    Some(0x8C) => Ok((F32Neg, i + 1))\n    Some(0x8D) => Ok((F32Ceil, i + 1))\n    Some(0x8E) => Ok((F32Floor, i + 1))\n    Some(0x8F) => Ok((F32Trunc, i + 1))\n    Some(0x90) => Ok((F32Nearest, i + 1))\n    Some(0x91) => Ok((F32Sqrt, i + 1))\n    Some(0x92) => Ok((F32Add, i + 1))\n    Some(0x93) => Ok((F32Sub, i + 1))\n    Some(0x94) => Ok((F32Mul, i + 1))\n    Some(0x95) => Ok((F32Div, i + 1))\n    Some(0x96) => Ok((F32Min, i + 1))\n    Some(0x97) => Ok((F32Max, i + 1))\n    Some(0x98) => Ok((F32Copysign, i + 1))\n    Some(0x99) => Ok((F64Abs, i + 1))\n    Some(0x9A) => Ok((F64Neg, i + 1))\n    Some(0x9B) => Ok((F64Ceil, i + 1))\n    Some(0x9C) => Ok((F64Floor, i + 1))\n    Some(0x9D) => Ok((F64Trunc, i + 1))\n    Some(0x9E) => Ok((F64Nearest, i + 1))\n    Some(0x9F) => Ok((F64Sqrt, i + 1))\n    Some(0xA0) => Ok((F64Add, i + 1))\n    Some(0xA1) => Ok((F64Sub, i + 1))\n    Some(0xA2) => Ok((F64Mul, i + 1))\n    Some(0xA3) => Ok((F64Div, i + 1))\n    Some(0xA4) => Ok((F64Min, i + 1))\n    Some(0xA5) => Ok((F64Max, i + 1))\n    Some(0xA6) => Ok((F64Copysign, i + 1))\n    Some(0xA7) => Ok((I32WrapI64, i + 1))\n    Some(0xA8) => Ok((I32TruncF32S, i + 1))\n    Some(0xA9) => Ok((I32TruncF32U, i + 1))\n    Some(0xAA) => Ok((I32TruncF64S, i + 1))\n    Some(0xAB) => Ok((I32TruncF64U, i + 1))\n    Some(0xAC) => Ok((I64ExtendI32S, i + 1))\n    Some(0xAD) => Ok((I64ExtendI32U, i + 1))\n    Some(0xAE) => Ok((I64TruncF32S, i + 1))\n    Some(0xAF) => Ok((I64TruncF32U, i + 1))\n    Some(0xB0) => Ok((I64TruncF64S, i + 1))\n    Some(0xB1) => Ok((I64TruncF64U, i + 1))\n    Some(0xB2) => Ok((F32ConvertI32S, i + 1))\n    Some(0xB3) => Ok((F32ConvertI32U, i + 1))\n    Some(0xB4) => Ok((F32ConvertI64S, i + 1))\n    Some(0xB5) => Ok((F32ConvertI64U, i + 1))\n    Some(0xB6) => Ok((F32DemoteF64, i + 1))\n    Some(0xB7) => Ok((F64ConvertI32S, i + 1))\n    Some(0xB8) => Ok((F64ConvertI32U, i + 1))\n    Some(0xB9) => Ok((F64ConvertI64S, i + 1))\n    Some(0xBA) => Ok((F64ConvertI64U, i + 1))\n    Some(0xBB) => Ok((F64PromoteF32, i + 1))\n    Some(0xBC) => Ok((I32ReinterpretF32, i + 1))\n    Some(0xBD) => Ok((I64ReinterpretF64, i + 1))\n    Some(0xBE) => Ok((F32ReinterpretI32, i + 1))\n    Some(0xBF) => Ok((F64ReinterpretI64, i + 1))\n    Some(0xC0) => Ok((I32Extend8S, i + 1))\n    Some(0xC1) => Ok((I32Extend16S, i + 1))\n    Some(0xC2) => Ok((I64Extend8S, i + 1))\n    Some(0xC3) => Ok((I64Extend16S, i + 1))\n    Some(0xC4) => Ok((I64Extend32S, i + 1))\n    Some(0x41) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((n, i)) => Ok((I32Const(n), i))\n        Err(t) => Err(t)\n      }\n    Some(0x42) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((n, i)) => Ok((I64Const(n), i))\n        Err(t) => Err(t)\n      }\n    Some(0x43) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((n, i)) => Ok((F32Const(n), i))\n        Err(t) => Err(t)\n      }\n    Some(0x44) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((n, i)) => Ok((F64Const(n), i))\n        Err(t) => Err(t)\n      }\n\n    // Section: Control Flow/Aggregate 0xFB\n    Some(0xFB) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U32(0), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((StructNew(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(1), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((StructNewDefault(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(2), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((StructGet(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(3), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((StructGetS(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(4), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((StructGetU(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(5), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((StructSet(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(6), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArrayNew(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(7), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArrayNewDefault(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(8), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((ArrayNewFixed(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(9), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((ArrayNewData(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(10), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((n, i)) => Ok((ArrayNewElem(x, n), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(11), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArrayGet(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(12), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArrayGetS(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(13), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArrayGetU(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(14), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArraySet(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(15), i)) => Ok((ArrayLen, i))\n        Ok((@lib.U32(16), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((ArrayFill(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(17), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x1, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((x2, i)) => Ok((ArrayCopy(x1, x2), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(18), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x1, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((x2, i)) => Ok((ArrayInitData(x1, x2), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(19), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x1, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((x2, i)) => Ok((ArrayInitElem(x1, x2), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(20), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((ht, i)) => Ok((RefTest(false, ht), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(21), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((ht, i)) => Ok((RefTest(true, ht), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(22), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((ht, i)) => Ok((RefCast(false, ht), i))\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(23), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((ht, i)) => Ok((RefCast(true, ht), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(24), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((c, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) =>\n                  match Decode::decode(bytes, i) {\n                    Ok((ht1, i)) =>\n                      match Decode::decode(bytes, i) {\n                        Ok((ht2, i)) => Ok((BrOnCast(l, c, ht1, ht2), i))\n                        Err(t) => Err(t)\n                      }\n                    Err(t) => Err(t)\n                  }\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(25), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((c, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) =>\n                  match Decode::decode(bytes, i) {\n                    Ok((ht1, i)) =>\n                      match Decode::decode(bytes, i) {\n                        Ok((ht2, i)) => Ok((BrOnCastFail(l, c, ht1, ht2), i))\n                        Err(t) => Err(t)\n                      }\n                    Err(t) => Err(t)\n                  }\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(26), i)) => Ok((AnyConvertExtern, i))\n        Ok((U32(27), i)) => Ok((ExternConvertAny, i))\n        Ok((U32(28), i)) => Ok((RefI31, i))\n        Ok((U32(29), i)) => Ok((I31GetS, i))\n        Ok((U32(30), i)) => Ok((I31GetU, i))\n        Err(t) => Err(t)\n        _ => Err(\"Invalid instruction\")\n      }\n\n    // Section: Memory/Table/Elem\n    Some(0xFC) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U32(0), i)) => Ok((I32TruncSatF32S, i))\n        Ok((U32(1), i)) => Ok((I32TruncSatF32U, i))\n        Ok((U32(2), i)) => Ok((I32TruncSatF64S, i))\n        Ok((U32(3), i)) => Ok((I32TruncSatF64U, i))\n        Ok((U32(4), i)) => Ok((I64TruncSatF32S, i))\n        Ok((U32(5), i)) => Ok((I64TruncSatF32U, i))\n        Ok((U32(6), i)) => Ok((I64TruncSatF64S, i))\n        Ok((U32(7), i)) => Ok((I64TruncSatF64U, i))\n        Ok((U32(8), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((y, i)) => Ok((MemoryInit(x, y), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(9), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((DataDrop(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(10), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((y, i)) => Ok((MemoryCopy(x, y), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(11), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) => Ok((MemoryFill(x), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(12), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((y, i)) => Ok((TableInit(x, y), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(13), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((y, i)) => Ok((ElemDrop(y), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(14), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((x, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((y, i)) => Ok((TableCopy(x, y), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(15), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((y, i)) => Ok((TableGrow(y), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(16), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((y, i)) => Ok((TableSize(y), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(17), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((y, i)) => Ok((TableFill(y), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n        _ => Err(\"Invalid Instruction\")\n      }\n\n    // Section: Vector\n    Some(0xFD) =>\n      match Decode::decode(bytes, i + 1) {\n        Ok((@lib.U32(0), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(1), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load8x8S(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(2), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load8x8U(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(3), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load16x4S(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(4), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load16x4U(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(5), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load32x2S(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(6), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load32x2U(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(7), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load8Splat(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(8), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load16Splat(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(9), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load32Splat(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(10), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load64Splat(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(11), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Store(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(12), i)) =>\n          // 16 bytes const\n          if bytes.length() >= i + 16 {\n            Ok(\n              (\n                V128Const(\n                  bytes.unsafe_get(i),\n                  bytes.unsafe_get(i + 1),\n                  bytes.unsafe_get(i + 2),\n                  bytes.unsafe_get(i + 3),\n                  bytes.unsafe_get(i + 4),\n                  bytes.unsafe_get(i + 5),\n                  bytes.unsafe_get(i + 6),\n                  bytes.unsafe_get(i + 7),\n                  bytes.unsafe_get(i + 8),\n                  bytes.unsafe_get(i + 9),\n                  bytes.unsafe_get(i + 10),\n                  bytes.unsafe_get(i + 11),\n                  bytes.unsafe_get(i + 12),\n                  bytes.unsafe_get(i + 13),\n                  bytes.unsafe_get(i + 14),\n                  bytes.unsafe_get(i + 15),\n                ),\n                i + 16,\n              ),\n            )\n          } else {\n            Err(\"Invalid Instruction\")\n          }\n        Ok((U32(13), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l0, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l1, i)) =>\n                  match Decode::decode(bytes, i) {\n                    Ok((l2, i)) =>\n                      match Decode::decode(bytes, i) {\n                        Ok((l3, i)) =>\n                          match Decode::decode(bytes, i) {\n                            Ok((l4, i)) =>\n                              match Decode::decode(bytes, i) {\n                                Ok((l5, i)) =>\n                                  match Decode::decode(bytes, i) {\n                                    Ok((l6, i)) =>\n                                      match Decode::decode(bytes, i) {\n                                        Ok((l7, i)) =>\n                                          match Decode::decode(bytes, i) {\n                                            Ok((l8, i)) =>\n                                              match Decode::decode(bytes, i) {\n                                                Ok((l9, i)) =>\n                                                  match\n                                                    Decode::decode(bytes, i) {\n                                                    Ok((l10, i)) =>\n                                                      match\n                                                        Decode::decode(bytes, i) {\n                                                        Ok((l11, i)) =>\n                                                          match\n                                                            Decode::decode(\n                                                              bytes, i,\n                                                            ) {\n                                                            Ok((l12, i)) =>\n                                                              match\n                                                                Decode::decode(\n                                                                  bytes, i,\n                                                                ) {\n                                                                Ok((l13, i)) =>\n                                                                  match\n                                                                    Decode::decode(\n                                                                      bytes, i,\n                                                                    ) {\n                                                                    Ok((l14, i)) =>\n                                                                      match\n                                                                        Decode::decode(\n                                                                          bytes,\n                                                                          i,\n                                                                        ) {\n                                                                        Ok(\n                                                                          (\n                                                                            l15,\n                                                                            i,\n                                                                          )\n                                                                        ) =>\n                                                                          Ok(\n                                                                            (\n                                                                              I8x16Shuffle(\n                                                                                l0,\n                                                                                l1,\n                                                                                l2,\n                                                                                l3,\n                                                                                l4,\n                                                                                l5,\n                                                                                l6,\n                                                                                l7,\n                                                                                l8,\n                                                                                l9,\n                                                                                l10,\n                                                                                l11,\n                                                                                l12,\n                                                                                l13,\n                                                                                l14,\n                                                                                l15,\n                                                                              ),\n                                                                              i,\n                                                                            ),\n                                                                          )\n                                                                        Err(t) =>\n                                                                          Err(t)\n                                                                      }\n                                                                    Err(t) =>\n                                                                      Err(t)\n                                                                  }\n                                                                Err(t) => Err(t)\n                                                              }\n                                                            Err(t) => Err(t)\n                                                          }\n                                                        Err(t) => Err(t)\n                                                      }\n                                                    Err(t) => Err(t)\n                                                  }\n                                                Err(t) => Err(t)\n                                              }\n                                            Err(t) => Err(t)\n                                          }\n                                        Err(t) => Err(t)\n                                      }\n                                    Err(t) => Err(t)\n                                  }\n                                Err(t) => Err(t)\n                              }\n                            Err(t) => Err(t)\n                          }\n                        Err(t) => Err(t)\n                      }\n                    Err(t) => Err(t)\n                  }\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((@lib.U32(14), i)) => Ok((I8x16Swizzle, i))\n        Ok((@lib.U32(15), i)) => Ok((I8x16Splat, i))\n        Ok((@lib.U32(16), i)) => Ok((I16x8Splat, i))\n        Ok((@lib.U32(17), i)) => Ok((I32x4Splat, i))\n        Ok((@lib.U32(18), i)) => Ok((I64x2Splat, i))\n        Ok((@lib.U32(19), i)) => Ok((F32x4Splat, i))\n        Ok((@lib.U32(20), i)) => Ok((F64x2Splat, i))\n        Ok((@lib.U32(35), i)) => Ok((I8x16Eq, i))\n        Ok((@lib.U32(36), i)) => Ok((I8x16Ne, i))\n        Ok((@lib.U32(37), i)) => Ok((I8x16LtS, i))\n        Ok((@lib.U32(38), i)) => Ok((I8x16LtU, i))\n        Ok((@lib.U32(39), i)) => Ok((I8x16GtS, i))\n        Ok((@lib.U32(40), i)) => Ok((I8x16GtU, i))\n        Ok((@lib.U32(41), i)) => Ok((I8x16LeS, i))\n        Ok((@lib.U32(42), i)) => Ok((I8x16LeU, i))\n        Ok((@lib.U32(43), i)) => Ok((I8x16GeS, i))\n        Ok((@lib.U32(44), i)) => Ok((I8x16GeU, i))\n        Ok((@lib.U32(45), i)) => Ok((I16x8Eq, i))\n        Ok((@lib.U32(46), i)) => Ok((I16x8Ne, i))\n        Ok((@lib.U32(47), i)) => Ok((I16x8LtS, i))\n        Ok((@lib.U32(48), i)) => Ok((I16x8LtU, i))\n        Ok((@lib.U32(49), i)) => Ok((I16x8GtS, i))\n        Ok((@lib.U32(50), i)) => Ok((I16x8GtU, i))\n        Ok((@lib.U32(51), i)) => Ok((I16x8LeS, i))\n        Ok((@lib.U32(52), i)) => Ok((I16x8LeU, i))\n        Ok((@lib.U32(53), i)) => Ok((I16x8GeS, i))\n        Ok((@lib.U32(54), i)) => Ok((I16x8GeU, i))\n        Ok((@lib.U32(55), i)) => Ok((I32x4Eq, i))\n        Ok((@lib.U32(56), i)) => Ok((I32x4Ne, i))\n        Ok((@lib.U32(57), i)) => Ok((I32x4LtS, i))\n        Ok((@lib.U32(58), i)) => Ok((I32x4LtU, i))\n        Ok((@lib.U32(59), i)) => Ok((I32x4GtS, i))\n        Ok((@lib.U32(60), i)) => Ok((I32x4GtU, i))\n        Ok((@lib.U32(61), i)) => Ok((I32x4LeS, i))\n        Ok((@lib.U32(62), i)) => Ok((I32x4LeU, i))\n        Ok((@lib.U32(63), i)) => Ok((I32x4GeS, i))\n        Ok((@lib.U32(64), i)) => Ok((I32x4GeU, i))\n        Ok((@lib.U32(65), i)) => Ok((F32x4Eq, i))\n        Ok((@lib.U32(66), i)) => Ok((F32x4Ne, i))\n        Ok((@lib.U32(67), i)) => Ok((F32x4Lt, i))\n        Ok((@lib.U32(68), i)) => Ok((F32x4Gt, i))\n        Ok((@lib.U32(69), i)) => Ok((F32x4Le, i))\n        Ok((@lib.U32(70), i)) => Ok((F32x4Ge, i))\n        Ok((@lib.U32(71), i)) => Ok((F64x2Eq, i))\n        Ok((@lib.U32(72), i)) => Ok((F64x2Ne, i))\n        Ok((@lib.U32(73), i)) => Ok((F64x2Lt, i))\n        Ok((@lib.U32(74), i)) => Ok((F64x2Gt, i))\n        Ok((@lib.U32(75), i)) => Ok((F64x2Le, i))\n        Ok((@lib.U32(76), i)) => Ok((F64x2Ge, i))\n        Ok((@lib.U32(77), i)) => Ok((V128Not, i))\n        Ok((@lib.U32(78), i)) => Ok((V128And, i))\n        Ok((@lib.U32(79), i)) => Ok((V128Andnot, i))\n        Ok((@lib.U32(80), i)) => Ok((V128Or, i))\n        Ok((@lib.U32(81), i)) => Ok((V128Xor, i))\n        Ok((@lib.U32(82), i)) => Ok((V128Bitselect, i))\n        Ok((@lib.U32(83), i)) => Ok((V128AnyTrue, i))\n        Ok((@lib.U32(94), i)) => Ok((F32x4DemoteF64x2Zero, i))\n        Ok((@lib.U32(95), i)) => Ok((F64x2PromoteLowF32x4, i))\n        Ok((@lib.U32(96), i)) => Ok((I8x16Abs, i))\n        Ok((@lib.U32(97), i)) => Ok((I8x16Neg, i))\n        Ok((@lib.U32(98), i)) => Ok((I8x16Popcnt, i))\n        Ok((@lib.U32(99), i)) => Ok((I8x16AllTrue, i))\n        Ok((@lib.U32(100), i)) => Ok((I8x16Bitmask, i))\n        Ok((@lib.U32(101), i)) => Ok((I8x16NarrowI16x8S, i))\n        Ok((@lib.U32(102), i)) => Ok((I8x16NarrowI16x8U, i))\n        Ok((@lib.U32(103), i)) => Ok((F32x4Ceil, i))\n        Ok((@lib.U32(104), i)) => Ok((F32x4Floor, i))\n        Ok((@lib.U32(105), i)) => Ok((F32x4Trunc, i))\n        Ok((@lib.U32(106), i)) => Ok((F32x4Nearest, i))\n        Ok((@lib.U32(107), i)) => Ok((I8x16Shl, i))\n        Ok((@lib.U32(108), i)) => Ok((I8x16ShrS, i))\n        Ok((@lib.U32(109), i)) => Ok((I8x16ShrU, i))\n        Ok((@lib.U32(110), i)) => Ok((I8x16Add, i))\n        Ok((@lib.U32(111), i)) => Ok((I8x16AddSatS, i))\n        Ok((@lib.U32(112), i)) => Ok((I8x16AddSatU, i))\n        Ok((@lib.U32(113), i)) => Ok((I8x16Sub, i))\n        Ok((@lib.U32(114), i)) => Ok((I8x16SubSatS, i))\n        Ok((@lib.U32(115), i)) => Ok((I8x16SubSatU, i))\n        Ok((@lib.U32(116), i)) => Ok((F64x2Ceil, i))\n        Ok((@lib.U32(117), i)) => Ok((F64x2Floor, i))\n        Ok((@lib.U32(118), i)) => Ok((I8x16MinS, i))\n        Ok((@lib.U32(119), i)) => Ok((I8x16MinU, i))\n        Ok((@lib.U32(120), i)) => Ok((I8x16MaxS, i))\n        Ok((@lib.U32(121), i)) => Ok((I8x16MaxU, i))\n        Ok((@lib.U32(122), i)) => Ok((F64x2Trunc, i))\n        Ok((@lib.U32(123), i)) => Ok((I8x16AvgrU, i))\n        Ok((@lib.U32(124), i)) => Ok((I16x8ExtaddPairwiseI8x16S, i))\n        Ok((@lib.U32(125), i)) => Ok((I16x8ExtaddPairwiseI8x16U, i))\n        Ok((@lib.U32(126), i)) => Ok((I32x4ExtaddPairwiseI16x8S, i))\n        Ok((@lib.U32(127), i)) => Ok((I32x4ExtaddPairwiseI16x8U, i))\n        Ok((@lib.U32(128), i)) => Ok((I16x8Abs, i))\n        Ok((@lib.U32(129), i)) => Ok((I16x8Neg, i))\n        Ok((@lib.U32(130), i)) => Ok((I16x8Q15mulrSatS, i))\n        Ok((@lib.U32(131), i)) => Ok((I16x8AllTrue, i))\n        Ok((@lib.U32(132), i)) => Ok((I16x8Bitmask, i))\n        Ok((@lib.U32(133), i)) => Ok((I16x8NarrowI32x4S, i))\n        Ok((@lib.U32(134), i)) => Ok((I16x8NarrowI32x4U, i))\n        Ok((@lib.U32(135), i)) => Ok((I16x8ExtendLowI8x16S, i))\n        Ok((@lib.U32(136), i)) => Ok((I16x8ExtendHighI8x16S, i))\n        Ok((@lib.U32(137), i)) => Ok((I16x8ExtendLowI8x16U, i))\n        Ok((@lib.U32(138), i)) => Ok((I16x8ExtendHighI8x16U, i))\n        Ok((@lib.U32(139), i)) => Ok((I16x8Shl, i))\n        Ok((@lib.U32(140), i)) => Ok((I16x8ShrS, i))\n        Ok((@lib.U32(141), i)) => Ok((I16x8ShrU, i))\n        Ok((@lib.U32(142), i)) => Ok((I16x8Add, i))\n        Ok((@lib.U32(143), i)) => Ok((I16x8AddSatS, i))\n        Ok((@lib.U32(144), i)) => Ok((I16x8AddSatU, i))\n        Ok((@lib.U32(145), i)) => Ok((I16x8Sub, i))\n        Ok((@lib.U32(146), i)) => Ok((I16x8SubSatS, i))\n        Ok((@lib.U32(147), i)) => Ok((I16x8SubSatU, i))\n        Ok((@lib.U32(148), i)) => Ok((F64x2Nearest, i))\n        Ok((@lib.U32(149), i)) => Ok((I16x8Mul, i))\n        Ok((@lib.U32(150), i)) => Ok((I16x8MinS, i))\n        Ok((@lib.U32(151), i)) => Ok((I16x8MinU, i))\n        Ok((@lib.U32(152), i)) => Ok((I16x8MaxS, i))\n        Ok((@lib.U32(153), i)) => Ok((I16x8MaxU, i))\n        Ok((@lib.U32(155), i)) => Ok((I16x8AvgrU, i))\n        Ok((@lib.U32(156), i)) => Ok((I16x8ExtmulLowI8x16S, i))\n        Ok((@lib.U32(157), i)) => Ok((I16x8ExtmulHighI8x16S, i))\n        Ok((@lib.U32(158), i)) => Ok((I16x8ExtmulLowI8x16U, i))\n        Ok((@lib.U32(159), i)) => Ok((I16x8ExtmulHighI8x16U, i))\n        Ok((@lib.U32(160), i)) => Ok((I32x4Abs, i))\n        Ok((@lib.U32(161), i)) => Ok((I32x4Neg, i))\n        Ok((@lib.U32(163), i)) => Ok((I32x4AllTrue, i))\n        Ok((@lib.U32(164), i)) => Ok((I32x4Bitmask, i))\n        Ok((@lib.U32(167), i)) => Ok((I32x4ExtendLowI16x8S, i))\n        Ok((@lib.U32(168), i)) => Ok((I32x4ExtendHighI16x8S, i))\n        Ok((@lib.U32(169), i)) => Ok((I32x4ExtendLowI16x8U, i))\n        Ok((@lib.U32(170), i)) => Ok((I32x4ExtendHighI16x8U, i))\n        Ok((@lib.U32(171), i)) => Ok((I32x4Shl, i))\n        Ok((@lib.U32(172), i)) => Ok((I32x4ShrS, i))\n        Ok((@lib.U32(173), i)) => Ok((I32x4ShrU, i))\n        Ok((@lib.U32(174), i)) => Ok((I32x4Add, i))\n        Ok((@lib.U32(177), i)) => Ok((I32x4Sub, i))\n        Ok((@lib.U32(181), i)) => Ok((I32x4Mul, i))\n        Ok((@lib.U32(182), i)) => Ok((I32x4MinS, i))\n        Ok((@lib.U32(183), i)) => Ok((I32x4MinU, i))\n        Ok((@lib.U32(184), i)) => Ok((I32x4MaxS, i))\n        Ok((@lib.U32(185), i)) => Ok((I32x4MaxU, i))\n        Ok((@lib.U32(186), i)) => Ok((I32x4DotI16x8S, i))\n        Ok((@lib.U32(188), i)) => Ok((I32x4ExtmulLowI16x8S, i))\n        Ok((@lib.U32(189), i)) => Ok((I32x4ExtmulHighI16x8S, i))\n        Ok((@lib.U32(190), i)) => Ok((I32x4ExtmulLowI16x8U, i))\n        Ok((@lib.U32(191), i)) => Ok((I32x4ExtmulHighI16x8U, i))\n        Ok((@lib.U32(192), i)) => Ok((I64x2Abs, i))\n        Ok((@lib.U32(193), i)) => Ok((I64x2Neg, i))\n        Ok((@lib.U32(195), i)) => Ok((I64x2AllTrue, i))\n        Ok((@lib.U32(196), i)) => Ok((I64x2Bitmask, i))\n        Ok((@lib.U32(199), i)) => Ok((I64x2ExtendLowI32x4S, i))\n        Ok((@lib.U32(200), i)) => Ok((I64x2ExtendHighI32x4S, i))\n        Ok((@lib.U32(201), i)) => Ok((I64x2ExtendLowI32x4U, i))\n        Ok((@lib.U32(202), i)) => Ok((I64x2ExtendHighI32x4U, i))\n        Ok((@lib.U32(203), i)) => Ok((I64x2Shl, i))\n        Ok((@lib.U32(204), i)) => Ok((I64x2ShrS, i))\n        Ok((@lib.U32(205), i)) => Ok((I64x2ShrU, i))\n        Ok((@lib.U32(206), i)) => Ok((I64x2Add, i))\n        Ok((@lib.U32(209), i)) => Ok((I64x2Sub, i))\n        Ok((@lib.U32(213), i)) => Ok((I64x2Mul, i))\n        Ok((@lib.U32(214), i)) => Ok((I64x2Eq, i))\n        Ok((@lib.U32(215), i)) => Ok((I64x2Ne, i))\n        Ok((@lib.U32(216), i)) => Ok((I64x2LtS, i))\n        Ok((@lib.U32(217), i)) => Ok((I64x2GtS, i))\n        Ok((@lib.U32(218), i)) => Ok((I64x2LeS, i))\n        Ok((@lib.U32(219), i)) => Ok((I64x2GeS, i))\n        Ok((@lib.U32(220), i)) => Ok((I64x2ExtmulLowI32x4S, i))\n        Ok((@lib.U32(221), i)) => Ok((I64x2ExtmulHighI32x4S, i))\n        Ok((@lib.U32(222), i)) => Ok((I64x2ExtmulLowI32x4U, i))\n        Ok((@lib.U32(223), i)) => Ok((I64x2ExtmulHighI32x4U, i))\n        Ok((@lib.U32(224), i)) => Ok((F32x4Abs, i))\n        Ok((@lib.U32(225), i)) => Ok((F32x4Neg, i))\n        Ok((@lib.U32(227), i)) => Ok((F32x4Sqrt, i))\n        Ok((@lib.U32(228), i)) => Ok((F32x4Add, i))\n        Ok((@lib.U32(229), i)) => Ok((F32x4Sub, i))\n        Ok((@lib.U32(230), i)) => Ok((F32x4Mul, i))\n        Ok((@lib.U32(231), i)) => Ok((F32x4Div, i))\n        Ok((@lib.U32(232), i)) => Ok((F32x4Min, i))\n        Ok((@lib.U32(233), i)) => Ok((F32x4Max, i))\n        Ok((@lib.U32(234), i)) => Ok((F32x4Pmin, i))\n        Ok((@lib.U32(235), i)) => Ok((F32x4Pmax, i))\n        Ok((@lib.U32(236), i)) => Ok((F64x2Abs, i))\n        Ok((@lib.U32(237), i)) => Ok((F64x2Neg, i))\n        Ok((@lib.U32(239), i)) => Ok((F64x2Sqrt, i))\n        Ok((@lib.U32(240), i)) => Ok((F64x2Add, i))\n        Ok((@lib.U32(241), i)) => Ok((F64x2Sub, i))\n        Ok((@lib.U32(242), i)) => Ok((F64x2Mul, i))\n        Ok((@lib.U32(243), i)) => Ok((F64x2Div, i))\n        Ok((@lib.U32(244), i)) => Ok((F64x2Min, i))\n        Ok((@lib.U32(245), i)) => Ok((F64x2Max, i))\n        Ok((@lib.U32(246), i)) => Ok((F64x2Pmin, i))\n        Ok((@lib.U32(247), i)) => Ok((F64x2Pmax, i))\n        Ok((@lib.U32(248), i)) => Ok((I32x4TruncSatF32x4S, i))\n        Ok((@lib.U32(249), i)) => Ok((I32x4TruncSatF32x4U, i))\n        Ok((@lib.U32(250), i)) => Ok((F32x4ConvertI32x4S, i))\n        Ok((@lib.U32(251), i)) => Ok((F32x4ConvertI32x4U, i))\n        Ok((@lib.U32(252), i)) => Ok((I32x4TruncSatF64x2SZero, i))\n        Ok((@lib.U32(253), i)) => Ok((I32x4TruncSatF64x2UZero, i))\n        Ok((@lib.U32(254), i)) => Ok((F64x2ConvertLowI32x4S, i))\n        Ok((@lib.U32(255), i)) => Ok((F64x2ConvertLowI32x4U, i))\n        Ok((@lib.U32(256), i)) => Ok((I8x16RelaxedSwizzle, i))\n        Ok((@lib.U32(257), i)) => Ok((I32x4RelaxedTruncF32x4S, i))\n        Ok((@lib.U32(258), i)) => Ok((I32x4RelaxedTruncF32x4U, i))\n        Ok((@lib.U32(259), i)) => Ok((I32x4RelaxedTruncZeroF64x2S, i))\n        Ok((@lib.U32(260), i)) => Ok((I32x4RelaxedTruncZeroF64x2U, i))\n        Ok((@lib.U32(261), i)) => Ok((F32x4RelaxedMadd, i))\n        Ok((@lib.U32(262), i)) => Ok((F32x4RelaxedNmadd, i))\n        Ok((@lib.U32(263), i)) => Ok((F64x2RelaxedMadd, i))\n        Ok((@lib.U32(264), i)) => Ok((F64x2RelaxedNmadd, i))\n        Ok((@lib.U32(265), i)) => Ok((I8x16RelaxedLaneselect, i))\n        Ok((@lib.U32(266), i)) => Ok((I16x8RelaxedLaneselect, i))\n        Ok((@lib.U32(267), i)) => Ok((I32x4RelaxedLaneselect, i))\n        Ok((@lib.U32(268), i)) => Ok((I64x2RelaxedLaneselect, i))\n        Ok((@lib.U32(269), i)) => Ok((F32x4RelaxedMin, i))\n        Ok((@lib.U32(270), i)) => Ok((F32x4RelaxedMax, i))\n        Ok((@lib.U32(271), i)) => Ok((F64x2RelaxedMin, i))\n        Ok((@lib.U32(272), i)) => Ok((F64x2RelaxedMax, i))\n        Ok((@lib.U32(273), i)) => Ok((I16x8RelaxedQ15mulrS, i))\n        Ok((@lib.U32(274), i)) => Ok((I16x8RelaxedDotI8x16I7x16S, i))\n        Ok((@lib.U32(275), i)) => Ok((I32x4RelaxedDotI8x16I7x16AddS, i))\n        Ok((@lib.U32(21), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I8x16ExtractLaneS(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(22), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I8x16ExtractLaneU(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(23), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I8x16ReplaceLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(24), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I16x8ExtractLaneS(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(25), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I16x8ExtractLaneU(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(26), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I16x8ReplaceLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(27), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I32x4ExtractLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(28), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I32x4ReplaceLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(29), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I64x2ExtractLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(30), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((I64x2ReplaceLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(31), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((F32x4ExtractLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(32), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((F32x4ReplaceLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(33), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((F64x2ExtractLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(34), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((l, i)) => Ok((F64x2ReplaceLane(l), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(84), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Load8Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(85), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Load16Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(86), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Load32Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(87), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Load64Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(88), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Store8Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(89), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Store16Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(90), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Store32Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(91), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) =>\n              match Decode::decode(bytes, i) {\n                Ok((l, i)) => Ok((V128Store64Lane(m, l), i))\n                Err(t) => Err(t)\n              }\n            Err(t) => Err(t)\n          }\n        Ok((U32(92), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load32Zero(m), i))\n            Err(t) => Err(t)\n          }\n        Ok((U32(93), i)) =>\n          match Decode::decode(bytes, i) {\n            Ok((m, i)) => Ok((V128Load64Zero(m), i))\n            Err(t) => Err(t)\n          }\n        Err(t) => Err(t)\n        _ => Err(\"Invalid Instruction\")\n      }\n    _ => Err(\"Invalid Instruction\")\n  }\n}\n\n///|\npub impl Encode for Instruction with encode(val, buf) {\n  match val {\n    Unreachable => buf.write_byte(0x00)\n    Nop => buf.write_byte(0x01)\n    Block(bt, i) => {\n      buf.write_byte(0x02)\n      if Encode::encode(bt, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    Loop(bt, i) => {\n      buf.write_byte(0x03)\n      if Encode::encode(bt, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    If(bt, if_block, else_block) => {\n      buf.write_byte(0x04)\n      if Encode::encode(bt, buf) is Err(t) {\n        return Err(t)\n      }\n      for i in if_block.iter() {\n        if Encode::encode(i, buf) is Err(t) {\n          return Err(t)\n        }\n      }\n      if else_block is Some(else_block) {\n        buf.write_byte(0x05)\n        for i in else_block.iter() {\n          if Encode::encode(i, buf) is Err(t) {\n            return Err(t)\n          }\n        }\n      }\n      buf.write_byte(0x0B)\n    }\n    Throw(t) => {\n      buf.write_byte(0x08)\n      if Encode::encode(t, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ThrowRef => buf.write_byte(0x0A)\n    Br(i) => {\n      buf.write_byte(0x0C)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    BrIf(i) => {\n      buf.write_byte(0x0D)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    BrTable(ls, i) => {\n      buf.write_byte(0x0E)\n      if Encode::encode(ls, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    Return => buf.write_byte(0x0F)\n    Call(i) => {\n      buf.write_byte(0x10)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    CallIndirect(ty, ta) => {\n      buf.write_byte(0x11)\n      if Encode::encode(ty, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ta, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ReturnCall(f) => {\n      buf.write_byte(0x12)\n      if Encode::encode(f, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ReturnCallIndirect(ty, ta) => {\n      buf.write_byte(0x13)\n      if Encode::encode(ty, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ta, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    CallRef(t) => {\n      buf.write_byte(0x14)\n      if Encode::encode(t, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ReturnCallRef(t) => {\n      buf.write_byte(0x15)\n      if Encode::encode(t, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    Drop => buf.write_byte(0x1A)\n    Select(None) => buf.write_byte(0x1b)\n    Select(Some(vts)) => {\n      buf.write_byte(0x1C)\n      if Encode::encode(vts, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TryTable(bt, c, e) => {\n      buf.write_byte(0x1F)\n      if Encode::encode(bt, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(c, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(e, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    LocalGet(l) => {\n      buf.write_byte(0x20)\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    LocalSet(l) => {\n      buf.write_byte(0x21)\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    LocalTee(l) => {\n      buf.write_byte(0x22)\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    GlobalGet(g) => {\n      buf.write_byte(0x23)\n      if Encode::encode(g, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    GlobalSet(g) => {\n      buf.write_byte(0x24)\n      if Encode::encode(g, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableGet(i) => {\n      buf.write_byte(0x25)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableSet(i) => {\n      buf.write_byte(0x26)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Load(m) => {\n      buf.write_byte(0x28)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load(m) => {\n      buf.write_byte(0x29)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F32Load(m) => {\n      buf.write_byte(0x2A)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F64Load(m) => {\n      buf.write_byte(0x2B)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Load8S(m) => {\n      buf.write_byte(0x2C)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Load8U(m) => {\n      buf.write_byte(0x2D)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Load16S(m) => {\n      buf.write_byte(0x2E)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Load16U(m) => {\n      buf.write_byte(0x2F)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load8S(m) => {\n      buf.write_byte(0x30)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load8U(m) => {\n      buf.write_byte(0x31)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load16S(m) => {\n      buf.write_byte(0x32)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load16U(m) => {\n      buf.write_byte(0x33)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load32S(m) => {\n      buf.write_byte(0x34)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Load32U(m) => {\n      buf.write_byte(0x35)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Store(m) => {\n      buf.write_byte(0x36)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Store(m) => {\n      buf.write_byte(0x37)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F32Store(m) => {\n      buf.write_byte(0x38)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F64Store(m) => {\n      buf.write_byte(0x39)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Store8(m) => {\n      buf.write_byte(0x3A)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Store16(m) => {\n      buf.write_byte(0x3B)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Store8(m) => {\n      buf.write_byte(0x3C)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Store16(m) => {\n      buf.write_byte(0x3D)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Store32(m) => {\n      buf.write_byte(0x3E)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    MemorySize(m) => {\n      buf.write_byte(0x3F)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    MemoryGrow(m) => {\n      buf.write_byte(0x40)\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Const(c) => {\n      buf.write_byte(0x41)\n      if Encode::encode(c, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64Const(c) => {\n      buf.write_byte(0x42)\n      if Encode::encode(c, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F32Const(c) => {\n      buf.write_byte(0x43)\n      if Encode::encode(c, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F64Const(c) => {\n      buf.write_byte(0x44)\n      if Encode::encode(c, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32Eqz => buf.write_byte(0x45)\n    I32Eq => buf.write_byte(0x46)\n    I32Ne => buf.write_byte(0x47)\n    I32LtS => buf.write_byte(0x48)\n    I32LtU => buf.write_byte(0x49)\n    I32GtS => buf.write_byte(0x4A)\n    I32GtU => buf.write_byte(0x4B)\n    I32LeS => buf.write_byte(0x4C)\n    I32LeU => buf.write_byte(0x4D)\n    I32GeS => buf.write_byte(0x4E)\n    I32GeU => buf.write_byte(0x4F)\n    I64Eqz => buf.write_byte(0x50)\n    I64Eq => buf.write_byte(0x51)\n    I64Ne => buf.write_byte(0x52)\n    I64LtS => buf.write_byte(0x53)\n    I64LtU => buf.write_byte(0x54)\n    I64GtS => buf.write_byte(0x55)\n    I64GtU => buf.write_byte(0x56)\n    I64LeS => buf.write_byte(0x57)\n    I64LeU => buf.write_byte(0x58)\n    I64GeS => buf.write_byte(0x59)\n    I64GeU => buf.write_byte(0x5A)\n    F32Eq => buf.write_byte(0x5B)\n    F32Ne => buf.write_byte(0x5C)\n    F32Lt => buf.write_byte(0x5D)\n    F32Gt => buf.write_byte(0x5E)\n    F32Le => buf.write_byte(0x5F)\n    F32Ge => buf.write_byte(0x60)\n    F64Eq => buf.write_byte(0x61)\n    F64Ne => buf.write_byte(0x62)\n    F64Lt => buf.write_byte(0x63)\n    F64Gt => buf.write_byte(0x64)\n    F64Le => buf.write_byte(0x65)\n    F64Ge => buf.write_byte(0x66)\n    I32Clz => buf.write_byte(0x67)\n    I32Ctz => buf.write_byte(0x68)\n    I32Popcnt => buf.write_byte(0x69)\n    I32Add => buf.write_byte(0x6A)\n    I32Sub => buf.write_byte(0x6B)\n    I32Mul => buf.write_byte(0x6C)\n    I32DivS => buf.write_byte(0x6D)\n    I32DivU => buf.write_byte(0x6E)\n    I32RemS => buf.write_byte(0x6F)\n    I32RemU => buf.write_byte(0x70)\n    I32And => buf.write_byte(0x71)\n    I32Or => buf.write_byte(0x72)\n    I32Xor => buf.write_byte(0x73)\n    I32Shl => buf.write_byte(0x74)\n    I32ShrS => buf.write_byte(0x75)\n    I32ShrU => buf.write_byte(0x76)\n    I32Rotl => buf.write_byte(0x77)\n    I32Rotr => buf.write_byte(0x78)\n    I64Clz => buf.write_byte(0x79)\n    I64Ctz => buf.write_byte(0x7A)\n    I64Popcnt => buf.write_byte(0x7B)\n    I64Add => buf.write_byte(0x7C)\n    I64Sub => buf.write_byte(0x7D)\n    I64Mul => buf.write_byte(0x7E)\n    I64DivS => buf.write_byte(0x7F)\n    I64DivU => buf.write_byte(0x80)\n    I64RemS => buf.write_byte(0x81)\n    I64RemU => buf.write_byte(0x82)\n    I64And => buf.write_byte(0x83)\n    I64Or => buf.write_byte(0x84)\n    I64Xor => buf.write_byte(0x85)\n    I64Shl => buf.write_byte(0x86)\n    I64ShrS => buf.write_byte(0x87)\n    I64ShrU => buf.write_byte(0x88)\n    I64Rotl => buf.write_byte(0x89)\n    I64Rotr => buf.write_byte(0x8A)\n    F32Abs => buf.write_byte(0x8B)\n    F32Neg => buf.write_byte(0x8C)\n    F32Ceil => buf.write_byte(0x8D)\n    F32Floor => buf.write_byte(0x8E)\n    F32Trunc => buf.write_byte(0x8F)\n    F32Nearest => buf.write_byte(0x90)\n    F32Sqrt => buf.write_byte(0x91)\n    F32Add => buf.write_byte(0x92)\n    F32Sub => buf.write_byte(0x93)\n    F32Mul => buf.write_byte(0x94)\n    F32Div => buf.write_byte(0x95)\n    F32Min => buf.write_byte(0x96)\n    F32Max => buf.write_byte(0x97)\n    F32Copysign => buf.write_byte(0x98)\n    F64Abs => buf.write_byte(0x99)\n    F64Neg => buf.write_byte(0x9A)\n    F64Ceil => buf.write_byte(0x9B)\n    F64Floor => buf.write_byte(0x9C)\n    F64Trunc => buf.write_byte(0x9D)\n    F64Nearest => buf.write_byte(0x9E)\n    F64Sqrt => buf.write_byte(0x9F)\n    F64Add => buf.write_byte(0xA0)\n    F64Sub => buf.write_byte(0xA1)\n    F64Mul => buf.write_byte(0xA2)\n    F64Div => buf.write_byte(0xA3)\n    F64Min => buf.write_byte(0xA4)\n    F64Max => buf.write_byte(0xA5)\n    F64Copysign => buf.write_byte(0xA6)\n    I32WrapI64 => buf.write_byte(0xA7)\n    I32TruncF32S => buf.write_byte(0xA8)\n    I32TruncF32U => buf.write_byte(0xA9)\n    I32TruncF64S => buf.write_byte(0xAA)\n    I32TruncF64U => buf.write_byte(0xAB)\n    I64ExtendI32S => buf.write_byte(0xAC)\n    I64ExtendI32U => buf.write_byte(0xAD)\n    I64TruncF32S => buf.write_byte(0xAE)\n    I64TruncF32U => buf.write_byte(0xAF)\n    I64TruncF64S => buf.write_byte(0xB0)\n    I64TruncF64U => buf.write_byte(0xB1)\n    F32ConvertI32S => buf.write_byte(0xB2)\n    F32ConvertI32U => buf.write_byte(0xB3)\n    F32ConvertI64S => buf.write_byte(0xB4)\n    F32ConvertI64U => buf.write_byte(0xB5)\n    F32DemoteF64 => buf.write_byte(0xB6)\n    F64ConvertI32S => buf.write_byte(0xB7)\n    F64ConvertI32U => buf.write_byte(0xB8)\n    F64ConvertI64S => buf.write_byte(0xB9)\n    F64ConvertI64U => buf.write_byte(0xBA)\n    F64PromoteF32 => buf.write_byte(0xBB)\n    I32ReinterpretF32 => buf.write_byte(0xBC)\n    I64ReinterpretF64 => buf.write_byte(0xBD)\n    F32ReinterpretI32 => buf.write_byte(0xBE)\n    F64ReinterpretI64 => buf.write_byte(0xBF)\n    I32Extend8S => buf.write_byte(0xC0)\n    I32Extend16S => buf.write_byte(0xC1)\n    I64Extend8S => buf.write_byte(0xC2)\n    I64Extend16S => buf.write_byte(0xC3)\n    I64Extend32S => buf.write_byte(0xC4)\n    RefNull(ht) => {\n      buf.write_byte(0xD0)\n      if Encode::encode(ht, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefIsNull => buf.write_byte(0xD1)\n    RefFunc(i) => {\n      buf.write_byte(0xD2)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefEq => buf.write_byte(0xD3)\n    RefAsNonNull => buf.write_byte(0xD4)\n    BrOnNull(i) => {\n      buf.write_byte(0xD5)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    BrOnNonNull(i) => {\n      buf.write_byte(0xD6)\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    StructNew(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(0), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    StructNewDefault(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(1), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    StructGet(i, idx) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(2), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    StructGetS(i, idx) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(3), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    StructGetU(i, idx) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(4), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    StructSet(i, idx) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(5), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayNew(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(6), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayNewDefault(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(7), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayNewFixed(i, n) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(8), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(n, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayNewData(i, idx) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(9), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayNewElem(i, idx) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(10), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(idx, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayGet(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(11), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayGetS(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(12), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayGetU(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(13), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArraySet(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(14), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayLen => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(15), buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayFill(i) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(16), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(i, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayCopy(x0, x1) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(17), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(x0, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(x1, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayInitData(x, y) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(18), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(x, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(y, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ArrayInitElem(x, y) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(19), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(x, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(y, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefTest(false, ht) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(20), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefTest(true, ht) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(21), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefCast(false, ht) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(22), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefCast(true, ht) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(23), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    BrOnCast(l, castop, ht0, ht1) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(24), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(castop, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht0, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht1, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    BrOnCastFail(l, castop, ht0, ht1) => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(25), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(castop, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht0, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ht1, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    AnyConvertExtern => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(26), buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ExternConvertAny => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(27), buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    RefI31 => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(28), buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I31GetS => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(29), buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I31GetU => {\n      buf.write_byte(0xFB)\n      if Encode::encode(@lib.U32(30), buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32TruncSatF32S => buf.write_bytes(b\"\\xFC\\x00\")\n    I32TruncSatF32U => buf.write_bytes(b\"\\xFC\\x01\")\n    I32TruncSatF64S => buf.write_bytes(b\"\\xFC\\x02\")\n    I32TruncSatF64U => buf.write_bytes(b\"\\xFC\\x03\")\n    I64TruncSatF32S => buf.write_bytes(b\"\\xFC\\x04\")\n    I64TruncSatF32U => buf.write_bytes(b\"\\xFC\\x05\")\n    I64TruncSatF64S => buf.write_bytes(b\"\\xFC\\x06\")\n    I64TruncSatF64U => buf.write_bytes(b\"\\xFC\\x07\")\n    MemoryInit(di, mi) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(8), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(di, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(mi, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    DataDrop(di) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(9), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(di, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    MemoryCopy(mi0, mi1) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(10), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(mi0, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(mi1, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    MemoryFill(mi) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(11), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(mi, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableInit(ei, ti) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(12), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ei, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ti, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    ElemDrop(ei) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(13), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ei, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableCopy(ti0, ti1) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(14), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ti0, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ti1, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableGrow(ti) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(15), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ti, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableSize(ti) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(16), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ti, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    TableFill(ti) => {\n      buf.write_byte(0xFC)\n      if Encode::encode(@lib.U32(17), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(ti, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(0), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load8x8S(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(1), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load8x8U(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(2), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load16x4S(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(3), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load16x4U(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(4), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load32x2S(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(5), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load32x2U(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(6), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load8Splat(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(7), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load16Splat(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(8), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load32Splat(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(9), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load64Splat(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(10), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Store(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(11), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Const(\n      b0,\n      b1,\n      b2,\n      b3,\n      b4,\n      b5,\n      b6,\n      b7,\n      b8,\n      b9,\n      b10,\n      b11,\n      b12,\n      b13,\n      b14,\n      b15\n    ) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(12), buf) is Err(t) {\n        return Err(t)\n      }\n      buf.write_byte(b0)\n      buf.write_byte(b1)\n      buf.write_byte(b2)\n      buf.write_byte(b3)\n      buf.write_byte(b4)\n      buf.write_byte(b5)\n      buf.write_byte(b6)\n      buf.write_byte(b7)\n      buf.write_byte(b8)\n      buf.write_byte(b9)\n      buf.write_byte(b10)\n      buf.write_byte(b11)\n      buf.write_byte(b12)\n      buf.write_byte(b13)\n      buf.write_byte(b14)\n      buf.write_byte(b15)\n    }\n    I8x16Shuffle(\n      b0,\n      b1,\n      b2,\n      b3,\n      b4,\n      b5,\n      b6,\n      b7,\n      b8,\n      b9,\n      b10,\n      b11,\n      b12,\n      b13,\n      b14,\n      b15\n    ) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(13), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b0, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b1, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b2, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b3, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b4, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b5, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b6, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b7, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b8, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b9, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b10, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b11, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b12, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b13, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b14, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(b15, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I8x16Swizzle => return simd_inst(14, buf)\n    I8x16Splat => return simd_inst(15, buf)\n    I16x8Splat => return simd_inst(16, buf)\n    I32x4Splat => return simd_inst(17, buf)\n    I64x2Splat => return simd_inst(18, buf)\n    F32x4Splat => return simd_inst(19, buf)\n    F64x2Splat => return simd_inst(20, buf)\n    I8x16ExtractLaneS(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(21), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I8x16ExtractLaneU(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(22), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I8x16ReplaceLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(23), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I16x8ExtractLaneS(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(24), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I16x8ExtractLaneU(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(25), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I16x8ReplaceLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(26), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32x4ExtractLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(27), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I32x4ReplaceLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(28), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64x2ExtractLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(29), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I64x2ReplaceLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(30), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F32x4ExtractLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(31), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F32x4ReplaceLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(32), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F64x2ExtractLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(33), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F64x2ReplaceLane(l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(34), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    I8x16Eq => return simd_inst(35, buf)\n    I8x16Ne => return simd_inst(36, buf)\n    I8x16LtS => return simd_inst(37, buf)\n    I8x16LtU => return simd_inst(38, buf)\n    I8x16GtS => return simd_inst(39, buf)\n    I8x16GtU => return simd_inst(40, buf)\n    I8x16LeS => return simd_inst(41, buf)\n    I8x16LeU => return simd_inst(42, buf)\n    I8x16GeS => return simd_inst(43, buf)\n    I8x16GeU => return simd_inst(44, buf)\n    I16x8Eq => return simd_inst(45, buf)\n    I16x8Ne => return simd_inst(46, buf)\n    I16x8LtS => return simd_inst(47, buf)\n    I16x8LtU => return simd_inst(48, buf)\n    I16x8GtS => return simd_inst(49, buf)\n    I16x8GtU => return simd_inst(50, buf)\n    I16x8LeS => return simd_inst(51, buf)\n    I16x8LeU => return simd_inst(52, buf)\n    I16x8GeS => return simd_inst(53, buf)\n    I16x8GeU => return simd_inst(54, buf)\n    I32x4Eq => return simd_inst(55, buf)\n    I32x4Ne => return simd_inst(56, buf)\n    I32x4LtS => return simd_inst(57, buf)\n    I32x4LtU => return simd_inst(58, buf)\n    I32x4GtS => return simd_inst(59, buf)\n    I32x4GtU => return simd_inst(60, buf)\n    I32x4LeS => return simd_inst(61, buf)\n    I32x4LeU => return simd_inst(62, buf)\n    I32x4GeS => return simd_inst(63, buf)\n    I32x4GeU => return simd_inst(64, buf)\n    F32x4Eq => return simd_inst(65, buf)\n    F32x4Ne => return simd_inst(66, buf)\n    F32x4Lt => return simd_inst(67, buf)\n    F32x4Gt => return simd_inst(68, buf)\n    F32x4Le => return simd_inst(69, buf)\n    F32x4Ge => return simd_inst(70, buf)\n    F64x2Eq => return simd_inst(71, buf)\n    F64x2Ne => return simd_inst(72, buf)\n    F64x2Lt => return simd_inst(73, buf)\n    F64x2Gt => return simd_inst(74, buf)\n    F64x2Le => return simd_inst(75, buf)\n    F64x2Ge => return simd_inst(76, buf)\n    V128Not => return simd_inst(77, buf)\n    V128And => return simd_inst(78, buf)\n    V128Andnot => return simd_inst(79, buf)\n    V128Or => return simd_inst(80, buf)\n    V128Xor => return simd_inst(81, buf)\n    V128Bitselect => return simd_inst(82, buf)\n    V128AnyTrue => return simd_inst(83, buf)\n    V128Load8Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(84), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load16Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(85), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load32Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(86), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load64Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(87), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Store8Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(88), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Store16Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(89), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Store32Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(90), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Store64Lane(m, l) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(91), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(l, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load32Zero(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(92), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    V128Load64Zero(m) => {\n      buf.write_byte(0xFD)\n      if Encode::encode(@lib.U32(93), buf) is Err(t) {\n        return Err(t)\n      }\n      if Encode::encode(m, buf) is Err(t) {\n        return Err(t)\n      }\n    }\n    F32x4DemoteF64x2Zero => return simd_inst(94, buf)\n    F64x2PromoteLowF32x4 => return simd_inst(95, buf)\n    I8x16Abs => return simd_inst(96, buf)\n    I8x16Neg => return simd_inst(97, buf)\n    I8x16Popcnt => return simd_inst(98, buf)\n    I8x16AllTrue => return simd_inst(99, buf)\n    I8x16Bitmask => return simd_inst(100, buf)\n    I8x16NarrowI16x8S => return simd_inst(101, buf)\n    I8x16NarrowI16x8U => return simd_inst(102, buf)\n    F32x4Ceil => return simd_inst(103, buf)\n    F32x4Floor => return simd_inst(104, buf)\n    F32x4Trunc => return simd_inst(105, buf)\n    F32x4Nearest => return simd_inst(106, buf)\n    I8x16Shl => return simd_inst(107, buf)\n    I8x16ShrS => return simd_inst(108, buf)\n    I8x16ShrU => return simd_inst(109, buf)\n    I8x16Add => return simd_inst(110, buf)\n    I8x16AddSatS => return simd_inst(111, buf)\n    I8x16AddSatU => return simd_inst(112, buf)\n    I8x16Sub => return simd_inst(113, buf)\n    I8x16SubSatS => return simd_inst(114, buf)\n    I8x16SubSatU => return simd_inst(115, buf)\n    F64x2Ceil => return simd_inst(116, buf)\n    F64x2Floor => return simd_inst(117, buf)\n    I8x16MinS => return simd_inst(118, buf)\n    I8x16MinU => return simd_inst(119, buf)\n    I8x16MaxS => return simd_inst(120, buf)\n    I8x16MaxU => return simd_inst(121, buf)\n    F64x2Trunc => return simd_inst(122, buf)\n    I8x16AvgrU => return simd_inst(123, buf)\n    I16x8ExtaddPairwiseI8x16S => return simd_inst(124, buf)\n    I16x8ExtaddPairwiseI8x16U => return simd_inst(125, buf)\n    I32x4ExtaddPairwiseI16x8S => return simd_inst(126, buf)\n    I32x4ExtaddPairwiseI16x8U => return simd_inst(127, buf)\n    I16x8Abs => return simd_inst(128, buf)\n    I16x8Neg => return simd_inst(129, buf)\n    I16x8Q15mulrSatS => return simd_inst(130, buf)\n    I16x8AllTrue => return simd_inst(131, buf)\n    I16x8Bitmask => return simd_inst(132, buf)\n    I16x8NarrowI32x4S => return simd_inst(133, buf)\n    I16x8NarrowI32x4U => return simd_inst(134, buf)\n    I16x8ExtendLowI8x16S => return simd_inst(135, buf)\n    I16x8ExtendHighI8x16S => return simd_inst(136, buf)\n    I16x8ExtendLowI8x16U => return simd_inst(137, buf)\n    I16x8ExtendHighI8x16U => return simd_inst(138, buf)\n    I16x8Shl => return simd_inst(139, buf)\n    I16x8ShrS => return simd_inst(140, buf)\n    I16x8ShrU => return simd_inst(141, buf)\n    I16x8Add => return simd_inst(142, buf)\n    I16x8AddSatS => return simd_inst(143, buf)\n    I16x8AddSatU => return simd_inst(144, buf)\n    I16x8Sub => return simd_inst(145, buf)\n    I16x8SubSatS => return simd_inst(146, buf)\n    I16x8SubSatU => return simd_inst(147, buf)\n    F64x2Nearest => return simd_inst(148, buf)\n    I16x8Mul => return simd_inst(149, buf)\n    I16x8MinS => return simd_inst(150, buf)\n    I16x8MinU => return simd_inst(151, buf)\n    I16x8MaxS => return simd_inst(152, buf)\n    I16x8MaxU => return simd_inst(153, buf)\n    I16x8AvgrU => return simd_inst(155, buf)\n    I16x8ExtmulLowI8x16S => return simd_inst(156, buf)\n    I16x8ExtmulHighI8x16S => return simd_inst(157, buf)\n    I16x8ExtmulLowI8x16U => return simd_inst(158, buf)\n    I16x8ExtmulHighI8x16U => return simd_inst(159, buf)\n    I32x4Abs => return simd_inst(160, buf)\n    I32x4Neg => return simd_inst(161, buf)\n    I32x4AllTrue => return simd_inst(163, buf)\n    I32x4Bitmask => return simd_inst(164, buf)\n    I32x4ExtendLowI16x8S => return simd_inst(167, buf)\n    I32x4ExtendHighI16x8S => return simd_inst(168, buf)\n    I32x4ExtendLowI16x8U => return simd_inst(169, buf)\n    I32x4ExtendHighI16x8U => return simd_inst(170, buf)\n    I32x4Shl => return simd_inst(171, buf)\n    I32x4ShrS => return simd_inst(172, buf)\n    I32x4ShrU => return simd_inst(173, buf)\n    I32x4Add => return simd_inst(174, buf)\n    I32x4Sub => return simd_inst(177, buf)\n    I32x4Mul => return simd_inst(181, buf)\n    I32x4MinS => return simd_inst(182, buf)\n    I32x4MinU => return simd_inst(183, buf)\n    I32x4MaxS => return simd_inst(184, buf)\n    I32x4MaxU => return simd_inst(185, buf)\n    I32x4DotI16x8S => return simd_inst(186, buf)\n    I32x4ExtmulLowI16x8S => return simd_inst(188, buf)\n    I32x4ExtmulHighI16x8S => return simd_inst(189, buf)\n    I32x4ExtmulLowI16x8U => return simd_inst(190, buf)\n    I32x4ExtmulHighI16x8U => return simd_inst(191, buf)\n    I64x2Abs => return simd_inst(192, buf)\n    I64x2Neg => return simd_inst(193, buf)\n    I64x2AllTrue => return simd_inst(195, buf)\n    I64x2Bitmask => return simd_inst(196, buf)\n    I64x2ExtendLowI32x4S => return simd_inst(199, buf)\n    I64x2ExtendHighI32x4S => return simd_inst(200, buf)\n    I64x2ExtendLowI32x4U => return simd_inst(201, buf)\n    I64x2ExtendHighI32x4U => return simd_inst(202, buf)\n    I64x2Shl => return simd_inst(203, buf)\n    I64x2ShrS => return simd_inst(204, buf)\n    I64x2ShrU => return simd_inst(205, buf)\n    I64x2Add => return simd_inst(206, buf)\n    I64x2Sub => return simd_inst(209, buf)\n    I64x2Mul => return simd_inst(213, buf)\n    I64x2Eq => return simd_inst(214, buf)\n    I64x2Ne => return simd_inst(215, buf)\n    I64x2LtS => return simd_inst(216, buf)\n    I64x2GtS => return simd_inst(217, buf)\n    I64x2LeS => return simd_inst(218, buf)\n    I64x2GeS => return simd_inst(219, buf)\n    I64x2ExtmulLowI32x4S => return simd_inst(220, buf)\n    I64x2ExtmulHighI32x4S => return simd_inst(221, buf)\n    I64x2ExtmulLowI32x4U => return simd_inst(222, buf)\n    I64x2ExtmulHighI32x4U => return simd_inst(223, buf)\n    F32x4Abs => return simd_inst(224, buf)\n    F32x4Neg => return simd_inst(225, buf)\n    F32x4Sqrt => return simd_inst(227, buf)\n    F32x4Add => return simd_inst(228, buf)\n    F32x4Sub => return simd_inst(229, buf)\n    F32x4Mul => return simd_inst(230, buf)\n    F32x4Div => return simd_inst(231, buf)\n    F32x4Min => return simd_inst(232, buf)\n    F32x4Max => return simd_inst(233, buf)\n    F32x4Pmin => return simd_inst(234, buf)\n    F32x4Pmax => return simd_inst(235, buf)\n    F64x2Abs => return simd_inst(236, buf)\n    F64x2Neg => return simd_inst(237, buf)\n    F64x2Sqrt => return simd_inst(239, buf)\n    F64x2Add => return simd_inst(240, buf)\n    F64x2Sub => return simd_inst(241, buf)\n    F64x2Mul => return simd_inst(242, buf)\n    F64x2Div => return simd_inst(243, buf)\n    F64x2Min => return simd_inst(244, buf)\n    F64x2Max => return simd_inst(245, buf)\n    F64x2Pmin => return simd_inst(246, buf)\n    F64x2Pmax => return simd_inst(247, buf)\n    I32x4TruncSatF32x4S => return simd_inst(248, buf)\n    I32x4TruncSatF32x4U => return simd_inst(249, buf)\n    F32x4ConvertI32x4S => return simd_inst(250, buf)\n    F32x4ConvertI32x4U => return simd_inst(251, buf)\n    I32x4TruncSatF64x2SZero => return simd_inst(252, buf)\n    I32x4TruncSatF64x2UZero => return simd_inst(253, buf)\n    F64x2ConvertLowI32x4S => return simd_inst(254, buf)\n    F64x2ConvertLowI32x4U => return simd_inst(255, buf)\n    I8x16RelaxedSwizzle => return simd_inst(256, buf)\n    I32x4RelaxedTruncF32x4S => return simd_inst(257, buf)\n    I32x4RelaxedTruncF32x4U => return simd_inst(258, buf)\n    I32x4RelaxedTruncZeroF64x2S => return simd_inst(259, buf)\n    I32x4RelaxedTruncZeroF64x2U => return simd_inst(260, buf)\n    F32x4RelaxedMadd => return simd_inst(261, buf)\n    F32x4RelaxedNmadd => return simd_inst(262, buf)\n    F64x2RelaxedMadd => return simd_inst(263, buf)\n    F64x2RelaxedNmadd => return simd_inst(264, buf)\n    I8x16RelaxedLaneselect => return simd_inst(265, buf)\n    I16x8RelaxedLaneselect => return simd_inst(266, buf)\n    I32x4RelaxedLaneselect => return simd_inst(267, buf)\n    I64x2RelaxedLaneselect => return simd_inst(268, buf)\n    F32x4RelaxedMin => return simd_inst(269, buf)\n    F32x4RelaxedMax => return simd_inst(270, buf)\n    F64x2RelaxedMin => return simd_inst(271, buf)\n    F64x2RelaxedMax => return simd_inst(272, buf)\n    I16x8RelaxedQ15mulrS => return simd_inst(273, buf)\n    I16x8RelaxedDotI8x16I7x16S => return simd_inst(274, buf)\n    I32x4RelaxedDotI8x16I7x16AddS => return simd_inst(275, buf)\n  }\n  Ok(())\n}\n\n///|\npub impl[T : Encode] Encode for Array[T] with encode(val, buf) {\n  if Encode::encode(@lib.U32(val.length().reinterpret_as_uint()), buf) is Err(t) {\n    return Err(t)\n  }\n  for v in val {\n    if Encode::encode(v, buf) is Err(t) {\n      return Err(t)\n    }\n  }\n  Ok(())\n}\n\n///|\npub impl[T : Decode] Decode for Array[T] with decode(bytes, i) {\n  match Decode::decode(bytes, i) {\n    Err(t) => Err(t)\n    Ok((@lib.U32(count), i)) =>\n      loop (count, [], i) {\n        (0, result, i) => break Ok((result, i))\n        (n, result, i) =>\n          match T::decode(bytes, i) {\n            Ok((t, i)) => {\n              result.push(t)\n              continue (n - 1, result, i)\n            }\n            Err(t) => break Err(t)\n          }\n      }\n  }\n}\n\n// For tests:\n\n///|\npriv suberror EncodingFailed\n\n///|\npriv suberror DecodingFailed\n\n///|\nfn[T : Encode + Decode + Eq + Show] roundtrip(x : T) -> Unit raise {\n  let buf = @buffer.new()\n  match Encode::encode(x, buf) {\n    Ok(_) => ()\n    Err(t) => {\n      println((\"Encoding failed\", t))\n      raise EncodingFailed\n    }\n  }\n  let bytes = buf.to_bytes()\n  let (y, i2) = match Decode::decode(bytes, 0) {\n    Ok(t) => t\n    Err(t) => {\n      println((\"Decoding failed\", t, \"for\", x))\n      println((\"Bytes\", bytes.to_array()))\n      raise DecodingFailed\n    }\n  }\n  if bytes.length() != i2 {\n    println((\"Failed: Byte Length Mismatch\", bytes.length(), i2))\n  }\n  if y != x {\n    println((\"Failed\", x))\n    println((\"Byte Representation\", bytes.to_array()))\n    let compare = @buffer.new()\n    match Encode::encode(y, compare) {\n      Ok(_) =>\n        println((\"Decoded byte representation\", compare.to_bytes().to_array()))\n      Err(_) => println(\"Could not re-encode actual value\")\n    }\n    println((\"Decoded\", y))\n  }\n  assert_eq(i2, bytes.length())\n  assert_eq(y, x)\n}\n\n///|\nfn[T : Encode + Decode + Eq + Show + @quickcheck.Arbitrary] roundtrip_arbitrary(\n  count : Int,\n) -> Array[T] raise {\n  let st = @quickcheck/splitmix.new()\n  let a = Array::new(capacity=count)\n  loop count {\n    0 => break a\n    n => {\n      let val = T::arbitrary(n, st)\n      roundtrip(val)\n      a.push(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"uleb roundtrip u33\" {\n  let vals : Array[UInt64] = [0, 1, 127, 128, 129, 0xffff, 0xffffffff]\n  for v in vals {\n    let buf = @buffer.new()\n    encode_unsigned(v, buf, 33).unwrap()\n    let bytes = buf.to_bytes()\n    let (v2, i2) = decode_unsigned(bytes, 0, 33).unwrap()\n    assert_eq(v2, v)\n    assert_eq(i2, bytes.length())\n  }\n}\n\n///|\ntest \"sleb roundtrip s33 boundary\" {\n  let vals : Array[Int64] = [\n    0, 1, -1, 63, -64, 64, -65, 2147483647, -2147483648,\n  ]\n  for v in vals {\n    let buf = @buffer.new()\n    encode_signed(v, buf, 33).unwrap()\n    let bytes = buf.to_bytes()\n    let (v2, i2) = decode_signed(bytes, 0, 33).unwrap()\n    assert_eq(v2, v)\n    assert_eq(i2, bytes.length())\n  }\n}\n\n///|\ntest \"uleb u33 rejects terminal unused bits\" {\n  let bytes : Bytes = [0x80, 0x80, 0x80, 0x80, 0x20]\n  match decode_unsigned(bytes, 0, 33) {\n    Ok(_) => fail(\"expected error\")\n    Err(_) => ()\n  }\n}\n\n///|\ntest \"sleb s33 accepts 0x3f\" {\n  match decode_signed(b\"\\x3f\", 0, 33) {\n    Ok((value, _)) => assert_eq(value, 63L)\n    Err(e) => fail(\"unexpected error: \\{e}\")\n  }\n}\n\n///|\ntest \"uleb u33 rejects too many bytes\" {\n  let bytes : Bytes = [0x80, 0x80, 0x80, 0x80, 0x80, 0x00]\n  match decode_unsigned(bytes, 0, 33) {\n    Ok(_) => fail(\"expected error\")\n    Err(_) => ()\n  }\n}\n\n///|\ntest \"uleb allows trailing zeros within max bytes\" {\n  let bytes : Bytes = [0x83, 0x00]\n  let (v, i) = decode_unsigned(bytes, 0, 8).unwrap()\n  assert_eq(v, 3)\n  assert_eq(i, 2)\n}\n\n///|\ntest \"uleb u33 boundaries roundtrip\" {\n  let vals : Array[UInt64] = [\n    0UL,\n    1UL,\n    31UL,\n    32UL,\n    127UL,\n    128UL,\n    0xffffffffUL,\n    (1UL << 33) - 1UL,\n  ]\n  for v in vals {\n    let buf = @buffer.new()\n    encode_unsigned(v, buf, 33).unwrap()\n    let bytes = buf.to_bytes()\n    let (v2, i2) = decode_unsigned(bytes, 0, 33).unwrap()\n    assert_eq(v2, v)\n    assert_eq(i2, bytes.length())\n  }\n}\n\n///|\ntest \"uleb allows trailing zeros within bound\" {\n  let (v, i) = decode_unsigned(b\"\\x83\\x00\", 0, 8).unwrap()\n  assert_eq(v, 3UL)\n  assert_eq(i, 2)\n}\n\n///|\ntest \"sleb s33 boundaries roundtrip\" {\n  let min = -1L << 32\n  let max = (1L << 32) - 1L\n  let vals : Array[Int64] = [\n    min,\n    min + 1,\n    -1,\n    0,\n    1,\n    31,\n    32,\n    63,\n    64,\n    max - 1,\n    max,\n  ]\n  for v in vals {\n    let buf = @buffer.new()\n    encode_signed(v, buf, 33).unwrap()\n    let bytes = buf.to_bytes()\n    let (v2, i2) = decode_signed(bytes, 0, 33).unwrap()\n    assert_eq(v2, v)\n    assert_eq(i2, bytes.length())\n  }\n}\n\n///|\ntest \"sleb s33 rejects too many bytes\" {\n  match decode_signed(b\"\\x80\\x80\\x80\\x80\\x80\\x00\", 0, 33) {\n    Ok(_) => fail(\"expected error\")\n    Err(_) => ()\n  }\n}\n\n///|\ntest \"sleb allows extra sign extension within bound\" {\n  let (v, i) = decode_signed(b\"\\xff\\x7f\", 0, 8).unwrap()\n  assert_eq(v, -1)\n  assert_eq(i, 2)\n}\n\n///|\ntest \"uleb encoder never exceeds ceil(nbits/7)\" {\n  let buf = @buffer.new()\n  encode_unsigned((1UL << 33) - 1UL, buf, 33).unwrap()\n  assert_true(buf.to_bytes().length() <= max_leb_bytes(33))\n}\n\n///|\ntest \"numtype valtype\" {\n  roundtrip(@lib.F32NumType)\n  roundtrip(@lib.F64NumType)\n  roundtrip(@lib.I32NumType)\n  roundtrip(@lib.I64NumType)\n}\n\n///|\ntest \"Heap Types\" {\n  roundtrip(@lib.AbsHeapTypeHeapType(ExnAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(ArrayAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(StructAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(I31AbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(EqAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(AnyAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(ExternAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(FuncAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(NoneAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(NoExternAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(NoFuncAbsHeapType))\n  roundtrip(@lib.AbsHeapTypeHeapType(NoExnAbsHeapType))\n  roundtrip(@lib.HeapType(TypeIdx(23)))\n}\n\n///|\ntest \"Type Indexes\" {\n  let _ : Array[TypeIdx] = roundtrip_arbitrary(50)\n\n}\n\n///|\ntest \"Ref Types\" {\n  let _ : Array[RefType] = roundtrip_arbitrary(20)\n\n}\n\n///|\ntest \"Comp Types\" {\n  roundtrip(\n    @lib.ArrayCompType(\n      FieldType(ValTypeStorageType(NumTypeValType(I32NumType)), Var),\n    ),\n  )\n  roundtrip(\n    @lib.StructCompType([\n      FieldType(\n        ValTypeStorageType(\n          RefTypeValType(\n            HeapTypeRefType(true, AbsHeapTypeHeapType(I31AbsHeapType)),\n          ),\n        ),\n        Var,\n      ),\n    ]),\n  )\n  roundtrip(\n    @lib.FuncCompType([i32_valtype(), i64_valtype()], [\n      i64_valtype(),\n      i32_valtype(),\n    ]),\n  )\n  let _ : Array[CompType] = roundtrip_arbitrary(30)\n\n}\n\n///|\ntest \"Storage Type\" {\n  let _ : Array[StorageType] = roundtrip_arbitrary(30)\n\n}\n\n///|\ntest \"Packed Type\" {\n  roundtrip(@lib.I8PackType)\n  roundtrip(@lib.I16PackType)\n}\n\n///|\ntest \"SubTypes\" {\n  roundtrip(\n    @lib.CompTypeSubType(\n      ArrayCompType(FieldType(ValTypeStorageType(i32_valtype()), Var)),\n    ),\n  )\n  roundtrip(\n    @lib.SubType(\n      false,\n      [TypeIdx(0), TypeIdx(2), TypeIdx(4)],\n      FuncCompType([], []),\n    ),\n  )\n}\n\n///|\ntest \"SubTypes arbitrary\" {\n  let _ : Array[SubType] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"RecTypes arbitrary\" {\n  let _ : Array[RecType] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"TagTypes arbitrary\" {\n  let _ : Array[TagType] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"MemTypes arbitrary\" {\n  let _ : Array[MemType] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"TableTypes arbitrary\" {\n  let _ : Array[TableType] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"ExternTypes arbitrary\" {\n  let _ : Array[TableType] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"MemArg arbitrary\" {\n  let _ : Array[MemArg] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"LaneIdx\" {\n  let _ : Array[LaneIdx] = roundtrip_arbitrary(100)\n\n}\n\n///|\ntest \"Float specific edge case?\" {\n  roundtrip(@lib.F32Const(F32(0.011397957801818848)))\n}\n\n///|\ntest \"Floats arbitrary\" {\n  let _ : Array[F32] = roundtrip_arbitrary(10000)\n\n}\n\n///|\ntest \"Doubles arbitrary\" {\n  let _ : Array[F64] = roundtrip_arbitrary(10000)\n\n}\n\n///|\ntest \"Signed integers\" {\n  let _ : Array[I64] = roundtrip_arbitrary(100000)\n\n}\n\n///|\ntest \"Block Types\" {\n  let _ : Array[BlockType] = roundtrip_arbitrary(1000)\n\n}\n\n///|\ntest \"Instructions arbitrary\" {\n  let st = @quickcheck/splitmix.new()\n  loop 1000000 {\n    0 => break ()\n    n => {\n      let val = Instruction::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary CustomSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = CustomSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary TypeSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = TypeSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary ImportSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = ImportSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary FuncSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = FuncSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary TableSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = TableSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary MemSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = MemSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary GlobalSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = GlobalSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary ExportSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = ExportSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary StartSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = StartSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary Elem\" {\n  let st = @quickcheck/splitmix.new()\n  loop 1000 {\n    0 => break ()\n    n => {\n      let val = Elem::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary ElemSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = ElemSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary Func\" {\n  let st = @quickcheck/splitmix.new()\n  loop 1000 {\n    0 => break ()\n    n => {\n      let val = Func::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary CodeSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = CodeSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary Data\" {\n  let st = @quickcheck/splitmix.new()\n  loop 1000 {\n    0 => break ()\n    n => {\n      let val = Data::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary DataSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = DataSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary DataCntSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = DataCntSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary TagSec\" {\n  let st = @quickcheck/splitmix.new()\n  loop 100 {\n    0 => break ()\n    n => {\n      let val = TagSec::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Arbitrary Module\" {\n  let st = @quickcheck/splitmix.new()\n  loop 1000 {\n    0 => break ()\n    n => {\n      let val = Module::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n\n///|\ntest \"Names\" {\n  let st = @quickcheck/splitmix.new()\n  loop 1000 {\n    0 => break ()\n    n => {\n      let val = Name::arbitrary(n, st)\n      roundtrip(val)\n      continue n - 1\n    }\n  }\n}\n","///|\npub impl Eq for Module with equal(l, r) {\n  let l_custom = l.0\n  let r_custom = r.0\n  if l_custom.length() != r_custom.length() {\n    return false\n  }\n  for lc in l_custom {\n    if !r_custom.contains(lc) {\n      return false\n    }\n  }\n  for rc in r_custom {\n    if !l_custom.contains(rc) {\n      return false\n    }\n  }\n  l.1 == r.1 &&\n  l.2 == r.2 &&\n  l.3 == r.3 &&\n  l.4 == r.4 &&\n  l.5 == r.5 &&\n  l.6 == r.6 &&\n  l.7 == r.7 &&\n  l.8 == r.8 &&\n  l.9 == r.9 &&\n  l.10 == r.10 &&\n  l.11 == r.11 &&\n  l.12 == r.12 &&\n  l.13 == r.13\n}\n\n///|\npub impl Eq for RecType with equal(l, r) {\n  match (l, r) {\n    (SingleRecType(stl), GroupRecType([str])) => stl == str\n    (GroupRecType([stl]), SingleRecType(str)) => stl == str\n    (SingleRecType(stl), SingleRecType(str)) => stl == str\n    (GroupRecType(stl), GroupRecType(str)) => stl == str\n    _ => false\n  }\n}\n\n///|\npub impl Eq for RefType with equal(l, r) {\n  match (l, r) {\n    (HeapTypeRefType(l0, l1), HeapTypeRefType(r0, r1)) => l0 == r0 && l1 == r1\n    (AbsHeapTypeRefType(l0), AbsHeapTypeRefType(r0)) => l0 == r0\n    (AbsHeapTypeRefType(l0), HeapTypeRefType(true, AbsHeapTypeHeapType(r0))) =>\n      l0 == r0\n    (HeapTypeRefType(true, AbsHeapTypeHeapType(l0)), AbsHeapTypeRefType(r0)) =>\n      l0 == r0\n    _ => false\n  }\n}\n\n///|\npub impl Eq for MemArg with equal(l, r) {\n  l.0 == r.0 &&\n  l.1.unwrap_or(MemIdx(0)) == r.1.unwrap_or(MemIdx(0)) &&\n  l.2 == r.2\n}\n\n///|\ntest \"RecType equality edge cases\" {\n  let st = CompTypeSubType(FuncCompType([], []))\n\n  // SingleRecType should equal GroupRecType with single element\n  assert_eq(SingleRecType(st), GroupRecType([st]))\n  assert_eq(GroupRecType([st]), SingleRecType(st))\n\n  // But different subtypes should not be equal\n  let st2 = CompTypeSubType(FuncCompType([NumTypeValType(I32NumType)], []))\n  assert_not_eq(SingleRecType(st), SingleRecType(st2))\n  assert_not_eq(SingleRecType(st), GroupRecType([st2]))\n\n  // Multiple elements should not equal single\n  assert_not_eq(GroupRecType([st, st]), SingleRecType(st))\n}\n\n///|\ntest \"RefType equality edge cases\" {\n  // AbsHeapTypeRefType should equal HeapTypeRefType with nullable + AbsHeapTypeHeapType\n  assert_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType)),\n  )\n  assert_eq(\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)),\n    AbsHeapTypeRefType(ExternAbsHeapType),\n  )\n\n  // Non-nullable should NOT equal AbsHeapTypeRefType\n  assert_not_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    HeapTypeRefType(false, AbsHeapTypeHeapType(FuncAbsHeapType)),\n  )\n\n  // Different heap types should not be equal\n  assert_not_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    AbsHeapTypeRefType(ExternAbsHeapType),\n  )\n  assert_not_eq(\n    AbsHeapTypeRefType(FuncAbsHeapType),\n    HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)),\n  )\n}\n\n///|\ntest \"MemArg equality edge cases\" {\n  // None memidx should equal Some(MemIdx(0))\n  assert_eq(\n    MemArg(U32(0), None, U64(0)),\n    MemArg(U32(0), Some(MemIdx(0)), U64(0)),\n  )\n  assert_eq(\n    MemArg(U32(4), None, U64(8)),\n    MemArg(U32(4), Some(MemIdx(0)), U64(8)),\n  )\n\n  // But Some(MemIdx(1)) should NOT equal None\n  assert_not_eq(\n    MemArg(U32(0), None, U64(0)),\n    MemArg(U32(0), Some(MemIdx(1)), U64(0)),\n  )\n\n  // Different align/offset should not be equal\n  assert_not_eq(MemArg(U32(0), None, U64(0)), MemArg(U32(1), None, U64(0)))\n  assert_not_eq(MemArg(U32(0), None, U64(0)), MemArg(U32(0), None, U64(1)))\n}\n\n///|\ntest \"HeapType equality - verify transformer changes are detected\" {\n  // These should NOT be equal - this is what HeapTypeSwap produces\n  let before : HeapType = AbsHeapTypeHeapType(FuncAbsHeapType)\n  let after : HeapType = AbsHeapTypeHeapType(ExternAbsHeapType)\n  assert_not_eq(before, after)\n\n  // TypeIdx changes should be detected\n  let idx_before : HeapType = HeapType(TypeIdx(0))\n  let idx_after : HeapType = HeapType(TypeIdx(1000))\n  assert_not_eq(idx_before, idx_after)\n}\n\n///|\ntest \"RefType with transformed HeapType should not be equal\" {\n  // The transformer changes HeapType inside RefType\n  let before = HeapTypeRefType(true, AbsHeapTypeHeapType(FuncAbsHeapType))\n  let after = HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType))\n  assert_not_eq(before, after)\n\n  // But AbsHeapTypeRefType doesn't contain HeapType - verify these are different\n  let abs_func = AbsHeapTypeRefType(FuncAbsHeapType)\n  let abs_extern = AbsHeapTypeRefType(ExternAbsHeapType)\n  assert_not_eq(abs_func, abs_extern)\n}\n","///|\npub impl Show for S33 with output(self, logger) {\n  let S33(t) = self\n  logger.write_string(\"S33(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for I32 with output(self, logger) {\n  let I32(t) = self\n  logger.write_string(\"I32(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for I64 with output(self, logger) {\n  let I64(t) = self\n  logger.write_string(\"I64(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for F32 with output(self, logger) {\n  let F32(t) = self\n  logger.write_string(\"F32(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for F64 with output(self, logger) {\n  let F64(t) = self\n  logger.write_string(\"F64(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for U32 with output(self, logger) {\n  let U32(t) = self\n  logger.write_string(\"U32(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for U64 with output(self, logger) {\n  let U64(t) = self\n  logger.write_string(\"U64(\")\n  t.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for NumType with output(self, logger) {\n  match self {\n    F32NumType => logger.write_string(\"(NumType F32)\")\n    F64NumType => logger.write_string(\"(NumType F64)\")\n    I32NumType => logger.write_string(\"(NumType I32)\")\n    I64NumType => logger.write_string(\"(NumType I64)\")\n  }\n}\n\n///|\npub impl Show for AbsHeapType with output(self, logger) {\n  match self {\n    ExnAbsHeapType => logger.write_string(\"(AbsHeapType Exn)\")\n    ArrayAbsHeapType => logger.write_string(\"(AbsHeapType Array)\")\n    StructAbsHeapType => logger.write_string(\"(AbsHeapType Struct)\")\n    I31AbsHeapType => logger.write_string(\"(AbsHeapType I31)\")\n    EqAbsHeapType => logger.write_string(\"(AbsHeapType Eq)\")\n    AnyAbsHeapType => logger.write_string(\"(AbsHeapType Any)\")\n    ExternAbsHeapType => logger.write_string(\"(AbsHeapType Extern)\")\n    FuncAbsHeapType => logger.write_string(\"(AbsHeapType Func)\")\n    NoneAbsHeapType => logger.write_string(\"(AbsHeapType None)\")\n    NoExternAbsHeapType => logger.write_string(\"(AbsHeapType NoExtern)\")\n    NoFuncAbsHeapType => logger.write_string(\"(AbsHeapType NoFunc)\")\n    NoExnAbsHeapType => logger.write_string(\"(AbsHeapType NoExn)\")\n  }\n}\n\n///|\npub impl Show for HeapType with output(self, logger) {\n  match self {\n    AbsHeapTypeHeapType(ht) => {\n      logger.write_string(\"(HeapType \")\n      ht.output(logger)\n      logger.write_char(')')\n    }\n    HeapType(TypeIdx(t)) => {\n      logger.write_string(\"(HeapType Idx \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    HeapType(RecIdx(t)) => {\n      logger.write_string(\"(HeapType Rec \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    DefTypeHeapType(d) => {\n      logger.write_string(\"(HeapType \")\n      d.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for DefType with output(self, logger) {\n  logger.write_string(\"(DefType \")\n  self.0.output(logger)\n  logger.write_char(' ')\n  self.1.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for RefType with output(self, logger) {\n  match self {\n    HeapTypeRefType(n, ht) => {\n      logger.write_string(\"(RefType \")\n      if !n {\n        logger.write_string(\"Not \")\n      }\n      logger.write_string(\"Null \")\n      ht.output(logger)\n      logger.write_char(')')\n    }\n    AbsHeapTypeRefType(aht) => {\n      logger.write_string(\"(RefType Null \")\n      aht.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for ValType with output(self, logger) {\n  match self {\n    VecTypeValType => logger.write_string(\"(V128)\")\n    NumTypeValType(nt) => nt.output(logger)\n    RefTypeValType(rt) => rt.output(logger)\n    BotValType => logger.write_string(\"(Bot)\")\n  }\n}\n\n///|\npub impl Show for PackType with output(self, logger) {\n  match self {\n    I16PackType => logger.write_string(\"(I16)\")\n    I8PackType => logger.write_string(\"(I8)\")\n  }\n}\n\n///|\npub impl Show for StorageType with output(self, logger) {\n  match self {\n    ValTypeStorageType(vt) => vt.output(logger)\n    PackTypeStorageType(pt) => pt.output(logger)\n  }\n}\n\n///|\npub impl Show for FieldType with output(self, logger) {\n  let FieldType(st, m) = self\n  logger.write_string(\"(Field \")\n  m.output(logger)\n  logger.write_char(' ')\n  st.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Mut with output(self, logger) {\n  match self {\n    Var => logger.write_string(\"Mut\")\n    Const => logger.write_string(\"Const\")\n  }\n}\n\n///|\npub impl Show for TypeIdx with output(self, logger) {\n  match self {\n    TypeIdx(val) => {\n      logger.write_string(\"(Type \")\n      val.output(logger)\n      logger.write_char(')')\n    }\n    RecIdx(i) => {\n      logger.write_string(\"(Rec \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for FuncIdx with output(self, logger) {\n  let FuncIdx(val) = self\n  logger.write_string(\"(Func \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for TableIdx with output(self, logger) {\n  let TableIdx(val) = self\n  logger.write_string(\"(Table \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for MemIdx with output(self, logger) {\n  let MemIdx(val) = self\n  logger.write_string(\"(Mem \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for GlobalIdx with output(self, logger) {\n  let GlobalIdx(val) = self\n  logger.write_string(\"(Global \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for TagIdx with output(self, logger) {\n  let TagIdx(val) = self\n  logger.write_string(\"(Tag \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for ElemIdx with output(self, logger) {\n  let ElemIdx(val) = self\n  logger.write_string(\"(Elem \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for DataIdx with output(self, logger) {\n  let DataIdx(val) = self\n  logger.write_string(\"(Data \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for LocalIdx with output(self, logger) {\n  let LocalIdx(val) = self\n  logger.write_string(\"(Local \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for LabelIdx with output(self, logger) {\n  let LabelIdx(val) = self\n  logger.write_string(\"(Label \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for LaneIdx with output(self, logger) {\n  let LaneIdx(val) = self\n  logger.write_string(\"(Lane \")\n  val.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for CompType with output(self, logger) {\n  match self {\n    StructCompType(st) => {\n      logger.write_string(\"(Struct \")\n      for f in st {\n        f.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n    ArrayCompType(at) => {\n      logger.write_string(\"(Array \")\n      at.output(logger)\n      logger.write_char(')')\n    }\n    FuncCompType(p, r) => {\n      logger.write_string(\"(Func (Props \")\n      match p {\n        [] => logger.write_string(\"(Void)\")\n        _ =>\n          for pm in p {\n            pm.output(logger)\n            logger.write_char(' ')\n          }\n      }\n      logger.write_string(\") (Ret \")\n      match r {\n        [] => logger.write_string(\"(Void)\")\n        _ =>\n          for pm in r {\n            pm.output(logger)\n            logger.write_char(' ')\n          }\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for SubType with output(self, logger) {\n  match self {\n    SubType(f, sts, ct) => {\n      logger.write_string(\"(Sub \")\n      if f {\n        logger.write_string(\"Final \")\n      }\n      for st in sts {\n        st.output(logger)\n        logger.write_char(' ')\n      }\n      ct.output(logger)\n      logger.write_char(')')\n    }\n    CompTypeSubType(ct) => {\n      logger.write_string(\"(Sub Final \")\n      ct.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for RecType with output(self, logger) {\n  match self {\n    SingleRecType(st) => {\n      logger.write_string(\"(Rec \")\n      st.output(logger)\n      logger.write_char(')')\n    }\n    GroupRecType(sts) => {\n      logger.write_string(\"(Rec \")\n      for st in sts {\n        st.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for Limits with output(self, logger) {\n  match self {\n    I32Limits(min, max) => {\n      logger.write_string(\"(Lim I32 \")\n      min.output(logger)\n      if max is Some(max) {\n        logger.write_char(' ')\n        max.output(logger)\n      }\n      logger.write_char(')')\n    }\n    I64Limits(min, max) => {\n      logger.write_string(\"(Lim I64 \")\n      min.output(logger)\n      if max is Some(max) {\n        logger.write_char(' ')\n        max.output(logger)\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for TagType with output(self, logger) {\n  let TagType(t) = self\n  t.output(logger)\n}\n\n///|\npub impl Show for GlobalType with output(self, logger) {\n  let GlobalType(vt, m) = self\n  logger.write_string(\"(GlobalType \")\n  if m {\n    logger.write_string(\"Mut \")\n  }\n  vt.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for MemType with output(self, logger) {\n  let MemType(l) = self\n  l.output(logger)\n}\n\n///|\npub impl Show for TableType with output(self, logger) {\n  let TableType(rt, l) = self\n  logger.write_string(\"(TableType \")\n  rt.output(logger)\n  logger.write_char(' ')\n  l.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for ExternType with output(self, logger) {\n  match self {\n    GlobalExternType(gt) => gt.output(logger)\n    MemExternType(mt) => mt.output(logger)\n    TableExternType(tt) => tt.output(logger)\n    FuncExternType(t) => t.output(logger)\n    TagExternType(t) => t.output(logger)\n  }\n}\n\n///|\npub impl Show for ExternIdx with output(self, logger) {\n  match self {\n    GlobalExternIdx(g) => g.output(logger)\n    MemExternIdx(m) => m.output(logger)\n    TableExternIdx(t) => t.output(logger)\n    FuncExternIdx(f) => f.output(logger)\n    TagExternIdx(t) => t.output(logger)\n  }\n}\n\n///|\npub impl Show for ElemMode with output(self, logger) {\n  match self {\n    Active(t, e) => {\n      logger.write_string(\"(Active \")\n      t.output(logger)\n      logger.write_char(' ')\n      e.output(logger)\n      logger.write_char(')')\n    }\n    Passive => logger.write_string(\"Passive\")\n    Declarative => logger.write_string(\"Declarative\")\n  }\n}\n\n///|\npub impl Show for ElemKind with output(self, logger) {\n  match self {\n    FuncExprsElemKind(exprs) => {\n      logger.write_string(\"(Funcs \")\n      for expr in exprs {\n        expr.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n    FuncsElemKind(idxs) => {\n      logger.write_string(\"(Funcs Indexes \")\n      for idx in idxs {\n        idx.output(logger)\n        logger.write_char(' ')\n      }\n      logger.write_char(')')\n    }\n    TypedExprsElemKind(rt, exprs) => {\n      logger.write_string(\"(Exprs \")\n      rt.output(logger)\n      logger.write_char(' ')\n      for expr in exprs {\n        expr.output(logger)\n      }\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for Elem with output(self, logger) {\n  let Elem(m, k) = self\n  logger.write_string(\"(Elem \")\n  m.output(logger)\n  logger.write_char(' ')\n  k.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Expr with output(self, logger) {\n  let Expr(insts) = self\n  for inst in insts {\n    inst.output(logger)\n  }\n  logger.write_string(\"(end)\")\n}\n\n///|\npub impl Show for Import with output(self, logger) {\n  let Import(ns, n, et) = self\n  logger.write_char('(')\n  ns.output(logger)\n  logger.write_char(' ')\n  n.output(logger)\n  logger.write_char(' ')\n  et.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Table with output(self, logger) {\n  let Table(tt, e) = self\n  logger.write_string(\"(Table \")\n  tt.output(logger)\n  if e is Some(e) {\n    logger.write_char(' ')\n    e.output(logger)\n  }\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Global with output(self, logger) {\n  let Global(gt, e) = self\n  logger.write_string(\"(Global \")\n  gt.output(logger)\n  logger.write_char(' ')\n  e.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Export with output(self, logger) {\n  let Export(n, idx) = self\n  logger.write_string(\"(Export \")\n  n.output(logger)\n  logger.write_char(' ')\n  idx.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Locals with output(self, logger) {\n  let Locals(i, vt) = self\n  loop i {\n    0 => break\n    n => {\n      vt.output(logger)\n      logger.write_char(' ')\n      continue n - 1\n    }\n  }\n}\n\n///|\npub impl Show for Func with output(self, logger) {\n  match self {\n    Func(ls, expr) => {\n      logger.write_string(\"(Func \")\n      ls.output(logger)\n      logger.write_char(' ')\n      expr.output(logger)\n      logger.write_char(')')\n    }\n    TFunc(ls, texpr) => {\n      logger.write_string(\"(Func \")\n      ls.output(logger)\n      logger.write_char(' ')\n      texpr.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for DataMode with output(self, logger) {\n  match self {\n    Active(m, e) => {\n      logger.write_string(\"(Active \")\n      m.output(logger)\n      logger.write_char(' ')\n      e.output(logger)\n      logger.write_char(')')\n    }\n    Passive => logger.write_string(\"Passive\")\n  }\n}\n\n///|\npub impl Show for Data with output(self, logger) {\n  let Data(dm, b) = self\n  logger.write_string(\"(Data \")\n  dm.output(logger)\n  logger.write_char(' ')\n  b.output(logger)\n  logger.write_char(')')\n}\n\n///|\npub impl Show for Name with output(self, logger) {\n  let Name(sv) = self\n  logger.write_char('\"')\n  sv.to_string().output(logger)\n  logger.write_char('\"')\n}\n\n///|\npub impl Show for BlockType with output(self, logger) {\n  match self {\n    ValTypeBlockType(vt) => vt.output(logger)\n    EmptyBlockType => logger.write_string(\"(Void)\")\n    TypeIdxBlockType(t) => t.output(logger)\n  }\n}\n\n///|\npub impl Show for Catch with output(self, logger) {\n  match self {\n    CatchAll(l) => {\n      logger.write_string(\"(catch_all \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    CatchRef(t, l) => {\n      logger.write_string(\"(catch_ref \")\n      t.output(logger)\n      logger.write_char(' ')\n      l.output(logger)\n      logger.write_char(')')\n    }\n    Catch(t, l) => {\n      logger.write_string(\"(catch \")\n      t.output(logger)\n      logger.write_char(' ')\n      l.output(logger)\n      logger.write_char(')')\n    }\n    CatchAllRef(l) => {\n      logger.write_string(\"(catch_all_ref \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n  }\n}\n\n///|\npub impl Show for MemArg with output(self, logger) {\n  let MemArg(a, m, o) = self\n  logger.write_string(\"align=\")\n  a.output(logger)\n  if m is Some(m) {\n    logger.write_string(\" mem=\")\n    m.output(logger)\n  }\n  logger.write_string(\" offset=\")\n  o.output(logger)\n}\n\n///|\npub impl Show for Instruction with output(self, logger) {\n  match self {\n    Unreachable => logger.write_string(\"unreachable\")\n    Nop => logger.write_string(\"nop\")\n    Block(bt, expr) => {\n      logger.write_string(\"(block \")\n      bt.output(logger)\n      logger.write_char(' ')\n      expr.output(logger)\n      logger.write_char(')')\n    }\n    Loop(bt, expr) => {\n      logger.write_string(\"(loop \")\n      bt.output(logger)\n      logger.write_char(' ')\n      expr.output(logger)\n      logger.write_char(')')\n    }\n    If(bt, i, e) => {\n      logger.write_string(\"(if \")\n      bt.output(logger)\n      logger.write_char(' ')\n      for n in i {\n        n.output(logger)\n        logger.write_char(' ')\n      }\n      if e is Some(e) {\n        logger.write_string(\"else \")\n        for n in e {\n          n.output(logger)\n          logger.write_char(' ')\n        }\n        logger.write_char(')')\n      }\n    }\n    Throw(t) => {\n      logger.write_string(\"(throw \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    ThrowRef => logger.write_string(\"throw_ref\")\n    Br(l) => {\n      logger.write_string(\"(br \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    BrIf(l) => {\n      logger.write_string(\"(br_if \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    BrTable(ls, l) => {\n      logger.write_string(\"(br_table \")\n      for n in ls {\n        n.output(logger)\n        logger.write_char(' ')\n      }\n      l.output(logger)\n      logger.write_char(')')\n    }\n    Return => logger.write_string(\"return\")\n    Call(f) => {\n      logger.write_string(\"(call \")\n      f.output(logger)\n      logger.write_char(')')\n    }\n    CallIndirect(ty, tbl) => {\n      logger.write_string(\"(call_indirect \")\n      ty.output(logger)\n      logger.write_char(' ')\n      tbl.output(logger)\n      logger.write_char(')')\n    }\n    ReturnCall(f) => {\n      logger.write_string(\"(return_call \")\n      f.output(logger)\n      logger.write_char(')')\n    }\n    ReturnCallIndirect(ty, tbl) => {\n      logger.write_string(\"(return_call_indirect \")\n      ty.output(logger)\n      logger.write_char(' ')\n      tbl.output(logger)\n      logger.write_char(')')\n    }\n    CallRef(t) => {\n      logger.write_string(\"(call_ref \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    ReturnCallRef(t) => {\n      logger.write_string(\"(return_call_ref \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    Drop => logger.write_string(\"drop\")\n    Select(None) => logger.write_string(\"select\")\n    Select(Some(vts)) => {\n      logger.write_string(\"(select\")\n      for vt in vts {\n        logger.write_char(' ')\n        vt.output(logger)\n      }\n      logger.write_char(')')\n    }\n    TryTable(bt, c, e) => {\n      logger.write_string(\"(try_table \")\n      bt.output(logger)\n      logger.write_char(' ')\n      c.output(logger)\n      logger.write_char(' ')\n      e.output(logger)\n      logger.write_char(')')\n    }\n    LocalGet(l) => {\n      logger.write_string(\"(local.get \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    LocalSet(l) => {\n      logger.write_string(\"(local.set \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    LocalTee(l) => {\n      logger.write_string(\"(local.tee \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    GlobalGet(g) => {\n      logger.write_string(\"(global.get \")\n      g.output(logger)\n      logger.write_char(')')\n    }\n    GlobalSet(g) => {\n      logger.write_string(\"(global.set \")\n      g.output(logger)\n      logger.write_char(')')\n    }\n    TableGet(t) => {\n      logger.write_string(\"(table.get \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    TableSet(t) => {\n      logger.write_string(\"(table.set \")\n      t.output(logger)\n      logger.write_char(')')\n    }\n    I32Load(m) => {\n      logger.write_string(\"(i32.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load(m) => {\n      logger.write_string(\"(i64.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F32Load(m) => {\n      logger.write_string(\"(f32.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F64Load(m) => {\n      logger.write_string(\"(f64.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load8S(m) => {\n      logger.write_string(\"(i32.load8s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load8U(m) => {\n      logger.write_string(\"(i32.load8u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load16S(m) => {\n      logger.write_string(\"(i32.load16s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Load16U(m) => {\n      logger.write_string(\"(i32.load16u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load8S(m) => {\n      logger.write_string(\"(i64.load8s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load8U(m) => {\n      logger.write_string(\"(i64.load8u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load16S(m) => {\n      logger.write_string(\"(i64.load16s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load16U(m) => {\n      logger.write_string(\"(i64.load16u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load32S(m) => {\n      logger.write_string(\"(i64.load32s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Load32U(m) => {\n      logger.write_string(\"(i64.load32u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Store(m) => {\n      logger.write_string(\"(i32.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store(m) => {\n      logger.write_string(\"(i64.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F32Store(m) => {\n      logger.write_string(\"(f32.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F64Store(m) => {\n      logger.write_string(\"(f64.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Store8(m) => {\n      logger.write_string(\"(i32.store8 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Store16(m) => {\n      logger.write_string(\"(i32.store16 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store8(m) => {\n      logger.write_string(\"(i64.store8 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store16(m) => {\n      logger.write_string(\"(i64.store16 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I64Store32(m) => {\n      logger.write_string(\"(i64.store32 \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    MemorySize(m) => {\n      logger.write_string(\"(memory.size \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    MemoryGrow(m) => {\n      logger.write_string(\"(memory.grow \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    I32Const(c) => {\n      logger.write_string(\"(i32.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    I64Const(c) => {\n      logger.write_string(\"(i64.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    F32Const(c) => {\n      logger.write_string(\"(f32.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    F64Const(c) => {\n      logger.write_string(\"(f64.const \")\n      c.output(logger)\n      logger.write_char(')')\n    }\n    I32Eqz => logger.write_string(\"i32.eqz\")\n    I32Eq => logger.write_string(\"i32.eq\")\n    I32Ne => logger.write_string(\"i32.ne\")\n    I32LtS => logger.write_string(\"i32.lt_s\")\n    I32LtU => logger.write_string(\"i32.lt_u\")\n    I32GtS => logger.write_string(\"i32.gt_s\")\n    I32GtU => logger.write_string(\"i32.gt_u\")\n    I32LeS => logger.write_string(\"i32.le_s\")\n    I32LeU => logger.write_string(\"i32.le_u\")\n    I32GeS => logger.write_string(\"i32.ge_s\")\n    I32GeU => logger.write_string(\"i32.ge_u\")\n    I64Eqz => logger.write_string(\"i64.eqz\")\n    I64Eq => logger.write_string(\"i64.eq\")\n    I64Ne => logger.write_string(\"i64.ne\")\n    I64LtS => logger.write_string(\"i64.lt_s\")\n    I64LtU => logger.write_string(\"i64.lt_u\")\n    I64GtS => logger.write_string(\"i64.gt_s\")\n    I64GtU => logger.write_string(\"i64.gt_u\")\n    I64LeS => logger.write_string(\"i64.le_s\")\n    I64LeU => logger.write_string(\"i64.le_u\")\n    I64GeS => logger.write_string(\"i64.ge_s\")\n    I64GeU => logger.write_string(\"i64.ge_u\")\n    F32Eq => logger.write_string(\"f32.eq\")\n    F32Ne => logger.write_string(\"f32.ne\")\n    F32Lt => logger.write_string(\"f32.lt\")\n    F32Gt => logger.write_string(\"f32.gt\")\n    F32Le => logger.write_string(\"f32.le\")\n    F32Ge => logger.write_string(\"f32.ge\")\n    F64Eq => logger.write_string(\"f64.eq\")\n    F64Ne => logger.write_string(\"f64.ne\")\n    F64Lt => logger.write_string(\"f64.lt\")\n    F64Gt => logger.write_string(\"f64.gt\")\n    F64Le => logger.write_string(\"f64.le\")\n    F64Ge => logger.write_string(\"f64.ge\")\n    I32Clz => logger.write_string(\"i32.clz\")\n    I32Ctz => logger.write_string(\"i32.ctz\")\n    I32Popcnt => logger.write_string(\"i32.popcnt\")\n    I32Add => logger.write_string(\"i32.add\")\n    I32Sub => logger.write_string(\"i32.sub\")\n    I32Mul => logger.write_string(\"i32.mul\")\n    I32DivS => logger.write_string(\"i32.div_s\")\n    I32DivU => logger.write_string(\"i32.div_u\")\n    I32RemS => logger.write_string(\"i32.rem_s\")\n    I32RemU => logger.write_string(\"i32.rem_u\")\n    I32And => logger.write_string(\"i32.and\")\n    I32Or => logger.write_string(\"i32.or\")\n    I32Xor => logger.write_string(\"i32.xor\")\n    I32Shl => logger.write_string(\"i32.shl\")\n    I32ShrS => logger.write_string(\"i32.shr_s\")\n    I32ShrU => logger.write_string(\"i32.shr_u\")\n    I32Rotl => logger.write_string(\"i32.rotl\")\n    I32Rotr => logger.write_string(\"i32.rotr\")\n    I64Clz => logger.write_string(\"i64.clz\")\n    I64Ctz => logger.write_string(\"i64.ctz\")\n    I64Popcnt => logger.write_string(\"i64.popcnt\")\n    I64Add => logger.write_string(\"i64.add\")\n    I64Sub => logger.write_string(\"i64.sub\")\n    I64Mul => logger.write_string(\"i64.mul\")\n    I64DivS => logger.write_string(\"i64.div_s\")\n    I64DivU => logger.write_string(\"i64.div_u\")\n    I64RemS => logger.write_string(\"i64.rem_s\")\n    I64RemU => logger.write_string(\"i64.rem_u\")\n    I64And => logger.write_string(\"i64.and\")\n    I64Or => logger.write_string(\"i64.or\")\n    I64Xor => logger.write_string(\"i64.xor\")\n    I64Shl => logger.write_string(\"i64.shl\")\n    I64ShrS => logger.write_string(\"i64.shr_s\")\n    I64ShrU => logger.write_string(\"i64.shr_u\")\n    I64Rotl => logger.write_string(\"i64.rotl\")\n    I64Rotr => logger.write_string(\"i64.rotr\")\n    F32Abs => logger.write_string(\"f32.abs\")\n    F32Neg => logger.write_string(\"f32.neg\")\n    F32Ceil => logger.write_string(\"f32.ceil\")\n    F32Floor => logger.write_string(\"f32.floor\")\n    F32Trunc => logger.write_string(\"f32.trunc\")\n    F32Nearest => logger.write_string(\"f32.nearest\")\n    F32Sqrt => logger.write_string(\"f32.sqrt\")\n    F32Add => logger.write_string(\"f32.add\")\n    F32Sub => logger.write_string(\"f32.sub\")\n    F32Mul => logger.write_string(\"f32.mul\")\n    F32Div => logger.write_string(\"f32.div\")\n    F32Min => logger.write_string(\"f32.min\")\n    F32Max => logger.write_string(\"f32.max\")\n    F32Copysign => logger.write_string(\"f32.copysign\")\n    F64Abs => logger.write_string(\"f64.abs\")\n    F64Neg => logger.write_string(\"f64.neg\")\n    F64Ceil => logger.write_string(\"f64.ceil\")\n    F64Floor => logger.write_string(\"f64.floor\")\n    F64Trunc => logger.write_string(\"f64.trunc\")\n    F64Nearest => logger.write_string(\"f64.nearest\")\n    F64Sqrt => logger.write_string(\"f64.sqrt\")\n    F64Add => logger.write_string(\"f64.add\")\n    F64Sub => logger.write_string(\"f64.sub\")\n    F64Mul => logger.write_string(\"f64.mul\")\n    F64Div => logger.write_string(\"f64.div\")\n    F64Min => logger.write_string(\"f64.min\")\n    F64Max => logger.write_string(\"f64.max\")\n    F64Copysign => logger.write_string(\"f64.copysign\")\n    I32WrapI64 => logger.write_string(\"i32.wrap_i64\")\n    I32TruncF32S => logger.write_string(\"i32.trunc_f32s\")\n    I32TruncF32U => logger.write_string(\"i32.trunc_f32u\")\n    I32TruncF64S => logger.write_string(\"i32.trunc_f64s\")\n    I32TruncF64U => logger.write_string(\"i32.trunc_f64u\")\n    I64ExtendI32S => logger.write_string(\"i64.extend_i32s\")\n    I64ExtendI32U => logger.write_string(\"i64.extend_i32u\")\n    I64TruncF32S => logger.write_string(\"i64.trunc_f32s\")\n    I64TruncF32U => logger.write_string(\"i64.trunc_f32u\")\n    I64TruncF64S => logger.write_string(\"i64.trunc_f64s\")\n    I64TruncF64U => logger.write_string(\"i64.trunc_f64u\")\n    F32ConvertI32S => logger.write_string(\"f32.convert_i32s\")\n    F32ConvertI32U => logger.write_string(\"f32.convert_i32u\")\n    F32ConvertI64S => logger.write_string(\"f32.convert_i64s\")\n    F32ConvertI64U => logger.write_string(\"f32.convert_i64u\")\n    F32DemoteF64 => logger.write_string(\"f32.demote_f64\")\n    F64ConvertI32S => logger.write_string(\"f64.convert_i32s\")\n    F64ConvertI32U => logger.write_string(\"f64.convert_i32u\")\n    F64ConvertI64S => logger.write_string(\"f64.convert_i64s\")\n    F64ConvertI64U => logger.write_string(\"f64.convert_i64u\")\n    F64PromoteF32 => logger.write_string(\"f64.promote_f32\")\n    I32ReinterpretF32 => logger.write_string(\"i32.reinterpret_f32\")\n    I64ReinterpretF64 => logger.write_string(\"i64.reinterpret_f64\")\n    F32ReinterpretI32 => logger.write_string(\"f32.reinterpret_i32\")\n    F64ReinterpretI64 => logger.write_string(\"f64.reinterpret_i64\")\n    I32Extend8S => logger.write_string(\"i32.extend8s\")\n    I32Extend16S => logger.write_string(\"i32.extend16s\")\n    I64Extend8S => logger.write_string(\"i64.extend8s\")\n    I64Extend16S => logger.write_string(\"i64.extend16s\")\n    I64Extend32S => logger.write_string(\"i64.extend32s\")\n    RefNull(ht) => {\n      logger.write_string(\"(ref.null \")\n      ht.output(logger)\n      logger.write_char(')')\n    }\n    RefIsNull => logger.write_string(\"ref.null\")\n    RefFunc(i) => {\n      logger.write_string(\"(ref.func \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    RefEq => logger.write_string(\"ref.eq\")\n    RefAsNonNull => logger.write_string(\"ref.as_non_null\")\n    BrOnNull(l) => {\n      logger.write_string(\"(br_on_null \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    BrOnNonNull(l) => {\n      logger.write_string(\"(br_on_non_null \")\n      l.output(logger)\n      logger.write_char(')')\n    }\n    StructNew(i) => {\n      logger.write_string(\"(struct.new \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructNewDefault(i) => {\n      logger.write_string(\"(struct.new_default \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructGet(t, i) => {\n      logger.write_string(\"(struct.get \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructGetS(t, i) => {\n      logger.write_string(\"(struct.get_s \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructGetU(t, i) => {\n      logger.write_string(\"(struct.get_u \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    StructSet(t, i) => {\n      logger.write_string(\"(struct.set \")\n      t.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNew(i) => {\n      logger.write_string(\"(array.new \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewDefault(i) => {\n      logger.write_string(\"(array.new_default \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewFixed(i, n) => {\n      logger.write_string(\"(array.new_fixed \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewData(i, n) => {\n      logger.write_string(\"(array.new_data \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayNewElem(i, n) => {\n      logger.write_string(\"(array.new_elem \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayGet(i) => {\n      logger.write_string(\"(array.get \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayGetS(i) => {\n      logger.write_string(\"(array.get_s \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayGetU(i) => {\n      logger.write_string(\"(array.get_u \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArraySet(i) => {\n      logger.write_string(\"(array.set \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayLen => logger.write_string(\"array.len\")\n    ArrayFill(i) => {\n      logger.write_string(\"(array.fill \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    ArrayCopy(i, n) => {\n      logger.write_string(\"(array.copy \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayInitData(i, n) => {\n      logger.write_string(\"(array.init_data \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    ArrayInitElem(i, n) => {\n      logger.write_string(\"(array.init_elem \")\n      i.output(logger)\n      logger.write_char(' ')\n      n.output(logger)\n      logger.write_char(')')\n    }\n    RefTest(n, ht) => {\n      logger.write_string(\"(ref.test \")\n      HeapTypeRefType(n, ht).output(logger)\n      logger.write_char(')')\n    }\n    RefCast(n, ht) => {\n      logger.write_string(\"(ref.cast \")\n      HeapTypeRefType(n, ht).output(logger)\n      logger.write_char(')')\n    }\n    BrOnCast(i, CastOp(l, r), lht, rht) => {\n      logger.write_string(\"(br_on_cast \")\n      i.output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(l, lht).output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(r, rht).output(logger)\n      logger.write_char(')')\n    }\n    BrOnCastFail(i, CastOp(l, r), lht, rht) => {\n      logger.write_string(\"(br_on_cast_fail \")\n      i.output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(l, lht).output(logger)\n      logger.write_char(' ')\n      HeapTypeRefType(r, rht).output(logger)\n      logger.write_char(')')\n    }\n    AnyConvertExtern => logger.write_string(\"any.convert_extern\")\n    ExternConvertAny => logger.write_string(\"extern.convert_any\")\n    RefI31 => logger.write_string(\"ref.i31\")\n    I31GetS => logger.write_string(\"i31.get_s\")\n    I31GetU => logger.write_string(\"i31.get_u\")\n    I32TruncSatF32S => logger.write_string(\"i32.trunc_sat_f32s\")\n    I32TruncSatF32U => logger.write_string(\"i32.trunc_sat_f32u\")\n    I32TruncSatF64S => logger.write_string(\"i32.trunc_sat_f64s\")\n    I32TruncSatF64U => logger.write_string(\"i32.trunc_sat_f64u\")\n    I64TruncSatF32S => logger.write_string(\"i64.trunc_sat_f32s\")\n    I64TruncSatF32U => logger.write_string(\"i64.trunc_sat_f32u\")\n    I64TruncSatF64S => logger.write_string(\"i64.trunc_sat_f64s\")\n    I64TruncSatF64U => logger.write_string(\"i64.trunc_sat_f64u\")\n    MemoryInit(i, m) => {\n      logger.write_string(\"(memory.init \")\n      i.output(logger)\n      logger.write_char(' ')\n      m.output(logger)\n      logger.write_char(')')\n    }\n    DataDrop(i) => {\n      logger.write_string(\"(data.drop \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    MemoryCopy(i0, i1) => {\n      logger.write_string(\"(memory.copy \")\n      i0.output(logger)\n      logger.write_char(' ')\n      i1.output(logger)\n      logger.write_char(')')\n    }\n    MemoryFill(i) => {\n      logger.write_string(\"(memory.fill \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableInit(i0, i1) => {\n      logger.write_string(\"(table.init \")\n      i0.output(logger)\n      logger.write_char(' ')\n      i1.output(logger)\n      logger.write_char(')')\n    }\n    ElemDrop(i) => {\n      logger.write_string(\"(elem.drop \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableCopy(i0, i1) => {\n      logger.write_string(\"(table.copy \")\n      i0.output(logger)\n      logger.write_char(' ')\n      i1.output(logger)\n      logger.write_char(')')\n    }\n    TableGrow(i) => {\n      logger.write_string(\"(table.grow \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableSize(i) => {\n      logger.write_string(\"(table.size \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    TableFill(i) => {\n      logger.write_string(\"(table.fill \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load(m) => {\n      logger.write_string(\"(v128.load \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load8x8S(m) => {\n      logger.write_string(\"(v128.load8x8s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load8x8U(m) => {\n      logger.write_string(\"(v128.load8x8u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16x4S(m) => {\n      logger.write_string(\"(v128.load16x4s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16x4U(m) => {\n      logger.write_string(\"(v128.load16x4u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32x2S(m) => {\n      logger.write_string(\"(v128.load32x2s \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32x2U(m) => {\n      logger.write_string(\"(v128.load32x2u \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load8Splat(m) => {\n      logger.write_string(\"(v128.load8_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16Splat(m) => {\n      logger.write_string(\"(v128.load16_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32Splat(m) => {\n      logger.write_string(\"(v128.load32_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load64Splat(m) => {\n      logger.write_string(\"(v128.load64_splat \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Store(m) => {\n      logger.write_string(\"(v128.store \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Const(\n      l0,\n      l1,\n      l2,\n      l3,\n      l4,\n      l5,\n      l6,\n      l7,\n      l8,\n      l9,\n      l10,\n      l11,\n      l12,\n      l13,\n      l14,\n      l15\n    ) => {\n      logger.write_string(\"(v128.const \")\n      l0.to_hex().pad_start(2, '0').output(logger)\n      l1.to_hex().pad_start(2, '0').output(logger)\n      l2.to_hex().pad_start(2, '0').output(logger)\n      l3.to_hex().pad_start(2, '0').output(logger)\n      l4.to_hex().pad_start(2, '0').output(logger)\n      l5.to_hex().pad_start(2, '0').output(logger)\n      l6.to_hex().pad_start(2, '0').output(logger)\n      l7.to_hex().pad_start(2, '0').output(logger)\n      l8.to_hex().pad_start(2, '0').output(logger)\n      l9.to_hex().pad_start(2, '0').output(logger)\n      l10.to_hex().pad_start(2, '0').output(logger)\n      l11.to_hex().pad_start(2, '0').output(logger)\n      l12.to_hex().pad_start(2, '0').output(logger)\n      l13.to_hex().pad_start(2, '0').output(logger)\n      l14.to_hex().pad_start(2, '0').output(logger)\n      l15.to_hex().pad_start(2, '0').output(logger)\n      logger.write_char(')')\n    }\n    I8x16Shuffle(\n      l0,\n      l1,\n      l2,\n      l3,\n      l4,\n      l5,\n      l6,\n      l7,\n      l8,\n      l9,\n      l10,\n      l11,\n      l12,\n      l13,\n      l14,\n      l15\n    ) => {\n      logger.write_string(\"(i8x16.shuffle \")\n      l0.output(logger)\n      logger.write_char(' ')\n      l1.output(logger)\n      logger.write_char(' ')\n      l2.output(logger)\n      logger.write_char(' ')\n      l3.output(logger)\n      logger.write_char(' ')\n      l4.output(logger)\n      logger.write_char(' ')\n      l5.output(logger)\n      logger.write_char(' ')\n      l6.output(logger)\n      logger.write_char(' ')\n      l7.output(logger)\n      logger.write_char(' ')\n      l8.output(logger)\n      logger.write_char(' ')\n      l9.output(logger)\n      logger.write_char(' ')\n      l10.output(logger)\n      logger.write_char(' ')\n      l11.output(logger)\n      logger.write_char(' ')\n      l12.output(logger)\n      logger.write_char(' ')\n      l13.output(logger)\n      logger.write_char(' ')\n      l14.output(logger)\n      logger.write_char(' ')\n      l15.output(logger)\n      logger.write_char(')')\n    }\n    I8x16Swizzle => logger.write_string(\"i8x16.swizzle\")\n    I8x16Splat => logger.write_string(\"i8x16.splat\")\n    I16x8Splat => logger.write_string(\"i16x8.splat\")\n    I32x4Splat => logger.write_string(\"i32x4.splat\")\n    I64x2Splat => logger.write_string(\"i64x2.splat\")\n    F32x4Splat => logger.write_string(\"f32x4.splat\")\n    F64x2Splat => logger.write_string(\"f64x2.splat\")\n    I8x16ExtractLaneS(i) => {\n      logger.write_string(\"(i8x16.extract_lane_s \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I8x16ExtractLaneU(i) => {\n      logger.write_string(\"(i8x16.extract_lane_u \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I8x16ReplaceLane(i) => {\n      logger.write_string(\"(i8x16.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I16x8ExtractLaneS(i) => {\n      logger.write_string(\"(i16x8.extract_lane_s \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I16x8ExtractLaneU(i) => {\n      logger.write_string(\"(i16x8.extract_lane_u \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I16x8ReplaceLane(i) => {\n      logger.write_string(\"(i16x8.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I32x4ExtractLane(i) => {\n      logger.write_string(\"(i32x4.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I32x4ReplaceLane(i) => {\n      logger.write_string(\"(i32x4.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I64x2ExtractLane(i) => {\n      logger.write_string(\"(i64x2.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I64x2ReplaceLane(i) => {\n      logger.write_string(\"(i64x2.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F32x4ExtractLane(i) => {\n      logger.write_string(\"(f32x4.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F32x4ReplaceLane(i) => {\n      logger.write_string(\"(f32x4.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F64x2ExtractLane(i) => {\n      logger.write_string(\"(f64x2.extract_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    F64x2ReplaceLane(i) => {\n      logger.write_string(\"(f64x2.replace_lane \")\n      i.output(logger)\n      logger.write_char(')')\n    }\n    I8x16Eq => logger.write_string(\"i8x16.eq\")\n    I8x16Ne => logger.write_string(\"i8x16.ne\")\n    I8x16LtS => logger.write_string(\"i8x16.lt_s\")\n    I8x16LtU => logger.write_string(\"i8x16.lt_u\")\n    I8x16GtS => logger.write_string(\"i8x16.gt_s\")\n    I8x16GtU => logger.write_string(\"i8x16.gt_u\")\n    I8x16LeS => logger.write_string(\"i8x16.le_s\")\n    I8x16LeU => logger.write_string(\"i8x16.le_u\")\n    I8x16GeS => logger.write_string(\"i8x16.ge_s\")\n    I8x16GeU => logger.write_string(\"i8x16.ge_u\")\n    I16x8Eq => logger.write_string(\"i16x8.eq\")\n    I16x8Ne => logger.write_string(\"i16x8.ne\")\n    I16x8LtS => logger.write_string(\"i16x8.lt_s\")\n    I16x8LtU => logger.write_string(\"i16x8.lt_u\")\n    I16x8GtS => logger.write_string(\"i16x8.gt_s\")\n    I16x8GtU => logger.write_string(\"i16x8.gt_u\")\n    I16x8LeS => logger.write_string(\"i16x8.le_s\")\n    I16x8LeU => logger.write_string(\"i16x8.le_u\")\n    I16x8GeS => logger.write_string(\"i16x8.ge_s\")\n    I16x8GeU => logger.write_string(\"i16x8.ge_u\")\n    I32x4Eq => logger.write_string(\"i32x4.eq\")\n    I32x4Ne => logger.write_string(\"i32x4.ne\")\n    I32x4LtS => logger.write_string(\"i32x4.lt_s\")\n    I32x4LtU => logger.write_string(\"i32x4.lt_u\")\n    I32x4GtS => logger.write_string(\"i32x4.gt_s\")\n    I32x4GtU => logger.write_string(\"i32x4.gt_u\")\n    I32x4LeS => logger.write_string(\"i32x4.le_s\")\n    I32x4LeU => logger.write_string(\"i32x4.le_u\")\n    I32x4GeS => logger.write_string(\"i32x4.ge_s\")\n    I32x4GeU => logger.write_string(\"i32x4.ge_u\")\n    F32x4Eq => logger.write_string(\"f32x4.eq\")\n    F32x4Ne => logger.write_string(\"f32x4.ne\")\n    F32x4Lt => logger.write_string(\"f32x4.lt\")\n    F32x4Gt => logger.write_string(\"f32x4.gt\")\n    F32x4Le => logger.write_string(\"f32x4.le\")\n    F32x4Ge => logger.write_string(\"f32x4.ge\")\n    F64x2Eq => logger.write_string(\"f64x2.eq\")\n    F64x2Ne => logger.write_string(\"f64x2.ne\")\n    F64x2Lt => logger.write_string(\"f64x2.lt\")\n    F64x2Gt => logger.write_string(\"f64x2.gt\")\n    F64x2Le => logger.write_string(\"f64x2.le\")\n    F64x2Ge => logger.write_string(\"f64x2.ge\")\n    V128Not => logger.write_string(\"v128.not\")\n    V128And => logger.write_string(\"v128.and\")\n    V128Andnot => logger.write_string(\"v128.andnot\")\n    V128Or => logger.write_string(\"v128.or\")\n    V128Xor => logger.write_string(\"v128.xor\")\n    V128Bitselect => logger.write_string(\"v128.bitselect\")\n    V128AnyTrue => logger.write_string(\"v128.any_true\")\n    V128Load8Lane(m, i) => {\n      logger.write_string(\"(v128.load8_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load16Lane(m, i) => {\n      logger.write_string(\"(v128.load16_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32Lane(m, i) => {\n      logger.write_string(\"(v128.load32_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load64Lane(m, i) => {\n      logger.write_string(\"(v128.load64_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store8Lane(m, i) => {\n      logger.write_string(\"(v128.store8_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store16Lane(m, i) => {\n      logger.write_string(\"(v128.store16_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store32Lane(m, i) => {\n      logger.write_string(\"(v128.store32_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Store64Lane(m, i) => {\n      logger.write_string(\"(v128.store64_lane \")\n      m.output(logger)\n      logger.write_char(' ')\n      i.output(logger)\n      logger.write_char(')')\n    }\n    V128Load32Zero(m) => {\n      logger.write_string(\"(v128_load32_zero \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    V128Load64Zero(m) => {\n      logger.write_string(\"(v128_load64_zero \")\n      m.output(logger)\n      logger.write_char(')')\n    }\n    F32x4DemoteF64x2Zero => logger.write_string(\"f32x4.demote_f64x2_zero\")\n    F64x2PromoteLowF32x4 => logger.write_string(\"f64x2.promote_low_f32x4\")\n    I8x16Abs => logger.write_string(\"i8x16.abs\")\n    I8x16Neg => logger.write_string(\"i8x16.neg\")\n    I8x16Popcnt => logger.write_string(\"i8x16.popcnt\")\n    I8x16AllTrue => logger.write_string(\"i8x16.all_true\")\n    I8x16Bitmask => logger.write_string(\"i8x16.bitmask\")\n    I8x16NarrowI16x8S => logger.write_string(\"i8x16.narrow_i16x8s\")\n    I8x16NarrowI16x8U => logger.write_string(\"i8x16.narrow_i16x8u\")\n    F32x4Ceil => logger.write_string(\"f32x4.ceil\")\n    F32x4Floor => logger.write_string(\"f32x4.floor\")\n    F32x4Trunc => logger.write_string(\"f32x4.trunc\")\n    F32x4Nearest => logger.write_string(\"f32x4.nearest\")\n    I8x16Shl => logger.write_string(\"i8x16.shl\")\n    I8x16ShrS => logger.write_string(\"i8x16.shr_s\")\n    I8x16ShrU => logger.write_string(\"i8x16.shr_u\")\n    I8x16Add => logger.write_string(\"i8x16.add\")\n    I8x16AddSatS => logger.write_string(\"i8x16.add_sat_s\")\n    I8x16AddSatU => logger.write_string(\"i8x16.add_sat_u\")\n    I8x16Sub => logger.write_string(\"i8x16.sub\")\n    I8x16SubSatS => logger.write_string(\"i8x16.sub_sat_s\")\n    I8x16SubSatU => logger.write_string(\"i8x16.sub_sat_u\")\n    F64x2Ceil => logger.write_string(\"f64x2.ceil\")\n    F64x2Floor => logger.write_string(\"f64x2.floor\")\n    I8x16MinS => logger.write_string(\"i8x16.min_s\")\n    I8x16MinU => logger.write_string(\"i8x16.min_u\")\n    I8x16MaxS => logger.write_string(\"i8x16.max_s\")\n    I8x16MaxU => logger.write_string(\"i8x16.max_u\")\n    F64x2Trunc => logger.write_string(\"f64x2.trunc\")\n    I8x16AvgrU => logger.write_string(\"i8x16.avgr_u\")\n    I16x8ExtaddPairwiseI8x16S =>\n      logger.write_string(\"i16x8.extadd_pairwise_i8x16s\")\n    I16x8ExtaddPairwiseI8x16U =>\n      logger.write_string(\"i16x8.extadd_pairwise_i8x16u\")\n    I32x4ExtaddPairwiseI16x8S =>\n      logger.write_string(\"i32x4.extadd_pairwise_i16x8s\")\n    I32x4ExtaddPairwiseI16x8U =>\n      logger.write_string(\"i32x4.extadd_pairwise_i16x8u\")\n    I16x8Abs => logger.write_string(\"i16x8.abs\")\n    I16x8Neg => logger.write_string(\"i16x8.neg\")\n    I16x8Q15mulrSatS => logger.write_string(\"i16x8.15mulr_sat_s\")\n    I16x8AllTrue => logger.write_string(\"i16x8.all_true\")\n    I16x8Bitmask => logger.write_string(\"i16x8.bitmask\")\n    I16x8NarrowI32x4S => logger.write_string(\"i16x8.narrow_i32x4s\")\n    I16x8NarrowI32x4U => logger.write_string(\"i16x8.narrow_i32x4u\")\n    I16x8ExtendLowI8x16S => logger.write_string(\"i16x8.extend_low_i8x16s\")\n    I16x8ExtendHighI8x16S => logger.write_string(\"i16x8.extend_high_i8x16s\")\n    I16x8ExtendLowI8x16U => logger.write_string(\"i16x8.extend_low_i8x16u\")\n    I16x8ExtendHighI8x16U => logger.write_string(\"i16x8.extend_high_i8x16u\")\n    I16x8Shl => logger.write_string(\"i16x8.shl\")\n    I16x8ShrS => logger.write_string(\"i16x8.shr_s\")\n    I16x8ShrU => logger.write_string(\"i16x8.shr_u\")\n    I16x8Add => logger.write_string(\"i16x8.add\")\n    I16x8AddSatS => logger.write_string(\"i16x8.add_sat_s\")\n    I16x8AddSatU => logger.write_string(\"i16x8.add_sat_u\")\n    I16x8Sub => logger.write_string(\"i16x8.sub\")\n    I16x8SubSatS => logger.write_string(\"i16x8.sub_sat_s\")\n    I16x8SubSatU => logger.write_string(\"i16x8.sub_sat_u\")\n    F64x2Nearest => logger.write_string(\"f64x2.nearest\")\n    I16x8Mul => logger.write_string(\"i16x8.mul\")\n    I16x8MinS => logger.write_string(\"i16x8.min_s\")\n    I16x8MinU => logger.write_string(\"i16x8.min_u\")\n    I16x8MaxS => logger.write_string(\"i16x8.max_s\")\n    I16x8MaxU => logger.write_string(\"i16x8.max_u\")\n    I16x8AvgrU => logger.write_string(\"i16x8.avgr_u\")\n    I16x8ExtmulLowI8x16S => logger.write_string(\"i16x8.extmul_low_i8x16s\")\n    I16x8ExtmulHighI8x16S => logger.write_string(\"i16x8.extmul_high_i8x16s\")\n    I16x8ExtmulLowI8x16U => logger.write_string(\"i16x8.extmul_low_i8x16u\")\n    I16x8ExtmulHighI8x16U => logger.write_string(\"i16x8.extmul_high_i8x16u\")\n    I32x4Abs => logger.write_string(\"i32x4.abs\")\n    I32x4Neg => logger.write_string(\"i32x4.neg\")\n    I32x4AllTrue => logger.write_string(\"i32x4.all_true\")\n    I32x4Bitmask => logger.write_string(\"i32x4.bitmask\")\n    I32x4ExtendLowI16x8S => logger.write_string(\"i32x4.extend_low_i16x8s\")\n    I32x4ExtendHighI16x8S => logger.write_string(\"i32x4.extend_high_i16x8s\")\n    I32x4ExtendLowI16x8U => logger.write_string(\"i32x4.extend_low_i16x8u\")\n    I32x4ExtendHighI16x8U => logger.write_string(\"i32x4.extend_high_i16x8u\")\n    I32x4Shl => logger.write_string(\"i32x4.shl\")\n    I32x4ShrS => logger.write_string(\"i32x4.shr_s\")\n    I32x4ShrU => logger.write_string(\"i32x4.shr_u\")\n    I32x4Add => logger.write_string(\"i32x4.add\")\n    I32x4Sub => logger.write_string(\"i32x4.sub\")\n    I32x4Mul => logger.write_string(\"i32x4.mul\")\n    I32x4MinS => logger.write_string(\"i32x4.min_s\")\n    I32x4MinU => logger.write_string(\"i32x4.min_u\")\n    I32x4MaxS => logger.write_string(\"i32x4.max_s\")\n    I32x4MaxU => logger.write_string(\"i32x4.max_u\")\n    I32x4DotI16x8S => logger.write_string(\"i32x4.dot_i16x8s\")\n    I32x4ExtmulLowI16x8S => logger.write_string(\"i32x4.extmul_low_i16x8s\")\n    I32x4ExtmulHighI16x8S => logger.write_string(\"i32x4.extmul_high_i16x8s\")\n    I32x4ExtmulLowI16x8U => logger.write_string(\"i32x4.extmul_low_i16x8u\")\n    I32x4ExtmulHighI16x8U => logger.write_string(\"i32x4.extmul_high_i16x8u\")\n    I64x2Abs => logger.write_string(\"i64x2.abs\")\n    I64x2Neg => logger.write_string(\"i64x2.neg\")\n    I64x2AllTrue => logger.write_string(\"i64x2.all_true\")\n    I64x2Bitmask => logger.write_string(\"i64x2.bitmask\")\n    I64x2ExtendLowI32x4S => logger.write_string(\"i64x2.extend_low_i32x4s\")\n    I64x2ExtendHighI32x4S => logger.write_string(\"i64x2.extend_high_i32x4s\")\n    I64x2ExtendLowI32x4U => logger.write_string(\"i64x2.extend_low_i32x4u\")\n    I64x2ExtendHighI32x4U => logger.write_string(\"i64x2.extend_high_i32x4u\")\n    I64x2Shl => logger.write_string(\"i64x2.shl\")\n    I64x2ShrS => logger.write_string(\"i64x2.shr_s\")\n    I64x2ShrU => logger.write_string(\"i64x2.shr_u\")\n    I64x2Add => logger.write_string(\"i64x2.add\")\n    I64x2Sub => logger.write_string(\"i64x2.sub\")\n    I64x2Mul => logger.write_string(\"i64x2.mul\")\n    I64x2Eq => logger.write_string(\"i64x2.eq\")\n    I64x2Ne => logger.write_string(\"i64x2.ne\")\n    I64x2LtS => logger.write_string(\"i64x2.lt_s\")\n    I64x2GtS => logger.write_string(\"i64x2.gt_s\")\n    I64x2LeS => logger.write_string(\"i64x2.le_s\")\n    I64x2GeS => logger.write_string(\"i64x2.ge_s\")\n    I64x2ExtmulLowI32x4S => logger.write_string(\"i64x2.extmul_low_i32x4s\")\n    I64x2ExtmulHighI32x4S => logger.write_string(\"i64x2.extmul_high_i32x4s\")\n    I64x2ExtmulLowI32x4U => logger.write_string(\"i64x2.extmul_low_i32x4u\")\n    I64x2ExtmulHighI32x4U => logger.write_string(\"i64x2.extmul_high_i32x4u\")\n    F32x4Abs => logger.write_string(\"f32x4.abs\")\n    F32x4Neg => logger.write_string(\"f32x4.neg\")\n    F32x4Sqrt => logger.write_string(\"f32x4.sqrt\")\n    F32x4Add => logger.write_string(\"f32x4.add\")\n    F32x4Sub => logger.write_string(\"f32x4.sub\")\n    F32x4Mul => logger.write_string(\"f32x4.mul\")\n    F32x4Div => logger.write_string(\"f32x4.div\")\n    F32x4Min => logger.write_string(\"f32x4.min\")\n    F32x4Max => logger.write_string(\"f32x4.max\")\n    F32x4Pmin => logger.write_string(\"f32x4.pmin\")\n    F32x4Pmax => logger.write_string(\"f32x4.pmax\")\n    F64x2Abs => logger.write_string(\"f64x2.abs\")\n    F64x2Neg => logger.write_string(\"f64x2.neg\")\n    F64x2Sqrt => logger.write_string(\"f64x2.sqrt\")\n    F64x2Add => logger.write_string(\"f64x2.add\")\n    F64x2Sub => logger.write_string(\"f64x2.sub\")\n    F64x2Mul => logger.write_string(\"f64x2.mul\")\n    F64x2Div => logger.write_string(\"f64x2.div\")\n    F64x2Min => logger.write_string(\"f64x2.min\")\n    F64x2Max => logger.write_string(\"f64x2.max\")\n    F64x2Pmin => logger.write_string(\"f64x2.pmin\")\n    F64x2Pmax => logger.write_string(\"f64x2.pmax\")\n    I32x4TruncSatF32x4S => logger.write_string(\"i32x4.trunc_sat_f32x4s\")\n    I32x4TruncSatF32x4U => logger.write_string(\"i32x4.trunc_sat_f32x4u\")\n    F32x4ConvertI32x4S => logger.write_string(\"f32x4.convert_i32x4s\")\n    F32x4ConvertI32x4U => logger.write_string(\"f32x4.convert_i32x4u\")\n    I32x4TruncSatF64x2SZero =>\n      logger.write_string(\"i32x4.trunc_sat_f64x2s_zero\")\n    I32x4TruncSatF64x2UZero =>\n      logger.write_string(\"i32x4.trunc_sat_f64x2u_zero\")\n    F64x2ConvertLowI32x4S => logger.write_string(\"f64x2.convert_low_i32x4s\")\n    F64x2ConvertLowI32x4U => logger.write_string(\"f64x2.convert_low_i32x4u\")\n    I8x16RelaxedSwizzle => logger.write_string(\"i8x16.relaxed_swizzle\")\n    I32x4RelaxedTruncF32x4S => logger.write_string(\"i32x4.relaxed_trunc_f32x4s\")\n    I32x4RelaxedTruncF32x4U => logger.write_string(\"i32x4.relaxed_trunc_f32x4u\")\n    I32x4RelaxedTruncZeroF64x2S =>\n      logger.write_string(\"i32x4.relaxed_trunc_zero_f64x2s\")\n    I32x4RelaxedTruncZeroF64x2U =>\n      logger.write_string(\"i32x4.relaxed_trunc_zero_f64x2u\")\n    F32x4RelaxedMadd => logger.write_string(\"f32x4.relaxed_madd\")\n    F32x4RelaxedNmadd => logger.write_string(\"f32x4.relaxed_nmadd\")\n    F64x2RelaxedMadd => logger.write_string(\"f64x2.relaxed_madd\")\n    F64x2RelaxedNmadd => logger.write_string(\"f64x2.relaxed_nmadd\")\n    I8x16RelaxedLaneselect => logger.write_string(\"i8x16.relaxed_laneselect\")\n    I16x8RelaxedLaneselect => logger.write_string(\"i16x8.relaxed_laneselect\")\n    I32x4RelaxedLaneselect => logger.write_string(\"i32x4.relaxed_laneselect\")\n    I64x2RelaxedLaneselect => logger.write_string(\"i64x2.relaxed_laneselect\")\n    F32x4RelaxedMin => logger.write_string(\"f32x4.relaxed_min\")\n    F32x4RelaxedMax => logger.write_string(\"f32x4.relaxed_max\")\n    F64x2RelaxedMin => logger.write_string(\"f64x2.relaxed_min\")\n    F64x2RelaxedMax => logger.write_string(\"f64x2.relaxed_max\")\n    I16x8RelaxedQ15mulrS => logger.write_string(\"i16x8.relaxed_q15mulr_s\")\n    I16x8RelaxedDotI8x16I7x16S =>\n      logger.write_string(\"i16x8.relaxed_dot_i8x16i7x16s\")\n    I32x4RelaxedDotI8x16I7x16AddS =>\n      logger.write_string(\"i32x4.relaxed_dot_i8x16i7x16_add_s\")\n  }\n}\n\n///|\npub impl Show for CustomSec with output(self, logger) {\n  let CustomSec(name, _) = self\n  logger.write_string(\"[Custom: \")\n  name.output(logger)\n  logger.write_char(']')\n}\n\n///|\npub impl Show for TypeSec with output(self, logger) {\n  let TypeSec(tys) = self\n  logger.write_string(\"[Types\")\n  if tys.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\":\\n\")\n  for ty in tys {\n    logger.write_string(\"  - \")\n    ty.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for ImportSec with output(self, logger) {\n  let ImportSec(imports) = self\n  logger.write_string(\"[Imports\")\n  if imports.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in imports {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for FuncSec with output(self, logger) {\n  let FuncSec(fns) = self\n  logger.write_string(\"[Funcs\")\n  if fns.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in fns {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for TableSec with output(self, logger) {\n  let TableSec(tbls) = self\n  logger.write_string(\"[Tables\")\n  if tbls.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in tbls {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for MemSec with output(self, logger) {\n  let MemSec(mems) = self\n  logger.write_string(\"[Memory\")\n  if mems.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in mems {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for TagSec with output(self, logger) {\n  let TagSec(mems) = self\n  logger.write_string(\"[Tags\")\n  if mems.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in mems {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for GlobalSec with output(self, logger) {\n  let GlobalSec(globals) = self\n  logger.write_string(\"[Globals\")\n  if globals.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in globals {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for ExportSec with output(self, logger) {\n  let ExportSec(exports) = self\n  logger.write_string(\"[Globals\")\n  if exports.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in exports {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for StartSec with output(self, logger) {\n  let StartSec(start) = self\n  logger.write_string(\"[Start \")\n  start.output(logger)\n  logger.write_char(']')\n}\n\n///|\npub impl Show for ElemSec with output(self, logger) {\n  let ElemSec(elems) = self\n  logger.write_string(\"[Elems\")\n  if elems.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in elems {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for DataCntSec with output(self, logger) {\n  let DataCntSec(start) = self\n  logger.write_string(\"[DataCount \")\n  start.output(logger)\n  logger.write_char(']')\n}\n\n///|\npub impl Show for CodeSec with output(self, logger) {\n  let CodeSec(codes) = self\n  logger.write_string(\"[Code\")\n  if codes.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in codes {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for DataSec with output(self, logger) {\n  let DataSec(datas) = self\n  logger.write_string(\"[Elems\")\n  if datas.length() == 0 {\n    logger.write_char(']')\n    return\n  }\n  logger.write_string(\": \\n\")\n  for i in datas {\n    logger.write_string(\"  - \")\n    i.output(logger)\n    logger.write_char('\\n')\n  }\n  logger.write_char(']')\n}\n\n///|\npub impl Show for Module with output(self, logger) {\n  let Module(\n    customs,\n    type_sec,\n    import_sec,\n    func_sec,\n    table_sec,\n    mem_sec,\n    tag_sec,\n    global_sec,\n    export_sec,\n    start_sec,\n    elem_sec,\n    data_cnt_sec,\n    code_sec,\n    data_sec\n  ) = self\n  logger.write_string(\"Module[\\n\")\n  logger.write_string(\"customs: \")\n  customs.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"type_sec: \")\n  type_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"import_sec: \")\n  import_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"func_sec: \")\n  func_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"table_sec: \")\n  table_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"mem_sec: \")\n  mem_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"tag_sec: \")\n  tag_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"global_sec: \")\n  global_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"export_sec: \")\n  export_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"start_sec: \")\n  start_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"elem_sec: \")\n  elem_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"data_cnt_sec: \")\n  data_cnt_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"code_sec: \")\n  code_sec.output(logger)\n  logger.write_char('\\n')\n  logger.write_string(\"data_sec: \")\n  data_sec.output(logger)\n  logger.write_string(\"]\")\n}\n","///|\npub type TransformerResult[T, Elem] = Result[(T, Elem)?, String]\n\n///|\npub fn[T, Elem] change(t : T, elem : Elem) -> TransformerResult[T, Elem] {\n  Ok(Some((t, elem)))\n}\n\n///|\npub fn[T, Elem] unchanged() -> TransformerResult[T, Elem] {\n  Ok(None)\n}\n\n///|\npub fn[T, Elem] error(err : String) -> TransformerResult[T, Elem] {\n  Err(err)\n}\n\n// Transformer Definition\n\n///|\npub(all) struct ModuleTransformer[T] {\n  on_typesec : ((ModuleTransformer[T], T, TypeSec) -> TransformerResult[\n    T,\n    TypeSec,\n  ])?\n  on_funcsec : ((ModuleTransformer[T], T, FuncSec) -> TransformerResult[\n    T,\n    FuncSec,\n  ])?\n  on_tablesec : ((ModuleTransformer[T], T, TableSec) -> TransformerResult[\n    T,\n    TableSec,\n  ])?\n  on_memsec : ((ModuleTransformer[T], T, MemSec) -> TransformerResult[T, MemSec])?\n  on_tagsec : ((ModuleTransformer[T], T, TagSec) -> TransformerResult[T, TagSec])?\n  on_globalsec : ((ModuleTransformer[T], T, GlobalSec) -> TransformerResult[\n    T,\n    GlobalSec,\n  ])?\n  on_exportsec : ((ModuleTransformer[T], T, ExportSec) -> TransformerResult[\n    T,\n    ExportSec,\n  ])?\n  on_startsec : ((ModuleTransformer[T], T, StartSec) -> TransformerResult[\n    T,\n    StartSec,\n  ])?\n  on_elemsec : ((ModuleTransformer[T], T, ElemSec) -> TransformerResult[\n    T,\n    ElemSec,\n  ])?\n  on_elemkind : ((ModuleTransformer[T], T, ElemKind) -> TransformerResult[\n    T,\n    ElemKind,\n  ])?\n  on_datacntsec : ((ModuleTransformer[T], T, DataCntSec) -> TransformerResult[\n    T,\n    DataCntSec,\n  ])?\n  on_codesec : ((ModuleTransformer[T], T, CodeSec) -> TransformerResult[\n    T,\n    CodeSec,\n  ])?\n  on_datasec : ((ModuleTransformer[T], T, DataSec) -> TransformerResult[\n    T,\n    DataSec,\n  ])?\n  on_instruction : ((ModuleTransformer[T], T, Instruction) -> TransformerResult[\n    T,\n    Instruction,\n  ])?\n  on_tinstruction : ((ModuleTransformer[T], T, TInstr) -> TransformerResult[\n    T,\n    TInstr,\n  ])?\n  on_expr : ((ModuleTransformer[T], T, Expr) -> TransformerResult[T, Expr])?\n  on_texpr : ((ModuleTransformer[T], T, TExpr) -> TransformerResult[T, TExpr])?\n  on_table : ((ModuleTransformer[T], T, Table) -> TransformerResult[T, Table])?\n  on_valtype : ((ModuleTransformer[T], T, ValType) -> TransformerResult[\n    T,\n    ValType,\n  ])?\n  on_numtype : ((ModuleTransformer[T], T, NumType) -> TransformerResult[\n    T,\n    NumType,\n  ])?\n  on_rectype : ((ModuleTransformer[T], T, RecType) -> TransformerResult[\n    T,\n    RecType,\n  ])?\n  on_subtype : ((ModuleTransformer[T], T, SubType) -> TransformerResult[\n    T,\n    SubType,\n  ])?\n  on_comptype : ((ModuleTransformer[T], T, CompType) -> TransformerResult[\n    T,\n    CompType,\n  ])?\n  on_reftype : ((ModuleTransformer[T], T, RefType) -> TransformerResult[\n    T,\n    RefType,\n  ])?\n  on_heaptype : ((ModuleTransformer[T], T, HeapType) -> TransformerResult[\n    T,\n    HeapType,\n  ])?\n  on_blocktype : ((ModuleTransformer[T], T, BlockType) -> TransformerResult[\n    T,\n    BlockType,\n  ])?\n  on_funcidx : ((ModuleTransformer[T], T, FuncIdx) -> TransformerResult[\n    T,\n    FuncIdx,\n  ])?\n  on_typeidx : ((ModuleTransformer[T], T, TypeIdx) -> TransformerResult[\n    T,\n    TypeIdx,\n  ])?\n  on_laneidx : ((ModuleTransformer[T], T, LaneIdx) -> TransformerResult[\n    T,\n    LaneIdx,\n  ])?\n  on_localidx : ((ModuleTransformer[T], T, LocalIdx) -> TransformerResult[\n    T,\n    LocalIdx,\n  ])?\n  on_globalidx : ((ModuleTransformer[T], T, GlobalIdx) -> TransformerResult[\n    T,\n    GlobalIdx,\n  ])?\n  on_tableidx : ((ModuleTransformer[T], T, TableIdx) -> TransformerResult[\n    T,\n    TableIdx,\n  ])?\n  on_memidx : ((ModuleTransformer[T], T, MemIdx) -> TransformerResult[T, MemIdx])?\n  on_labelidx : ((ModuleTransformer[T], T, LabelIdx) -> TransformerResult[\n    T,\n    LabelIdx,\n  ])?\n  on_dataidx : ((ModuleTransformer[T], T, DataIdx) -> TransformerResult[\n    T,\n    DataIdx,\n  ])?\n  on_elemidx : ((ModuleTransformer[T], T, ElemIdx) -> TransformerResult[\n    T,\n    ElemIdx,\n  ])?\n  on_tagidx : ((ModuleTransformer[T], T, TagIdx) -> TransformerResult[T, TagIdx])?\n  on_name : ((ModuleTransformer[T], T, Name) -> TransformerResult[T, Name])?\n  on_externtype : ((ModuleTransformer[T], T, ExternType) -> TransformerResult[\n    T,\n    ExternType,\n  ])?\n  on_limits : ((ModuleTransformer[T], T, Limits) -> TransformerResult[T, Limits])?\n  on_memtype : ((ModuleTransformer[T], T, MemType) -> TransformerResult[\n    T,\n    MemType,\n  ])?\n  on_tagtype : ((ModuleTransformer[T], T, TagType) -> TransformerResult[\n    T,\n    TagType,\n  ])?\n  on_export : ((ModuleTransformer[T], T, Export) -> TransformerResult[T, Export])?\n  on_global : ((ModuleTransformer[T], T, Global) -> TransformerResult[T, Global])?\n  on_globaltype : ((ModuleTransformer[T], T, GlobalType) -> TransformerResult[\n    T,\n    GlobalType,\n  ])?\n  on_func : ((ModuleTransformer[T], T, Func) -> TransformerResult[T, Func])?\n  on_locals : ((ModuleTransformer[T], T, Array[Locals]) -> TransformerResult[\n    T,\n    Array[Locals],\n  ])?\n  on_externidx : ((ModuleTransformer[T], T, ExternIdx) -> TransformerResult[\n    T,\n    ExternIdx,\n  ])?\n  on_fieldtype : ((ModuleTransformer[T], T, FieldType) -> TransformerResult[\n    T,\n    FieldType,\n  ])?\n  on_storagetype : ((ModuleTransformer[T], T, StorageType) -> TransformerResult[\n    T,\n    StorageType,\n  ])?\n  on_unaryop : ((ModuleTransformer[T], T, UnaryOp) -> TransformerResult[\n    T,\n    UnaryOp,\n  ])?\n  on_binaryop : ((ModuleTransformer[T], T, BinaryOp) -> TransformerResult[\n    T,\n    BinaryOp,\n  ])?\n  on_storeop : ((ModuleTransformer[T], T, StoreOp) -> TransformerResult[\n    T,\n    StoreOp,\n  ])?\n  on_loadop : ((ModuleTransformer[T], T, LoadOp) -> TransformerResult[T, LoadOp])?\n  on_extractlaneop : ((ModuleTransformer[T], T, ExtractLaneOp) -> TransformerResult[\n    T,\n    ExtractLaneOp,\n  ])?\n  on_replacelaneop : ((ModuleTransformer[T], T, ReplaceLaneOp) -> TransformerResult[\n    T,\n    ReplaceLaneOp,\n  ])?\n  on_v128shiftop : ((ModuleTransformer[T], T, V128ShiftOp) -> TransformerResult[\n    T,\n    V128ShiftOp,\n  ])?\n  on_v128ternaryop : ((ModuleTransformer[T], T, V128TernaryOp) -> TransformerResult[\n    T,\n    V128TernaryOp,\n  ])?\n  on_v128loadlaneop : ((ModuleTransformer[T], T, V128LoadLaneOp) -> TransformerResult[\n    T,\n    V128LoadLaneOp,\n  ])?\n  on_v128storelaneop : ((ModuleTransformer[T], T, V128StoreLaneOp) -> TransformerResult[\n    T,\n    V128StoreLaneOp,\n  ])?\n  on_memarg : ((ModuleTransformer[T], T, MemArg) -> TransformerResult[T, MemArg])?\n}\n\n///|\npub fn[T] ModuleTransformer::new() -> ModuleTransformer[T] {\n  ModuleTransformer::{\n    on_typesec: None,\n    on_funcsec: None,\n    on_tablesec: None,\n    on_memsec: None,\n    on_tagsec: None,\n    on_globalsec: None,\n    on_exportsec: None,\n    on_startsec: None,\n    on_elemsec: None,\n    on_elemkind: None,\n    on_datacntsec: None,\n    on_codesec: None,\n    on_datasec: None,\n    on_instruction: None,\n    on_tinstruction: None,\n    on_expr: None,\n    on_texpr: None,\n    on_table: None,\n    on_valtype: None,\n    on_numtype: None,\n    on_rectype: None,\n    on_subtype: None,\n    on_comptype: None,\n    on_reftype: None,\n    on_heaptype: None,\n    on_blocktype: None,\n    on_funcidx: None,\n    on_typeidx: None,\n    on_laneidx: None,\n    on_localidx: None,\n    on_globalidx: None,\n    on_tableidx: None,\n    on_memidx: None,\n    on_labelidx: None,\n    on_dataidx: None,\n    on_elemidx: None,\n    on_tagidx: None,\n    on_name: None,\n    on_externtype: None,\n    on_limits: None,\n    on_memtype: None,\n    on_tagtype: None,\n    on_export: None,\n    on_global: None,\n    on_globaltype: None,\n    on_func: None,\n    on_locals: None,\n    on_externidx: None,\n    on_fieldtype: None,\n    on_storagetype: None,\n    on_unaryop: None,\n    on_binaryop: None,\n    on_storeop: None,\n    on_loadop: None,\n    on_extractlaneop: None,\n    on_replacelaneop: None,\n    on_v128shiftop: None,\n    on_v128ternaryop: None,\n    on_v128loadlaneop: None,\n    on_v128storelaneop: None,\n    on_memarg: None,\n  }\n}\n\n///|\npub fn[T, E] ModuleTransformer::walk_array(\n  self : ModuleTransformer[T],\n  t : T,\n  f : (ModuleTransformer[T], T, E) -> TransformerResult[T, E],\n  a : Array[E],\n) -> TransformerResult[T, Array[E]] {\n  let mut t = t\n  let mut changed = false\n  let a = a.copy()\n  let end = a.length()\n  loop 0 {\n    n if n == end => break\n    n => {\n      let item = a[n]\n      match f(self, t, item) {\n        Ok(None) => continue n + 1 // No change\n        Ok(Some((next_t, next_item))) => {\n          t = next_t\n          a[n] = next_item\n          changed = true\n          continue n + 1\n        }\n        Err(e) => return Err(e)\n      }\n    }\n  }\n  if changed {\n    Ok(Some((t, a)))\n  } else {\n    Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_name(\n  self : ModuleTransformer[T],\n  t : T,\n  name : Name,\n) -> TransformerResult[T, Name] {\n  match self.on_name {\n    Some(f) => f(self, t, name)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_expr(\n  self : ModuleTransformer[T],\n  t : T,\n  expr : Expr,\n) -> TransformerResult[T, Expr] {\n  match self.on_expr {\n    Some(f) =>\n      match f(self, t, expr) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_expr_default(t, expr)\n        ok => ok\n      }\n    None => self.walk_expr_default(t, expr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_texpr(\n  self : ModuleTransformer[T],\n  t : T,\n  texpr : TExpr,\n) -> TransformerResult[T, TExpr] {\n  match self.on_texpr {\n    Some(f) =>\n      match f(self, t, texpr) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_texpr_default(t, texpr)\n        ok => ok\n      }\n    None => self.walk_texpr_default(t, texpr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_expr_default(\n  self : ModuleTransformer[T],\n  t : T,\n  expr : Expr,\n) -> TransformerResult[T, Expr] {\n  let Expr(instructions) = expr\n  match self.walk_array(t, ModuleTransformer::walk_instruction, instructions) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, instructions))) => Ok(Some((t, Expr(instructions))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_texpr_default(\n  self : ModuleTransformer[T],\n  t : T,\n  expr : TExpr,\n) -> TransformerResult[T, TExpr] {\n  let TExpr(instructions) = expr\n  let (t, instructions) = match\n    self.walk_array(t, ModuleTransformer::walk_tinstruction, instructions) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, instructions)\n    Ok(Some(t)) => t\n  }\n  Ok(Some((t, TExpr(instructions))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tinstruction(\n  self : ModuleTransformer[T],\n  t : T,\n  tinstr : TInstr,\n) -> TransformerResult[T, TInstr] {\n  match self.on_tinstruction {\n    Some(f) =>\n      match f(self, t, tinstr) {\n        Ok(None) => self.walk_tinstruction_default(t, tinstr)\n        Ok(t) => Ok(t)\n        Err(t) => Err(t)\n      }\n    None => self.walk_tinstruction_default(t, tinstr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tinstruction_default(\n  self : ModuleTransformer[T],\n  t : T,\n  tinstr : TInstr,\n) -> TransformerResult[T, TInstr] {\n  match tinstr {\n    // === Constants (0 children, 1 result) ===\n\n    TRefNull(ht) => {\n      let (t, ht) = match self.walk_heaptype(t, ht) {\n        Ok(None) => (t, ht)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefNull(ht))))\n    }\n    TRefFunc(fi) => {\n      let (t, fi) = match self.walk_funcidx(t, fi) {\n        Ok(None) => (t, fi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefFunc(fi))))\n    }\n    // === Nullary (0 children) ===\n\n    TLocalGet(li) => {\n      let (t, li) = match self.walk_localidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLocalGet(li))))\n    }\n    TGlobalGet(gi) => {\n      let (t, gi) = match self.walk_globalidx(t, gi) {\n        Ok(None) => (t, gi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TGlobalGet(gi))))\n    }\n    TMemorySize(mi) => {\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemorySize(mi))))\n    }\n    TTableSize(ti) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableSize(ti))))\n    }\n\n    // === Unary (1 child) ===\n    TUnary(op, i) => {\n      let (t, op) = match self.walk_unaryop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TUnary(op, i))))\n    }\n    TDrop(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TDrop(i))))\n    }\n    TLocalSet(li, i) => {\n      let (t, li) = match self.walk_localidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLocalSet(li, i))))\n    }\n    TLocalTee(li, i) => {\n      let (t, li) = match self.walk_localidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLocalTee(li, i))))\n    }\n    TGlobalSet(gi, i) => {\n      let (t, gi) = match self.walk_globalidx(t, gi) {\n        Ok(None) => (t, gi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TGlobalSet(gi, i))))\n    }\n    TRefIsNull(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefIsNull(i))))\n    }\n    TRefAsNonNull(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefAsNonNull(i))))\n    }\n    TI31GetS(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI31GetS(i))))\n    }\n    TI31GetU(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI31GetU(i))))\n    }\n    TRefI31(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefI31(i))))\n    }\n    TArrayLen(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayLen(i))))\n    }\n    TAnyConvertExtern(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TAnyConvertExtern(i))))\n    }\n    TExternConvertAny(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TExternConvertAny(i))))\n    }\n    TThrowRef(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TThrowRef(i))))\n    }\n\n    // === Binary (2 children) ===\n    TBinary(op, i1, i2) => {\n      let (t, op) = match self.walk_binaryop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBinary(op, i1, i2))))\n    }\n    TRefEq(i1, i2) => {\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefEq(i1, i2))))\n    }\n    TStore(op, ma, i1, i2) => {\n      let (t, op) = match self.walk_storeop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStore(op, ma, i1, i2))))\n    }\n\n    // === Load (1 child - address) ===\n    TLoad(op, ma, i) => {\n      let (t, op) = match self.walk_loadop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLoad(op, ma, i))))\n    }\n\n    // === Memory operations ===\n    TMemoryGrow(mi, i) => {\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryGrow(mi, i))))\n    }\n    TMemoryFill(mi, i1, i2, i3) => {\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryFill(mi, i1, i2, i3))))\n    }\n    TMemoryCopy(mi1, mi2, i1, i2, i3) => {\n      let (t, mi1) = match self.walk_memidx(t, mi1) {\n        Ok(None) => (t, mi1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, mi2) = match self.walk_memidx(t, mi2) {\n        Ok(None) => (t, mi2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryCopy(mi1, mi2, i1, i2, i3))))\n    }\n    TMemoryInit(di, mi, i1, i2, i3) => {\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, mi) = match self.walk_memidx(t, mi) {\n        Ok(None) => (t, mi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TMemoryInit(di, mi, i1, i2, i3))))\n    }\n    TDataDrop(di) => {\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TDataDrop(di))))\n    }\n\n    // === Table operations ===\n    TTableGet(ti, i) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableGet(ti, i))))\n    }\n    TTableSet(ti, i1, i2) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableSet(ti, i1, i2))))\n    }\n    TTableGrow(ti, i1, i2) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableGrow(ti, i1, i2))))\n    }\n    TTableFill(ti, i1, i2, i3) => {\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableFill(ti, i1, i2, i3))))\n    }\n    TTableCopy(ti1, ti2, i1, i2, i3) => {\n      let (t, ti1) = match self.walk_tableidx(t, ti1) {\n        Ok(None) => (t, ti1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ti2) = match self.walk_tableidx(t, ti2) {\n        Ok(None) => (t, ti2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableCopy(ti1, ti2, i1, i2, i3))))\n    }\n    TTableInit(ei, ti, i1, i2, i3) => {\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ti) = match self.walk_tableidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTableInit(ei, ti, i1, i2, i3))))\n    }\n    TElemDrop(ei) => {\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TElemDrop(ei))))\n    }\n\n    // === Calls (N children based on function type) ===\n    TCall(fi, i) => {\n      let (t, fi) = match self.walk_funcidx(t, fi) {\n        Ok(None) => (t, fi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TCall(fi, i))))\n    }\n    TCallIndirect(tyi, tai, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, tai) = match self.walk_tableidx(t, tai) {\n        Ok(None) => (t, tai)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TCallIndirect(tyi, tai, i0, i))))\n    }\n    TCallRef(tyi, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TCallRef(tyi, i0, i))))\n    }\n    TReturnCall(fi, i) => {\n      let (t, fi) = match self.walk_funcidx(t, fi) {\n        Ok(None) => (t, fi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturnCall(fi, i))))\n    }\n    TReturnCallIndirect(tyi, tai, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, tai) = match self.walk_tableidx(t, tai) {\n        Ok(None) => (t, tai)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturnCallIndirect(tyi, tai, i0, i))))\n    }\n    TReturnCallRef(tyi, i0, i) => {\n      let (t, tyi) = match self.walk_typeidx(t, tyi) {\n        Ok(None) => (t, tyi)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturnCallRef(tyi, i0, i))))\n    }\n\n    // === Control flow ===\n    TBlock(bt, e) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e) = match self.walk_texpr(t, e) {\n        Ok(None) => (t, e)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBlock(bt, e))))\n    }\n    TLoop(bt, e) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e) = match self.walk_texpr(t, e) {\n        Ok(None) => (t, e)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TLoop(bt, e))))\n    }\n    TIf(bt, i_if, e_then, e_else_option) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i_if) = match self.walk_tinstruction(t, i_if) {\n        Ok(None) => (t, i_if)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e_then) = match self.walk_texpr(t, e_then) {\n        Ok(None) => (t, e_then)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e_else_option) = if e_else_option is Some(e_else) {\n        match self.walk_texpr(t, e_else) {\n          Ok(None) => (t, e_else_option)\n          Ok(Some((t, e_else))) => (t, Some(e_else))\n          Err(t) => return Err(t)\n        }\n      } else {\n        (t, e_else_option)\n      }\n      Ok(Some((t, TIf(bt, i_if, e_then, e_else_option))))\n    }\n    TTryTable(bt, c, e) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Ok(None) => (t, bt)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, c) = match self.walk_array(t, ModuleTransformer::walk_catch, c) {\n        Ok(None) => (t, c)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, e) = match self.walk_texpr(t, e) {\n        Ok(None) => (t, e)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TTryTable(bt, c, e))))\n    }\n    TThrow(ti, i) => {\n      let (t, ti) = match self.walk_tagidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TThrow(ti, i))))\n    }\n\n    // === Branches ===\n    TBr(li, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBr(li, i))))\n    }\n    TBrIf(li, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrIf(li, i0, i))))\n    }\n    TBrTable(ls, li, i0, i) => {\n      let (t, ls) = match\n        self.walk_array(t, ModuleTransformer::walk_labelidx, ls) {\n        Ok(None) => (t, ls)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrTable(ls, li, i0, i))))\n    }\n    TBrOnNull(li, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnNull(li, i0, i))))\n    }\n    TBrOnNonNull(li, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnNonNull(li, i0, i))))\n    }\n    TBrOnCast(li, co, ht0, ht1, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht0) = match self.walk_heaptype(t, ht0) {\n        Ok(None) => (t, ht0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Ok(None) => (t, ht1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnCast(li, co, ht0, ht1, i0, i))))\n    }\n    TBrOnCastFail(li, co, ht0, ht1, i0, i) => {\n      let (t, li) = match self.walk_labelidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht0) = match self.walk_heaptype(t, ht0) {\n        Ok(None) => (t, ht0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Ok(None) => (t, ht1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TBrOnCastFail(li, co, ht0, ht1, i0, i))))\n    }\n    TReturn(i) => {\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReturn(i))))\n    }\n\n    // === Select ===\n    TSelect(vts_option, i0, i1, i2) => {\n      let (t, vts_option) = if vts_option is Some(vts) {\n        match self.walk_array(t, ModuleTransformer::walk_valtype, vts) {\n          Ok(None) => (t, vts_option)\n          Ok(Some((t, vts))) => (t, Some(vts))\n          Err(t) => return Err(t)\n        }\n      } else {\n        (t, vts_option)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TSelect(vts_option, i0, i1, i2))))\n    }\n\n    // === GC: Structs ===\n    TStructNew(ti, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructNew(ti, i))))\n    }\n    TStructNewDefault(ti) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructNewDefault(ti))))\n    }\n    TStructGet(ti, f, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructGet(ti, f, i))))\n    }\n    TStructGetS(ti, f, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructGetS(ti, f, i))))\n    }\n    TStructGetU(ti, f, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructGetU(ti, f, i))))\n    }\n    TStructSet(ti, f, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TStructSet(ti, f, i0, i1))))\n    }\n\n    // === GC: Arrays ===\n    TArrayNew(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNew(ti, i0, i1))))\n    }\n    TArrayNewDefault(ti, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewDefault(ti, i))))\n    }\n    TArrayNewFixed(ti, i) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match\n        self.walk_array(t, ModuleTransformer::walk_tinstruction, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewFixed(ti, i))))\n    }\n    TArrayNewData(ti, di, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewData(ti, di, i0, i1))))\n    }\n    TArrayNewElem(ti, ei, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayNewElem(ti, ei, i0, i1))))\n    }\n    TArrayGet(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayGet(ti, i0, i1))))\n    }\n    TArrayGetS(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayGetS(ti, i0, i1))))\n    }\n    TArrayGetU(ti, i0, i1) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayGetU(ti, i0, i1))))\n    }\n    TArraySet(ti, i0, i1, i2) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArraySet(ti, i0, i1, i2))))\n    }\n    TArrayFill(ti, i0, i1, i2, i3) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayFill(ti, i0, i1, i2, i3))))\n    }\n    TArrayCopy(ti0, ti1, i0, i1, i2, i3, i4) => {\n      let (t, ti0) = match self.walk_typeidx(t, ti0) {\n        Ok(None) => (t, ti0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ti1) = match self.walk_typeidx(t, ti1) {\n        Ok(None) => (t, ti1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i4) = match self.walk_tinstruction(t, i4) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayCopy(ti0, ti1, i0, i1, i2, i3, i4))))\n    }\n    TArrayInitData(ti, di, i0, i1, i2, i3) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, di) = match self.walk_dataidx(t, di) {\n        Ok(None) => (t, di)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayInitData(ti, di, i0, i1, i2, i3))))\n    }\n    TArrayInitElem(ti, ei, i0, i1, i2, i3) => {\n      let (t, ti) = match self.walk_typeidx(t, ti) {\n        Ok(None) => (t, ti)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ei) = match self.walk_elemidx(t, ei) {\n        Ok(None) => (t, ei)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i3) = match self.walk_tinstruction(t, i3) {\n        Ok(None) => (t, i3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TArrayInitElem(ti, ei, i0, i1, i2, i3))))\n    }\n\n    // === GC: Casts ===\n    TRefTest(b, ht, i) => {\n      let (t, ht) = match self.walk_heaptype(t, ht) {\n        Ok(None) => (t, ht)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefTest(b, ht, i))))\n    }\n    TRefCast(b, ht, i) => {\n      let (t, ht) = match self.walk_heaptype(t, ht) {\n        Ok(None) => (t, ht)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TRefCast(b, ht, i))))\n    }\n\n    // === SIMD: Splat (scalar -> v128) ===\n    TI8x16Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI8x16Splat(i))))\n    }\n    TI16x8Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI16x8Splat(i))))\n    }\n    TI32x4Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI32x4Splat(i))))\n    }\n    TI64x2Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI64x2Splat(i))))\n    }\n    TF32x4Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TF32x4Splat(i))))\n    }\n    TF64x2Splat(i) => {\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TF64x2Splat(i))))\n    }\n\n    // === SIMD: Extract lane (v128 -> scalar) ===\n    TExtractLane(op, li, i) => {\n      let (t, op) = match self.walk_extractlaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i) = match self.walk_tinstruction(t, i) {\n        Ok(None) => (t, i)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TExtractLane(op, li, i))))\n    }\n\n    // === SIMD: Replace lane (v128, scalar -> v128) ===\n    TReplaceLane(op, li, i0, i1) => {\n      let (t, op) = match self.walk_replacelaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TReplaceLane(op, li, i0, i1))))\n    }\n\n    // === SIMD: Shuffle (v128, v128 -> v128 with 16 lane indices) ===\n    TI8x16Shuffle(\n      li0,\n      li1,\n      li2,\n      li3,\n      li4,\n      li5,\n      li6,\n      li7,\n      li8,\n      li9,\n      li10,\n      li11,\n      li12,\n      li13,\n      li14,\n      li15,\n      i0,\n      i1\n    ) => {\n      let (t, li0) = match self.walk_laneidx(t, li0) {\n        Ok(None) => (t, li0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li1) = match self.walk_laneidx(t, li1) {\n        Ok(None) => (t, li1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li2) = match self.walk_laneidx(t, li2) {\n        Ok(None) => (t, li2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li3) = match self.walk_laneidx(t, li3) {\n        Ok(None) => (t, li3)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li4) = match self.walk_laneidx(t, li4) {\n        Ok(None) => (t, li4)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li5) = match self.walk_laneidx(t, li5) {\n        Ok(None) => (t, li5)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li6) = match self.walk_laneidx(t, li6) {\n        Ok(None) => (t, li6)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li7) = match self.walk_laneidx(t, li7) {\n        Ok(None) => (t, li7)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li8) = match self.walk_laneidx(t, li8) {\n        Ok(None) => (t, li8)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li9) = match self.walk_laneidx(t, li9) {\n        Ok(None) => (t, li9)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li10) = match self.walk_laneidx(t, li10) {\n        Ok(None) => (t, li10)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li11) = match self.walk_laneidx(t, li11) {\n        Ok(None) => (t, li11)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li12) = match self.walk_laneidx(t, li12) {\n        Ok(None) => (t, li12)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li13) = match self.walk_laneidx(t, li13) {\n        Ok(None) => (t, li13)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li14) = match self.walk_laneidx(t, li14) {\n        Ok(None) => (t, li14)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li15) = match self.walk_laneidx(t, li15) {\n        Ok(None) => (t, li15)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(\n        Some(\n          (\n            t,\n            TI8x16Shuffle(\n              li0, li1, li2, li3, li4, li5, li6, li7, li8, li9, li10, li11, li12,\n              li13, li14, li15, i0, i1,\n            ),\n          ),\n        ),\n      )\n    }\n\n    // === SIMD: Swizzle (v128, v128 -> v128) ===\n    TI8x16Swizzle(i0, i1) => {\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI8x16Swizzle(i0, i1))))\n    }\n    TI8x16RelaxedSwizzle(i0, i1) => {\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TI8x16RelaxedSwizzle(i0, i1))))\n    }\n\n    // === SIMD: Shift (v128, i32 -> v128) ===\n    TV128Shift(op, i0, i1) => {\n      let (t, op) = match self.walk_v128shiftop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128Shift(op, i0, i1))))\n    }\n\n    // === SIMD: Ternary (v128, v128, v128 -> v128) ===\n    TV128Ternary(op, i0, i1, i2) => {\n      let (t, op) = match self.walk_v128ternaryop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i2) = match self.walk_tinstruction(t, i2) {\n        Ok(None) => (t, i2)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128Ternary(op, i0, i1, i2))))\n    }\n\n    // === SIMD: Lane load (v128, addr -> v128) ===\n    TV128LoadLane(op, ma, li, i0, i1) => {\n      let (t, op) = match self.walk_v128loadlaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128LoadLane(op, ma, li, i0, i1))))\n    }\n\n    // === SIMD: Lane store (v128, addr -> void) ===\n    TV128StoreLane(op, ma, li, i0, i1) => {\n      let (t, op) = match self.walk_v128storelaneop(t, op) {\n        Ok(None) => (t, op)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, ma) = match self.walk_memarg(t, ma) {\n        Ok(None) => (t, ma)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, li) = match self.walk_laneidx(t, li) {\n        Ok(None) => (t, li)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i0) = match self.walk_tinstruction(t, i0) {\n        Ok(None) => (t, i0)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      let (t, i1) = match self.walk_tinstruction(t, i1) {\n        Ok(None) => (t, i1)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TV128StoreLane(op, ma, li, i0, i1))))\n    }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_instruction(\n  self : ModuleTransformer[T],\n  t : T,\n  instr : Instruction,\n) -> TransformerResult[T, Instruction] {\n  match self.on_instruction {\n    Some(f) =>\n      match f(self, t, instr) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_instruction_default(t, instr)\n        ok => ok\n      }\n    None => self.walk_instruction_default(t, instr)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_instruction_default(\n  self : ModuleTransformer[T],\n  t : T,\n  instr : Instruction,\n) -> TransformerResult[T, Instruction] {\n  match instr {\n    // Control instructions\n    Block(bt, body) =>\n      match self.walk_blocktype(t, bt) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, body))) => Ok(Some((t, Block(bt, body))))\n          }\n        Ok(Some((t, bt))) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(Some((t, Block(bt, body))))\n            Ok(Some((t, body))) => Ok(Some((t, Block(bt, body))))\n          }\n      }\n    Loop(bt, body) =>\n      match self.walk_blocktype(t, bt) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, body))) => Ok(Some((t, Loop(bt, body))))\n          }\n        Ok(Some((t, bt))) =>\n          match self.walk_expr(t, body) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(Some((t, Loop(bt, body))))\n            Ok(Some((t, body))) => Ok(Some((t, Loop(bt, body))))\n          }\n      }\n    If(bt, then_body, else_body_opt) => {\n      let (t, bt) = match self.walk_blocktype(t, bt) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, bt)\n        Ok(Some((t, bt))) => (t, bt)\n      }\n      let (t, then_body) = match\n        self.walk_array(t, ModuleTransformer::walk_instruction, then_body) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, then_body)\n        Ok(Some((t, arr))) => (t, arr)\n      }\n      let (t, else_body_opt) = match else_body_opt {\n        None => (t, None)\n        Some(else_body) =>\n          match\n            self.walk_array(t, ModuleTransformer::walk_instruction, else_body) {\n            Err(e) => return Err(e)\n            Ok(None) => (t, Some(else_body))\n            Ok(Some((t, arr))) => (t, Some(arr))\n          }\n      }\n      Ok(Some((t, If(bt, then_body, else_body_opt))))\n    }\n    TryTable(bt, catches, body) =>\n      match self.walk_blocktype(t, bt) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_array(t, ModuleTransformer::walk_catch, catches) {\n            Err(e) => Err(e)\n            Ok(None) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(None)\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n            Ok(Some((t, catches))) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(Some((t, TryTable(bt, catches, body))))\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n          }\n        Ok(Some((t, bt))) =>\n          match self.walk_array(t, ModuleTransformer::walk_catch, catches) {\n            Err(e) => Err(e)\n            Ok(None) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(Some((t, TryTable(bt, catches, body))))\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n            Ok(Some((t, catches))) =>\n              match self.walk_expr(t, body) {\n                Err(e) => Err(e)\n                Ok(None) => Ok(Some((t, TryTable(bt, catches, body))))\n                Ok(Some((t, body))) =>\n                  Ok(Some((t, TryTable(bt, catches, body))))\n              }\n          }\n      }\n\n    // Branch instructions\n    Br(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, Br(l))))\n      }\n    BrIf(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, BrIf(l))))\n      }\n    BrTable(labels, default) =>\n      match self.walk_array(t, ModuleTransformer::walk_labelidx, labels) {\n        Err(e) => Err(e)\n        Ok(None) =>\n          match self.walk_labelidx(t, default) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, default))) => Ok(Some((t, BrTable(labels, default))))\n          }\n        Ok(Some((t, labels))) =>\n          match self.walk_labelidx(t, default) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(Some((t, BrTable(labels, default))))\n            Ok(Some((t, default))) => Ok(Some((t, BrTable(labels, default))))\n          }\n      }\n    BrOnNull(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, BrOnNull(l))))\n      }\n    BrOnNonNull(l) =>\n      match self.walk_labelidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, BrOnNonNull(l))))\n      }\n    BrOnCast(l, op, ht1, ht2) => {\n      let (t, l) = match self.walk_labelidx(t, l) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, l)\n        Ok(Some((t, l))) => (t, l)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht1)\n        Ok(Some((t, ht1))) => (t, ht1)\n      }\n      let (t, ht2) = match self.walk_heaptype(t, ht2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht2)\n        Ok(Some((t, ht2))) => (t, ht2)\n      }\n      Ok(Some((t, BrOnCast(l, op, ht1, ht2))))\n    }\n    BrOnCastFail(l, op, ht1, ht2) => {\n      let (t, l) = match self.walk_labelidx(t, l) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, l)\n        Ok(Some((t, l))) => (t, l)\n      }\n      let (t, ht1) = match self.walk_heaptype(t, ht1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht1)\n        Ok(Some((t, ht1))) => (t, ht1)\n      }\n      let (t, ht2) = match self.walk_heaptype(t, ht2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ht2)\n        Ok(Some((t, ht2))) => (t, ht2)\n      }\n      Ok(Some((t, BrOnCastFail(l, op, ht1, ht2))))\n    }\n\n    // Call instructions\n    Call(f) =>\n      match self.walk_funcidx(t, f) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, f))) => Ok(Some((t, Call(f))))\n      }\n    CallIndirect(ty, tbl) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, tbl) = match self.walk_tableidx(t, tbl) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tbl)\n        Ok(Some((t, tbl))) => (t, tbl)\n      }\n      Ok(Some((t, CallIndirect(ty, tbl))))\n    }\n    ReturnCall(f) =>\n      match self.walk_funcidx(t, f) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, f))) => Ok(Some((t, ReturnCall(f))))\n      }\n    ReturnCallIndirect(ty, tbl) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, tbl) = match self.walk_tableidx(t, tbl) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tbl)\n        Ok(Some((t, tbl))) => (t, tbl)\n      }\n      Ok(Some((t, ReturnCallIndirect(ty, tbl))))\n    }\n    CallRef(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, CallRef(ty))))\n      }\n    ReturnCallRef(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ReturnCallRef(ty))))\n      }\n\n    // Variable instructions\n    LocalGet(l) =>\n      match self.walk_localidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, LocalGet(l))))\n      }\n    LocalSet(l) =>\n      match self.walk_localidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, LocalSet(l))))\n      }\n    LocalTee(l) =>\n      match self.walk_localidx(t, l) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, l))) => Ok(Some((t, LocalTee(l))))\n      }\n    GlobalGet(g) =>\n      match self.walk_globalidx(t, g) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, g))) => Ok(Some((t, GlobalGet(g))))\n      }\n    GlobalSet(g) =>\n      match self.walk_globalidx(t, g) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, g))) => Ok(Some((t, GlobalSet(g))))\n      }\n\n    // Table instructions\n    TableGet(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableGet(tbl))))\n      }\n    TableSet(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableSet(tbl))))\n      }\n    TableGrow(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableGrow(tbl))))\n      }\n    TableSize(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableSize(tbl))))\n      }\n    TableFill(tbl) =>\n      match self.walk_tableidx(t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, tbl))) => Ok(Some((t, TableFill(tbl))))\n      }\n    TableCopy(t1, t2) => {\n      let (t, t1) = match self.walk_tableidx(t, t1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t1)\n        Ok(Some((t, t1))) => (t, t1)\n      }\n      let (t, t2) = match self.walk_tableidx(t, t2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t2)\n        Ok(Some((t, t2))) => (t, t2)\n      }\n      Ok(Some((t, TableCopy(t1, t2))))\n    }\n    TableInit(e, tbl) => {\n      let (t, e) = match self.walk_elemidx(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, e)\n        Ok(Some((t, e))) => (t, e)\n      }\n      let (t, tbl) = match self.walk_tableidx(t, tbl) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tbl)\n        Ok(Some((t, tbl))) => (t, tbl)\n      }\n      Ok(Some((t, TableInit(e, tbl))))\n    }\n    ElemDrop(e) =>\n      match self.walk_elemidx(t, e) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, e))) => Ok(Some((t, ElemDrop(e))))\n      }\n\n    // Reference instructions\n    RefNull(ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, RefNull(ht))))\n      }\n    RefFunc(f) =>\n      match self.walk_funcidx(t, f) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, f))) => Ok(Some((t, RefFunc(f))))\n      }\n    RefTest(nullable, ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, RefTest(nullable, ht))))\n      }\n    RefCast(nullable, ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, RefCast(nullable, ht))))\n      }\n\n    // Struct/Array instructions\n    StructNew(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructNew(ty))))\n      }\n    StructNewDefault(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructNewDefault(ty))))\n      }\n    StructGet(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructGet(ty, f))))\n      }\n    StructGetS(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructGetS(ty, f))))\n      }\n    StructGetU(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructGetU(ty, f))))\n      }\n    StructSet(ty, f) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, StructSet(ty, f))))\n      }\n    ArrayNew(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNew(ty))))\n      }\n    ArrayNewDefault(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNewDefault(ty))))\n      }\n    ArrayNewFixed(ty, n) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNewFixed(ty, n))))\n      }\n    ArrayNewData(ty, n) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayNewData(ty, n))))\n      }\n    ArrayNewElem(ty, e) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, e) = match self.walk_elemidx(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, e)\n        Ok(Some((t, e))) => (t, e)\n      }\n      Ok(Some((t, ArrayNewElem(ty, e))))\n    }\n    ArrayGet(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayGet(ty))))\n      }\n    ArrayGetS(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayGetS(ty))))\n      }\n    ArrayGetU(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayGetU(ty))))\n      }\n    ArraySet(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArraySet(ty))))\n      }\n    ArrayFill(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, ArrayFill(ty))))\n      }\n    ArrayCopy(t1, t2) => {\n      let (t, t1) = match self.walk_typeidx(t, t1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t1)\n        Ok(Some((t, t1))) => (t, t1)\n      }\n      let (t, t2) = match self.walk_typeidx(t, t2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, t2)\n        Ok(Some((t, t2))) => (t, t2)\n      }\n      Ok(Some((t, ArrayCopy(t1, t2))))\n    }\n    ArrayInitData(ty, d) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, d) = match self.walk_dataidx(t, d) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, d)\n        Ok(Some((t, d))) => (t, d)\n      }\n      Ok(Some((t, ArrayInitData(ty, d))))\n    }\n    ArrayInitElem(ty, e) => {\n      let (t, ty) = match self.walk_typeidx(t, ty) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ty)\n        Ok(Some((t, ty))) => (t, ty)\n      }\n      let (t, e) = match self.walk_elemidx(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, e)\n        Ok(Some((t, e))) => (t, e)\n      }\n      Ok(Some((t, ArrayInitElem(ty, e))))\n    }\n\n    // Memory instructions\n    MemorySize(m) =>\n      match self.walk_memidx(t, m) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, m))) => Ok(Some((t, MemorySize(m))))\n      }\n    MemoryGrow(m) =>\n      match self.walk_memidx(t, m) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, m))) => Ok(Some((t, MemoryGrow(m))))\n      }\n    MemoryFill(m) =>\n      match self.walk_memidx(t, m) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, m))) => Ok(Some((t, MemoryFill(m))))\n      }\n    MemoryCopy(m1, m2) => {\n      let (t, m1) = match self.walk_memidx(t, m1) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, m1)\n        Ok(Some((t, m1))) => (t, m1)\n      }\n      let (t, m2) = match self.walk_memidx(t, m2) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, m2)\n        Ok(Some((t, m2))) => (t, m2)\n      }\n      Ok(Some((t, MemoryCopy(m1, m2))))\n    }\n    MemoryInit(d, m) => {\n      let (t, d) = match self.walk_dataidx(t, d) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, d)\n        Ok(Some((t, d))) => (t, d)\n      }\n      let (t, m) = match self.walk_memidx(t, m) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, m)\n        Ok(Some((t, m))) => (t, m)\n      }\n      Ok(Some((t, MemoryInit(d, m))))\n    }\n    DataDrop(d) =>\n      match self.walk_dataidx(t, d) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, d))) => Ok(Some((t, DataDrop(d))))\n      }\n\n    // Exception instructions\n    Throw(ty) =>\n      match self.walk_tagidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, Throw(ty))))\n      }\n\n    // Select with types\n    Select(types) =>\n      match types {\n        None => Ok(None)\n        Some(types) =>\n          match self.walk_array(t, ModuleTransformer::walk_valtype, types) {\n            Err(e) => Err(e)\n            Ok(None) => Ok(None)\n            Ok(Some((t, types))) => Ok(Some((t, Select(Some(types)))))\n          }\n      }\n\n    // All other instructions pass through unchanged\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_blocktype(\n  self : ModuleTransformer[T],\n  t : T,\n  bt : BlockType,\n) -> TransformerResult[T, BlockType] {\n  match self.on_blocktype {\n    Some(f) =>\n      match f(self, t, bt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_blocktype_default(t, bt)\n        ok => ok\n      }\n    None => self.walk_blocktype_default(t, bt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_blocktype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  bt : BlockType,\n) -> TransformerResult[T, BlockType] {\n  match bt {\n    ValTypeBlockType(vt) =>\n      match self.walk_valtype(t, vt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, vt))) => Ok(Some((t, ValTypeBlockType(vt))))\n      }\n    TypeIdxBlockType(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, TypeIdxBlockType(ty))))\n      }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_catch(\n  self : ModuleTransformer[T],\n  t : T,\n  c : Catch,\n) -> TransformerResult[T, Catch] {\n  match c {\n    Catch(tag, label) => {\n      let (t, tag) = match self.walk_tagidx(t, tag) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tag)\n        Ok(Some((t, tag))) => (t, tag)\n      }\n      let (t, label) = match self.walk_labelidx(t, label) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, label)\n        Ok(Some((t, label))) => (t, label)\n      }\n      Ok(Some((t, Catch(tag, label))))\n    }\n    CatchRef(tag, label) => {\n      let (t, tag) = match self.walk_tagidx(t, tag) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tag)\n        Ok(Some((t, tag))) => (t, tag)\n      }\n      let (t, label) = match self.walk_labelidx(t, label) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, label)\n        Ok(Some((t, label))) => (t, label)\n      }\n      Ok(Some((t, CatchRef(tag, label))))\n    }\n    CatchAll(label) =>\n      match self.walk_labelidx(t, label) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, label))) => Ok(Some((t, CatchAll(label))))\n      }\n    CatchAllRef(label) =>\n      match self.walk_labelidx(t, label) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, label))) => Ok(Some((t, CatchAllRef(label))))\n      }\n  }\n}\n\n// Index walkers - leaf nodes\n\n///|\npub fn[T] ModuleTransformer::walk_funcidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : FuncIdx,\n) -> TransformerResult[T, FuncIdx] {\n  match self.on_funcidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_typeidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : TypeIdx,\n) -> TransformerResult[T, TypeIdx] {\n  match self.on_typeidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_localidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : LocalIdx,\n) -> TransformerResult[T, LocalIdx] {\n  match self.on_localidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globalidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : GlobalIdx,\n) -> TransformerResult[T, GlobalIdx] {\n  match self.on_globalidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tableidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : TableIdx,\n) -> TransformerResult[T, TableIdx] {\n  match self.on_tableidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : MemIdx,\n) -> TransformerResult[T, MemIdx] {\n  match self.on_memidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_labelidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : LabelIdx,\n) -> TransformerResult[T, LabelIdx] {\n  match self.on_labelidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_laneidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : LaneIdx,\n) -> TransformerResult[T, LaneIdx] {\n  match self.on_laneidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_dataidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : DataIdx,\n) -> TransformerResult[T, DataIdx] {\n  match self.on_dataidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : ElemIdx,\n) -> TransformerResult[T, ElemIdx] {\n  match self.on_elemidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagidx(\n  self : ModuleTransformer[T],\n  t : T,\n  idx : TagIdx,\n) -> TransformerResult[T, TagIdx] {\n  match self.on_tagidx {\n    Some(f) => f(self, t, idx)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_valtype(\n  self : ModuleTransformer[T],\n  t : T,\n  vt : ValType,\n) -> TransformerResult[T, ValType] {\n  match self.on_valtype {\n    Some(f) =>\n      match f(self, t, vt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_valtype_default(t, vt)\n        ok => ok\n      }\n    None => self.walk_valtype_default(t, vt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_valtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  vt : ValType,\n) -> TransformerResult[T, ValType] {\n  match vt {\n    RefTypeValType(rt) =>\n      match self.walk_reftype(t, rt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, rt))) => Ok(Some((t, RefTypeValType(rt))))\n      }\n    NumTypeValType(nt) =>\n      match self.walk_numtype(t, nt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, nt))) => Ok(Some((t, NumTypeValType(nt))))\n      }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_numtype(\n  self : ModuleTransformer[T],\n  t : T,\n  nt : NumType,\n) -> TransformerResult[T, NumType] {\n  match self.on_numtype {\n    Some(f) => f(self, t, nt)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_reftype(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RefType,\n) -> TransformerResult[T, RefType] {\n  match self.on_reftype {\n    Some(f) =>\n      match f(self, t, rt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_reftype_default(t, rt)\n        ok => ok\n      }\n    None => self.walk_reftype_default(t, rt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_reftype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RefType,\n) -> TransformerResult[T, RefType] {\n  match rt {\n    HeapTypeRefType(nullable, ht) =>\n      match self.walk_heaptype(t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ht))) => Ok(Some((t, HeapTypeRefType(nullable, ht))))\n      }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_heaptype(\n  self : ModuleTransformer[T],\n  t : T,\n  ht : HeapType,\n) -> TransformerResult[T, HeapType] {\n  match self.on_heaptype {\n    Some(f) =>\n      match f(self, t, ht) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_heaptype_default(t, ht)\n        ok => ok\n      }\n    None => self.walk_heaptype_default(t, ht)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_heaptype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ht : HeapType,\n) -> TransformerResult[T, HeapType] {\n  match ht {\n    HeapType(ty) =>\n      match self.walk_typeidx(t, ty) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ty))) => Ok(Some((t, HeapType(ty))))\n      }\n    _ => Ok(None)\n  }\n}\n\n// Sections\n\n///|\npub fn[T] ModuleTransformer::walk_customsec(\n  self : ModuleTransformer[T],\n  t : T,\n  sec : CustomSec,\n) -> TransformerResult[T, CustomSec] {\n  let CustomSec(n, d) = sec\n  match self.walk_name(t, n) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, n))) => Ok(Some((t, CustomSec(n, d))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_customsecs(\n  self : ModuleTransformer[T],\n  t : T,\n  secs : Array[CustomSec],\n) -> TransformerResult[T, Array[CustomSec]] {\n  self.walk_array(t, ModuleTransformer::walk_customsec, secs)\n}\n\n///|\npub fn[T] ModuleTransformer::walk_module(\n  self : ModuleTransformer[T],\n  t : T,\n  mod : Module,\n) -> TransformerResult[T, Module] {\n  let Module(\n    custom,\n    type_sec,\n    import_sec,\n    func_sec,\n    table_sec,\n    mem_sec,\n    tag_sec,\n    global_sec,\n    export_sec,\n    start_sec,\n    elem_sec,\n    datacnt_sec,\n    code_sec,\n    data_sec\n  ) = mod\n  let (t, custom) = match self.walk_customsecs(t, custom) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, custom)\n    Ok(Some(v)) => v\n  }\n  let (t, type_sec) = match type_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_typesec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, import_sec) = match import_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_importsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, func_sec) = match func_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_funcsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, table_sec) = match table_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_tablesec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, mem_sec) = match mem_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_memsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, tag_sec) = match tag_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_tagsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, global_sec) = match global_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_globalsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, export_sec) = match export_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_exportsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, start_sec) = match start_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_startsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, elem_sec) = match elem_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_elemsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, datacnt_sec) = match datacnt_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_datacntsec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, code_sec) = match code_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_codesec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  let (t, data_sec) = match data_sec {\n    None => (t, None)\n    Some(sec) =>\n      match self.walk_datasec(t, sec) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(sec))\n        Ok(Some((t, sec))) => (t, Some(sec))\n      }\n  }\n  Ok(\n    Some(\n      (\n        t,\n        Module(\n          custom, type_sec, import_sec, func_sec, table_sec, mem_sec, tag_sec, global_sec,\n          export_sec, start_sec, elem_sec, datacnt_sec, code_sec, data_sec,\n        ),\n      ),\n    ),\n  )\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datasec(\n  self : ModuleTransformer[T],\n  t : T,\n  ds : DataSec,\n) -> TransformerResult[T, DataSec] {\n  match self.on_datasec {\n    Some(f) =>\n      match f(self, t, ds) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_datasec_default(t, ds)\n        ok => ok\n      }\n    None => self.walk_datasec_default(t, ds)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datasec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ds : DataSec,\n) -> TransformerResult[T, DataSec] {\n  let DataSec(ds) = ds\n  match self.walk_array(t, ModuleTransformer::walk_data, ds) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, ds))) => Ok(Some((t, DataSec(ds))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_codesec(\n  self : ModuleTransformer[T],\n  t : T,\n  cs : CodeSec,\n) -> TransformerResult[T, CodeSec] {\n  match self.on_codesec {\n    Some(f) =>\n      match f(self, t, cs) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_codesec_default(t, cs)\n        ok => ok\n      }\n    None => self.walk_codesec_default(t, cs)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_codesec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  cs : CodeSec,\n) -> TransformerResult[T, CodeSec] {\n  let CodeSec(fs) = cs\n  match self.walk_array(t, ModuleTransformer::walk_func, fs) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, fs))) => Ok(Some((t, CodeSec(fs))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datacntsec(\n  self : ModuleTransformer[T],\n  t : T,\n  dcs : DataCntSec,\n) -> TransformerResult[T, DataCntSec] {\n  match self.on_datacntsec {\n    Some(f) => f(self, t, dcs)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemsec(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ElemSec,\n) -> TransformerResult[T, ElemSec] {\n  match self.on_elemsec {\n    Some(f) =>\n      match f(self, t, es) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_elemsec_default(t, es)\n        ok => ok\n      }\n    None => self.walk_elemsec_default(t, es)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ElemSec,\n) -> TransformerResult[T, ElemSec] {\n  let ElemSec(es) = es\n  match self.walk_array(t, ModuleTransformer::walk_elem, es) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, es))) => Ok(Some((t, ElemSec(es))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_startsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ss : StartSec,\n) -> TransformerResult[T, StartSec] {\n  match self.on_startsec {\n    Some(f) =>\n      match f(self, t, ss) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_startsec_default(t, ss)\n        ok => ok\n      }\n    None => self.walk_startsec_default(t, ss)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_startsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ss : StartSec,\n) -> TransformerResult[T, StartSec] {\n  let StartSec(fidx) = ss\n  match self.walk_funcidx(t, fidx) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, fidx))) => Ok(Some((t, StartSec(fidx))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_exportsec(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ExportSec,\n) -> TransformerResult[T, ExportSec] {\n  match self.on_exportsec {\n    Some(f) =>\n      match f(self, t, es) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_exportsec_default(t, es)\n        ok => ok\n      }\n    None => self.walk_exportsec_default(t, es)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_exportsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  es : ExportSec,\n) -> TransformerResult[T, ExportSec] {\n  let ExportSec(es) = es\n  match self.walk_array(t, ModuleTransformer::walk_export, es) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, es))) => Ok(Some((t, ExportSec(es))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TagSec,\n) -> TransformerResult[T, TagSec] {\n  match self.on_tagsec {\n    Some(f) =>\n      match f(self, t, ts) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_tagsec_default(t, ts)\n        ok => ok\n      }\n    None => self.walk_tagsec_default(t, ts)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TagSec,\n) -> TransformerResult[T, TagSec] {\n  let TagSec(tags) = ts\n  match self.walk_array(t, ModuleTransformer::walk_tagtype, tags) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, tags))) => Ok(Some((t, TagSec(tags))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ms : MemSec,\n) -> TransformerResult[T, MemSec] {\n  match self.on_memsec {\n    Some(f) =>\n      match f(self, t, ms) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_memsec_default(t, ms)\n        ok => ok\n      }\n    None => self.walk_memsec_default(t, ms)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ms : MemSec,\n) -> TransformerResult[T, MemSec] {\n  let MemSec(m) = ms\n  match self.walk_array(t, ModuleTransformer::walk_memtype, m) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, m))) => Ok(Some((t, MemSec(m))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tablesec(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TableSec,\n) -> TransformerResult[T, TableSec] {\n  match self.on_tablesec {\n    Some(f) =>\n      match f(self, t, ts) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_tablesec_default(t, ts)\n        ok => ok\n      }\n    None => self.walk_tablesec_default(t, ts)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tablesec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TableSec,\n) -> TransformerResult[T, TableSec] {\n  let TableSec(tts) = ts\n  match self.walk_array(t, ModuleTransformer::walk_table, tts) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, tts))) => Ok(Some((t, TableSec(tts))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_func(\n  self : ModuleTransformer[T],\n  t : T,\n  func : Func,\n) -> TransformerResult[T, Func] {\n  match self.on_func {\n    Some(f) =>\n      match f(self, t, func) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_func_default(t, func)\n        ok => ok\n      }\n    None => self.walk_func_default(t, func)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_func_default(\n  self : ModuleTransformer[T],\n  t : T,\n  f : Func,\n) -> TransformerResult[T, Func] {\n  match f {\n    Func(locals, body) => {\n      let mut locals = locals\n      let t = match self.walk_locals(t, locals) {\n        Err(e) => return Err(e)\n        Ok(None) => t\n        Ok(Some((t, ls))) => {\n          locals = ls\n          t\n        }\n      }\n      match self.walk_expr(t, body) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, body))) => Ok(Some((t, Func(locals, body))))\n      }\n    }\n    TFunc(locals, tbody) => {\n      let (t, locals) = match\n        self.walk_array(t, ModuleTransformer::walk_valtype, locals) {\n        Ok(None) => (t, locals)\n        Ok(Some((t, locals))) => (t, locals)\n        Err(t) => return Err(t)\n      }\n      let (t, tbody) = match self.walk_texpr(t, tbody) {\n        Ok(None) => (t, tbody)\n        Ok(Some(t)) => t\n        Err(t) => return Err(t)\n      }\n      Ok(Some((t, TFunc(locals, tbody))))\n    }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_locals(\n  self : ModuleTransformer[T],\n  t : T,\n  l : Array[Locals],\n) -> TransformerResult[T, Array[Locals]] {\n  match self.on_locals {\n    Some(f) => f(self, t, l)\n    None => self.walk_locals_default(t, l)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_locals_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ls : Array[Locals],\n) -> TransformerResult[T, Array[Locals]] {\n  self.walk_array(t, ModuleTransformer::walk_single_local, ls)\n}\n\n///|\npub fn[T] ModuleTransformer::walk_single_local(\n  self : ModuleTransformer[T],\n  t : T,\n  l : Locals,\n) -> TransformerResult[T, Locals] {\n  let Locals(count, vt) = l\n  match self.walk_valtype(t, vt) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, vt))) => Ok(Some((t, Locals(count, vt))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_importsec(\n  self : ModuleTransformer[T],\n  t : T,\n  ims : ImportSec,\n) -> TransformerResult[T, ImportSec] {\n  let ImportSec(ims) = ims\n  match self.walk_array(t, ModuleTransformer::walk_import, ims) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, ims))) => Ok(Some((t, ImportSec(ims))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_export(\n  self : ModuleTransformer[T],\n  t : T,\n  expt : Export,\n) -> TransformerResult[T, Export] {\n  match self.on_export {\n    Some(f) =>\n      match f(self, t, expt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_export_default(t, expt)\n        ok => ok\n      }\n    None => self.walk_export_default(t, expt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_export_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : Export,\n) -> TransformerResult[T, Export] {\n  let Export(n, ei) = ex\n  let (t, n) = match self.walk_name(t, n) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, n)\n    Ok(Some((t, n))) => (t, n)\n  }\n  let (t, ei) = match self.walk_externidx(t, ei) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, ei)\n    Ok(Some((t, ei))) => (t, ei)\n  }\n  Ok(Some((t, Export(n, ei))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_externidx(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : ExternIdx,\n) -> TransformerResult[T, ExternIdx] {\n  match self.on_externidx {\n    Some(f) =>\n      match f(self, t, ex) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_externidx_default(t, ex)\n        ok => ok\n      }\n    None => self.walk_externidx_default(t, ex)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_externidx_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : ExternIdx,\n) -> TransformerResult[T, ExternIdx] {\n  match ex {\n    FuncExternIdx(fi) =>\n      match self.walk_funcidx(t, fi) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, fi))) => Ok(Some((t, FuncExternIdx(fi))))\n      }\n    TableExternIdx(ti) =>\n      match self.walk_tableidx(t, ti) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ti))) => Ok(Some((t, TableExternIdx(ti))))\n      }\n    MemExternIdx(mi) =>\n      match self.walk_memidx(t, mi) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, mi))) => Ok(Some((t, MemExternIdx(mi))))\n      }\n    GlobalExternIdx(gi) =>\n      match self.walk_globalidx(t, gi) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, gi))) => Ok(Some((t, GlobalExternIdx(gi))))\n      }\n    TagExternIdx(ti) =>\n      match self.walk_tagidx(t, ti) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ti))) => Ok(Some((t, TagExternIdx(ti))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_table(\n  self : ModuleTransformer[T],\n  t : T,\n  tbl : Table,\n) -> TransformerResult[T, Table] {\n  match self.on_table {\n    Some(f) =>\n      match f(self, t, tbl) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_table_default(t, tbl)\n        ok => ok\n      }\n    None => self.walk_table_default(t, tbl)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_table_default(\n  self : ModuleTransformer[T],\n  t : T,\n  tbl : Table,\n) -> TransformerResult[T, Table] {\n  let Table(tt, e_option) = tbl\n  let (t, tt) = match self.walk_tabletype(t, tt) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, tt)\n    Ok(Some((t, tt))) => (t, tt)\n  }\n  let (t, e_option) = match e_option {\n    None => (t, None)\n    Some(e) =>\n      match self.walk_expr(t, e) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, Some(e))\n        Ok(Some((t, e))) => (t, Some(e))\n      }\n  }\n  Ok(Some((t, Table(tt, e_option))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_import(\n  self : ModuleTransformer[T],\n  t : T,\n  im : Import,\n) -> TransformerResult[T, Import] {\n  let Import(n1, n2, ty) = im\n  let (t, n1) = match self.walk_name(t, n1) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, n1)\n    Ok(Some((t, n1))) => (t, n1)\n  }\n  let (t, n2) = match self.walk_name(t, n2) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, n2)\n    Ok(Some((t, n2))) => (t, n2)\n  }\n  let (t, ty) = match self.walk_externtype(t, ty) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, ty)\n    Ok(Some((t, ty))) => (t, ty)\n  }\n  Ok(Some((t, Import(n1, n2, ty))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_externtype(\n  self : ModuleTransformer[T],\n  t : T,\n  ex : ExternType,\n) -> TransformerResult[T, ExternType] {\n  match self.on_externtype {\n    Some(f) => f(self, t, ex)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagtype(\n  self : ModuleTransformer[T],\n  t : T,\n  tt : TagType,\n) -> TransformerResult[T, TagType] {\n  match self.on_tagtype {\n    Some(f) =>\n      match f(self, t, tt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_tagtype_default(t, tt)\n        ok => ok\n      }\n    None => self.walk_tagtype_default(t, tt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tagtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  tt : TagType,\n) -> TransformerResult[T, TagType] {\n  let TagType(ti) = tt\n  match self.walk_typeidx(t, ti) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, ti))) => Ok(Some((t, TagType(ti))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memtype(\n  self : ModuleTransformer[T],\n  t : T,\n  mt : MemType,\n) -> TransformerResult[T, MemType] {\n  match self.on_memtype {\n    Some(f) =>\n      match f(self, t, mt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_memtype_default(t, mt)\n        ok => ok\n      }\n    None => self.walk_memtype_default(t, mt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  mt : MemType,\n) -> TransformerResult[T, MemType] {\n  let MemType(l) = mt\n  match self.walk_limits(t, l) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, l))) => Ok(Some((t, MemType(l))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_tabletype(\n  self : ModuleTransformer[T],\n  t : T,\n  tt : TableType,\n) -> TransformerResult[T, TableType] {\n  let TableType(rt, l) = tt\n  let (t, rt) = match self.walk_reftype(t, rt) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, rt)\n    Ok(Some((t, rt))) => (t, rt)\n  }\n  let (t, l) = match self.walk_limits(t, l) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, l)\n    Ok(Some((t, l))) => (t, l)\n  }\n  Ok(Some((t, TableType(rt, l))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_limits(\n  self : ModuleTransformer[T],\n  t : T,\n  l : Limits,\n) -> TransformerResult[T, Limits] {\n  match self.on_limits {\n    Some(f) => f(self, t, l)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_typesec(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TypeSec,\n) -> TransformerResult[T, TypeSec] {\n  match self.on_typesec {\n    Some(f) =>\n      match f(self, t, ts) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_typesec_default(t, ts)\n        ok => ok\n      }\n    None => self.walk_typesec_default(t, ts)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_typesec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ts : TypeSec,\n) -> TransformerResult[T, TypeSec] {\n  let TypeSec(rectypes) = ts\n  match self.walk_array(t, ModuleTransformer::walk_rectype, rectypes) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, rectypes))) => Ok(Some((t, TypeSec(rectypes))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_rectype(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RecType,\n) -> TransformerResult[T, RecType] {\n  match self.on_rectype {\n    Some(f) =>\n      match f(self, t, rt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_rectype_default(t, rt)\n        ok => ok\n      }\n    None => self.walk_rectype_default(t, rt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_rectype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  rt : RecType,\n) -> TransformerResult[T, RecType] {\n  match rt {\n    SingleRecType(st) =>\n      match self.walk_subtype(t, st) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, st))) => Ok(Some((t, SingleRecType(st))))\n      }\n    GroupRecType(sts) =>\n      match self.walk_array(t, ModuleTransformer::walk_subtype, sts) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, sts))) => Ok(Some((t, GroupRecType(sts))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_subtype(\n  self : ModuleTransformer[T],\n  t : T,\n  st : SubType,\n) -> TransformerResult[T, SubType] {\n  match self.on_subtype {\n    Some(f) =>\n      match f(self, t, st) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_subtype_default(t, st)\n        ok => ok\n      }\n    None => self.walk_subtype_default(t, st)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_subtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  st : SubType,\n) -> TransformerResult[T, SubType] {\n  match st {\n    SubType(f, supers, ct) => {\n      let (t, supers) = match\n        self.walk_array(t, ModuleTransformer::walk_typeidx, supers) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, supers)\n        Ok(Some((t, supers))) => (t, supers)\n      }\n      let (t, ct) = match self.walk_comptype(t, ct) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, ct)\n        Ok(Some((t, ct))) => (t, ct)\n      }\n      Ok(Some((t, SubType(f, supers, ct))))\n    }\n    CompTypeSubType(ct) =>\n      match self.walk_comptype(t, ct) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ct))) => Ok(Some((t, CompTypeSubType(ct))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_comptype(\n  self : ModuleTransformer[T],\n  t : T,\n  ct : CompType,\n) -> TransformerResult[T, CompType] {\n  match self.on_comptype {\n    Some(f) =>\n      match f(self, t, ct) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_comptype_default(t, ct)\n        ok => ok\n      }\n    None => self.walk_comptype_default(t, ct)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_comptype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ct : CompType,\n) -> TransformerResult[T, CompType] {\n  match ct {\n    FuncCompType(params, results) => {\n      let (t, params) = match\n        self.walk_array(t, ModuleTransformer::walk_valtype, params) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, params)\n        Ok(Some((t, params))) => (t, params)\n      }\n      let (t, results) = match\n        self.walk_array(t, ModuleTransformer::walk_valtype, results) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, results)\n        Ok(Some((t, results))) => (t, results)\n      }\n      Ok(Some((t, FuncCompType(params, results))))\n    }\n    StructCompType(fields) =>\n      match self.walk_array(t, ModuleTransformer::walk_fieldtype, fields) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, fields))) => Ok(Some((t, StructCompType(fields))))\n      }\n    ArrayCompType(ft) =>\n      match self.walk_fieldtype(t, ft) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, ft))) => Ok(Some((t, ArrayCompType(ft))))\n      }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_fieldtype(\n  self : ModuleTransformer[T],\n  t : T,\n  ft : FieldType,\n) -> TransformerResult[T, FieldType] {\n  match self.on_fieldtype {\n    Some(f) =>\n      match f(self, t, ft) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_fieldtype_default(t, ft)\n        ok => ok\n      }\n    None => self.walk_fieldtype_default(t, ft)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_fieldtype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  ft : FieldType,\n) -> TransformerResult[T, FieldType] {\n  let FieldType(st, mut_) = ft\n  match self.walk_storagetype(t, st) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, st))) => Ok(Some((t, FieldType(st, mut_))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_storagetype(\n  self : ModuleTransformer[T],\n  t : T,\n  st : StorageType,\n) -> TransformerResult[T, StorageType] {\n  match self.on_storagetype {\n    Some(f) =>\n      match f(self, t, st) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_storagetype_default(t, st)\n        ok => ok\n      }\n    None => self.walk_storagetype_default(t, st)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_storagetype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  st : StorageType,\n) -> TransformerResult[T, StorageType] {\n  match st {\n    ValTypeStorageType(vt) =>\n      match self.walk_valtype(t, vt) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, vt))) => Ok(Some((t, ValTypeStorageType(vt))))\n      }\n    PackTypeStorageType(_) => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globalsec(\n  self : ModuleTransformer[T],\n  t : T,\n  gs : GlobalSec,\n) -> TransformerResult[T, GlobalSec] {\n  match self.on_globalsec {\n    Some(f) =>\n      match f(self, t, gs) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_globalsec_default(t, gs)\n        ok => ok\n      }\n    None => self.walk_globalsec_default(t, gs)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globalsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  gs : GlobalSec,\n) -> TransformerResult[T, GlobalSec] {\n  let GlobalSec(gs) = gs\n  match self.walk_array(t, ModuleTransformer::walk_global, gs) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, gs))) => Ok(Some((t, GlobalSec(gs))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_global(\n  self : ModuleTransformer[T],\n  t : T,\n  g : Global,\n) -> TransformerResult[T, Global] {\n  match self.on_global {\n    Some(f) =>\n      match f(self, t, g) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_global_default(t, g)\n        ok => ok\n      }\n    None => self.walk_global_default(t, g)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_global_default(\n  self : ModuleTransformer[T],\n  t : T,\n  g : Global,\n) -> TransformerResult[T, Global] {\n  let Global(gt, init) = g\n  let (t, gt) = match self.walk_globaltype(t, gt) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, gt)\n    Ok(Some((t, gt))) => (t, gt)\n  }\n  let (t, init) = match self.walk_expr(t, init) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, init)\n    Ok(Some((t, init))) => (t, init)\n  }\n  Ok(Some((t, Global(gt, init))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globaltype(\n  self : ModuleTransformer[T],\n  t : T,\n  gt : GlobalType,\n) -> TransformerResult[T, GlobalType] {\n  match self.on_globaltype {\n    Some(f) =>\n      match f(self, t, gt) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_globaltype_default(t, gt)\n        ok => ok\n      }\n    None => self.walk_globaltype_default(t, gt)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_globaltype_default(\n  self : ModuleTransformer[T],\n  t : T,\n  gt : GlobalType,\n) -> TransformerResult[T, GlobalType] {\n  let GlobalType(vt, mutable) = gt\n  match self.walk_valtype(t, vt) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, vt))) => Ok(Some((t, GlobalType(vt, mutable))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elem(\n  self : ModuleTransformer[T],\n  t : T,\n  e : Elem,\n) -> TransformerResult[T, Elem] {\n  let Elem(mode, kind) = e\n  let (t, mode) = match self.walk_elemmode(t, mode) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, mode)\n    Ok(Some((t, mode))) => (t, mode)\n  }\n  let (t, kind) = match self.walk_elemkind(t, kind) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, kind)\n    Ok(Some((t, kind))) => (t, kind)\n  }\n  Ok(Some((t, Elem(mode, kind))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemmode(\n  self : ModuleTransformer[T],\n  t : T,\n  mode : ElemMode,\n) -> TransformerResult[T, ElemMode] {\n  match mode {\n    Active(tidx, offset) => {\n      let (t, tidx) = match self.walk_tableidx(t, tidx) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, tidx)\n        Ok(Some((t, tidx))) => (t, tidx)\n      }\n      let (t, offset) = match self.walk_expr(t, offset) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, offset)\n        Ok(Some((t, offset))) => (t, offset)\n      }\n      Ok(Some((t, Active(tidx, offset))))\n    }\n    _ => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemkind(\n  self : ModuleTransformer[T],\n  t : T,\n  ek : ElemKind,\n) -> TransformerResult[T, ElemKind] {\n  match self.on_elemkind {\n    Some(f) =>\n      match f(self, t, ek) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_elemkind_default(t, ek)\n        ok => ok\n      }\n    None => self.walk_elemkind_default(t, ek)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_elemkind_default(\n  self : ModuleTransformer[T],\n  t : T,\n  kind : ElemKind,\n) -> TransformerResult[T, ElemKind] {\n  match kind {\n    FuncsElemKind(idxs) =>\n      match self.walk_array(t, ModuleTransformer::walk_funcidx, idxs) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, idxs))) => Ok(Some((t, FuncsElemKind(idxs))))\n      }\n    FuncExprsElemKind(exprs) =>\n      match self.walk_array(t, ModuleTransformer::walk_expr, exprs) {\n        Err(e) => Err(e)\n        Ok(None) => Ok(None)\n        Ok(Some((t, exprs))) => Ok(Some((t, FuncExprsElemKind(exprs))))\n      }\n    TypedExprsElemKind(rt, exprs) => {\n      let (t, rt) = match self.walk_reftype(t, rt) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, rt)\n        Ok(Some((t, rt))) => (t, rt)\n      }\n      let (t, exprs) = match\n        self.walk_array(t, ModuleTransformer::walk_expr, exprs) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, exprs)\n        Ok(Some((t, exprs))) => (t, exprs)\n      }\n      Ok(Some((t, TypedExprsElemKind(rt, exprs))))\n    }\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_data(\n  self : ModuleTransformer[T],\n  t : T,\n  d : Data,\n) -> TransformerResult[T, Data] {\n  let Data(mode, bytes) = d\n  let (t, mode) = match self.walk_datamode(t, mode) {\n    Err(e) => return Err(e)\n    Ok(None) => (t, mode)\n    Ok(Some((t, mode))) => (t, mode)\n  }\n  Ok(Some((t, Data(mode, bytes))))\n}\n\n///|\npub fn[T] ModuleTransformer::walk_datamode(\n  self : ModuleTransformer[T],\n  t : T,\n  mode : DataMode,\n) -> TransformerResult[T, DataMode] {\n  match mode {\n    Active(midx, offset) => {\n      let (t, midx) = match self.walk_memidx(t, midx) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, midx)\n        Ok(Some((t, midx))) => (t, midx)\n      }\n      let (t, offset) = match self.walk_expr(t, offset) {\n        Err(e) => return Err(e)\n        Ok(None) => (t, offset)\n        Ok(Some((t, offset))) => (t, offset)\n      }\n      Ok(Some((t, Active(midx, offset))))\n    }\n    Passive => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_funcsec(\n  self : ModuleTransformer[T],\n  t : T,\n  fs : FuncSec,\n) -> TransformerResult[T, FuncSec] {\n  match self.on_funcsec {\n    Some(f) =>\n      match f(self, t, fs) {\n        Err(e) => Err(e)\n        Ok(None) => self.walk_funcsec_default(t, fs)\n        ok => ok\n      }\n    None => self.walk_funcsec_default(t, fs)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_funcsec_default(\n  self : ModuleTransformer[T],\n  t : T,\n  fs : FuncSec,\n) -> TransformerResult[T, FuncSec] {\n  let FuncSec(idxs) = fs\n  match self.walk_array(t, ModuleTransformer::walk_typeidx, idxs) {\n    Err(e) => Err(e)\n    Ok(None) => Ok(None)\n    Ok(Some((t, idxs))) => Ok(Some((t, FuncSec(idxs))))\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_unaryop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : UnaryOp,\n) -> TransformerResult[T, UnaryOp] {\n  match self.on_unaryop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_binaryop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : BinaryOp,\n) -> TransformerResult[T, BinaryOp] {\n  match self.on_binaryop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_storeop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : StoreOp,\n) -> TransformerResult[T, StoreOp] {\n  match self.on_storeop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_memarg(\n  self : ModuleTransformer[T],\n  t : T,\n  ma : MemArg,\n) -> TransformerResult[T, MemArg] {\n  match self.on_memarg {\n    Some(f) => f(self, t, ma)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_loadop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : LoadOp,\n) -> TransformerResult[T, LoadOp] {\n  match self.on_loadop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_extractlaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : ExtractLaneOp,\n) -> TransformerResult[T, ExtractLaneOp] {\n  match self.on_extractlaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_replacelaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : ReplaceLaneOp,\n) -> TransformerResult[T, ReplaceLaneOp] {\n  match self.on_replacelaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128shiftop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128ShiftOp,\n) -> TransformerResult[T, V128ShiftOp] {\n  match self.on_v128shiftop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128ternaryop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128TernaryOp,\n) -> TransformerResult[T, V128TernaryOp] {\n  match self.on_v128ternaryop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128loadlaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128LoadLaneOp,\n) -> TransformerResult[T, V128LoadLaneOp] {\n  match self.on_v128loadlaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n\n///|\npub fn[T] ModuleTransformer::walk_v128storelaneop(\n  self : ModuleTransformer[T],\n  t : T,\n  op : V128StoreLaneOp,\n) -> TransformerResult[T, V128StoreLaneOp] {\n  match self.on_v128storelaneop {\n    Some(f) => f(self, t, op)\n    None => Ok(None)\n  }\n}\n","///|\npub(all) struct S33(UInt) derive(Eq, Hash)\n\n///|\npub(all) struct I32(Int) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct I64(Int64) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct F32(Float) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct F64(Double) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct U32(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct U64(UInt64) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum NumType {\n  F32NumType\n  F64NumType\n  I32NumType\n  I64NumType\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum AbsHeapType {\n  ExnAbsHeapType\n  ArrayAbsHeapType\n  StructAbsHeapType\n  I31AbsHeapType\n  EqAbsHeapType\n  AnyAbsHeapType\n  ExternAbsHeapType\n  FuncAbsHeapType\n  NoneAbsHeapType\n  NoExternAbsHeapType\n  NoFuncAbsHeapType\n  NoExnAbsHeapType\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum HeapType {\n  AbsHeapTypeHeapType(AbsHeapType)\n  HeapType(TypeIdx)\n  DefTypeHeapType(DefType)\n} derive(Eq, Hash)\n\n///|\npub(all) enum RefType {\n  HeapTypeRefType(Bool, HeapType)\n  AbsHeapTypeRefType(AbsHeapType)\n} derive(Arbitrary, Hash)\n\n///|\npub(all) enum ValType {\n  NumTypeValType(NumType)\n  VecTypeValType\n  RefTypeValType(RefType)\n  BotValType\n} derive(Eq, Hash)\n\n///|\npub type ResultType = Array[ValType]\n\n///|\npub(all) enum PackType {\n  I16PackType\n  I8PackType\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum StorageType {\n  ValTypeStorageType(ValType)\n  PackTypeStorageType(PackType)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct FieldType(StorageType, Mut) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum Mut {\n  Const\n  Var\n} derive(Arbitrary, Eq, Hash)\n\n///|\npub(all) enum TypeIdx {\n  TypeIdx(UInt)\n  RecIdx(UInt)\n} derive(Eq, Hash)\n\n///|\npub(all) struct FuncIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TableIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct GlobalIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TagIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ElemIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct DataIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct LocalIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct LabelIdx(UInt) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct LaneIdx(Byte) derive(Eq, Hash)\n\n///|\npub(all) enum CompType {\n  ArrayCompType(FieldType)\n  StructCompType(Array[FieldType])\n  FuncCompType(ResultType, ResultType)\n} derive(Eq, Hash)\n\n///|\npub(all) enum SubType {\n  SubType(Bool, Array[TypeIdx], CompType)\n  CompTypeSubType(CompType)\n} derive(Eq, Hash)\n\n///|\npub(all) enum RecType {\n  SingleRecType(SubType)\n  GroupRecType(Array[SubType])\n} derive(Hash)\n\n///|\npub(all) struct DefType(RecType, UInt) derive(Eq, Hash)\n\n///|\npub(all) enum Limits {\n  I32Limits(UInt, UInt?)\n  I64Limits(UInt64, UInt64?)\n} derive(Eq, Hash)\n\n///|\npub(all) struct TagType(TypeIdx) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct GlobalType(ValType, Bool) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemType(Limits) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TableType(RefType, Limits) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ExternType {\n  FuncExternType(TypeIdx)\n  TableExternType(TableType)\n  MemExternType(MemType)\n  GlobalExternType(GlobalType)\n  TagExternType(TagType)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ExternIdx {\n  FuncExternIdx(FuncIdx)\n  TableExternIdx(TableIdx)\n  MemExternIdx(MemIdx)\n  GlobalExternIdx(GlobalIdx)\n  TagExternIdx(TagIdx)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ElemMode {\n  Passive\n  Active(TableIdx, Expr)\n  Declarative\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum ElemKind {\n  FuncsElemKind(Array[FuncIdx])\n  FuncExprsElemKind(Array[Expr])\n  TypedExprsElemKind(RefType, Array[Expr])\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Elem(ElemMode, ElemKind) derive(Eq, Hash)\n\n///|\npub(all) struct Expr(Array[Instruction]) derive(Eq, Hash)\n\n///|\npub(all) struct Import(Name, Name, ExternType) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Table(TableType, Expr?) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Global(GlobalType, Expr) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Export(Name, ExternIdx) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Locals(UInt, ValType) derive(Eq, Hash)\n\n///|\npub(all) enum DataMode {\n  Active(MemIdx, Expr)\n  Passive\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct Data(DataMode, Bytes) derive(Eq, Hash)\n\n///|\npub(all) struct Name(StringView) derive(Eq, Hash)\n\n///|\npub(all) struct Module(\n  Array[CustomSec],\n  TypeSec?,\n  ImportSec?,\n  FuncSec?,\n  TableSec?,\n  MemSec?,\n  TagSec?,\n  GlobalSec?,\n  ExportSec?,\n  StartSec?,\n  ElemSec?,\n  DataCntSec?,\n  CodeSec?,\n  DataSec?\n) derive(Hash)\n\n///|\npub(all) struct FuncType(Array[ValType], Array[ValType]) derive(Hash)\n\n///|\npub(all) struct Env {\n  global_types : Array[SubType]\n  rec_stack : Stack[Array[SubType]]\n  funcs : Array[FuncType]\n  tables : Array[TableType]\n  mems : Array[MemType]\n  globals : Array[GlobalType]\n  elems : Array[Elem]\n  datas : Array[Data]\n  tags : Array[TagType]\n  locals : Array[ValType]\n  labels : Stack[Array[ValType]]\n  return_type : Array[ValType]?\n} derive(Hash)\n\n///|\npub(all) enum Func {\n  Func(Array[Locals], Expr)\n  TFunc(Array[ValType], TExpr)\n} derive(Eq, Hash)\n\n///|\npub impl @quickcheck.Arbitrary for CompType with arbitrary(t, state) {\n  match state.next_uint() % 3 {\n    1 => StructCompType(array_of_arbitrary(5, t, state))\n    2 =>\n      FuncCompType(\n        array_of_arbitrary(5, t, state),\n        array_of_arbitrary(5, t, state),\n      )\n    _ => ArrayCompType(@quickcheck.Arbitrary::arbitrary(t, state))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for RecType with arbitrary(t, state) {\n  if (state.next_uint() & 1) == 1 {\n    SingleRecType(@quickcheck.Arbitrary::arbitrary(t, state))\n  } else {\n    GroupRecType(array_of_arbitrary(5, t, state))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for HeapType with arbitrary(size, st) {\n  if (st.next_uint() & 1) == 1 {\n    AbsHeapTypeHeapType(@quickcheck.Arbitrary::arbitrary(size, st))\n  } else {\n    HeapType(@quickcheck.Arbitrary::arbitrary(size, st))\n  }\n  // Def types are not arbitrary\n}\n\n///|\npub impl @quickcheck.Arbitrary for ValType with arbitrary(size, st) {\n  match st.next_uint() % 3 {\n    0 => NumTypeValType(@quickcheck.Arbitrary::arbitrary(size, st))\n    1 => VecTypeValType\n    2 => RefTypeValType(@quickcheck.Arbitrary::arbitrary(size, st))\n    _ => VecTypeValType\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for TypeIdx with arbitrary(_, st) {\n  TypeIdx(st.next_uint())\n  // recursive indexes are not arbitrary\n}\n\n///|\npub impl @quickcheck.Arbitrary for LaneIdx with arbitrary(_, state) {\n  let b : Byte = (state.next_uint() % 16).to_byte()\n  LaneIdx(b)\n}\n\n///|\npub impl @quickcheck.Arbitrary for SubType with arbitrary(t, st) {\n  if st.next_uint() % 2 == 1 {\n    SubType(\n      st.next_uint() % 2 == 1,\n      array_of_arbitrary(1, t, st),\n      @quickcheck.Arbitrary::arbitrary(t, st),\n    )\n  } else {\n    CompTypeSubType(@quickcheck.Arbitrary::arbitrary(t, st))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for DefType with arbitrary(t, state) {\n  let s = @quickcheck.Arbitrary::arbitrary(t, state)\n  match s {\n    SingleRecType(_) => DefType(s, 0)\n    GroupRecType(g) => {\n      let idx = state.next_uint() % g.length().reinterpret_as_uint()\n      DefType(s, idx)\n    }\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for Limits with arbitrary(_, state) {\n  if (state.next_uint() & 1) == 1 {\n    if (state.next_uint() & 1) == 1 {\n      I32Limits(state.next_uint(), None)\n    } else {\n      let a : UInt = state.next_uint()\n      let b : UInt = state.next_uint()\n      let min = if a > b { b } else { a }\n      let max = if a > b { a } else { b }\n      I32Limits(min, Some(max))\n    }\n  } else if (state.next_uint() & 1) == 1 {\n    I64Limits(state.next_uint64(), None)\n  } else {\n    let a : UInt64 = state.next_uint64()\n    let b : UInt64 = state.next_uint64()\n    let min = if a > b { b } else { a }\n    let max = if a > b { a } else { b }\n    I64Limits(min, Some(max))\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for Elem with arbitrary(size, state) {\n  match state.next_uint() % 8 {\n    // 0x00: Active(table 0) + FuncsElemKind\n    0 => {\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Active(TableIdx(0), expr), FuncsElemKind(funcs))\n    }\n    // 0x01: Passive + FuncsElemKind\n    1 => {\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Passive, FuncsElemKind(funcs))\n    }\n    // 0x02: Active(any table) + FuncsElemKind\n    2 => {\n      let ti : TableIdx = @quickcheck.Arbitrary::arbitrary(size, state)\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Active(ti, expr), FuncsElemKind(funcs))\n    }\n    // 0x03: Declarative + FuncsElemKind\n    3 => {\n      let funcs = array_of_arbitrary(5, size, state)\n      Elem(Declarative, FuncsElemKind(funcs))\n    }\n    // 0x04: Active(table 0) + FuncExprsElemKind\n    4 => {\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Active(TableIdx(0), expr), FuncExprsElemKind(exprs))\n    }\n    // 0x05: Passive + TypedExprsElemKind (covers FuncExprsElemKind too)\n    5 => {\n      let rt : RefType = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Passive, TypedExprsElemKind(rt, exprs))\n    }\n    // 0x06: Active(any table) + FuncExprsElemKind\n    6 => {\n      let ti : TableIdx = @quickcheck.Arbitrary::arbitrary(size, state)\n      let expr = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Active(ti, expr), FuncExprsElemKind(exprs))\n    }\n    // 0x07: Declarative + TypedExprsElemKind\n    _ => {\n      let rt : RefType = @quickcheck.Arbitrary::arbitrary(size, state)\n      let exprs = array_of_arbitrary(3, size, state)\n      Elem(Declarative, TypedExprsElemKind(rt, exprs))\n    }\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for Expr with arbitrary(t, state) {\n  Expr([\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n  ])\n}\n\n///|\npub impl @quickcheck.Arbitrary for Locals with arbitrary(t, state) {\n  let count = state.next_positive_int() % 3 + 1\n  Locals(\n    count.reinterpret_as_uint(),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n  )\n}\n\n///|\npub impl @quickcheck.Arbitrary for Func with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  Func(elems, @quickcheck.Arbitrary::arbitrary(t, state))\n}\n\n///|\npub impl @quickcheck.Arbitrary for Data with arbitrary(t, state) {\n  let size = state.next_positive_int() % 10 + 1\n  Data(\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(size, state),\n  )\n}\n\n///|\npub impl @quickcheck.Arbitrary for Name with arbitrary(_, state) {\n  let count = state.next_positive_int() % 5\n  let sb = StringBuilder::new(size_hint=count)\n  loop (count, state.next_positive_int() % 91799) {\n    (0, _) => break\n    (n, i) if (i >= 32 && i <= 126) ||\n      (i >= 160 && i <= 172) ||\n      (i >= 174 && i <= 887) ||\n      (i >= 890 && i <= 895) ||\n      (i >= 900 && i <= 906) ||\n      (i >= 908 && i <= 908) ||\n      (i >= 910 && i <= 929) ||\n      (i >= 931 && i <= 1327) ||\n      (i >= 1329 && i <= 1366) ||\n      (i >= 1369 && i <= 1418) ||\n      (i >= 1421 && i <= 1423) ||\n      (i >= 1425 && i <= 1479) ||\n      (i >= 1488 && i <= 1514) ||\n      (i >= 1519 && i <= 1524) ||\n      (i >= 1542 && i <= 1563) ||\n      (i >= 1565 && i <= 1756) ||\n      (i >= 1758 && i <= 1805) ||\n      (i >= 1808 && i <= 1866) ||\n      (i >= 1869 && i <= 1969) ||\n      (i >= 1984 && i <= 2042) ||\n      (i >= 2045 && i <= 2093) ||\n      (i >= 2096 && i <= 2110) ||\n      (i >= 2112 && i <= 2139) ||\n      (i >= 2142 && i <= 2142) ||\n      (i >= 2144 && i <= 2154) ||\n      (i >= 2160 && i <= 2191) ||\n      (i >= 2199 && i <= 2273) ||\n      (i >= 2275 && i <= 2435) ||\n      (i >= 2437 && i <= 2444) ||\n      (i >= 2447 && i <= 2448) ||\n      (i >= 2451 && i <= 2472) ||\n      (i >= 2474 && i <= 2480) ||\n      (i >= 2482 && i <= 2482) ||\n      (i >= 2486 && i <= 2489) ||\n      (i >= 2492 && i <= 2500) ||\n      (i >= 2503 && i <= 2504) ||\n      (i >= 2507 && i <= 2510) ||\n      (i >= 2519 && i <= 2519) ||\n      (i >= 2524 && i <= 2525) ||\n      (i >= 2527 && i <= 2531) ||\n      (i >= 2534 && i <= 2558) ||\n      (i >= 2561 && i <= 2563) ||\n      (i >= 2565 && i <= 2570) ||\n      (i >= 2575 && i <= 2576) ||\n      (i >= 2579 && i <= 2600) ||\n      (i >= 2602 && i <= 2608) ||\n      (i >= 2610 && i <= 2611) ||\n      (i >= 2613 && i <= 2614) ||\n      (i >= 2616 && i <= 2617) ||\n      (i >= 2620 && i <= 2620) ||\n      (i >= 2622 && i <= 2626) ||\n      (i >= 2631 && i <= 2632) ||\n      (i >= 2635 && i <= 2637) ||\n      (i >= 2641 && i <= 2641) ||\n      (i >= 2649 && i <= 2652) ||\n      (i >= 2654 && i <= 2654) ||\n      (i >= 2662 && i <= 2678) ||\n      (i >= 2689 && i <= 2691) ||\n      (i >= 2693 && i <= 2701) ||\n      (i >= 2703 && i <= 2705) ||\n      (i >= 2707 && i <= 2728) ||\n      (i >= 2730 && i <= 2736) ||\n      (i >= 2738 && i <= 2739) ||\n      (i >= 2741 && i <= 2745) ||\n      (i >= 2748 && i <= 2757) ||\n      (i >= 2759 && i <= 2761) ||\n      (i >= 2763 && i <= 2765) ||\n      (i >= 2768 && i <= 2768) ||\n      (i >= 2784 && i <= 2787) ||\n      (i >= 2790 && i <= 2801) ||\n      (i >= 2809 && i <= 2815) ||\n      (i >= 2817 && i <= 2819) ||\n      (i >= 2821 && i <= 2828) ||\n      (i >= 2831 && i <= 2832) ||\n      (i >= 2835 && i <= 2856) ||\n      (i >= 2858 && i <= 2864) ||\n      (i >= 2866 && i <= 2867) ||\n      (i >= 2869 && i <= 2873) ||\n      (i >= 2876 && i <= 2884) ||\n      (i >= 2887 && i <= 2888) ||\n      (i >= 2891 && i <= 2893) ||\n      (i >= 2901 && i <= 2903) ||\n      (i >= 2908 && i <= 2909) ||\n      (i >= 2911 && i <= 2915) ||\n      (i >= 2918 && i <= 2935) ||\n      (i >= 2946 && i <= 2947) ||\n      (i >= 2949 && i <= 2954) ||\n      (i >= 2958 && i <= 2960) ||\n      (i >= 2962 && i <= 2965) ||\n      (i >= 2969 && i <= 2970) ||\n      (i >= 2972 && i <= 2972) ||\n      (i >= 2974 && i <= 2975) ||\n      (i >= 2979 && i <= 2980) ||\n      (i >= 2984 && i <= 2986) ||\n      (i >= 2990 && i <= 3001) ||\n      (i >= 3006 && i <= 3010) ||\n      (i >= 3014 && i <= 3016) ||\n      (i >= 3018 && i <= 3021) ||\n      (i >= 3024 && i <= 3024) ||\n      (i >= 3031 && i <= 3031) ||\n      (i >= 3046 && i <= 3066) ||\n      (i >= 3072 && i <= 3084) ||\n      (i >= 3086 && i <= 3088) ||\n      (i >= 3090 && i <= 3112) ||\n      (i >= 3114 && i <= 3129) ||\n      (i >= 3132 && i <= 3140) ||\n      (i >= 3142 && i <= 3144) ||\n      (i >= 3146 && i <= 3149) ||\n      (i >= 3157 && i <= 3158) ||\n      (i >= 3160 && i <= 3162) ||\n      (i >= 3164 && i <= 3165) ||\n      (i >= 3168 && i <= 3171) ||\n      (i >= 3174 && i <= 3183) ||\n      (i >= 3191 && i <= 3212) ||\n      (i >= 3214 && i <= 3216) ||\n      (i >= 3218 && i <= 3240) ||\n      (i >= 3242 && i <= 3251) ||\n      (i >= 3253 && i <= 3257) ||\n      (i >= 3260 && i <= 3268) ||\n      (i >= 3270 && i <= 3272) ||\n      (i >= 3274 && i <= 3277) ||\n      (i >= 3285 && i <= 3286) ||\n      (i >= 3292 && i <= 3294) ||\n      (i >= 3296 && i <= 3299) ||\n      (i >= 3302 && i <= 3311) ||\n      (i >= 3313 && i <= 3315) ||\n      (i >= 3328 && i <= 3340) ||\n      (i >= 3342 && i <= 3344) ||\n      (i >= 3346 && i <= 3396) ||\n      (i >= 3398 && i <= 3400) ||\n      (i >= 3402 && i <= 3407) ||\n      (i >= 3412 && i <= 3427) ||\n      (i >= 3430 && i <= 3455) ||\n      (i >= 3457 && i <= 3459) ||\n      (i >= 3461 && i <= 3478) ||\n      (i >= 3482 && i <= 3505) ||\n      (i >= 3507 && i <= 3515) ||\n      (i >= 3517 && i <= 3517) ||\n      (i >= 3520 && i <= 3526) ||\n      (i >= 3530 && i <= 3530) ||\n      (i >= 3535 && i <= 3540) ||\n      (i >= 3542 && i <= 3542) ||\n      (i >= 3544 && i <= 3551) ||\n      (i >= 3558 && i <= 3567) ||\n      (i >= 3570 && i <= 3572) ||\n      (i >= 3585 && i <= 3642) ||\n      (i >= 3647 && i <= 3675) ||\n      (i >= 3713 && i <= 3714) ||\n      (i >= 3716 && i <= 3716) ||\n      (i >= 3718 && i <= 3722) ||\n      (i >= 3724 && i <= 3747) ||\n      (i >= 3749 && i <= 3749) ||\n      (i >= 3751 && i <= 3773) ||\n      (i >= 3776 && i <= 3780) ||\n      (i >= 3782 && i <= 3782) ||\n      (i >= 3784 && i <= 3790) ||\n      (i >= 3792 && i <= 3801) ||\n      (i >= 3804 && i <= 3807) ||\n      (i >= 3840 && i <= 3911) ||\n      (i >= 3913 && i <= 3948) ||\n      (i >= 3953 && i <= 3991) ||\n      (i >= 3993 && i <= 4028) ||\n      (i >= 4030 && i <= 4044) ||\n      (i >= 4046 && i <= 4058) ||\n      (i >= 4096 && i <= 4293) ||\n      (i >= 4295 && i <= 4295) ||\n      (i >= 4301 && i <= 4301) ||\n      (i >= 4304 && i <= 4680) ||\n      (i >= 4682 && i <= 4685) ||\n      (i >= 4688 && i <= 4694) ||\n      (i >= 4696 && i <= 4696) ||\n      (i >= 4698 && i <= 4701) ||\n      (i >= 4704 && i <= 4744) ||\n      (i >= 4746 && i <= 4749) ||\n      (i >= 4752 && i <= 4784) ||\n      (i >= 4786 && i <= 4789) ||\n      (i >= 4792 && i <= 4798) ||\n      (i >= 4800 && i <= 4800) ||\n      (i >= 4802 && i <= 4805) ||\n      (i >= 4808 && i <= 4822) ||\n      (i >= 4824 && i <= 4880) ||\n      (i >= 4882 && i <= 4885) ||\n      (i >= 4888 && i <= 4954) ||\n      (i >= 4957 && i <= 4988) ||\n      (i >= 4992 && i <= 5017) ||\n      (i >= 5024 && i <= 5109) ||\n      (i >= 5112 && i <= 5117) ||\n      (i >= 5120 && i <= 5788) ||\n      (i >= 5792 && i <= 5880) ||\n      (i >= 5888 && i <= 5909) ||\n      (i >= 5919 && i <= 5942) ||\n      (i >= 5952 && i <= 5971) ||\n      (i >= 5984 && i <= 5996) ||\n      (i >= 5998 && i <= 6000) ||\n      (i >= 6002 && i <= 6003) ||\n      (i >= 6016 && i <= 6109) ||\n      (i >= 6112 && i <= 6121) ||\n      (i >= 6128 && i <= 6137) ||\n      (i >= 6144 && i <= 6157) ||\n      (i >= 6159 && i <= 6169) ||\n      (i >= 6176 && i <= 6264) ||\n      (i >= 6272 && i <= 6314) ||\n      (i >= 6320 && i <= 6389) ||\n      (i >= 6400 && i <= 6430) ||\n      (i >= 6432 && i <= 6443) ||\n      (i >= 6448 && i <= 6459) ||\n      (i >= 6464 && i <= 6464) ||\n      (i >= 6468 && i <= 6509) ||\n      (i >= 6512 && i <= 6516) ||\n      (i >= 6528 && i <= 6571) ||\n      (i >= 6576 && i <= 6601) ||\n      (i >= 6608 && i <= 6618) ||\n      (i >= 6622 && i <= 6683) ||\n      (i >= 6686 && i <= 6750) ||\n      (i >= 6752 && i <= 6780) ||\n      (i >= 6783 && i <= 6793) ||\n      (i >= 6800 && i <= 6809) ||\n      (i >= 6816 && i <= 6829) ||\n      (i >= 6832 && i <= 6877) ||\n      (i >= 6880 && i <= 6891) ||\n      (i >= 6912 && i <= 6988) ||\n      (i >= 6990 && i <= 7155) ||\n      (i >= 7164 && i <= 7223) ||\n      (i >= 7227 && i <= 7241) ||\n      (i >= 7245 && i <= 7306) ||\n      (i >= 7312 && i <= 7354) ||\n      (i >= 7357 && i <= 7367) ||\n      (i >= 7376 && i <= 7418) ||\n      (i >= 7424 && i <= 7957) ||\n      (i >= 7960 && i <= 7965) ||\n      (i >= 7968 && i <= 8005) ||\n      (i >= 8008 && i <= 8013) ||\n      (i >= 8016 && i <= 8023) ||\n      (i >= 8025 && i <= 8025) ||\n      (i >= 8027 && i <= 8027) ||\n      (i >= 8029 && i <= 8029) ||\n      (i >= 8031 && i <= 8061) ||\n      (i >= 8064 && i <= 8116) ||\n      (i >= 8118 && i <= 8132) ||\n      (i >= 8134 && i <= 8147) ||\n      (i >= 8150 && i <= 8155) ||\n      (i >= 8157 && i <= 8175) ||\n      (i >= 8178 && i <= 8180) ||\n      (i >= 8182 && i <= 8190) ||\n      (i >= 8192 && i <= 8202) ||\n      (i >= 8208 && i <= 8233) ||\n      (i >= 8239 && i <= 8287) ||\n      (i >= 8304 && i <= 8305) ||\n      (i >= 8308 && i <= 8334) ||\n      (i >= 8336 && i <= 8348) ||\n      (i >= 8352 && i <= 8385) ||\n      (i >= 8400 && i <= 8432) ||\n      (i >= 8448 && i <= 8587) ||\n      (i >= 8592 && i <= 9257) ||\n      (i >= 9280 && i <= 9290) ||\n      (i >= 9312 && i <= 11123) ||\n      (i >= 11126 && i <= 11507) ||\n      (i >= 11513 && i <= 11557) ||\n      (i >= 11559 && i <= 11559) ||\n      (i >= 11565 && i <= 11565) ||\n      (i >= 11568 && i <= 11623) ||\n      (i >= 11631 && i <= 11632) ||\n      (i >= 11647 && i <= 11670) ||\n      (i >= 11680 && i <= 11686) ||\n      (i >= 11688 && i <= 11694) ||\n      (i >= 11696 && i <= 11702) ||\n      (i >= 11704 && i <= 11710) ||\n      (i >= 11712 && i <= 11718) ||\n      (i >= 11720 && i <= 11726) ||\n      (i >= 11728 && i <= 11734) ||\n      (i >= 11736 && i <= 11742) ||\n      (i >= 11744 && i <= 11869) ||\n      (i >= 11904 && i <= 11929) ||\n      (i >= 11931 && i <= 12019) ||\n      (i >= 12032 && i <= 12245) ||\n      (i >= 12272 && i <= 12351) ||\n      (i >= 12353 && i <= 12438) ||\n      (i >= 12441 && i <= 12543) ||\n      (i >= 12549 && i <= 12591) ||\n      (i >= 12593 && i <= 12686) ||\n      (i >= 12688 && i <= 12773) ||\n      (i >= 12783 && i <= 12830) ||\n      (i >= 12832 && i <= 42124) ||\n      (i >= 42128 && i <= 42182) ||\n      (i >= 42192 && i <= 42539) ||\n      (i >= 42560 && i <= 42743) ||\n      (i >= 42752 && i <= 42972) ||\n      (i >= 42993 && i <= 43052) ||\n      (i >= 43056 && i <= 43065) ||\n      (i >= 43072 && i <= 43127) ||\n      (i >= 43136 && i <= 43205) ||\n      (i >= 43214 && i <= 43225) ||\n      (i >= 43232 && i <= 43347) ||\n      (i >= 43359 && i <= 43388) ||\n      (i >= 43392 && i <= 43469) ||\n      (i >= 43471 && i <= 43481) ||\n      (i >= 43486 && i <= 43518) ||\n      (i >= 43520 && i <= 43574) ||\n      (i >= 43584 && i <= 43597) ||\n      (i >= 43600 && i <= 43609) ||\n      (i >= 43612 && i <= 43714) ||\n      (i >= 43739 && i <= 43766) ||\n      (i >= 43777 && i <= 43782) ||\n      (i >= 43785 && i <= 43790) ||\n      (i >= 43793 && i <= 43798) ||\n      (i >= 43808 && i <= 43814) ||\n      (i >= 43816 && i <= 43822) ||\n      (i >= 43824 && i <= 43883) ||\n      (i >= 43888 && i <= 44013) ||\n      (i >= 44016 && i <= 44025) ||\n      (i >= 44032 && i <= 55203) ||\n      (i >= 55216 && i <= 55238) ||\n      (i >= 55243 && i <= 55291) ||\n      (i >= 63744 && i <= 64109) ||\n      (i >= 64112 && i <= 64217) ||\n      (i >= 64256 && i <= 64262) ||\n      (i >= 64275 && i <= 64279) ||\n      (i >= 64285 && i <= 64310) ||\n      (i >= 64312 && i <= 64316) ||\n      (i >= 64318 && i <= 64318) ||\n      (i >= 64320 && i <= 64321) ||\n      (i >= 64323 && i <= 64324) ||\n      (i >= 64326 && i <= 64975) ||\n      (i >= 65008 && i <= 65049) ||\n      (i >= 65056 && i <= 65106) ||\n      (i >= 65108 && i <= 65126) ||\n      (i >= 65128 && i <= 65131) ||\n      (i >= 65136 && i <= 65140) ||\n      (i >= 65142 && i <= 65276) ||\n      (i >= 65281 && i <= 65470) ||\n      (i >= 65474 && i <= 65479) ||\n      (i >= 65482 && i <= 65487) ||\n      (i >= 65490 && i <= 65495) ||\n      (i >= 65498 && i <= 65500) ||\n      (i >= 65504 && i <= 65510) ||\n      (i >= 65512 && i <= 65518) ||\n      (i >= 65532 && i <= 65533) ||\n      (i >= 65536 && i <= 65547) ||\n      (i >= 65549 && i <= 65574) ||\n      (i >= 65576 && i <= 65594) ||\n      (i >= 65596 && i <= 65597) ||\n      (i >= 65599 && i <= 65613) ||\n      (i >= 65616 && i <= 65629) ||\n      (i >= 65664 && i <= 65786) ||\n      (i >= 65792 && i <= 65794) ||\n      (i >= 65799 && i <= 65843) ||\n      (i >= 65847 && i <= 65934) ||\n      (i >= 65936 && i <= 65948) ||\n      (i >= 65952 && i <= 65952) ||\n      (i >= 66000 && i <= 66045) ||\n      (i >= 66176 && i <= 66204) ||\n      (i >= 66208 && i <= 66256) ||\n      (i >= 66272 && i <= 66299) ||\n      (i >= 66304 && i <= 66339) ||\n      (i >= 66349 && i <= 66378) ||\n      (i >= 66384 && i <= 66426) ||\n      (i >= 66432 && i <= 66461) ||\n      (i >= 66463 && i <= 66499) ||\n      (i >= 66504 && i <= 66517) ||\n      (i >= 66560 && i <= 66717) ||\n      (i >= 66720 && i <= 66729) ||\n      (i >= 66736 && i <= 66771) ||\n      (i >= 66776 && i <= 66811) ||\n      (i >= 66816 && i <= 66855) ||\n      (i >= 66864 && i <= 66915) ||\n      (i >= 66927 && i <= 66938) ||\n      (i >= 66940 && i <= 66954) ||\n      (i >= 66956 && i <= 66962) ||\n      (i >= 66964 && i <= 66965) ||\n      (i >= 66967 && i <= 66977) ||\n      (i >= 66979 && i <= 66993) ||\n      (i >= 66995 && i <= 67001) ||\n      (i >= 67003 && i <= 67004) ||\n      (i >= 67008 && i <= 67059) ||\n      (i >= 67072 && i <= 67382) ||\n      (i >= 67392 && i <= 67413) ||\n      (i >= 67424 && i <= 67431) ||\n      (i >= 67456 && i <= 67461) ||\n      (i >= 67463 && i <= 67504) ||\n      (i >= 67506 && i <= 67514) ||\n      (i >= 67584 && i <= 67589) ||\n      (i >= 67592 && i <= 67592) ||\n      (i >= 67594 && i <= 67637) ||\n      (i >= 67639 && i <= 67640) ||\n      (i >= 67644 && i <= 67644) ||\n      (i >= 67647 && i <= 67669) ||\n      (i >= 67671 && i <= 67742) ||\n      (i >= 67751 && i <= 67759) ||\n      (i >= 67808 && i <= 67826) ||\n      (i >= 67828 && i <= 67829) ||\n      (i >= 67835 && i <= 67867) ||\n      (i >= 67871 && i <= 67897) ||\n      (i >= 67903 && i <= 67929) ||\n      (i >= 67968 && i <= 68023) ||\n      (i >= 68028 && i <= 68047) ||\n      (i >= 68050 && i <= 68099) ||\n      (i >= 68101 && i <= 68102) ||\n      (i >= 68108 && i <= 68115) ||\n      (i >= 68117 && i <= 68119) ||\n      (i >= 68121 && i <= 68149) ||\n      (i >= 68152 && i <= 68154) ||\n      (i >= 68159 && i <= 68168) ||\n      (i >= 68176 && i <= 68184) ||\n      (i >= 68192 && i <= 68255) ||\n      (i >= 68288 && i <= 68326) ||\n      (i >= 68331 && i <= 68342) ||\n      (i >= 68352 && i <= 68405) ||\n      (i >= 68409 && i <= 68437) ||\n      (i >= 68440 && i <= 68466) ||\n      (i >= 68472 && i <= 68497) ||\n      (i >= 68505 && i <= 68508) ||\n      (i >= 68521 && i <= 68527) ||\n      (i >= 68608 && i <= 68680) ||\n      (i >= 68736 && i <= 68786) ||\n      (i >= 68800 && i <= 68850) ||\n      (i >= 68858 && i <= 68903) ||\n      (i >= 68912 && i <= 68921) ||\n      (i >= 68928 && i <= 68965) ||\n      (i >= 68969 && i <= 68997) ||\n      (i >= 69006 && i <= 69007) ||\n      (i >= 69216 && i <= 69246) ||\n      (i >= 69248 && i <= 69289) ||\n      (i >= 69291 && i <= 69293) ||\n      (i >= 69296 && i <= 69297) ||\n      (i >= 69314 && i <= 69319) ||\n      (i >= 69328 && i <= 69336) ||\n      (i >= 69370 && i <= 69415) ||\n      (i >= 69424 && i <= 69465) ||\n      (i >= 69488 && i <= 69513) ||\n      (i >= 69552 && i <= 69579) ||\n      (i >= 69600 && i <= 69622) ||\n      (i >= 69632 && i <= 69709) ||\n      (i >= 69714 && i <= 69749) ||\n      (i >= 69759 && i <= 69820) ||\n      (i >= 69822 && i <= 69826) ||\n      (i >= 69840 && i <= 69864) ||\n      (i >= 69872 && i <= 69881) ||\n      (i >= 69888 && i <= 69940) ||\n      (i >= 69942 && i <= 69959) ||\n      (i >= 69968 && i <= 70006) ||\n      (i >= 70016 && i <= 70111) ||\n      (i >= 70113 && i <= 70132) ||\n      (i >= 70144 && i <= 70161) ||\n      (i >= 70163 && i <= 70209) ||\n      (i >= 70272 && i <= 70278) ||\n      (i >= 70280 && i <= 70280) ||\n      (i >= 70282 && i <= 70285) ||\n      (i >= 70287 && i <= 70301) ||\n      (i >= 70303 && i <= 70313) ||\n      (i >= 70320 && i <= 70378) ||\n      (i >= 70384 && i <= 70393) ||\n      (i >= 70400 && i <= 70403) ||\n      (i >= 70405 && i <= 70412) ||\n      (i >= 70415 && i <= 70416) ||\n      (i >= 70419 && i <= 70440) ||\n      (i >= 70442 && i <= 70448) ||\n      (i >= 70450 && i <= 70451) ||\n      (i >= 70453 && i <= 70457) ||\n      (i >= 70459 && i <= 70468) ||\n      (i >= 70471 && i <= 70472) ||\n      (i >= 70475 && i <= 70477) ||\n      (i >= 70480 && i <= 70480) ||\n      (i >= 70487 && i <= 70487) ||\n      (i >= 70493 && i <= 70499) ||\n      (i >= 70502 && i <= 70508) ||\n      (i >= 70512 && i <= 70516) ||\n      (i >= 70528 && i <= 70537) ||\n      (i >= 70539 && i <= 70539) ||\n      (i >= 70542 && i <= 70542) ||\n      (i >= 70544 && i <= 70581) ||\n      (i >= 70583 && i <= 70592) ||\n      (i >= 70594 && i <= 70594) ||\n      (i >= 70597 && i <= 70597) ||\n      (i >= 70599 && i <= 70602) ||\n      (i >= 70604 && i <= 70613) ||\n      (i >= 70615 && i <= 70616) ||\n      (i >= 70625 && i <= 70626) ||\n      (i >= 70656 && i <= 70747) ||\n      (i >= 70749 && i <= 70753) ||\n      (i >= 70784 && i <= 70855) ||\n      (i >= 70864 && i <= 70873) ||\n      (i >= 71040 && i <= 71093) ||\n      (i >= 71096 && i <= 71133) ||\n      (i >= 71168 && i <= 71236) ||\n      (i >= 71248 && i <= 71257) ||\n      (i >= 71264 && i <= 71276) ||\n      (i >= 71296 && i <= 71353) ||\n      (i >= 71360 && i <= 71369) ||\n      (i >= 71376 && i <= 71395) ||\n      (i >= 71424 && i <= 71450) ||\n      (i >= 71453 && i <= 71467) ||\n      (i >= 71472 && i <= 71494) ||\n      (i >= 71680 && i <= 71739) ||\n      (i >= 71840 && i <= 71922) ||\n      (i >= 71935 && i <= 71942) ||\n      (i >= 71945 && i <= 71945) ||\n      (i >= 71948 && i <= 71955) ||\n      (i >= 71957 && i <= 71958) ||\n      (i >= 71960 && i <= 71989) ||\n      (i >= 71991 && i <= 71992) ||\n      (i >= 71995 && i <= 72006) ||\n      (i >= 72016 && i <= 72025) ||\n      (i >= 72096 && i <= 72103) ||\n      (i >= 72106 && i <= 72151) ||\n      (i >= 72154 && i <= 72164) ||\n      (i >= 72192 && i <= 72263) ||\n      (i >= 72272 && i <= 72354) ||\n      (i >= 72368 && i <= 72440) ||\n      (i >= 72448 && i <= 72457) ||\n      (i >= 72544 && i <= 72551) ||\n      (i >= 72640 && i <= 72673) ||\n      (i >= 72688 && i <= 72697) ||\n      (i >= 72704 && i <= 72712) ||\n      (i >= 72714 && i <= 72758) ||\n      (i >= 72760 && i <= 72773) ||\n      (i >= 72784 && i <= 72812) ||\n      (i >= 72816 && i <= 72847) ||\n      (i >= 72850 && i <= 72871) ||\n      (i >= 72873 && i <= 72886) ||\n      (i >= 72960 && i <= 72966) ||\n      (i >= 72968 && i <= 72969) ||\n      (i >= 72971 && i <= 73014) ||\n      (i >= 73018 && i <= 73018) ||\n      (i >= 73020 && i <= 73021) ||\n      (i >= 73023 && i <= 73031) ||\n      (i >= 73040 && i <= 73049) ||\n      (i >= 73056 && i <= 73061) ||\n      (i >= 73063 && i <= 73064) ||\n      (i >= 73066 && i <= 73102) ||\n      (i >= 73104 && i <= 73105) ||\n      (i >= 73107 && i <= 73112) ||\n      (i >= 73120 && i <= 73129) ||\n      (i >= 73136 && i <= 73179) ||\n      (i >= 73184 && i <= 73193) ||\n      (i >= 73440 && i <= 73464) ||\n      (i >= 73472 && i <= 73488) ||\n      (i >= 73490 && i <= 73530) ||\n      (i >= 73534 && i <= 73562) ||\n      (i >= 73648 && i <= 73648) ||\n      (i >= 73664 && i <= 73713) ||\n      (i >= 73727 && i <= 74649) ||\n      (i >= 74752 && i <= 74862) ||\n      (i >= 74864 && i <= 74868) ||\n      (i >= 74880 && i <= 75075) ||\n      (i >= 77712 && i <= 77810) ||\n      (i >= 77824 && i <= 78895) ||\n      (i >= 78912 && i <= 78933) ||\n      (i >= 78944 && i <= 82938) ||\n      (i >= 82944 && i <= 83526) ||\n      (i >= 90368 && i <= 90425) ||\n      (i >= 92160 && i <= 92728) ||\n      (i >= 92736 && i <= 92766) ||\n      (i >= 92768 && i <= 92777) ||\n      (i >= 92782 && i <= 92862) ||\n      (i >= 92864 && i <= 92873) ||\n      (i >= 92880 && i <= 92909) ||\n      (i >= 92912 && i <= 92917) ||\n      (i >= 92928 && i <= 92997) ||\n      (i >= 93008 && i <= 93017) ||\n      (i >= 93019 && i <= 93025) ||\n      (i >= 93027 && i <= 93047) ||\n      (i >= 93053 && i <= 93071) ||\n      (i >= 93504 && i <= 93561) ||\n      (i >= 93760 && i <= 93850) ||\n      (i >= 93856 && i <= 93880) ||\n      (i >= 93883 && i <= 93907) ||\n      (i >= 93952 && i <= 94026) ||\n      (i >= 94031 && i <= 94087) ||\n      (i >= 94095 && i <= 94111) ||\n      (i >= 94176 && i <= 94180) ||\n      (i >= 94192 && i <= 94198) ||\n      (i >= 94208 && i <= 101589) ||\n      (i >= 101631 && i <= 101662) ||\n      (i >= 101760 && i <= 101874) ||\n      (i >= 110576 && i <= 110579) ||\n      (i >= 110581 && i <= 110587) ||\n      (i >= 110589 && i <= 110590) ||\n      (i >= 110592 && i <= 110882) ||\n      (i >= 110898 && i <= 110898) ||\n      (i >= 110928 && i <= 110930) ||\n      (i >= 110933 && i <= 110933) ||\n      (i >= 110948 && i <= 110951) ||\n      (i >= 110960 && i <= 111355) ||\n      (i >= 113664 && i <= 113770) ||\n      (i >= 113776 && i <= 113788) ||\n      (i >= 113792 && i <= 113800) ||\n      (i >= 113808 && i <= 113817) ||\n      (i >= 113820 && i <= 113823) ||\n      (i >= 117760 && i <= 118012) ||\n      (i >= 118016 && i <= 118451) ||\n      (i >= 118458 && i <= 118480) ||\n      (i >= 118496 && i <= 118512) ||\n      (i >= 118528 && i <= 118573) ||\n      (i >= 118576 && i <= 118598) ||\n      (i >= 118608 && i <= 118723) ||\n      (i >= 118784 && i <= 119029) ||\n      (i >= 119040 && i <= 119078) ||\n      (i >= 119081 && i <= 119154) ||\n      (i >= 119163 && i <= 119274) ||\n      (i >= 119296 && i <= 119365) ||\n      (i >= 119488 && i <= 119507) ||\n      (i >= 119520 && i <= 119539) ||\n      (i >= 119552 && i <= 119638) ||\n      (i >= 119648 && i <= 119672) ||\n      (i >= 119808 && i <= 119892) ||\n      (i >= 119894 && i <= 119964) ||\n      (i >= 119966 && i <= 119967) ||\n      (i >= 119970 && i <= 119970) ||\n      (i >= 119973 && i <= 119974) ||\n      (i >= 119977 && i <= 119980) ||\n      (i >= 119982 && i <= 119993) ||\n      (i >= 119995 && i <= 119995) ||\n      (i >= 119997 && i <= 120003) ||\n      (i >= 120005 && i <= 120069) ||\n      (i >= 120071 && i <= 120074) ||\n      (i >= 120077 && i <= 120084) ||\n      (i >= 120086 && i <= 120092) ||\n      (i >= 120094 && i <= 120121) ||\n      (i >= 120123 && i <= 120126) ||\n      (i >= 120128 && i <= 120132) ||\n      (i >= 120134 && i <= 120134) ||\n      (i >= 120138 && i <= 120144) ||\n      (i >= 120146 && i <= 120485) ||\n      (i >= 120488 && i <= 120779) ||\n      (i >= 120782 && i <= 121483) ||\n      (i >= 121499 && i <= 121503) ||\n      (i >= 121505 && i <= 121519) ||\n      (i >= 122624 && i <= 122654) ||\n      (i >= 122661 && i <= 122666) ||\n      (i >= 122880 && i <= 122886) ||\n      (i >= 122888 && i <= 122904) ||\n      (i >= 122907 && i <= 122913) ||\n      (i >= 122915 && i <= 122916) ||\n      (i >= 122918 && i <= 122922) ||\n      (i >= 122928 && i <= 122989) ||\n      (i >= 123023 && i <= 123023) ||\n      (i >= 123136 && i <= 123180) ||\n      (i >= 123184 && i <= 123197) ||\n      (i >= 123200 && i <= 123209) ||\n      (i >= 123214 && i <= 123215) ||\n      (i >= 123536 && i <= 123566) ||\n      (i >= 123584 && i <= 123641) ||\n      (i >= 123647 && i <= 123647) ||\n      (i >= 124112 && i <= 124153) ||\n      (i >= 124368 && i <= 124410) ||\n      (i >= 124415 && i <= 124415) ||\n      (i >= 124608 && i <= 124638) ||\n      (i >= 124640 && i <= 124661) ||\n      (i >= 124670 && i <= 124671) ||\n      (i >= 124896 && i <= 124902) ||\n      (i >= 124904 && i <= 124907) ||\n      (i >= 124909 && i <= 124910) ||\n      (i >= 124912 && i <= 124926) ||\n      (i >= 124928 && i <= 125124) ||\n      (i >= 125127 && i <= 125142) ||\n      (i >= 125184 && i <= 125259) ||\n      (i >= 125264 && i <= 125273) ||\n      (i >= 125278 && i <= 125279) ||\n      (i >= 126065 && i <= 126132) ||\n      (i >= 126209 && i <= 126269) ||\n      (i >= 126464 && i <= 126467) ||\n      (i >= 126469 && i <= 126495) ||\n      (i >= 126497 && i <= 126498) ||\n      (i >= 126500 && i <= 126500) ||\n      (i >= 126503 && i <= 126503) ||\n      (i >= 126505 && i <= 126514) ||\n      (i >= 126516 && i <= 126519) ||\n      (i >= 126521 && i <= 126521) ||\n      (i >= 126523 && i <= 126523) ||\n      (i >= 126530 && i <= 126530) ||\n      (i >= 126535 && i <= 126535) ||\n      (i >= 126537 && i <= 126537) ||\n      (i >= 126539 && i <= 126539) ||\n      (i >= 126541 && i <= 126543) ||\n      (i >= 126545 && i <= 126546) ||\n      (i >= 126548 && i <= 126548) ||\n      (i >= 126551 && i <= 126551) ||\n      (i >= 126553 && i <= 126553) ||\n      (i >= 126555 && i <= 126555) ||\n      (i >= 126557 && i <= 126557) ||\n      (i >= 126559 && i <= 126559) ||\n      (i >= 126561 && i <= 126562) ||\n      (i >= 126564 && i <= 126564) ||\n      (i >= 126567 && i <= 126570) ||\n      (i >= 126572 && i <= 126578) ||\n      (i >= 126580 && i <= 126583) ||\n      (i >= 126585 && i <= 126588) ||\n      (i >= 126590 && i <= 126590) ||\n      (i >= 126592 && i <= 126601) ||\n      (i >= 126603 && i <= 126619) ||\n      (i >= 126625 && i <= 126627) ||\n      (i >= 126629 && i <= 126633) ||\n      (i >= 126635 && i <= 126651) ||\n      (i >= 126704 && i <= 126705) ||\n      (i >= 126976 && i <= 127019) ||\n      (i >= 127024 && i <= 127123) ||\n      (i >= 127136 && i <= 127150) ||\n      (i >= 127153 && i <= 127167) ||\n      (i >= 127169 && i <= 127183) ||\n      (i >= 127185 && i <= 127221) ||\n      (i >= 127232 && i <= 127405) ||\n      (i >= 127462 && i <= 127490) ||\n      (i >= 127504 && i <= 127547) ||\n      (i >= 127552 && i <= 127560) ||\n      (i >= 127568 && i <= 127569) ||\n      (i >= 127584 && i <= 127589) ||\n      (i >= 127744 && i <= 128728) ||\n      (i >= 128732 && i <= 128748) ||\n      (i >= 128752 && i <= 128764) ||\n      (i >= 128768 && i <= 128985) ||\n      (i >= 128992 && i <= 129003) ||\n      (i >= 129008 && i <= 129008) ||\n      (i >= 129024 && i <= 129035) ||\n      (i >= 129040 && i <= 129095) ||\n      (i >= 129104 && i <= 129113) ||\n      (i >= 129120 && i <= 129159) ||\n      (i >= 129168 && i <= 129197) ||\n      (i >= 129200 && i <= 129211) ||\n      (i >= 129216 && i <= 129217) ||\n      (i >= 129232 && i <= 129240) ||\n      (i >= 129280 && i <= 129623) ||\n      (i >= 129632 && i <= 129645) ||\n      (i >= 129648 && i <= 129660) ||\n      (i >= 129664 && i <= 129674) ||\n      (i >= 129678 && i <= 129734) ||\n      (i >= 129736 && i <= 129736) ||\n      (i >= 129741 && i <= 129756) ||\n      (i >= 129759 && i <= 129770) ||\n      (i >= 129775 && i <= 129784) ||\n      (i >= 129792 && i <= 129938) ||\n      (i >= 129940 && i <= 130042) ||\n      (i >= 131072 && i <= 173791) ||\n      (i >= 173824 && i <= 178205) ||\n      (i >= 178208 && i <= 183981) ||\n      (i >= 183984 && i <= 191456) ||\n      (i >= 191472 && i <= 192093) ||\n      (i >= 194560 && i <= 195101) ||\n      (i >= 196608 && i <= 201546) ||\n      (i >= 201552 && i <= 210041) ||\n      (i >= 917760 && i <= 917999) => {\n      sb.write_char(i.unsafe_to_char())\n      continue (n - 1, state.next_positive_int() % 91799)\n    }\n    (n, _) => continue (n, state.next_positive_int() % 91799)\n  }\n  Name(sb.to_string().to_string_view())\n}\n\n///|\npub(all) struct CustomSec(Name, Bytes) derive(Eq, Hash)\n\n///|\npub(all) struct TypeSec(Array[RecType]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ImportSec(Array[Import]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct FuncSec(Array[TypeIdx]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TableSec(Array[Table]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemSec(Array[MemType]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct GlobalSec(Array[Global]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ExportSec(Array[Export]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct StartSec(FuncIdx) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct ElemSec(Array[Elem]) derive(Eq, Hash)\n\n///|\npub(all) struct DataCntSec(U32) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct TagSec(Array[TagType]) derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct MemArg(U32, MemIdx?, U64) derive(Hash)\n\n///|\npub(all) enum BlockType {\n  EmptyBlockType\n  ValTypeBlockType(ValType)\n  TypeIdxBlockType(TypeIdx)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) enum Catch {\n  Catch(TagIdx, LabelIdx)\n  CatchRef(TagIdx, LabelIdx)\n  CatchAll(LabelIdx)\n  CatchAllRef(LabelIdx)\n} derive(Eq, Arbitrary, Hash)\n\n///|\npub(all) struct CodeSec(Array[Func]) derive(Eq, Hash)\n\n///|\npub(all) struct DataSec(Array[Data]) derive(Eq, Hash)\n\n///|\npub(all) struct CastOp(Bool, Bool) derive(Eq, Arbitrary, Show, Hash)\n\n///|\npub(all) enum Instruction {\n  Unreachable\n  Nop\n  Block(BlockType, Expr)\n  Loop(BlockType, Expr)\n  If(BlockType, Array[Instruction], Array[Instruction]?)\n  Throw(TagIdx)\n  ThrowRef\n  Br(LabelIdx)\n  BrIf(LabelIdx)\n  BrTable(Array[LabelIdx], LabelIdx)\n  Return\n  Call(FuncIdx)\n  CallIndirect(TypeIdx, TableIdx)\n  ReturnCall(FuncIdx)\n  ReturnCallIndirect(TypeIdx, TableIdx)\n  CallRef(TypeIdx)\n  ReturnCallRef(TypeIdx)\n  Drop\n  Select(Array[ValType]?)\n  TryTable(BlockType, Array[Catch], Expr)\n  LocalGet(LocalIdx)\n  LocalSet(LocalIdx)\n  LocalTee(LocalIdx)\n  GlobalGet(GlobalIdx)\n  GlobalSet(GlobalIdx)\n  TableGet(TableIdx)\n  TableSet(TableIdx)\n  I32Load(MemArg)\n  I64Load(MemArg)\n  F32Load(MemArg)\n  F64Load(MemArg)\n  I32Load8S(MemArg)\n  I32Load8U(MemArg)\n  I32Load16S(MemArg)\n  I32Load16U(MemArg)\n  I64Load8S(MemArg)\n  I64Load8U(MemArg)\n  I64Load16S(MemArg)\n  I64Load16U(MemArg)\n  I64Load32S(MemArg)\n  I64Load32U(MemArg)\n  I32Store(MemArg)\n  I64Store(MemArg)\n  F32Store(MemArg)\n  F64Store(MemArg)\n  I32Store8(MemArg)\n  I32Store16(MemArg)\n  I64Store8(MemArg)\n  I64Store16(MemArg)\n  I64Store32(MemArg)\n  MemorySize(MemIdx)\n  MemoryGrow(MemIdx)\n  I32Const(I32)\n  I64Const(I64)\n  F32Const(F32)\n  F64Const(F64)\n  I32Eqz\n  I32Eq\n  I32Ne\n  I32LtS\n  I32LtU\n  I32GtS\n  I32GtU\n  I32LeS\n  I32LeU\n  I32GeS\n  I32GeU\n  I64Eqz\n  I64Eq\n  I64Ne\n  I64LtS\n  I64LtU\n  I64GtS\n  I64GtU\n  I64LeS\n  I64LeU\n  I64GeS\n  I64GeU\n  F32Eq\n  F32Ne\n  F32Lt\n  F32Gt\n  F32Le\n  F32Ge\n  F64Eq\n  F64Ne\n  F64Lt\n  F64Gt\n  F64Le\n  F64Ge\n  I32Clz\n  I32Ctz\n  I32Popcnt\n  I32Add\n  I32Sub\n  I32Mul\n  I32DivS\n  I32DivU\n  I32RemS\n  I32RemU\n  I32And\n  I32Or\n  I32Xor\n  I32Shl\n  I32ShrS\n  I32ShrU\n  I32Rotl\n  I32Rotr\n  I64Clz\n  I64Ctz\n  I64Popcnt\n  I64Add\n  I64Sub\n  I64Mul\n  I64DivS\n  I64DivU\n  I64RemS\n  I64RemU\n  I64And\n  I64Or\n  I64Xor\n  I64Shl\n  I64ShrS\n  I64ShrU\n  I64Rotl\n  I64Rotr\n  F32Abs\n  F32Neg\n  F32Ceil\n  F32Floor\n  F32Trunc\n  F32Nearest\n  F32Sqrt\n  F32Add\n  F32Sub\n  F32Mul\n  F32Div\n  F32Min\n  F32Max\n  F32Copysign\n  F64Abs\n  F64Neg\n  F64Ceil\n  F64Floor\n  F64Trunc\n  F64Nearest\n  F64Sqrt\n  F64Add\n  F64Sub\n  F64Mul\n  F64Div\n  F64Min\n  F64Max\n  F64Copysign\n  I32WrapI64\n  I32TruncF32S\n  I32TruncF32U\n  I32TruncF64S\n  I32TruncF64U\n  I64ExtendI32S\n  I64ExtendI32U\n  I64TruncF32S\n  I64TruncF32U\n  I64TruncF64S\n  I64TruncF64U\n  F32ConvertI32S\n  F32ConvertI32U\n  F32ConvertI64S\n  F32ConvertI64U\n  F32DemoteF64\n  F64ConvertI32S\n  F64ConvertI32U\n  F64ConvertI64S\n  F64ConvertI64U\n  F64PromoteF32\n  I32ReinterpretF32\n  I64ReinterpretF64\n  F32ReinterpretI32\n  F64ReinterpretI64\n  I32Extend8S\n  I32Extend16S\n  I64Extend8S\n  I64Extend16S\n  I64Extend32S\n  RefNull(HeapType)\n  RefIsNull\n  RefFunc(FuncIdx)\n  RefEq\n  RefAsNonNull\n  BrOnNull(LabelIdx)\n  BrOnNonNull(LabelIdx)\n  StructNew(TypeIdx)\n  StructNewDefault(TypeIdx)\n  StructGet(TypeIdx, U32)\n  StructGetS(TypeIdx, U32)\n  StructGetU(TypeIdx, U32)\n  StructSet(TypeIdx, U32)\n  ArrayNew(TypeIdx)\n  ArrayNewDefault(TypeIdx)\n  ArrayNewFixed(TypeIdx, U32)\n  ArrayNewData(TypeIdx, DataIdx)\n  ArrayNewElem(TypeIdx, ElemIdx)\n  ArrayGet(TypeIdx)\n  ArrayGetS(TypeIdx)\n  ArrayGetU(TypeIdx)\n  ArraySet(TypeIdx)\n  ArrayLen\n  ArrayFill(TypeIdx)\n  ArrayCopy(TypeIdx, TypeIdx)\n  ArrayInitData(TypeIdx, DataIdx)\n  ArrayInitElem(TypeIdx, ElemIdx)\n  RefTest(Bool, HeapType)\n  RefCast(Bool, HeapType)\n  BrOnCast(LabelIdx, CastOp, HeapType, HeapType)\n  BrOnCastFail(LabelIdx, CastOp, HeapType, HeapType)\n  AnyConvertExtern\n  ExternConvertAny\n  RefI31\n  I31GetS\n  I31GetU\n  I32TruncSatF32S\n  I32TruncSatF32U\n  I32TruncSatF64S\n  I32TruncSatF64U\n  I64TruncSatF32S\n  I64TruncSatF32U\n  I64TruncSatF64S\n  I64TruncSatF64U\n  MemoryInit(DataIdx, MemIdx)\n  DataDrop(DataIdx)\n  MemoryCopy(MemIdx, MemIdx)\n  MemoryFill(MemIdx)\n  TableInit(ElemIdx, TableIdx)\n  ElemDrop(ElemIdx)\n  TableCopy(TableIdx, TableIdx)\n  TableGrow(TableIdx)\n  TableSize(TableIdx)\n  TableFill(TableIdx)\n  V128Load(MemArg)\n  V128Load8x8S(MemArg)\n  V128Load8x8U(MemArg)\n  V128Load16x4S(MemArg)\n  V128Load16x4U(MemArg)\n  V128Load32x2S(MemArg)\n  V128Load32x2U(MemArg)\n  V128Load8Splat(MemArg)\n  V128Load16Splat(MemArg)\n  V128Load32Splat(MemArg)\n  V128Load64Splat(MemArg)\n  V128Store(MemArg)\n  V128Const(\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte\n  )\n  I8x16Shuffle(\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx\n  )\n  I8x16Swizzle\n  I8x16Splat\n  I16x8Splat\n  I32x4Splat\n  I64x2Splat\n  F32x4Splat\n  F64x2Splat\n  I8x16ExtractLaneS(LaneIdx)\n  I8x16ExtractLaneU(LaneIdx)\n  I8x16ReplaceLane(LaneIdx)\n  I16x8ExtractLaneS(LaneIdx)\n  I16x8ExtractLaneU(LaneIdx)\n  I16x8ReplaceLane(LaneIdx)\n  I32x4ExtractLane(LaneIdx)\n  I32x4ReplaceLane(LaneIdx)\n  I64x2ExtractLane(LaneIdx)\n  I64x2ReplaceLane(LaneIdx)\n  F32x4ExtractLane(LaneIdx)\n  F32x4ReplaceLane(LaneIdx)\n  F64x2ExtractLane(LaneIdx)\n  F64x2ReplaceLane(LaneIdx)\n  I8x16Eq\n  I8x16Ne\n  I8x16LtS\n  I8x16LtU\n  I8x16GtS\n  I8x16GtU\n  I8x16LeS\n  I8x16LeU\n  I8x16GeS\n  I8x16GeU\n  I16x8Eq\n  I16x8Ne\n  I16x8LtS\n  I16x8LtU\n  I16x8GtS\n  I16x8GtU\n  I16x8LeS\n  I16x8LeU\n  I16x8GeS\n  I16x8GeU\n  I32x4Eq\n  I32x4Ne\n  I32x4LtS\n  I32x4LtU\n  I32x4GtS\n  I32x4GtU\n  I32x4LeS\n  I32x4LeU\n  I32x4GeS\n  I32x4GeU\n  F32x4Eq\n  F32x4Ne\n  F32x4Lt\n  F32x4Gt\n  F32x4Le\n  F32x4Ge\n  F64x2Eq\n  F64x2Ne\n  F64x2Lt\n  F64x2Gt\n  F64x2Le\n  F64x2Ge\n  V128Not\n  V128And\n  V128Andnot\n  V128Or\n  V128Xor\n  V128Bitselect\n  V128AnyTrue\n  V128Load8Lane(MemArg, LaneIdx)\n  V128Load16Lane(MemArg, LaneIdx)\n  V128Load32Lane(MemArg, LaneIdx)\n  V128Load64Lane(MemArg, LaneIdx)\n  V128Store8Lane(MemArg, LaneIdx)\n  V128Store16Lane(MemArg, LaneIdx)\n  V128Store32Lane(MemArg, LaneIdx)\n  V128Store64Lane(MemArg, LaneIdx)\n  V128Load32Zero(MemArg)\n  V128Load64Zero(MemArg)\n  F32x4DemoteF64x2Zero\n  F64x2PromoteLowF32x4\n  I8x16Abs\n  I8x16Neg\n  I8x16Popcnt\n  I8x16AllTrue\n  I8x16Bitmask\n  I8x16NarrowI16x8S\n  I8x16NarrowI16x8U\n  F32x4Ceil\n  F32x4Floor\n  F32x4Trunc\n  F32x4Nearest\n  I8x16Shl\n  I8x16ShrS\n  I8x16ShrU\n  I8x16Add\n  I8x16AddSatS\n  I8x16AddSatU\n  I8x16Sub\n  I8x16SubSatS\n  I8x16SubSatU\n  F64x2Ceil\n  F64x2Floor\n  I8x16MinS\n  I8x16MinU\n  I8x16MaxS\n  I8x16MaxU\n  F64x2Trunc\n  I8x16AvgrU\n  I16x8ExtaddPairwiseI8x16S\n  I16x8ExtaddPairwiseI8x16U\n  I32x4ExtaddPairwiseI16x8S\n  I32x4ExtaddPairwiseI16x8U\n  I16x8Abs\n  I16x8Neg\n  I16x8Q15mulrSatS\n  I16x8AllTrue\n  I16x8Bitmask\n  I16x8NarrowI32x4S\n  I16x8NarrowI32x4U\n  I16x8ExtendLowI8x16S\n  I16x8ExtendHighI8x16S\n  I16x8ExtendLowI8x16U\n  I16x8ExtendHighI8x16U\n  I16x8Shl\n  I16x8ShrS\n  I16x8ShrU\n  I16x8Add\n  I16x8AddSatS\n  I16x8AddSatU\n  I16x8Sub\n  I16x8SubSatS\n  I16x8SubSatU\n  F64x2Nearest\n  I16x8Mul\n  I16x8MinS\n  I16x8MinU\n  I16x8MaxS\n  I16x8MaxU\n  I16x8AvgrU\n  I16x8ExtmulLowI8x16S\n  I16x8ExtmulHighI8x16S\n  I16x8ExtmulLowI8x16U\n  I16x8ExtmulHighI8x16U\n  I32x4Abs\n  I32x4Neg\n  I32x4AllTrue\n  I32x4Bitmask\n  I32x4ExtendLowI16x8S\n  I32x4ExtendHighI16x8S\n  I32x4ExtendLowI16x8U\n  I32x4ExtendHighI16x8U\n  I32x4Shl\n  I32x4ShrS\n  I32x4ShrU\n  I32x4Add\n  I32x4Sub\n  I32x4Mul\n  I32x4MinS\n  I32x4MinU\n  I32x4MaxS\n  I32x4MaxU\n  I32x4DotI16x8S\n  I32x4ExtmulLowI16x8S\n  I32x4ExtmulHighI16x8S\n  I32x4ExtmulLowI16x8U\n  I32x4ExtmulHighI16x8U\n  I64x2Abs\n  I64x2Neg\n  I64x2AllTrue\n  I64x2Bitmask\n  I64x2ExtendLowI32x4S\n  I64x2ExtendHighI32x4S\n  I64x2ExtendLowI32x4U\n  I64x2ExtendHighI32x4U\n  I64x2Shl\n  I64x2ShrS\n  I64x2ShrU\n  I64x2Add\n  I64x2Sub\n  I64x2Mul\n  I64x2Eq\n  I64x2Ne\n  I64x2LtS\n  I64x2GtS\n  I64x2LeS\n  I64x2GeS\n  I64x2ExtmulLowI32x4S\n  I64x2ExtmulHighI32x4S\n  I64x2ExtmulLowI32x4U\n  I64x2ExtmulHighI32x4U\n  F32x4Abs\n  F32x4Neg\n  F32x4Sqrt\n  F32x4Add\n  F32x4Sub\n  F32x4Mul\n  F32x4Div\n  F32x4Min\n  F32x4Max\n  F32x4Pmin\n  F32x4Pmax\n  F64x2Abs\n  F64x2Neg\n  F64x2Sqrt\n  F64x2Add\n  F64x2Sub\n  F64x2Mul\n  F64x2Div\n  F64x2Min\n  F64x2Max\n  F64x2Pmin\n  F64x2Pmax\n  I32x4TruncSatF32x4S\n  I32x4TruncSatF32x4U\n  F32x4ConvertI32x4S\n  F32x4ConvertI32x4U\n  I32x4TruncSatF64x2SZero\n  I32x4TruncSatF64x2UZero\n  F64x2ConvertLowI32x4S\n  F64x2ConvertLowI32x4U\n  I8x16RelaxedSwizzle\n  I32x4RelaxedTruncF32x4S\n  I32x4RelaxedTruncF32x4U\n  I32x4RelaxedTruncZeroF64x2S\n  I32x4RelaxedTruncZeroF64x2U\n  F32x4RelaxedMadd\n  F32x4RelaxedNmadd\n  F64x2RelaxedMadd\n  F64x2RelaxedNmadd\n  I8x16RelaxedLaneselect\n  I16x8RelaxedLaneselect\n  I32x4RelaxedLaneselect\n  I64x2RelaxedLaneselect\n  F32x4RelaxedMin\n  F32x4RelaxedMax\n  F64x2RelaxedMin\n  F64x2RelaxedMax\n  I16x8RelaxedQ15mulrS\n  I16x8RelaxedDotI8x16I7x16S\n  I32x4RelaxedDotI8x16I7x16AddS\n} derive(Eq, Hash)\n\n///|\npub impl @quickcheck.Arbitrary for MemArg with arbitrary(t, state) {\n  MemArg(\n    U32(state.next_uint() % 64),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n    @quickcheck.Arbitrary::arbitrary(t, state),\n  )\n}\n\n///|\npub impl @quickcheck.Arbitrary for Instruction with arbitrary(t, state) {\n  match state.next_uint() % 494 {\n    0 => Unreachable\n    1 => Nop\n    2 =>\n      Block(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    3 =>\n      Loop(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    4 =>\n      If(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        array_of_arbitrary(5, t, state),\n        if (state.next_uint() & 1) == 1 {\n          Some(array_of_arbitrary(5, t, state))\n        } else {\n          None\n        },\n      )\n    5 => Throw(@quickcheck.Arbitrary::arbitrary(t, state))\n    6 => ThrowRef\n    7 => Br(@quickcheck.Arbitrary::arbitrary(t, state))\n    8 => BrIf(@quickcheck.Arbitrary::arbitrary(t, state))\n    9 =>\n      BrTable(\n        array_of_arbitrary(3, t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    10 => Return\n    11 => Call(@quickcheck.Arbitrary::arbitrary(t, state))\n    12 =>\n      CallIndirect(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    13 => ReturnCall(@quickcheck.Arbitrary::arbitrary(t, state))\n    14 =>\n      ReturnCallIndirect(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    15 => CallRef(@quickcheck.Arbitrary::arbitrary(t, state))\n    16 => ReturnCallRef(@quickcheck.Arbitrary::arbitrary(t, state))\n    17 => Drop\n    18 =>\n      TryTable(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        array_of_arbitrary(4, t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    19 =>\n      Select(\n        if @quickcheck.Arbitrary::arbitrary(t, state) {\n          Some(array_of_arbitrary(4, t, state))\n        } else {\n          None\n        },\n      )\n    20 => LocalGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    21 => LocalSet(@quickcheck.Arbitrary::arbitrary(t, state))\n    22 => LocalTee(@quickcheck.Arbitrary::arbitrary(t, state))\n    23 => GlobalGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    24 => GlobalSet(@quickcheck.Arbitrary::arbitrary(t, state))\n    25 => TableGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    26 => TableSet(@quickcheck.Arbitrary::arbitrary(t, state))\n    27 => I32Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    28 => I64Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    29 => F32Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    30 => F64Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    31 => I32Load8S(@quickcheck.Arbitrary::arbitrary(t, state))\n    32 => I32Load8U(@quickcheck.Arbitrary::arbitrary(t, state))\n    33 => I32Load16S(@quickcheck.Arbitrary::arbitrary(t, state))\n    34 => I32Load16U(@quickcheck.Arbitrary::arbitrary(t, state))\n    35 => I64Load8S(@quickcheck.Arbitrary::arbitrary(t, state))\n    36 => I64Load8U(@quickcheck.Arbitrary::arbitrary(t, state))\n    37 => I64Load16S(@quickcheck.Arbitrary::arbitrary(t, state))\n    38 => I64Load16U(@quickcheck.Arbitrary::arbitrary(t, state))\n    39 => I64Load32S(@quickcheck.Arbitrary::arbitrary(t, state))\n    40 => I64Load32U(@quickcheck.Arbitrary::arbitrary(t, state))\n    41 => I32Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    42 => I64Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    43 => F32Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    44 => F64Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    45 => I32Store8(@quickcheck.Arbitrary::arbitrary(t, state))\n    46 => I32Store16(@quickcheck.Arbitrary::arbitrary(t, state))\n    47 => I64Store8(@quickcheck.Arbitrary::arbitrary(t, state))\n    48 => I64Store16(@quickcheck.Arbitrary::arbitrary(t, state))\n    49 => I64Store32(@quickcheck.Arbitrary::arbitrary(t, state))\n    50 => MemorySize(@quickcheck.Arbitrary::arbitrary(t, state))\n    51 => MemoryGrow(@quickcheck.Arbitrary::arbitrary(t, state))\n    52 => I32Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    53 => I64Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    54 => F32Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    55 => F64Const(@quickcheck.Arbitrary::arbitrary(t, state))\n    56 => I32Eqz\n    57 => I32Eq\n    58 => I32Ne\n    59 => I32LtS\n    60 => I32LtU\n    61 => I32GtS\n    62 => I32GtU\n    63 => I32LeS\n    64 => I32LeU\n    65 => I32GeS\n    66 => I32GeU\n    67 => I64Eqz\n    68 => I64Eq\n    69 => I64Ne\n    70 => I64LtS\n    71 => I64LtU\n    72 => I64GtS\n    73 => I64GtU\n    74 => I64LeS\n    75 => I64LeU\n    76 => I64GeS\n    77 => I64GeU\n    78 => F32Eq\n    79 => F32Ne\n    80 => F32Lt\n    81 => F32Gt\n    82 => F32Le\n    83 => F32Ge\n    84 => F64Eq\n    85 => F64Ne\n    86 => F64Lt\n    87 => F64Gt\n    88 => F64Le\n    89 => F64Ge\n    90 => I32Clz\n    91 => I32Ctz\n    92 => I32Popcnt\n    93 => I32Add\n    94 => I32Sub\n    95 => I32Mul\n    96 => I32DivS\n    97 => I32DivU\n    98 => I32RemS\n    99 => I32RemU\n    100 => I32And\n    101 => I32Or\n    102 => I32Xor\n    103 => I32Shl\n    104 => I32ShrS\n    105 => I32ShrU\n    106 => I32Rotl\n    107 => I32Rotr\n    108 => I64Clz\n    109 => I64Ctz\n    110 => I64Popcnt\n    111 => I64Add\n    112 => I64Sub\n    113 => I64Mul\n    114 => I64DivS\n    115 => I64DivU\n    116 => I64RemS\n    117 => I64RemU\n    118 => I64And\n    119 => I64Or\n    120 => I64Xor\n    121 => I64Shl\n    122 => I64ShrS\n    123 => I64ShrU\n    124 => I64Rotl\n    125 => I64Rotr\n    126 => F32Abs\n    127 => F32Neg\n    128 => F32Ceil\n    129 => F32Floor\n    130 => F32Trunc\n    131 => F32Nearest\n    132 => F32Sqrt\n    133 => F32Add\n    134 => F32Sub\n    135 => F32Mul\n    136 => F32Div\n    137 => F32Min\n    138 => F32Max\n    139 => F32Copysign\n    140 => F64Abs\n    141 => F64Neg\n    142 => F64Ceil\n    143 => F64Floor\n    144 => F64Trunc\n    145 => F64Nearest\n    146 => F64Sqrt\n    147 => F64Add\n    148 => F64Sub\n    149 => F64Mul\n    150 => F64Div\n    151 => F64Min\n    152 => F64Max\n    153 => F64Copysign\n    154 => I32WrapI64\n    155 => I32TruncF32S\n    156 => I32TruncF32U\n    157 => I32TruncF64S\n    158 => I32TruncF64U\n    159 => I64ExtendI32S\n    160 => I64ExtendI32U\n    161 => I64TruncF32S\n    162 => I64TruncF32U\n    163 => I64TruncF64S\n    164 => I64TruncF64U\n    165 => F32ConvertI32S\n    166 => F32ConvertI32U\n    167 => F32ConvertI64S\n    168 => F32ConvertI64U\n    169 => F32DemoteF64\n    170 => F64ConvertI32S\n    171 => F64ConvertI32U\n    172 => F64ConvertI64S\n    173 => F64ConvertI64U\n    174 => F64PromoteF32\n    175 => I32ReinterpretF32\n    176 => I64ReinterpretF64\n    177 => F32ReinterpretI32\n    178 => F64ReinterpretI64\n    179 => I32Extend8S\n    180 => I32Extend16S\n    181 => I64Extend8S\n    182 => I64Extend16S\n    183 => I64Extend32S\n    184 => RefNull(@quickcheck.Arbitrary::arbitrary(t, state))\n    185 => RefIsNull\n    186 => RefFunc(@quickcheck.Arbitrary::arbitrary(t, state))\n    187 => RefEq\n    188 => RefAsNonNull\n    189 => BrOnNull(@quickcheck.Arbitrary::arbitrary(t, state))\n    190 => BrOnNonNull(@quickcheck.Arbitrary::arbitrary(t, state))\n    191 => StructNew(@quickcheck.Arbitrary::arbitrary(t, state))\n    192 => StructNewDefault(@quickcheck.Arbitrary::arbitrary(t, state))\n    193 =>\n      StructGet(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    194 =>\n      StructGetS(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    195 =>\n      StructGetU(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    196 =>\n      StructSet(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    197 => ArrayNew(@quickcheck.Arbitrary::arbitrary(t, state))\n    198 => ArrayNewDefault(@quickcheck.Arbitrary::arbitrary(t, state))\n    199 =>\n      ArrayNewFixed(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    200 =>\n      ArrayNewData(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    201 =>\n      ArrayNewElem(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    202 => ArrayGet(@quickcheck.Arbitrary::arbitrary(t, state))\n    203 => ArrayGetS(@quickcheck.Arbitrary::arbitrary(t, state))\n    204 => ArrayGetU(@quickcheck.Arbitrary::arbitrary(t, state))\n    205 => ArraySet(@quickcheck.Arbitrary::arbitrary(t, state))\n    206 => ArrayLen\n    207 => ArrayFill(@quickcheck.Arbitrary::arbitrary(t, state))\n    208 =>\n      ArrayCopy(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    209 =>\n      ArrayInitData(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    210 =>\n      ArrayInitElem(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    211 =>\n      RefTest(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    212 =>\n      RefCast(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    213 =>\n      BrOnCast(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    214 =>\n      BrOnCastFail(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    215 => AnyConvertExtern\n    216 => ExternConvertAny\n    217 => RefI31\n    218 => I31GetS\n    219 => I31GetU\n    220 => I32TruncSatF32S\n    221 => I32TruncSatF32U\n    222 => I32TruncSatF64S\n    223 => I32TruncSatF64U\n    224 => I64TruncSatF32S\n    225 => I64TruncSatF32U\n    226 => I64TruncSatF64S\n    227 => I64TruncSatF64U\n    228 =>\n      MemoryInit(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    229 => DataDrop(@quickcheck.Arbitrary::arbitrary(t, state))\n    230 =>\n      MemoryCopy(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    231 => MemoryFill(@quickcheck.Arbitrary::arbitrary(t, state))\n    232 =>\n      TableInit(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    233 => ElemDrop(@quickcheck.Arbitrary::arbitrary(t, state))\n    234 =>\n      TableCopy(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    235 => TableGrow(@quickcheck.Arbitrary::arbitrary(t, state))\n    236 => TableSize(@quickcheck.Arbitrary::arbitrary(t, state))\n    237 => TableFill(@quickcheck.Arbitrary::arbitrary(t, state))\n    238 => V128Load(@quickcheck.Arbitrary::arbitrary(t, state))\n    239 => V128Load8x8S(@quickcheck.Arbitrary::arbitrary(t, state))\n    240 => V128Load8x8U(@quickcheck.Arbitrary::arbitrary(t, state))\n    241 => V128Load16x4S(@quickcheck.Arbitrary::arbitrary(t, state))\n    242 => V128Load16x4U(@quickcheck.Arbitrary::arbitrary(t, state))\n    243 => V128Load32x2S(@quickcheck.Arbitrary::arbitrary(t, state))\n    244 => V128Load32x2U(@quickcheck.Arbitrary::arbitrary(t, state))\n    245 => V128Load8Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    246 => V128Load16Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    247 => V128Load32Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    248 => V128Load64Splat(@quickcheck.Arbitrary::arbitrary(t, state))\n    249 => V128Store(@quickcheck.Arbitrary::arbitrary(t, state))\n    250 =>\n      V128Const(\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n        (state.next_uint() % 256).to_byte(),\n      )\n    251 =>\n      I8x16Shuffle(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    252 => I8x16Swizzle\n    253 => I8x16Splat\n    254 => I16x8Splat\n    255 => I32x4Splat\n    256 => I64x2Splat\n    257 => F32x4Splat\n    258 => F64x2Splat\n    259 => I8x16ExtractLaneS(@quickcheck.Arbitrary::arbitrary(t, state))\n    260 => I8x16ExtractLaneU(@quickcheck.Arbitrary::arbitrary(t, state))\n    261 => I8x16ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    262 => I16x8ExtractLaneS(@quickcheck.Arbitrary::arbitrary(t, state))\n    263 => I16x8ExtractLaneU(@quickcheck.Arbitrary::arbitrary(t, state))\n    264 => I16x8ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    265 => I32x4ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    266 => I32x4ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    267 => I64x2ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    268 => I64x2ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    269 => F32x4ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    270 => F32x4ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    271 => F64x2ExtractLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    272 => F64x2ReplaceLane(@quickcheck.Arbitrary::arbitrary(t, state))\n    273 => I8x16Eq\n    274 => I8x16Ne\n    275 => I8x16LtS\n    276 => I8x16LtU\n    277 => I8x16GtS\n    278 => I8x16GtU\n    279 => I8x16LeS\n    280 => I8x16LeU\n    281 => I8x16GeS\n    282 => I8x16GeU\n    283 => I16x8Eq\n    284 => I16x8Ne\n    285 => I16x8LtS\n    286 => I16x8LtU\n    287 => I16x8GtS\n    288 => I16x8GtU\n    289 => I16x8LeS\n    290 => I16x8LeU\n    291 => I16x8GeS\n    292 => I16x8GeU\n    293 => I32x4Eq\n    294 => I32x4Ne\n    295 => I32x4LtS\n    296 => I32x4LtU\n    297 => I32x4GtS\n    298 => I32x4GtU\n    299 => I32x4LeS\n    300 => I32x4LeU\n    301 => I32x4GeS\n    302 => I32x4GeU\n    303 => F32x4Eq\n    304 => F32x4Ne\n    305 => F32x4Lt\n    306 => F32x4Gt\n    307 => F32x4Le\n    308 => F32x4Ge\n    309 => F64x2Eq\n    310 => F64x2Ne\n    311 => F64x2Lt\n    312 => F64x2Gt\n    313 => F64x2Le\n    314 => F64x2Ge\n    315 => V128Not\n    316 => V128And\n    317 => V128Andnot\n    318 => V128Or\n    319 => V128Xor\n    320 => V128Bitselect\n    321 => V128AnyTrue\n    322 =>\n      V128Load8Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    323 =>\n      V128Load16Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    324 =>\n      V128Load32Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    325 =>\n      V128Load64Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    326 =>\n      V128Store8Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    327 =>\n      V128Store16Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    328 =>\n      V128Store32Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    329 =>\n      V128Store64Lane(\n        @quickcheck.Arbitrary::arbitrary(t, state),\n        @quickcheck.Arbitrary::arbitrary(t, state),\n      )\n    330 => V128Load32Zero(@quickcheck.Arbitrary::arbitrary(t, state))\n    331 => V128Load64Zero(@quickcheck.Arbitrary::arbitrary(t, state))\n    332 => F32x4DemoteF64x2Zero\n    333 => F64x2PromoteLowF32x4\n    334 => I8x16Abs\n    335 => I8x16Neg\n    336 => I8x16Popcnt\n    337 => I8x16AllTrue\n    338 => I8x16Bitmask\n    339 => I8x16NarrowI16x8S\n    340 => I8x16NarrowI16x8U\n    341 => F32x4Ceil\n    342 => F32x4Floor\n    343 => F32x4Trunc\n    344 => F32x4Nearest\n    345 => I8x16Shl\n    346 => I8x16ShrS\n    347 => I8x16ShrU\n    348 => I8x16Add\n    349 => I8x16AddSatS\n    350 => I8x16AddSatU\n    351 => I8x16Sub\n    352 => I8x16SubSatS\n    353 => I8x16SubSatU\n    354 => F64x2Ceil\n    355 => F64x2Floor\n    356 => I8x16MinS\n    357 => I8x16MinU\n    358 => I8x16MaxS\n    359 => I8x16MaxU\n    360 => F64x2Trunc\n    361 => I8x16AvgrU\n    362 => I16x8ExtaddPairwiseI8x16S\n    363 => I16x8ExtaddPairwiseI8x16U\n    364 => I32x4ExtaddPairwiseI16x8S\n    365 => I32x4ExtaddPairwiseI16x8U\n    366 => I16x8Abs\n    367 => I16x8Neg\n    368 => I16x8Q15mulrSatS\n    369 => I16x8AllTrue\n    370 => I16x8Bitmask\n    371 => I16x8NarrowI32x4S\n    372 => I16x8NarrowI32x4U\n    373 => I16x8ExtendLowI8x16S\n    374 => I16x8ExtendHighI8x16S\n    375 => I16x8ExtendLowI8x16U\n    376 => I16x8ExtendHighI8x16U\n    377 => I16x8Shl\n    378 => I16x8ShrS\n    379 => I16x8ShrU\n    380 => I16x8Add\n    381 => I16x8AddSatS\n    382 => I16x8AddSatU\n    383 => I16x8Sub\n    384 => I16x8SubSatS\n    385 => I16x8SubSatU\n    386 => F64x2Nearest\n    387 => I16x8Mul\n    388 => I16x8MinS\n    389 => I16x8MinU\n    390 => I16x8MaxS\n    391 => I16x8MaxU\n    392 => I16x8AvgrU\n    393 => I16x8ExtmulLowI8x16S\n    394 => I16x8ExtmulHighI8x16S\n    395 => I16x8ExtmulLowI8x16U\n    396 => I16x8ExtmulHighI8x16U\n    397 => I32x4Abs\n    398 => I32x4Neg\n    399 => I32x4AllTrue\n    400 => I32x4Bitmask\n    401 => I32x4ExtendLowI16x8S\n    402 => I32x4ExtendHighI16x8S\n    403 => I32x4ExtendLowI16x8U\n    404 => I32x4ExtendHighI16x8U\n    405 => I32x4Shl\n    406 => I32x4ShrS\n    407 => I32x4ShrU\n    408 => I32x4Add\n    409 => I32x4Sub\n    410 => I32x4Mul\n    411 => I32x4MinS\n    412 => I32x4MinU\n    413 => I32x4MaxS\n    414 => I32x4MaxU\n    415 => I32x4DotI16x8S\n    416 => I32x4ExtmulLowI16x8S\n    417 => I32x4ExtmulHighI16x8S\n    418 => I32x4ExtmulLowI16x8U\n    419 => I32x4ExtmulHighI16x8U\n    420 => I64x2Abs\n    421 => I64x2Neg\n    422 => I64x2AllTrue\n    423 => I64x2Bitmask\n    424 => I64x2ExtendLowI32x4S\n    425 => I64x2ExtendHighI32x4S\n    426 => I64x2ExtendLowI32x4U\n    427 => I64x2ExtendHighI32x4U\n    428 => I64x2Shl\n    429 => I64x2ShrS\n    430 => I64x2ShrU\n    431 => I64x2Add\n    432 => I64x2Sub\n    433 => I64x2Mul\n    434 => I64x2Eq\n    435 => I64x2Ne\n    436 => I64x2LtS\n    437 => I64x2GtS\n    438 => I64x2LeS\n    439 => I64x2GeS\n    440 => I64x2ExtmulLowI32x4S\n    441 => I64x2ExtmulHighI32x4S\n    442 => I64x2ExtmulLowI32x4U\n    443 => I64x2ExtmulHighI32x4U\n    444 => F32x4Abs\n    445 => F32x4Neg\n    446 => F32x4Sqrt\n    447 => F32x4Add\n    448 => F32x4Sub\n    449 => F32x4Mul\n    450 => F32x4Div\n    451 => F32x4Min\n    452 => F32x4Max\n    453 => F32x4Pmin\n    454 => F32x4Pmax\n    455 => F64x2Abs\n    456 => F64x2Neg\n    457 => F64x2Sqrt\n    458 => F64x2Add\n    459 => F64x2Sub\n    460 => F64x2Mul\n    461 => F64x2Div\n    462 => F64x2Min\n    463 => F64x2Max\n    464 => F64x2Pmin\n    465 => F64x2Pmax\n    466 => I32x4TruncSatF32x4S\n    467 => I32x4TruncSatF32x4U\n    468 => F32x4ConvertI32x4S\n    469 => F32x4ConvertI32x4U\n    470 => I32x4TruncSatF64x2SZero\n    471 => I32x4TruncSatF64x2UZero\n    472 => F64x2ConvertLowI32x4S\n    473 => F64x2ConvertLowI32x4U\n    474 => I8x16RelaxedSwizzle\n    475 => I32x4RelaxedTruncF32x4S\n    476 => I32x4RelaxedTruncF32x4U\n    477 => I32x4RelaxedTruncZeroF64x2S\n    478 => I32x4RelaxedTruncZeroF64x2U\n    479 => F32x4RelaxedMadd\n    480 => F32x4RelaxedNmadd\n    481 => F64x2RelaxedMadd\n    482 => F64x2RelaxedNmadd\n    483 => I8x16RelaxedLaneselect\n    484 => I16x8RelaxedLaneselect\n    485 => I32x4RelaxedLaneselect\n    486 => I64x2RelaxedLaneselect\n    487 => F32x4RelaxedMin\n    488 => F32x4RelaxedMax\n    489 => F64x2RelaxedMin\n    490 => F64x2RelaxedMax\n    491 => I16x8RelaxedQ15mulrS\n    492 => I16x8RelaxedDotI8x16I7x16S\n    493 => I32x4RelaxedDotI8x16I7x16AddS\n    _ => Nop\n  }\n}\n\n///|\npub impl @quickcheck.Arbitrary for ElemSec with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  ElemSec(elems)\n}\n\n///|\npub impl @quickcheck.Arbitrary for CodeSec with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  CodeSec(elems)\n}\n\n///|\npub impl @quickcheck.Arbitrary for DataSec with arbitrary(t, state) {\n  let elems = []\n  let count = state.next_positive_int() % 4 + 1\n  loop count {\n    0 => break ()\n    n => {\n      elems.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n  DataSec(elems)\n}\n\n///|\npub impl @quickcheck.Arbitrary for CustomSec with arbitrary(size, st) {\n  let name = @quickcheck.Arbitrary::arbitrary(size, st)\n  let length = st.next_positive_int() % 19 + 1\n  let buf = @buffer.new()\n  let bytes = loop length {\n    0 => buf.to_bytes()\n    n => {\n      buf.write_byte((st.next_positive_int() % 256).to_byte())\n      continue n - 1\n    }\n  }\n  CustomSec(name, bytes)\n}\n\n///|\npub impl @quickcheck.Arbitrary for Module with arbitrary(t, state) {\n  Module(\n    array_of_arbitrary(5, t, state),\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n    if state.next_positive_int() % 2 == 0 {\n      Some(@quickcheck.Arbitrary::arbitrary(t, state))\n    } else {\n      None\n    },\n  )\n}\n\n///|\ntype Stack[T] = Array[T]\n\n///|\npub fn Limits::mem_addr_bits(lim : Limits) -> Int {\n  match lim {\n    I32Limits(_, _) => 32\n    I64Limits(_, _) => 64\n  }\n}\n\n///|\npub fn[T : @quickcheck.Arbitrary] array_of_arbitrary(\n  max : UInt,\n  t : Int,\n  state : @quickcheck/splitmix.RandomState,\n) -> Array[T] {\n  let count = state.next_uint() % max + 1\n  let a = []\n  loop count {\n    0 => break a\n    n => {\n      a.push(@quickcheck.Arbitrary::arbitrary(t, state))\n      continue n - 1\n    }\n  }\n}\n\n///|\npub fn RefType::is_nullable(rt : RefType) -> Bool {\n  match rt {\n    HeapTypeRefType(b, _) => b\n    AbsHeapTypeRefType(_) => true\n  }\n}\n\n///|\npub fn RefType::get_heap_type(rt : RefType) -> HeapType {\n  match rt {\n    HeapTypeRefType(_, ht) => ht\n    AbsHeapTypeRefType(ahs) => AbsHeapTypeHeapType(ahs)\n  }\n}\n\n///|\npub fn SubType::super_types(self : SubType) -> Array[TypeIdx] {\n  match self {\n    SubType(_, sts, _) => sts\n    CompTypeSubType(_) => []\n  }\n}\n\n///|\npub fn SubType::get_comptype(self : SubType) -> CompType {\n  match self {\n    SubType(_, _, ct) => ct\n    CompTypeSubType(ct) => ct\n  }\n}\n\n///|\npub fn RecType::get_subtype(self : RecType, idx : UInt) -> SubType? {\n  match (self, idx) {\n    (SingleRecType(st), 0) => Some(st)\n    (GroupRecType(sts), i) => sts.get(i.reinterpret_as_int())\n    _ => None\n  }\n}\n\n///|\npub fn DefType::project(self : DefType) -> SubType? {\n  let DefType(rt, n) = self\n  match rt {\n    SingleRecType(st) => if n == 0 { Some(st) } else { None }\n    GroupRecType(sts) => sts.get(n.reinterpret_as_int())\n  }\n}\n\n///|\npub impl Show for FuncType with output(self, logger) {\n  let FuncType(props, results) = self\n  logger.write_string(\"FuncType {\\n  props : \")\n  props.output(logger)\n  logger.write_string(\"\\n  results : \")\n  results.output(logger)\n  logger.write_string(\"\\n}\")\n}\n\n///|\npub impl Show for Env with output(self, logger) {\n  logger.write_string(\"Env {\\n  global_types : \")\n  self.global_types.output(logger)\n  logger.write_string(\"\\n  rec_stack : \")\n  self.rec_stack.output(logger)\n  logger.write_string(\"\\n  funcs : \")\n  self.funcs.output(logger)\n  logger.write_string(\"\\n  tables : \")\n  self.tables.output(logger)\n  logger.write_string(\"\\n  mems : \")\n  self.mems.output(logger)\n  logger.write_string(\"\\n  globals : \")\n  self.globals.output(logger)\n  logger.write_string(\"\\n  elems : \")\n  self.elems.output(logger)\n  logger.write_string(\"\\n  datas : \")\n  self.datas.output(logger)\n  logger.write_string(\"\\n  tags : \")\n  self.tags.output(logger)\n  logger.write_string(\"\\n  locals : \")\n  self.locals.output(logger)\n  logger.write_string(\"\\n  labels : \")\n  self.labels.output(logger)\n  logger.write_string(\"\\n  return_type : \")\n  self.return_type.output(logger)\n  logger.write_string(\"\\n}\")\n}\n\n///|\npub fn i32_valtype() -> ValType {\n  NumTypeValType(I32NumType)\n}\n\n///|\npub fn i64_valtype() -> ValType {\n  NumTypeValType(I64NumType)\n}\n\n///|\npub fn ref_valtype(rt : RefType) -> ValType {\n  RefTypeValType(rt)\n}\n\n///|\npub fn ref_null_exn_valtype() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(ExnAbsHeapType)))\n}\n\n///|\npub fn funcref_valtype() -> ValType {\n  // In core Wasm, call_indirect uses funcref.\n  // Your encoding: AbsHeapTypeRefType(_) is nullable; funcref is (ref null func).\n  RefTypeValType(AbsHeapTypeRefType(FuncAbsHeapType))\n}\n\n///|\npub fn[T : Eq] equals(a : Array[T], b : Array[T]) -> Bool {\n  if a.length() != b.length() {\n    return false\n  }\n  for i in 0..<a.length() {\n    if a[i] != b[i] {\n      return false\n    }\n  }\n  true\n}\n\n///|\npub fn Limits::addr_valtype(at : Limits) -> ValType {\n  match at {\n    I32Limits(_) => NumTypeValType(I32NumType)\n    I64Limits(_) => NumTypeValType(I64NumType)\n  }\n}\n\n///|\npub fn min_addr(a : Limits, b : Limits) -> Limits {\n  match (a, b) {\n    (I32Limits(_), _) => a\n    (_, I32Limits(_)) => b\n    _ => a\n  }\n}\n\n///|\npub fn elem_reftype(e : Elem) -> RefType {\n  match e {\n    Elem(_, kind) =>\n      match kind {\n        FuncsElemKind(_) => AbsHeapTypeRefType(FuncAbsHeapType) // funcref\n        FuncExprsElemKind(_) => AbsHeapTypeRefType(FuncAbsHeapType) // funcref\n        TypedExprsElemKind(rt, _) => rt\n      }\n  }\n}\n\n///|\npub fn ref_null_valtype(ht : HeapType) -> ValType {\n  RefTypeValType(HeapTypeRefType(true, ht))\n}\n\n///|\npub fn eqref_null_valtype() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(EqAbsHeapType)))\n}\n\n///|\npub fn unpack_storage(st : StorageType) -> ValType {\n  match st {\n    ValTypeStorageType(vt) => vt\n    PackTypeStorageType(_) => NumTypeValType(I32NumType)\n  }\n}\n\n///|\npub fn is_packed(st : StorageType) -> Bool {\n  match st {\n    PackTypeStorageType(_) => true\n    _ => false\n  }\n}\n\n///|\npub fn u32_to_int(u : U32) -> Int {\n  let U32(i) = u\n  i.reinterpret_as_int()\n}\n\n///|\npub fn has_default(vt : ValType) -> Bool {\n  match vt {\n    NumTypeValType(_) => true\n    VecTypeValType => true\n    RefTypeValType(rt) => rt.is_nullable() // default is ref.null\n    BotValType => true\n  }\n}\n\n///|\npub fn get_struct_field(\n  fields : Array[FieldType],\n  i : U32,\n) -> Result[FieldType, String] {\n  let idx = u32_to_int(i)\n  match fields.get(idx) {\n    None => Err(\"struct field index out of range\")\n    Some(ft) => Ok(ft)\n  }\n}\n\n///|\npub fn field_is_mutable(ft : FieldType) -> Bool {\n  match ft {\n    FieldType(_, Var) => true\n    _ => false\n  }\n}\n\n///|\npub fn vt_i32() -> ValType {\n  NumTypeValType(I32NumType)\n}\n\n///|\npub fn vt_i64() -> ValType {\n  NumTypeValType(I64NumType)\n}\n\n///|\npub fn vt_f32() -> ValType {\n  NumTypeValType(F32NumType)\n}\n\n///|\npub fn vt_f64() -> ValType {\n  NumTypeValType(F64NumType)\n}\n\n///|\npub fn vt_v128() -> ValType {\n  VecTypeValType\n}\n\n///|\npub fn min_addr_valtype(l1 : Limits, l2 : Limits) -> ValType {\n  match (l1, l2) {\n    (I64Limits(_, _), I64Limits(_, _)) => NumTypeValType(I64NumType)\n    _ => NumTypeValType(I32NumType)\n  }\n}\n\n///|\npub fn anyref_valtype() -> ValType {\n  // (ref null any)\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(AnyAbsHeapType)))\n}\n\n///|\npub fn externref_valtype() -> ValType {\n  // (ref null extern)\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(ExternAbsHeapType)))\n}\n\n///|\npub fn i31ref_valtype() -> ValType {\n  // (ref i31) (non-null)\n  RefTypeValType(HeapTypeRefType(false, AbsHeapTypeHeapType(I31AbsHeapType)))\n}\n\n///|\npub fn i31ref_nullable_valtype() -> ValType {\n  RefTypeValType(HeapTypeRefType(true, AbsHeapTypeHeapType(I31AbsHeapType)))\n}\n\n///|\npub fn ref_array_nonnull(x : TypeIdx) -> ValType {\n  RefTypeValType(HeapTypeRefType(false, HeapType(x)))\n}\n\n///|\npub fn ref_array_nullable(x : TypeIdx) -> ValType {\n  RefTypeValType(HeapTypeRefType(true, HeapType(x)))\n}\n\n///|\npub fn ref_null_array_of(x : TypeIdx) -> ValType {\n  RefTypeValType(HeapTypeRefType(true, HeapType(x)))\n}\n\n///|\n/// A tree-based expression where operands are explicit children rather than implicit stack values.\n/// Each TInstr node contains its consumed operands as children.\npub(all) struct TExpr(Array[TInstr]) derive(Eq, Show, Hash)\n\n///|\n/// A tree-based instruction with explicit operands\npub(all) enum TInstr {\n  // === Constants (0 children, 1 result) ===\n  TI32Const(I32)\n  TI64Const(I64)\n  TF32Const(F32)\n  TF64Const(F64)\n  TRefNull(HeapType)\n  TRefFunc(FuncIdx)\n  TV128Const(\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte,\n    Byte\n  )\n\n  // === Nullary (0 children) ===\n  TUnreachable\n  TNop\n  TLocalGet(LocalIdx)\n  TGlobalGet(GlobalIdx)\n  TMemorySize(MemIdx)\n  TTableSize(TableIdx)\n\n  // === Unary (1 child) ===\n  TUnary(UnaryOp, TInstr)\n  TDrop(TInstr)\n  TLocalSet(LocalIdx, TInstr)\n  TLocalTee(LocalIdx, TInstr)\n  TGlobalSet(GlobalIdx, TInstr)\n  TRefIsNull(TInstr)\n  TRefAsNonNull(TInstr)\n  TI31GetS(TInstr)\n  TI31GetU(TInstr)\n  TRefI31(TInstr)\n  TArrayLen(TInstr)\n  TAnyConvertExtern(TInstr)\n  TExternConvertAny(TInstr)\n  TThrowRef(TInstr)\n\n  // === Binary (2 children) ===\n  TBinary(BinaryOp, TInstr, TInstr)\n  TRefEq(TInstr, TInstr)\n  TStore(StoreOp, MemArg, TInstr, TInstr) // addr, value\n\n  // === Load (1 child - address) ===\n  TLoad(LoadOp, MemArg, TInstr)\n\n  // === Memory operations ===\n  TMemoryGrow(MemIdx, TInstr)\n  TMemoryFill(MemIdx, TInstr, TInstr, TInstr) // dest, val, len\n  TMemoryCopy(MemIdx, MemIdx, TInstr, TInstr, TInstr) // dest, src, len\n  TMemoryInit(DataIdx, MemIdx, TInstr, TInstr, TInstr)\n  TDataDrop(DataIdx)\n\n  // === Table operations ===\n  TTableGet(TableIdx, TInstr)\n  TTableSet(TableIdx, TInstr, TInstr)\n  TTableGrow(TableIdx, TInstr, TInstr)\n  TTableFill(TableIdx, TInstr, TInstr, TInstr)\n  TTableCopy(TableIdx, TableIdx, TInstr, TInstr, TInstr)\n  TTableInit(ElemIdx, TableIdx, TInstr, TInstr, TInstr)\n  TElemDrop(ElemIdx)\n\n  // === Calls (N children based on function type) ===\n  TCall(FuncIdx, Array[TInstr])\n  TCallIndirect(TypeIdx, TableIdx, Array[TInstr], TInstr) // args, table index\n  TCallRef(TypeIdx, Array[TInstr], TInstr) // args, funcref\n  TReturnCall(FuncIdx, Array[TInstr])\n  TReturnCallIndirect(TypeIdx, TableIdx, Array[TInstr], TInstr)\n  TReturnCallRef(TypeIdx, Array[TInstr], TInstr)\n\n  // === Control flow ===\n  TBlock(BlockType, TExpr)\n  TLoop(BlockType, TExpr)\n  TIf(BlockType, TInstr, TExpr, TExpr?) // condition, then, else\n  TTryTable(BlockType, Array[Catch], TExpr)\n  TThrow(TagIdx, Array[TInstr])\n\n  // === Branches ===\n  TBr(LabelIdx, Array[TInstr]) // values to pass\n  TBrIf(LabelIdx, TInstr, Array[TInstr]) // condition, values\n  TBrTable(Array[LabelIdx], LabelIdx, TInstr, Array[TInstr]) // index, values\n  TBrOnNull(LabelIdx, TInstr, Array[TInstr])\n  TBrOnNonNull(LabelIdx, TInstr, Array[TInstr])\n  TBrOnCast(LabelIdx, CastOp, HeapType, HeapType, TInstr, Array[TInstr])\n  TBrOnCastFail(LabelIdx, CastOp, HeapType, HeapType, TInstr, Array[TInstr])\n  TReturn(Array[TInstr])\n\n  // === Select ===\n  TSelect(Array[ValType]?, TInstr, TInstr, TInstr) // cond, if_true, if_false\n\n  // === GC: Structs ===\n  TStructNew(TypeIdx, Array[TInstr])\n  TStructNewDefault(TypeIdx)\n  TStructGet(TypeIdx, U32, TInstr)\n  TStructGetS(TypeIdx, U32, TInstr)\n  TStructGetU(TypeIdx, U32, TInstr)\n  TStructSet(TypeIdx, U32, TInstr, TInstr) // struct, value\n\n  // === GC: Arrays ===\n  TArrayNew(TypeIdx, TInstr, TInstr) // init, len\n  TArrayNewDefault(TypeIdx, TInstr) // len\n  TArrayNewFixed(TypeIdx, Array[TInstr])\n  TArrayNewData(TypeIdx, DataIdx, TInstr, TInstr) // offset, len\n  TArrayNewElem(TypeIdx, ElemIdx, TInstr, TInstr)\n  TArrayGet(TypeIdx, TInstr, TInstr) // arr, idx\n  TArrayGetS(TypeIdx, TInstr, TInstr)\n  TArrayGetU(TypeIdx, TInstr, TInstr)\n  TArraySet(TypeIdx, TInstr, TInstr, TInstr) // arr, idx, val\n  TArrayFill(TypeIdx, TInstr, TInstr, TInstr, TInstr) // arr, offset, val, len\n  TArrayCopy(TypeIdx, TypeIdx, TInstr, TInstr, TInstr, TInstr, TInstr)\n  TArrayInitData(TypeIdx, DataIdx, TInstr, TInstr, TInstr, TInstr)\n  TArrayInitElem(TypeIdx, ElemIdx, TInstr, TInstr, TInstr, TInstr)\n\n  // === GC: Casts ===\n  TRefTest(Bool, HeapType, TInstr)\n  TRefCast(Bool, HeapType, TInstr)\n\n  // === SIMD: Splat (scalar -> v128) ===\n  TI8x16Splat(TInstr)\n  TI16x8Splat(TInstr)\n  TI32x4Splat(TInstr)\n  TI64x2Splat(TInstr)\n  TF32x4Splat(TInstr)\n  TF64x2Splat(TInstr)\n\n  // === SIMD: Extract lane (v128 -> scalar) ===\n  TExtractLane(ExtractLaneOp, LaneIdx, TInstr)\n\n  // === SIMD: Replace lane (v128, scalar -> v128) ===\n  TReplaceLane(ReplaceLaneOp, LaneIdx, TInstr, TInstr)\n\n  // === SIMD: Shuffle (v128, v128 -> v128 with 16 lane indices) ===\n  TI8x16Shuffle(\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    LaneIdx,\n    TInstr,\n    TInstr\n  )\n\n  // === SIMD: Swizzle (v128, v128 -> v128) ===\n  TI8x16Swizzle(TInstr, TInstr)\n  TI8x16RelaxedSwizzle(TInstr, TInstr)\n\n  // === SIMD: Shift (v128, i32 -> v128) ===\n  TV128Shift(V128ShiftOp, TInstr, TInstr)\n\n  // === SIMD: Ternary (v128, v128, v128 -> v128) ===\n  TV128Ternary(V128TernaryOp, TInstr, TInstr, TInstr)\n\n  // === SIMD: Lane load (v128, addr -> v128) ===\n  TV128LoadLane(V128LoadLaneOp, MemArg, LaneIdx, TInstr, TInstr)\n\n  // === SIMD: Lane store (v128, addr -> void) ===\n  TV128StoreLane(V128StoreLaneOp, MemArg, LaneIdx, TInstr, TInstr)\n} derive(Eq, Show, Hash)\n\n///|\n/// Unary operations\npub(all) enum UnaryOp {\n  // === Scalar ===\n  I32EqzOp\n  I64EqzOp\n  I32ClzOp\n  I32CtzOp\n  I32PopcntOp\n  I64ClzOp\n  I64CtzOp\n  I64PopcntOp\n  F32AbsOp\n  F32NegOp\n  F32CeilOp\n  F32FloorOp\n  F32TruncOp\n  F32NearestOp\n  F32SqrtOp\n  F64AbsOp\n  F64NegOp\n  F64CeilOp\n  F64FloorOp\n  F64TruncOp\n  F64NearestOp\n  F64SqrtOp\n  I32WrapI64Op\n  I32TruncF32SOp\n  I32TruncF32UOp\n  I32TruncF64SOp\n  I32TruncF64UOp\n  I64ExtendI32SOp\n  I64ExtendI32UOp\n  I64TruncF32SOp\n  I64TruncF32UOp\n  I64TruncF64SOp\n  I64TruncF64UOp\n  F32ConvertI32SOp\n  F32ConvertI32UOp\n  F32ConvertI64SOp\n  F32ConvertI64UOp\n  F32DemoteF64Op\n  F64ConvertI32SOp\n  F64ConvertI32UOp\n  F64ConvertI64SOp\n  F64ConvertI64UOp\n  F64PromoteF32Op\n  I32ReinterpretF32Op\n  I64ReinterpretF64Op\n  F32ReinterpretI32Op\n  F64ReinterpretI64Op\n  I32Extend8SOp\n  I32Extend16SOp\n  I64Extend8SOp\n  I64Extend16SOp\n  I64Extend32SOp\n  I32TruncSatF32SOp\n  I32TruncSatF32UOp\n  I32TruncSatF64SOp\n  I32TruncSatF64UOp\n  I64TruncSatF32SOp\n  I64TruncSatF32UOp\n  I64TruncSatF64SOp\n  I64TruncSatF64UOp\n\n  // === SIMD: v128 -> v128 ===\n  V128NotOp\n  I8x16AbsOp\n  I8x16NegOp\n  I8x16PopcntOp\n  I16x8AbsOp\n  I16x8NegOp\n  I32x4AbsOp\n  I32x4NegOp\n  I64x2AbsOp\n  I64x2NegOp\n  F32x4AbsOp\n  F32x4NegOp\n  F32x4SqrtOp\n  F32x4CeilOp\n  F32x4FloorOp\n  F32x4TruncOp\n  F32x4NearestOp\n  F64x2AbsOp\n  F64x2NegOp\n  F64x2SqrtOp\n  F64x2CeilOp\n  F64x2FloorOp\n  F64x2TruncOp\n  F64x2NearestOp\n\n  // === SIMD: v128 -> i32 (bitmask/alltrue) ===\n  V128AnyTrueOp\n  I8x16AllTrueOp\n  I8x16BitmaskOp\n  I16x8AllTrueOp\n  I16x8BitmaskOp\n  I32x4AllTrueOp\n  I32x4BitmaskOp\n  I64x2AllTrueOp\n  I64x2BitmaskOp\n\n  // === SIMD: Extend/narrow (v128 -> v128) ===\n  I16x8ExtendLowI8x16SOp\n  I16x8ExtendHighI8x16SOp\n  I16x8ExtendLowI8x16UOp\n  I16x8ExtendHighI8x16UOp\n  I32x4ExtendLowI16x8SOp\n  I32x4ExtendHighI16x8SOp\n  I32x4ExtendLowI16x8UOp\n  I32x4ExtendHighI16x8UOp\n  I64x2ExtendLowI32x4SOp\n  I64x2ExtendHighI32x4SOp\n  I64x2ExtendLowI32x4UOp\n  I64x2ExtendHighI32x4UOp\n\n  // === SIMD: Pairwise add (v128 -> v128) ===\n  I16x8ExtaddPairwiseI8x16SOp\n  I16x8ExtaddPairwiseI8x16UOp\n  I32x4ExtaddPairwiseI16x8SOp\n  I32x4ExtaddPairwiseI16x8UOp\n\n  // === SIMD: Conversion (v128 -> v128) ===\n  F32x4DemoteF64x2ZeroOp\n  F64x2PromoteLowF32x4Op\n  I32x4TruncSatF32x4SOp\n  I32x4TruncSatF32x4UOp\n  F32x4ConvertI32x4SOp\n  F32x4ConvertI32x4UOp\n  I32x4TruncSatF64x2SZeroOp\n  I32x4TruncSatF64x2UZeroOp\n  F64x2ConvertLowI32x4SOp\n  F64x2ConvertLowI32x4UOp\n\n  // === SIMD: Relaxed truncation (v128 -> v128) ===\n  I32x4RelaxedTruncF32x4SOp\n  I32x4RelaxedTruncF32x4UOp\n  I32x4RelaxedTruncZeroF64x2SOp\n  I32x4RelaxedTruncZeroF64x2UOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Binary operations\npub(all) enum BinaryOp {\n  // === Scalar ===\n  I32EqOp\n  I32NeOp\n  I32LtSOp\n  I32LtUOp\n  I32GtSOp\n  I32GtUOp\n  I32LeSOp\n  I32LeUOp\n  I32GeSOp\n  I32GeUOp\n  I64EqOp\n  I64NeOp\n  I64LtSOp\n  I64LtUOp\n  I64GtSOp\n  I64GtUOp\n  I64LeSOp\n  I64LeUOp\n  I64GeSOp\n  I64GeUOp\n  F32EqOp\n  F32NeOp\n  F32LtOp\n  F32GtOp\n  F32LeOp\n  F32GeOp\n  F64EqOp\n  F64NeOp\n  F64LtOp\n  F64GtOp\n  F64LeOp\n  F64GeOp\n  I32AddOp\n  I32SubOp\n  I32MulOp\n  I32DivSOp\n  I32DivUOp\n  I32RemSOp\n  I32RemUOp\n  I32AndOp\n  I32OrOp\n  I32XorOp\n  I32ShlOp\n  I32ShrSOp\n  I32ShrUOp\n  I32RotlOp\n  I32RotrOp\n  I64AddOp\n  I64SubOp\n  I64MulOp\n  I64DivSOp\n  I64DivUOp\n  I64RemSOp\n  I64RemUOp\n  I64AndOp\n  I64OrOp\n  I64XorOp\n  I64ShlOp\n  I64ShrSOp\n  I64ShrUOp\n  I64RotlOp\n  I64RotrOp\n  F32AddOp\n  F32SubOp\n  F32MulOp\n  F32DivOp\n  F32MinOp\n  F32MaxOp\n  F32CopysignOp\n  F64AddOp\n  F64SubOp\n  F64MulOp\n  F64DivOp\n  F64MinOp\n  F64MaxOp\n  F64CopysignOp\n\n  // === SIMD: Bitwise (v128, v128 -> v128) ===\n  V128AndOp\n  V128AndnotOp\n  V128OrOp\n  V128XorOp\n\n  // === SIMD: i8x16 comparisons ===\n  I8x16EqOp\n  I8x16NeOp\n  I8x16LtSOp\n  I8x16LtUOp\n  I8x16GtSOp\n  I8x16GtUOp\n  I8x16LeSOp\n  I8x16LeUOp\n  I8x16GeSOp\n  I8x16GeUOp\n\n  // === SIMD: i16x8 comparisons ===\n  I16x8EqOp\n  I16x8NeOp\n  I16x8LtSOp\n  I16x8LtUOp\n  I16x8GtSOp\n  I16x8GtUOp\n  I16x8LeSOp\n  I16x8LeUOp\n  I16x8GeSOp\n  I16x8GeUOp\n\n  // === SIMD: i32x4 comparisons ===\n  I32x4EqOp\n  I32x4NeOp\n  I32x4LtSOp\n  I32x4LtUOp\n  I32x4GtSOp\n  I32x4GtUOp\n  I32x4LeSOp\n  I32x4LeUOp\n  I32x4GeSOp\n  I32x4GeUOp\n\n  // === SIMD: i64x2 comparisons ===\n  I64x2EqOp\n  I64x2NeOp\n  I64x2LtSOp\n  I64x2GtSOp\n  I64x2LeSOp\n  I64x2GeSOp\n\n  // === SIMD: f32x4 comparisons ===\n  F32x4EqOp\n  F32x4NeOp\n  F32x4LtOp\n  F32x4GtOp\n  F32x4LeOp\n  F32x4GeOp\n\n  // === SIMD: f64x2 comparisons ===\n  F64x2EqOp\n  F64x2NeOp\n  F64x2LtOp\n  F64x2GtOp\n  F64x2LeOp\n  F64x2GeOp\n\n  // === SIMD: i8x16 arithmetic ===\n  I8x16AddOp\n  I8x16AddSatSOp\n  I8x16AddSatUOp\n  I8x16SubOp\n  I8x16SubSatSOp\n  I8x16SubSatUOp\n  I8x16MinSOp\n  I8x16MinUOp\n  I8x16MaxSOp\n  I8x16MaxUOp\n  I8x16AvgrUOp\n  I8x16NarrowI16x8SOp\n  I8x16NarrowI16x8UOp\n\n  // === SIMD: i16x8 arithmetic ===\n  I16x8AddOp\n  I16x8AddSatSOp\n  I16x8AddSatUOp\n  I16x8SubOp\n  I16x8SubSatSOp\n  I16x8SubSatUOp\n  I16x8MulOp\n  I16x8MinSOp\n  I16x8MinUOp\n  I16x8MaxSOp\n  I16x8MaxUOp\n  I16x8AvgrUOp\n  I16x8Q15mulrSatSOp\n  I16x8NarrowI32x4SOp\n  I16x8NarrowI32x4UOp\n  I16x8ExtmulLowI8x16SOp\n  I16x8ExtmulHighI8x16SOp\n  I16x8ExtmulLowI8x16UOp\n  I16x8ExtmulHighI8x16UOp\n\n  // === SIMD: i32x4 arithmetic ===\n  I32x4AddOp\n  I32x4SubOp\n  I32x4MulOp\n  I32x4MinSOp\n  I32x4MinUOp\n  I32x4MaxSOp\n  I32x4MaxUOp\n  I32x4DotI16x8SOp\n  I32x4ExtmulLowI16x8SOp\n  I32x4ExtmulHighI16x8SOp\n  I32x4ExtmulLowI16x8UOp\n  I32x4ExtmulHighI16x8UOp\n\n  // === SIMD: i64x2 arithmetic ===\n  I64x2AddOp\n  I64x2SubOp\n  I64x2MulOp\n  I64x2ExtmulLowI32x4SOp\n  I64x2ExtmulHighI32x4SOp\n  I64x2ExtmulLowI32x4UOp\n  I64x2ExtmulHighI32x4UOp\n\n  // === SIMD: f32x4 arithmetic ===\n  F32x4AddOp\n  F32x4SubOp\n  F32x4MulOp\n  F32x4DivOp\n  F32x4MinOp\n  F32x4MaxOp\n  F32x4PminOp\n  F32x4PmaxOp\n\n  // === SIMD: f64x2 arithmetic ===\n  F64x2AddOp\n  F64x2SubOp\n  F64x2MulOp\n  F64x2DivOp\n  F64x2MinOp\n  F64x2MaxOp\n  F64x2PminOp\n  F64x2PmaxOp\n\n  // === SIMD: Relaxed ===\n  F32x4RelaxedMinOp\n  F32x4RelaxedMaxOp\n  F64x2RelaxedMinOp\n  F64x2RelaxedMaxOp\n  I16x8RelaxedQ15mulrSOp\n  I16x8RelaxedDotI8x16I7x16SOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Load operations\npub(all) enum LoadOp {\n  // === Scalar ===\n  I32LoadOp\n  I64LoadOp\n  F32LoadOp\n  F64LoadOp\n  I32Load8SOp\n  I32Load8UOp\n  I32Load16SOp\n  I32Load16UOp\n  I64Load8SOp\n  I64Load8UOp\n  I64Load16SOp\n  I64Load16UOp\n  I64Load32SOp\n  I64Load32UOp\n\n  // === SIMD ===\n  V128LoadOp\n  V128Load8x8SOp\n  V128Load8x8UOp\n  V128Load16x4SOp\n  V128Load16x4UOp\n  V128Load32x2SOp\n  V128Load32x2UOp\n  V128Load8SplatOp\n  V128Load16SplatOp\n  V128Load32SplatOp\n  V128Load64SplatOp\n  V128Load32ZeroOp\n  V128Load64ZeroOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Store operations\npub(all) enum StoreOp {\n  // === Scalar ===\n  I32StoreOp\n  I64StoreOp\n  F32StoreOp\n  F64StoreOp\n  I32Store8Op\n  I32Store16Op\n  I64Store8Op\n  I64Store16Op\n  I64Store32Op\n\n  // === SIMD ===\n  V128StoreOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Extract lane operations (v128 -> scalar)\npub(all) enum ExtractLaneOp {\n  I8x16ExtractLaneSOp\n  I8x16ExtractLaneUOp\n  I16x8ExtractLaneSOp\n  I16x8ExtractLaneUOp\n  I32x4ExtractLaneOp\n  I64x2ExtractLaneOp\n  F32x4ExtractLaneOp\n  F64x2ExtractLaneOp\n} derive(Eq, Show, Hash)\n\n///|\n/// Replace lane operations (v128, scalar -> v128)\npub(all) enum ReplaceLaneOp {\n  I8x16ReplaceLaneOp\n  I16x8ReplaceLaneOp\n  I32x4ReplaceLaneOp\n  I64x2ReplaceLaneOp\n  F32x4ReplaceLaneOp\n  F64x2ReplaceLaneOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 shift operations (v128, i32 -> v128)\npub(all) enum V128ShiftOp {\n  I8x16ShlOp\n  I8x16ShrSOp\n  I8x16ShrUOp\n  I16x8ShlOp\n  I16x8ShrSOp\n  I16x8ShrUOp\n  I32x4ShlOp\n  I32x4ShrSOp\n  I32x4ShrUOp\n  I64x2ShlOp\n  I64x2ShrSOp\n  I64x2ShrUOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 ternary operations (v128, v128, v128 -> v128)\npub(all) enum V128TernaryOp {\n  V128BitselectOp\n  I8x16RelaxedLaneselectOp\n  I16x8RelaxedLaneselectOp\n  I32x4RelaxedLaneselectOp\n  I64x2RelaxedLaneselectOp\n  F32x4RelaxedMaddOp\n  F32x4RelaxedNmaddOp\n  F64x2RelaxedMaddOp\n  F64x2RelaxedNmaddOp\n  I32x4RelaxedDotI8x16I7x16AddSOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 lane load operations\npub(all) enum V128LoadLaneOp {\n  V128Load8LaneOp\n  V128Load16LaneOp\n  V128Load32LaneOp\n  V128Load64LaneOp\n} derive(Eq, Show, Hash)\n\n///|\n/// V128 lane store operations\npub(all) enum V128StoreLaneOp {\n  V128Store8LaneOp\n  V128Store16LaneOp\n  V128Store32LaneOp\n  V128Store64LaneOp\n} derive(Eq, Show, Hash)\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// A newtype wrapper that reverses the comparison order of the wrapped value.\n///\n/// `Reverse[T]` is useful when you need to reverse the natural ordering of a type.\n/// For example, to create a min-heap from a max-heap data structure, or to sort\n/// in descending order instead of ascending order.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let a = @cmp.Reverse(1)\n///   let b = @cmp.Reverse(2)\n///   inspect(a.compare(b), content=\"1\") // 1 > 2 in reversed order\n///   inspect(b.compare(a), content=\"-1\") // 2 < 1 in reversed order\n///   inspect(a == a, content=\"true\") // Equality works correctly\n///   inspect(a.to_string(), content=\"Reverse(1)\") // Shows wrapped value\n/// }\n/// ```\npub(all) struct Reverse[T](T) derive(Eq, Show, Hash)\n\n///|\npub impl[T : Compare] Compare for Reverse[T] with compare(a, b) {\n  -a.0.compare(b.0)\n}\n\n///|\n/// Returns the element that gives the maximum value from the specified function.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   inspect(@cmp.maximum_by_key(1, -2, Int::abs), content=\"-2\")\n///   inspect(@cmp.maximum_by_key(-2, 1, Int::abs), content=\"-2\")\n///   inspect(@cmp.maximum_by_key(-2, 2, Int::abs), content=\"2\")\n/// }\n/// ```\npub fn[T, K : Compare] maximum_by_key(x : T, y : T, f : (T) -> K) -> T {\n  if f(x) > f(y) {\n    x\n  } else {\n    y\n  }\n}\n\n///|\n/// Returns the element that gives the minimum value from the specified function.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   inspect(@cmp.minimum_by_key(1, -2, Int::abs), content=\"1\")\n///   inspect(@cmp.minimum_by_key(-2, 1, Int::abs), content=\"1\")\n///   inspect(@cmp.minimum_by_key(-2, 2, Int::abs), content=\"-2\")\n/// }\n/// ```\npub fn[T, K : Compare] minimum_by_key(x : T, y : T, f : (T) -> K) -> T {\n  if f(x) > f(y) {\n    y\n  } else {\n    x\n  }\n}\n\n///|\n/// Compares and returns the maximum of two values.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   inspect(@cmp.maximum(1, 2), content=\"2\")\n///   inspect(@cmp.maximum(2, 1), content=\"2\")\n///   let fst = []\n///   let snd = []\n///   @cmp.maximum(fst, snd).push(0)\n///   inspect(snd, content=\"[0]\")\n/// }\n/// ```\npub fn[T : Compare] maximum(x : T, y : T) -> T {\n  if x > y {\n    x\n  } else {\n    y\n  }\n}\n\n///|\n/// Compares and returns the minimum of two values.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   inspect(@cmp.minimum(1, 2), content=\"1\")\n///   inspect(@cmp.minimum(2, 1), content=\"1\")\n///   let fst = []\n///   let snd = []\n///   @cmp.minimum(fst, snd).push(0)\n///   inspect(fst, content=\"[0]\")\n/// }\n/// ```\npub fn[T : Compare] minimum(x : T, y : T) -> T {\n  if x > y {\n    y\n  } else {\n    x\n  }\n}\n\n///|\n/// Returns both the minimum and maximum of two values as a tuple.\n///\n/// Parameters:\n///\n/// * `x` : The first value to compare.\n/// * `y` : The second value to compare.\n///\n/// Returns a tuple `(min, max)` where the first element is the smaller value\n/// and the second element is the larger value. If the values are equal, returns\n/// `(x, y)`.\n///\n/// Examples:\n///\n/// ```mbt check\n/// test {\n///   inspect(@cmp.minmax(1, 2), content=\"(1, 2)\")\n///   inspect(@cmp.minmax(2, 1), content=\"(1, 2)\")\n/// }\n/// ```\npub fn[T : Compare] minmax(x : T, y : T) -> (T, T) {\n  if x > y {\n    (y, x)\n  } else {\n    (x, y)\n  }\n}\n\n///|\n/// Returns the minimum and maximum of two values based on a comparison\n/// function.\n///\n/// Parameters:\n///\n/// * `x` : The first value to compare.\n/// * `y` : The second value to compare.\n/// * `f` : A function that extracts a comparable key from each value.\n///\n/// Returns a tuple `(min, max)` where the first element is the value that\n/// produces the smaller key and the second element is the value that produces\n/// the larger key. If the keys are equal, returns `(x, y)`.\n///\n/// Examples:\n///\n/// ```mbt check\n/// test {\n///   inspect(@cmp.minmax_by_key(1, -2, Int::abs), content=\"(1, -2)\")\n///   inspect(@cmp.minmax_by_key(-2, 1, Int::abs), content=\"(1, -2)\")\n///   inspect(@cmp.minmax_by_key(-2, 2, Int::abs), content=\"(-2, 2)\")\n/// }\n/// ```\npub fn[T, K : Compare] minmax_by_key(x : T, y : T, f : (T) -> K) -> (T, T) {\n  if f(x) > f(y) {\n    (y, x)\n  } else {\n    (x, y)\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Extensible buffer.\n///\n/// It provides accumulative concatenation of bytes in linear time.\n/// The capacity of buffer will automatically expand as necessary.\n///\n/// Note: StringBuilder is recommended for string concatenation in favor of\n/// Buffer, since it is optimized for all targets.\n/// # Usage\n///\n/// ```mbt\n///   let buf = @buffer.new(size_hint=100)\n///   buf.write_string(\"Tes\")\n///   buf.write_char('t')\n///   inspect(\n///     buf.contents(), \n///     content=(\n///       \n///   #|b\"T\\x00e\\x00s\\x00t\\x00\"\n///\n///     ),\n///   )\n/// ```\n#alias(T, deprecated)\nstruct Buffer {\n  mut data : FixedArray[Byte]\n  mut len : Int\n}\n\n///|\n/// Expand the buffer size if capacity smaller than required space.\nfn Buffer::grow_if_necessary(self : Buffer, required : Int) -> Unit {\n  let start = if self.data.length() <= 0 { 1 } else { self.data.length() }\n  let enough_space = for space = start {\n    if space >= required {\n      break space\n    }\n    continue space * 2\n  }\n  if enough_space != self.data.length() {\n    let new_data = FixedArray::make(enough_space, Byte::default())\n    new_data.unsafe_blit(0, self.data, 0, self.len)\n    self.data = new_data\n  }\n}\n\n///|\n/// Returns the number of bytes currently stored in the buffer.\n///\n/// Parameters:\n///\n/// * `buffer`: The buffer to get the length from.\n///\n/// Returns the length of the buffer in bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_string(\"Test\")\n///   inspect(buf.length(), content=\"8\") // each char takes 2 bytes in UTF-16\n/// }\n/// ```\npub fn Buffer::length(self : Buffer) -> Int {\n  self.len\n}\n\n///|\n/// Returns whether the buffer is empty.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to check.\n///\n/// Returns `true` if the buffer is empty (i.e., contains no bytes), `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   inspect(buf.is_empty(), content=\"true\")\n///   buf.write_string(\"test\")\n///   inspect(buf.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn Buffer::is_empty(self : Buffer) -> Bool {\n  self.len == 0\n}\n\n///|\n/// Creates a new extensible buffer with specified initial capacity. If the\n/// initial capacity is less than 1, the buffer will be initialized with capacity\n/// 1.\n///\n/// Parameters:\n///\n/// * `size_hint` : Initial capacity of the buffer in bytes. Defaults to 0.\n///\n/// Returns a new buffer of type `Buffer`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new(size_hint=10)\n///   inspect(buf.length(), content=\"0\")\n///   buf.write_string(\"test\")\n///   inspect(buf.length(), content=\"8\")\n/// }\n/// ```\npub fn new(size_hint? : Int = 0) -> Buffer {\n  let initial = if size_hint < 1 { 1 } else { size_hint }\n  let data = FixedArray::make(initial, Byte::default())\n  { data, len: 0 }\n}\n\n///|\n/// Create a buffer from a bytes.\npub fn from_bytes(bytes : Bytes) -> Buffer {\n  let val_len = bytes.length()\n  let buf = new(size_hint=val_len)\n  // inline write_bytes, skip grow_if_necessary check\n  // SAFETY: known bytes size\n  buf.data.blit_from_bytes(0, bytes, 0, val_len)\n  buf.len = val_len\n  buf\n}\n\n///|\n/// Create a buffer from an array.\npub fn from_array(arr : ArrayView[Byte]) -> Buffer {\n  let buf = new(size_hint=arr.length())\n  for byte in arr {\n    // inline write_byte, skip grow_if_necessary check\n    // SAFETY: known array size\n    buf.data[buf.len] = byte\n    buf.len += 1\n  }\n  buf\n}\n\n///|\n/// Create a buffer from an iterator.\npub fn from_iter(iter : Iter[Byte]) -> Buffer {\n  let buf = new()\n  let mut capacity = buf.data.length()\n  for byte in iter {\n    // inline write_byte and grow_if_necessary\n    // only call grow_if_necessary when necessary\n    if buf.len == capacity {\n      buf.grow_if_necessary(capacity + 1)\n      capacity = buf.data.length()\n    }\n    buf.data[buf.len] = byte\n    buf.len += 1\n  }\n  buf\n}\n\n///|\n/// Writes a UTF-16LE encoded string into the buffer. The buffer will\n/// automatically grow if needed to accommodate the string.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `string` : The string to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_string(\"Test\")\n///   // Each UTF-16 char takes 2 bytes in little-endian format\n///   // 'T' -> [0x54, 0x00]\n///   // 'e' -> [0x65, 0x00]\n///   // 's' -> [0x73, 0x00]\n///   // 't' -> [0x74, 0x00]\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"T\\x00e\\x00s\\x00t\\x00\"\n///     ),\n///   )\n/// }\n/// ```\npub impl Logger for Buffer with write_string(self, value) {\n  self.grow_if_necessary(self.len + value.length() * 2)\n  self.data.blit_from_string(self.len, value, 0, value.length())\n  self.len += value.length() * 2\n}\n\n///|\n/// Writes an unsigned 64-bit integer into the buffer in big-endian format (most\n/// significant byte first).\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The unsigned 64-bit integer to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_uint64_be(0xAABBCCDD11223344)\n///   // Bytes are written in big-endian order\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\xaa\\xbb\\xcc\\xdd\\x11\\x223D\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_uint64_be(self : Buffer, value : UInt64) -> Unit {\n  self.grow_if_necessary(self.len + 8)\n  let offset = self.len\n  self.data[offset] = (value >> 56).to_byte()\n  self.data[offset + 1] = (value >> 48).to_byte()\n  self.data[offset + 2] = (value >> 40).to_byte()\n  self.data[offset + 3] = (value >> 32).to_byte()\n  self.data[offset + 4] = (value >> 24).to_byte()\n  self.data[offset + 5] = (value >> 16).to_byte()\n  self.data[offset + 6] = (value >> 8).to_byte()\n  self.data[offset + 7] = value.to_byte()\n  self.len += 8\n}\n\n///|\n/// Writes an unsigned 64-bit integer to the buffer in little-endian byte order.\n/// Each byte is written sequentially from least significant to most significant.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The UInt64 value to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_uint64_le(0x0123456789ABCDEF)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\xef\\xcd\\xab\\x89gE#\\x01\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_uint64_le(self : Buffer, value : UInt64) -> Unit {\n  self.grow_if_necessary(self.len + 8)\n  let offset = self.len\n  self.data[offset] = value.to_byte()\n  self.data[offset + 1] = (value >> 8).to_byte()\n  self.data[offset + 2] = (value >> 16).to_byte()\n  self.data[offset + 3] = (value >> 24).to_byte()\n  self.data[offset + 4] = (value >> 32).to_byte()\n  self.data[offset + 5] = (value >> 40).to_byte()\n  self.data[offset + 6] = (value >> 48).to_byte()\n  self.data[offset + 7] = (value >> 56).to_byte()\n  self.len += 8\n}\n\n///|\n/// Writes a 64-bit integer into the buffer in big-endian format, where the most\n/// significant byte is written first.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write into.\n/// * `value` : The 64-bit integer to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_int64_be(0x0102030405060708L)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_int64_be(self : Buffer, value : Int64) -> Unit {\n  self.write_uint64_be(value.reinterpret_as_uint64())\n}\n\n///|\n/// Writes a 64-bit signed integer to the buffer in little-endian byte order.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The 64-bit signed integer to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_int64_le(-1L)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_int64_le(self : Buffer, value : Int64) -> Unit {\n  self.write_uint64_le(value.reinterpret_as_uint64())\n}\n\n///|\n/// Writes a 32-bit unsigned integer into the buffer in big-endian format (most\n/// significant byte first).\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The unsigned integer value to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_uint_be(0x12345678)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\x124Vx\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_uint_be(self : Buffer, value : UInt) -> Unit {\n  self.grow_if_necessary(self.len + 4)\n  let offset = self.len\n  self.data[offset] = (value >> 24).to_byte()\n  self.data[offset + 1] = (value >> 16).to_byte()\n  self.data[offset + 2] = (value >> 8).to_byte()\n  self.data[offset + 3] = value.to_byte()\n  self.len += 4\n}\n\n///|\n/// Writes a 32-bit unsigned integer into the buffer in little-endian format. The\n/// integer is split into 4 bytes and written in order from least significant to\n/// most significant byte.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : A 32-bit unsigned integer to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_uint_le(0x12345678)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"xV4\\x12\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_uint_le(self : Buffer, value : UInt) -> Unit {\n  self.grow_if_necessary(self.len + 4)\n  let offset = self.len\n  self.data[offset] = value.to_byte()\n  self.data[offset + 1] = (value >> 8).to_byte()\n  self.data[offset + 2] = (value >> 16).to_byte()\n  self.data[offset + 3] = (value >> 24).to_byte()\n  self.len += 4\n}\n\n///|\n/// Writes a 32-bit integer to the buffer in big-endian format. Big-endian means\n/// the most significant byte is written first.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The 32-bit integer to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_int_be(0x12345678)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\x124Vx\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_int_be(self : Buffer, value : Int) -> Unit {\n  self.write_uint_be(value.reinterpret_as_uint())\n}\n\n///|\n/// Writes a 32-bit integer into the buffer in little-endian format. The integer\n/// is first reinterpreted as an unsigned integer, then written as 4 bytes where\n/// the least significant byte is written first.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write into.\n/// * `value` : The integer value to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_int_le(-1)\n///   inspect(buf.contents(), content=\"b\\\"\\\\xff\\\\xff\\\\xff\\\\xff\\\"\")\n/// }\n/// ```\npub fn Buffer::write_int_le(self : Buffer, value : Int) -> Unit {\n  self.write_uint_le(value.reinterpret_as_uint())\n}\n\n///|\n/// Writes a 16-bit unsigned integer into the buffer in big-endian format (most\n/// significant byte first).\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The unsigned 16-bit integer value to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_uint16_be(0x1234)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\x124\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_uint16_be(self : Buffer, value : UInt16) -> Unit {\n  self.grow_if_necessary(self.len + 2)\n  let offset = self.len\n  self.data[offset] = (value.to_int() >> 8).to_byte()\n  self.data[offset + 1] = value.to_byte()\n  self.len += 2\n}\n\n///|\n/// Writes a 16-bit unsigned integer into the buffer in little-endian format. The\n/// integer is split into 2 bytes and written in order from least significant to\n/// most significant byte.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : A 16-bit unsigned integer to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_uint16_le(0x1234)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"4\\x12\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_uint16_le(self : Buffer, value : UInt16) -> Unit {\n  self.grow_if_necessary(self.len + 2)\n  let offset = self.len\n  self.data[offset] = value.to_byte()\n  self.data[offset + 1] = (value.to_int() >> 8).to_byte()\n  self.len += 2\n}\n\n///|\n/// Writes a 16-bit integer to the buffer in big-endian format. Big-endian means\n/// the most significant byte is written first.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The 16-bit integer to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_int16_be(0x1234)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\x124\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_int16_be(self : Buffer, value : Int16) -> Unit {\n  self.grow_if_necessary(self.len + 2)\n  let offset = self.len\n  self.data[offset] = (value.to_int() >> 8).to_byte()\n  self.data[offset + 1] = value.to_byte()\n  self.len += 2\n}\n\n///|\n/// Writes a 16-bit integer into the buffer in little-endian format. The integer\n/// is written as 2 bytes where the least significant byte is written first.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write into.\n/// * `value` : The 16-bit integer value to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_int16_le(-1)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\xff\\xff\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_int16_le(self : Buffer, value : Int16) -> Unit {\n  self.grow_if_necessary(self.len + 2)\n  let offset = self.len\n  self.data[offset] = value.to_byte()\n  self.data[offset + 1] = (value.to_int() >> 8).to_byte()\n  self.len += 2\n}\n\n///|\n/// Writes an IEEE 754 double-precision floating-point number into the buffer in\n/// big-endian format (most significant byte first).\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The double-precision floating-point number to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_double_be(1.0)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"?\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_double_be(self : Buffer, value : Double) -> Unit {\n  self.write_uint64_be(value.reinterpret_as_uint64())\n}\n\n///|\n/// Writes a double-precision floating-point number into the buffer in\n/// little-endian format.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The double-precision floating-point number to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_double_le(3.14)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\x1f\\x85\\xebQ\\xb8\\x1e\\x09@\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_double_le(self : Buffer, value : Double) -> Unit {\n  self.write_uint64_le(value.reinterpret_as_uint64())\n}\n\n///|\n/// Writes a 32-bit floating-point number to the buffer in big-endian byte order.\n/// The float value is first reinterpreted as a 32-bit unsigned integer before\n/// writing.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The floating-point number to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_float_be(3.14)\n///   // In big-endian format, 3.14 is represented as [0x40, 0x48, 0xF5, 0xC3]\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"@H\\xf5\\xc3\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_float_be(self : Buffer, value : Float) -> Unit {\n  self.write_uint_be(value.reinterpret_as_uint())\n}\n\n///|\n/// Writes a Float value into the buffer in little-endian format. The float value\n/// is converted to its binary representation and written as four bytes.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The Float value to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_float_le(3.14)\n///   // The bytes are written in little-endian format\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"\\xc3\\xf5H@\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_float_le(self : Buffer, value : Float) -> Unit {\n  self.write_uint_le(value.reinterpret_as_uint())\n}\n\n///|\n/// Writes a string representation of any value that implements the `Show` trait\n/// into the buffer.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : Any value that implements the `Show` trait. The value will be\n/// converted to a string using its `to_string` method before being written to\n/// the buffer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_object(42)\n///   inspect(buf.contents().to_unchecked_string(), content=\"42\")\n/// }\n/// ```\npub fn Buffer::write_object(self : Buffer, value : &Show) -> Unit {\n  self.write_string(value.to_string())\n}\n\n///|\n/// Writes a sequence of bytes into the buffer.\n///\n/// Parameters:\n///\n/// * `buffer` : An extensible buffer to write into.\n/// * `bytes` : The sequence of bytes to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_bytes(b\"Test\")\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"Test\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_bytes(self : Buffer, value : Bytes) -> Unit {\n  let val_len = value.length()\n  self.grow_if_necessary(self.len + val_len)\n  self.data.blit_from_bytes(self.len, value, 0, val_len)\n  self.len += val_len\n}\n\n///|\n/// Writes a sequence of bytes from a BytesView into the buffer.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `value` : The View containing the bytes to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   let view = b\"Test\"[1:3]\n///   buf.write_bytesview(view)\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"es\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_bytesview(self : Buffer, value : BytesView) -> Unit {\n  let val_len = value.length()\n  self.grow_if_necessary(self.len + val_len)\n  self.data.blit_from_bytes(\n    self.len,\n    value.data(),\n    value.start_offset(),\n    value.length(),\n  )\n  self.len += val_len\n}\n\n///|\n/// Write a char into buffer as UTF8.\npub fn Buffer::write_char_utf8(buf : Self, value : Char) -> Unit {\n  let code = value.to_uint()\n  match code {\n    _..<0x80 => {\n      buf.grow_if_necessary(buf.len + 1)\n      buf.data[buf.len] = ((code & 0x7F) | 0x00).to_byte()\n      buf.len += 1\n    }\n    _..<0x0800 => {\n      buf.grow_if_necessary(buf.len + 2)\n      buf.data[buf.len] = (((code >> 6) & 0x1F) | 0xC0).to_byte()\n      buf.data[buf.len + 1] = ((code & 0x3F) | 0x80).to_byte()\n      buf.len += 2\n    }\n    _..<0x010000 => {\n      buf.grow_if_necessary(buf.len + 3)\n      buf.data[buf.len] = (((code >> 12) & 0x0F) | 0xE0).to_byte()\n      buf.data[buf.len + 1] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      buf.data[buf.len + 2] = ((code & 0x3F) | 0x80).to_byte()\n      buf.len += 3\n    }\n    _..<0x110000 => {\n      buf.grow_if_necessary(buf.len + 4)\n      buf.data[buf.len] = (((code >> 18) & 0x07) | 0xF0).to_byte()\n      buf.data[buf.len + 1] = (((code >> 12) & 0x3F) | 0x80).to_byte()\n      buf.data[buf.len + 2] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      buf.data[buf.len + 3] = ((code & 0x3F) | 0x80).to_byte()\n      buf.len += 4\n    }\n    _ => abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Write a char into buffer as UTF16LE.\npub fn Buffer::write_char_utf16le(buf : Self, value : Char) -> Unit {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    buf.grow_if_necessary(buf.len + 2)\n    buf.data[buf.len + 0] = (code & 0xFF).to_byte()\n    buf.data[buf.len + 1] = (code >> 8).to_byte()\n    buf.len += 2\n  } else if code < 0x110000 {\n    let cp = code - 0x10000\n    let high = (cp >> 10) | 0xD800\n    let low = (cp & 0x3FF) | 0xDC00\n    buf.grow_if_necessary(buf.len + 4)\n    buf.data[buf.len + 0] = (high & 0xFF).to_byte()\n    buf.data[buf.len + 1] = (high >> 8).to_byte()\n    buf.data[buf.len + 2] = (low & 0xFF).to_byte()\n    buf.data[buf.len + 3] = (low >> 8).to_byte()\n    buf.len += 4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Write a char into buffer as UTF16BE.\npub fn Buffer::write_char_utf16be(buf : Self, value : Char) -> Unit {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    buf.grow_if_necessary(buf.len + 2)\n    buf.data[buf.len + 0] = (code >> 8).to_byte()\n    buf.data[buf.len + 1] = (code & 0xFF).to_byte()\n    buf.len += 2\n  } else if code < 0x110000 {\n    buf.grow_if_necessary(buf.len + 4)\n    let cp = code - 0x10000\n    let high = (cp >> 10) | 0xD800\n    let low = (cp & 0x3FF) | 0xDC00\n    buf.data[buf.len + 0] = (high >> 8).to_byte()\n    buf.data[buf.len + 1] = (high & 0xFF).to_byte()\n    buf.data[buf.len + 2] = (low >> 8).to_byte()\n    buf.data[buf.len + 3] = (low & 0xFF).to_byte()\n    buf.len += 4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\npub fn Buffer::write_string_utf8(buf : Self, string : StringView) -> Unit {\n  for ch in string {\n    buf.write_char_utf8(ch)\n  }\n}\n\n///|\n#alias(write_stringview, deprecated=\"use write_string_utf16le instead\")\npub fn Buffer::write_string_utf16le(buf : Self, string : StringView) -> Unit {\n  let len = string.length()\n  buf.grow_if_necessary(buf.len + len * 2)\n  for i = 0, j = buf.len; i < len; i = i + 1, j = j + 2 {\n    let c = string.unsafe_charcode_at(i).reinterpret_as_uint()\n    buf.data[j] = (c & 0xff).to_byte()\n    buf.data[j + 1] = (c >> 8).to_byte()\n  }\n  buf.len += len * 2\n}\n\n///|\npub fn Buffer::write_string_utf16be(buf : Self, string : StringView) -> Unit {\n  let len = string.length()\n  buf.grow_if_necessary(buf.len + len * 2)\n  for i = 0, j = buf.len; i < len; i = i + 1, j = j + 2 {\n    let c = string.unsafe_charcode_at(i).reinterpret_as_uint()\n    buf.data[j + 1] = (c & 0xff).to_byte()\n    buf.data[j] = (c >> 8).to_byte()\n  }\n  buf.len += len * 2\n}\n\n///|\n/// Parameters:\n///\n/// * `self` : The buffer to write to.\n/// * `str` : The source string from which the substring will be taken.\n/// * `offset` : The starting position in the source string (inclusive). Must be\n/// non-negative.\n/// * `count` : The number of characters to write. Must be non-negative and\n/// `offset + count` must not exceed the length of the source string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_view(\"Hello, World!\"[:5])\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"H\\x00e\\x00l\\x00l\\x00o\\x00\"\n///     ),\n///   )\n/// }\n/// ```\npub impl Logger for Buffer with write_view(self : Buffer, value : StringView) -> Unit {\n  self.grow_if_necessary(self.len + value.length() * 2)\n  self.data.blit_from_string(\n    self.len,\n    value.data(),\n    value.start_offset(),\n    value.length(),\n  )\n  self.len += value.length() * 2\n}\n\n///|\n/// Writes a UTF-16LE encoded character into the buffer. Automatically grows the\n/// buffer if necessary.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `char` : The character to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_char('A')\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"A\\x00\"\n///     ),\n///   )\n/// }\n/// ```\npub impl Logger for Buffer with write_char(self : Buffer, value : Char) -> Unit {\n  self.grow_if_necessary(self.len + 4)\n  let inc = self.data.set_utf16le_char(self.len, value)\n  self.len += inc\n}\n\n///|\n/// Writes a single byte to the end of the buffer. The buffer will automatically\n/// grow if necessary to accommodate the new byte.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer to write to.\n/// * `byte` : The byte value to be written.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_byte(b'\\x41')\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"A\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_byte(self : Buffer, value : Byte) -> Unit {\n  self.grow_if_necessary(self.len + 1)\n  self.data[self.len] = value\n  self.len += 1\n}\n\n///|\n/// Writes bytes from an iterator to the buffer. \n///\n/// Parameters:\n///\n/// * `self` : The buffer to write to.\n/// * `iter` : An iterator yielding bytes to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   let bytes = b\"Hello\"\n///   buf.write_iter(bytes.iter())\n///   inspect(\n///     buf.contents(),\n///     content=(\n///       #|b\"Hello\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Buffer::write_iter(self : Buffer, iter : Iter[Byte]) -> Unit {\n  for byte in iter {\n    self.write_byte(byte)\n  }\n}\n\n///|\n/// Resets the buffer to an empty state by setting the internal offset to 0.\n/// This makes the buffer appear empty without actually clearing the underlying data.\n///\n/// Parameters:\n///\n/// * `self` : The buffer to be reset.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_string(\"Hello\")\n///   inspect(buf.length(), content=\"10\")\n///   buf.reset()\n///   inspect(buf.length(), content=\"0\")\n///   inspect(buf.is_empty(), content=\"true\")\n/// }\n/// ```\n///\npub fn Buffer::reset(self : Buffer) -> Unit {\n  self.len = 0\n}\n\n///|\n/// Returns a copy of the buffer's contents as a `Bytes` object. The returned\n/// bytes will have the same length as the buffer.\n///\n/// Parameters:\n///\n/// * `buffer` : The buffer whose contents will be converted to bytes.\n///\n/// Returns a `Bytes` object containing a copy of the buffer's contents.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = @buffer.new()\n///   buf.write_string(\"Test\")\n///   let bytes = buf.to_bytes()\n///   inspect(bytes.length(), content=\"8\") //utf16\n/// }\n/// ```\n#alias(contents)\npub fn Buffer::to_bytes(self : Buffer) -> Bytes {\n  Bytes::from_array(self.data[0:self.len])\n}\n\n///|\npub fn Buffer::view(self : Buffer) -> ArrayView[Byte] {\n  self.data[0:self.len]\n}\n\n///|\npub impl Show for Buffer with output(self, logger) {\n  logger.write_string(self.contents().to_unchecked_string())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts a floating-point number to its string representation.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be converted.\n/// * `logger` : The logger to write the string representation to.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f : Float = 3.14\n///   let s = f.to_double().to_string()\n///   inspect(s, content=\"3.140000104904175\")\n/// }\n/// ```\npub impl Show for Float with output(self, logger) {\n  logger.write_string(self.to_double().to_string())\n}\n\n///|\n/// Returns a default value for the `Float` type, which is `0.0`.\n///\n/// Returns a `Float` value initialized to zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Float::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Float with default() {\n  0\n}\n\n///|\n/// Combines the hash value of a floating-point number with an existing hasher.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be hashed.\n/// * `hasher` : The hasher object to combine the hash value with.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Float = 3.14\n///   let y : Float = 3.14\n///   // Same values should produce same hash combinations\n///   inspect(Hash::hash(x) == Hash::hash(y), content=\"true\")\n/// }\n/// ```\npub impl Hash for Float with hash_combine(self, hasher) {\n  hasher.combine_uint(self.reinterpret_as_uint())\n}\n\n///|\n/// Converts a floating-point number to a sequence of bytes in big-endian byte\n/// order. In big-endian order, the most significant byte is stored at the lowest\n/// memory address.\n///\n/// Parameters:\n///\n/// * `float` : The floating-point number to be converted.\n///\n/// Returns a sequence of 4 bytes representing the floating-point number in IEEE\n/// 754 single-precision format with big-endian byte order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Float = 1.0\n///   inspect(\n///     x.to_be_bytes(),\n///     content=(\n///       #|b\"?\\x80\\x00\\x00\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Float::to_be_bytes(self : Float) -> Bytes {\n  let uint = self.reinterpret_as_uint()\n  [\n    (uint >> 24).to_byte(),\n    (uint >> 16).to_byte(),\n    (uint >> 8).to_byte(),\n    uint.to_byte(),\n  ]\n}\n\n///|\n/// Converts a floating-point number to its binary representation in\n/// little-endian byte order.\n///\n/// Parameters:\n///\n/// * `float` : The floating-point number to be converted.\n///\n/// Returns a sequence of bytes representing the float value in little-endian\n/// order (least significant byte first).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f : Float = 1.0\n///   let bytes = f.to_le_bytes()\n///   inspect(bytes.length(), content=\"4\")\n/// }\n/// ```\npub fn Float::to_le_bytes(self : Float) -> Bytes {\n  let uint = self.reinterpret_as_uint()\n  [\n    uint.to_byte(),\n    (uint >> 8).to_byte(),\n    (uint >> 16).to_byte(),\n    (uint >> 24).to_byte(),\n  ]\n}\n\n///|\n/// Determines if the floating-point number is positive or negative infinity.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is positive or negative\n/// infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.infinity.is_inf(), content=\"true\")\n///   inspect(@float.neg_infinity.is_inf(), content=\"true\")\n///   inspect((1.0 : Float).is_inf(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_inf(self : Float) -> Bool {\n  self.is_pos_inf() || self.is_neg_inf()\n}\n\n///|\n/// Determines if the floating-point number is positive infinity.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is positive infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.infinity.is_pos_inf(), content=\"true\")\n///   inspect((1.0 : Float).is_pos_inf(), content=\"false\")\n///   inspect(@float.neg_infinity.is_pos_inf(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_pos_inf(self : Float) -> Bool {\n  self > max_value\n}\n\n///|\n/// Determines if the floating-point number is negative infinity.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is negative infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.neg_infinity.is_neg_inf(), content=\"true\")\n///   inspect((1.0 : Float).is_neg_inf(), content=\"false\")\n///   inspect(@float.infinity.is_neg_inf(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_neg_inf(self : Float) -> Bool {\n  self < min_value\n}\n\n///|\n/// Determines if the floating-point number is NaN (Not a Number).\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to be checked.\n///\n/// Returns a boolean value indicating whether the number is NaN.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@float.not_a_number.is_nan(), content=\"true\")\n///   inspect((1.0 : Float).is_nan(), content=\"false\")\n///   inspect(@float.infinity.is_nan(), content=\"false\")\n/// }\n/// ```\npub fn Float::is_nan(self : Float) -> Bool {\n  self != self\n}\n\n///|\n/// Determines whether two floating-point numbers are approximately equal within\n/// specified tolerances.\n/// The implementation follows the algorithm described in PEP 485 for Python's\n/// `math.isclose()`.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n/// * `relative_tolerance` : The relative tolerance for the comparison. Must be\n/// non-negative. Defaults to 1e-9.\n/// * `absolute_tolerance` : The absolute tolerance for the comparison. Must be\n/// non-negative. Defaults to 0.0.\n///\n/// Returns whether the two numbers are considered approximately equal. Returns\n/// `true` if the numbers are exactly equal or if they are within either the\n/// relative or absolute tolerance. Returns `false` if either number is infinite.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1.0\n///   let y = 1.000000001\n///   inspect(x.is_close(y), content=\"false\")\n///   inspect(x.is_close(y, relative_tolerance=1.0e-10), content=\"false\")\n///   inspect(@float.infinity.is_close(@float.infinity), content=\"true\")\n/// }\n/// ```\npub fn Float::is_close(\n  self : Self,\n  other : Self,\n  relative_tolerance? : Self = 1.0e-09,\n  absolute_tolerance? : Self = 0.0,\n) -> Bool {\n  if relative_tolerance < 0.0 || absolute_tolerance < 0.0 {\n    abort(\"Tolerances must be non-negative\")\n  }\n  if self == other {\n    return true\n  }\n  if self.is_inf() || other.is_inf() {\n    return false\n  }\n  let diff = (other - self).abs()\n  return (\n      diff <= (relative_tolerance * other).abs() ||\n      diff <= (relative_tolerance * self).abs()\n    ) ||\n    diff <= absolute_tolerance\n}\n\n///|\n/// Calculates the modulo operation between two floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The dividend floating-point number.\n/// * `other` : The divisor floating-point number.\n///\n/// Returns the remainder of the division of `self` by `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect((5.7 : Float).mod(2.0), content=\"1.6999998092651367\")\n///   inspect((-5.7 : Float).mod(2.0), content=\"-1.6999998092651367\")\n/// }\n/// ```\npub impl Mod for Float with mod(self : Float, other : Float) -> Float {\n  Float::from_double(self.to_double() % other.to_double())\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Float::upto(\n  self : Float,\n  end : Float,\n  inclusive? : Bool = false,\n) -> Iter[Float] {\n  let mut i = self\n  Iter::new(() => {\n    guard i < end || (inclusive && i == end) else { None }\n    let result = i\n    if i != end {\n      i += 1\n    }\n    Some(result)\n  })\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n/// To grow the range downward, set the `step` parameter to a negative value.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive by default).\n/// * `step` - The step size of the range (default 1.0).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\npub fn Float::until(\n  self : Float,\n  end : Float,\n  step? : Float = 1.0,\n  inclusive? : Bool = false,\n) -> Iter[Float] {\n  if step == 0.0 {\n    return Iter::empty()\n  }\n  let mut curr_value = Some(self)\n  Iter::new(() => {\n    guard curr_value is Some(i) else { None }\n    guard (step > 0.0 && i < end) ||\n      (step < 0.0 && i > end) ||\n      (inclusive && i == end) else {\n      None\n    }\n    let next = i + step\n    if (step > 0.0 && next >= i) || (step < 0.0 && next <= i) {\n      curr_value = Some(next)\n    } else {\n      // overflow\n      curr_value = None\n    }\n    Some(i)\n  })\n}\n\n///|\n/// Converts a 32-bit floating-point number to a double-precision (64-bit)\n/// floating-point number.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number to be converted.\n///\n/// Returns a double-precision floating-point number that preserves the exact\n/// value of the input. Since double-precision has more bits than\n/// single-precision, this conversion is always exact and never loses precision.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f = Float::from_double(3.14)\n///   inspect(f.to_double(), content=\"3.140000104904175\")\n/// }\n/// ```\npub fn Float::to_double(self : Float) -> Double = \"%f32.to_f64\"\n\n///|\npub impl ToJson for Float with to_json(self : Float) -> Json {\n  Json::number(self.to_double())\n}\n\n///|\n/// Calculates the square root of a floating-point number. For non-negative\n/// numbers, returns the principal square root. For negative numbers or NaN,\n/// returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number whose square root is to be calculated.\n///\n/// Returns a 32-bit floating-point number representing the square root of the\n/// input value:\n///\n/// * For a positive number, returns its principal square root\n/// * For zero (positive or negative), returns zero with the same sign\n/// * For NaN or negative numbers, returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Float::from_double(16.0)\n///   let root = x.sqrt()\n///   inspect(root.to_double(), content=\"4\")\n///   let neg = Float::from_double(-4.0)\n///   let neg_root = neg.sqrt()\n///   inspect(neg_root.to_double(), content=\"NaN\")\n/// }\n/// ```\npub fn Float::sqrt(self : Float) -> Float = \"%f32.sqrt\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as a 32-bit signed\n/// integer without performing any numeric conversion. The bit pattern is\n/// preserved exactly, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns a 32-bit signed integer that has the same bit pattern as the input\n/// floating-point number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f = Float::from_double(1.0)\n///   // IEEE 754 representation of 1.0 is 0x3F800000\n///   inspect(f.reinterpret_as_int(), content=\"1065353216\")\n/// }\n/// ```\npub fn Float::reinterpret_as_int(self : Float) -> Int = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Performs unary negation on a 32-bit floating-point number. Returns the\n/// arithmetic inverse of the operand.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to negate.\n///\n/// Returns a new floating-point number with the same magnitude but opposite sign\n/// as the input. Special cases:\n///\n/// * Negating NaN returns NaN\n/// * Negating +0.0 returns -0.0\n/// * Negating -0.0 returns +0.0\n/// * Negating +Infinity returns -Infinity\n/// * Negating -Infinity returns +Infinity\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let f = Float::from_double(3.14)\n///   inspect((-f).to_double(), content=\"-3.140000104904175\")\n///   let zero = Float::from_double(0.0)\n///   inspect((-zero).to_double(), content=\"0\")\n/// }\n/// ```\npub impl Neg for Float with neg(self) = \"%f32.neg\"\n\n///|\n/// Performs addition between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point operand.\n/// * `other` : The second floating-point operand to be added to the first\n/// operand.\n///\n/// Returns a single-precision floating-point number representing the sum of the\n/// two operands.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = Float::from_double(3.14)\n///   let b = Float::from_double(2.86)\n///   let sum = a + b\n///   inspect(sum.to_double(), content=\"6\")\n/// }\n/// ```\npub impl Add for Float with add(self, other) = \"%f32.add\"\n\n///|\n/// Performs subtraction between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number (minuend).\n/// * `other` : The second floating-point number (subtrahend).\n///\n/// Returns a new floating-point number representing the difference between\n/// `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Float::from_double(3.14)\n///   let y = Float::from_double(1.0)\n///   let result = x - y\n///   inspect(result.to_double(), content=\"2.140000104904175\")\n/// }\n/// ```\npub impl Sub for Float with sub(self, other) = \"%f32.sub\"\n\n///|\n/// Performs multiplication between two single-precision floating-point numbers\n/// according to IEEE 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number operand.\n/// * `other` : The second floating-point number operand to multiply with the\n/// first.\n///\n/// Returns a single-precision floating-point number that is the product of the\n/// two operands.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Float::from_int(2)\n///   let y = Float::from_int(3)\n///   let z = x * y\n///   inspect(z.to_double(), content=\"6\")\n/// }\n/// ```\npub impl Mul for Float with mul(self, other) = \"%f32.mul\"\n\n///|\n/// Performs division between two 32-bit floating-point numbers according to IEEE\n/// 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The dividend floating-point number.\n/// * `other` : The divisor floating-point number.\n///\n/// Returns a new floating-point number representing the quotient of the\n/// division. Special cases follow IEEE 754 rules:\n///\n/// * Division by zero returns infinity (with the appropriate sign)\n/// * Division of zero by zero returns NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = Float::from_double(6.0)\n///   let b = Float::from_double(2.0)\n///   let result = (a / b).to_double()\n///   inspect(result, content=\"3\")\n///   inspect(\n///     (Float::from_double(0.0) / Float::from_double(0.0)).to_double(),\n///     content=\"NaN\",\n///   )\n/// }\n/// ```\npub impl Div for Float with div(self, other) = \"%f32.div\"\n\n///|\n/// Tests two floating-point numbers for equality. Follows IEEE 754 equality\n/// comparison rules, where NaN values are not equal to any value, including\n/// themselves.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise. Note that `-0.0`\n/// and `+0.0` are considered equal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 3.14\n///   let y = 3.14\n///   let z = 0.0 / 0.0 // NaN\n///   inspect(x == y, content=\"true\")\n///   inspect(z == z, content=\"false\") // NaN is not equal to itself\n/// }\n/// ```\npub impl Eq for Float with equal(self : Float, other : Float) -> Bool = \"%f32.eq\"\n\n///|\n/// Tests two floating-point numbers for inequality. Follows IEEE 754 inequality\n/// comparison rules, where NaN values are not equal to any value, including\n/// themselves.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if the numbers are not equal, `false` otherwise. Note that `-0.0`\n/// and `+0.0` are considered equal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 3.14\n///   let y = 3.14\n///   let z = 0.0 / 0.0 // NaN\n///   inspect(x != y, content=\"false\")\n///   inspect(z != z, content=\"true\") // NaN is not equal to itself\n/// }\n/// ```\npub impl Eq for Float with not_equal(self : Float, other : Float) -> Bool = \"%f32.ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Float::op_neq(self : Float, other : Float) -> Bool = \"%f32.ne\"\n\n///|\n/// Compares two 32-bit floating-point numbers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Float with compare(self, other) = \"%f32.compare\"\n\n///|\npub impl Compare for Float with op_lt(x, y) = \"%f32.lt\"\n\n///|\npub impl Compare for Float with op_le(x, y) = \"%f32.le\"\n\n///|\npub impl Compare for Float with op_gt(x, y) = \"%f32.gt\"\n\n///|\npub impl Compare for Float with op_ge(x, y) = \"%f32.ge\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as an unsigned 32-bit\n/// integer without performing any numeric conversion. Preserves the exact bit\n/// pattern of the input value, only changing how these bits are interpreted.\n///\n/// Parameters:\n///\n/// * `float` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns an unsigned 32-bit integer (`UInt`) that has the same bit pattern as\n/// the input floating-point number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Float = 1.0\n///   inspect(x.reinterpret_as_uint(), content=\"1065353216\") // Decimal representation of 0x3F800000\n/// }\n/// ```\npub fn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets the bits of a 32-bit integer as a single-precision\n/// floating-point number according to IEEE 754 standard. The bit pattern of the\n/// input is preserved, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be reinterpreted as a\n/// single-precision floating-point number.\n///\n/// Returns a 32-bit floating-point number (`Float`) that has the same bit\n/// pattern as the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   // 0x3F800000 represents 1.0 in IEEE 754 single-precision format\n///   let n = 1065353216 // 0x3F800000\n///   inspect(Float::reinterpret_from_int(n), content=\"1\")\n/// }\n/// ```\n// TODO(upstream): no test entry found\npub fn Float::reinterpret_from_int(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n/// Reinterprets the bits of an unsigned 32-bit integer as a single-precision\n/// floating-point number (IEEE 754). The bit pattern is preserved exactly, only\n/// the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be reinterpreted as\n/// a single-precision floating-point number.\n///\n/// Returns a single-precision floating-point number (`Float`) whose bit pattern\n/// is identical to the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 0x3F800000U // Bit pattern for 1.0f\n///   inspect(Float::reinterpret_from_uint(n), content=\"1\")\n/// }\n/// ```\n// TODO(upstream): no test entry found\npub fn Float::reinterpret_from_uint(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\ntest \"Float::reinterpret\" {\n  inspect(Float::reinterpret_from_int(1065353216), content=\"1\")\n  inspect(Float::reinterpret_from_uint(0x3F800000), content=\"1\")\n}\n\n///|\n/// Converts an integer to a 32-bit floating-point number. The conversion is\n/// exact for small integers, but may lose precision for large integers due to\n/// the limited precision of the floating-point format.\n///\n/// Parameters:\n///\n/// * `number` : The integer value to be converted to a floating-point number.\n///\n/// Returns a 32-bit floating-point number representing the same value as the\n/// input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   let f = Float::from_int(n)\n///   // Convert back to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"42\")\n/// }\n/// ```\npub fn Float::from_int(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n/// Converts a byte value to a 32-bit floating-point number (IEEE 754\n/// single-precision format). The byte value is treated as an unsigned 8-bit\n/// integer during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to a float.\n///\n/// Returns a 32-bit floating-point number representing the byte value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // 255 in decimal\n///   let f = Float::from_byte(b)\n///   // Convert to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"255\")\n/// }\n/// ```\npub fn Float::from_byte(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// Converts a double-precision floating-point number to a single-precision\n/// floating-point number. The conversion may result in a loss of precision due\n/// to the reduced number of bits available in the single-precision format.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns a single-precision floating-point number that represents the closest\n/// possible value to the input double-precision number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let d = 3.14159265359\n///   inspect(Float::from_double(d).to_double(), content=\"3.1415927410125732\") // Note the loss of precision\n/// }\n/// ```\npub fn Float::from_double(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n/// Converts an unsigned 32-bit integer to a single-precision floating-point\n/// number. Due to the limited precision of the 32-bit floating-point format,\n/// values above 16777216 (2^24) may lose precision during conversion.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the same numerical\n/// value as the input unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(Float::from_uint(n).to_double(), content=\"42\")\n///   let big = 16777216U // 2^24\n///   inspect(Float::from_uint(big).to_double(), content=\"16777216\") // Last precisely representable integer\n/// }\n/// ```\npub fn Float::from_uint(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n/// Converts an unsigned 64-bit integer to a 32-bit floating-point number. Due to\n/// floating-point precision limitations, the conversion may lose precision if\n/// the integer value is too large to be represented exactly as a float.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the input value. If\n/// the input value is too large to be represented exactly, the result will be\n/// rounded to the nearest representable float value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42UL\n///   inspect(Float::from_uint64(n).to_double(), content=\"42\")\n///   let big = 18446744073709551615UL // UInt64::max_value\n///   inspect(Float::from_uint64(big).to_double(), content=\"18446744073709552000\")\n/// }\n/// ```\n#cfg(not(target=\"js\"))\npub fn Float::from_uint64(self : UInt64) -> Float = \"%u64.to_f32\"\n\n///|\n#cfg(target=\"js\")\npub fn Float::from_uint64(self : UInt64) -> Float {\n  Float::from_double(self.to_double())\n}\n\n///|\ntest \"Float::from_uint64\" {\n  let n = 42UL\n  inspect(Float::from_uint64(n).to_double(), content=\"42\")\n  let big = 18446744073709551615UL // UInt64::max_value\n  inspect(Float::from_uint64(big).to_double(), content=\"18446744073709552000\")\n}\n\n///|\n/// Converts a 64-bit integer to a 32-bit floating-point number. The conversion\n/// may result in loss of precision due to the limited precision of the 32-bit\n/// floating-point format.\n///\n/// Parameters:\n///\n/// * `self` : The 64-bit integer value to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the input integer\n/// value. Note that for values outside the range of representable 32-bit\n/// floating-point numbers, the result will be rounded to the nearest\n/// representable value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42L\n///   let f = Float::from_int64(n)\n///   // Convert to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"42\")\n/// }\n/// ```\n#cfg(not(target=\"js\"))\npub fn Float::from_int64(self : Int64) -> Float = \"%i64.to_f32\"\n\n///|\n#cfg(target=\"js\")\npub fn Float::from_int64(self : Int64) -> Float {\n  Float::from_double(self.to_double())\n}\n\n///|\ntest \"Float::from_int64\" {\n  let n = 42L\n  let f = Float::from_int64(n)\n  inspect(f.to_double(), content=\"42\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts an integer to a double-precision floating-point number.\n///\n/// Parameters:\n///\n/// * `integer` : The integer value to be converted.\n///\n/// Returns a double-precision floating-point number representing the given\n/// integer value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Double::from_int(42), content=\"42\")\n///   inspect(Double::from_int(-1), content=\"-1\")\n/// }\n/// ```\n#as_free_fn(deprecated)\npub fn Double::from_int(i : Int) -> Double {\n  i.to_double()\n}\n\n///|\n/// Returns the absolute value of a double-precision floating-point number.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to compute the\n/// absolute value of.\n///\n/// Returns the absolute value of the input number. For any input `x`, the result\n/// is equivalent to `if x < 0.0 { -x } else { x }`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect((-2.5).abs(), content=\"2.5\")\n///   inspect(3.14.abs(), content=\"3.14\")\n///   inspect(0.0.abs(), content=\"0\")\n/// }\n/// ```\n#as_free_fn(deprecated)\npub fn Double::abs(self : Double) -> Double = \"%f64.abs\"\n\n///|\n/// Returns the sign of the double.\n/// - If the double is positive, returns 1.0.\n/// - If the double is negative, returns -1.0.\n/// - Otherwise, returns the double itself (0.0, -0.0 and NaN).\npub fn Double::signum(self : Double) -> Double {\n  if self < 0.0 {\n    -1.0\n  } else if self > 0.0 {\n    1.0\n  } else {\n    self // handles 0.0, -0.0, NaN\n  }\n}\n\n///|\n/// Checks whether a double-precision floating-point number represents a \"Not a\n/// Number\" (NaN) value.\n///\n/// Parameters:\n///\n/// * `number` : A double-precision floating-point value to be checked.\n///\n/// Returns `true` if the number is NaN, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@double.not_a_number.is_nan(), content=\"true\")\n///   inspect(42.0.is_nan(), content=\"false\")\n///   inspect((0.0 / 0.0).is_nan(), content=\"true\")\n/// }\n/// ```\npub fn Double::is_nan(self : Double) -> Bool {\n  // only NaNs satisfy f != f.\n  self != self\n}\n\n///|\n/// Checks whether a double-precision floating-point number represents positive\n/// or negative infinity.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to check.\n///\n/// Returns `true` if the value is either positive or negative infinity, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@double.infinity.is_inf(), content=\"true\")\n///   inspect(@double.neg_infinity.is_inf(), content=\"true\")\n///   inspect(42.0.is_inf(), content=\"false\")\n/// }\n/// ```\npub fn Double::is_inf(self : Double) -> Bool {\n  self > max_value || self < min_value\n}\n\n///|\n/// Checks whether a double-precision floating-point number is positive infinity.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to check.\n///\n/// Returns `true` if the number is positive infinity, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(@double.infinity.is_pos_inf(), content=\"true\")\n///   inspect(@double.neg_infinity.is_pos_inf(), content=\"false\")\n///   inspect(42.0.is_pos_inf(), content=\"false\") // TODO: better formatter\n/// }\n/// ```\npub fn Double::is_pos_inf(self : Double) -> Bool {\n  self > max_value\n}\n\n///|\n/// Checks whether a double-precision floating-point number is negative infinity.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number to check.\n///\n/// Returns a boolean value indicating whether the number is negative infinity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect((-1.0 / 0.0).is_neg_inf(), content=\"true\")\n///   inspect(42.0.is_neg_inf(), content=\"false\")\n///   inspect((1.0 / 0.0).is_neg_inf(), content=\"false\") // positive infinity\n/// }\n/// ```\npub fn Double::is_neg_inf(self : Double) -> Bool {\n  self < min_value\n}\n\n///|\npub impl Hash for Double with hash_combine(self, hasher) {\n  hasher.combine_double(self)\n}\n\n///|\n/// Converts a double-precision floating-point number to its string\n/// representation.\n///\n/// Parameters:\n///\n/// * `self`: The double-precision floating-point number to be converted.\n///\n/// Returns a string representation of the double-precision floating-point\n/// number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42.0.to_string(), content=\"42\")\n///   inspect(3.14159.to_string(), content=\"3.14159\")\n///   inspect((-0.0).to_string(), content=\"0\")\n///   inspect(@double.not_a_number.to_string(), content=\"NaN\")\n/// }\n/// ```\n///\npub fn Double::to_string(self : Double) -> String {\n  @ryu.ryu_to_string(self)\n}\n\n// TODO:\n// #intrinsic(\"%f64.to_string\")\n// impl Show for Double with to_string(self) -> String{\n//   @ryu.ryu_to_string(self)\n// }\n\n///|\npub impl Show for Double with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\n/// Determines whether two floating-point numbers are approximately equal within\n/// specified tolerances.\n/// The implementation follows the algorithm described in PEP 485 for Python's\n/// `math.isclose()`.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n/// * `relative_tolerance` : The relative tolerance for the comparison. Must be\n/// non-negative. Defaults to 1e-9.\n/// * `absolute_tolerance` : The absolute tolerance for the comparison. Must be\n/// non-negative. Defaults to 0.0.\n///\n/// Returns whether the two numbers are considered approximately equal. Returns\n/// `true` if the numbers are exactly equal or if they are within either the\n/// relative or absolute tolerance. Returns `false` if either number is infinite.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1.0\n///   let y = 1.000000001\n///   inspect(x.is_close(y), content=\"false\")\n///   inspect(x.is_close(y, relative_tolerance=1.0e-10), content=\"false\")\n///   inspect(@double.infinity.is_close(@double.infinity), content=\"true\")\n/// }\n/// ```\n#as_free_fn(deprecated)\npub fn Double::is_close(\n  self : Self,\n  other : Self,\n  relative_tolerance? : Self = 1.0e-09,\n  absolute_tolerance? : Self = 0.0,\n) -> Bool {\n  if relative_tolerance < 0.0 || absolute_tolerance < 0.0 {\n    abort(\"Tolerances must be non-negative\")\n  }\n  if self == other {\n    return true\n  }\n  if self.is_inf() || other.is_inf() {\n    return false\n  }\n  let diff = (other - self).abs()\n  return (\n      diff <= (relative_tolerance * other).abs() ||\n      diff <= (relative_tolerance * self).abs()\n    ) ||\n    diff <= absolute_tolerance\n}\n\n///|\n/// Converts a double-precision floating-point number to a sequence of bytes in\n/// big-endian byte order (most significant byte first).\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number to be converted.\n///\n/// Returns a sequence of 8 bytes representing the double-precision\n/// floating-point number in big-endian byte order.\n///\n#deprecated\n#doc(hidden)\npub fn Double::to_be_bytes(self : Double) -> Bytes {\n  self.reinterpret_as_uint64().to_be_bytes()\n}\n\n///|\n/// Converts a double-precision floating-point number to a sequence of bytes in\n/// little-endian order (least significant byte first).\n///\n/// Parameters:\n///\n/// * `self` : A double-precision floating-point number to be converted.\n///\n/// Returns a sequence of 8 bytes representing the double-precision\n/// floating-point number in little-endian order.\n///\n#deprecated\n#doc(hidden)\npub fn Double::to_le_bytes(self : Double) -> Bytes {\n  self.reinterpret_as_uint64().to_le_bytes()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.\n\n///|\nfn pow5bits(e : Int) -> Int {\n  ((e * 1217359).reinterpret_as_uint() >> 19).reinterpret_as_int() + 1\n}\n\n///|\nfn copy_special_str(sign : Bool, exponent : Bool, mantissa : Bool) -> String {\n  if mantissa {\n    return \"NaN\"\n  }\n  let s = if sign { \"-\" } else { \"\" }\n  if exponent {\n    return s + \"Infinity\"\n  }\n  return s + \"0.0\"\n}\n\n// Returns floor(log_10(5^e)); requires 0 <= e <= 2620.\n\n///|\nfn log10Pow5(e : Int) -> Int {\n  ((e * 732923).reinterpret_as_uint() >> 20).reinterpret_as_int()\n}\n\n// Returns floor(log_10(2^e)); requires 0 <= e <= 1650.\n\n///|\nfn log10Pow2(e : Int) -> Int {\n  ((e * 78913).reinterpret_as_uint() >> 18).reinterpret_as_int()\n}\n\n// MoonBit implementation of Ryu, https://github.com/ulfjack/ryu\n// This is a fork of the ryu crate adjusted to comply to the ECMAScript number-to-string algorithm,\n\n///|\nfn string_from_bytes(bytes : FixedArray[Byte], from : Int, to : Int) -> String {\n  let buf = StringBuilder::new(size_hint=bytes.length())\n  for i in from..<to {\n    buf.write_char(bytes[i].to_char())\n  }\n  buf.to_string()\n}\n\n///|\n#valtype\npriv struct Umul128(UInt64, UInt64)\n\n///|\n#valtype\npriv struct Pow5Pair(UInt64, UInt64)\n\n///|\n#valtype\npriv struct MulShiftAll64Result(UInt64, UInt64, UInt64)\n\n///|\nfn umul128(a : UInt64, b : UInt64) -> Umul128 {\n  let aLo = a & 0xffffffff\n  let aHi = a >> 32\n  let bLo = b & 0xffffffff\n  let bHi = b >> 32\n  let x = aLo * bLo\n  let y = aHi * bLo + (x >> 32)\n  let z = aLo * bHi + (y & 0xffffffff)\n  let w = aHi * bHi + (y >> 32) + (z >> 32)\n  let lo = a * b\n  let hi = w\n  Umul128(lo, hi)\n}\n\n///|\nfn shiftright128(lo : UInt64, hi : UInt64, dist : Int) -> UInt64 {\n  (hi << (64 - dist)) | (lo >> dist)\n}\n\n///|\nfn pow5Factor(value : UInt64) -> Int {\n  // We want to find the largest power of 5 that divides value.\n  if value % 5UL != 0UL {\n    return 0\n  }\n  if value % 25UL != 0UL {\n    return 1\n  }\n  if value % 125UL != 0UL {\n    return 2\n  }\n  if value % 625UL != 0UL {\n    return 3\n  }\n  let mut count = 4\n  let mut value = value / 625UL\n  while value > 0UL {\n    if value % 5UL != 0UL {\n      return count\n    }\n    value = value / 5UL\n    count = count + 1\n  }\n  abort(\"IllegalArgumentException \\{value}\")\n}\n\n///|\nfn multipleOfPowerOf5(value : UInt64, p : Int) -> Bool {\n  pow5Factor(value) >= p\n}\n\n///|\nfn multipleOfPowerOf2(value : UInt64, p : Int) -> Bool {\n  (value & ((1UL << p) - 1UL)) == 0UL\n}\n\n///|\nfn mulShiftAll64(\n  m : UInt64,\n  mul : Pow5Pair,\n  j : Int,\n  mmShift : Bool,\n) -> MulShiftAll64Result {\n  let Pow5Pair(mul0, mul1) = mul\n  let m = m << 1\n  let Umul128(lo, tmp) = umul128(m, mul0)\n  let Umul128(lo2, hi2) = umul128(m, mul1)\n  let mid = tmp + lo2\n  let hi = hi2 + (if mid < tmp { 1UL } else { 0UL })\n  let lo2 = lo + mul0\n  let mid2 = mid + mul1 + (if lo2 < lo { 1UL } else { 0UL })\n  let hi2 = hi + (if mid2 < mid { 1UL } else { 0UL })\n  let vp : UInt64 = shiftright128(mid2, hi2, j - 64 - 1)\n  let mut vm : UInt64 = 0UL\n  if mmShift {\n    let lo3 = lo - mul0\n    let mid3 = mid - mul1 - (if lo < lo3 { 1UL } else { 0UL })\n    let hi3 = hi - (if mid < mid3 { 1UL } else { 0UL })\n    vm = shiftright128(mid3, hi3, j - 64 - 1)\n  } else {\n    let lo3 : UInt64 = lo + lo\n    let mid3 : UInt64 = mid + mid + (if lo3 < lo { 1UL } else { 0UL })\n    let hi3 : UInt64 = hi + hi + (if mid3 < mid { 1UL } else { 0UL })\n    let lo4 : UInt64 = lo3 - mul0\n    let mid4 : UInt64 = mid3 - mul1 - (if lo3 < lo4 { 1UL } else { 0UL })\n    let hi4 : UInt64 = hi3 - (if mid3 < mid4 { 1UL } else { 0UL })\n    vm = shiftright128(mid4, hi4, j - 64)\n  }\n  let vr : UInt64 = shiftright128(mid, hi, j - 64 - 1)\n  MulShiftAll64Result(vr, vp, vm)\n}\n\n///|\nlet gPOW5_TABLE_SIZE = 26\n\n///|\nlet gDOUBLE_POW5_INV_SPLIT2 : ReadOnlyArray[UInt64] = [\n  1, 2305843009213693952, 5955668970331000884, 1784059615882449851, 8982663654677661702,\n  1380349269358112757, 7286864317269821294, 2135987035920910082, 7005857020398200553,\n  1652639921975621497, 17965325103354776697, 1278668206209430417, 8928596168509315048,\n  1978643211784836272, 10075671573058298858, 1530901034580419511, 597001226353042382,\n  1184477304306571148, 1527430471115325346, 1832889850782397517, 12533209867169019542,\n  1418129833677084982, 5577825024675947042, 2194449627517475473, 11006974540203867551,\n  1697873161311732311, 10313493231639821582, 1313665730009899186, 12701016819766672773,\n  2032799256770390445,\n]\n\n///|\nlet gPOW5_INV_OFFSETS : ReadOnlyArray[UInt] = [\n  0x54544554, 0x04055545, 0x10041000, 0x00400414, 0x40010000, 0x41155555, 0x00000454,\n  0x00010044, 0x40000000, 0x44000041, 0x50454450, 0x55550054, 0x51655554, 0x40004000,\n  0x01000001, 0x00010500, 0x51515411, 0x05555554, 0x00000000,\n]\n\n///|\nlet gDOUBLE_POW5_SPLIT2 : ReadOnlyArray[UInt64] = [\n  0, 1152921504606846976, 0, 1490116119384765625, 1032610780636961552, 1925929944387235853,\n  7910200175544436838, 1244603055572228341, 16941905809032713930, 1608611746708759036,\n  13024893955298202172, 2079081953128979843, 6607496772837067824, 1343575221513417750,\n  17332926989895652603, 1736530273035216783, 13037379183483547984, 2244412773384604712,\n  1605989338741628675, 1450417759929778918, 9630225068416591280, 1874621017369538693,\n  665883850346957067, 1211445438634777304, 14931890668723713708, 1565756531257009982,\n]\n\n///|\nlet gPOW5_OFFSETS : ReadOnlyArray[UInt] = [\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000000, 0x59695995, 0x55545555,\n  0x56555515, 0x41150504, 0x40555410, 0x44555145, 0x44504540, 0x45555550, 0x40004000,\n  0x96440440, 0x55565565, 0x54454045, 0x40154151, 0x55559155, 0x51405555, 0x00000105,\n]\n\n///|\nlet gDOUBLE_POW5_TABLE : ReadOnlyArray[UInt64] = [\n  1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625, 48828125, 244140625,\n  1220703125, 6103515625, 30517578125, 152587890625, 762939453125, 3814697265625,\n  19073486328125, 95367431640625, 476837158203125, 2384185791015625, 11920928955078125,\n  59604644775390625, 298023223876953125,\n]\n\n///|\n/// Computes 5^i in the form required by Ry.\nfn double_computePow5(i : Int) -> Pow5Pair {\n  let base = i / gPOW5_TABLE_SIZE\n  let base2 = base * gPOW5_TABLE_SIZE\n  let offset = i - base2\n  let mul0 = gDOUBLE_POW5_SPLIT2[base * 2]\n  let mul1 = gDOUBLE_POW5_SPLIT2[base * 2 + 1]\n  if offset == 0 {\n    return Pow5Pair(mul0, mul1)\n  }\n  let m : UInt64 = gDOUBLE_POW5_TABLE[offset]\n  let Umul128(low1, high1) = umul128(m, mul1)\n  let Umul128(low0, high0) = umul128(m, mul0)\n  let sum : UInt64 = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1UL\n  }\n  let delta : Int = pow5bits(i) - pow5bits(base2)\n  let a : UInt64 = shiftright128(low0, sum, delta) +\n    ((gPOW5_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3).to_uint64()\n  let b : UInt64 = shiftright128(sum, high1, delta)\n  Pow5Pair(a, b)\n}\n\n///|\n/// Computes 5^-i in the form required by Ry.\nfn double_computeInvPow5(i : Int) -> Pow5Pair {\n  let base = (i + gPOW5_TABLE_SIZE - 1) / gPOW5_TABLE_SIZE\n  let base2 = base * gPOW5_TABLE_SIZE\n  let offset = base2 - i\n  let mul0 = gDOUBLE_POW5_INV_SPLIT2[base * 2]\n  let mul1 = gDOUBLE_POW5_INV_SPLIT2[base * 2 + 1]\n  if offset == 0 {\n    return Pow5Pair(mul0, mul1)\n  }\n  let m = gDOUBLE_POW5_TABLE[offset]\n  let Umul128(low1, high1) = umul128(m, mul1)\n  let Umul128(low0, high0) = umul128(m, mul0)\n  let sum = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1UL\n  }\n  let delta : Int = pow5bits(base2) - pow5bits(i)\n  let a : UInt64 = shiftright128(low0, sum, delta) +\n    1UL +\n    ((gPOW5_INV_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3).to_uint64()\n  let b : UInt64 = shiftright128(sum, high1, delta)\n  Pow5Pair(a, b)\n}\n\n///|\nlet gDOUBLE_MANTISSA_BITS : Int = 52\n\n///|\nlet gDOUBLE_EXPONENT_BITS : Int = 11\n\n///|\nlet gDOUBLE_BIAS : Int = 1023\n\n///|\nlet gDOUBLE_POW5_INV_BITCOUNT : Int = 125\n\n///|\nlet gDOUBLE_POW5_BITCOUNT : Int = 125\n\n///|\nfn decimal_length17(v : UInt64) -> Int {\n  // This is slightly faster than a loop.\n  // The average output length is 16.38 digits, so we check high-to-low.\n  // Function precondition: v is not an 18, 19, or 20-digit number.\n  // (17 digits are sufficient for round-tripping.)\n  if v >= 10000000000000000 {\n    return 17\n  }\n  if v >= 1000000000000000 {\n    return 16\n  }\n  if v >= 100000000000000 {\n    return 15\n  }\n  if v >= 10000000000000 {\n    return 14\n  }\n  if v >= 1000000000000 {\n    return 13\n  }\n  if v >= 100000000000 {\n    return 12\n  }\n  if v >= 10000000000 {\n    return 11\n  }\n  if v >= 1000000000 {\n    return 10\n  }\n  if v >= 100000000 {\n    return 9\n  }\n  if v >= 10000000 {\n    return 8\n  }\n  if v >= 1000000 {\n    return 7\n  }\n  if v >= 100000 {\n    return 6\n  }\n  if v >= 10000 {\n    return 5\n  }\n  if v >= 1000 {\n    return 4\n  }\n  if v >= 100 {\n    return 3\n  }\n  if v >= 10 {\n    return 2\n  }\n  return 1\n}\n\n// A floating decimal representing m * 10^e.\n\n///|\npriv struct FloatingDecimal64 {\n  mantissa : UInt64\n  // Decimal exponent's range is -324 to 308\n  // inclusive, and can fit in a short if needed.\n  exponent : Int\n}\n\n///|\nfn d2d(ieeeMantissa : UInt64, ieeeExponent : UInt) -> FloatingDecimal64 {\n  let mut e2 : Int = 0\n  let mut m2 : UInt64 = 0\n  if ieeeExponent == 0 {\n    // Denormal number - no implicit leading 1, and the exponent is 1, not 0.\n    e2 = 1 - gDOUBLE_BIAS - gDOUBLE_MANTISSA_BITS - 2\n    m2 = ieeeMantissa\n  } else {\n    // Add implicit leading 1.\n    e2 = ieeeExponent.reinterpret_as_int() -\n      gDOUBLE_BIAS -\n      gDOUBLE_MANTISSA_BITS -\n      2\n    m2 = (1UL << gDOUBLE_MANTISSA_BITS) | ieeeMantissa\n  }\n  let even = (m2 & 1UL) == 0UL\n  let mv = 4UL *\n\n    // Step 2: Determine the interval of valid decimal representations.\n    m2\n  // Implicit bool -> int conversion. True is 1, false is 0.\n  let mmShift = ieeeMantissa != 0UL || ieeeExponent <= 1\n  // We would compute mp and mm like this:\n  // uint64_t mp = 4 * m2 + 2;\n  // uint64_t mm = mv - 1 - mmShift;\n\n  // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n  let mut vr = 0UL\n  let mut vp = 0UL\n  let mut vm = 0UL\n  let mut e10 : Int = 0\n  let mut vmIsTrailingZeros = false\n  let mut vrIsTrailingZeros = false\n  if e2 >= 0 {\n    // I tried special-casing q == 0, but there was no effect on performance.\n    // This expression is slightly faster than max(0, log10Pow2(e2) - 1).\n    let q : Int = log10Pow2(e2) - (e2 > 3).to_int()\n    e10 = q\n    let k = gDOUBLE_POW5_INV_BITCOUNT + pow5bits(q) - 1\n    let i = -e2 + q + k\n    let pow5 : Pow5Pair = double_computeInvPow5(q)\n    let MulShiftAll64Result(vrOut, vpOut, vmOut) = mulShiftAll64(\n      m2, pow5, i, mmShift,\n    )\n    vr = vrOut\n    vp = vpOut\n    vm = vmOut\n    if q <= 21 {\n      // This should use q <= 22, but I think 21 is also safe. Smaller values\n      // may still be safe, but it's more difficult to reason about them.\n      // Only one of mp, mv, and mm can be a multiple of 5, if any.\n      let mvMod5 : Int = mv.to_int() - 5 * (mv / 5UL).to_int()\n      if mvMod5 == 0 {\n        vrIsTrailingZeros = multipleOfPowerOf5(mv, q)\n      } else if even {\n        // Same as min(e2 + (~mm & 1), pow5Factor(mm)) >= q\n        // <=> e2 + (~mm & 1) >= q && pow5Factor(mm) >= q\n        // <=> true && pow5Factor(mm) >= q, since e2 >= q.\n        vmIsTrailingZeros = multipleOfPowerOf5(\n          mv - 1UL - mmShift.to_uint64(),\n          q,\n        )\n      } else {\n        vp = vp - multipleOfPowerOf5(mv + 2UL, q).to_uint64()\n      }\n    }\n  } else {\n    // This expression is slightly faster than max(0, log10Pow5(-e2) - 1).\n    let q : Int = log10Pow5(-e2) - (-e2 > 1).to_int()\n    e10 = q + e2\n    let i : Int = -e2 - q\n    let k = pow5bits(i) - gDOUBLE_POW5_BITCOUNT\n    let j = q - k\n    let pow5 : Pow5Pair = double_computePow5(i)\n    let MulShiftAll64Result(vrOut, vpOut, vmOut) = mulShiftAll64(\n      m2, pow5, j, mmShift,\n    )\n    vr = vrOut\n    vp = vpOut\n    vm = vmOut\n    if q <= 1 {\n      // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n      // mv = 4 * m2, so it always has at least two trailing 0 bits.\n      vrIsTrailingZeros = true\n      if even {\n        vmIsTrailingZeros = mmShift.to_int() == 1\n      } else {\n        vp = vp - 1\n      }\n    } else if q < 63 {\n      vrIsTrailingZeros = multipleOfPowerOf2(mv, q)\n    }\n  }\n\n  // Step 4: Find the shortest decimal representation in the interval of valid representations.\n  let mut removed : Int = 0\n  let mut lastRemovedDigit : Int = 0\n  let mut output : UInt64 = 0UL\n  // On average, we remove ~2 digits.\n  if vmIsTrailingZeros || vrIsTrailingZeros {\n    // General case, which happens rarely (~0.7%).\n    while true {\n      let vpDiv10 = vp / 10\n      let vmDiv10 = vm / 10\n      if vpDiv10 <= vmDiv10 {\n        break\n      }\n      let vmMod10 : Int = vm.to_int() - 10 * vmDiv10.to_int()\n      let vrDiv10 = vr / 10\n      let vrMod10 : Int = vr.to_int() - 10 * vrDiv10.to_int()\n      vmIsTrailingZeros = vmIsTrailingZeros && vmMod10 == 0\n      vrIsTrailingZeros = vrIsTrailingZeros && lastRemovedDigit == 0\n      lastRemovedDigit = vrMod10\n      vr = vrDiv10\n      vp = vpDiv10\n      vm = vmDiv10\n      removed = removed + 1\n    }\n    if vmIsTrailingZeros {\n      while true {\n        let vmDiv10 = vm / 10\n        let vmMod10 : Int = vm.to_int() - 10 * vmDiv10.to_int()\n        if vmMod10 != 0 {\n          break\n        }\n        let vpDiv10 = vp / 10\n        let vrDiv10 = vr / 10\n        let vrMod10 : Int = vr.to_int() - 10 * vrDiv10.to_int()\n        vrIsTrailingZeros = vrIsTrailingZeros && lastRemovedDigit == 0\n        lastRemovedDigit = vrMod10\n        vr = vrDiv10\n        vp = vpDiv10\n        vm = vmDiv10\n        removed = removed + 1\n      }\n    }\n    if vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0 {\n      lastRemovedDigit = 4\n    }\n    output = vr +\n      ((vr == vm && (!even || !vmIsTrailingZeros)) || lastRemovedDigit >= 5)\n      .to_int64()\n      .reinterpret_as_uint64()\n  } else {\n    // Specialized for the common case (~99.3%). Percentages below are relative to this.\n    let mut roundUp = false\n    let vpDiv100 = vp / 100\n    let vmDiv100 = vm / 100\n    if vpDiv100 > vmDiv100 {\n      let vrDiv100 = vr / 100\n      let vrMod100 : Int = vr.to_int() - 100 * vrDiv100.to_int()\n      roundUp = vrMod100 >= 50\n      vr = vrDiv100\n      vp = vpDiv100\n      vm = vmDiv100\n      removed = removed + 2\n    }\n    // Loop iterations below (approximately), without optimization above:\n    // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n    // Loop iterations below (approximately), with optimization above:\n    // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n    while true {\n      let vpDiv10 = vp / 10\n      let vmDiv10 = vm / 10\n      if vpDiv10 <= vmDiv10 {\n        break\n      }\n      let vrDiv10 = vr / 10\n      let vrMod10 : Int = vr.to_int() - 10 * vrDiv10.to_int()\n      roundUp = vrMod10 >= 5\n      vr = vrDiv10\n      vp = vpDiv10\n      vm = vmDiv10\n      removed = removed + 1\n    }\n    output = vr + (vr == vm || roundUp).to_uint64()\n  }\n  let exp : Int = e10 + removed\n  let fd : FloatingDecimal64 = { mantissa: output, exponent: exp }\n  fd\n}\n\n///|\nfn to_chars(v : FloatingDecimal64, sign : Bool) -> String {\n  // Step 5: Print the decimal representation.\n  let result = FixedArray::make(25, Byte::default())\n  let mut index : Int = 0\n  if sign {\n    result[index] = b'-'\n    index += 1\n  }\n  let mut output = v.mantissa\n  let olength = decimal_length17(output)\n  let mut exp : Int = v.exponent + olength - 1\n  let scientificNotation = !(exp >= -6 && exp < 21)\n  if scientificNotation {\n    // Print the decimal digits.\n    for i in 0..<(olength - 1) {\n      let c = output % 10\n      output /= 10\n      // 48 is ASCII '0', the same applies below.\n      result[index + olength - i] = (48 + c.to_int()).to_byte()\n    }\n    result[index] = (48 + output.to_int() % 10).to_byte()\n    if olength > 1 {\n      result[index + 1] = b'.'\n    } else {\n      // If there are no decimals, suppress .0\n      index -= 1\n    }\n    index += olength + 1\n\n    // Print the exponent.\n    result[index] = b'e'\n    index += 1\n    if exp < 0 {\n      result[index] = b'-'\n      index += 1\n      exp = -exp\n    } else {\n      result[index] = b'+'\n      index += 1\n    }\n    if exp >= 100 {\n      let a = exp / 100\n      let b = exp / 10 % 10\n      let c = exp % 10\n      result[index + 0] = (48 + a).to_byte()\n      result[index + 1] = (48 + b).to_byte()\n      result[index + 2] = (48 + c).to_byte()\n      index += 3\n    } else if exp >= 10 {\n      let a = exp / 10\n      let b = exp % 10\n      result[index + 0] = (48 + a).to_byte()\n      result[index + 1] = (48 + b).to_byte()\n      index += 2\n    } else {\n      result[index] = (48 + exp).to_byte()\n      index += 1\n    }\n    string_from_bytes(result, 0, index)\n  } else {\n    // Otherwise follow the ECMAScript spec.\n    if exp < 0 {\n      // Decimal dot is before any of the digits.\n      result[index] = b'0'\n      index += 1\n      result[index] = b'.'\n      index += 1\n      for i = -1; i > exp; i = i - 1 {\n        result[index] = b'0'\n        index += 1\n      }\n      let current = index\n      for i in 0..<olength {\n        result[current + olength - i - 1] = (48 + (output % 10).to_int()).to_byte()\n        output /= 10\n        index += 1\n      }\n    } else if exp + 1 >= olength {\n      // Decimal dot is after any of the digits.\n      for i in 0..<olength {\n        result[index + olength - i - 1] = (48 + (output % 10).to_int()).to_byte()\n        output /= 10\n      }\n      index += olength\n      for i in olength..<(exp + 1) {\n        result[index] = b'0'\n        index += 1\n      }\n    } else {\n      // Decimal dot is somewhere between the digits.\n      let mut current = index + 1\n      for i in 0..<olength {\n        if olength - i - 1 == exp {\n          result[current + olength - i - 1] = b'.'\n          current -= 1\n        }\n        result[current + olength - i - 1] = (48 + (output % 10).to_int()).to_byte()\n        output /= 10\n      }\n      index += olength + 1\n    }\n    return string_from_bytes(result, 0, index)\n  }\n}\n\n///|\nfn d2d_small_int(\n  ieeeMantissa : UInt64,\n  ieeeExponent : Int,\n) -> FloatingDecimal64? {\n  let m2 : UInt64 = (1UL << gDOUBLE_MANTISSA_BITS) | ieeeMantissa\n  let e2 : Int = ieeeExponent - gDOUBLE_BIAS - gDOUBLE_MANTISSA_BITS\n  if e2 > 0 {\n    return None\n  }\n  if e2 < -52 {\n    return None\n  }\n  let mask : UInt64 = (1UL << -e2) - 1UL\n  let fraction : UInt64 = m2 & mask\n  if fraction != 0UL {\n    return None\n  }\n  Some({ mantissa: m2 >> -e2, exponent: 0 })\n}\n\n///|\n/// TODO: ryu_to_logger[T:Logger](Double/Float, T) -> Unit\npub fn ryu_to_string(val : Double) -> String {\n  if val == 0.0 {\n    return \"0\"\n  }\n  // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.\n  let bits : UInt64 = val.reinterpret_as_uint64()\n\n  // Decode bits into sign, mantissa, and exponent.\n  let ieeeSign = (\n      (bits >> (gDOUBLE_MANTISSA_BITS + gDOUBLE_EXPONENT_BITS)) & 1UL\n    ) !=\n    0UL\n  let ieeeMantissa : UInt64 = bits & ((1UL << gDOUBLE_MANTISSA_BITS) - 1UL)\n  let ieeeExponent : Int = ((bits >> gDOUBLE_MANTISSA_BITS) &\n  ((1UL << gDOUBLE_EXPONENT_BITS) - 1UL)).to_int()\n  if ieeeExponent == (1 << gDOUBLE_EXPONENT_BITS) - 1 ||\n    (ieeeExponent == 0 && ieeeMantissa == 0UL) {\n    return copy_special_str(ieeeSign, ieeeExponent != 0, ieeeMantissa != 0UL)\n  }\n  let mut v : FloatingDecimal64 = { mantissa: 0UL, exponent: 0 }\n  let small = d2d_small_int(ieeeMantissa, ieeeExponent)\n  match small {\n    Some(f) => {\n      let mut x = f\n      while true {\n        let q : UInt64 = x.mantissa / 10\n        let r = x.mantissa - 10UL * q\n        if r != 0 {\n          break\n        }\n        x = { mantissa: q, exponent: x.exponent + 1 }\n      }\n      v = x\n    }\n    None => v = d2d(ieeeMantissa, ieeeExponent.reinterpret_as_uint())\n  }\n  to_chars(v, ieeeSign)\n}\n\n///|\ntest \"double/ryu.mbt:205\" {\n  let m = 123456789UL\n  let mul0 = 987654321UL\n  let Umul128(_, high0) = umul128(m, mul0)\n  let low1 = 111111111UL\n  let high1 = 222222222UL\n  let sum = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1\n  }\n  inspect(high1, content=\"222222222\")\n}\n\n///|\ntest \"double/ryu.mbt:230\" {\n  let m = 123456789UL\n  let mul0 = 987654321UL\n  let Umul128(_, high0) = umul128(m, mul0)\n  let low1 = 111111111UL\n  let high1 = 222222222UL\n  let sum = high0 + low1\n  let mut high1 = high1\n  if sum < high0 {\n    high1 = high1 + 1UL\n  }\n  assert_eq(high1, 222222222UL)\n}\n\n///|\ntest \"double/ryu.mbt:252\" {\n  inspect(gDOUBLE_POW5_BITCOUNT, content=\"125\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// }\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// }\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Creates a new array of the specified length, where each element is\n/// initialized using an index-based initialization function.\n///\n/// Parameters:\n///\n/// * `length` : The length of the new array. If `length` is less than or equal\n/// to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (starting from 0) and\n/// returns a value of type `T`. This function is called for each index to\n/// initialize the corresponding element.\n///\n/// Returns a new array of type `Array[T]` with the specified length, where each\n/// element is initialized using the provided function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::makei(3, i => i * 2)\n///   inspect(arr, content=\"[0, 2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::makei(length : Int, f : (Int) -> T raise?) -> Array[T] raise? {\n  if length <= 0 {\n    []\n  } else {\n    let array = Array::make_uninit(length)\n    for i in 0..<length {\n      array.unsafe_set(i, f(i))\n    }\n    array\n  }\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.get\")\n#alias(\"_[_]\")\npub fn[T] Array::at(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// }\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\npub fn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.set\")\n#alias(\"_[_]=_\")\npub fn[T] Array::set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// }\n/// ```\npub impl[T : Eq] Eq for Array[T] with equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// }\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// }\n/// ```\npub impl[T] Add for Array[T] with add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[T] Array::append(self : Array[T], other : ArrayView[T]) -> Unit {\n  other.blit_to(self, dst_offset=self.length())\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each(x => sum = sum - x)\n///   @json.inspect(sum, content=-12)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => sum = sum + x + i)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks whether all elements satisfy the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.all(x => x < 6))\n///   assert_false(arr.all(x => x < 5))\n/// }\n/// ```\n#alias(every)\npub fn[T] Array::all(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].all(f)\n}\n\n///|\n/// Checks whether any element satisfies the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.any(x => x < 6))\n///   assert_false(arr.any(x => x < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] Array::any(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].any(f)\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// }\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.map(x => x + 1)\n///   assert_eq(v2, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.map_in_place(x => x + 1)\n///   assert_eq(v, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\n#alias(map_inplace, deprecated)\npub fn[T] Array::map_in_place(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => x + i)\n///   assert_eq(v2, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.mapi_in_place((i, x) => x + i)\n///   assert_eq(v, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\n#alias(mapi_inplace, deprecated)\npub fn[T] Array::mapi_in_place(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter(x => x % 2 == 0)\n///   inspect(evens, content=\"[2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///   let arr : Array[Int] = []\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n#alias(rev_inplace, deprecated)\npub fn[T] Array::rev_in_place(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// }\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let (v1, v2) = (v[:1], v[1:])\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// }\n/// ```\n#deprecated(\"Use ArrayView instead, e.g, (a[:index], a[index:])\")\n#doc(hidden)\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  self[:].starts_with(prefix[:])\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  self[:].ends_with(suffix[:])\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// }\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// }\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  self[:].search(value)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by(x => x == 3) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// }\n/// ```\n#locals(f)\n#alias(find_index, deprecated)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// }\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  self[:].binary_search(value)\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by(x => x.compare(3))\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by(x => x.compare(4))\n///   inspect(find_4, content=\"Err(2)\")\n/// }\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self[:].binary_search_by(cmp)\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// }\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain(x => x % 2 == 0)\n///   inspect(arr, content=\"[2, 4]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(x => x > 10)\n///   inspect(arr, content=\"[]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// }\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens an array of arrays into an array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create an array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// }\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_left, deprecated)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_right, deprecated)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_lefti, deprecated)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_righti, deprecated)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if(x => x % 2 == 0)\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let removed = []\n  let mut write = 0\n  for read in 0..<self.length() {\n    let elem = self[read]\n    if f(elem) {\n      removed.push(elem)\n    } else {\n      if read != write {\n        self[write] = elem\n      }\n      write += 1\n    }\n  }\n  self.truncate(write)\n  removed\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length()\n  if len == 0 {\n    return []\n  }\n  let num_chunks = (len + size - 1) / size\n  Array::makei(num_chunks, i => {\n    let start = i * size\n    let end = Int::min(start + size, len)\n    self[start:end]\n  })\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => x <= y)\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => x <= y), content=\"[]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[ArrayView[T]] raise? {\n  let chunks = []\n  if self.is_empty() {\n    return chunks\n  }\n  let mut start = 0\n  for i in 1..<self.length() {\n    if !pred(self[i - 1], self[i]) {\n      chunks.push(self[start:i])\n      start = i\n    }\n  }\n  chunks.push(self[start:self.length()])\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  Array::makei(len, i => self[i:i + size])\n}\n\n///|\npub fn[T] Array::suffixes(\n  self : Array[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split(x => x == 0), content=\"[[1], [2], [3], [4]]\")\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split(x => x == 0), content=\"[[], [1], [], [2]]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  self[:].iter()\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each(x => result.push(x))\n///   inspect(result, content=\"[3, 2, 1]\")\n/// }\n/// ```\n#alias(rev_iterator, deprecated)\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  self[:].rev_iter()\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => sum = sum + i + x)\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  self[:].iter2()\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// }\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// }\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\n#doc(hidden)\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.truncate(3)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain_map(fn(x) { if x % 2 == 0 { Some(x * 2) } else { None } })\n///   inspect(arr, content=\"[4, 8]\")\n/// }\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(42)\n///   let arr = Array::from_iter(iter)\n///   inspect(arr, content=\"[42]\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] Array::from_iter(iter : Iter[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Adds all elements from an iterator to the end of the array.\n///\n/// This function iterates over each element in the provided iterator\n/// and adds them to the array using the `push` method.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let u = [1, 2, 3]\n///   let v = [4, 5, 6]\n///   u.push_iter(v.iter())\n///   assert_eq(u, [1, 2, 3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::push_iter(self : Self[T], iter : Iter[T]) -> Unit {\n  // This function used by [Array spread operator](https://docs.moonbitlang.com/en/latest/language/fundamentals.html#spread-operator)\n  // it can't be removed and deprecated\n  for x in iter {\n    self.push(x)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt check\n/// test {\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// Array::shuffle_in_place(arr, rand~)\n/// }\n/// ```\npub fn[T] Array::shuffle_in_place(\n  self : Array[T],\n  rand~ : (Int) -> Int,\n) -> Unit {\n  let n = self.length()\n  for i = n - 1; i > 0; i = i - 1 {\n    let j = rand(i + 1) % (i + 1)\n    // for safety, perf is not a concern here\n    // TODO: maybe return an error later\n    self.swap(i, j)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt\n/// let arr = [1, 2, 3, 4, 5]\n///\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// let _shuffled = Array::shuffle(arr, rand~)\n/// ```\npub fn[T] Array::shuffle(self : Array[T], rand~ : (Int) -> Int) -> Array[T] {\n  let new_arr = self.copy()\n  Array::shuffle_in_place(new_arr, rand~)\n  new_arr\n}\n\n///|\n/// Returns a new array containing the elements of the original array that satisfy the given predicate.\n///\n/// # Arguments\n///\n/// * `self` - The array to filter.\n/// * `f` - The predicate function.\n///\n/// # Returns\n///\npub fn[A, B] Array::filter_map(\n  self : Array[A],\n  f : (A) -> B? raise?,\n) -> Array[B] raise? {\n  let result = []\n  for x in self {\n    if f(x) is Some(x) {\n      result.push(x)\n    }\n  }\n  result\n}\n\n///|\n/// Returns the last element of the array, or `None` if the array is empty.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the last element from.\n///\n/// Returns an optional value containing the last element of the array. The\n/// result is `None` if the array is empty, or `Some(x)` where `x` is the last\n/// element of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.last(), content=\"Some(3)\")\n///   let empty : Array[Int] = []\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[A] Array::last(self : Array[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\n/// Zips two arrays into a single array of tuples.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an array of tuples, where each tuple contains corresponding elements\n/// from the two input arrays.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(arr1.zip(arr2), content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\")\n/// }\n/// ```\npub fn[A, B] Array::zip(self : Array[A], other : Array[B]) -> Array[(A, B)] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  Array::makei(length, i => (self[i], other[i]))\n}\n\n///|\n/// Splits an array of pairs into two arrays, separating the first and second elements.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n///   let (nums, strs) = arr.unzip()\n///   inspect(nums, content=\"[1, 2, 3]\")\n///   inspect(strs, content=\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\")\n/// }\n/// ```\npub fn[T1, T2] Array::unzip(self : Array[(T1, T2)]) -> (Array[T1], Array[T2]) {\n  let arr1 : Array[T1] = Array::new(capacity=self.length())\n  let arr2 : Array[T2] = Array::new(capacity=self.length())\n  for pair in self {\n    let (x, y) = pair\n    arr1.push(x)\n    arr2.push(y)\n  }\n  (arr1, arr2)\n}\n\n///|\n/// Zips two arrays into an iterator that yields corresponding elements.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an `Iter2` iterator that produces corresponding elements\n/// from both arrays. The iteration continues until the shorter array is exhausted.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(\n///     arr1.zip_to_iter2(arr2).to_array(),\n///     content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\",\n///   )\n/// }\n/// ```\npub fn[A, B] Array::zip_to_iter2(\n  self : Array[A],\n  other : Array[B],\n) -> Iter2[A, B] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  let mut i = 0\n  Iter2::new(() => {\n    guard i < length else { None }\n    let elem = (self[i], other[i])\n    i += 1\n    Some(elem)\n  }).iter2()\n}\n\n///|\n/// Join an array of strings using the provided `separator`.\n///\n/// Parameters:\n///   * `separator` : The string inserted between each element.\n///\n/// Returns a single concatenated `String`.\n/// # Example:\n/// ```mbt check\n/// test {\n///   let s = \"hello world\"\n///   inspect(s.split(\" \").to_array().join(\":\"), content=\"hello:world\")\n/// }\n/// ```\npub fn[A : ToStringView] Array::join(\n  self : Array[A],\n  separator : StringView,\n) -> String {\n  self[:].join(separator)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] UninitializedArray::set_null(self : UninitializedArray[T], index : Int) = \"%fixedarray.set_null\"\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\nstruct Array[T] {\n  mut buf : UninitializedArray[T]\n  mut len : Int\n}\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] {\n  { buf: UninitializedArray::make(len), len }\n}\n\n///|\n/// Creates a new empty array with an optional initial capacity.\n///\n/// Parameters:\n///\n/// * `capacity` : The initial capacity of the array. If 0 (default), creates an\n/// array with minimum capacity. Must be non-negative.\n///\n/// Returns a new empty array of type `Array[T]` with the specified initial\n/// capacity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::new(capacity=10)\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.capacity(), content=\"10\")\n///   let arr : Array[Int] = Array::new()\n///   inspect(arr.length(), content=\"0\")\n/// }\n/// ```\npub fn[T] Array::new(capacity? : Int = 0) -> Array[T] {\n  if capacity == 0 {\n    []\n  } else {\n    { buf: UninitializedArray::make(capacity), len: 0 }\n  }\n}\n\n///|\n/// Returns the number of elements in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array whose length is to be determined.\n///\n/// Returns the number of elements in the array as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.length(), content=\"3\")\n///   let empty : Array[Int] = []\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\n#intrinsic(\"%array.length\")\npub fn[T] Array::length(self : Array[T]) -> Int {\n  self.len\n}\n\n///|\n/// Truncates the array to the specified length. This function is marked as\n/// `unsafe` because it directly manipulates the internal buffer of the array,\n/// which can lead to undefined behavior if not used carefully.\n///\n/// # Parameters\n///\n/// - `self` : The array to be truncated.\n/// - `new_len` : The new length to which the array should be truncated. Must be\n/// less than or equal to the current length of the array.\n///\n/// # Returns\n///\n/// - `Unit` : This function does not return a value.\n///\n/// # Errors\n///\n/// - This function does not explicitly raise errors, but improper use (e.g.,\n/// setting `new_len` greater than the current length) can lead to undefined\n/// behavior.\n///\n/// TODO: this can be optimized by using the intrinsic to null out the range\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  let len = self.length()\n  guard new_len <= len\n  for i in new_len..<len {\n    self.buf.set_null(i)\n  }\n  self.len = new_len\n}\n\n///|\ntest \"unsafe_truncate_to_length\" {\n  let arr = [1, 2, 3, 4, 5]\n  arr.unsafe_truncate_to_length(3)\n  inspect(arr, content=\"[1, 2, 3]\")\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] {\n  self.buf\n}\n\n///|\nfn[T] Array::resize_buffer(self : Array[T], new_capacity : Int) -> Unit {\n  let new_buf = UninitializedArray::make(new_capacity)\n  let old_buf = self.buf\n  let old_cap = old_buf.0.length()\n  let copy_len = if old_cap < new_capacity { old_cap } else { new_capacity }\n  UninitializedArray::unsafe_blit(new_buf, 0, old_buf, 0, copy_len)\n  self.buf = new_buf\n}\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"Array::resize_buffer\" {\n  let arr = Array::new(capacity=2)\n  arr.push(1)\n  arr.push(2)\n  arr.resize_buffer(4)\n  assert_eq(arr.buffer().0.length() >= 4, true)\n  arr.push(3)\n  arr.push(4)\n  assert_eq(arr.length(), 4)\n  assert_eq(arr[0], 1)\n  assert_eq(arr[1], 2)\n  assert_eq(arr[2], 3)\n  assert_eq(arr[3], 4)\n}\n\n///|\n/// Reallocate the array with a new capacity.\nfn[T] Array::realloc(self : Array[T]) -> Unit {\n  let old_cap = self.length()\n  let new_cap = if old_cap == 0 { 8 } else { old_cap * 2 }\n  self.resize_buffer(new_cap)\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 10)\n/// }\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  if self.capacity() >= capacity {\n    return\n  }\n  self.resize_buffer(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// }\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  if self.capacity() <= self.length() {\n    return\n  }\n  self.resize_buffer(self.length())\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = []\n///   v.push(3)\n/// }\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  let length = self.length()\n  self.unsafe_set(length, value)\n  self.len = length + 1\n}\n\n///|\n/// Removes the last element from an array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3]\n///   assert_eq(v.pop(), Some(3))\n///   assert_eq(v, [1, 2])\n/// }\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    let index = len - 1\n    let v = self.unsafe_get(index)\n    self.buf.set_null(index)\n    self.len = index\n    Some(v)\n  }\n}\n\n///|\n/// Removes and returns the last element from the array.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to remove and return the last element.\n///\n/// Returns the last element of the array before removal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_pop(), content=\"3\")\n///   inspect(arr, content=\"[1, 2]\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if the array is empty.\")\n#doc(hidden)\n#alias(pop_exn, deprecated)\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  let len = self.length()\n  guard len != 0\n  let index = len - 1\n  let v = self.unsafe_get(index)\n  self.buf.set_null(index)\n  self.len = index\n  v\n}\n\n///|\n/// Removes and returns the element at position index within the array, \n/// shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   assert_eq(v.remove(1), 4)\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.unsafe_get(index)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index,\n    self.buffer(),\n    index + 1,\n    self.length() - index - 1,\n  )\n  self.unsafe_truncate_to_length(self.length() - 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns an array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end\n  let num = end - begin\n  let v = Array::make_uninit(num)\n  UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), begin, num)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    begin,\n    self.buffer(),\n    end,\n    self.length() - end,\n  )\n  self.unsafe_truncate_to_length(self.length() - num)\n  v\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   a.insert(1, 4)\n///   inspect(a, content=\"[1, 4, 2, 3]\")\n///   let b = [1, 2, 3]\n///   b.insert(0, 5)\n///   inspect(b, content=\"[5, 1, 2, 3]\")\n///   let c = [1, 2, 3]\n///   c.insert(3, 6)\n///   inspect(c, content=\"[1, 2, 3, 6]\")\n/// }\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index + 1,\n    self.buffer(),\n    index,\n    self.length() - index,\n  )\n  let length = self.length()\n  self.unsafe_set(index, value)\n  self.len = length + 1\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitialized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  let new_buf = UninitializedArray::make(new_len)\n  UninitializedArray::unsafe_blit(new_buf, 0, self.buf, 0, self.len)\n  self.len = new_len\n  self.buf = new_buf\n}\n\n///|\n/// Fills an Array with a specified value.\n/// \n/// This method fills all or part of an Array with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```mbt check\n/// test {\n///   // Fill entire array\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.fill(0)\n///   inspect(arr, content=\"[0, 0, 0, 0, 0]\")\n///\n///   // Fill from index 1 to 3 (exclusive)\n///   let arr2 = [1, 2, 3, 4, 5]\n///   arr2.fill(99, start=1, end=3)\n///   inspect(arr2, content=\"[1, 99, 99, 4, 5]\")\n///\n///   // Fill from index 2 to end\n///   let arr3 = [\"a\", \"b\", \"c\", \"d\"]\n///   arr3.fill(\"x\", start=2)\n///   inspect(\n///     arr3,\n///     content=(\n///       #|[\"a\", \"b\", \"x\", \"x\"]\n///     ),\n///   )\n/// }\n/// ```\npub fn[A] Array::fill(\n  self : Array[A],\n  value : A,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let length = match end {\n    None => array_length\n    Some(e) => {\n      guard e >= start && e <= array_length\n      e\n    }\n  }\n  self.buf.unchecked_fill(start, value, length - start)\n}\n\n///|\n/// Creates and returns a new array with a copy of all elements from the input\n/// array.\n///\n/// Parameters:\n///\n/// * `array` : The array to be copied.\n///\n/// Returns a new array containing all elements from the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let original = [1, 2, 3]\n///   let copied = original.copy()\n///   inspect(copied, content=\"[1, 2, 3]\")\n///   inspect(physical_equal(original, copied), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::copy(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    Array::unsafe_blit(arr, 0, self, 0, len)\n    arr\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Copies elements from one array to another array. Works correctly even when\n/// the source and destination arrays overlap.\n///\n/// Parameters:\n///\n/// * `dst` : The destination array where elements will be copied to.\n/// * `dst_offset` : The starting index in the destination array where elements\n/// should be copied.\n/// * `src` : The source array from which elements will be copied.\n/// * `src_offset` : The starting index in the source array from which elements\n/// should be copied.\n/// * `len` : The number of elements to copy.\n///\n/// The behavior is undefined if any of the following conditions are met:\n///\n/// * `len` is negative\n/// * `dst_offset` is negative\n/// * `src_offset` is negative\n/// * `dst_offset + len` exceeds the length of destination array\n/// * `src_offset + len` exceeds the length of source array\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = [1, 2, 3, 4, 5]\n///   let dst = [0, 0, 0, 0, 0]\n///   Array::unsafe_blit(dst, 1, src, 2, 2)\n///   inspect(dst, content=\"[0, 3, 4, 0, 0]\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if the indices or length are out of bounds\")\n#doc(hidden)\npub fn[A] Array::unsafe_blit(\n  dst : Array[A],\n  dst_offset : Int,\n  src : Array[A],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(\n    dst.buffer().0,\n    dst_offset,\n    src.buffer().0,\n    src_offset,\n    len,\n  )\n}\n\n///|\n/// Copies elements from a fixed-size array to a dynamic array. The arrays may\n/// overlap, in which case the copy is performed in a way that preserves the\n/// data.\n///\n/// Parameters:\n///\n/// * `dst` : The destination dynamic array where elements will be copied to.\n/// * `dst_offset` : The starting index in the destination array where copying\n/// begins.\n/// * `src` : The source fixed-size array from which elements will be copied.\n/// * `src_offset` : The starting index in the source array from which copying\n/// begins.\n/// * `len` : The number of elements to copy.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = FixedArray::make(5, 0)\n///   let dst = Array::make(5, 0)\n///   for i in 0..<5 {\n///     src[i] = i + 1\n///   }\n///   Array::unsafe_blit_fixed(dst, 1, src, 0, 2)\n///   inspect(dst, content=\"[0, 1, 2, 0, 0]\")\n/// }\n/// ```\npub fn[A] Array::unsafe_blit_fixed(\n  dst : Array[A],\n  dst_offset : Int,\n  src : FixedArray[A],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  UninitializedArray::unsafe_blit_fixed(\n    dst.buffer(),\n    dst_offset,\n    src,\n    src_offset,\n    len,\n  )\n}\n\n///|\n/// Copies elements from one array to another array, with support for growing the\n/// destination array if needed. The arrays may overlap, in which case the copy\n/// is performed in a way that preserves the data.\n///\n/// Parameters:\n///\n/// * `self` : The array to copy elements from.\n/// * `dst` : The array to copy elements to. Will be automatically grown\n/// if needed to accommodate the copied elements.\n/// * `len` : The number of elements to copy.\n/// * `src_offset` : Starting index in the source array. Defaults to 0.\n/// * `dst_offset` : Starting index in the destination array. Defaults to\n/// 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = [1, 2, 3, 4, 5]\n///   let dst = [0, 0]\n///   src[:3].blit_to(dst, dst_offset=1)\n///   inspect(dst, content=\"[0, 1, 2, 3]\")\n/// }\n/// ```\n///\n/// Panics if:\n///\n/// * `len` is negative\n/// * `src_offset` is negative\n/// * `dst_offset` is negative\n/// * `dst_offset` exceeds the length of destination array\n/// * `src_offset + len` exceeds the length of source array\n// TODO: make len optional and deprecate it\n#label_migration(src_offset, fill=false, msg=\"Use ArrayView::blit_to instead\")\n#label_migration(len, fill=false, msg=\"Use ArrayView::blit_to instead\")\npub fn[A] Array::blit_to(\n  self : Array[A],\n  dst : Array[A],\n  len? : Int = self.length(),\n  src_offset? : Int = 0,\n  dst_offset? : Int = 0,\n) -> Unit {\n  guard len >= 0 &&\n    dst_offset >= 0 &&\n    src_offset >= 0 &&\n    dst_offset <= dst.length() &&\n    src_offset + len <= self.length()\n  if dst_offset + len > dst.length() {\n    dst.unsafe_grow_to_length(dst_offset + len)\n  }\n  Array::unsafe_blit(dst, dst_offset, self, src_offset, len)\n}\n\n///|\n/// Copies all elements from an array view to a destination array, with support\n/// for growing the destination array if needed.\n///\n/// Parameters:\n///\n/// * `self` : The array view to copy elements from.\n/// * `dst` : The array to copy elements to. Will be automatically grown\n/// if needed to accommodate the copied elements.\n/// * `dst_offset` : Starting index in the destination array. Defaults to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = [1, 2, 3, 4, 5]\n///   let view = src[1:4] // view = [2, 3, 4]\n///   let dst = [0, 0]\n///   view.blit_to(dst, dst_offset=1)\n///   inspect(dst, content=\"[0, 2, 3, 4]\")\n/// }\n/// ```\n///\n/// Panics if:\n///\n/// * `dst_offset` is negative\n/// * `dst_offset` exceeds the length of destination array\npub fn[A] ArrayView::blit_to(\n  self : ArrayView[A],\n  dst : Array[A],\n  dst_offset? : Int = 0,\n) -> Unit {\n  let len = self.len()\n  guard dst_offset >= 0 && dst_offset <= dst.length()\n  if dst_offset + len > dst.length() {\n    dst.unsafe_grow_to_length(dst_offset + len)\n  }\n  UninitializedArray::unsafe_blit(\n    dst.buffer(),\n    dst_offset,\n    self.buf(),\n    self.start(),\n    len,\n  )\n}\n\n///|\ntest \"Array::blit_to/basic\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  src[1:4].blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 0, 2, 3, 4]\")\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  src[0:3].blit_to(dst)\n  inspect(dst, content=\"[1, 2, 3, 0, 0]\")\n}\n\n///|\ntest \"Array::blit_to/zero_length\" {\n  let src = [1, 2, 3]\n  let dst = [4, 5, 6]\n  src[0:0].blit_to(dst)\n  inspect(dst, content=\"[4, 5, 6]\")\n}\n\n///|\ntest \"Array::blit_to/grow_destination\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0]\n  src[0:3].blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 1, 2, 3]\")\n}\n\n///|\ntest \"Array::blit_to/edge_cases\" {\n  // Test with src_offset and dst_offset\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  src[1:3].blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 0, 2, 3, 0]\")\n\n  // Test when src and dst are the same array\n  src[0:2].blit_to(src, dst_offset=3)\n  inspect(src, content=\"[1, 2, 3, 1, 2]\")\n\n  // Test with len equal to 0\n  src[0:0].blit_to(dst, dst_offset=0)\n  inspect(dst, content=\"[0, 0, 2, 3, 0]\")\n\n  // Test with len equal to the length of src\n  src[0:5].blit_to(dst)\n  inspect(dst, content=\"[1, 2, 3, 1, 2]\")\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases1\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n\n  // Invalid range (start > end will panic)\n  ignore(src[3:1].blit_to(dst))\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases2\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  // Invalid src_offset (negative index in view creation will panic)\n  ignore(src[-1:1].blit_to(dst))\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases3\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  // len exceeding src length\n  ignore(src[0:6].blit_to(dst))\n}\n\n///|\ntest \"panic Array::blit_to/boundary_cases4\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  // dst offset exceeding dst length\n  ignore(src[0:5].blit_to(dst, dst_offset=6))\n}\n\n///|\n/// TODO\n/// 1. allow skip\n/// 2. verify test\n/// 3. concurrency test\ntest \"Array::blit_to - random cases\" {\n  let src = [10, 20, 30, 40, 50]\n  let dst = [0, 0, 0, 0, 0]\n\n  // Random len, src_offset, and dst_offset\n  src[2:4].blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 30, 40, 0, 0]\")\n\n  // Another random case\n  src[1:4].blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 30, 20, 30, 40]\")\n\n  // Yet another random case\n  src[4:5].blit_to(dst, dst_offset=4)\n  inspect(dst, content=\"[0, 30, 20, 30, 50]\")\n}\n\n///|\ntest \"Array::blit_to - boundary cases\" {\n  let src = [1, 2, 3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n\n  // Test with src_offset at the end of src\n  src[4:5].blit_to(dst, dst_offset=0)\n  inspect(dst, content=\"[5, 0, 0, 0, 0]\")\n\n  // Test with dst_offset at the end of dst\n  src[0:1].blit_to(dst, dst_offset=4)\n  inspect(dst, content=\"[5, 0, 0, 0, 1]\")\n\n  // Test with len equal to the remaining length of src\n  src[3:5].blit_to(dst, dst_offset=3)\n  inspect(dst, content=\"[5, 0, 0, 4, 5]\")\n}\n\n///|\ntest \"Array::unsafe_blit_fixed\" {\n  let src = FixedArray::make(3, 1) // Create a FixedArray with 3 elements of value 1\n  let dst = Array::make(5, 0) // Create an Array with 5 elements of value 0\n  Array::unsafe_blit_fixed(dst, 1, src, 0, 2) // Copy 2 elements from src[0] to dst[1]\n  inspect(dst, content=\"[0, 1, 1, 0, 0]\")\n}\n\n///|\ntest \"ArrayView::blit_to/basic\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4] // view = [2, 3, 4]\n  let dst = [0, 0, 0, 0, 0]\n  view.blit_to(dst)\n  inspect(dst, content=\"[2, 3, 4, 0, 0]\")\n}\n\n///|\ntest \"ArrayView::blit_to/with_offset\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4] // view = [2, 3, 4]\n  let dst = [0, 0, 0, 0, 0]\n  view.blit_to(dst, dst_offset=2)\n  inspect(dst, content=\"[0, 0, 2, 3, 4]\")\n}\n\n///|\ntest \"ArrayView::blit_to/grow_destination\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4] // view = [2, 3, 4]\n  let dst = [0, 0]\n  view.blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 2, 3, 4]\")\n}\n\n///|\ntest \"ArrayView::blit_to/empty_view\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[2:2] // empty view\n  let dst = [0, 0, 0]\n  view.blit_to(dst)\n  inspect(dst, content=\"[0, 0, 0]\")\n}\n\n///|\ntest \"ArrayView::blit_to/nested_view\" {\n  let src = [1, 2, 3, 4, 5, 6, 7]\n  let view1 = src[1:6] // [2, 3, 4, 5, 6]\n  let view2 = view1[1:4] // [3, 4, 5]\n  let dst = [0, 0, 0, 0, 0]\n  view2.blit_to(dst, dst_offset=1)\n  inspect(dst, content=\"[0, 3, 4, 5, 0]\")\n}\n\n///|\ntest \"panic ArrayView::blit_to/invalid_offset\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4]\n  let dst = [0, 0, 0]\n  ignore(view.blit_to(dst, dst_offset=-1))\n}\n\n///|\ntest \"panic ArrayView::blit_to/offset_exceeds_length\" {\n  let src = [1, 2, 3, 4, 5]\n  let view = src[1:4]\n  let dst = [0, 0, 0]\n  ignore(view.blit_to(dst, dst_offset=4))\n}\n\n// test \"Array::blit_to - invalid cases\" {\n//   let src = [1, 2, 3, 4, 5]\n//   let dst = [0, 0, 0, 0, 0]\n\n//   // Invalid len\n//   Array::blit_to(src, dst, len=-1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // Invalid src_offset\n//   Array::blit_to(src, dst, len=2, src_offset=-1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // Invalid dst_offset\n//   Array::blit_to(src, dst, len=2, dst_offset=-1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // len exceeding src length\n//   Array::blit_to(src, dst, len=6)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n\n//   // len exceeding dst length\n//   Array::blit_to(src, dst, len=5, dst_offset=1)\n//   inspect(dst, content=\"[0, 0, 0, 0, 0]\")\n// }\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"@package:file:start_line:start_column-end_line:end_column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\nfn SourceLoc::repr(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  SourceLocRepr::parse(self.repr()).output(logger)\n}\n\n///|\npriv struct SourceLocRepr {\n  pkg : StringView\n  filename : StringView\n  start_line : StringView\n  start_column : StringView\n  end_line : StringView\n  end_column : StringView\n}\n\n///|\nimpl Show for SourceLocRepr with output(self, logger) {\n  let pkg = self.pkg\n  let (module_name, package_name) = lexmatch pkg {\n    ((\"[^/]*/[^/]*\" as module_name) \"/\" (\".*\" as package_name)) =>\n      (module_name, Some(package_name))\n    _ => (pkg, None)\n  }\n  if package_name is Some(pkg_name) {\n    logger..write_view(pkg_name)..write_char('/')\n  }\n  logger\n  ..write_view(self.filename)\n  ..write_char(':')\n  ..write_view(self.start_line)\n  ..write_char(':')\n  ..write_view(self.start_column)\n  ..write_char('-')\n  ..write_view(self.end_line)\n  ..write_char(':')\n  ..write_view(self.end_column)\n  ..write_char('@')\n  ..write_view(module_name)\n}\n\n///|\nfn SourceLocRepr::parse(repr : String) -> SourceLocRepr {\n  lexmatch repr[:] {\n    (\n      \"@\"\n      (\"[^:]*\" as pkg)\n      \":\"\n      (\".+?\" as filename)\n      \":\"\n      (\"[[:digit:]]+\" as start_line)\n      \":\"\n      (\"[[:digit:]]+\" as start_column)\n      \"-\"\n      (\"[[:digit:]]+\" as end_line)\n      \":\"\n      (\"[[:digit:]]+\" as end_column)\n    ) => { pkg, filename, start_line, start_column, end_line, end_column }\n    _ => panic()\n  }\n}\n\n///|\nfn SourceLocRepr::to_json_string(self : SourceLocRepr) -> String {\n  StringBuilder::new()\n  ..write_string(\"{\\\"pkg\\\":\\\"\\{self.pkg}\\\"\")\n  ..write_string(\",\\\"filename\\\":\")\n  ..write_object(self.filename)\n  ..write_string(\",\\\"start_line\\\":\\{self.start_line}\")\n  ..write_string(\",\\\"start_column\\\":\\{self.start_column}\")\n  ..write_string(\",\\\"end_line\\\":\\{self.end_line}\")\n  ..write_string(\",\\\"end_column\\\":\\{self.end_column}}\")\n  .to_string()\n}\n\n///|\n/// Convert a source location to a JSON string\npub fn SourceLoc::to_json_string(self : SourceLoc) -> String {\n  SourceLocRepr::parse(self.repr()).to_json_string()\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => buf.write_string(loc.to_json_string())\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts a boolean value to its integer representation.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to convert.\n///\n/// Returns 1 if the boolean is `true`, 0 if it is `false`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_int(), content=\"1\")\n///   inspect(false.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_int(self : Bool) -> Int {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to a 64-bit integer. Returns 1 for `true` and 0 for\n/// `false`.\n///\n/// Parameters:\n///\n/// * `bool` : The boolean value to be converted.\n///\n/// Returns a 64-bit integer representation of the boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_int64(), content=\"1\")\n///   inspect(false.to_int64(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_int64(self : Bool) -> Int64 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to an unsigned integer.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to be converted.\n///\n/// Returns an unsigned integer, where `true` is converted to 1 and `false` is\n/// converted to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_uint(), content=\"1\")\n///   inspect(false.to_uint(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_uint(self : Bool) -> UInt {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to an unsigned 64-bit integer. Returns 1 for `true`\n/// and 0 for `false`.\n///\n/// Parameters:\n///\n/// * `bool` : The boolean value to convert.\n///\n/// Returns an unsigned 64-bit integer representation of the boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_uint64(), content=\"1\")\n///   inspect(false.to_uint64(), content=\"0\")\n/// }\n/// ```\npub fn Bool::to_uint64(self : Bool) -> UInt64 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\npub impl Hash for Bool with hash_combine(self, hasher) {\n  hasher.combine_bool(self)\n}\n\n///|\n/// Converts a boolean value to an unsigned 16-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to be converted.\n///\n/// Returns an unsigned 16-bit integer, where `true` is converted to 1 and\n/// `false` is converted to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_uint16(), content=\"1\")\n///   inspect(false.to_uint16(), content=\"0\")\n/// }\n/// ```\n///\npub fn Bool::to_uint16(self : Bool) -> UInt16 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to a 16-bit integer representation.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to be converted.\n///\n/// Returns a 16-bit integer, where `true` is converted to 1 and `false` is\n/// converted to 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.to_int16(), content=\"1\")\n///   inspect(false.to_int16(), content=\"0\")\n/// }\n/// ```\n///\npub fn Bool::to_int16(self : Bool) -> Int16 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Reinterpret the byte sequence as Bytes.\n///\n/// Notice that this will make the `Bytes` object to be a view of the original\n/// byte sequence, so any modification to the original byte sequence will be\n/// reflected in the `Bytes` object.\n#internal(unsafe, \"Creating mutable Bytes\")\n#doc(hidden)\npub fn FixedArray::unsafe_reinterpret_as_bytes(\n  self : FixedArray[Byte],\n) -> Bytes = \"%identity\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized using a function that maps indices to bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. If `length` is less than or\n/// equal to 0, returns an empty byte sequence.\n/// * `value` : A function that takes an index (from 0 to `length - 1`) and\n/// returns a byte for that position.\n///\n/// Returns a new byte sequence containing the bytes produced by applying the\n/// value function to each index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::makei(3, i => (i + 65).to_byte())\n///   assert_eq(bytes, b\"ABC\")\n/// }\n/// ```\npub fn Bytes::makei(length : Int, value : (Int) -> Byte raise?) -> Bytes raise? {\n  if length <= 0 {\n    return []\n  }\n  let arr = FixedArray::make(length, value(0))\n  for i in 1..<length {\n    arr[i] = value(i)\n  }\n  FixedArray::unsafe_reinterpret_as_bytes(arr)\n}\n\n///|\n/// TODO: support local primitive declaration\n#owned(bytes)\nfn unsafe_sub_string(\n  bytes : Bytes,\n  byte_offset : Int,\n  byte_length : Int,\n) -> String = \"$moonbit.unsafe_bytes_sub_string\"\n\n///|\n/// Return an unchecked string, containing the subsequence of `self` that starts at\n/// `offset` and has length `length`. Both `offset` and `length`\n/// are indexed by byte.\n///\n/// Note this function does not validate the encoding of the byte sequence,\n/// it simply copy the bytes into a new String.\npub fn Bytes::to_unchecked_string(\n  self : Bytes,\n  offset? : Int = 0,\n  length? : Int,\n) -> String {\n  let len = self.length()\n  let length = if length is Some(l) { l } else { len - offset }\n  guard offset >= 0 && length >= 0 && offset + length <= len\n  unsafe_sub_string(self, offset, length)\n}\n\n///|\n/// Copies characters from a string to a byte sequence in UTF-16LE encoding. Each\n/// character is converted into two bytes, with the lower byte stored first.\n///\n/// Parameters:\n///\n/// * `self` : The destination byte array to copy the characters into.\n/// * `bytes_offset` : The starting position in the destination array where bytes\n/// will be written.\n/// * `str` : The source string containing the characters to copy.\n/// * `str_offset` : The starting position in the source string from which\n/// characters will be read.\n/// * `length` : The number of characters to copy.\n///\n/// Throws a runtime error if:\n///\n/// * `length` is negative\n/// * `bytes_offset` is negative\n/// * `str_offset` is negative\n/// * The range `[bytes_offset, bytes_offset + length * 2)` exceeds the length of\n/// the destination array\n/// * The range `[str_offset, str_offset + length)` exceeds the length of the\n/// source string\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = FixedArray::make(6, b'\\x00')\n///   bytes.blit_from_string(0, \"ABC\", 0, 3)\n///   @json.inspect(bytes, content=[65, 0, 66, 0, 67, 0]) // 'A'\n///   bytes.blit_from_string(0, \"\", 0, 3)\n///   @json.inspect(bytes, content=[96, 79, 125, 89, 74, 85]) // ''\n///   bytes.blit_from_string(0, \"\", 0, 2)\n///   @json.inspect(bytes, content=[61, 216, 8, 222, 74, 85]) // ''\n/// }\n/// ```\npub fn FixedArray::blit_from_string(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  str : String,\n  str_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = str_offset\n  let e1 = bytes_offset + length * 2 - 1\n  let e2 = str_offset + length - 1\n  let len1 = self.length()\n  let len2 = str.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  let end_str_offset = str_offset + length\n  for i = str_offset, j = bytes_offset; i < end_str_offset; i = i + 1, j = j + 2 {\n    let c = str.unsafe_charcode_at(i).reinterpret_as_uint()\n    self[j] = (c & 0xff).to_byte()\n    self[j + 1] = (c >> 8).to_byte()\n  }\n}\n\n///|\n/// TODO: specific copy\nfn unsafe_from_bytes(bytes : Bytes) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Copy `length` chars from byte sequence `src`, starting at `src_offset`,\n/// into byte sequence `self`, starting at `bytes_offset`.\npub fn FixedArray::blit_from_bytes(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : Bytes,\n  src_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = src_offset\n  let e1 = bytes_offset + length - 1\n  let e2 = src_offset + length - 1\n  let len1 = self.length()\n  let len2 = src.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  FixedArray::unsafe_blit(\n    self,\n    bytes_offset,\n    unsafe_from_bytes(src),\n    src_offset,\n    length,\n  )\n}\n\n///|\n/// Copy bytes from a BytesView into a fixed array of bytes.\n///\n/// Parameters:\n///\n/// * `self` : The destination fixed array of bytes.\n/// * `bytes_offset` : The starting position in the destination array where bytes will be copied.\n/// * `src` : The source View to copy from.\n///\n/// Throws a panic if:\n/// * `bytes_offset` is negative\n/// * The destination array is too small to hold all bytes from the source View\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(4, b'\\x00')\n///   let view = b\"\\x01\\x02\\x03\"[1:]\n///   arr.blit_from_bytesview(1, view)\n///   inspect(arr, content=\"[b'\\\\x00', b'\\\\x02', b'\\\\x03', b'\\\\x00']\")\n/// }\n/// ```\npub fn FixedArray::blit_from_bytesview(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : BytesView,\n) -> Unit {\n  FixedArray::blit_from_bytes(\n    self,\n    bytes_offset,\n    src.bytes(),\n    src.start(),\n    src.len(),\n  )\n}\n\n///|\n/// Encodes a Unicode character into UTF-8 bytes and writes them into a fixed\n/// array of bytes at the specified offset.\n///\n/// Parameters:\n///\n/// * `array` : The fixed array of bytes to write into.\n/// * `offset` : The starting position in the array where the encoded bytes will\n/// be written.\n/// * `char` : The Unicode character to be encoded.\n///\n/// Returns the number of bytes written (1 to 4 bytes depending on the\n/// character's code point).\n///\n/// Throws a panic if:\n///\n/// * The character's code point is greater than 0x10FFFF.\n/// ```mbt check\n/// test {\n///   let buf = FixedArray::make(4, b'\\x00')\n///   let written = buf.set_utf8_char(0, '') // Euro symbol (U+20AC)\n///   inspect(written, content=\"3\") // UTF-8 encoding takes 3 bytes\n///   inspect(buf[0], content=\"b'\\\\xE2'\")\n///   inspect(buf[1], content=\"b'\\\\x82'\")\n///   inspect(buf[2], content=\"b'\\\\xAC'\")\n/// }\n/// ```\npub fn FixedArray::set_utf8_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  match code {\n    _..<0x80 => {\n      self[offset] = ((code & 0x7F) | 0x00).to_byte()\n      1\n    }\n    _..<0x0800 => {\n      self[offset] = (((code >> 6) & 0x1F) | 0xC0).to_byte()\n      self[offset + 1] = ((code & 0x3F) | 0x80).to_byte()\n      2\n    }\n    _..<0x010000 => {\n      self[offset] = (((code >> 12) & 0x0F) | 0xE0).to_byte()\n      self[offset + 1] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = ((code & 0x3F) | 0x80).to_byte()\n      3\n    }\n    _..<0x110000 => {\n      self[offset] = (((code >> 18) & 0x07) | 0xF0).to_byte()\n      self[offset + 1] = (((code >> 12) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 3] = ((code & 0x3F) | 0x80).to_byte()\n      4\n    }\n    _ => abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16LE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16le_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code & 0xFF).to_byte()\n    self[offset + 1] = (code >> 8).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo & 0xFF).to_byte()\n    self[offset + 1] = (lo >> 8).to_byte()\n    self[offset + 2] = (hi & 0xFF).to_byte()\n    self[offset + 3] = (hi >> 8).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16BE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16be_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code >> 8).to_byte()\n    self[offset + 1] = (code & 0xFF).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo >> 8).to_byte()\n    self[offset + 1] = (lo & 0xFF).to_byte()\n    self[offset + 2] = (hi >> 8).to_byte()\n    self[offset + 3] = (hi & 0xFF).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Compares two byte sequences for equality. Returns true only if both sequences\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes1 = b\"\\x01\\x02\\x03\"\n///   let bytes2 = b\"\\x01\\x02\\x03\"\n///   let bytes3 = b\"\\x01\\x02\\x04\"\n///   inspect(bytes1 == bytes2, content=\"true\")\n///   inspect(bytes1 == bytes3, content=\"false\")\n/// }\n/// ```\npub impl Eq for Bytes with equal(self : Bytes, other : Bytes) -> Bool {\n  if self.length() != other.length() {\n    false\n  } else {\n    let len = self.length()\n    for i in 0..<len {\n      if self[i] != other[i] {\n        break false\n      }\n    } else {\n      true\n    }\n  }\n}\n\n///|\n/// Compares two byte sequences based on shortlex order. First compares the lengths of\n/// the sequences, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b\"\\x01\\x02\\x03\"\n///   let b = b\"\\x01\\x02\\x04\"\n///   inspect(a.compare(b), content=\"-1\") // a < b\n///   inspect(b.compare(a), content=\"1\") // b > a\n///   inspect(a.compare(a), content=\"0\") // a = a\n///   let a = b\"\\x01\\x02\"\n///   let b = b\"\\x01\\x02\\x03\"\n///   inspect(a.compare(b), content=\"-1\") // shorter sequence is less\n///   inspect(b.compare(a), content=\"1\") // longer sequence is greater\n/// }\n/// ```\npub impl Compare for Bytes with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  if cmp != 0 {\n    return cmp\n  }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    if cmp != 0 {\n      break cmp\n    }\n  } else {\n    0\n  }\n}\n\n///|\n/// Creates a new bytes sequence from a byte array.\n///\n/// Parameters:\n///\n/// * `array` : An array of bytes to be converted.\n///\n/// Returns a new bytes sequence containing the same bytes as the input array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [b'h', b'i']\n///   let bytes = Bytes::from_array(arr)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hi\"\n///     ),\n///   )\n/// }\n///\n/// test {\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::from_array(arr)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hello\"\n///     ),\n///   )\n/// }\n/// ```\n// TODO: marked as intrinsic, inline if it is constant\n#alias(of, deprecated)\npub fn Bytes::from_array(arr : ArrayView[Byte]) -> Bytes {\n  Bytes::makei(arr.length(), i => arr[i])\n}\n\n///|\n/// Creates a new bytes sequence from a fixed-size array of bytes with an\n/// optional length parameter.\n///\n/// Parameters:\n///\n/// * `array` : A fixed-size array of bytes to be converted into a bytes\n/// sequence.\n/// * `length` : (Optional) The length of the resulting bytes sequence. If not\n/// provided, uses the full length of the input array.\n///\n/// Returns a new bytes sequence containing the bytes from the input array. If a\n/// length is specified, only includes up to that many bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::from_array(arr[0:3])\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hel\"\n///     ),\n///   )\n/// }\n/// ```\n/// \n/// Panics if the length is invalid\n#deprecated(\"Use Bytes::from_array instead\")\npub fn Bytes::from_fixedarray(arr : FixedArray[Byte], len? : Int) -> Bytes {\n  let len = match len {\n    None => arr.length()\n    Some(x) => {\n      guard 0 <= x && x <= arr.length()\n      x\n    }\n  }\n  let result = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_to(result, len~)\n  result.unsafe_reinterpret_as_bytes()\n}\n\n///|\n/// Converts a bytes sequence into a fixed-size array of bytes. If an optional\n/// length is provided, the resulting array will have exactly that length,\n/// otherwise it will match the length of the input bytes.\n///\n/// Parameters:\n///\n/// * `self` : The bytes sequence to convert.\n/// * `len` : Optional. The desired length of the output array. If specified, the\n/// resulting array will have this length. If not specified, the length of the\n/// input bytes sequence will be used.\n///\n/// Returns a fixed-size array containing the bytes from the input sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"hello\"\n///   let arr = bytes.to_fixedarray()\n///   inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n///   let arr2 = bytes[:3].to_fixedarray()\n///   inspect(arr2, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C']\")\n/// }\n/// ```\n/// \n/// Panics if the length is invalid\n#label_migration(len, fill=false)\npub fn Bytes::to_fixedarray(self : Bytes, len? : Int) -> FixedArray[Byte] {\n  let len = match len {\n    None => self.length()\n    Some(x) => {\n      guard 0 <= x && x <= self.length()\n      x\n    }\n  }\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self, 0, len)\n  arr\n}\n\n///|\npub fn BytesView::to_fixedarray(self : BytesView) -> FixedArray[Byte] {\n  let len = self.length()\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self.data(), self.start_offset(), len)\n  arr\n}\n\n///|\n/// Creates a new bytes sequence from an iterator of bytes.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator that yields bytes.\n///\n/// Returns a new bytes sequence containing all the bytes from the iterator.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(b'h')\n///   let bytes = Bytes::from_iter(iter)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"h\"\n///     ),\n///   )\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn Bytes::from_iter(iter : Iter[Byte]) -> Bytes {\n  Bytes::from_array(iter.collect())\n}\n\n///|\n/// Converts a bytes sequence into an array of bytes.\n///\n/// Parameters:\n///\n/// * `bytes` : A sequence of bytes to be converted into an array.\n///\n/// Returns an array containing the same bytes as the input sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"hello\"\n///   let arr = bytes.to_array()\n///   inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n/// }\n/// ```\npub fn Bytes::to_array(self : Bytes) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\npub fn BytesView::to_array(self : BytesView) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\n/// Creates an iterator over the bytes in the sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : A byte sequence to iterate over.\n///\n/// Returns an iterator that yields each byte in the sequence in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::from_array([b'h', b'i'])\n///   let mut sum = 0\n///   bytes.iter().each(b => sum = sum + b.to_int())\n///   inspect(sum, content=\"209\") // ASCII values: 'h'(104) + 'i'(105) = 209\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn Bytes::iter(self : Bytes) -> Iter[Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let c = self.unsafe_get(i)\n    i += 1\n    Some(c)\n  })\n}\n\n///|\n/// Creates an iterator that yields tuples of index and byte,\n/// indices start from 0.\n/// \n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = StringBuilder::new(size_hint=5)\n///   let keys = []\n///   let it = b\"abcde\".iter2()\n///   while it.next() is Some((i, x)) {\n///     buf.write_string(x.to_string())\n///     keys.push(i)\n///   }\n///   inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n///   inspect(keys, content=\"[0, 1, 2, 3, 4]\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn Bytes::iter2(self : Bytes) -> Iter2[Int, Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let result = (i, self.unsafe_get(i))\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Creates a new empty bytes sequence.\n///\n/// Returns an empty bytes sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::default()\n///   inspect(bytes, content=\"b\\\"\\\"\")\n///   inspect(bytes.length(), content=\"0\")\n/// }\n/// ```\npub impl Default for Bytes with default() {\n  b\"\"\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index, or None if the index is out of bounds.\n///\n/// Example:\n/// \n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   let byte = bytes.get(1)\n///   inspect(byte, content=\"Some(b'\\\\x02')\")\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   let byte = bytes.get(3)\n///   inspect(byte, content=\"None\")\n/// }\n/// ```\npub fn Bytes::get(self : Bytes, index : Int) -> Byte? {\n  guard index >= 0 && index < self.length() else { None }\n  Some(self[index])\n}\n\n///|\nfn unsafe_to_fixedarray(array : UninitializedArray[Byte]) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Concatenates two bytes sequences.\n///\n/// Parameters:\n///\n/// * `self` : The first bytes sequence.\n/// * `other` : The second bytes sequence.\n/// TODO: marked as intrinsic, inline if it is constant\npub impl Add for Bytes with add(self : Bytes, other : Bytes) -> Bytes {\n  let len_self = self.length()\n  let len_other = other.length()\n  let rv : FixedArray[Byte] = FixedArray::make(len_self + len_other, 0)\n  for i in 0..<len_self {\n    rv[i] = self[i]\n  }\n  for i in 0..<len_other {\n    rv[len_self + i] = other[i]\n  }\n  unsafe_to_bytes(rv)\n}\n\n///|\npub impl Hash for Bytes with hash_combine(self, hasher) {\n  hasher.combine(self[:])\n}\n\n///|\n/// Returns a new `Bytes` consisting of `self` repeated `count` times.\n///\n/// If `count <= 0` or `self` is empty, an empty `Bytes` is returned. When\n/// `count == 1`, `self` is returned directly without allocation.\n///\n/// This implementation performs a single allocation sized exactly to the\n/// result and fills it using an exponential copy (doubling) strategy so the\n/// number of blit operations is O(log count).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\n///     b\"ab\".repeat(3),\n///     content=(\n///       #|b\"ababab\"\n///     ),\n///   )\n///   inspect(\n///     b\"xyz\".repeat(0),\n///     content=(\n///       #|b\"\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Bytes::repeat(self : Self, count : Int) -> Bytes {\n  if count <= 0 || self.length() == 0 {\n    return []\n  }\n  if count == 1 {\n    return self\n  }\n  let len = self.length()\n  let total = len * count\n  // (Optional) detect overflow: if multiplication wrapped (best-effort)\n  guard total / count == len\n  let arr = FixedArray::make(total, (0 : Byte))\n  arr.blit_from_bytes(0, self, 0, len)\n  let mut filled = len\n  while filled < total {\n    let remaining = total - filled\n    let copy_len = if filled < remaining { filled } else { remaining }\n    let src = unsafe_to_bytes(arr)\n    arr.blit_from_bytes(filled, src, 0, copy_len)\n    filled = filled + copy_len\n  }\n  unsafe_to_bytes(arr)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// #region FixedArray\n\n///|\n/// **UNSAFE**: Writes a UInt64 to the FixedArray[Byte] in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 7 < bytes.length()`\n/// - **Buffer overrun risk**: Writing beyond the array boundary may corrupt memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient space is available\n/// \n/// # Parameters\n/// - `bytes`: The FixedArray[Byte] to write to\n/// - `index`: Starting byte index (0-based)\n/// - `value`: The UInt64 value to write\n/// \n/// # Behavior\n/// Writes 8 bytes starting at `index` in little-endian order:\n/// - `bytes[index]`  bits 0-7 (least significant)\n/// - `bytes[index+1]`  bits 8-15\n/// - ...\n/// - `bytes[index+7]`  bits 56-63 (most significant)\n#intrinsic(\"%bytes.unsafe_write_uint64_le\")\npub fn FixedArray::unsafe_write_uint64_le(\n  bytes : FixedArray[Byte],\n  index : Int,\n  value : UInt64,\n) -> Unit {\n  for i in 0..=7 {\n    bytes.unsafe_set(i + index, (value >> (8 * i)).to_byte())\n  }\n}\n\n///|\n/// **UNSAFE**: Writes a UInt64 to the FixedArray[Byte] in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 7 < bytes.length()`\n/// - **Buffer overrun risk**: Writing beyond the array boundary may corrupt memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient space is available\n/// \n/// # Parameters\n/// - `bytes`: The FixedArray[Byte] to write to\n/// - `index`: Starting byte index (0-based)\n/// - `value`: The UInt64 value to write\n/// \n/// # Behavior\n/// Writes 8 bytes starting at `index` in big-endian order:\n/// - `bytes[index]`  bits 56-63 (most significant)\n/// - `bytes[index+1]`  bits 48-55\n/// - ...\n/// - `bytes[index+7]`  bits 0-7 (least significant)\n#intrinsic(\"%bytes.unsafe_write_uint64_be\")\npub fn FixedArray::unsafe_write_uint64_be(\n  bytes : FixedArray[Byte],\n  index : Int,\n  value : UInt64,\n) -> Unit {\n  for i in 0..=7 {\n    bytes.unsafe_set(i + index, (value >> (8 * (7 - i))).to_byte())\n  }\n}\n\n///|\n/// **UNSAFE**: Writes a UInt32 to the FixedArray[Byte] in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 3 < bytes.length()`\n/// - **Buffer overrun risk**: Writing beyond the array boundary may corrupt memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient space is available\n/// \n/// # Parameters\n/// - `bytes`: The FixedArray[Byte] to write to\n/// - `index`: Starting byte index (0-based)\n/// - `value`: The UInt32 value to write\n/// \n/// # Behavior\n/// Writes 4 bytes starting at `index` in little-endian order:\n/// - `bytes[index]`  bits 0-7 (least significant)\n/// - `bytes[index+1]`  bits 8-15\n/// - `bytes[index+2]`  bits 16-23\n/// - `bytes[index+3]`  bits 24-31 (most significant)\n#intrinsic(\"%bytes.unsafe_write_uint32_le\")\npub fn FixedArray::unsafe_write_uint32_le(\n  bytes : FixedArray[Byte],\n  index : Int,\n  value : UInt,\n) -> Unit {\n  for i in 0..=3 {\n    bytes.unsafe_set(i + index, (value >> (8 * i)).to_byte())\n  }\n}\n\n///|\n/// **UNSAFE**: Writes a UInt32 to the FixedArray[Byte] in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 3 < bytes.length()`\n/// - **Buffer overrun risk**: Writing beyond the array boundary may corrupt memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient space is available\n/// \n/// # Parameters\n/// - `bytes`: The FixedArray[Byte] to write to\n/// - `index`: Starting byte index (0-based)\n/// - `value`: The UInt32 value to write\n/// \n/// # Behavior\n/// Writes 4 bytes starting at `index` in big-endian order:\n/// - `bytes[index]`  bits 24-31 (most significant)\n/// - `bytes[index+1]`  bits 16-23\n/// - `bytes[index+2]`  bits 8-15\n/// - `bytes[index+3]`  bits 0-7 (least significant)\n#intrinsic(\"%bytes.unsafe_write_uint32_be\")\npub fn FixedArray::unsafe_write_uint32_be(\n  bytes : FixedArray[Byte],\n  index : Int,\n  value : UInt,\n) -> Unit {\n  for i in 0..=3 {\n    bytes.unsafe_set(i + index, (value >> (8 * (3 - i))).to_byte())\n  }\n}\n\n///|\n/// **UNSAFE**: Writes a UInt16 to the FixedArray[Byte] in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 1 < bytes.length()`\n/// - **Buffer overrun risk**: Writing beyond the array boundary may corrupt memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient space is available\n/// \n/// # Parameters\n/// - `bytes`: The FixedArray[Byte] to write to\n/// - `index`: Starting byte index (0-based)\n/// - `value`: The UInt16 value to write\n/// \n/// # Behavior\n/// Writes 2 bytes starting at `index` in little-endian order:\n/// - `bytes[index]`  bits 0-7 (least significant)\n/// - `bytes[index+1]`  bits 8-15 (most significant)\n#intrinsic(\"%bytes.unsafe_write_uint16_le\")\npub fn FixedArray::unsafe_write_uint16_le(\n  bytes : FixedArray[Byte],\n  index : Int,\n  value : UInt16,\n) -> Unit {\n  for i in 0..=1 {\n    bytes.unsafe_set(i + index, (value >> (8 * i)).to_byte())\n  }\n}\n\n///|\n/// **UNSAFE**: Writes a UInt16 to the FixedArray[Byte] in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 1 < bytes.length()`\n/// - **Buffer overrun risk**: Writing beyond the array boundary may corrupt memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient space is available\n/// \n/// # Parameters\n/// - `bytes`: The FixedArray[Byte] to write to\n/// - `index`: Starting byte index (0-based)\n/// - `value`: The UInt16 value to write\n/// \n/// # Behavior\n/// Writes 2 bytes starting at `index` in big-endian order:\n/// - `bytes[index]`  bits 8-15 (most significant)\n/// - `bytes[index+1]`  bits 0-7 (least significant)\n#intrinsic(\"%bytes.unsafe_write_uint16_be\")\npub fn FixedArray::unsafe_write_uint16_be(\n  bytes : FixedArray[Byte],\n  index : Int,\n  value : UInt16,\n) -> Unit {\n  for i in 0..=1 {\n    bytes.unsafe_set(i + index, (value >> (8 * (1 - i))).to_byte())\n  }\n}\n\n// #endregion\n// #region Bytes\n\n///|\n/// **UNSAFE**: Reads a UInt64 from the bytes in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 7 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the buffer boundary may access invalid memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient bytes are available\n/// \n/// # Parameters\n/// - `bytes`: The Bytes to read from\n/// - `index`: Starting byte index (0-based)\n/// \n/// # Behavior\n/// Reads 8 bytes starting at `index` and interprets them as a UInt64 in little-endian order:\n/// - `bytes[index]`  bits 0-7 (least significant)\n/// - `bytes[index+1]`  bits 8-15\n/// - ...\n/// - `bytes[index+7]`  bits 56-63 (most significant)\n#intrinsic(\"%bytes.unsafe_read_uint64_le\")\n#doc(hidden)\npub fn Bytes::unsafe_read_uint64_le(bytes : Bytes, index : Int) -> UInt64 {\n  let mut result : UInt64 = 0\n  for i in 0..=7 {\n    result = result | (bytes.unsafe_get(i + index).to_uint64() << (8 * i))\n  }\n  result\n}\n\n///|\n/// **UNSAFE**: Reads a UInt64 from the bytes in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 7 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the buffer boundary may access invalid memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient bytes are available\n/// \n/// # Parameters\n/// - `bytes`: The Bytes to read from\n/// - `index`: Starting byte index (0-based)\n/// \n/// # Behavior\n/// Reads 8 bytes starting at `index` and interprets them as a UInt64 in big-endian order:\n/// - `bytes[index]`  bits 56-63 (most significant)\n/// - `bytes[index+1]`  bits 48-55\n/// - ...\n/// - `bytes[index+7]`  bits 0-7 (least significant)\n#intrinsic(\"%bytes.unsafe_read_uint64_be\")\n#doc(hidden)\npub fn Bytes::unsafe_read_uint64_be(bytes : Bytes, index : Int) -> UInt64 {\n  let mut result : UInt64 = 0\n  for i in 0..=7 {\n    result = result | (bytes.unsafe_get(i + index).to_uint64() << (8 * (7 - i)))\n  }\n  result\n}\n\n///|\n/// **UNSAFE**: Reads a UInt32 from the bytes in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 3 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the buffer boundary may access invalid memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient bytes are available\n/// \n/// # Parameters\n/// - `bytes`: The Bytes to read from\n/// - `index`: Starting byte index (0-based)\n/// \n/// # Behavior\n/// Reads 4 bytes starting at `index` and interprets them as a UInt32 in little-endian order:\n/// - `bytes[index]`  bits 0-7 (least significant)\n/// - `bytes[index+1]`  bits 8-15\n/// - `bytes[index+2]`  bits 16-23\n/// - `bytes[index+3]`  bits 24-31 (most significant)\n#intrinsic(\"%bytes.unsafe_read_uint32_le\")\n#doc(hidden)\npub fn Bytes::unsafe_read_uint32_le(bytes : Bytes, index : Int) -> UInt {\n  let mut result : UInt = 0\n  for i in 0..=3 {\n    result = result | (bytes.unsafe_get(i + index).to_uint() << (8 * i))\n  }\n  result\n}\n\n///|\n/// **UNSAFE**: Reads a UInt32 from the bytes in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 3 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the buffer boundary may access invalid memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient bytes are available\n/// \n/// # Parameters\n/// - `bytes`: The Bytes to read from\n/// - `index`: Starting byte index (0-based)\n/// \n/// # Behavior\n/// Reads 4 bytes starting at `index` and interprets them as a UInt32 in big-endian order:\n/// - `bytes[index]`  bits 24-31 (most significant)\n/// - `bytes[index+1]`  bits 16-23\n/// - `bytes[index+2]`  bits 8-15\n/// - `bytes[index+3]`  bits 0-7 (least significant)\n#intrinsic(\"%bytes.unsafe_read_uint32_be\")\n#doc(hidden)\npub fn Bytes::unsafe_read_uint32_be(bytes : Bytes, index : Int) -> UInt {\n  let mut result : UInt = 0\n  for i in 0..=3 {\n    result = result | (bytes.unsafe_get(i + index).to_uint() << (8 * (3 - i)))\n  }\n  result\n}\n\n///|\n/// **UNSAFE**: Reads a UInt16 from the bytes in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 1 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the buffer boundary may access invalid memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient bytes are available\n/// \n/// # Parameters\n/// - `bytes`: The Bytes to read from\n/// - `index`: Starting byte index (0-based)\n/// \n/// # Behavior\n/// Reads 2 bytes starting at `index` and interprets them as a UInt16 in little-endian order:\n/// - `bytes[index]`  bits 0-7 (least significant)\n/// - `bytes[index+1]`  bits 8-15 (most significant)\n#intrinsic(\"%bytes.unsafe_read_uint16_le\")\n#doc(hidden)\npub fn Bytes::unsafe_read_uint16_le(bytes : Bytes, index : Int) -> UInt16 {\n  let mut result : UInt16 = 0\n  for i in 0..=1 {\n    result = result | (bytes.unsafe_get(i + index).to_uint16() << (8 * i))\n  }\n  result\n}\n\n///|\n/// **UNSAFE**: Reads a UInt16 from the bytes in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 1 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the buffer boundary may access invalid memory\n/// - **Alignment**: No alignment requirements, but misaligned access may be slower on some architectures\n/// - **Responsibility**: Caller must ensure sufficient bytes are available\n/// \n/// # Parameters\n/// - `bytes`: The Bytes to read from\n/// - `index`: Starting byte index (0-based)\n/// \n/// # Behavior\n/// Reads 2 bytes starting at `index` and interprets them as a UInt16 in big-endian order:\n/// - `bytes[index]`  bits 8-15 (most significant)\n/// - `bytes[index+1]`  bits 0-7 (least significant)\n#intrinsic(\"%bytes.unsafe_read_uint16_be\")\n#doc(hidden)\npub fn Bytes::unsafe_read_uint16_be(bytes : Bytes, index : Int) -> UInt16 {\n  let mut result : UInt16 = 0\n  for i in 0..=1 {\n    result = result | (bytes.unsafe_get(i + index).to_uint16() << (8 * (1 - i)))\n  }\n  result\n}\n\n///|\n/// **UNSAFE**: Reads a UInt64 from the BytesView in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 7 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the view boundary may access invalid memory\n/// - **Responsibility**: Caller must ensure sufficient bytes are available within the view\n/// \n/// # Parameters\n/// - `bytes`: The BytesView to read from\n/// - `index`: Relative index within the view (0-based)\n/// \n/// # Note\n/// This function delegates to `Bytes::unsafe_read_uint64_le` with the proper offset calculation.\n#doc(hidden)\npub fn BytesView::unsafe_read_uint64_le(\n  bytes : BytesView,\n  index : Int,\n) -> UInt64 {\n  bytes.bytes().unsafe_read_uint64_le(bytes.start() + index)\n}\n\n///|\n/// **UNSAFE**: Reads a UInt64 from the BytesView in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 7 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the view boundary may access invalid memory\n/// - **Responsibility**: Caller must ensure sufficient bytes are available within the view\n/// \n/// # Parameters\n/// - `bytes`: The BytesView to read from\n/// - `index`: Relative index within the view (0-based)\n/// \n/// # Note\n/// This function delegates to `Bytes::unsafe_read_uint64_be` with the proper offset calculation.\n#doc(hidden)\npub fn BytesView::unsafe_read_uint64_be(\n  bytes : BytesView,\n  index : Int,\n) -> UInt64 {\n  bytes.bytes().unsafe_read_uint64_be(bytes.start() + index)\n}\n\n///|\n/// **UNSAFE**: Reads a UInt32 from the BytesView in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 3 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the view boundary may access invalid memory\n/// - **Responsibility**: Caller must ensure sufficient bytes are available within the view\n/// \n/// # Parameters\n/// - `bytes`: The BytesView to read from\n/// - `index`: Relative index within the view (0-based)\n/// \n/// # Note\n/// This function delegates to `Bytes::unsafe_read_uint32_le` with the proper offset calculation.\n#doc(hidden)\npub fn BytesView::unsafe_read_uint32_le(bytes : BytesView, index : Int) -> UInt {\n  bytes.bytes().unsafe_read_uint32_le(bytes.start() + index)\n}\n\n///|\n/// **UNSAFE**: Reads a UInt32 from the BytesView in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 3 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the view boundary may access invalid memory\n/// - **Responsibility**: Caller must ensure sufficient bytes are available within the view\n/// \n/// # Parameters\n/// - `bytes`: The BytesView to read from\n/// - `index`: Relative index within the view (0-based)\n/// \n/// # Note\n/// This function delegates to `Bytes::unsafe_read_uint32_be` with the proper offset calculation.\n#doc(hidden)\npub fn BytesView::unsafe_read_uint32_be(bytes : BytesView, index : Int) -> UInt {\n  bytes.bytes().unsafe_read_uint32_be(bytes.start() + index)\n}\n\n///|\n/// **UNSAFE**: Reads a UInt16 from the BytesView in little-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 1 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the view boundary may access invalid memory\n/// - **Responsibility**: Caller must ensure sufficient bytes are available within the view\n/// \n/// # Parameters\n/// - `bytes`: The BytesView to read from\n/// - `index`: Relative index within the view (0-based)\n/// \n/// # Note\n/// This function delegates to `Bytes::unsafe_read_uint16_le` with the proper offset calculation.\n#doc(hidden)\npub fn BytesView::unsafe_read_uint16_le(\n  bytes : BytesView,\n  index : Int,\n) -> UInt16 {\n  bytes.bytes().unsafe_read_uint16_le(bytes.start() + index)\n}\n\n///|\n/// **UNSAFE**: Reads a UInt16 from the BytesView in big-endian byte order.\n/// \n///  **Warning: This function is unsafe and can cause undefined behavior!**\n/// \n/// # Safety\n/// - **No bounds checking**: This function does not verify that `index + 1 < bytes.length()`\n/// - **Buffer overrun risk**: Reading beyond the view boundary may access invalid memory\n/// - **Responsibility**: Caller must ensure sufficient bytes are available within the view\n/// \n/// # Parameters\n/// - `bytes`: The BytesView to read from\n/// - `index`: Relative index within the view (0-based)\n/// \n/// # Note\n/// This function delegates to `Bytes::unsafe_read_uint16_be` with the proper offset calculation.\n#doc(hidden)\npub fn BytesView::unsafe_read_uint16_be(\n  bytes : BytesView,\n  index : Int,\n) -> UInt16 {\n  bytes.bytes().unsafe_read_uint16_be(bytes.start() + index)\n}\n\n// #endregion\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Performs multiplication between two byte values. The result is truncated to\n/// fit within the byte range.\n///\n/// Parameters:\n///\n/// * `self` : The first byte operand in the multiplication.\n/// * `that` : The second byte operand in the multiplication.\n///\n/// Returns the product of the two bytes, truncated to fit within the byte range\n/// (0-255).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b'\\x02'\n///   let b = b'\\x03'\n///   inspect(a * b, content=\"b'\\\\x06'\") // 2 * 3 = 6\n///   let c = b'\\xFF'\n///   inspect(c * c, content=\"b'\\\\x01'\") // 255 * 255 = 65025, truncated to 1\n/// }\n/// ```\npub impl Mul for Byte with mul(self : Byte, that : Byte) -> Byte {\n  (self.to_int() * that.to_int()).to_byte()\n}\n\n///|\n/// Performs division operation between two bytes by converting them to integers,\n/// performing the division, and converting the result back to a byte.\n///\n/// Parameters:\n///\n/// * `self` : The dividend byte value.\n/// * `that` : The divisor byte value.\n///\n/// Returns the quotient of the division as a byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b'\\xFF' // 255\n///   let b = b'\\x03' // 3\n///   inspect(a / b, content=\"b'\\\\x55'\") // 255 / 3 = 85 (0x55)\n/// }\n/// ```\npub impl Div for Byte with div(self : Byte, that : Byte) -> Byte {\n  (self.to_int() / that.to_int()).to_byte()\n}\n\n///|\npub impl Mod for Byte with mod(self : Byte, that : Byte) -> Byte {\n  (self.to_int() % that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values for equality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are equal, otherwise `false`.\npub impl Eq for Byte with equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() == that.to_int()\n}\n\n///|\n/// Compares two `Byte` values for inequality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are not equal, otherwise `false`.\npub impl Eq for Byte with not_equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() != that.to_int()\n}\n\n///|\n/// Adds two `Byte` values together and returns the result as a `Byte`.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to be added.\n/// - `byte2` : The second `Byte` value to be added.\n///\n/// Returns the sum of `byte1` and `byte2` as a `Byte`.\npub impl Add for Byte with add(self : Byte, that : Byte) -> Byte {\n  (self.to_int() + that.to_int()).to_byte()\n}\n\n///|\n/// Subtracts the second byte from the first byte and returns the result as a\n/// byte.\n///\n/// Parameters:\n///\n/// - `self` : The byte from which the second byte will be subtracted.\n/// - `that` : The byte to subtract from the first byte.\n///\n/// Returns the result of the subtraction as a byte.\npub impl Sub for Byte with sub(self : Byte, that : Byte) -> Byte {\n  (self.to_int() - that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values and returns an integer indicating their relative\n/// order.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to compare.\n/// - `byte2` : The second `Byte` value to compare.\n///\n/// Returns an integer where:\n/// - A value less than 0 indicates that `byte1` is less than `byte2`.\n/// - A value of 0 indicates that `byte1` is equal to `byte2`.\n/// - A value greater than 0 indicates that `byte1` is greater than `byte2`.\npub impl Compare for Byte with compare(self : Byte, that : Byte) -> Int {\n  self.to_int().compare(that.to_int())\n}\n\n///|\npub impl Compare for Byte with op_lt(x, y) {\n  x.to_int() < y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_le(x, y) {\n  x.to_int() <= y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_gt(x, y) {\n  x.to_int() > y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_ge(x, y) {\n  x.to_int() >= y.to_int()\n}\n\n///|\nfn alphabet(x : Int) -> String {\n  match x {\n    0 => \"0\"\n    1 => \"1\"\n    2 => \"2\"\n    3 => \"3\"\n    4 => \"4\"\n    5 => \"5\"\n    6 => \"6\"\n    7 => \"7\"\n    8 => \"8\"\n    9 => \"9\"\n    10 => \"A\"\n    11 => \"B\"\n    12 => \"C\"\n    13 => \"D\"\n    14 => \"E\"\n    15 => \"F\"\n    _ => abort(\"impossible\")\n  }\n}\n\n///|\n/// Converts a `Byte` to its string representation in hexadecimal format.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns a `String` representing the `Byte` in the format `b'\\xHH'`, where\n/// `HH` is the hexadecimal representation of the byte.\npub fn Byte::to_string(self : Byte) -> String {\n  let i = self.to_int()\n  let hi = alphabet(i / 16)\n  let lo = alphabet(i % 16)\n  \"b'\\\\x\\{hi}\\{lo}'\"\n}\n\n///|\n/// Implements the `Hash` trait for `Byte` type by providing a `hash_combine`\n/// method that combines a byte value with a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The byte value to be hashed.\n/// * `hasher` : The hasher object that will be used to combine the byte value\n/// into its internal state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub impl Hash for Byte with hash_combine(self, hasher) {\n  hasher.combine_byte(self)\n}\n\n///|\n/// Returns the default value for a `Byte`, which is `b'\\x00'`.\n///\n/// Parameters:\n///\n/// - None\n///\n/// Returns the default `Byte` value, which is `b'\\x00'`.\npub impl Default for Byte with default() {\n  b'\\x00'\n}\n\n///|\n/// Performs a bitwise NOT operation on the given `Byte` value.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to apply the bitwise NOT operation on.\n///\n/// Returns the result of the bitwise NOT operation as a `Byte`.\npub fn Byte::lnot(self : Byte) -> Byte {\n  self.to_int().lnot().to_byte()\n}\n\n///|\n/// Performs a bitwise AND operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to perform the bitwise AND operation with.\n/// - `byte2` : The second `Byte` value to perform the bitwise AND operation\n///   with.\n///\n/// Returns the result of the bitwise AND operation as a `Byte`.\npub impl BitAnd for Byte with land(self : Byte, that : Byte) -> Byte {\n  (self.to_int() & that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise OR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns a new `Byte` value resulting from the bitwise OR operation.\npub impl BitOr for Byte with lor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() | that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise XOR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns the result of the bitwise XOR operation as a `Byte`.\npub impl BitXOr for Byte with lxor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() ^ that.to_int()).to_byte()\n}\n\n///|\n/// Converts a `Byte` to a `UInt`.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns the `UInt` representation of the `Byte`.\npub fn Byte::to_uint(self : Byte) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n/// Converts a byte value to an unsigned 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns an unsigned 64-bit integer representation of the byte value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_uint64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_uint64(self : Byte) -> UInt64 {\n  self.to_uint().to_uint64()\n}\n\n///|\n/// Counts the number of 1-bits (population count) in the byte using bitwise operations.\n///\n/// Parameters:\n///\n/// * `self` : The byte value whose 1-bits are to be counted.\n///\n/// Returns the number of 1-bits in the byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\x0F'\n///   inspect(b.popcnt(), content=\"4\")\n/// }\n/// ```\npub fn Byte::popcnt(self : Byte) -> Int {\n  let mut n = self\n  n = (n & 0x55) + ((n >> 1) & 0x55)\n  n = (n & 0x33) + ((n >> 2) & 0x33)\n  n = (n & 0x0F) + ((n >> 4) & 0x0F)\n  n.to_int()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the left by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the shift operation.\npub impl Shl for Byte with shl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the right by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value whose bits are to be shifted.\n/// - `count` : The number of bit positions to shift the `byte` value to the\n///   right.\n///\n/// Returns the resulting `Byte` value after the bitwise right shift operation.\npub impl Shr for Byte with shr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn BytesView::bytes(self : BytesView) -> Bytes = \"%bytesview.bytes\"\n\n///|\nfn BytesView::start(self : BytesView) -> Int = \"%bytesview.start\"\n\n///|\nfn BytesView::len(self : BytesView) -> Int = \"%bytesview.len\"\n\n///|\nfn BytesView::make(b : Bytes, start : Int, len : Int) -> BytesView = \"%bytesview.make\"\n\n///|\n/// Returns the number of bytes in the view.\n///\n/// Parameters:\n///\n/// * `bytes_view` : The view of a byte sequence.\n///\n/// Returns an integer representing the length of the view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x00\\x01\\x02\\x03\\x04\"\n///   let view = bytes[2:4]\n///   inspect(view.length(), content=\"2\")\n/// }\n/// ```\npub fn BytesView::length(self : BytesView) -> Int {\n  self.len()\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index if the index is valid.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[1:4] // view contains [0x02, 0x03, 0x04]\n///   inspect(view[1], content=\"b'\\\\x03'\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn BytesView::at(self : BytesView, index : Int) -> Byte {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  self.bytes()[self.start() + index]\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index, or None if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[1:4]\n///   let result = view.get(1)\n///   inspect(result, content=\"Some(b'\\\\x03')\")\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[1:4]\n///   let result = view.get(5)\n///   inspect(result, content=\"None\")\n/// }\n/// ```\npub fn BytesView::get(self : BytesView, index : Int) -> Byte? {\n  guard index >= 0 && index < self.length() else { None }\n  Some(self.bytes().unsafe_get(self.start() + index))\n}\n\n///|\n/// Retrieves a byte at the specified index from a bytes view without performing\n/// bounds checking.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte. The\n/// index is relative to the start of the view, not the underlying bytes.\n///\n/// Returns a single byte from the specified position in the view.\n///\n/// Throws a panic if the index is out of bounds (less than 0 or greater than or\n/// equal to the length of the view).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\"\n///   let view = bytes[2:4] // view contains [0x03, 0x04]\n///   inspect(view.unsafe_get(0), content=\"b'\\\\x03'\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn BytesView::unsafe_get(self : BytesView, index : Int) -> Byte {\n  self.bytes()[self.start() + index]\n}\n\n///|\n/// Creates a new `View` from the given `Bytes`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let bs = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"\n///   let bv = bs[1:4]\n///   inspect(bv.length(), content=\"3\")\n///   assert_eq(bv[0], b'\\x01')\n///   assert_eq(bv[1], b'\\x02')\n///   assert_eq(bv[2], b'\\x03')\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn Bytes::sub(self : Bytes, start? : Int = 0, end? : Int) -> BytesView {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"Invalid index for View\")\n  }\n  BytesView::make(self, start, end - start)\n}\n\n///|\n/// Creates a new `View` from the given `View`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let bv = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"[:]\n///   let bv2 = bv[1:4]\n///   inspect(bv2.length(), content=\"3\")\n///   assert_eq(bv2[1], b'\\x02')\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn BytesView::sub(\n  self : BytesView,\n  start? : Int = 0,\n  end? : Int,\n) -> BytesView {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"Invalid index for View\")\n  }\n  BytesView::make(self.bytes(), self.start() + start, end - start)\n}\n\n///|\n/// Returns an iterator over the `View`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let bv = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"[:]\n///   let mut sum = 0\n///   bv.iter().each(x => sum = sum + x.to_int())\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn BytesView::iter(self : BytesView) -> Iter[Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let result = self.unsafe_get(i)\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the `View` with index.\n/// \n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = StringBuilder::new(size_hint=5)\n///   let keys = []\n///   let it = b\"abcde\"[:].iter2()\n///   while it.next() is Some((i, x)) {\n///     buf.write_string(x.to_string())\n///     keys.push(i)\n///   }\n///   inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n///   inspect(keys, content=\"[0, 1, 2, 3, 4]\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn BytesView::iter2(self : BytesView) -> Iter2[Int, Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter2::new(fn() {\n    guard i < len else { None }\n    let result = (i, self.unsafe_get(i))\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Converts a 4-byte sequence to an unsigned 32-bit integer using big-endian\n/// byte order. The first byte is treated as the most significant byte, and the\n/// last byte as the least significant byte.\n///\n/// Parameters:\n///\n/// * `self` : A byte view containing exactly 4 bytes to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x12\\x34\\x56\\x78\"\n///   guard bytes is [u32be(x), ..]\n///   inspect(x, content=\"305419896\") // 0x12345678\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint_be(self : BytesView) -> UInt {\n  (self[0].to_uint() << 24) +\n  (self[1].to_uint() << 16) +\n  (self[2].to_uint() << 8) +\n  self[3].to_uint()\n}\n\n///|\n/// Converts a sequence of 4 bytes into an unsigned 32-bit integer using\n/// little-endian byte order. Each byte in the view contributes 8 bits to the\n/// final integer, with the least significant byte at index 0.\n///\n/// Parameters:\n///\n/// * `view` : A `View` containing exactly 4 bytes to be interpreted as a\n/// little-endian unsigned integer.\n///\n/// Returns an unsigned 32-bit integer (`UInt`) formed by interpreting the bytes\n/// in little-endian order.\n///\n/// Throws a panic if the view does not contain exactly 4 bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\"\n///   guard bytes is [u32le(x), ..]\n///   inspect(x, content=\"67305985\") // 0x04030201\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint_le(self : BytesView) -> UInt {\n  self[0].to_uint() +\n  (self[1].to_uint() << 8) +\n  (self[2].to_uint() << 16) +\n  (self[3].to_uint() << 24)\n}\n\n///|\n/// Converts a sequence of 8 bytes into a 64-bit unsigned integer using\n/// big-endian byte order. The most significant byte is at index 0, and the least\n/// significant byte is at index 7.\n///\n/// Parameters:\n///\n/// * `bytes` : A view into a byte sequence that must be at least 8 bytes long.\n/// The bytes are interpreted in big-endian order, where the first byte is the\n/// most significant byte.\n///\n/// Returns a 64-bit unsigned integer constructed by concatenating the bytes in\n/// big-endian order.\n///\n/// Throws a runtime error if the byte sequence view is less than 8 bytes long or\n/// if attempting to access an index beyond the view's bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\"\n///   guard bytes is [u64be(x), ..]\n///   inspect(x, content=\"81985529216486895\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint64_be(self : BytesView) -> UInt64 {\n  (self[0].to_uint().to_uint64() << 56) +\n  (self[1].to_uint().to_uint64() << 48) +\n  (self[2].to_uint().to_uint64() << 40) +\n  (self[3].to_uint().to_uint64() << 32) +\n  (self[4].to_uint().to_uint64() << 24) +\n  (self[5].to_uint().to_uint64() << 16) +\n  (self[6].to_uint().to_uint64() << 8) +\n  self[7].to_uint().to_uint64()\n}\n\n///|\n/// Converts an 8-byte sequence to an unsigned 64-bit integer using little-endian\n/// byte order. Each byte in the view is treated as an 8-bit unsigned integer and\n/// combined to form the final 64-bit value, with the least significant byte\n/// first.\n///\n/// Parameters:\n///\n/// * `bytes_view` : A view into a byte sequence that must be exactly 8 bytes\n/// long. Each byte represents one byte of the resulting 64-bit integer, with the\n/// first byte being the least significant.\n///\n/// Returns an unsigned 64-bit integer assembled from the bytes in little-endian\n/// order.\n///\n/// Throws a panic if the View is less than 8 bytes long or if trying to\n/// access a byte beyond the view's bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n///   guard bytes is [u64le(x), ..]\n///   inspect(x, content=\"578437695752307201\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_uint64_le(self : BytesView) -> UInt64 {\n  self[0].to_uint().to_uint64() +\n  (self[1].to_uint().to_uint64() << 8) +\n  (self[2].to_uint().to_uint64() << 16) +\n  (self[3].to_uint().to_uint64() << 24) +\n  (self[4].to_uint().to_uint64() << 32) +\n  (self[5].to_uint().to_uint64() << 40) +\n  (self[6].to_uint().to_uint64() << 48) +\n  (self[7].to_uint().to_uint64() << 56)\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int_be(self : BytesView) -> Int {\n  guard self is [u32be(u32), ..]\n  u32.reinterpret_as_int()\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int_le(self : BytesView) -> Int {\n  guard self is [u32le(u32), ..]\n  u32.reinterpret_as_int()\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int64_be(self : BytesView) -> Int64 {\n  guard self is [u64be(u64), ..]\n  u64.reinterpret_as_int64()\n}\n\n///|\n#deprecated\n#doc(hidden)\npub fn BytesView::to_int64_le(self : BytesView) -> Int64 {\n  guard self is [u64le(u64), ..]\n  u64.reinterpret_as_int64()\n}\n\n///|\n/// Converts the bytes in a byte view to a double-precision floating-point number\n/// using big-endian byte order. The byte view must contain exactly 8 bytes,\n/// which represent the IEEE 754 double-precision format.\n///\n/// Parameters:\n///\n/// * `byte_view` : The byte view containing exactly 8 bytes to be interpreted as\n/// a double-precision floating-point number in big-endian order.\n///\n/// Returns a double-precision floating-point number reconstructed from the\n/// bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   // Bytes representing 1.0 in IEEE 754 double-precision format (big-endian)\n///   let bytes = b\"\\x3F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n///   guard bytes is [u64be(bits), ..]\n///   inspect(bits.reinterpret_as_double(), content=\"1\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_double_be(self : BytesView) -> Double {\n  guard self is [u64be(u64), ..]\n  u64.reinterpret_as_double()\n}\n\n///|\n/// Converts the bytes in the view to a double-precision floating-point number\n/// using little-endian byte order. Interprets the first 8 bytes as a IEEE 754\n/// double-precision binary floating-point format (binary64) value.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte view to be converted. Must contain at least 8 bytes.\n///\n/// Returns a `Double` value representing the bytes interpreted in little-endian\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x3F\" // represents 1.0 in little-endian\n///   guard bytes is [u64le(bits), ..]\n///   inspect(bits.reinterpret_as_double(), content=\"1\")\n/// }\n/// ```\n#deprecated(\"Use bits pattern directly\")\n#doc(hidden)\npub fn BytesView::to_double_le(self : BytesView) -> Double {\n  guard self is [u64le(u64), ..]\n  u64.reinterpret_as_double()\n}\n\n///|\npub impl Show for BytesView with output(self, logger) {\n  logger.write_string(\"b\\\"\")\n  for byte in self {\n    if byte is (' '..='~') && byte != '\"' && byte != '\\\\' {\n      logger.write_char(byte.to_char())\n    } else {\n      logger..write_string(\"\\\\x\")..write_string(byte.to_hex())\n    }\n  }\n  logger.write_string(\"\\\"\")\n}\n\n///|\npub impl Show for Bytes with output(self, logger) {\n  BytesView::output(self[:], logger)\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first view to compare.\n/// * `other` : The second view to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   let bytes = b\"abcabc\"\n///   inspect(bytes[0:3] == bytes[3:6], content=\"true\")\n///   inspect(bytes[0:3] == bytes[2:5], content=\"false\")\n///   inspect(bytes[0:4] == bytes[3:6], content=\"false\")\n/// }\n/// ```\npub impl Eq for BytesView with equal(self, other) -> Bool {\n  guard self.length() == other.length() else { return false }\n  for i in 0..<self.length() {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { return false }\n  }\n  true\n}\n\n///|\n/// Compares two views based on shortlex order. First compares the lengths of\n/// the views, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first view to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"abcabc\"\n///   inspect(bytes[0:3].compare(bytes[3:6]), content=\"0\") // abc = abc\n///   inspect(bytes[0:3].compare(bytes[2:5]), content=\"-1\") // abc < cab\n///   inspect(bytes[1:4].compare(bytes[3:6]), content=\"1\") // bca > abc\n///   inspect(bytes[0:3].compare(bytes[0:4]), content=\"-1\") // abc < abca\n///   inspect(bytes[1:5].compare(bytes[2:5]), content=\"1\") // bcab > cab\n/// }\n/// ```\npub impl Compare for BytesView with compare(self, other) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Retrieves the underlying `Bytes` from a `View`.\npub fn BytesView::data(self : BytesView) -> Bytes {\n  self.bytes()\n}\n\n///|\n/// Retrieves the start index of the view.\npub fn BytesView::start_offset(self : BytesView) -> Int {\n  self.start()\n}\n\n///|\npub fn BytesView::to_bytes(self : BytesView) -> Bytes {\n  if self.length() == self.bytes().length() {\n    // If the view covers the entire bytes, return the original bytes to avoid copying\n    return self.bytes()\n  }\n  let bytes = FixedArray::make(self.length(), (0 : Byte))\n  bytes.blit_from_bytes(0, self.bytes(), self.start_offset(), self.length())\n  unsafe_to_bytes(bytes)\n}\n\n///|\npub impl ToJson for BytesView with to_json(self) -> Json {\n  let sb = StringBuilder::new()\n  for byte in self {\n    if byte is (' '..='~') && byte != '\"' && byte != '\\\\' {\n      sb.write_char(byte.to_char())\n    } else {\n      sb..write_string(\"\\\\x\")..write_string(byte.to_hex())\n    }\n  }\n  Json::string(sb.to_string())\n}\n\n///|\n/// Converts a `Bytes` value to a JSON representation.\n/// The representation is picked for easier debugging.\n/// Printable ASCII characters (from space to tilde, excluding '\"' and '\\') are output as-is.\n/// All other bytes are represented as \\xHH, where HH is the two-digit hexadecimal value of the byte.\npub impl ToJson for Bytes with to_json(self : Bytes) -> Json {\n  BytesView::to_json(self[:])\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   if false {\n///     println(42)\n///     println(\"Hello, World!\")\n///     println([1, 2, 3])\n///   }\n/// }\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = 42\n///   inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// }\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"a\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"aa\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42, content=\"42\")\n///   inspect(\"hello\", content=\"hello\")\n///   inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// }\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content? : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_json_string()\n    let args_loc = args_loc.to_json()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n///   match err {\n///     SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n///   }\n/// }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T : Show] debug_string(t : T) -> String {\n  let buf = StringBuilder::new(size_hint=50)\n  t.output(buf)\n  buf.to_string()\n}\n\n///|\n/// Asserts that two values are equal. If they are not equal, raises a failure\n/// with a message containing the source location and the values being compared.\n///\n/// Parameters:\n///\n/// * `a` : First value to compare.\n/// * `b` : Second value to compare.\n/// * `loc` : Source location information to include in failure messages. This is\n/// usually automatically provided by the compiler.\n///\n/// Throws a `Failure` error if the values are not equal, with a message showing\n/// the location of the failing assertion and the actual values that were\n/// compared.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_eq(1, 1)\n///   assert_eq(\"hello\", \"hello\")\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if a != b {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} != \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that two values of the same type are not equal. If the values are\n/// equal, raises a failure with a detailed error message including the source\n/// location and string representation of both values.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `location` : Source location information for error reporting. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error if the values are equal. The error message includes\n/// the source location and string representations of both values.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_not_eq(1, 2) // Passes\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_not_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if !(a != b) {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} == \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that the given boolean value is true. Throws an error with source\n/// location information if the assertion fails.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean value to be checked.\n/// * `location` : The source location where the assertion is made. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error with a descriptive message including the source\n/// location if the condition is false.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(true)\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_true(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if !x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not true\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Tests whether a boolean condition is false, throwing an error if the\n/// condition is true.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean condition to test.\n/// * `location` : The source location where the assertion is made. Used in error\n/// messages.\n///\n/// Throws a `Failure` error if the condition is true. The error message includes\n/// the source location and the value that was expected to be false.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_false(false)\n///   assert_false(1 > 2)\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_false(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not false\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let h1 = Hasher::new(seed=0) // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// }\n/// ```\npub fn Hasher::new(seed? : Int = seed) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n#cfg(not(target=\"js\"))\nlet seed : Int = 0\n\n///|\n#cfg(target=\"js\")\nlet seed : Int = random_seed()\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn random_seed() -> Int =\n  #|() => {\n  #|  if (globalThis.crypto?.getRandomValues) {\n  #|    const array = new Uint32Array(1);\n  #|    globalThis.crypto.getRandomValues(array);\n  #|    return array[0] | 0; // Convert to signed 32\n  #|  } else {\n  #|    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random\n  #|  }\n  #|}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// }\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// }\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// }\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(3.14F)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// }\n/// ```\n#deprecated\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\nfn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// }\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// }\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// }\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// }\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\npub impl Hash for StringView with hash_combine(\n  self : StringView,\n  hasher : Hasher,\n) -> Unit {\n  let str = self.str()\n  for i in self.start()..<self.end() {\n    hasher.combine_uint(str.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new(seed=0)\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// }\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// }\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\npub impl Hash for BytesView with hash_combine(self : BytesView, hasher : Hasher) {\n  let mut start = self.start()\n  let data = self.bytes()\n  let mut rest = self.len()\n  while rest >= 4 {\n    let mut result : UInt = 0\n    for i in 0..=3 {\n      result = result | (data.unsafe_get(i + start).to_uint() << (8 * i))\n    }\n    hasher.combine_uint(result)\n    rest -= 4\n    start += 4\n  }\n  while rest >= 1 {\n    hasher.combine_byte(data.unsafe_get(start))\n    rest -= 1\n    start += 1\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 42\n///   ignore(x) // Explicitly ignore the value\n///   let mut sum = 0\n///   ignore([1, 2, 3].iter().each(x => sum = sum + x)) // Ignore the Unit return value of each()\n/// }\n/// ```\npub fn[T] ignore(t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = arr1\n///   let arr3 = [1, 2, 3]\n///   inspect(physical_equal(arr1, arr2), content=\"true\") // Same object\n///   inspect(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// }\n/// ```\npub fn[T] physical_equal(a : T, b : T) -> Bool = \"%refeq\"\n\n///|\n#callsite(autofill(loc))\npub fn[T] abort(string : String, loc~ : SourceLoc) -> T {\n  @abort.abort(\n    (\n      $|\\{string}\n      $|  at \\{loc}\n      $|\n    ),\n  )\n}\n\n///|\npub fn[T] panic() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(not(true), content=\"false\")\n///   inspect(not(false), content=\"true\")\n/// }\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true == true, content=\"true\")\n///   inspect(false == true, content=\"false\")\n///   inspect(true == false, content=\"false\")\n///   inspect(false == false, content=\"true\")\n/// }\n/// ```\npub impl Eq for Bool with equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let t = true\n///   let f = false\n///   // This usage is deprecated, use compare() instead\n///   inspect(t.compare(f), content=\"1\")\n///   inspect(f.compare(t), content=\"-1\")\n///   inspect(t.compare(t), content=\"0\")\n/// }\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.compare(false), content=\"1\") // true > false\n///   inspect(false.compare(true), content=\"-1\") // false < true\n///   inspect(true.compare(true), content=\"0\") // true = true\n/// }\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b : Bool = Bool::default()\n///   inspect(b, content=\"false\")\n/// }\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42, content=\"-42\")\n///   inspect(42, content=\"42\")\n///   inspect(2147483647, content=\"2147483647\") // negating near min value\n/// }\n/// ```\npub impl Neg for Int with neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 + 1, content=\"43\")\n///   inspect(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// }\n/// ```\npub impl Add for Int with add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 10\n///   inspect(a - b, content=\"32\")\n///   let max = 2147483647 // Int maximum value\n///   inspect(max - -1, content=\"-2147483648\") // Overflow case\n/// }\n/// ```\npub impl Sub for Int with sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 * 2, content=\"84\")\n///   inspect(-10 * 3, content=\"-30\")\n///   let max = 2147483647 // Int.max_value\n///   inspect(max * 2, content=\"-2\") // Overflow wraps around\n/// }\n/// ```\npub impl Mul for Int with mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(10 / 3, content=\"3\") // truncates towards zero\n///   inspect(-10 / 3, content=\"-3\")\n///   inspect(10 / -3, content=\"-3\")\n/// }\n/// ```\npub impl Div for Int with div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(7 % 3, content=\"1\")\n///   inspect(-7 % 3, content=\"-1\")\n///   inspect(7 % -3, content=\"1\")\n/// }\n/// ```\npub impl Mod for Int with mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = -1 // All bits are 1\n///   let b = 0 // All bits are 0\n///   inspect(a.lnot(), content=\"0\")\n///   inspect(b.lnot(), content=\"-1\")\n/// }\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0 // 11110000\n///   let y = 0xAA // 10101010\n///   inspect(x & y, content=\"160\") // 10100000 = 160\n/// }\n/// ```\npub impl BitAnd for Int with land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// }\n/// ```\npub impl BitOr for Int with lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n///   inspect(x ^ x, content=\"0\") // XOR with self gives 0\n/// }\n/// ```\npub impl BitXOr for Int with lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = -4\n///   inspect(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// }\n/// ```\npub impl Shl for Int with shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -16\n///   inspect(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n///   let p = 16\n///   inspect(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// }\n/// ```\npub impl Shr for Int with shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 42\n///   inspect(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Equivalent to x << 3\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -4 // Binary: 11111...11100\n///   let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n///   inspect(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -16\n///   inspect(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -1024\n///   inspect(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0\n///   inspect(x.ctz(), content=\"32\") // All bits are zero\n///   let y = 1\n///   inspect(y.ctz(), content=\"0\") // No trailing zeros\n///   let z = 16\n///   inspect(z.ctz(), content=\"4\") // Binary: ...10000\n/// }\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0b1011 // Binary: 1011 (3 bits set)\n///   inspect(x.popcnt(), content=\"3\")\n///   let y = -1 // All bits set in two's complement\n///   inspect(y.popcnt(), content=\"32\")\n/// }\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 == 42, content=\"true\")\n///   inspect(42 == -42, content=\"false\")\n/// }\n/// ```\npub impl Eq for Int with equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 != 42, content=\"false\")\n///   inspect(42 != -42, content=\"true\")\n/// }\n/// ```\npub impl Eq for Int with not_equal(self : Int, other : Int) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 24\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub impl Compare for Int with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Int with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Int with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Int with op_ge(x, y) = \"%i32.ge\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let neg = -42\n///   let zero = 0\n///   let pos = 42\n///   inspect(neg.is_neg(), content=\"true\")\n///   inspect(zero.is_neg(), content=\"false\")\n///   inspect(pos.is_neg(), content=\"false\")\n/// }\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = Int::default()\n///   inspect(x, content=\"0\")\n/// }\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_double(), content=\"42\")\n///   let neg = -42\n///   inspect(neg.to_double(), content=\"-42\")\n/// }\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(UInt::trunc_double(42.75), content=\"42\")\n/// }\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   let neg = -1\n///   inspect(pos.reinterpret_as_uint(), content=\"42\")\n///   inspect(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   inspect(pos.to_uint64(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// }\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42.0, content=\"-42\")\n///   inspect(42.0, content=\"42\")\n///   inspect(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// }\n/// ```\npub impl Neg for Double with neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding + and -, returns NaN\n/// * If adding  with any finite number, returns \n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 + 3.7, content=\"6.2\")\n///   inspect(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// }\n/// ```\npub impl Add for Double with add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5.0\n///   let b = 3.0\n///   inspect(a - b, content=\"2\")\n///   inspect(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// }\n/// ```\npub impl Sub for Double with sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 * 2.0, content=\"5\")\n///   inspect(-2.0 * 3.0, content=\"-6\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan * 1.0, content=\"NaN\")\n/// }\n/// ```\npub impl Mul for Double with mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(6.0 / 2.0, content=\"3\")\n///   inspect(-6.0 / 2.0, content=\"-3\")\n///   inspect(1.0 / 0.0, content=\"Infinity\")\n/// }\n/// ```\npub impl Div for Double with div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(4.0.sqrt(), content=\"2\")\n///   inspect(0.0.sqrt(), content=\"0\")\n///   inspect((-1.0).sqrt(), content=\"NaN\")\n/// }\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan == nan, content=\"false\") // NaN != NaN\n/// }\n/// ```\npub impl Eq for Double with equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n/// Compares two double-precision floating-point numbers for inequality following\n/// IEEE 754 rules. Returns `true` if the numbers are not equal.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if the numbers are not equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan != nan, content=\"true\") // NaN != NaN is true\n/// }\n/// ```\npub impl Eq for Double with not_equal(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\npub impl Compare for Double with op_lt(x, y) = \"%f64.lt\"\n\n///|\npub impl Compare for Double with op_le(x, y) = \"%f64.le\"\n\n///|\npub impl Compare for Double with op_gt(x, y) = \"%f64.gt\"\n\n///|\npub impl Compare for Double with op_ge(x, y) = \"%f64.ge\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Double::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(Double::convert_uint(n), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(Double::convert_uint(max), content=\"4294967295\")\n/// }\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('A'.to_int(), content=\"65\") // ASCII value of 'A'\n///   inspect(''.to_int(), content=\"12354\") // Unicode code point of ''\n/// }\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let c = 'A'\n///   inspect(c.to_uint(), content=\"65\") // ASCII value of 'A'\n///   let emoji = ''\n///   inspect(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// }\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n#deprecated(\"Use `Int::unsafe_to_char` instead, and use `Int::to_char` for safe conversion\")\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for Char with equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if the characters represent different Unicode code points,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for Char with not_equal(self : Char, other : Char) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('a'.compare('b'), content=\"-1\")\n///   inspect('b'.compare('a'), content=\"1\")\n///   inspect('a'.compare('a'), content=\"0\")\n/// }\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\npub impl Compare for Char with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Char with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Char with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Char with op_ge(x, y) = \"%i32.ge\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(Char::default().to_string() == \"\\u0000\")\n/// }\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes[1], content=\"b'\\\\x02'\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn Bytes::at(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes.unsafe_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.length(), content=\"3\")\n///   let empty = b\"\"\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::make(3, b'\\xFF')\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"\\xff\\xff\\xff\"\n///     ),\n///   )\n///   let empty = Bytes::make(0, b'\\x00')\n///   inspect(empty, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::new(3)\n///   inspect(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n///   let bytes = Bytes::new(0)\n///   inspect(bytes, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258 // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let neg = -1 // In binary: all 1's\n///   inspect(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\npub fn Int::unsafe_to_char(self : Int) -> Char = \"%char_from_int\"\n\n///|\npub fn Int::to_char(self : Int) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..=0x10FFFF) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258UL // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// }\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Panics if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] FixedArray::at(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.unsafe_get(1), content=\"42\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_set(\n  self : FixedArray[T],\n  idx : Int,\n  val : T,\n) -> Unit = \"%fixedarray.unsafe_set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 0)\n///   arr.set(1, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[T] FixedArray::set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn[T] FixedArray::length(self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[0], content=\"42\")\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\n/// \n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the FixedArray[Int] in this case). \n/// One should use makei() instead which creates an object for each index.\npub fn[T] FixedArray::make(len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello\".length(), content=\"5\")\n///   inspect(\"\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n///   inspect(\"\".length(), content=\"0\") // Empty string\n/// }\n/// ```\n#alias(charcode_length, deprecated)\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n///\n/// Parameters:\n///\n/// * `string` : The string to access.\n/// * `index` : The position in the string from which to retrieve the code unit.\n///\n/// This method has O(1) complexity.\n#deprecated(\"Use `_[_]` instead which returns UInt16\")\npub fn String::charcode_at(self : String, idx : Int) -> Int = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn String::at(self : String, idx : Int) -> UInt16 = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str = \"BC\"\n///   inspect(str.unsafe_charcode_at(0), content=\"66\") // 'B'\n///   inspect(str.unsafe_charcode_at(1), content=\"55358\") // First surrogate of \n///   inspect(str.unsafe_charcode_at(2), content=\"56611\") // Second surrogate of \n///   inspect(str.unsafe_charcode_at(3), content=\"55358\") // First surrogate of \n///   inspect(str.unsafe_charcode_at(4), content=\"56611\") // Second surrogate of \n///   inspect(str.unsafe_charcode_at(5), content=\"67\") // 'C'\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\n#internal(unsafe, \"Panic if index is out of bounds.\")\n#doc(hidden)\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hello = \"Hello\"\n///   let world = \" World!\"\n///   inspect(hello + world, content=\"Hello World!\")\n///   inspect(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// }\n/// ```\npub impl Add for String with add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str1 = \"hello\"\n///   let str2 = \"hello\"\n///   let str3 = \"world\"\n///   inspect(str1 == str2, content=\"true\")\n///   inspect(str1 == str3, content=\"false\")\n/// }\n/// ```\npub impl Eq for String with equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s = \"hello\"\n///   inspect(s.to_string(), content=\"hello\")\n/// }\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n// For internal use only\n\n///|\npriv type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_int(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a character.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns the character corresponding to the byte value.\npub fn Byte::to_char(self : Byte) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_int64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   inspect(a.reinterpret_as_int(), content=\"42\")\n///   let b = 4294967295U // maximum value of UInt (2^32 - 1)\n///   inspect(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 100U\n///   inspect(a + b, content=\"142\")\n///\n///   // Demonstrate overflow behavior\n///   let max = 4294967295U // UInt::max_value\n///   inspect(max + 1U, content=\"0\")\n/// }\n/// ```\npub impl Add for UInt with add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5U\n///   let b = 3U\n///   inspect(a - b, content=\"2\")\n///   let c = 3U\n///   let d = 5U\n///   inspect(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// }\n/// ```\npub impl Sub for UInt with sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3U\n///   let b = 4U\n///   inspect(a * b, content=\"12\")\n///   let max = 4294967295U\n///   inspect(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// }\n/// ```\npub impl Mul for UInt with mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 5U\n///   inspect(a / b, content=\"8\") // Using infix operator\n/// }\n/// ```\npub impl Div for UInt with div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 17U\n///   let b = 5U\n///   inspect(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n///   inspect(7U % 4U, content=\"3\")\n/// }\n/// ```\npub impl Mod for UInt with mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for UInt with equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n/// Compares two unsigned 32-bit integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for UInt with not_equal(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 24U\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\npub impl Compare for UInt with op_lt(x, y) = \"%u32.lt\"\n\n///|\npub impl Compare for UInt with op_le(x, y) = \"%u32.le\"\n\n///|\npub impl Compare for UInt with op_gt(x, y) = \"%u32.gt\"\n\n///|\npub impl Compare for UInt with op_ge(x, y) = \"%u32.ge\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // 1111_0000_1111_0000\n///   let b = 0xFF00U // 1111_1111_0000_0000\n///   inspect(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// }\n/// ```\npub impl BitAnd for UInt with land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// }\n/// ```\npub impl BitOr for UInt with lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xFF00U // Binary: 1111_1111_0000_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// }\n/// ```\npub impl BitXOr for UInt with lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF00U // Binary: 1111_1111_0000_0000\n///   inspect(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// }\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Using the recommended operator\n///   let y = 8U\n///   inspect(y << 1, content=\"16\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0000000U\n///   inspect(x >> 4, content=\"251658240\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 0xFFFFFFFFU\n///   inspect(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// }\n/// ```\npub impl Shl for UInt with shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n///   inspect(x >> 24, content=\"255\") // 0x000000FF\n///   let x = 0xFF000000U\n///   inspect(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// }\n/// ```\npub impl Shr for UInt with shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(0U.clz(), content=\"32\")\n///   inspect(1U.clz(), content=\"31\")\n///   inspect(0x80000000U.clz(), content=\"0\")\n/// }\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 24U // Binary: ...011000\n///   inspect(x.ctz(), content=\"3\") // 3 trailing zeros\n///   let y = 0U\n///   inspect(y.ctz(), content=\"32\") // All bits are zero\n/// }\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n///   inspect(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// }\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint64(), content=\"42\")\n///   let max = 4294967295U // Maximum value of UInt\n///   inspect(max.to_uint64(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258U // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let big = 4294967295U // Maximum value of UInt\n///   inspect(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_double(), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(max.to_double(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n#deprecated(\"Use `Float::from_int` instead\")\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_int` instead\")\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_uint` instead\")\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::from_byte` instead\")\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// TODO: enable skip_current_package=false\n#deprecated(\"Use `Float::from_double` instead\", skip_current_package=true)\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n#deprecated(\"Use `Float::from_uint` instead\")\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n#deprecated(\"Use `Int16::from_int` instead\")\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n#deprecated(\"Use `Int16::from_byte` instead\")\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(42)\n///   inspect(x.to_int(), content=\"42\")\n///   let max = Int::to_uint16(65535) // maximum value of UInt16\n///   inspect(max.to_int(), content=\"65535\")\n/// }\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n///   inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// }\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit unsigned integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit unsigned integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint16(), content=\"42\")\n///   let max = 4294967295U\n///   inspect(max.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536U\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn UInt::to_uint16(self : UInt) -> UInt16 {\n  self.reinterpret_as_int().to_uint16()\n}\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_uint16(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_uint16(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_uint16(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let map = { 3: \"three\", 8: \"eight\", 1: \"one\" }\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// }\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : ArrayView[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  for e in arr {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map : Map[String, Int] = Map::new()\n///   map.set(\"key\", 42)\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   map.set(\"key\", 24) // update existing key\n///   inspect(map.get(\"key\"), content=\"Some(24)\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"key\": 42 }\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   inspect(map.get(\"nonexistent\"), content=\"None\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n#alias(\"_[_]\")\npub fn[K : Hash + Eq, V] Map::at(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   map.remove(\"a\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.length(), content=\"1\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  self.remove_with_hash(key, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::remove_with_hash(\n  self : Map[K, V],\n  key : K,\n  hash : Int,\n) -> Unit {\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\n#alias(size, deprecated)\npub fn[K, V] Map::length(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\n#alias(iterator, deprecated)\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, value, next, .. }) => {\n        curr_entry = next\n        Some((key, value))\n      }\n      None => None\n    }\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  self.iter()\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, next, .. }) => {\n        curr_entry = next\n        Some(key)\n      }\n      None => None\n    }\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ value, next, .. }) => {\n        curr_entry = next\n        Some(value)\n      }\n      None => None\n    }\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n#alias(from_iterator, deprecated)\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  while iter.next() is Some((k, v)) {\n    m.set(k, v)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Merges two maps into a new map. Returns a new map containing all key-value\n/// pairs from both maps. When both maps contain the same key, the value from\n/// `other` takes precedence. The iteration order follows the order of `self`\n/// followed by new entries from `other`.\n///\n/// This is a pure operation - it does not modify either of the input maps.\n///\n/// Parameters:\n///\n/// * `self` : The first map.\n/// * `other` : The second map whose values take precedence in case of key\n/// conflicts.\n///\n/// Returns a new linked hash map containing all entries from both maps.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   let merged = map1.merge(map2)\n///   @json.inspect(merged, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge(self : Map[K, V], other : Map[K, V]) -> Map[K, V] {\n  let result = self.copy()\n  result.merge_in_place(other)\n  result\n}\n\n///|\n/// Merges another map into this map in-place. Updates the current map by adding\n/// all key-value pairs from `other`. When both maps contain the same key, the\n/// value from `other` overwrites the value in this map. New entries from `other`\n/// are added at the end, preserving the original order of `self` and appending\n/// new keys from `other`.\n///\n/// This is a mutating operation - it modifies the receiver map.\n///\n/// Parameters:\n///\n/// * `self` : The map to be modified.\n/// * `other` : The map whose entries will be added to `self`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   map1.merge_in_place(map2)\n///   @json.inspect(map1, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge_in_place(\n  self : Map[K, V],\n  other : Map[K, V],\n) -> Unit {\n  loop other.head {\n    Some({ key, value, next, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Retains only the key-value pairs that satisfy the given predicate function.\n/// This method modifies the map in-place, removing all entries for which\n/// the predicate returns `false`. The order of remaining elements is preserved.\n///\n/// Parameters:\n///\n/// * `self` : The map to be filtered.\n/// * `predicate` : A function that takes a key and value as arguments and returns\n/// `true` if the key-value pair should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 }\n///   map.retain((_k, v) => v % 2 == 0) // Keep only even values\n///   inspect(map.length(), content=\"2\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.get(\"b\"), content=\"Some(2)\")\n///   inspect(map.get(\"c\"), content=\"None\")\n///   inspect(map.get(\"d\"), content=\"Some(4)\")\n/// }\n/// ```\n#locals(f)\npub fn[K, V] Map::retain(self : Map[K, V], f : (K, V) -> Bool) -> Unit {\n  loop (self.head, false) {\n    (Some({ key, value, next, prev: idx, .. }), remove_prev) => {\n      if remove_prev {\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n      continue (next, !f(key, value))\n    }\n    (None, remove_prev) =>\n      if remove_prev {\n        let idx = self.tail\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n  }\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///\n///   // Update existing value\n///   map.update(\"a\", fn(v) {\n///     match v {\n///       Some(x) => Some(x + 10)\n///       None => Some(0)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2}\n///     ),\n///   )\n///\n///   // Insert new value\n///   map.update(\"c\", fn(v) {\n///     match v {\n///       Some(x) => Some(x)\n///       None => Some(3)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2, \"c\": 3}\n///     ),\n///   )\n///\n///   // Remove existing value\n///   map.update(\"b\", fn(_) { None })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"c\": 3}\n///     ),\n///   )\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n\n// Special handling for Views as accessors\n\n///|\nfn StringView::equal_to_string(self : Self, other : String) -> Bool {\n  let str = self.str()\n  let start = self.start()\n  let end = self.end()\n  let len = end - start\n  guard len == other.length() else { return false }\n  if physical_equal(str, other) && self.start() == 0 {\n    return true\n  }\n  for i in 0..<len {\n    guard str.unsafe_charcode_at(self.start() + i) ==\n      other.unsafe_charcode_at(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\nfn BytesView::equal_to_bytes(self : Self, other : Bytes) -> Bool {\n  let self_len = self.len()\n  let start = self.start()\n  guard self_len == other.length() else { return false }\n  for i in 0..<self_len {\n    guard self.bytes().unsafe_get(i + start) == other.unsafe_get(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Retrieves the value associated with a `BytesView` key in a map with `Bytes` keys.\n///\n/// This function allows efficient lookups using `BytesView` without creating a new `Bytes` object.\n/// It's particularly useful when working with byte slices or subranges of existing byte arrays.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `Bytes` keys to search in.\n/// * `key` : A `BytesView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { b\"hello\": 1, b\"world\": 2 }\n///   let bytes = b\"prefix_hello_suffix\"\n///   let view = bytes[7:12] // view of \"hello\"\n///   inspect(map.get_from_bytes(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_bytes(map : Self[Bytes, V], key : BytesView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_bytes(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n\n///|\n/// Retrieves the value associated with a `StringView` key in a map with `String` keys.\n///\n/// This function allows efficient lookups using `StringView` without creating a new `String` object.\n/// It's particularly useful when working with substrings or string slices.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `String` keys to search in.\n/// * `key` : A `StringView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"hello\": 1, \"world\": 2 }\n///   let str = \"say hello to everyone\"\n///   let view = str.view(start_offset=4, end_offset=9) // view of \"hello\"\n///   inspect(map.get_from_string(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_string(map : Self[String, V], key : StringView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_string(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. \n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3]\n///   inspect(arr.get(1), content=\"Some(2)\")\n///   let arr : FixedArray[Int] = [1, 2, 3]\n///   inspect(arr.get(3), content=\"None\")\n/// }\n/// ```\npub fn[T] FixedArray::get(self : FixedArray[T], idx : Int) -> T? {\n  let len = self.length()\n  guard idx >= 0 && idx < len else { None }\n  Some(self.unsafe_get(idx))\n}\n\n///|\n/// Returns an empty fixed-size array of the specified type.\n///\n/// Parameters:\n///\n/// * `X` : The type parameter specifying the element type of the array.\n///\n/// Returns an empty fixed-size array of type `FixedArray[X]`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = FixedArray::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// }\n/// ```\npub impl[X] Default for FixedArray[X] with default() {\n  []\n}\n\n///|\n/// Fill the array with a given value.\n/// \n/// This method fills all or part of a FixedArray with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```mbt check\n/// test {\n///   // Fill entire array\n///   let fa : FixedArray[Int] = [0, 0, 0, 0, 0]\n///   fa.fill(3)\n///   inspect(fa, content=\"[3, 3, 3, 3, 3]\")\n///\n///   // Fill from index 1 to 3 (exclusive)\n///   let fa2 : FixedArray[Int] = [0, 0, 0, 0, 0]\n///   fa2.fill(9, start=1, end=3)\n///   inspect(fa2, content=\"[0, 9, 9, 0, 0]\")\n///\n///   // Fill from index 2 to end\n///   let fa3 : FixedArray[String] = [\"a\", \"b\", \"c\", \"d\"]\n///   fa3.fill(\"x\", start=2)\n///   inspect(\n///     fa3,\n///     content=(\n///       #|[\"a\", \"b\", \"x\", \"x\"]\n///     ),\n///   )\n/// }\n/// ```\npub fn[T] FixedArray::fill(\n  self : FixedArray[T],\n  value : T,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let length = match end {\n    None => array_length - start\n    Some(e) => {\n      guard e >= start && e <= array_length\n      e - start\n    }\n  }\n  self.unchecked_fill(start, value, length)\n}\n\n///|\n#coverage.skip\n#intrinsic(\"%fixedarray.fill\")\nfn[T] FixedArray::unchecked_fill(\n  self : FixedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n\n///|\n/// Tests whether the FixedArray contains no elements.\n///\n/// Parameters:\n///\n/// * `FixedArray` : The FixedArray to check.\n///\n/// Returns `true` if the FixedArray has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let empty : FixedArray[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] FixedArray::is_empty(self : FixedArray[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// \n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v : FixedArray[Int] = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// }\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] FixedArray::binary_search(\n  self : FixedArray[T],\n  value : T,\n) -> Result[Int, Int] {\n  self[:].binary_search(value)\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by(x => x.compare(3))\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by(x => x.compare(4))\n///   inspect(find_4, content=\"Err(2)\")\n/// }\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\npub fn[T] FixedArray::binary_search_by(\n  self : FixedArray[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self[:].binary_search_by(cmp)\n}\n\n///|\n/// Iterates over each element.\n///\n/// # Arguments\n///\n/// - `self`: The array to iterate over.\n/// - `f`: The function to apply to each element.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3, 4, 5].each(x => arr.push(x))\n///   assert_eq(arr, [1, 2, 3, 4, 5])\n/// }\n/// ```\npub fn[T] FixedArray::each(\n  self : FixedArray[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\ntest \"each\" {\n  let mut i = 0\n  let mut failed = false\n  let f = elem => {\n    if elem != i + 1 {\n      failed = true\n    }\n    i = i + 1\n  }\n  {\n    i = 0\n    ([] : FixedArray[_]).each(f)\n    assert_false(failed)\n    inspect(i, content=\"0\")\n  }\n  {\n    i = 0\n    ([1] : FixedArray[_]).each(f)\n    assert_false(failed)\n    inspect(i, content=\"1\")\n  }\n  i = 0\n  ([1, 2, 3, 4, 5] : FixedArray[_]).each(f)\n  assert_false(failed)\n  inspect(i, content=\"5\")\n}\n\n///|\n/// Iterates over the array with index.\n///\n/// # Arguments\n///\n/// - `self`: The array to iterate over.\n/// - `f`: A function that takes an `Int` representing the index and a `T` representing the element of the array, and returns `Unit`.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3, 4, 5].eachi((index, elem) => arr.push((index, elem)))\n///   assert_eq(arr, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\n/// }\n/// ```\npub fn[T] FixedArray::eachi(\n  self : FixedArray[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\ntest \"eachi\" {\n  let mut i = 0\n  let mut failed = false\n  let f = (index, elem) => {\n    if index != i || elem != i + 1 {\n      failed = true\n    }\n    i = i + 1\n  }\n  {\n    i = 0\n    ([] : FixedArray[_]).eachi(f)\n    assert_false(failed)\n    inspect(i, content=\"0\")\n  }\n  {\n    i = 0\n    ([1] : FixedArray[_]).eachi(f)\n    assert_false(failed)\n    inspect(i, content=\"1\")\n  }\n  i = 0\n  ([1, 2, 3, 4, 5] : FixedArray[_]).eachi(f)\n  assert_false(failed)\n  inspect(i, content=\"5\")\n}\n\n///|\n/// Iterates over each element in reversed turn.\n///\n/// # Arguments\n///\n/// - `self`: The array to iterate over.\n/// - `f`: The function to apply to each element.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3, 4, 5].rev_each(x => arr.push(x))\n///   assert_eq(arr, [5, 4, 3, 2, 1])\n/// }\n/// ```\npub fn[T] FixedArray::rev_each(\n  self : FixedArray[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  for i = self.length() - 1; i >= 0; i = i - 1 {\n    f(self[i])\n  }\n}\n\n///|\ntest \"rev_each\" {\n  let mut i = 6\n  let mut failed = false\n  let f = elem => {\n    if elem != i - 1 {\n      failed = true\n    }\n    i = i - 1\n  }\n  {\n    i = 1\n    ([] : FixedArray[_]).rev_each(f)\n    assert_false(failed)\n    inspect(i, content=\"1\")\n  }\n  {\n    i = 2\n    ([1] : FixedArray[_]).rev_each(f)\n    assert_false(failed)\n    inspect(i, content=\"1\")\n  }\n  i = 6\n  ([1, 2, 3, 4, 5] : FixedArray[_]).rev_each(f)\n  assert_false(failed)\n  inspect(i, content=\"1\")\n}\n\n///|\n/// Iterates over the array with index in reversed turn.\n///\n/// # Arguments\n///\n/// - `self`: The array to iterate over.\n/// - `f`: A function that takes an `Int` representing the index and a `T` representing the element of the array, and returns `Unit`.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3, 4, 5].rev_eachi((index, elem) => arr.push((index, elem)))\n///   assert_eq(arr, [(0, 5), (1, 4), (2, 3), (3, 2), (4, 1)])\n/// }\n/// ```\npub fn[T] FixedArray::rev_eachi(\n  self : FixedArray[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\ntest \"rev_eachi\" {\n  let mut i = 6\n  let mut j = 0\n  let mut failed = false\n  let f = (index, elem) => {\n    if index != j || elem != i - 1 {\n      failed = true\n    }\n    i = i - 1\n    j = j + 1\n  }\n  {\n    i = 1\n    j = 0\n    ([] : FixedArray[_]).rev_eachi(f)\n    assert_false(failed)\n    inspect(i, content=\"1\")\n    inspect(j, content=\"0\")\n  }\n  {\n    i = 2\n    j = 0\n    ([1] : FixedArray[_]).rev_eachi(f)\n    assert_false(failed)\n    inspect(i, content=\"1\")\n    inspect(j, content=\"1\")\n  }\n  i = 6\n  j = 0\n  ([1, 2, 3, 4, 5] : FixedArray[_]).rev_eachi(f)\n  assert_false(failed)\n  inspect(i, content=\"1\")\n  inspect(j, content=\"5\")\n}\n\n///|\n/// Applies a function to each element of the array and returns a new array with the results.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let doubled = arr.map(x => x * 2)\n///   assert_eq(doubled, [2, 4, 6, 8, 10])\n/// }\n/// ```\npub fn[T, U] FixedArray::map(\n  self : FixedArray[T],\n  f : (T) -> U raise?,\n) -> FixedArray[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let res = FixedArray::make(self.length(), f(self[0]))\n  for i in 1..<self.length() {\n    res[i] = f(self[i])\n  }\n  res\n}\n\n///|\ntest \"map\" {\n  let empty : FixedArray[Unit] = FixedArray::default().map(x => x)\n  assert_eq(empty, [])\n  let simple_arr : FixedArray[_] = [6]\n  let simple_doubled = simple_arr.map(x => x * 2)\n  assert_eq(simple_doubled, [12])\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  let doubled = arr.map(x => x * 2)\n  assert_eq(doubled, [2, 4, 6, 8, 10])\n}\n\n///|\n/// Maps a function over the elements of the arr with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [3, 4, 5]\n///   let added = arr.mapi((i, x) => x + i)\n///   assert_eq(added, [3, 5, 7])\n/// }\n/// ```\npub fn[T, U] FixedArray::mapi(\n  self : FixedArray[T],\n  f : (Int, T) -> U raise?,\n) -> FixedArray[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let res = FixedArray::make(self.length(), f(0, self[0]))\n  for i in 1..<self.length() {\n    res[i] = f(i, self[i])\n  }\n  res\n}\n\n///|\ntest \"mapi\" {\n  let empty : FixedArray[Int] = FixedArray::default().mapi((i, x) => x + i)\n  assert_eq(empty, [])\n  let simple_arr : FixedArray[_] = [6]\n  let simple_doubled = simple_arr.mapi((i, x) => x * 2 + i)\n  assert_eq(simple_doubled, [12])\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  let doubled = arr.mapi((i, x) => x * 2 + i)\n  assert_eq(doubled, [2, 5, 8, 11, 14])\n}\n\n///|\n/// Creates a new fixed-size array of the specified length, where each element is\n/// initialized using a function that maps indices to values.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. If `length` is less than or\n/// equal to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (from 0 to `length - 1`) and\n/// returns a value of type `T` for that position.\n///\n/// Returns a new fixed array containing the values produced by applying the\n/// initializer function to each index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::makei(3, i => i * 2)\n///   inspect(arr, content=\"[0, 2, 4]\")\n/// }\n/// ```\n#locals(value)\npub fn[T] FixedArray::makei(\n  length : Int,\n  value : (Int) -> T raise?,\n) -> FixedArray[T] raise? {\n  if length <= 0 {\n    []\n  } else {\n    let array = FixedArray::make(length, value(0))\n    for i in 1..<length {\n      array[i] = value(i)\n    }\n    array\n  }\n}\n\n///|\ntest \"fixedarray_new_with_index\" {\n  let empty = FixedArray::makei(0, i => i)\n  inspect(empty.length(), content=\"0\")\n  let simple_arr = FixedArray::makei(1, i => i)\n  inspect(simple_arr.length(), content=\"1\")\n  inspect(simple_arr[0], content=\"0\")\n  let arr = FixedArray::makei(2, i => i)\n  inspect(arr.length(), content=\"2\")\n  inspect(arr[0], content=\"0\")\n  inspect(arr[1], content=\"1\")\n}\n\n///|\n/// Creates a new fixed-size array from a dynamic array. The resulting fixed\n/// array will have the same length and elements as the input array.\n///\n/// Parameters:\n///\n/// * `array` : A dynamic array containing elements of type `T` that will be\n/// converted to a fixed array.\n///\n/// Returns a new fixed array containing the same elements as the input array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let dynamic_array = [1, 2, 3, 4, 5]\n///   let fixed_array = FixedArray::from_array(dynamic_array)\n///   inspect(fixed_array, content=\"[1, 2, 3, 4, 5]\")\n/// }\n/// ```\npub fn[T] FixedArray::from_array(array : ArrayView[T]) -> FixedArray[T] {\n  FixedArray::makei(array.length(), i => array.unsafe_get(i))\n}\n\n///|\ntest \"from_array\" {\n  let array = FixedArray::from_array([1, 2, 3, 4, 5])\n  assert_eq(array, [1, 2, 3, 4, 5])\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] FixedArray::fold(\n  self : FixedArray[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\ntest \"fold\" {\n  let sum = ([] : FixedArray[_]).fold(init=1, (sum, elem) => sum + elem)\n  inspect(sum, content=\"1\")\n  let sum = ([1] : FixedArray[_]).fold(init=2, (sum, elem) => sum + elem)\n  inspect(sum, content=\"3\")\n  let sum = ([1, 2, 3, 4, 5] : FixedArray[_]).fold(init=0, (sum, elem) => sum +\n    elem)\n  inspect(sum, content=\"15\")\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] FixedArray::rev_fold(\n  self : FixedArray[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\ntest \"rev_fold\" {\n  let sum = ([] : FixedArray[_]).rev_fold(init=1, (sum, elem) => sum + elem)\n  inspect(sum, content=\"1\")\n  let sum = ([1] : FixedArray[_]).rev_fold(init=2, (sum, elem) => sum + elem)\n  inspect(sum, content=\"3\")\n  let sum = ([1, 2, 3, 4, 5] : FixedArray[_]).rev_fold(init=0, (sum, elem) => sum +\n    elem)\n  inspect(sum, content=\"15\")\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] FixedArray::foldi(\n  self : FixedArray[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\ntest \"fold_lefti\" {\n  let f = (index, sum, elem) => index + sum + elem\n  {\n    let sum = ([] : FixedArray[_]).foldi(init=1, f)\n    inspect(sum, content=\"1\")\n  }\n  {\n    let sum = ([1] : FixedArray[_]).foldi(init=2, f)\n    inspect(sum, content=\"3\")\n  }\n  let sum = ([1, 2, 3, 4, 5] : FixedArray[_]).foldi(init=0, f)\n  inspect(sum, content=\"25\")\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] FixedArray::rev_foldi(\n  self : FixedArray[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\ntest \"rev_foldi\" {\n  let f = (index, sum, elem) => index + sum + elem\n  {\n    let sum = ([] : FixedArray[_]).rev_foldi(init=1, f)\n    inspect(sum, content=\"1\")\n  }\n  {\n    let sum = ([1] : FixedArray[_]).rev_foldi(init=2, f)\n    inspect(sum, content=\"3\")\n  }\n  let sum = ([1, 2, 3, 4, 5] : FixedArray[_]).rev_foldi(init=0, f)\n  inspect(sum, content=\"25\")\n}\n\n///|\n/// Reverses the array in place by swapping elements from both ends until\n/// reaching the middle.\n///\n/// Parameters:\n///\n/// * `array` : The array to be reversed. The array will be modified in place.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n/// }\n/// ```\n#alias(rev_inplace, deprecated)\npub fn[T] FixedArray::rev_in_place(self : FixedArray[T]) -> Unit {\n  let mid_len = self.length() / 2\n  for i in 0..<mid_len {\n    let j = self.length() - i - 1\n    let temp = self[i]\n    self[i] = self[j]\n    self[j] = temp\n  }\n}\n\n///|\n/// Returns a new array containing all elements in reverse order. The original\n/// array remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array with the same elements but in reverse order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   // Original array remains unchanged\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\")\n/// }\n/// ```\npub fn[T] FixedArray::rev(self : FixedArray[T]) -> FixedArray[T] {\n  match self {\n    [] => []\n    [.., first] => {\n      let res = FixedArray::make(self.length(), first)\n      let len = self.length()\n      for i in 1..<len {\n        res[i] = self[len - 1 - i]\n      }\n      res\n    }\n  }\n}\n\n///|\ntest \"rev in place\" {\n  {\n    let arr : FixedArray[Int] = []\n    arr.rev_in_place()\n    assert_eq(arr, [])\n  }\n  {\n    let arr : FixedArray[_] = [1]\n    arr.rev_in_place()\n    assert_eq(arr, [1])\n  }\n  {\n    let arr : FixedArray[_] = [1, 2]\n    arr.rev_in_place()\n    assert_eq(arr, [2, 1])\n  }\n  {\n    let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n    arr.rev_in_place()\n    assert_eq(arr, [5, 4, 3, 2, 1])\n  }\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5, 6]\n  arr.rev_in_place()\n  assert_eq(arr, [6, 5, 4, 3, 2, 1])\n}\n\n///|\ntest \"rev\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_eq(arr.rev(), [])\n  }\n  {\n    let arr : FixedArray[_] = [1]\n    assert_eq(arr.rev(), [1])\n  }\n  {\n    let arr : FixedArray[_] = [1, 2]\n    assert_eq(arr.rev(), [2, 1])\n  }\n  {\n    let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n    assert_eq(arr.rev(), [5, 4, 3, 2, 1])\n  }\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5, 6]\n  assert_eq(arr.rev(), [6, 5, 4, 3, 2, 1])\n}\n\n///|\n/// Swap two elements in the array.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.swap(0, 1)\n///   assert_eq(arr, [2, 1, 3, 4, 5])\n/// }\n/// ```\npub fn[T] FixedArray::swap(self : FixedArray[T], i : Int, j : Int) -> Unit {\n  let temp = self[i]\n  self[i] = self[j]\n  self[j] = temp\n}\n\n///|\ntest \"swap\" {\n  {\n    let arr : FixedArray[Int] = [1]\n    arr.swap(0, 0)\n    assert_eq(arr, [1])\n  }\n  {\n    let arr : FixedArray[_] = [1, 2]\n    arr.swap(0, 0)\n    assert_eq(arr, [1, 2])\n    arr.swap(0, 1)\n    assert_eq(arr, [2, 1])\n  }\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  arr.swap(3, 3)\n  assert_eq(arr, [1, 2, 3, 4, 5])\n  arr.swap(1, 3)\n  assert_eq(arr, [1, 4, 3, 2, 5])\n}\n\n///|\n/// Check if all the elements in the array match the condition.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   assert_true(arr.all(ele => ele < 6))\n///   assert_false(arr.all(ele => ele < 5))\n/// }\n/// ```\n///\n#alias(every)\npub fn[T] FixedArray::all(\n  self : FixedArray[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  self[:].all(f)\n}\n\n///|\ntest \"all\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_true(arr.all(ele => ele < 6))\n    assert_true(arr.all(ele => ele < 5))\n  }\n  {\n    let arr : FixedArray[_] = [5]\n    assert_true(arr.all(ele => ele < 6))\n    assert_false(arr.all(ele => ele < 5))\n  }\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  assert_true(arr.all(ele => ele < 6))\n  assert_false(arr.all(ele => ele < 5))\n}\n\n///|\n/// Check if any of the elements in the array match the condition.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   assert_true(arr.any(ele => ele < 6))\n///   assert_true(arr.any(ele => ele < 5))\n/// }\n/// ```\n#alias(exists)\npub fn[T] FixedArray::any(\n  self : FixedArray[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  self[:].any(f)\n}\n\n///|\ntest \"any\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_false(arr.any(ele => ele < 6))\n    assert_false(arr.any(ele => ele < 5))\n  }\n  {\n    let arr : FixedArray[_] = [5]\n    assert_true(arr.any(ele => ele < 6))\n    assert_false(arr.any(ele => ele < 5))\n  }\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  assert_true(arr.any(ele => ele < 6))\n  assert_true(arr.any(ele => ele < 5))\n}\n\n///|\ntest \"fill\" {\n  {\n    let arr : FixedArray[Int] = []\n    arr.fill(3)\n    assert_eq(arr, [])\n  }\n  {\n    let arr : FixedArray[_] = [6]\n    arr.fill(5)\n    assert_eq(arr, [5])\n  }\n  let arr : FixedArray[_] = [0, 0, 0, 0, 0]\n  arr.fill(3)\n  assert_eq(arr, [3, 3, 3, 3, 3])\n}\n\n///|\n/// Search the array index for a given element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [3, 4, 5]\n///   assert_eq(arr.search(3), Some(0))\n/// }\n/// ```\npub fn[T : Eq] FixedArray::search(self : FixedArray[T], value : T) -> Int? {\n  self[:].search(value)\n}\n\n///|\ntest \"search\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_eq(arr.search(3), None)\n    assert_eq(arr.search(-1), None)\n  }\n  {\n    let arr : FixedArray[_] = [3]\n    assert_eq(arr.search(3), Some(0))\n    assert_eq(arr.search(-1), None)\n  }\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  assert_eq(arr.search(1), Some(0))\n  assert_eq(arr.search(5), Some(4))\n  assert_eq(arr.search(3), Some(2))\n  assert_eq(arr.search(-1), None)\n}\n\n///|\n/// Checks if the array contains an element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [3, 4, 5]\n///   assert_true(arr.contains(3))\n/// }\n/// ```\npub fn[T : Eq] FixedArray::contains(self : FixedArray[T], value : T) -> Bool {\n  for i in 0..<self.length() {\n    if self[i] == value {\n      return true\n    }\n  }\n  false\n}\n\n///|\ntest \"contains\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_false(arr.contains(3))\n    assert_false(arr.contains(-1))\n  }\n  {\n    let arr : FixedArray[_] = [3]\n    assert_true(arr.contains(3))\n    assert_false(arr.contains(-1))\n  }\n  let arr : FixedArray[_] = [3, 4, 5]\n  assert_true(arr.contains(3))\n  assert_true(arr.contains(4))\n  assert_true(arr.contains(5))\n  assert_false(arr.contains(6))\n}\n\n///|\n/// Check if the array starts with a given prefix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [3, 4, 5]\n///   assert_true(arr.starts_with([3, 4]))\n/// }\n/// ```\npub fn[T : Eq] FixedArray::starts_with(\n  self : FixedArray[T],\n  prefix : FixedArray[T],\n) -> Bool {\n  self[:].starts_with(prefix[:])\n}\n\n///|\ntest \"starts_with\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_true(arr.starts_with([]))\n    assert_false(arr.starts_with([1]))\n  }\n  {\n    let arr : FixedArray[_] = [3]\n    assert_true(arr.starts_with([]))\n    assert_true(arr.starts_with([3]))\n    assert_false(arr.starts_with([2]))\n    assert_false(arr.starts_with([3, 1]))\n  }\n  let arr : FixedArray[_] = [3, 4, 5]\n  assert_true(arr.starts_with([]))\n  assert_true(arr.starts_with([3]))\n  assert_false(arr.starts_with([2]))\n  assert_true(arr.starts_with([3, 4]))\n  assert_false(arr.starts_with([3, 2]))\n  assert_true(arr.starts_with([3, 4, 5]))\n  assert_false(arr.starts_with([3, 4, 2]))\n  assert_false(arr.starts_with([3, 4, 5, 6]))\n}\n\n///|\n/// Check if the array ends with a given suffix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v : FixedArray[Int] = [3, 4, 5]\n///   assert_true(v.ends_with([5]))\n/// }\n/// ```\npub fn[T : Eq] FixedArray::ends_with(\n  self : FixedArray[T],\n  suffix : FixedArray[T],\n) -> Bool {\n  self[:].ends_with(suffix[:])\n}\n\n///|\ntest \"ends_with\" {\n  {\n    let arr : FixedArray[Int] = []\n    assert_true(arr.ends_with([]))\n    assert_false(arr.ends_with([1]))\n  }\n  {\n    let arr : FixedArray[_] = [3]\n    assert_true(arr.ends_with([]))\n    assert_true(arr.ends_with([3]))\n    assert_false(arr.ends_with([2]))\n    assert_false(arr.ends_with([3, 1]))\n  }\n  let arr : FixedArray[_] = [3, 4, 5]\n  assert_true(arr.ends_with([]))\n  assert_true(arr.ends_with([5]))\n  assert_false(arr.ends_with([2]))\n  assert_true(arr.ends_with([4, 5]))\n  assert_false(arr.ends_with([4, 2]))\n  assert_false(arr.ends_with([2, 5]))\n  assert_true(arr.ends_with([3, 4, 5]))\n  assert_false(arr.ends_with([3, 4, 2]))\n  assert_false(arr.ends_with([3, 2, 5]))\n  assert_false(arr.ends_with([2, 4, 5]))\n  assert_false(arr.ends_with([3, 4, 5, 6]))\n  assert_false(arr.ends_with([2, 3, 4, 5]))\n}\n\n///|\n/// Checks if two fixed arrays are equal.\n///\n/// Two arrays are considered equal if they have the same length and all\n/// corresponding elements are equal. The elements in the arrays must implement\n/// the `Eq` trait.\n///\n/// Parameters:\n///\n/// * `self` : The first fixed array to compare.\n/// * `other` : The second fixed array to compare.\n///\n/// Returns `true` if the arrays are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 : FixedArray[Int] = [1, 2, 3]\n///   let arr2 : FixedArray[Int] = [1, 2, 3]\n///   let arr3 : FixedArray[Int] = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// }\n/// ```\npub impl[T : Eq] Eq for FixedArray[T] with equal(\n  self : FixedArray[T],\n  that : FixedArray[T],\n) -> Bool {\n  if self.length() != that.length() {\n    return false\n  }\n  for i in 0..<self.length() {\n    if self[i] != that[i] {\n      return false\n    }\n  }\n  true\n}\n\n///|\npub impl[T : Hash] Hash for FixedArray[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\ntest \"equal\" {\n  {\n    inspect(([] : FixedArray[Int]) == [], content=\"true\")\n    inspect(([] : FixedArray[_]) == [1], content=\"false\")\n    inspect(([1, 2] : FixedArray[_]) == [], content=\"false\")\n  }\n  {\n    inspect(([1] : FixedArray[_]) == [1], content=\"true\")\n    inspect(([1] : FixedArray[_]) == [2], content=\"false\")\n    inspect(([1, 2] : FixedArray[_]) == [1], content=\"false\")\n    inspect(([1] : FixedArray[_]) == [1, 2], content=\"false\")\n  }\n  inspect(([1, 2, 3, 4, 5] : FixedArray[_]) == [1, 2, 3, 4, 5], content=\"true\")\n  inspect(([1, 2, 3, 4, 5] : FixedArray[_]) == [1, 2, 3, 4], content=\"false\")\n  inspect(([1, 2, 3, 4] : FixedArray[_]) == [1, 2, 3, 4, 5], content=\"false\")\n  inspect(([1, 2, 3, 4, 5] : FixedArray[_]) == [6, 2, 3, 4, 5], content=\"false\")\n  inspect(([1, 2, 3, 4, 5] : FixedArray[_]) == [1, 2, 6, 4, 5], content=\"false\")\n  inspect(([1, 2, 3, 4, 5] : FixedArray[_]) == [1, 2, 3, 4, 6], content=\"false\")\n}\n\n///|\n/// Compares two fixed arrays based on shortlex order by their elements. First\n/// compares the lengths of the arrays, then compares elements pairwise until a\n/// difference is found or all elements have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first fixed array to compare.\n/// * `other` : The second fixed array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// }\n/// ```\npub impl[T : Compare] Compare for FixedArray[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp == 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp == 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays and returns a new array containing all elements from\n/// both arrays in order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array that contains all elements from the first array followed\n/// by all elements from the second array. The returned array is independent of\n/// both input arrays.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 : FixedArray[Int] = [1, 2, 3]\n///   let arr2 : FixedArray[Int] = [4, 5, 6]\n///   inspect(arr1 + arr2, content=\"[1, 2, 3, 4, 5, 6]\")\n/// }\n/// ```\npub impl[T] Add for FixedArray[T] with add(self, other) {\n  let slen = self.length()\n  let nlen = other.length()\n  FixedArray::makei(slen + nlen, i => if i < slen {\n    self[i]\n  } else {\n    other[i - slen]\n  })\n}\n\n///|\ntest \"add\" {\n  {\n    inspect(([] : FixedArray[Int]) + [], content=\"[]\")\n    inspect(([] : FixedArray[_]) + [1, 2, 3, 4, 5], content=\"[1, 2, 3, 4, 5]\")\n    inspect(([1, 2, 3, 4, 5] : FixedArray[_]) + [], content=\"[1, 2, 3, 4, 5]\")\n  }\n  {\n    inspect(([1] : FixedArray[_]) + [2], content=\"[1, 2]\")\n    inspect(\n      ([1] : FixedArray[_]) + [1, 2, 3, 4, 5],\n      content=\"[1, 1, 2, 3, 4, 5]\",\n    )\n    inspect(\n      ([1, 2, 3, 4, 5] : FixedArray[_]) + [1],\n      content=\"[1, 2, 3, 4, 5, 1]\",\n    )\n  }\n  inspect(\n    ([1, 2, 3, 4, 5] : FixedArray[_]) + [6, 7, 8, 9, 10],\n    content=\"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\",\n  )\n}\n\n///|\ntest \"iter\" {\n  let arr : FixedArray[_] = [1, 2, 3, 4, 5]\n  let iter = arr.iter()\n  let exb = StringBuilder::new()\n  let mut i = 0\n  iter.each(x => {\n    exb.write_string(x.to_string())\n    exb.write_char('\\n')\n    i = i + 1\n  })\n  assert_eq(i, arr.length())\n  inspect(\n    exb,\n    content=(\n      #|1\n      #|2\n      #|3\n      #|4\n      #|5\n      #|\n    ),\n  )\n}\n\n///|\n/// Creates a new fixed array from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator of type `Iter[T]` from which elements will be\n/// collected into a fixed array.\n///\n/// Returns a new fixed array containing all elements from the iterator.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let fixed_arr = FixedArray::from_iter(arr.iter())\n///   inspect(fixed_arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] FixedArray::from_iter(iter : Iter[T]) -> FixedArray[T] {\n  FixedArray::from_array(iter.collect())\n}\n\n///|\n/// Returns the last element of a fixed array if it exists.\n///\n/// Parameters:\n///\n/// * `self` : The fixed array to get the last element from.\n///\n/// Returns `Some(element)` containing the last element if the array is not\n/// empty, or `None` if the array is empty.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let array : FixedArray[Int] = [1, 2, 3]\n///   inspect(array.last(), content=\"Some(3)\")\n///   let empty : FixedArray[Int] = []\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[A] FixedArray::last(self : FixedArray[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\n/// Concatenate strings within an array into a single complete string.\n///\n/// Example:\n/// \n/// ```mbt check\n/// test {\n///   let fixed_array : FixedArray[String] = [\"1\", \"2\", \"3\"]\n///   inspect(fixed_array.join(\",\"), content=\"1,2,3\")\n/// }\n/// ```\npub fn FixedArray::join(\n  self : FixedArray[String],\n  separator : StringView,\n) -> String {\n  let len = self.length()\n  if len == 0 {\n    return \"\"\n  }\n  let first = self[0]\n  let mut size_hint = first.length()\n  for i in 1..<len {\n    size_hint += separator.length() + self[i].length()\n  }\n  let string = StringBuilder::new(size_hint~)\n  if separator.length() == 0 {\n    for i in 0..<len {\n      string.write_string(self[i])\n    }\n  } else {\n    string.write_string(self[0])\n    for i in 1..<len {\n      string.write_substring(\n        separator.data(),\n        separator.start_offset(),\n        separator.length(),\n      )\n      string.write_string(self[i])\n    }\n  }\n  string.to_string()\n}\n\n///|\ntest \"FixedArray::last/empty\" {\n  let empty : FixedArray[Int] = []\n  inspect(empty.last(), content=\"None\")\n}\n\n///|\ntest \"FixedArray::last/non_empty\" {\n  let array : FixedArray[_] = [1, 2, 3]\n  inspect(array.last(), content=\"Some(3)\")\n  let single : FixedArray[_] = [42]\n  inspect(single.last(), content=\"Some(42)\")\n}\n\n///|\ntest \"FixedArray::last/empty_array\" {\n  let empty_array : FixedArray[Int] = []\n  inspect(FixedArray::last(empty_array), content=\"None\")\n}\n\n///|\ntest \"FixedArray::last/single_element\" {\n  let single_element_array : FixedArray[Int] = [42]\n  inspect(FixedArray::last(single_element_array), content=\"Some(42)\")\n}\n\n///|\ntest \"FixedArray::last/multiple_elements\" {\n  let multiple_elements_array : FixedArray[Int] = [1, 2, 3, 4, 5]\n  inspect(FixedArray::last(multiple_elements_array), content=\"Some(5)\")\n}\n\n///|\ntest \"FixedArray::join\" {\n  let fixed_array : FixedArray[String] = [\"1\", \"2\", \"3\"]\n  inspect(fixed_array.join(\",\"), content=\"1,2,3\")\n  inspect(fixed_array.join(\"\"), content=\"123\")\n  inspect(fixed_array.join(\" \"), content=\"1 2 3\")\n  let fixed_array_empty : FixedArray[String] = []\n  inspect(fixed_array_empty.join(\",\"), content=\"\")\n}\n\n///|\n#alias(iterator, deprecated)\npub fn[X] FixedArray::iter(self : FixedArray[X]) -> Iter[X] {\n  self[:].iter()\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn[X] FixedArray::iter2(self : FixedArray[X]) -> Iter2[Int, X] {\n  self[:].iter2()\n}\n\n///|\n/// Creates a new array that is a copy of the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be copied. The type of elements in the array must be\n/// `T`.\n///\n/// Returns a new array containing all elements from the original array in the\n/// same order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let original = [1, 2, 3]\n///   let copied = original.copy()\n///   inspect(copied, content=\"[1, 2, 3]\")\n///   inspect(physical_equal(original, copied), content=\"false\")\n/// }\n/// ```\n#cfg(not(target=\"js\"))\npub fn[T] FixedArray::copy(self : FixedArray[T]) -> FixedArray[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = FixedArray::make(len, self[0])\n    FixedArray::unsafe_blit(arr, 0, self, 0, len)\n    arr\n  }\n}\n\n///|\n/// Creates a new array that is a copy of the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be copied. The type of elements in the array must be\n/// `T`.\n///\n/// Returns a new array containing all elements from the original array in the\n/// same order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let original = [1, 2, 3]\n///   let copied = original.copy()\n///   inspect(copied, content=\"[1, 2, 3]\")\n///   inspect(physical_equal(original, copied), content=\"false\")\n/// }\n/// ```\n#cfg(target=\"js\")\npub fn[T] FixedArray::copy(self : FixedArray[T]) -> FixedArray[T] {\n  JSArray::ofAnyFixedArray(self).copy().toAnyFixedArray()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// }\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// }\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// }\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// }\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n///   inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_surrogate(), content=\"true\") // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\") // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") //  emoji codepoint\n/// }\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n\n///|\n/// Computes the absolute value of an integer.\n///\n/// Parameters:\n///\n/// * `self` : The integer whose absolute value is to be computed.\n///\n/// Returns the absolute value of the integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Int::abs(42), content=\"42\")\n///   inspect(Int::abs(-42), content=\"42\")\n///   inspect(Int::abs(0), content=\"0\")\n/// }\n/// ```\npub fn Int::abs(self : Int) -> Int {\n  if self < 0 {\n    -self\n  } else {\n    self\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n#alias(or, deprecated)\npub fn[T] Option::unwrap_or(self : T?, default : T) -> T {\n  match self {\n    None => default\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n///\n/// Default is lazily evaluated\n#alias(or_else, deprecated)\npub fn[T] Option::unwrap_or_else(\n  self : T?,\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    None => default()\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the result of the `T::default()`.\n#alias(or_default, deprecated)\npub fn[T : Default] Option::unwrap_or_default(self : T?) -> T {\n  match self {\n    None => T::default()\n    Some(t) => t\n  }\n}\n\n///|\npub impl[X : Compare] Compare for X? with compare(self, other) {\n  match (self, other) {\n    (Some(x), Some(y)) => x.compare(y)\n    (Some(_), None) => 1\n    (None, Some(_)) => -1\n    (None, None) => 0\n  }\n}\n\n///|\n#alias(or_error, deprecated)\npub fn[T, Err : Error] Option::unwrap_or_error(\n  self : T?,\n  err : Err,\n) -> T raise Err {\n  match self {\n    Some(v) => v\n    None => raise err\n  }\n}\n\n///|\n/// `None`\npub impl[X] Default for X? with default() {\n  None\n}\n\n///|\n#alias(iterator, deprecated)\npub fn[T] Option::iter(self : T?) -> Iter[T] {\n  match self {\n    Some(v) => Iter::singleton(v)\n    None => Iter::empty()\n  }\n}\n\n///|\n/// Maps the value of an `Option` using a provided function.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map(x => x * 2), Some(10))\n///   let b = None\n///   assert_eq(b.map(x => x * 2), None)\n/// }\n/// ```\npub fn[T, U] Option::map(self : T?, f : (T) -> U raise?) -> U? raise? {\n  match self {\n    Some(t) => Some(f(t))\n    None => None\n  }\n}\n\n///|\n/// Returns the provided default result (if none), or applies a function to the contained value (if any).\n/// Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or(3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or(\n  self : T?,\n  default : U,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Computes a default function result (if none), or applies a different function to the contained value (if any).\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or_else(() => 3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or_else(\n  self : T?,\n  default : () -> U raise?,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default()\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Binds an option to a function that returns another option.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Option::Some(5)\n///   let r1 = a.bind(x => Some(x * 2))\n///   assert_eq(r1, Some(10))\n///   let b : Int? = None\n///   let r2 = b.bind(x => Some(x * 2))\n///   assert_eq(r2, None)\n/// }\n/// ```\npub fn[T, U] Option::bind(self : T?, f : (T) -> U? raise?) -> U? raise? {\n  match self {\n    Some(t) => f(t)\n    None => None\n  }\n}\n\n///|\n#deprecated(\"use `option.bind(x => x)` instead\")\npub fn[T] Option::flatten(self : T??) -> T? {\n  match self {\n    Some(inner) => inner\n    None => None\n  }\n}\n\n///|\n/// Checks if the option is empty.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_empty(self : T?) -> Bool {\n  self is None\n}\n\n///|\n/// Filters the option by applying the given predicate function `f`.\n///\n/// If the predicate function `f` returns `true` for the value contained in the option,\n/// the same option is returned. Otherwise, `None` is returned.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let x = Some(3)\n///   assert_eq(x.filter(x => x > 5), None)\n///   assert_eq(x.filter(x => x < 5), Some(3))\n/// }\n/// ```\npub fn[T] Option::filter(self : T?, f : (T) -> Bool raise?) -> T? raise? {\n  match self {\n    Some(t) => if f(t) { self } else { None }\n    None => None\n  }\n}\n\n///|\n/// Checks if the option contains a value.\n#deprecated(\"use `x is Some(_)` instead\")\npub fn[T] Option::is_some(self : T?) -> Bool {\n  self is Some(_)\n}\n\n///|\n/// Checks if the option is None.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_none(self : T?) -> Bool {\n  self is None\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// #region type definition and intrinsics\n\n///|\n/// An `ArrayView` represents a view into a section of an array without copying the data.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Creates a view of elements at indices 1,2,3\n///   assert_eq(view[0], 2)\n///   assert_eq(view.length(), 3)\n/// }\n/// ```\n#builtin.valtype\ntype ArrayView[T]\n\n///|\nfn[T] ArrayView::buf(self : ArrayView[T]) -> UninitializedArray[T] = \"%arrayview.buf\"\n\n///|\nfn[T] ArrayView::start(self : ArrayView[T]) -> Int = \"%arrayview.start\"\n\n///|\nfn[T] ArrayView::len(self : ArrayView[T]) -> Int = \"%arrayview.len\"\n\n///|\nfn[T] ArrayView::make(\n  buf : UninitializedArray[T],\n  start : Int,\n  len : Int,\n) -> ArrayView[T] = \"%arrayview.make\"\n\n// #endregion\n\n// #region methods\n\n///|\n/// Returns the length (number of elements) of an array view.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect(view.length(), content=\"2\")\n/// }\n/// ```\npub fn[T] ArrayView::length(self : ArrayView[T]) -> Int {\n  self.len()\n}\n\n///|\n/// Returns whether the array view is empty.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3][:]\n///   inspect(view.is_empty(), content=\"false\")\n///   let empty = [1, 2][0:0]\n///   inspect(empty.is_empty(), content=\"true\")\n/// }\n/// ```\npub fn[T] ArrayView::is_empty(self : ArrayView[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\npub fn[T] ArrayView::start_offset(self : Self[T]) -> Int {\n  self.start()\n}\n\n///|\n/// Retrieves an element at the specified index from the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to access.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array view).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect(view[0], content=\"3\")\n///   inspect(view[1], content=\"4\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] ArrayView::at(self : ArrayView[T], index : Int) -> T {\n  guard index >= 0 && index < self.len() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.len()} but the index is \\{index}\",\n    )\n  }\n  self.buf()[self.start() + index]\n}\n\n///|\n/// Retrieves an element from the array view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect(view.get(0), content=\"Some(2)\")\n///   inspect(view.get(1), content=\"Some(3)\")\n///   inspect(view.get(2), content=\"Some(4)\")\n///   inspect(view.get(5), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::get(self : ArrayView[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.buf()[self.start() + index])\n}\n\n///|\n/// Returns the last element of the array view, if any.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3][:]\n///   inspect(view.last(), content=\"Some(3)\")\n///   let empty = [1, 2][0:0]\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::last(self : ArrayView[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    Some(self.unsafe_get(len - 1))\n  }\n}\n\n///|\n/// Retrieves an element from the array view at the specified index without\n/// performing bounds checking.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect(view.unsafe_get(1), content=\"3\")\n/// }\n/// ```\n#intrinsic(\"%arrayview.unsafe_get\")\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] ArrayView::unsafe_get(self : ArrayView[T], index : Int) -> T {\n  self.buf()[self.start() + index]\n}\n\n///|\n/// Creates a view of a portion of the array. The view provides read-write access\n/// to the underlying array without copying the elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws a panic if the indices are invalid (i.e., `start` is negative, `end`\n/// is greater than the array length, or `start` is greater than `end`).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Create a view of elements at indices 1, 2, and 3\n///   inspect(view[0], content=\"2\") // First element of view is arr[1]\n///   inspect(view.length(), content=\"3\") // View contains 3 elements\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] Array::sub(\n  self : Array[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(self.buffer(), start, end - start)\n}\n\n///|\n/// Creates a new view into a portion of the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to create a new view from.\n/// * `start` : The starting index in the current view (inclusive). Defaults to\n/// 0.\n/// * `end` : The ending index in the current view (exclusive). Defaults to the\n/// length of the current view.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original array view. The indices are relative to the start of the\n/// current view.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the current view\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   let subview = view[1:2] // subview = [3]\n///   inspect(subview[0], content=\"3\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] ArrayView::sub(\n  self : ArrayView[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(self.buf(), self.start() + start, end - start)\n}\n\n///|\nfn[T] unsafe_cast_fixedarray_to_uninitializedarray(\n  arr : FixedArray[T],\n) -> UninitializedArray[T] = \"%identity\"\n\n///|\n/// Creates a new `ArrayView` from a `FixedArray`.\n///\n/// Parameters:\n///\n/// * `self` : The fixed array to create a new view from.\n/// * `start` : The starting index in the array (inclusive). Defaults to 0.\n/// * `end` : The ending index in the array (exclusive). Defaults to the\n/// length of the array.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original fixed array.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the array\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   inspect(view[0], content=\"2\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] FixedArray::sub(\n  self : FixedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(\n    unsafe_cast_fixedarray_to_uninitializedarray(self),\n    start,\n    end - start,\n  )\n}\n\n///|\npub fn[T] ArrayView::suffixes(\n  self : Self[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  let len = self.length()\n  let mut i = 0\n  Iter::new(fn() -> ArrayView[T]? {\n    if i < len {\n      let suffix = self[i:]\n      i += 1\n      Some(suffix)\n    } else if i == len {\n      i += 1\n      if include_empty {\n        Some(self[len:])\n      } else {\n        None\n      }\n    } else {\n      None\n    }\n  })\n}\n\n///|\n/// Returns an iterator that yields each element of the array view in sequence\n/// from start to end.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to iterate over.\n///\n/// Returns an iterator that yields elements of type `A` from the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   let mut sum = 0\n///   view.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"5\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[X] ArrayView::iter(self : ArrayView[X]) -> Iter[X] {\n  let mut i = 0\n  Iter::new(fn() {\n    guard i < self.length() else { None }\n    let elem = self.unsafe_get(i)\n    i += 1\n    Some(elem)\n  })\n}\n\n///|\n#alias(rev_iterator, deprecated)\npub fn[X] ArrayView::rev_iter(self : ArrayView[X]) -> Iter[X] {\n  let mut i = self.length()\n  Iter::new(fn() {\n    guard i > 0 else { None }\n    i -= 1\n    Some(self.unsafe_get(i))\n  })\n}\n\n///|\n/// Returns an iterator that yields tuples of index and value\n/// indices start from 0.\n/// \n/// Example:\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   let mut sum = 0\n///   let mut sum_keys = 0\n///   view\n///   .iter2()\n///   .each((i, x) => {\n///     sum = sum + x\n///     sum_keys = sum_keys + i\n///   })\n///   inspect(sum, content=\"5\")\n///   inspect(sum_keys, content=\"1\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[X] ArrayView::iter2(self : ArrayView[X]) -> Iter2[Int, X] {\n  let mut i = 0\n  Iter2::new(fn() {\n    guard i < self.length() else { None }\n    let result = Some((i, self.unsafe_get(i)))\n    i += 1\n    result\n  })\n}\n\n///|\n/// Iterates over each element in the array view and applies a function to it.\n///\n/// Parameters:\n///\n/// * `self` : The array view to iterate over.\n/// * `function` : A function that takes an element of type `T` and returns\n/// nothing. This function will be applied to each element in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3][:]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\npub fn[T] ArrayView::each(\n  self : ArrayView[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array view with index.\n///\n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5][:]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[T] ArrayView::eachi(\n  self : ArrayView[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks if all elements in the array view match the condition.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let v = [1, 4, 6, 8, 9]\n///   assert_false(v[:].all(elem => elem % 2 == 0))\n///   assert_true(v[1:4].all(elem => elem % 2 == 0))\n/// }\n/// ```\n#alias(every)\npub fn[T] ArrayView::all(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  for v in self {\n    if !f(v) {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Check if any of the elements in the array view match the condition.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5][:]\n///   assert_true(v.any(ele => ele < 6))\n///   assert_false(v.any(ele => ele < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] ArrayView::any(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  for v in self {\n    if f(v) {\n      return true\n    }\n  }\n  false\n}\n\n///|\n/// Checks whether the array view contains a specific element by comparing each\n/// element with the target value using the equality operator.\n///\n/// Parameters:\n///\n/// * `view` : The array view to search in.\n/// * `target` : The value to search for in the array view.\n///\n/// Returns a boolean value indicating whether the target value exists in the\n/// array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5][:]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::contains(self : ArrayView[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 2, 4][:]\n///   inspect(view.search(2), content=\"Some(1)\")\n///   inspect(view.search(5), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::search(self : ArrayView[T], value : T) -> Int? {\n  for i in 0..<self.length() {\n    if self.unsafe_get(i) == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Checks if the array view starts with the given prefix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5][:]\n///   inspect(view.starts_with([1, 2][:]), content=\"true\")\n///   inspect(view.starts_with([2, 3][:]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::starts_with(\n  self : ArrayView[T],\n  prefix : ArrayView[T],\n) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Checks if the array view ends with the given suffix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5][:]\n///   inspect(view.ends_with([4, 5][:]), content=\"true\")\n///   inspect(view.ends_with([3, 4][:]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::ends_with(\n  self : ArrayView[T],\n  suffix : ArrayView[T],\n) -> Bool {\n  let suffix_len = suffix.length()\n  let self_len = self.length()\n  if suffix_len > self_len {\n    return false\n  }\n  for i in 0..<suffix_len {\n    if self.unsafe_get(self_len - suffix_len + i) != suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 3, 5, 7, 9][:]\n///   inspect(view.binary_search(5), content=\"Ok(2)\")\n///   inspect(view.binary_search(6), content=\"Err(3)\")\n/// }\n/// ```\npub fn[T : Compare] ArrayView::binary_search(\n  self : ArrayView[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search using a custom comparison function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 3, 5, 7, 9][:]\n///   let result = view.binary_search_by(x => x.compare(5))\n///   inspect(result, content=\"Ok(2)\")\n/// }\n/// ```\n#locals(cmp)\npub fn[T] ArrayView::binary_search_by(\n  self : ArrayView[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ArrayView::fold(\n  self : ArrayView[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules in reversed turn.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].rev_fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ArrayView::rev_fold(\n  self : ArrayView[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].foldi(init=0, (index, sum, _elem) => sum + index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] ArrayView::foldi(\n  self : ArrayView[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules in reversed turn with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].rev_foldi(init=0, (index, sum, _elem) => sum +\n///     index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] ArrayView::rev_foldi(\n  self : ArrayView[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Maps a function over the elements of the array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v[1:].map(x => x + 1)\n///   assert_eq(v2, [5, 6])\n/// }\n/// ```\npub fn[T, U] ArrayView::map(\n  self : ArrayView[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  Array::makei(self.length(), i => f(self[i]))\n}\n\n///|\n/// Maps a function over the elements of the array view with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v[1:].mapi((i, x) => x + i)\n///   assert_eq(v2, [4, 6])\n/// }\n/// ```\npub fn[T, U] ArrayView::mapi(\n  self : ArrayView[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  Array::makei(self.length(), i => f(i, self[i]))\n}\n\n///|\n/// Filters the array view with a predicate function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5, 6]\n///   let v = arr[2:].filter(x => x % 2 == 0)\n///   assert_eq(v, [4, 6])\n/// }\n/// ```\npub fn[T] ArrayView::filter(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Copy the view elements to a new array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5, 6][2:4]\n///   let arr = view.to_array()\n///   assert_eq(arr, [3, 4])\n/// }\n/// ```\npub fn[T] ArrayView::to_array(self : ArrayView[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    for i, v in self {\n      arr[i] = v\n    }\n    arr\n  }\n}\n\n///|\n/// Concatenate strings within an array into a single complete string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a : Array[String] = [\"1\", \"2\", \"3\"]\n///   let array_view = a[:]\n///   inspect(array_view.join(\",\"), content=\"1,2,3\")\n/// }\n/// ```\npub fn[A : ToStringView] ArrayView::join(\n  self : ArrayView[A],\n  separator : StringView,\n) -> String {\n  match self {\n    [] => \"\"\n    [hd, .. tl] => {\n      let hd = hd.to_string_view()\n      let mut size_hint = hd.length()\n      for s in tl {\n        size_hint += s.to_string_view().length() + separator.length()\n      }\n      size_hint = size_hint << 1\n      let buf = StringBuilder::new(size_hint~)\n      // buf.write_string(hd)\n      buf.write_view(hd)\n      if separator is \"\" {\n        for s in tl {\n          // buf.write_string(s)\n          let s = s.to_string_view()\n          buf.write_view(s)\n        }\n      } else {\n        for s in tl {\n          let s = s.to_string_view()\n          buf.write_view(separator)\n          // buf.write_string(s)\n          buf.write_view(s)\n        }\n      }\n      buf.to_string()\n    }\n  }\n}\n\n// #endregion\n\n// #region trait impls\n\n///|\npub impl[X : Show] Show for ArrayView[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[T : Eq] Eq for ArrayView[T] with equal(self, other) -> Bool {\n  if self.length() != other.length() {\n    return false\n  }\n  for i in 0..<self.length() {\n    if !(self[i] == other[i]) {\n      return false\n    }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Compare] Compare for ArrayView[T] with compare(self, other) -> Int {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp == 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self[i].compare(other[i])\n    guard cmp == 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\npub impl[A : Hash] Hash for ArrayView[A] with hash_combine(self, hasher) {\n  for e in self {\n    hasher.combine(e)\n  }\n}\n\n// #endregion\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] ReadOnlyArray::unsafe_reinterpret_to_fixed_array(\n  self : ReadOnlyArray[T],\n) -> FixedArray[T] = \"%identity\"\n\n///|\nfn[T] unsafe_reinterpret_from_fixed_array(\n  arr : FixedArray[T],\n) -> ReadOnlyArray[T] = \"%identity\"\n\n///|\n#alias(\"_[_]\")\npub fn[T] ReadOnlyArray::at(self : ReadOnlyArray[T], index : Int) -> T {\n  self.unsafe_reinterpret_to_fixed_array()[index]\n}\n\n///|\n/// Creates an ReadOnlyArray from a dynamic Array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let dynamic_array = [1, 2, 3, 4, 5]\n///   let immut_array = ReadOnlyArray::from_array(dynamic_array)\n///   inspect(immut_array[0], content=\"1\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::from_array(array : ArrayView[T]) -> ReadOnlyArray[T] {\n  unsafe_reinterpret_from_fixed_array(FixedArray::from_array(array))\n}\n\n///|\n/// Creates an ReadOnlyArray from an iterator.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let iter = [1, 2, 3].iter()\n///   let immut_array = ReadOnlyArray::from_iter(iter)\n///   inspect(immut_array[0], content=\"1\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] ReadOnlyArray::from_iter(iter : Iter[T]) -> ReadOnlyArray[T] {\n  unsafe_reinterpret_from_fixed_array(FixedArray::from_iter(iter))\n}\n\n///|\n/// Creates an ReadOnlyArray by applying a function to each index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let immut_array = ReadOnlyArray::makei(3, fn(i) { i * 2 })\n///   inspect(immut_array[1], content=\"2\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::makei(\n  length : Int,\n  value : (Int) -> T raise?,\n) -> ReadOnlyArray[T] raise? {\n  unsafe_reinterpret_from_fixed_array(FixedArray::makei(length, value))\n}\n\n///|\n/// Safely retrieves an element at the specified index.\n/// Returns Some(element) if the index is valid, None otherwise.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.get(1), content=\"Some(2)\")\n///   inspect(arr.get(5), content=\"None\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::get(self : ReadOnlyArray[T], index : Int) -> T? {\n  self.unsafe_reinterpret_to_fixed_array().get(index)\n}\n\n///|\n/// Returns the length of the ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::length(self : ReadOnlyArray[T]) -> Int {\n  self.unsafe_reinterpret_to_fixed_array().length()\n}\n\n///|\n/// Checks if the ReadOnlyArray is empty.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let empty_arr : ReadOnlyArray[Int] = []\n///   inspect(empty_arr.is_empty(), content=\"true\")\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::is_empty(self : ReadOnlyArray[T]) -> Bool {\n  self.unsafe_reinterpret_to_fixed_array().is_empty()\n}\n\n///|\n/// Returns the last element of the ReadOnlyArray, if any.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.last(), content=\"Some(3)\")\n///   let empty_arr : ReadOnlyArray[Int] = []\n///   inspect(empty_arr.last(), content=\"None\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::last(self : ReadOnlyArray[T]) -> T? {\n  self.unsafe_reinterpret_to_fixed_array().last()\n}\n\n///|\n/// Creates an iterator over the elements of the ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each(fn(x) { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[T] ReadOnlyArray::iter(self : ReadOnlyArray[T]) -> Iter[T] {\n  self.unsafe_reinterpret_to_fixed_array().iter()\n}\n\n///|\n/// Creates an iterator that yields both indices and values.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each(fn(i, x) { sum = sum + i + x })\n///   inspect(sum, content=\"63\") // (0+10) + (1+20) + (2+30) = 63\n/// }\n/// ```\npub fn[T] ReadOnlyArray::iter2(self : ReadOnlyArray[T]) -> Iter2[Int, T] {\n  self.unsafe_reinterpret_to_fixed_array().iter2()\n}\n\n///|\n/// Iterates over each element in the ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let result = []\n///   arr.each(fn(x) { result.push(x * 2) })\n///   inspect(result, content=\"[2, 4, 6]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::each(\n  self : ReadOnlyArray[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().each(f)\n}\n\n///|\n/// Iterates over each element with its index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let result = []\n///   arr.eachi(fn(i, x) { result.push((i, x)) })\n///   inspect(result, content=\"[(0, 10), (1, 20), (2, 30)]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::eachi(\n  self : ReadOnlyArray[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().eachi(f)\n}\n\n///|\n/// Iterates over each element in reverse order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let result = []\n///   arr.rev_each(fn(x) { result.push(x) })\n///   inspect(result, content=\"[3, 2, 1]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::rev_each(\n  self : ReadOnlyArray[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_each(f)\n}\n\n///|\n/// Iterates over each element in reverse order with its index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let result = []\n///   arr.rev_eachi(fn(i, x) { result.push((i, x)) })\n///   inspect(result, content=\"[(0, 30), (1, 20), (2, 10)]\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::rev_eachi(\n  self : ReadOnlyArray[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_eachi(f)\n}\n\n///|\n/// Creates a new ReadOnlyArray by applying a function to each element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let doubled = arr.map(fn(x) { x * 2 })\n///   inspect(doubled[0], content=\"2\")\n///   inspect(doubled[2], content=\"6\")\n/// }\n/// ```\npub fn[T, U] ReadOnlyArray::map(\n  self : ReadOnlyArray[T],\n  f : (T) -> U raise?,\n) -> ReadOnlyArray[U] raise? {\n  unsafe_reinterpret_from_fixed_array(\n    self.unsafe_reinterpret_to_fixed_array().map(f),\n  )\n}\n\n///|\n/// Creates a new ReadOnlyArray by applying a function to each element with its index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [10, 20, 30]\n///   let result = arr.mapi(fn(i, x) { i + x })\n///   inspect(result[1], content=\"21\") // index 1 + value 20 = 21\n/// }\n/// ```\npub fn[T, U] ReadOnlyArray::mapi(\n  self : ReadOnlyArray[T],\n  f : (Int, T) -> U raise?,\n) -> ReadOnlyArray[U] raise? {\n  unsafe_reinterpret_from_fixed_array(\n    self.unsafe_reinterpret_to_fixed_array().mapi(f),\n  )\n}\n\n///|\n/// Folds the ReadOnlyArray from left to right.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let sum = arr.fold(init=0, fn(acc, x) { acc + x })\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::fold(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().fold(init~, f)\n}\n\n///|\n/// Folds the ReadOnlyArray from right to left.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   let result = arr.rev_fold(init=\"\", fn(acc, x) { acc + x.to_string() })\n///   inspect(result, content=\"321\") // Processed in reverse order\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::rev_fold(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_fold(init~, f)\n}\n\n///|\n/// Folds the ReadOnlyArray from left to right with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [2, 3]\n///   let sum = arr.foldi(init=0, fn(i, acc, x) { acc + i * x })\n///   inspect(sum, content=\"3\") // 0 + (0*2) + (1*3) = 3\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::foldi(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().foldi(init~, f)\n}\n\n///|\n/// Folds the ReadOnlyArray from right to left with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [2, 3]\n///   let sum = arr.rev_foldi(init=0, fn(i, acc, x) { acc + i * x })\n///   inspect(sum, content=\"2\") // 0 + (1*3) + (0*2) = 3\n/// }\n/// ```\npub fn[A, B] ReadOnlyArray::rev_foldi(\n  self : ReadOnlyArray[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  self.unsafe_reinterpret_to_fixed_array().rev_foldi(init~, f)\n}\n\n///|\n/// Returns a new ReadOnlyArray with elements in reverse order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let reversed = arr.rev()\n///   inspect(reversed[0], content=\"5\")\n///   inspect(reversed[4], content=\"1\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::rev(self : ReadOnlyArray[T]) -> ReadOnlyArray[T] {\n  unsafe_reinterpret_from_fixed_array(\n    self.unsafe_reinterpret_to_fixed_array().rev(),\n  )\n}\n\n///|\n/// Searches for an element and returns its index if found.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // Returns first occurrence\n///   inspect(arr.search(5), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::search(\n  self : ReadOnlyArray[T],\n  value : T,\n) -> Int? {\n  self.unsafe_reinterpret_to_fixed_array().search(value)\n}\n\n///|\n/// Checks if the ReadOnlyArray contains a specific value.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.contains(2), content=\"true\")\n///   inspect(arr.contains(4), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::contains(\n  self : ReadOnlyArray[T],\n  value : T,\n) -> Bool {\n  self.unsafe_reinterpret_to_fixed_array().contains(value)\n}\n\n///|\n/// Checks if the ReadOnlyArray is sorted in non-decreasing order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr.is_sorted(), content=\"true\")\n///   let arr2 : ReadOnlyArray[Int] = [2, 1]\n///   inspect(arr2.is_sorted(), content=\"false\")\n/// }\n/// ```\npub fn[T : Compare] ReadOnlyArray::is_sorted(self : ReadOnlyArray[T]) -> Bool {\n  self.unsafe_reinterpret_to_fixed_array().is_sorted()\n}\n\n///|\n/// Checks if the ReadOnlyArray starts with the given prefix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let prefix : ReadOnlyArray[Int] = [1, 2]\n///   inspect(arr.starts_with(prefix), content=\"true\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::starts_with(\n  self : ReadOnlyArray[T],\n  prefix : ReadOnlyArray[T],\n) -> Bool {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .starts_with(prefix.unsafe_reinterpret_to_fixed_array())\n}\n\n///|\n/// Checks if the ReadOnlyArray ends with the given suffix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let suffix : ReadOnlyArray[Int] = [4, 5]\n///   inspect(arr.ends_with(suffix), content=\"true\")\n/// }\n/// ```\npub fn[T : Eq] ReadOnlyArray::ends_with(\n  self : ReadOnlyArray[T],\n  suffix : ReadOnlyArray[T],\n) -> Bool {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .ends_with(suffix.unsafe_reinterpret_to_fixed_array())\n}\n\n///|\n/// Checks if all elements satisfy the given predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [2, 4, 6]\n///   inspect(arr.all(fn(x) { x % 2 == 0 }), content=\"true\")\n///   let arr2 : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr2.all(fn(x) { x % 2 == 0 }), content=\"false\")\n/// }\n/// ```\n#alias(every)\npub fn[T] ReadOnlyArray::all(\n  self : ReadOnlyArray[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  self.unsafe_reinterpret_to_fixed_array().all(f)\n}\n\n///|\n/// Checks if any element satisfies the given predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 3, 5]\n///   inspect(arr.any(fn(x) { x % 2 == 0 }), content=\"false\")\n///   let arr2 : ReadOnlyArray[Int] = [1, 2, 3]\n///   inspect(arr2.any(fn(x) { x % 2 == 0 }), content=\"true\")\n/// }\n/// ```\n#alias(exists)\npub fn[T] ReadOnlyArray::any(\n  self : ReadOnlyArray[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  self.unsafe_reinterpret_to_fixed_array().any(f)\n}\n\n///|\n/// Performs binary search on a sorted ReadOnlyArray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 3, 5, 7, 9]\n///   inspect(arr.binary_search(5), content=\"Ok(2)\")\n///   inspect(arr.binary_search(6), content=\"Err(3)\")\n/// }\n/// ```\npub fn[T : Compare] ReadOnlyArray::binary_search(\n  self : ReadOnlyArray[T],\n  value : T,\n) -> Result[Int, Int] {\n  self.unsafe_reinterpret_to_fixed_array().binary_search(value)\n}\n\n///|\n/// Performs binary search using a custom comparison function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 3, 5, 7, 9]\n///   let result = arr.binary_search_by(fn(x) { x.compare(5) })\n///   inspect(result, content=\"Ok(2)\")\n/// }\n/// ```\npub fn[T] ReadOnlyArray::binary_search_by(\n  self : ReadOnlyArray[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self.unsafe_reinterpret_to_fixed_array().binary_search_by(cmp)\n}\n\n///|\n/// Creates a view of a subarray.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[Int] = [1, 2, 3, 4, 5]\n///   let view = arr.sub(start=1, end=4)\n///   inspect(view[0], content=\"2\")\n///   inspect(view[2], content=\"4\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn[T] ReadOnlyArray::sub(\n  self : ReadOnlyArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  match end {\n    None => self.unsafe_reinterpret_to_fixed_array().sub(start~)\n    Some(e) => self.unsafe_reinterpret_to_fixed_array().sub(start~, end=e)\n  }\n}\n\n///|\n/// Joins string elements with a separator.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr : ReadOnlyArray[String] = [\"hello\", \"world\", \"moon\"]\n///   inspect(arr.join(\",\"), content=\"hello,world,moon\")\n///   inspect(arr.join(\" \"), content=\"hello world moon\")\n/// }\n/// ```\npub fn ReadOnlyArray::join(\n  self : ReadOnlyArray[String],\n  separator : StringView,\n) -> String {\n  self.unsafe_reinterpret_to_fixed_array().join(separator)\n}\n\n///|\n/// Default implementation for ReadOnlyArray - returns empty array.\npub impl[T] Default for ReadOnlyArray[T] with default() {\n  unsafe_reinterpret_from_fixed_array(FixedArray::default())\n}\n\n///|\n/// Show implementation for ReadOnlyArray.\npub impl[T : Show] Show for ReadOnlyArray[T] with output(self, logger) {\n  self.unsafe_reinterpret_to_fixed_array().output(logger)\n}\n\n///|\n/// ToJson implementation for ReadOnlyArray.\npub impl[T : ToJson] ToJson for ReadOnlyArray[T] with to_json(self) {\n  self.unsafe_reinterpret_to_fixed_array().to_json()\n}\n\n///|\npub impl[T : Eq] Eq for ReadOnlyArray[T] with equal(self, other) {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .equal(other.unsafe_reinterpret_to_fixed_array())\n}\n\n///|\npub impl[T : Hash] Hash for ReadOnlyArray[T] with hash_combine(self, hasher) {\n  self.unsafe_reinterpret_to_fixed_array().hash_combine(hasher)\n}\n\n///|\npub impl[T : Compare] Compare for ReadOnlyArray[T] with compare(self, other) {\n  self\n  .unsafe_reinterpret_to_fixed_array()\n  .compare(other.unsafe_reinterpret_to_fixed_array())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Maps the value of a Result if it is `Ok` into another, otherwise returns the `Err` value unchanged.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, Unit] = Ok(6)\n///   let y = x.map((v : Int) => v * 7)\n///   assert_eq(y, Ok(42))\n/// }\n/// ```\npub fn[T, E, U] Result::map(self : Result[T, E], f : (T) -> U) -> Result[U, E] {\n  match self {\n    Ok(value) => Ok(f(value))\n    Err(err) => Err(err)\n  }\n}\n\n///|\ntest \"map\" {\n  let x : Result[Int, Unit] = Ok(6)\n  let y = x.map((v : Int) => v * 7)\n  let z : Result[Int, Int] = Err(3)\n  let w = z.map((v : Int) => v * 7)\n  assert_eq(y, Ok(42))\n  assert_eq(w, Err(3))\n}\n\n///|\n/// Maps the value of a Result if it is `Err` into another, otherwise returns the `Ok` value unchanged.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Err(\"error\")\n///   let y = x.map_err((v : String) => v + \"!\")\n///   assert_eq(y, Err(\"error!\"))\n/// }\n/// ```\npub fn[T, E, F] Result::map_err(\n  self : Result[T, E],\n  f : (E) -> F,\n) -> Result[T, F] {\n  match self {\n    Ok(value) => Ok(value)\n    Err(err) => Err(f(err))\n  }\n}\n\n///|\ntest \"map_err\" {\n  let x : Result[Int, String] = Err(\"error\")\n  let y = x.map_err((v : String) => v + \"!\")\n  let z : Result[Int, Int] = Ok(6)\n  let w = z.map_err((v : Int) => v + 6)\n  assert_eq(y, Err(\"error!\"))\n  assert_eq(w, Ok(6))\n}\n\n///|\n/// Return the contained `Ok` value or the provided default.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(3)\n///   let y : Result[Int, String] = Err(\"error\")\n///   assert_eq(x.unwrap_or(5), 3)\n///   assert_eq(y.unwrap_or(5), 5)\n/// }\n/// ```\n#alias(or)\npub fn[T, E] Result::unwrap_or(self : Result[T, E], default : T) -> T {\n  match self {\n    Ok(value) => value\n    Err(_) => default\n  }\n}\n\n///|\ntest \"unwrap_or\" {\n  let x : Result[Int, String] = Ok(3)\n  let y : Result[Int, String] = Err(\"error\")\n  assert_eq(x.unwrap_or(5), 3)\n  assert_eq(y.unwrap_or(5), 5)\n}\n\n///|\n/// Return the contained `Ok` value or the provided default.\n///\n/// Default is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(3)\n///   let y : Result[Int, String] = Err(\"error\")\n///   assert_eq(x.unwrap_or_else(() => 5), 3)\n///   assert_eq(y.unwrap_or_else(() => 5), 5)\n/// }\n/// ```\n#alias(or_else)\npub fn[T, E] Result::unwrap_or_else(\n  self : Result[T, E],\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    Ok(value) => value\n    Err(_) => default()\n  }\n}\n\n///|\ntest \"unwrap_or_else\" {\n  let x : Result[Int, String] = Ok(3)\n  let y : Result[Int, String] = Err(\"error\")\n  assert_eq(x.unwrap_or_else(() => 5), 3)\n  assert_eq(y.unwrap_or_else(() => 5), 5)\n}\n\n///|\n/// Flatten a `Result` of `Result` into a single `Result`.\n///\n/// If the outer `Result` is an `Ok`, the inner `Result` is returned. If the outer `Result` is an `Err`, the inner `Result` is ignored and the `Err` is returned.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Result[Int, String], String] = Ok(Ok(6))\n///   let y = x.flatten()\n///   assert_eq(y, Ok(6))\n/// }\n/// ```\npub fn[T, E] Result::flatten(self : Result[Result[T, E], E]) -> Result[T, E] {\n  match self {\n    Ok(value) => value\n    Err(err) => Err(err)\n  }\n}\n\n///|\ntest \"flatten\" {\n  let x : Result[Result[Int, String], String] = Ok(Ok(6))\n  let y = x.flatten()\n  let z : Result[Result[Int, String], String] = Err(\"error\")\n  let w = z.flatten()\n  assert_eq(y, Ok(6))\n  assert_eq(w, Err(\"error\"))\n}\n\n///|\n/// Binds a result to a function that returns another result.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(6)\n///   let y = x.bind((v : Int) => Ok(v * 7))\n///   assert_eq(y, Ok(42))\n/// }\n/// ```\npub fn[T, E, U] Result::bind(\n  self : Result[T, E],\n  g : (T) -> Result[U, E],\n) -> Result[U, E] {\n  match self {\n    Ok(value) => g(value)\n    Err(err) => Err(err)\n  }\n}\n\n///|\ntest \"bind\" {\n  let x : Result[Int, String] = Ok(6)\n  let y = x.bind((v : Int) => Ok(v * 7))\n  assert_eq(y, Ok(42))\n}\n\n///|\n/// Converts a `Result` to an `Option`.\n///\n/// Converts `Ok` to `Some` and `Err` to `None`.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let x : Result[Int, String] = Ok(6)\n///   let y = x.to_option()\n///   assert_eq(y, Some(6))\n/// }\n/// ```\npub fn[T, E] Result::to_option(self : Result[T, E]) -> T? {\n  match self {\n    Ok(value) => Some(value)\n    Err(_) => None\n  }\n}\n\n///|\ntest \"to_option\" {\n  let x : Result[Int, String] = Ok(6)\n  let y : Result[Int, String] = Err(\"error\")\n  let z = x.to_option()\n  let w = y.to_option()\n  assert_eq(z, Some(6))\n  assert_eq(w, None)\n}\n\n///|\npub impl[T : Compare, E : Compare] Compare for Result[T, E] with compare(\n  self : Result[T, E],\n  other : Result[T, E],\n) -> Int {\n  match (self, other) {\n    (Ok(x), Ok(y)) => x.compare(y)\n    (Ok(_), Err(_)) => -1\n    (Err(_), Ok(_)) => 1\n    (Err(x), Err(y)) => x.compare(y)\n  }\n}\n\n///|\ntest \"compare\" {\n  let ok1 = Result::Ok(1)\n  let ok2 = Result::Ok(2)\n  let err1 = Result::Err(1)\n  let err2 = Result::Err(2)\n  assert_eq(0, ok1.compare(ok1))\n  assert_eq(0, err2.compare(Result::Err(2)))\n  assert_eq(-1, ok1.compare(ok2))\n  assert_eq(1, ok2.compare(ok1))\n  assert_eq(-1, err1.compare(err2))\n  assert_eq(1, err2.compare(err1))\n  assert_eq(-1, ok2.compare(err1))\n  assert_eq(1, err1.compare(ok2))\n}\n\n///|\npub fn[T, E] Result::unwrap(self : Result[T, E]) -> T {\n  match self {\n    Ok(x) => x\n    Err(_) => abort(\"called `Result::unwrap()` on an `Err` value\")\n  }\n}\n\n///|\n/// Extracts the error value from a `Result[T, E]`. If the `Result` is `Ok`,\n/// aborts with a runtime error message.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to extract the error from.\n///\n/// Returns the error value of type `E` if `self` is `Err(e)`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : Result[Int, String] = Err(\"error message\")\n///   inspect(err.unwrap_err(), content=\"error message\")\n/// }\n/// ```\npub fn[T, E] Result::unwrap_err(self : Result[T, E]) -> E {\n  match self {\n    Ok(_) => abort(\"called `Result::unwrap_err()` on an `Ok` value\")\n    Err(e) => e\n  }\n}\n\n///|\ntest \"show\" {\n  let ok : Result[_, String] = Ok(\"hello\")\n  inspect(\n    ok,\n    content=(\n      #|Ok(\"hello\")\n    ),\n  )\n  let err : Result[String, _] = Err(\"world\")\n  inspect(\n    err,\n    content=(\n      #|Err(\"world\")\n    ),\n  )\n}\n\n///|\n/// Return the contained `Ok` value or the result of the `T::default()`.\npub fn[T : Default, E] Result::unwrap_or_default(self : Result[T, E]) -> T {\n  match self {\n    Ok(value) => value\n    Err(_) => T::default()\n  }\n}\n\n///|\ntest \"unwrap_or_default\" {\n  let x : Result[Int, String] = Ok(3)\n  let y : Result[Int, String] = Err(\"error\")\n  assert_eq(x.unwrap_or_default(), 3)\n  assert_eq(y.unwrap_or_default(), 0)\n}\n\n///|\npub fn[T, E : Error] Result::unwrap_or_error(self : Result[T, E]) -> T raise E {\n  match self {\n    Ok(x) => x\n    Err(e) => raise e\n  }\n}\n\n///|\ntest \"unwrap exn\" {\n  (try\n    (Err(Failure(\"This is serious\")) : Result[Unit, Failure]).unwrap_or_error()\n    |> Ok\n  catch {\n    Failure(msg) => Err(msg)\n  })\n  |> inspect(\n    content=(\n      #|Err(\"This is serious\")\n    ),\n  )\n}\n\n///|\npub impl[T : Eq, E : Eq] Eq for Result[T, E] with equal(self, other) {\n  match (self, other) {\n    (Ok(x), Ok(y)) => x == y\n    (Err(x), Err(y)) => x == y\n    _ => false\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub fn Byte::to_hex(b : Byte) -> String {\n  fn to_hex_digit(i : Byte) -> Char {\n    if i < 10 {\n      (i + '0').to_char()\n    } else {\n      (i + 'a' - 10).to_char()\n    }\n  }\n\n  [to_hex_digit(b / 16), to_hex_digit(b % 16)]\n}\n\n///|\ntest \"to_hex_digit\" {\n  inspect(Byte::to_hex(b'\\xee'), content=\"ee\")\n  inspect(Byte::to_hex(b'\\xf3'), content=\"f3\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          // has to be ascii  \n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_string(code.to_byte().to_hex())\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// External iterator type.\n/// `Iterator[X]` is a mutable type: iterators internally maintain mutable state\n/// to advance iteration.\n/// All read operations on `Iterator` will advance the iterator,\n/// and would give different result when called multiple times.\n#alias(Iterator, deprecated=\"The name `Iterator` is deprecated, use `Iter` instead. Note that if you have defined `iterator()` method to support `for .. in` loop, you should also rename `iterator()` to `iter()`. See https://github.com/moonbitlang/core/pull/3127 for more details.\")\nstruct Iter[X](() -> X?)\n\n///|\n/// Get the next element from an iterator, or return `None` if no more element exists.\n/// The returned element will be consumed from the iterator.\n/// Calling `next` repeatedly will iterate through all elements in the iterator.\n#alias(peek, deprecated)\n#alias(head)\npub fn[X] Iter::next(self : Iter[X]) -> X? {\n  (self.0)()\n}\n\n///|\n#locals(f)\n#deprecated(\"write a loop instead.\")\npub fn[X] Iter::run(self : Iter[X], f : (X) -> IterResult) -> IterResult {\n  while self.next() is Some(x) {\n    guard f(x) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  }\n}\n\n///|\n#deprecated(\"write a loop instead.\")\npub fn[X] Iter::just_run(self : Iter[X], f : (X) -> IterResult) -> Unit {\n  while self.next() is Some(x) {\n    if f(x) is IterEnd {\n      break\n    }\n  }\n}\n\n///|\npub impl[X : Show] Show for Iter[X] with output(self, logger) {\n  logger.write_string(\"[\")\n  if self.next() is Some(x) {\n    logger.write_object(x)\n    while self.next() is Some(x) {\n      logger.write_string(\", \")\n      logger.write_object(x)\n    }\n  }\n  logger.write_string(\"]\")\n}\n\n///|\npub impl[X : ToJson] ToJson for Iter[X] with to_json(self) {\n  Json::array(self.map(_.to_json()).collect())\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an element of type `X` and returns `Unit`. This function is applied to each element of the iterator.\n#locals(f)\npub fn[X] Iter::each(self : Iter[X], f : (X) -> Unit raise?) -> Unit raise? {\n  while self.next() is Some(x) {\n    f(x)\n  }\n}\n\n///|\n#locals(f)\npub fn[X] Iter::any(self : Iter[X], f : (X) -> Bool) -> Bool {\n  while self.next() is Some(x) {\n    if f(x) {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n#locals(f)\npub fn[X] Iter::all(self : Iter[X], f : (X) -> Bool) -> Bool {\n  while self.next() is Some(x) {\n    guard f(x) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element with index.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an index of type `Int` and an element of type `X` and returns `Unit`. This function is applied to each element of the iterator.\n#locals(f)\npub fn[X] Iter::eachi(\n  self : Iter[X],\n  f : (Int, X) -> Unit raise?,\n) -> Unit raise? {\n  let mut i = 0\n  while self.next() is Some(x) {\n    f(i, x)\n    i += 1\n  }\n}\n\n///|\n/// Folds the elements of the iterator using the given function, starting with the given initial value.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `R`: The type of the accumulator (result) value.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an accumulator of type `R` and an element of type `X`, and returns a new accumulator value.\n/// - `init`: The initial value for the fold operation.\n///\n/// # Returns\n///\n/// Returns the final accumulator value after folding all elements of the iterator.\n#locals(f)\npub fn[X, R] Iter::fold(\n  self : Iter[X],\n  init~ : R,\n  f : (R, X) -> R raise?,\n) -> R raise? {\n  let mut acc = init\n  while self.next() is Some(x) {\n    acc = f(acc, x)\n  }\n  acc\n}\n\n///|\n/// Counts the number of elements in the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n///\n/// # Returns\n///\n/// Returns the number of elements in the iterator.\npub fn[X] Iter::count(self : Iter[X]) -> Int {\n  self.fold((acc, _) => acc + 1, init=0)\n}\n\n// Producers\n\n///|\n/// Create a new iterator by supplying a `next` function directly.\n/// The supplied function should output the next element being iterated\n/// everytime it is called.\n///\n/// This function is intended for use by data structure authors,\n/// and should not be called by end users in general.\npub fn[X] Iter::new(f : () -> X?) -> Iter[X] {\n  Iter(f)\n}\n\n///|\n/// Creates an empty iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Returns\n///\n/// Returns an empty iterator of type `Iter[X]`.\npub fn[X] Iter::empty() -> Iter[X] {\n  () => None\n}\n\n///|\n/// Creates an iterator that contains a single element.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the element in the iterator.\n///\n/// # Arguments\n///\n/// - `elem`: The single element to be contained in the iterator.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[X]` that contains the single element `a`.\npub fn[X] Iter::singleton(elem : X) -> Iter[X] {\n  let mut consumed = false\n  fn() {\n    if consumed {\n      None\n    } else {\n      consumed = true\n      Some(elem)\n    }\n  }\n}\n\n///|\n/// Creates an iterator that repeats the given element indefinitely.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `x`: The element to be repeated.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[X]` that repeats the element `x` indefinitely.\npub fn[X] Iter::repeat(x : X) -> Iter[X] {\n  () => Some(x)\n}\n\n///|\n/// Filters the elements of the iterator based on a predicate function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be included in the filtered iterator.\n///\n/// # Returns\n///\n/// A new iterator that only contains the elements for which the predicate function returns `IterContinue`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `filter`.\npub fn[X] Iter::filter(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  fn() {\n    while self.next() is Some(x) {\n      if f(x) {\n        break Some(x)\n      }\n    } else {\n      None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `map`.\npub fn[X, Y] Iter::map(self : Iter[X], f : (X) -> Y) -> Iter[Y] {\n  fn() {\n    match self.next() {\n      Some(x) => Some(f(x))\n      None => None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator with index.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `mapi`.\npub fn[X, Y] Iter::mapi(self : Iter[X], f : (Int, X) -> Y) -> Iter[Y] {\n  let mut i = 0\n  fn() {\n    match self.next() {\n      Some(x) => {\n        let result = f(i, x)\n        i += 1\n        Some(result)\n      }\n      None => None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function that returns an `Option`.\n/// The elements for which the function returns `None` are filtered out.\n///\n/// The old iterator `self` must not be used again after calling `filter_map`.\npub fn[X, Y] Iter::filter_map(self : Iter[X], f : (X) -> Y?) -> Iter[Y] {\n  fn() {\n    while self.next() is Some(x) {\n      match f(x) {\n        Some(_) as y => break y\n        None => ()\n      }\n    } else {\n      None\n    }\n  }\n}\n\n///|\n/// Transforms each element of the iterator into an iterator and flattens the resulting iterators into a single iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function that transforms each element of the iterator into an iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the flattened elements.\n///\n/// # Note\n/// The old iterator `self` and the iterators returned by `f`\n/// must not be used again after calling `flat_map`.\npub fn[X, Y] Iter::flat_map(self : Iter[X], f : (X) -> Iter[Y]) -> Iter[Y] {\n  let mut current_iter = Some(Iter::empty())\n  fn() {\n    guard current_iter is Some(iter) else { None }\n    loop iter.next() {\n      Some(_) as elem => elem\n      None => {\n        guard self.next() is Some(x) else { None }\n        let iter = f(x)\n        current_iter = Some(iter)\n        continue iter.next()\n      }\n    }\n  }\n}\n\n///|\n/// `iter.map(f).flatten() == iter.flat_map(f)`\npub fn[X] Iter::flatten(self : Iter[Iter[X]]) -> Iter[X] {\n  self.flat_map(it => it)\n}\n\n///|\n/// Collects the elements of the iterator into a string.\n/// The old iterator `self` must not be used again after calling `join`.\npub fn Iter::join(self : Iter[String], sep : String) -> String {\n  let result = StringBuilder::new()\n  if self.next() is Some(x) {\n    result.write_string(x)\n    while self.next() is Some(x) {\n      result.write_string(sep)\n      result.write_string(x)\n    }\n  }\n  result.to_string()\n}\n\n///|\n/// Applies a function to each element of the iterator without modifying the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function to apply to each element of the iterator.\n///\n/// # Returns\n///\n/// The same iterator.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `tap`.\npub fn[X] Iter::tap(self : Iter[X], f : (X) -> Unit) -> Iter[X] {\n  fn() {\n    let result = self.next()\n    if result is Some(x) {\n      f(x)\n    }\n    result\n  }\n}\n\n///|\n/// Takes the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to take.\n///\n/// # Returns\n///\n/// A new iterator that contains the first `n` elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `take`.\npub fn[X] Iter::take(self : Iter[X], n : Int) -> Iter[X] {\n  let mut remaining = n\n  fn() {\n    guard remaining > 0 else { None }\n    let result = self.next()\n    if result is Some(_) {\n      remaining -= 1\n    }\n    result\n  }\n}\n\n///|\n/// Takes elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be taken.\n///\n/// # Returns\n///\n/// A new iterator that contains the elements as long as the predicate function returns `true`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `take_while`.\npub fn[X] Iter::take_while(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  let mut still_running = true\n  fn() {\n    guard still_running else { None }\n    let result = self.next()\n    if result is Some(x) && !f(x) {\n      still_running = false\n      None\n    } else {\n      result\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function upto the function returns `None`.\n/// The old iterator `self` must not be used again after calling `map_while`.\npub fn[X, Y] Iter::map_while(self : Iter[X], f : (X) -> Y?) -> Iter[Y] {\n  let mut still_running = true\n  fn() {\n    guard still_running else { None }\n    let src = self.next()\n    guard src is Some(x) else { None }\n    let result = f(x)\n    if result is None {\n      still_running = false\n    }\n    result\n  }\n}\n\n///|\n/// Skips the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to skip.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the first `n` elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `drop`.\npub fn[X] Iter::drop(self : Iter[X], n : Int) -> Iter[X] {\n  let mut remaining = n\n  fn() {\n    while remaining > 0 {\n      guard self.next() is Some(_) else { break None }\n      remaining -= 1\n    } else {\n      self.next()\n    }\n  }\n}\n\n///|\n/// Skips elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be skipped.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the elements as long as the predicate function returns `true`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `drop_while`.\npub fn[X] Iter::drop_while(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  let mut dropped = false\n  fn() {\n    if !dropped {\n      dropped = true\n      loop self.next() {\n        Some(x) if f(x) => continue self.next()\n        result => result\n      }\n    } else {\n      self.next()\n    }\n  }\n}\n\n///|\n/// Finds the first element in the iterator that satisfies the predicate function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element is the first element to be found.\n///\n/// # Returns\n///\n/// An `Option` that contains the first element that satisfies the predicate function, or `None` if no such element is found.\n///\n/// # Note\n/// The iterator `self` will advance past the returned element.\npub fn[X] Iter::find_first(self : Iter[X], f : (X) -> Bool) -> X? {\n  while self.next() is Some(x) {\n    if f(x) {\n      break Some(x)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Combines two iterators into one by appending the elements of the second iterator to the first.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterators.\n///\n/// # Arguments\n///\n/// * `self` - The first input iterator.\n/// * `other` - The second input iterator to be appended to the first.\n///\n/// # Returns\n///\n/// Returns a new iterator that contains the elements of `self` followed by the elements of `other`.\n///\n/// # Note\n/// The old iterator `self` and `other` must not be used again after calling `tap`.\npub fn[X] Iter::concat(self : Iter[X], other : Iter[X]) -> Iter[X] {\n  let mut in_first = true\n  fn() {\n    if in_first {\n      let result = self.next()\n      if result is None {\n        in_first = false\n        other.next()\n      } else {\n        result\n      }\n    } else {\n      other.next()\n    }\n  }\n}\n\n///|\npub impl[T] Add for Iter[T] with add(self, other) {\n  self.concat(other)\n}\n\n///|\n/// Collects the elements of the iterator into an array.\n/// The old iterator `self` must not be used again.\n#alias(collect)\npub fn[X] Iter::to_array(self : Iter[X]) -> Array[X] {\n  let result = []\n  while self.next() is Some(x) {\n    result.push(x)\n  }\n  result\n}\n\n///|\n#alias(iterator)\npub fn[X] Iter::iter(self : Iter[X]) -> Iter[X] {\n  self\n}\n\n///|\n#alias(iterator2)\npub fn[X] Iter::iter2(self : Iter[X]) -> Iter2[Int, X] {\n  let mut i = 0\n  Iter(() => {\n    guard self.next() is Some(elem) else { None }\n    let result = Some((i, elem))\n    i += 1\n    result\n  })\n}\n\n///|\n/// Returns the last element of the iterator, or `None` if the iterator is empty.\n/// The old iterator `self` must not be used again after calling `last`.\npub fn[X] Iter::last(self : Iter[X]) -> X? {\n  loop (None, self.next()) {\n    (last, None) => last\n    (_, Some(_) as x) => continue (x, self.next())\n  }\n}\n\n///|\n/// Inserts a separator element `sep` between each element of the iterator.\n///\n/// # Parameters\n///\n/// - `self` : The iterator to intersperse the separator into.\n/// - `sep` : The separator element to insert between each element of the iterator.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3].iter().intersperse(0).each(i => arr.push(i))\n///   assert_eq(arr, [1, 0, 2, 0, 3])\n/// }\n/// ```\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `intersperse`.\npub fn[X] Iter::intersperse(self : Iter[X], sep : X) -> Iter[X] {\n  enum State {\n    Init\n    Output_Elem(X)\n    Output_Sep\n  }\n  let mut state = Init\n  fn() {\n    match state {\n      Init => {\n        let result = self.next()\n        state = Output_Sep\n        result\n      }\n      Output_Elem(x) => {\n        state = Output_Sep\n        Some(x)\n      }\n      Output_Sep =>\n        // make sure we only output the separator when there is remaining element\n        match self.next() {\n          Some(x) => {\n            state = Output_Elem(x)\n            Some(sep)\n          }\n          None => None\n        }\n    }\n  }\n}\n\n///|\n#alias(\"_[_:_]\")\npub fn[X] Iter::sub(self : Iter[X], start? : Int = 0, end? : Int) -> Iter[X] {\n  match (start, end) {\n    (_..=0, None) => self\n    (_..=0, Some(end)) => self.take(end)\n    (start, None) => self.drop(start)\n    (start, Some(end)) => {\n      let mut index = 0\n      fn() {\n        if index >= end {\n          return None\n        }\n        while index < start {\n          guard self.next() is Some(_) else { return None }\n          index += 1\n        }\n        if index >= end {\n          return None\n        }\n        let result = self.next()\n        if result is Some(_) {\n          index += 1\n        }\n        result\n      }\n    }\n  }\n}\n\n///|\n/// Checks if the iterator contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `self` : The iterator to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the iterator contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = [1, 2, 3, 4, 5].iter()\n///   inspect(iter.contains(3), content=\"true\")\n///   inspect(iter.contains(6), content=\"false\")\n///   let iter = Iter::empty()\n///   inspect(iter.contains(1), content=\"false\")\n/// }\n/// ```\n///\n/// # Note\n/// The old iterator `self` will advance past the searched element.\npub fn[X : Eq] Iter::contains(self : Iter[X], value : X) -> Bool {\n  while self.next() is Some(x) {\n    if x == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Returns the nth element of the iterator, or `None` if the iterator is\n/// shorter than `n` elements.\n/// The iterator `self` will advance past the returned element.\npub fn[X] Iter::nth(self : Iter[X], n : Int) -> X? {\n  guard n >= 0 else { None }\n  for i = 0; i < n; i = i + 1 {\n    guard self.next() is Some(_) else { break None }\n  } else {\n    self.next()\n  }\n}\n\n///|\npub fn[X : Compare] Iter::maximum(self : Iter[X]) -> X? {\n  guard self.next() is Some(x) else { return None }\n  let mut res = x\n  while self.next() is Some(x) {\n    if x > res {\n      res = x\n    }\n  }\n  Some(res)\n}\n\n///|\npub fn[X : Compare] Iter::minimum(self : Iter[X]) -> X? {\n  guard self.next() is Some(x) else { return None }\n  let mut res = x\n  while self.next() is Some(x) {\n    if x < res {\n      res = x\n    }\n  }\n  Some(res)\n}\n\n///|\n/// This type is used for `for _, _ in ..` loop\n/// (`for .. in` loop with two loop variables),\n/// and should not be used directly in general.\n#alias(Iterator2, deprecated=\"The name `Iterator2` is deprecated, use `Iter2` instead. Note that if you have defined `iterator2()` method to support `for .. in` loop, you should also rename `iterator2()` to `iter2()`. See https://github.com/moonbitlang/core/pull/3127 for more details.\")\npub(all) struct Iter2[X, Y](Iter[(X, Y)])\n\n///|\npub fn[X, Y] Iter2::new(f : () -> (X, Y)?) -> Iter2[X, Y] {\n  Iter2(Iter::new(f))\n}\n\n///|\n#alias(iterator)\npub fn[X, Y] Iter2::iter(self : Iter2[X, Y]) -> Iter[(X, Y)] {\n  self.0\n}\n\n///|\n#alias(iterator2)\npub fn[X, Y] Iter2::iter2(self : Iter2[X, Y]) -> Iter2[X, Y] {\n  self\n}\n\n///|\npub fn[X, Y] Iter2::next(self : Iter2[X, Y]) -> (X, Y)? {\n  self.0.next()\n}\n\n///|\npub impl[X : Show, Y : Show] Show for Iter2[X, Y] with output(self, logger) {\n  self.0.output(logger)\n}\n\n///|\npub fn[X, Y] Iter2::run(\n  self : Iter2[X, Y],\n  f : (X, Y) -> IterResult,\n) -> IterResult {\n  while self.0.next() is Some((x, y)) {\n    guard f(x, y) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  }\n}\n\n///|\npub fn[X, Y] Iter2::each(self : Iter2[X, Y], f : (X, Y) -> Unit) -> Unit {\n  self.0.each(pair => f(pair.0, pair.1))\n}\n\n///|\npub fn[X, Y] Iter2::concat(\n  self : Iter2[X, Y],\n  other : Iter2[X, Y],\n) -> Iter2[X, Y] {\n  Iter2(self.0.concat(other.0))\n}\n\n///|\npub fn[X, Y] Iter2::to_array(self : Iter2[X, Y]) -> Array[(X, Y)] {\n  self.0.to_array()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder {\n  mut data : FixedArray[Byte]\n  mut len : Int\n}\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  let initial = if size_hint < 1 { 1 } else { size_hint }\n  let data : FixedArray[Byte] = FixedArray::make(initial, 0)\n  { data, len: 0 }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.len == 0\n}\n\n///|\nfn StringBuilder::grow_if_necessary(\n  self : StringBuilder,\n  required : Int,\n) -> Unit {\n  let current_len = self.data.length()\n  if required <= current_len {\n    return\n  }\n  // current_len is at least 1\n  let mut enough_space = current_len\n  // double the enough_space until it larger than required\n  while enough_space < required {\n    enough_space = enough_space * 2\n  }\n  let new_data = FixedArray::make(enough_space, Byte::default())\n  new_data.unsafe_blit(0, self.data, 0, self.len)\n  self.data = new_data\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(self.len, str, 0, str.length())\n  self.len += str.length() * 2\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.grow_if_necessary(self.len + 4)\n  let inc = self.data.set_utf16le_char(self.len, ch)\n  self.len += inc\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sb = StringBuilder::new()\n///   sb.write_view(\"Hello, world!\"[:5])\n///   assert_eq(sb.to_string(), \"Hello\")\n/// }\n/// ```\npub impl Logger for StringBuilder with write_view(\n  self : StringBuilder,\n  str : StringView,\n) -> Unit {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(\n    self.len,\n    str.data(),\n    str.start_offset(),\n    str.length(),\n  )\n  self.len += str.length() * 2\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.data\n  .unsafe_reinterpret_as_bytes()\n  .to_unchecked_string(offset=0, length=self.len)\n}\n\n///|\n/// TODO: improve perf\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(\n    self.data\n    .unsafe_reinterpret_as_bytes()\n    .to_unchecked_string(offset=0, length=self.len),\n  )\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.len = 0\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `suberror` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : Failure = Failure(\"Test assertion failed\")\n///   match err {\n///     Failure(msg) => inspect(msg, content=\"Test assertion failed\")\n///   }\n///   @json.inspect(err, content=[\"Failure\", \"Test assertion failed\"])\n/// }\n/// ```\npub(all) suberror Failure String derive(ToJson, Show)\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise Failure {\n  raise Failure(\"\\{loc} FAILED: \\{msg}\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#cfg(not(target=\"js\"))\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\n#cfg(not(target=\"js\"))\nfn unsafe_fixedarray_uint16_to_string(buffer : FixedArray[UInt16]) -> String = \"%string.unsafe_from_uint16_fixedarray\"\n\n//==========================================\n// Int and UInt (Non JS)\n//==========================================\n\n///|\n/// Converts an unsigned 32-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFU).reinterpret_as_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFU).reinterpret_as_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36\n#cfg(not(target=\"js\"))\nfn int_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.reinterpret_as_uint()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1U\n    while n > 0U {\n      offset = offset - 1\n      let digit = n.land(mask).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0U {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 32-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000U {\n    let t = num / 10000U\n    let r = (num % 10000U).reinterpret_as_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.reinterpret_as_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Calculates the number of decimal digits in a u32 value\n#cfg(not(target=\"js\"))\nfn dec_count32(value : UInt) -> Int {\n  // Binary search: split 1-10 digits into halves\n  if value >= 100000U { // >= 10^5 means 6+ digits\n    if value >= 10000000U { // >= 10^7 means 8+ digits\n      if value >= 1000000000U { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000U { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000U { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000U { // >= 10^3 means 4+ digits\n    if value >= 10000U { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100U { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10U { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u32 value\n#cfg(not(target=\"js\"))\nfn hex_count32(value : UInt) -> Int {\n  if value == 0U {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (31 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u32 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count32(value : UInt, radix : Int) -> Int {\n  if value == 0U {\n    return 1\n  }\n  let mut num = value\n  let base = radix.reinterpret_as_uint()\n  let mut count = 0\n  while num > 0U {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n/// Example:\n/// ```\n/// inspect((255).to_string(radix=16), content=\"ff\")\n/// inspect((-255).to_string(radix=16), content=\"-ff\")\n/// ```\n#cfg(not(target=\"js\"))\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0 {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0\n  let num : UInt = if is_negative {\n    // Negate and reinterpret as UInt\n    // Works correctly for Int::min_value due to two's complement:\n    // -Int::min_value wraps to itself, then reinterpreting gives 2147483648U\n    (-self).reinterpret_as_uint()\n  } else {\n    self.reinterpret_as_uint()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count32(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0U {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count32(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n//==========================================\n// Int and UInt (JS)\n//==========================================\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  int_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int_to_string_js(i : Int, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return x.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  uint_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint_to_string_js(i : UInt, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return (x >>> 0).toString(radix);\n  #|}\n\n//==========================================\n// Int64 and UInt64\n//==========================================\n\n///|\n/// Calculates the number of decimal digits in a u64 value\n#cfg(not(target=\"js\"))\nfn dec_count64(value : UInt64) -> Int {\n  // Binary search: split 1-20 digits into halves\n  if value >= 10000000000UL { // >= 10^10 means 11+ digits\n    if value >= 100000000000000UL { // >= 10^14 means 15+ digits\n      if value >= 10000000000000000UL { // >= 10^16 means 17+ digits\n        if value >= 1000000000000000000UL { // >= 10^18 means 19+ digits\n          if value >= 10000000000000000000UL { // >= 10^19 means 20 digits\n            20\n          } else {\n            19\n          }\n        } else if value >= 100000000000000000UL { // >= 10^17 means 18 digits\n          18\n        } else {\n          17\n        }\n      } else if value >= 1000000000000000UL { // >= 10^15 means 16 digits\n        16\n      } else {\n        15\n      }\n    } else if value >= 1000000000000UL { // >= 10^12 means 13+ digits\n      if value >= 10000000000000UL { // >= 10^13 means 14 digits\n        14\n      } else {\n        13\n      }\n    } else if value >= 100000000000UL { // >= 10^11 means 12 digits\n      12\n    } else {\n      11\n    }\n  } else if value >= 100000UL { // >= 10^5 means 6+ digits\n    if value >= 10000000UL { // >= 10^7 means 8+ digits\n      if value >= 1000000000UL { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000UL { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000UL { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000UL { // >= 10^3 means 4+ digits\n    if value >= 10000UL { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100UL { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10UL { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u64 value\n#cfg(not(target=\"js\"))\nfn hex_count64(value : UInt64) -> Int {\n  if value == 0UL {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (63 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u64 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count64(value : UInt64, radix : Int) -> Int {\n  if value == 0UL {\n    return 1\n  }\n  let mut num = value\n  let base = radix.to_uint64()\n  let mut count = 0\n  while num > 0UL {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an unsigned 64-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int64_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFUL).to_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFUL).to_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36 (64-bit)\n#cfg(not(target=\"js\"))\nfn int64_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.to_uint64()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1UL\n    while n > 0UL {\n      offset = offset - 1\n      let digit = n.land(mask).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0UL {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int64_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000UL {\n    let t = num / 10000UL\n    let r = (num % 10000UL).to_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.to_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0L {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0L\n  let num : UInt64 = if is_negative {\n    // Negate and reinterpret as UInt64\n    // Works correctly for Int64::min_value due to two's complement\n    (-self).reinterpret_as_uint64()\n  } else {\n    self.reinterpret_as_uint64()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count64(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0UL {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count64(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  int64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int64_to_string_js(num : Int64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  let val = (BigInt(num.hi >>> 0) << 32n) | BigInt(num.lo >>> 0);\n  #|  if (val & (1n << 63n)) {\n  #|    val = val - (1n << 64n);\n  #|  }\n  #|  return val.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  uint64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint64_to_string_js(num : UInt64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  return (BigInt(num.hi >>> 0) << 32n | BigInt(num.lo >>> 0)).toString(radix);\n  #|}\n\n//==========================================\n// Int16 and UInt16\n//==========================================\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n//==========================================\n// Test cases\n//==========================================\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  equal(Self, Self) -> Bool = _\n  #deprecated(\"use `equal` instead\", skip_current_package=true)\n  op_equal(Self, Self) -> Bool = _\n  not_equal(Self, Self) -> Bool = _\n}\n\n///|\nimpl Eq with not_equal(x, y) {\n  !(x == y)\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n  op_lt(Self, Self) -> Bool = _\n  op_gt(Self, Self) -> Bool = _\n  op_le(Self, Self) -> Bool = _\n  op_ge(Self, Self) -> Bool = _\n}\n\n///|\nimpl Compare with op_lt(x, y) {\n  x.compare(y).is_neg()\n}\n\n///|\nimpl Compare with op_gt(x, y) {\n  x.compare(y).is_pos()\n}\n\n///|\nimpl Compare with op_le(x, y) {\n  x.compare(y).is_non_pos()\n}\n\n///|\nimpl Compare with op_ge(x, y) {\n  x.compare(y).is_non_neg()\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit = _\n  #deprecated(\"use `write_view` instead\", skip_current_package=true)\n  write_substring(Self, String, Int, Int) -> Unit = _\n  write_view(Self, StringView) -> Unit = _\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_substring(self, value, start, len) {\n  self.write_view(try! value[start:start + len])\n}\n\n///|\nimpl Logger with write_string(self, value) {\n  self.write_view(value[:])\n}\n\n///|\n#deprecated(\"replace `impl write_substring` with `impl write_view`\")\nimpl Logger with write_view(self, value) {\n  self.write_substring(value.data(), value.start_offset(), value.length())\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n/// Default implementation for `Show::to_string`, uses a `StringBuilder`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n\n///|\n#deprecated(\"replace `impl op_equal` with `impl equal`\")\nimpl Eq with equal(self, other) {\n  Eq::op_equal(self, other)\n}\n\n///|\nimpl Eq with op_equal(self, other) {\n  Eq::equal(self, other)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the source string being viewed.\nfn StringView::str(self : StringView) -> String = \"%stringview.str\"\n\n///|\n/// Returns the starting UTF-16 code unit index into the string.\nfn StringView::start(self : StringView) -> Int = \"%stringview.start\"\n\n///|\n/// Returns the ending UTF-16 code unit index into the string (not included).\nfn StringView::end(self : StringView) -> Int = \"%stringview.end\"\n\n///|\nfn StringView::make_view(str : String, start : Int, end : Int) -> StringView = \"%stringview.make\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn StringView::at(self : StringView, index : Int) -> UInt16 {\n  guard index >= 0 && index < self.length() else {\n    abort(\"Index out of bounds\")\n  }\n  self.str().code_unit_at(self.start() + index)\n}\n\n///|\n/// Returns the length of the view.\n/// \n/// This method counts the charcodes(code unit) in the view and has O(1) complexity.\npub fn StringView::length(self : StringView) -> Int {\n  self.end() - self.start()\n}\n\n///|\n/// Iterates over all suffixes of the view, advancing by a Unicode character at\n/// a time. Each yielded suffix is itself a view into the original string.\npub fn StringView::suffixes(\n  self : StringView,\n  include_empty? : Bool = false,\n) -> Iter[StringView] {\n  let str = self.str()\n  let end = self.end()\n  let mut next_start = self.start()\n  let mut finished = false\n  Iter::new(fn() -> StringView? {\n    if finished {\n      None\n    } else if next_start == end {\n      finished = true\n      if include_empty {\n        Some(StringView::make_view(str, next_start, end))\n      } else {\n        None\n      }\n    } else {\n      let suffix = StringView::make_view(str, next_start, end)\n      let code = str.unsafe_charcode_at(next_start)\n      if code.is_leading_surrogate() &&\n        next_start + 1 < end &&\n        str.unsafe_charcode_at(next_start + 1).is_trailing_surrogate() {\n        next_start += 2\n      } else {\n        next_start += 1\n      }\n      Some(suffix)\n    }\n  })\n}\n\n///|\n/// Returns the original string that is being viewed.\npub fn StringView::data(self : StringView) -> String {\n  self.str()\n}\n\n///|\n/// Returns the starting offset (in UTF-16 code units) of this view into its\n/// underlying string.\npub fn StringView::start_offset(self : StringView) -> Int {\n  self.start()\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn StringView::view(\n  self : StringView,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(\n    self.str(),\n    self.start() + start_offset,\n    self.start() + end_offset,\n  )\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\n/// #Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"BC\"\n///   let view = str[:]\n///   inspect(view.unsafe_charcode_at(0), content=\"66\")\n///   inspect(view.unsafe_charcode_at(1), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(2), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(3), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(4), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(5), content=\"67\")\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\npub fn StringView::unsafe_charcode_at(self : StringView, index : Int) -> Int {\n  self.str().unsafe_charcode_at(self.start() + index)\n}\n\n///|\n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn StringView::char_length(self : StringView) -> Int {\n  self.str().char_length(start_offset=self.start(), end_offset=self.end())\n}\n\n///|\npub impl Show for StringView with output(self, logger) {\n  let substr = self.str().unsafe_substring(start=self.start(), end=self.end())\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello World\"\n///   let view = str.view(\n///     start_offset=str.offset_of_nth_char(0).unwrap(),\n///     end_offset=str.offset_of_nth_char(5).unwrap(),\n///   ) // \"Hello\"\n///   inspect(view.to_string(), content=\"Hello\")\n/// }\n/// ```\npub impl Show for StringView with to_string(self) {\n  // when `self == self.str()`, `String::unsafe_substring` would return original string, which doesn't create a new copy.\n  self.str().unsafe_substring(start=self.start(), end=self.end())\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\n#alias(iterator, deprecated)\npub fn StringView::iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  Iter::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        index += 2\n        return Some(code_point_of_surrogate_pair(c1, c2))\n      }\n    }\n    index += 1\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn StringView::iter2(self : StringView) -> Iter2[Int, Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  let mut char_index = 0\n  Iter2::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let result = (char_index, code_point_of_surrogate_pair(c1, c2))\n        index += 2\n        char_index += 1\n        return Some(result)\n      }\n    }\n    let result = (char_index, c1.unsafe_to_char())\n    index += 1\n    char_index += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\n#alias(rev_iterator, deprecated)\npub fn StringView::rev_iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = end\n  Iter::new(fn() {\n    guard index > start else { None }\n    index -= 1\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.str().unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2, c1))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for StringView with equal(self, other) {\n  let len = self.length()\n  guard len == other.length() else { return false }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str().unsafe_charcode_at(self.start() + i) ==\n      other.str().unsafe_charcode_at(other.start() + i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Views are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for StringView with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self\n      .str()\n      .unsafe_charcode_at(self.start() + i)\n      .compare(other.str().unsafe_charcode_at(other.start() + i))\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Performs a lexicographical comparison of two string views.\n///\n/// This method compares the views character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one view is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let str = \"abc\"\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=0, end_offset=3)),\n///     content=\"-1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=3)\n///     .lexical_compare(str.view(start_offset=0, end_offset=2)),\n///     content=\"1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=1, end_offset=3)),\n///     content=\"-1\",\n///   )\n/// }\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn StringView::lexical_compare(\n  self : StringView,\n  other : StringView,\n) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let min_len = if self_len < other_len { self_len } else { other_len }\n\n  // Compare character by character up to the minimum length\n  for i in 0..<min_len {\n    let self_char = self.str().unsafe_charcode_at(self.start() + i)\n    let other_char = other.str().unsafe_charcode_at(other.start() + i)\n    let cmp = self_char.compare(other_char)\n    if cmp != 0 {\n      return cmp\n    }\n  }\n\n  // If all characters match up to min_len, the shorter one is lexicographically smaller\n  self_len.compare(other_len)\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello\"\n///   let view1 = str.view()\n///   inspect(view1, content=\"Hello\")\n///   let start_offset = str.offset_of_nth_char(1).unwrap()\n///   let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset~, end_offset~)\n///   inspect(view2, content=\"ello\")\n/// }\n/// ```\npub fn String::view(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(self, start_offset, end_offset)\n}\n\n///|\n/// Convert char array to string view.\npub fn StringView::from_array(chars : ArrayView[Char]) -> StringView {\n  String::from_array(chars)\n}\n\n///|\n/// Convert char iterator to string view.\n#alias(from_iterator, deprecated)\npub fn StringView::from_iter(iter : Iter[Char]) -> StringView {\n  String::from_iter(iter)\n}\n\n///|\npub suberror CreatingViewError {\n  IndexOutOfBounds\n  InvalidIndex\n} derive(Show)\n\n///|\n/// Creates a view of a string with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index (default: 0)\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string (e.g., -1 means last position)\n/// - `end` : Ending UTF-16 code unit index (optional)\n///   - If `None`: extends to the end of the string\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified substring range\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of valid range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n/// let str = \"HelloWorld\"\n/// let view1 =  str[0:5]\n/// inspect(\n///   view1,\n///   content=(\n///     \"Hello\"\n///   ),\n/// )\n/// let view2 = try? str[-5:]\n/// inspect(\n///   view2,\n///   content=(\n///     #|Ok(\"World\")\n///   ),\n/// )\n/// let view3 = try? str[:6]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\n#alias(\"_[_:_]\")\npub fn String::sub(\n  self : String,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { raise IndexOutOfBounds }\n  if start < len && self.unsafe_charcode_at(start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if end < len && self.unsafe_charcode_at(end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self, start, end)\n}\n\n///|\n/// Creates a subview of an existing view with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index relative to this view (default: 0)\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// - `end` : Ending UTF-16 code unit index relative to this view (optional)\n///   - If `None`: extends to the end of this view\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified subrange of this view\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of this view's range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"HelloWorld\"[1:-1] // \"elloWorl\"\n///   let view1 = str[0:6]\n///   inspect(view1, content=\"ello\")\n///   let view2 = str[-2:]\n///   inspect(view2, content=\"rl\")\n///   let view3 = try? str[:5]\n///   inspect(view3, content=\"Err(InvalidIndex)\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn StringView::sub(\n  self : StringView,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let str_len = self.str().length()\n\n  // Calculate absolute positions in the original string\n  let abs_end = match end {\n    None => self.end()\n    Some(end) => if end < 0 { self.end() + end } else { self.start() + end }\n  }\n  let abs_start = if start < 0 {\n    self.end() + start\n  } else {\n    self.start() + start\n  }\n\n  // Validate bounds against the original string\n  guard abs_start >= self.start() &&\n    abs_start <= abs_end &&\n    abs_end <= self.end() else {\n    raise IndexOutOfBounds\n  }\n\n  // Check for surrogate pair boundaries\n  if abs_start < str_len &&\n    self.str().unsafe_charcode_at(abs_start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if abs_end < str_len &&\n    self.str().unsafe_charcode_at(abs_end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self.str(), abs_start, abs_end)\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_eq(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_eq(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_ge(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_ge(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn StringView::offset_of_nth_char(self : StringView, i : Int) -> Int? {\n  if self\n    .str()\n    .offset_of_nth_char(i, start_offset=self.start(), end_offset=self.end())\n    is Some(index) {\n    Some(index - self.start())\n  } else {\n    None\n  }\n}\n\n///|\n/// The empty view of a string\npub impl Default for StringView with default() {\n  \"\"\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn StringView::make(length : Int, value : Char) -> StringView {\n  String::make(length, value)\n}\n\n///|\npub impl ToJson for StringView with to_json(self) {\n  String::to_json(self.to_string())\n}\n\n///|\npub impl Add for StringView with add(self, other) {\n  [..self, ..other]\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[T0 : Eq, T1 : Eq] Eq for (T0, T1) with equal(\n  self : (T0, T1),\n  other : (T0, T1),\n) -> Bool {\n  self.0 == other.0 && self.1 == other.1\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq] Eq for (T0, T1, T2) with equal(\n  self : (T0, T1, T2),\n  other : (T0, T1, T2),\n) -> Bool {\n  self.0 == other.0 && self.1 == other.1 && self.2 == other.2\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq] Eq for (T0, T1, T2, T3) with equal(\n  self : (T0, T1, T2, T3),\n  other : (T0, T1, T2, T3),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n) with equal(self : (T0, T1, T2, T3, T4), other : (T0, T1, T2, T3, T4)) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq, T5 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n) with equal(self : (T0, T1, T2, T3, T4, T5), other : (T0, T1, T2, T3, T4, T5)) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq, T5 : Eq, T6 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n  T6,\n) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6),\n  other : (T0, T1, T2, T3, T4, T5, T6),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq, T5 : Eq, T6 : Eq, T7 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n  T6,\n  T7,\n) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n  T13 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12 &&\n  self.13 == other.13\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n  T13 : Eq,\n  T14 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12 &&\n  self.13 == other.13 &&\n  self.14 == other.14\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n  T13 : Eq,\n  T14 : Eq,\n  T15 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) with equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12 &&\n  self.13 == other.13 &&\n  self.14 == other.14 &&\n  self.15 == other.15\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[A : Show, B : Show] Show for (A, B) with output(self, logger) {\n  let (a, b) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(a)\n  ..write_string(\", \")\n  ..write_object(b)\n  ..write_string(\")\")\n}\n\n///|\npub impl[A : Show, B : Show, C : Show] Show for (A, B, C) with output(\n  self,\n  logger,\n) {\n  let (a, b, c) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(a)\n  ..write_string(\", \")\n  ..write_object(b)\n  ..write_string(\", \")\n  ..write_object(c)\n  ..write_string(\")\")\n}\n\n///|\npub impl[A : Show, B : Show, C : Show, D : Show] Show for (A, B, C, D) with output(\n  self,\n  logger,\n) {\n  let (a, b, c, d) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(a)\n  ..write_string(\", \")\n  ..write_object(b)\n  ..write_string(\", \")\n  ..write_object(c)\n  ..write_string(\", \")\n  ..write_object(d)\n  ..write_string(\")\")\n}\n\n///|\npub impl[A : Show, B : Show, C : Show, D : Show, E : Show] Show for (\n  A,\n  B,\n  C,\n  D,\n  E,\n) with output(self, logger) {\n  let (a, b, c, d, e) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(a)\n  ..write_string(\", \")\n  ..write_object(b)\n  ..write_string(\", \")\n  ..write_object(c)\n  ..write_string(\", \")\n  ..write_object(d)\n  ..write_string(\", \")\n  ..write_object(e)\n  ..write_string(\")\")\n}\n\n///|\npub impl[A : Show, B : Show, C : Show, D : Show, E : Show, F : Show] Show for (\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n) with output(self, logger) {\n  let (a, b, c, d, e, f) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(a)\n  ..write_string(\", \")\n  ..write_object(b)\n  ..write_string(\", \")\n  ..write_object(c)\n  ..write_string(\", \")\n  ..write_object(d)\n  ..write_string(\", \")\n  ..write_object(e)\n  ..write_string(\", \")\n  ..write_object(f)\n  ..write_string(\")\")\n}\n\n///|\npub impl[A : Show, B : Show, C : Show, D : Show, E : Show, F : Show, G : Show] Show for (\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n) with output(self, logger) {\n  let (a, b, c, d, e, f, g) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(a)\n  ..write_string(\", \")\n  ..write_object(b)\n  ..write_string(\", \")\n  ..write_object(c)\n  ..write_string(\", \")\n  ..write_object(d)\n  ..write_string(\", \")\n  ..write_object(e)\n  ..write_string(\", \")\n  ..write_object(f)\n  ..write_string(\", \")\n  ..write_object(g)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7) with output(self, logger) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8) with output(self, logger) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) with output(self, logger) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n  T10 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) with output(\n  self,\n  logger,\n) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\", \")\n  ..write_object(x10)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n  T10 : Show,\n  T11 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) with output(\n  self,\n  logger,\n) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\", \")\n  ..write_object(x10)\n  ..write_string(\", \")\n  ..write_object(x11)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n  T10 : Show,\n  T11 : Show,\n  T12 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) with output(\n  self,\n  logger,\n) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\", \")\n  ..write_object(x10)\n  ..write_string(\", \")\n  ..write_object(x11)\n  ..write_string(\", \")\n  ..write_object(x12)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n  T10 : Show,\n  T11 : Show,\n  T12 : Show,\n  T13 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) with output(\n  self,\n  logger,\n) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\", \")\n  ..write_object(x10)\n  ..write_string(\", \")\n  ..write_object(x11)\n  ..write_string(\", \")\n  ..write_object(x12)\n  ..write_string(\", \")\n  ..write_object(x13)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n  T10 : Show,\n  T11 : Show,\n  T12 : Show,\n  T13 : Show,\n  T14 : Show,\n] Show for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) with output(\n  self,\n  logger,\n) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\", \")\n  ..write_object(x10)\n  ..write_string(\", \")\n  ..write_object(x11)\n  ..write_string(\", \")\n  ..write_object(x12)\n  ..write_string(\", \")\n  ..write_object(x13)\n  ..write_string(\", \")\n  ..write_object(x14)\n  ..write_string(\")\")\n}\n\n///|\npub impl[\n  T0 : Show,\n  T1 : Show,\n  T2 : Show,\n  T3 : Show,\n  T4 : Show,\n  T5 : Show,\n  T6 : Show,\n  T7 : Show,\n  T8 : Show,\n  T9 : Show,\n  T10 : Show,\n  T11 : Show,\n  T12 : Show,\n  T13 : Show,\n  T14 : Show,\n  T15 : Show,\n] Show for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n  T6,\n  T7,\n  T8,\n  T9,\n  T10,\n  T11,\n  T12,\n  T13,\n  T14,\n  T15,\n) with output(self, logger) {\n  let (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15) = self\n  logger\n  ..write_string(\"(\")\n  ..write_object(x0)\n  ..write_string(\", \")\n  ..write_object(x1)\n  ..write_string(\", \")\n  ..write_object(x2)\n  ..write_string(\", \")\n  ..write_object(x3)\n  ..write_string(\", \")\n  ..write_object(x4)\n  ..write_string(\", \")\n  ..write_object(x5)\n  ..write_string(\", \")\n  ..write_object(x6)\n  ..write_string(\", \")\n  ..write_object(x7)\n  ..write_string(\", \")\n  ..write_object(x8)\n  ..write_string(\", \")\n  ..write_object(x9)\n  ..write_string(\", \")\n  ..write_object(x10)\n  ..write_string(\", \")\n  ..write_object(x11)\n  ..write_string(\", \")\n  ..write_object(x12)\n  ..write_string(\", \")\n  ..write_object(x13)\n  ..write_string(\", \")\n  ..write_object(x14)\n  ..write_string(\", \")\n  ..write_object(x15)\n  ..write_string(\")\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\n#alias(\"_[_]\")\npub fn[T] UninitializedArray::at(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\n#alias(\"_[_]=_\")\npub fn[T] UninitializedArray::set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\n#alias(\"_[_:_]\")\npub fn[T] UninitializedArray::sub(\n  self : UninitializedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  self.0.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\n#doc(hidden)\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n\n///|\n#coverage.skip\n#intrinsic(\"%fixedarray.fill\")\n#cfg(not(target=\"js\"))\nfn[T] UninitializedArray::unchecked_fill(\n  self : UninitializedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(not(target=\"native\"))\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\n#cfg(target=\"native\")\nfn println(s : String) -> Unit = \"%println\"\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(target=\"native\")\npub fn[T] abort(msg : String) -> T {\n  println(msg)\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n"],"mappings":"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"}